{"sha": "40bbdffc89edb4c3841a8b23c41d4092206e940c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYmJkZmZjODllZGI0YzM4NDFhOGIyM2M0MWQ0MDkyMjA2ZTk0MGM=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-03-18T01:51:43Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-04-20T10:30:00Z"}, "message": "use span_lint_and_help, cargo dev fmt", "tree": {"sha": "b74ffe7113f09ab4327c53379cbd4e60de3d66cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b74ffe7113f09ab4327c53379cbd4e60de3d66cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40bbdffc89edb4c3841a8b23c41d4092206e940c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40bbdffc89edb4c3841a8b23c41d4092206e940c", "html_url": "https://github.com/rust-lang/rust/commit/40bbdffc89edb4c3841a8b23c41d4092206e940c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40bbdffc89edb4c3841a8b23c41d4092206e940c/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "139e2c6227506d7dc0be8ddff3cfd1fbe818a1a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/139e2c6227506d7dc0be8ddff3cfd1fbe818a1a4", "html_url": "https://github.com/rust-lang/rust/commit/139e2c6227506d7dc0be8ddff3cfd1fbe818a1a4"}], "stats": {"total": 109, "additions": 64, "deletions": 45}, "files": [{"sha": "2238821ab700f36b70520c7b0e0e41b4004a6964", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/40bbdffc89edb4c3841a8b23c41d4092206e940c/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bbdffc89edb4c3841a8b23c41d4092206e940c/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=40bbdffc89edb4c3841a8b23c41d4092206e940c", "patch": "@@ -1,10 +1,6 @@\n-use crate::utils::{\n-    match_type, method_calls, method_chain_args, paths, snippet, snippet_with_applicability, span_lint_and_sugg,\n-};\n+use crate::utils::{match_type, paths, span_lint_and_help};\n use if_chain::if_chain;\n-use rustc::ty;\n-use rustc_errors::Applicability;\n-use rustc_hir::{print, Expr, ExprKind, MatchSource, PatKind, QPath, StmtKind};\n+use rustc_hir::{Expr, ExprKind, MatchSource, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -15,19 +11,26 @@ declare_clippy_lint! {\n     /// **Why is this bad?** The Mutex lock remains held for the whole\n     /// `if let ... else` block and deadlocks.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** This lint does not generate an auto-applicable suggestion.\n     ///\n     /// **Example:**\n     ///\n-    /// ```rust\n-    /// # use std::sync::Mutex;\n-    /// let mutex = Mutex::new(10);\n+    /// ```rust,ignore\n     /// if let Ok(thing) = mutex.lock() {\n     ///     do_thing();\n     /// } else {\n     ///     mutex.lock();\n     /// }\n     /// ```\n+    /// Should be written\n+    /// ```rust,ignore\n+    /// let locked = mutex.lock();\n+    /// if let Ok(thing) = locked {\n+    ///     do_thing(thing);\n+    /// } else {\n+    ///     use_locked(locked);\n+    /// }\n+    /// ```\n     pub IF_LET_MUTEX,\n     correctness,\n     \"locking a `Mutex` in an `if let` block can cause deadlocks\"\n@@ -43,93 +46,92 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n             }) = ex.kind; // if let ... {} else {}\n             if let ExprKind::MethodCall(_, _, ref args) = op.kind;\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if let ty::Adt(_, subst) = ty.kind;\n             if match_type(cx, ty, &paths::MUTEX); // make sure receiver is Mutex\n             if method_chain_names(op, 10).iter().any(|s| s == \"lock\"); // and lock is called\n \n-            let mut suggestion = String::from(&format!(\"if let _ = {} {{\\n\", snippet(cx, op.span, \"_\")));\n-            \n             if arms.iter().any(|arm| if_chain! {\n                 if let ExprKind::Block(ref block, _l) = arm.body.kind;\n                 if block.stmts.iter().any(|stmt| match stmt.kind {\n                     StmtKind::Local(l) => if_chain! {\n                         if let Some(ex) = l.init;\n-                        if let ExprKind::MethodCall(_, _, ref args) = op.kind;\n+                        if let ExprKind::MethodCall(_, _, _) = op.kind;\n                         if method_chain_names(ex, 10).iter().any(|s| s == \"lock\"); // and lock is called\n                         then {\n-                            let ty = cx.tables.expr_ty(&args[0]);\n-                            // // make sure receiver is Result<MutexGuard<...>>\n-                            match_type(cx, ty, &paths::RESULT)\n+                            match_type_method_chain(cx, ex, 5)\n                         } else {\n-                            suggestion.push_str(&format!(\"    {}\\n\", snippet(cx, l.span, \"_\")));\n                             false\n                         }\n                     },\n                     StmtKind::Expr(e) => if_chain! {\n-                        if let ExprKind::MethodCall(_, _, ref args) = e.kind;\n+                        if let ExprKind::MethodCall(_, _, _) = e.kind;\n                         if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n                         then {\n-                            let ty = cx.tables.expr_ty(&args[0]);\n-                            // // make sure receiver is Result<MutexGuard<...>>\n-                            match_type(cx, ty, &paths::RESULT)\n+                            match_type_method_chain(cx, ex, 5)\n                         } else {\n-                            suggestion.push_str(&format!(\"    {}\\n\", snippet(cx, e.span, \"_\")));\n                             false\n                         }\n                     },\n                     StmtKind::Semi(e) => if_chain! {\n-                        if let ExprKind::MethodCall(_, _, ref args) = e.kind;\n+                        if let ExprKind::MethodCall(_, _, _) = e.kind;\n                         if method_chain_names(e, 10).iter().any(|s| s == \"lock\"); // and lock is called\n                         then {\n-                            let ty = cx.tables.expr_ty(&args[0]);\n-                            // // make sure receiver is Result<MutexGuard<...>>\n-                            match_type(cx, ty, &paths::RESULT)\n+                            match_type_method_chain(cx, ex, 5)\n                         } else {\n-                            suggestion.push_str(&format!(\"    {}\\n\", snippet(cx, e.span, \"_\")));\n                             false\n                         }\n                     },\n-                    _ => { suggestion.push_str(&format!(\"     {}\\n\", snippet(cx, stmt.span, \"_\"))); false },\n+                    _ => {\n+                        false\n+                    },\n                 });\n                 then {\n                     true\n                 } else {\n-                    suggestion.push_str(&format!(\"else {}\\n\", snippet(cx, arm.span, \"_\")));\n                     false\n                 }\n             });\n             then {\n-                println!(\"{}\", suggestion);\n-                span_lint_and_sugg(\n+                span_lint_and_help(\n                     cx,\n                     IF_LET_MUTEX,\n                     ex.span,\n-                    \"using a `Mutex` in inner scope of `.lock` call\",\n-                    \"try\",\n-                    format!(\"{:?}\", \"hello\"),\n-                    Applicability::MachineApplicable,\n+                    \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n+                    \"move the lock call outside of the `if let ...` expression\",\n                 );\n             }\n         }\n     }\n }\n \n+/// Return the names of `max_depth` number of methods called in the chain.\n fn method_chain_names<'tcx>(expr: &'tcx Expr<'tcx>, max_depth: usize) -> Vec<String> {\n     let mut method_names = Vec::with_capacity(max_depth);\n-\n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, span, args) = &current.kind {\n+        if let ExprKind::MethodCall(path, _, args) = &current.kind {\n             if args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n             method_names.push(path.ident.to_string());\n-            println!(\"{:?}\", method_names);\n             current = &args[0];\n         } else {\n             break;\n         }\n     }\n-\n     method_names\n }\n+\n+/// Check that lock is called on a `Mutex`.\n+fn match_type_method_chain<'tcx>(cx: &LateContext<'_, '_>, expr: &'tcx Expr<'tcx>, max_depth: usize) -> bool {\n+    let mut current = expr;\n+    for _ in 0..max_depth {\n+        if let ExprKind::MethodCall(_, _, args) = &current.kind {\n+            let ty = cx.tables.expr_ty(&args[0]);\n+            if match_type(cx, ty, &paths::MUTEX) {\n+                return true;\n+            }\n+            current = &args[0];\n+        }\n+    }\n+    false\n+}"}, {"sha": "6088f9b9ef8cd19c02428e2835f1e23ffb52cd01", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40bbdffc89edb4c3841a8b23c41d4092206e940c/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bbdffc89edb4c3841a8b23c41d4092206e940c/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=40bbdffc89edb4c3841a8b23c41d4092206e940c", "patch": "@@ -734,7 +734,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"if_let_mutex\",\n         group: \"correctness\",\n-        desc: \"default lint description\",\n+        desc: \"locking a `Mutex` in an `if let` block can cause deadlocks\",\n         deprecation: None,\n         module: \"if_let_mutex\",\n     },"}, {"sha": "059764e9b21d110b942c5a1b93fe953653773038", "filename": "tests/ui/if_let_mutex.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40bbdffc89edb4c3841a8b23c41d4092206e940c/tests%2Fui%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40bbdffc89edb4c3841a8b23c41d4092206e940c/tests%2Fui%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.rs?ref=40bbdffc89edb4c3841a8b23c41d4092206e940c", "patch": "@@ -2,14 +2,15 @@\n \n use std::sync::Mutex;\n \n-fn do_stuff() {}\n+fn do_stuff<T>(_: T) {}\n fn foo() {\n     let m = Mutex::new(1u8);\n \n-    if let Ok(locked) = m.lock() {\n-        do_stuff();\n+    if let Err(locked) = m.lock() {\n+        do_stuff(locked);\n     } else {\n-        m.lock().unwrap();\n+        let lock = m.lock().unwrap();\n+        do_stuff(lock);\n     };\n }\n "}, {"sha": "84c19ed03d58bbe345434767d2476463e61656e2", "filename": "tests/ui/if_let_mutex.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40bbdffc89edb4c3841a8b23c41d4092206e940c/tests%2Fui%2Fif_let_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40bbdffc89edb4c3841a8b23c41d4092206e940c/tests%2Fui%2Fif_let_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.stderr?ref=40bbdffc89edb4c3841a8b23c41d4092206e940c", "patch": "@@ -0,0 +1,16 @@\n+error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n+  --> $DIR/if_let_mutex.rs:9:5\n+   |\n+LL | /     if let Err(locked) = m.lock() {\n+LL | |         do_stuff(locked);\n+LL | |     } else {\n+LL | |         let lock = m.lock().unwrap();\n+LL | |         do_stuff(lock);\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: `-D clippy::if-let-mutex` implied by `-D warnings`\n+   = help: move the lock call outside of the `if let ...` expression\n+\n+error: aborting due to previous error\n+"}]}