{"sha": "593f6a42d01070c7217c1241e8783b4e908884bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5M2Y2YTQyZDAxMDcwYzcyMTdjMTI0MWU4NzgzYjRlOTA4ODg0YmI=", "commit": {"author": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2014-05-01T14:02:44Z"}, "committer": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2014-05-01T18:10:16Z"}, "message": "BigUint always use u64 as the internal machine unsigned integer\n\nThis change allow a speedup of ~1.5 on shootout-pidigits on a i32\nsystem.  `DoubleBigDigit` is used to abstract the internal\nunsigned integer used in computation to simplity future\narchitecture specialization.\n\n`BigDigit::from_uint` and `BigDigit::to_uint` become\n`BigDigit::from_doublebigdigit` and `BigDigit::to_doublebigdigit`.\n\n[breaking-change]", "tree": {"sha": "794b852209b96896f9812f37ad1595c6410bc4c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/794b852209b96896f9812f37ad1595c6410bc4c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/593f6a42d01070c7217c1241e8783b4e908884bb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/593f6a42d01070c7217c1241e8783b4e908884bb", "html_url": "https://github.com/rust-lang/rust/commit/593f6a42d01070c7217c1241e8783b4e908884bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/593f6a42d01070c7217c1241e8783b4e908884bb/comments", "author": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "239557de6de72748a5c7604081b202d53f7d9ac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/239557de6de72748a5c7604081b202d53f7d9ac9", "html_url": "https://github.com/rust-lang/rust/commit/239557de6de72748a5c7604081b202d53f7d9ac9"}], "stats": {"total": 207, "additions": 41, "deletions": 166}, "files": [{"sha": "5e1bd29e5a6e7d2cdcc3ec616493d16f944ceeb3", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 41, "deletions": 166, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/593f6a42d01070c7217c1241e8783b4e908884bb/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593f6a42d01070c7217c1241e8783b4e908884bb/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=593f6a42d01070c7217c1241e8783b4e908884bb", "patch": "@@ -31,50 +31,43 @@ use std::{i64, u64};\n \n /**\n A `BigDigit` is a `BigUint`'s composing element.\n-\n-A `BigDigit` is half the size of machine word size.\n */\n-#[cfg(target_word_size = \"32\")]\n-pub type BigDigit = u16;\n+pub type BigDigit = u32;\n \n /**\n-A `BigDigit` is a `BigUint`'s composing element.\n-\n-A `BigDigit` is half the size of machine word size.\n+A `DoubleBigDigit` is the internal type used to do the computations.  Its\n+size is the double of the size of `BigDigit`.\n */\n-#[cfg(target_word_size = \"64\")]\n-pub type BigDigit = u32;\n+pub type DoubleBigDigit = u64;\n \n pub static ZERO_BIG_DIGIT: BigDigit = 0;\n static ZERO_VEC: [BigDigit, ..1] = [ZERO_BIG_DIGIT];\n \n pub mod BigDigit {\n     use super::BigDigit;\n+    use super::DoubleBigDigit;\n \n-    #[cfg(target_word_size = \"32\")]\n-    pub static bits: uint = 16;\n-\n-    #[cfg(target_word_size = \"64\")]\n+    // `DoubleBigDigit` size dependent\n     pub static bits: uint = 32;\n \n-    pub static base: uint = 1 << bits;\n-    static lo_mask: uint = (-1 as uint) >> bits;\n+    pub static base: DoubleBigDigit = 1 << bits;\n+    static lo_mask: DoubleBigDigit = (-1 as DoubleBigDigit) >> bits;\n \n     #[inline]\n-    fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    fn get_hi(n: DoubleBigDigit) -> BigDigit { (n >> bits) as BigDigit }\n     #[inline]\n-    fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+    fn get_lo(n: DoubleBigDigit) -> BigDigit { (n & lo_mask) as BigDigit }\n \n-    /// Split one machine sized unsigned integer into two `BigDigit`s.\n+    /// Split one `DoubleBigDigit` into two `BigDigit`s.\n     #[inline]\n-    pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n+    pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n-    /// Join two `BigDigit`s into one machine sized unsigned integer\n+    /// Join two `BigDigit`s into one `DoubleBigDigit`\n     #[inline]\n-    pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n-        (lo as uint) | ((hi as uint) << bits)\n+    pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {\n+        (lo as DoubleBigDigit) | ((hi as DoubleBigDigit) << bits)\n     }\n }\n \n@@ -202,7 +195,8 @@ impl Add<BigUint, BigUint> for BigUint {\n \n         let mut carry = 0;\n         let mut sum: Vec<BigDigit> =  a.data.iter().zip(b.data.iter().chain(zeros)).map(|(ai, bi)| {\n-            let (hi, lo) = BigDigit::from_uint((*ai as uint) + (*bi as uint) + (carry as uint));\n+            let (hi, lo) = BigDigit::from_doublebigdigit(\n+                (*ai as DoubleBigDigit) + (*bi as DoubleBigDigit) + (carry as DoubleBigDigit));\n             carry = hi;\n             lo\n         }).collect();\n@@ -219,8 +213,11 @@ impl Sub<BigUint, BigUint> for BigUint {\n \n         let mut borrow = 0;\n         let diff: Vec<BigDigit> =  a.take(new_len).zip(b).map(|(ai, bi)| {\n-            let (hi, lo) = BigDigit::from_uint(\n-                BigDigit::base + (*ai as uint) - (*bi as uint) - (borrow as uint)\n+            let (hi, lo) = BigDigit::from_doublebigdigit(\n+                BigDigit::base\n+                    + (*ai as DoubleBigDigit)\n+                    - (*bi as DoubleBigDigit)\n+                    - (borrow as DoubleBigDigit)\n             );\n             /*\n             hi * (base) + lo == 1*(base) + ai - bi - borrow\n@@ -274,8 +271,8 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n             let mut carry = 0;\n             let mut prod: Vec<BigDigit> = a.data.iter().map(|ai| {\n-                let (hi, lo) = BigDigit::from_uint(\n-                    (*ai as uint) * (n as uint) + (carry as uint)\n+                let (hi, lo) = BigDigit::from_doublebigdigit(\n+                    (*ai as DoubleBigDigit) * (n as DoubleBigDigit) + (carry as DoubleBigDigit)\n                 );\n                 carry = hi;\n                 lo\n@@ -440,10 +437,10 @@ impl Integer for BigUint {\n             let mut d = Vec::with_capacity(an.len());\n             let mut carry = 0;\n             for elt in an.iter().rev() {\n-                let ai = BigDigit::to_uint(carry, *elt);\n-                let di = ai / (bn as uint);\n+                let ai = BigDigit::to_doublebigdigit(carry, *elt);\n+                let di = ai / (bn as DoubleBigDigit);\n                 assert!(di < BigDigit::base);\n-                carry = (ai % (bn as uint)) as BigDigit;\n+                carry = (ai % (bn as DoubleBigDigit)) as BigDigit;\n                 d.push(di as BigDigit)\n             }\n             d.reverse();\n@@ -515,39 +512,14 @@ impl ToPrimitive for BigUint {\n         })\n     }\n \n-    #[cfg(target_word_size = \"32\")]\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64> {\n-        match self.data.len() {\n-            0 => Some(0),\n-            1 => Some(self.data.as_slice()[0] as u64),\n-            2 => {\n-                Some(BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0]) as u64)\n-            }\n-            3 => {\n-                let n_lo = BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0]) as\n-                    u64;\n-                let n_hi = self.data.as_slice()[2] as u64;\n-                Some((n_hi << 32) + n_lo)\n-            }\n-            4 => {\n-                let n_lo = BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0])\n-                    as u64;\n-                let n_hi = BigDigit::to_uint(self.data.as_slice()[3], self.data.as_slice()[2])\n-                    as u64;\n-                Some((n_hi << 32) + n_lo)\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    #[cfg(target_word_size = \"64\")]\n+    // `DoubleBigDigit` size dependent\n     #[inline]\n     fn to_u64(&self) -> Option<u64> {\n         match self.data.len() {\n             0 => Some(0),\n             1 => Some(self.data.as_slice()[0] as u64),\n-            2 => Some(BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0]) as u64),\n+            2 => Some(BigDigit::to_doublebigdigit(self.data.as_slice()[1], self.data.as_slice()[0])\n+                      as u64),\n             _ => None\n         }\n     }\n@@ -565,26 +537,10 @@ impl FromPrimitive for BigUint {\n         }\n     }\n \n-    #[cfg(target_word_size = \"32\")]\n-    #[inline]\n-    fn from_u64(n: u64) -> Option<BigUint> {\n-        let n_lo = (n & 0x0000_0000_FFFF_FFFF) as uint;\n-        let n_hi = (n >> 32) as uint;\n-\n-        let n = match (BigDigit::from_uint(n_hi), BigDigit::from_uint(n_lo)) {\n-            ((0,  0),  (0,  0))  => Zero::zero(),\n-            ((0,  0),  (0,  n0)) => BigUint::new(vec!(n0)),\n-            ((0,  0),  (n1, n0)) => BigUint::new(vec!(n0, n1)),\n-            ((0,  n2), (n1, n0)) => BigUint::new(vec!(n0, n1, n2)),\n-            ((n3, n2), (n1, n0)) => BigUint::new(vec!(n0, n1, n2, n3)),\n-        };\n-        Some(n)\n-    }\n-\n-    #[cfg(target_word_size = \"64\")]\n+    // `DoubleBigDigit` size dependent\n     #[inline]\n     fn from_u64(n: u64) -> Option<BigUint> {\n-        let n = match BigDigit::from_uint(n as uint) {\n+        let n = match BigDigit::from_doublebigdigit(n) {\n             (0,  0)  => Zero::zero(),\n             (0,  n0) => BigUint::new(vec!(n0)),\n             (n1, n0) => BigUint::new(vec!(n0, n1))\n@@ -650,8 +606,8 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base(self, base).as_slice(), radix, max_len);\n \n-        fn convert_base(n: &BigUint, base: uint) -> Vec<BigDigit> {\n-            let divider    = FromPrimitive::from_uint(base).unwrap();\n+        fn convert_base(n: &BigUint, base: DoubleBigDigit) -> Vec<BigDigit> {\n+            let divider    = base.to_biguint().unwrap();\n             let mut result = Vec::new();\n             let mut m      = n.clone();\n             while m >= divider {\n@@ -709,7 +665,7 @@ impl BigUint {\n     /// Creates and initializes a `BigUint`.\n     pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n-        let base_num = match FromPrimitive::from_uint(base) {\n+        let base_num = match base.to_biguint() {\n             Some(base_num) => base_num,\n             None => { return None; }\n         };\n@@ -756,8 +712,8 @@ impl BigUint {\n \n         let mut carry = 0;\n         let mut shifted: Vec<BigDigit> = self.data.iter().map(|elem| {\n-            let (hi, lo) = BigDigit::from_uint(\n-                (*elem as uint) << n_bits | (carry as uint)\n+            let (hi, lo) = BigDigit::from_doublebigdigit(\n+                (*elem as DoubleBigDigit) << n_bits | (carry as DoubleBigDigit)\n             );\n             carry = hi;\n             lo\n@@ -797,33 +753,9 @@ impl BigUint {\n     }\n }\n \n-#[cfg(target_word_size = \"32\")]\n+// `DoubleBigDigit` size dependent\n #[inline]\n-fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert!(1 < radix && radix <= 16);\n-    match radix {\n-        2  => (65536, 16),\n-        3  => (59049, 10),\n-        4  => (65536, 8),\n-        5  => (15625, 6),\n-        6  => (46656, 6),\n-        7  => (16807, 5),\n-        8  => (32768, 5),\n-        9  => (59049, 5),\n-        10 => (10000, 4),\n-        11 => (14641, 4),\n-        12 => (20736, 4),\n-        13 => (28561, 4),\n-        14 => (38416, 4),\n-        15 => (50625, 4),\n-        16 => (65536, 4),\n-        _  => fail!()\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-#[inline]\n-fn get_radix_base(radix: uint) -> (uint, uint) {\n+fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n@@ -1599,36 +1531,7 @@ mod biguint_tests {\n               \"88887777666655554444333322221111\");\n     }\n \n-    #[cfg(target_word_size = \"32\")]\n-    #[test]\n-    fn test_convert_i64() {\n-        fn check(b1: BigUint, i: i64) {\n-            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_i64().unwrap() == i);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n-\n-        check(BigUint::new(vec!(                   )), 0);\n-        check(BigUint::new(vec!( 1                 )), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1                 )), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  1             )), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1             )), (1 << (2*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  0,  1         )), (1 << (2*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1, -1         )), (1 << (3*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  0,  0,  1     )), (1 << (3*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1, -1, -1 >> 1)), i64::MAX);\n-\n-        assert_eq!(i64::MIN.to_biguint(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1, -1    )).to_i64(), None);\n-        assert_eq!(BigUint::new(vec!( 0,  0,  0,  0,  1)).to_i64(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1, -1, -1)).to_i64(), None);\n-    }\n-\n-    #[cfg(target_word_size = \"64\")]\n+    // `DoubleBigDigit` size dependent\n     #[test]\n     fn test_convert_i64() {\n         fn check(b1: BigUint, i: i64) {\n@@ -1653,35 +1556,7 @@ mod biguint_tests {\n         assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_i64(), None);\n     }\n \n-    #[cfg(target_word_size = \"32\")]\n-    #[test]\n-    fn test_convert_u64() {\n-        fn check(b1: BigUint, u: u64) {\n-            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_u64().unwrap() == u);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n-        check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n-\n-        check(BigUint::new(vec!(              )), 0);\n-        check(BigUint::new(vec!( 1            )), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1            )), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  1        )), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1        )), (1 << (2*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  0,  1    )), (1 << (2*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1, -1    )), (1 << (3*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  0,  0,  1)), (1 << (3*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1, -1, -1)), u64::MAX);\n-\n-        assert_eq!(BigUint::new(vec!( 0,  0,  0,  0,  1)).to_u64(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1, -1, -1)).to_u64(), None);\n-    }\n-\n-    #[cfg(target_word_size = \"64\")]\n+    // `DoubleBigDigit` size dependent\n     #[test]\n     fn test_convert_u64() {\n         fn check(b1: BigUint, u: u64) {"}]}