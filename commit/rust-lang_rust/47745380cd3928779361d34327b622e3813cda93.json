{"sha": "47745380cd3928779361d34327b622e3813cda93", "node_id": "C_kwDOAAsO6NoAKDQ3NzQ1MzgwY2QzOTI4Nzc5MzYxZDM0MzI3YjYyMmUzODEzY2RhOTM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-05T18:20:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-05T18:22:00Z"}, "message": "make Miri's scheduler proper round-robin", "tree": {"sha": "6b7637a830e08292497fad67a04f461de85b6479", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b7637a830e08292497fad67a04f461de85b6479"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47745380cd3928779361d34327b622e3813cda93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47745380cd3928779361d34327b622e3813cda93", "html_url": "https://github.com/rust-lang/rust/commit/47745380cd3928779361d34327b622e3813cda93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47745380cd3928779361d34327b622e3813cda93/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1b09eb9f9e908ad6a84be50aa8c4e9bde56365", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1b09eb9f9e908ad6a84be50aa8c4e9bde56365", "html_url": "https://github.com/rust-lang/rust/commit/5a1b09eb9f9e908ad6a84be50aa8c4e9bde56365"}], "stats": {"total": 59, "additions": 51, "deletions": 8}, "files": [{"sha": "b6fb866f714a4568d3e206fd8cea27438fd58a3c", "filename": "src/thread.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/47745380cd3928779361d34327b622e3813cda93/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47745380cd3928779361d34327b622e3813cda93/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=47745380cd3928779361d34327b622e3813cda93", "patch": "@@ -518,16 +518,26 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             return Ok(SchedulingAction::ExecuteTimeoutCallback);\n         }\n         // No callbacks scheduled, pick a regular thread to execute.\n-        // We need to pick a new thread for execution.\n-        for (id, thread) in self.threads.iter_enumerated() {\n+        // The active thread blocked or yielded. So we go search for another enabled thread.\n+        // Curcially, we start searching at the current active thread ID, rather than at 0, since we\n+        // want to avoid always scheduling threads 0 and 1 without ever making progress in thread 2.\n+        //\n+        // `skip(N)` means we start iterating at thread N, so we skip 1 more to start just *after*\n+        // the active thread. Then after that we look at `take(N)`, i.e., the threads *before* the\n+        // active thread.\n+        let threads = self\n+            .threads\n+            .iter_enumerated()\n+            .skip(self.active_thread.index() + 1)\n+            .chain(self.threads.iter_enumerated().take(self.active_thread.index()));\n+        for (id, thread) in threads {\n+            debug_assert_ne!(self.active_thread, id);\n             if thread.state == ThreadState::Enabled {\n-                if !self.yield_active_thread || id != self.active_thread {\n-                    self.active_thread = id;\n-                    if let Some(data_race) = data_race {\n-                        data_race.thread_set_active(self.active_thread);\n-                    }\n-                    break;\n+                self.active_thread = id;\n+                if let Some(data_race) = data_race {\n+                    data_race.thread_set_active(self.active_thread);\n                 }\n+                break;\n             }\n         }\n         self.yield_active_thread = false;"}, {"sha": "4229e54406815c1c0f1fe840f8a17b286857bc72", "filename": "tests/pass/concurrency/spin_loops.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/47745380cd3928779361d34327b622e3813cda93/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47745380cd3928779361d34327b622e3813cda93/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs?ref=47745380cd3928779361d34327b622e3813cda93", "patch": "@@ -0,0 +1,33 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+static FLAG: AtomicUsize = AtomicUsize::new(0);\n+\n+// When a thread yields, Miri's scheduler used to pick the thread with the lowest ID\n+// that can run. IDs are assigned in thread creation order.\n+// This means we could make 2 threads infinitely ping-pong with each other while\n+// really there is a 3rd thread that we should schedule to make progress.\n+\n+fn main() {\n+    let waiter1 = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // spin and wait\n+            thread::yield_now();\n+        }\n+    });\n+    let waiter2 = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // spin and wait\n+            thread::yield_now();\n+        }\n+    });\n+    let progress = thread::spawn(|| {\n+        FLAG.store(1, Ordering::Release);\n+    });\n+    // The first `join` blocks the main thread and thus takes it out of the equation.\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+    progress.join().unwrap();\n+}"}]}