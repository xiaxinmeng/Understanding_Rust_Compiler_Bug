{"sha": "111e167f48bd2e850e33828f2cb8837ce0da44a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMWUxNjdmNDhiZDJlODUwZTMzODI4ZjJjYjg4MzdjZTBkYTQ0YTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-22T02:56:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:35Z"}, "message": "librustc: De-`@mut` `MoveData::var_assignments`", "tree": {"sha": "ca70fca067d71c4e74ffbff376b1635443c147f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca70fca067d71c4e74ffbff376b1635443c147f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/111e167f48bd2e850e33828f2cb8837ce0da44a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/111e167f48bd2e850e33828f2cb8837ce0da44a7", "html_url": "https://github.com/rust-lang/rust/commit/111e167f48bd2e850e33828f2cb8837ce0da44a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/111e167f48bd2e850e33828f2cb8837ce0da44a7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "460305749c3b8c0a0726f490e7669f8259e6bbb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/460305749c3b8c0a0726f490e7669f8259e6bbb9", "html_url": "https://github.com/rust-lang/rust/commit/460305749c3b8c0a0726f490e7669f8259e6bbb9"}], "stats": {"total": 47, "additions": 29, "deletions": 18}, "files": [{"sha": "0a1ad19468eff3cd0eced71ccb9c1e322c0e8941", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/111e167f48bd2e850e33828f2cb8837ce0da44a7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111e167f48bd2e850e33828f2cb8837ce0da44a7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=111e167f48bd2e850e33828f2cb8837ce0da44a7", "patch": "@@ -43,7 +43,7 @@ pub struct MoveData {\n     /// Assignments to a variable, like `x = foo`. These are assigned\n     /// bits for dataflow, since we must track them to ensure that\n     /// immutable variables are assigned at most once along each path.\n-    var_assignments: ~[Assignment],\n+    var_assignments: RefCell<~[Assignment]>,\n \n     /// Assignments to a path, like `x.f = foo`. These are not\n     /// assigned dataflow bits, but we track them because they still\n@@ -169,7 +169,7 @@ impl MoveData {\n             path_map: RefCell::new(HashMap::new()),\n             moves: RefCell::new(~[]),\n             path_assignments: RefCell::new(~[]),\n-            var_assignments: ~[],\n+            var_assignments: RefCell::new(~[]),\n             assignee_ids: HashSet::new(),\n         }\n     }\n@@ -404,10 +404,11 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n+            let mut var_assignments = self.var_assignments.borrow_mut();\n             debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n-                   lp.repr(tcx), self.var_assignments.len(), path_index);\n+                   lp.repr(tcx), var_assignments.get().len(), path_index);\n \n-            self.var_assignments.push(assignment);\n+            var_assignments.get().push(assignment);\n         } else {\n             debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n@@ -438,9 +439,12 @@ impl MoveData {\n             }\n         }\n \n-        for (i, assignment) in self.var_assignments.iter().enumerate() {\n-            dfcx_assign.add_gen(assignment.id, i);\n-            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        {\n+            let var_assignments = self.var_assignments.borrow();\n+            for (i, assignment) in var_assignments.get().iter().enumerate() {\n+                dfcx_assign.add_gen(assignment.id, i);\n+                self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+            }\n         }\n \n         {\n@@ -470,14 +474,18 @@ impl MoveData {\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        for (assignment_index, assignment) in self.var_assignments.iter().enumerate() {\n-            match *self.path_loan_path(assignment.path) {\n-                LpVar(id) => {\n-                    let kill_id = tcx.region_maps.encl_scope(id);\n-                    dfcx_assign.add_kill(kill_id, assignment_index);\n-                }\n-                LpExtend(..) => {\n-                    tcx.sess.bug(\"Var assignment for non var path\");\n+        {\n+            let var_assignments = self.var_assignments.borrow();\n+            for (assignment_index, assignment) in\n+                    var_assignments.get().iter().enumerate() {\n+                match *self.path_loan_path(assignment.path) {\n+                    LpVar(id) => {\n+                        let kill_id = tcx.region_maps.encl_scope(id);\n+                        dfcx_assign.add_kill(kill_id, assignment_index);\n+                    }\n+                    LpExtend(..) => {\n+                        tcx.sess.bug(\"Var assignment for non var path\");\n+                    }\n                 }\n             }\n         }\n@@ -560,12 +568,14 @@ impl FlowedMoveData {\n                                  id_range,\n                                  moves.get().len())\n         };\n-        let mut dfcx_assign =\n+        let mut dfcx_assign = {\n+            let var_assignments = move_data.var_assignments.borrow();\n             DataFlowContext::new(tcx,\n                                  method_map,\n                                  AssignDataFlowOperator,\n                                  id_range,\n-                                 move_data.var_assignments.len());\n+                                 var_assignments.get().len())\n+        };\n         move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n         dfcx_moves.propagate(body);\n         dfcx_assign.propagate(body);\n@@ -681,7 +691,8 @@ impl FlowedMoveData {\n         };\n \n         self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n-            let assignment = &self.move_data.var_assignments[index];\n+            let var_assignments = self.move_data.var_assignments.borrow();\n+            let assignment = &var_assignments.get()[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}]}