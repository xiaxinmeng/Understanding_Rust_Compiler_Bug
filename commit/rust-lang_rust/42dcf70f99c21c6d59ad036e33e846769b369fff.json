{"sha": "42dcf70f99c21c6d59ad036e33e846769b369fff", "node_id": "C_kwDOAAsO6NoAKDQyZGNmNzBmOTljMjFjNmQ1OWFkMDM2ZTMzZTg0Njc2OWIzNjlmZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T03:44:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T03:44:54Z"}, "message": "Auto merge of #98148 - c410-f3r:assert-compiler, r=oli-obk\n\n[RFC 2011] Expand expressions where possible\n\nTracking issue: https://github.com/rust-lang/rust/issues/44838\nFourth step of https://github.com/rust-lang/rust/pull/96496\n\nExtends https://github.com/rust-lang/rust/pull/97665 considering expressions that are good candidates for expansion.\n\nr? `@oli-obk`", "tree": {"sha": "442eb1d0e91cf1818ce7d274ca2a227d6c7e12a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/442eb1d0e91cf1818ce7d274ca2a227d6c7e12a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42dcf70f99c21c6d59ad036e33e846769b369fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42dcf70f99c21c6d59ad036e33e846769b369fff", "html_url": "https://github.com/rust-lang/rust/commit/42dcf70f99c21c6d59ad036e33e846769b369fff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42dcf70f99c21c6d59ad036e33e846769b369fff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08871139915b95ec868aff807f224f78d00f4311", "url": "https://api.github.com/repos/rust-lang/rust/commits/08871139915b95ec868aff807f224f78d00f4311", "html_url": "https://github.com/rust-lang/rust/commit/08871139915b95ec868aff807f224f78d00f4311"}, {"sha": "47b057a3c96ae1e65121f053745c1e5a3567764e", "url": "https://api.github.com/repos/rust-lang/rust/commits/47b057a3c96ae1e65121f053745c1e5a3567764e", "html_url": "https://github.com/rust-lang/rust/commit/47b057a3c96ae1e65121f053745c1e5a3567764e"}], "stats": {"total": 134, "additions": 132, "deletions": 2}, "files": [{"sha": "cad301812123b07f56c1371600148c992064cda8", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 90, "deletions": 2, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/42dcf70f99c21c6d59ad036e33e846769b369fff/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dcf70f99c21c6d59ad036e33e846769b369fff/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=42dcf70f99c21c6d59ad036e33e846769b369fff", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::{\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n     BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, Mutability, Path,\n-    PathSegment, Stmt, UseTree, UseTreeKind, DUMMY_NODE_ID,\n+    PathSegment, Stmt, StructRest, UseTree, UseTreeKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -167,15 +167,103 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n         match (*expr).kind {\n+            ExprKind::AddrOf(_, _, ref mut local_expr) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n+            ExprKind::Array(ref mut local_exprs) => {\n+                for local_expr in local_exprs {\n+                    self.manage_cond_expr(local_expr);\n+                }\n+            }\n             ExprKind::Binary(_, ref mut lhs, ref mut rhs) => {\n                 self.manage_cond_expr(lhs);\n                 self.manage_cond_expr(rhs);\n             }\n+            ExprKind::Call(_, ref mut local_exprs) => {\n+                for local_expr in local_exprs {\n+                    self.manage_cond_expr(local_expr);\n+                }\n+            }\n+            ExprKind::Cast(ref mut local_expr, _) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n+            ExprKind::Index(ref mut prefix, ref mut suffix) => {\n+                self.manage_cond_expr(prefix);\n+                self.manage_cond_expr(suffix);\n+            }\n+            ExprKind::MethodCall(_, ref mut local_exprs, _) => {\n+                for local_expr in local_exprs.iter_mut().skip(1) {\n+                    self.manage_cond_expr(local_expr);\n+                }\n+            }\n             ExprKind::Path(_, Path { ref segments, .. }) if let &[ref path_segment] = &segments[..] => {\n                 let path_ident = path_segment.ident;\n                 self.manage_initial_capture(expr, path_ident);\n             }\n-            _ => {}\n+            ExprKind::Paren(ref mut local_expr) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n+            ExprKind::Range(ref mut prefix, ref mut suffix, _) => {\n+                if let Some(ref mut elem) = prefix {\n+                    self.manage_cond_expr(elem);\n+                }\n+                if let Some(ref mut elem) = suffix {\n+                    self.manage_cond_expr(elem);\n+                }\n+            }\n+            ExprKind::Repeat(ref mut local_expr, ref mut elem) => {\n+                self.manage_cond_expr(local_expr);\n+                self.manage_cond_expr(&mut elem.value);\n+            }\n+            ExprKind::Struct(ref mut elem) => {\n+                for field in &mut elem.fields {\n+                    self.manage_cond_expr(&mut field.expr);\n+                }\n+                if let StructRest::Base(ref mut local_expr) = elem.rest {\n+                    self.manage_cond_expr(local_expr);\n+                }\n+            }\n+            ExprKind::Tup(ref mut local_exprs) => {\n+                for local_expr in local_exprs {\n+                    self.manage_cond_expr(local_expr);\n+                }\n+            }\n+            ExprKind::Unary(_, ref mut local_expr) => {\n+                self.manage_cond_expr(local_expr);\n+            }\n+            // Expressions that are not worth or can not be captured.\n+            //\n+            // Full list instead of `_` to catch possible future inclusions and to\n+            // sync with the `rfc-2011-nicer-assert-messages/all-expr-kinds.rs` test.\n+            ExprKind::Assign(_, _, _)\n+            | ExprKind::AssignOp(_, _, _)\n+            | ExprKind::Async(_, _, _)\n+            | ExprKind::Await(_)\n+            | ExprKind::Block(_, _)\n+            | ExprKind::Box(_)\n+            | ExprKind::Break(_, _)\n+            | ExprKind::Closure(_, _, _, _, _, _)\n+            | ExprKind::ConstBlock(_)\n+            | ExprKind::Continue(_)\n+            | ExprKind::Err\n+            | ExprKind::Field(_, _)\n+            | ExprKind::ForLoop(_, _, _, _)\n+            | ExprKind::If(_, _, _)\n+            | ExprKind::InlineAsm(_)\n+            | ExprKind::Let(_, _, _)\n+            | ExprKind::Lit(_)\n+            | ExprKind::Loop(_, _)\n+            | ExprKind::MacCall(_)\n+            | ExprKind::Match(_, _)\n+            | ExprKind::Path(_, _)\n+            | ExprKind::Ret(_)\n+            | ExprKind::Try(_)\n+            | ExprKind::TryBlock(_)\n+            | ExprKind::Type(_, _)\n+            | ExprKind::Underscore\n+            | ExprKind::While(_, _, _)\n+            | ExprKind::Yeet(_)\n+            | ExprKind::Yield(_) => {}\n         }\n     }\n "}, {"sha": "f538ec643902eb66bbed67f520fe6e4b1a833447", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/42dcf70f99c21c6d59ad036e33e846769b369fff/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42dcf70f99c21c6d59ad036e33e846769b369fff/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fall-expr-kinds.rs?ref=42dcf70f99c21c6d59ad036e33e846769b369fff", "patch": "@@ -55,14 +55,56 @@ struct Foo {\n   bar: i32\n }\n \n+impl Foo {\n+  fn add(&self, a: i32, b: i32) -> i32 { a + b }\n+}\n+\n+fn add(a: i32, b: i32) -> i32 { a + b }\n+\n fn main() {\n   // ***** Allowed *****\n \n   tests!(\n     let mut elem = 1i32;\n \n+    // addr of\n+    [ &elem == &3 ] => \"Assertion failed: &elem == &3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // array\n+    [ [elem][0] == 3 ] => \"Assertion failed: [elem][0] == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n     // binary\n     [ elem + 1 == 3 ] => \"Assertion failed: elem + 1 == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // call\n+    [ add(elem, elem) == 3 ] => \"Assertion failed: add(elem, elem) == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // cast\n+    [ elem as i32 == 3 ] => \"Assertion failed: elem as i32 == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // index\n+    [ [1i32, 1][elem as usize] == 3 ] => \"Assertion failed: [1i32, 1][elem as usize] == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // method call\n+    [ FOO.add(elem, elem) == 3 ] => \"Assertion failed: FOO.add(elem, elem) == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // paren\n+    [ (elem) == 3 ] => \"Assertion failed: (elem) == 3\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // range\n+    [ (0..elem) == (0..3) ] => \"Assertion failed: (0..elem) == (0..3)\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // repeat\n+    [ [elem; 1] == [3; 1] ] => \"Assertion failed: [elem; 1] == [3; 1]\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // struct\n+    [ Foo { bar: elem } == Foo { bar: 3 } ] => \"Assertion failed: Foo { bar: elem } == Foo { bar: 3 }\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // tuple\n+    [ (elem, 1) == (3, 3) ] => \"Assertion failed: (elem, 1) == (3, 3)\\nWith captures:\\n  elem = 1\\n\"\n+\n+    // unary\n+    [ -elem == -3 ] => \"Assertion failed: -elem == -3\\nWith captures:\\n  elem = 1\\n\"\n   );\n \n   // ***** Disallowed *****"}]}