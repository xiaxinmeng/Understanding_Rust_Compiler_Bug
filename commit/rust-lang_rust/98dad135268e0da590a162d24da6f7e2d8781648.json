{"sha": "98dad135268e0da590a162d24da6f7e2d8781648", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZGFkMTM1MjY4ZTBkYTU5MGExNjJkMjRkYTZmN2UyZDg3ODE2NDg=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-29T02:41:09Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-05-01T06:22:27Z"}, "message": "Make implementation more scalable by using a helper trait to determine bitmask size.  Improve bitmask to int conversion.", "tree": {"sha": "88eeac702ab3122e5712b26b4420bc3bce14b5ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88eeac702ab3122e5712b26b4420bc3bce14b5ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98dad135268e0da590a162d24da6f7e2d8781648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98dad135268e0da590a162d24da6f7e2d8781648", "html_url": "https://github.com/rust-lang/rust/commit/98dad135268e0da590a162d24da6f7e2d8781648", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98dad135268e0da590a162d24da6f7e2d8781648/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eec42808aa024d354bb40ec890612c37ba4a496c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eec42808aa024d354bb40ec890612c37ba4a496c", "html_url": "https://github.com/rust-lang/rust/commit/eec42808aa024d354bb40ec890612c37ba4a496c"}], "stats": {"total": 495, "additions": 291, "deletions": 204}, "files": [{"sha": "e8d11406c0979ede20a2f43e3edbfae716d4ae37", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -7,6 +7,7 @@ macro_rules! implement_mask_ops {\n             where\n                 crate::$vector<LANES>: LanesAtMost32,\n                 crate::$inner_ty<LANES>: LanesAtMost32,\n+                crate::$mask<LANES>: crate::Mask,\n             {\n                 /// Test if each lane is equal to the corresponding lane in `other`.\n                 #[inline]"}, {"sha": "8cbb0cbccf7939b41b954457d333fdab09467334", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -79,6 +79,9 @@ extern \"platform-intrinsic\" {\n \n     // truncate integer vector to bitmask\n     pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n+\n+    // select\n+    pub(crate) fn simd_select_bitmask<T, U>(m: T, a: U, b: U) -> U;\n }\n \n #[cfg(feature = \"std\")]"}, {"sha": "6bcb08cf9dbb70d247af48c34a00d4ecb3eaa901", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 104, "deletions": 83, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -1,56 +1,103 @@\n+use crate::Mask;\n+use core::marker::PhantomData;\n+\n+/// Helper trait for limiting int conversion types\n+pub trait ConvertToInt {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where Self: crate::LanesAtMost32 {}\n+impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where Self: crate::LanesAtMost32 {}\n+\n /// A mask where each lane is represented by a single bit.\n-#[derive(Copy, Clone, Debug, PartialOrd, PartialEq, Ord, Eq, Hash)]\n #[repr(transparent)]\n-pub struct BitMask<const LANES: usize>(u64);\n+pub struct BitMask<T: Mask, const LANES: usize>(T::BitMask, PhantomData<[(); LANES]>);\n \n-impl<const LANES: usize> BitMask<LANES>\n-{\n+impl<T: Mask, const LANES: usize> Copy for BitMask<T, LANES> {}\n+\n+impl<T: Mask, const LANES: usize> Clone for BitMask<T, LANES> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T: Mask, const LANES: usize> PartialEq for BitMask<T, LANES> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.as_ref() == other.0.as_ref()\n+    }\n+}\n+\n+impl<T: Mask, const LANES: usize> PartialOrd for BitMask<T, LANES> {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.0.as_ref().partial_cmp(other.0.as_ref())\n+    }\n+}\n+\n+impl<T: Mask, const LANES: usize> Eq for BitMask<T, LANES> {}\n+\n+impl<T: Mask, const LANES: usize> Ord for BitMask<T, LANES> {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        self.0.as_ref().cmp(other.0.as_ref())\n+    }\n+}\n+\n+impl<T: Mask, const LANES: usize> BitMask<T, LANES> {\n     #[inline]\n     pub fn splat(value: bool) -> Self {\n+        let mut mask = T::BitMask::default();\n         if value {\n-            Self(u64::MAX >> (64 - LANES))\n+            mask.as_mut().fill(u8::MAX)\n         } else {\n-            Self(u64::MIN)\n+            mask.as_mut().fill(u8::MIN)\n+        }\n+        if LANES % 8 > 0 {\n+            *mask.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n         }\n+        Self(mask, PhantomData)\n     }\n \n     #[inline]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n-        (self.0 >> lane) & 0x1 > 0\n+        (self.0.as_ref()[lane / 8] >> lane % 8) & 0x1 > 0\n     }\n \n     #[inline]\n     pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n-        self.0 ^= ((value ^ self.test_unchecked(lane)) as u64) << lane\n+        self.0.as_mut()[lane / 8] ^= ((value ^ self.test_unchecked(lane)) as u8) << (lane % 8)\n     }\n \n     #[inline]\n-    pub fn to_int<V, T>(self) -> V\n+    pub fn to_int<V>(self) -> V\n     where\n-        V: Default + AsMut<[T; LANES]>,\n-        T: From<i8>,\n+        V: ConvertToInt + Default + core::ops::Not<Output = V>,\n     {\n-        // TODO this should be an intrinsic sign-extension\n-        let mut v = V::default();\n-        for i in 0..LANES {\n-            let lane = unsafe { self.test_unchecked(i) };\n-            v.as_mut()[i] = (-(lane as i8)).into();\n+        unsafe {\n+            let mask: T::IntBitMask = core::mem::transmute_copy(&self);\n+            crate::intrinsics::simd_select_bitmask(mask, !V::default(), V::default())\n         }\n-        v\n     }\n \n     #[inline]\n     pub unsafe fn from_int_unchecked<V>(value: V) -> Self\n     where\n         V: crate::LanesAtMost32,\n     {\n-        let mask: V::BitMask = crate::intrinsics::simd_bitmask(value);\n-        Self(mask.into())\n+        // TODO remove the transmute when rustc is more flexible\n+        assert_eq!(\n+            core::mem::size_of::<T::IntBitMask>(),\n+            core::mem::size_of::<T::BitMask>()\n+        );\n+        let mask: T::IntBitMask = crate::intrinsics::simd_bitmask(value);\n+        Self(core::mem::transmute_copy(&mask), PhantomData)\n     }\n \n     #[inline]\n-    pub fn to_bitmask(self) -> u64 {\n-        self.0\n+    pub fn to_bitmask<U: Mask>(self) -> U::BitMask {\n+        assert_eq!(\n+            core::mem::size_of::<T::BitMask>(),\n+            core::mem::size_of::<U::BitMask>()\n+        );\n+        unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n     #[inline]\n@@ -64,87 +111,61 @@ impl<const LANES: usize> BitMask<LANES>\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n+impl<T: Mask, const LANES: usize> core::ops::BitAnd for BitMask<T, LANES>\n+where\n+    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n-    fn bitand(self, rhs: Self) -> Self {\n-        Self(self.0 & rhs.0)\n+    fn bitand(mut self, rhs: Self) -> Self {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l &= r;\n+        }\n+        self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAnd<bool> for BitMask<LANES>\n+impl<T: Mask, const LANES: usize> core::ops::BitOr for BitMask<T, LANES>\n+where\n+    T::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n-    fn bitand(self, rhs: bool) -> Self {\n-        self & Self::splat(rhs)\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::BitAnd<BitMask<LANES>> for bool\n-{\n-    type Output = BitMask<LANES>;\n-    #[inline]\n-    fn bitand(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n-        BitMask::<LANES>::splat(self) & rhs\n+    fn bitor(mut self, rhs: Self) -> Self {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l |= r;\n+        }\n+        self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n-{\n+impl<T: Mask, const LANES: usize> core::ops::BitXor for BitMask<T, LANES> {\n     type Output = Self;\n     #[inline]\n-    fn bitor(self, rhs: Self) -> Self {\n-        Self(self.0 | rhs.0)\n+    fn bitxor(mut self, rhs: Self) -> Self::Output {\n+        for (l, r) in self.0.as_mut().iter_mut().zip(rhs.0.as_ref().iter()) {\n+            *l ^= r;\n+        }\n+        self\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n-{\n+impl<T: Mask, const LANES: usize> core::ops::Not for BitMask<T, LANES> {\n     type Output = Self;\n     #[inline]\n-    fn bitxor(self, rhs: Self) -> Self::Output {\n-        Self(self.0 ^ rhs.0)\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n-{\n-    type Output = BitMask<LANES>;\n-    #[inline]\n-    fn not(self) -> Self::Output {\n-        Self(!self.0) & Self::splat(true)\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::BitAndAssign for BitMask<LANES>\n-{\n-    #[inline]\n-    fn bitand_assign(&mut self, rhs: Self) {\n-        self.0 &= rhs.0;\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::BitOrAssign for BitMask<LANES>\n-{\n-    #[inline]\n-    fn bitor_assign(&mut self, rhs: Self) {\n-        self.0 |= rhs.0;\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::BitXorAssign for BitMask<LANES>\n-{\n-    #[inline]\n-    fn bitxor_assign(&mut self, rhs: Self) {\n-        self.0 ^= rhs.0;\n+    fn not(mut self) -> Self::Output {\n+        for x in self.0.as_mut() {\n+            *x = !*x;\n+        }\n+        if LANES % 8 > 0 {\n+            *self.0.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n+        }\n+        self\n     }\n }\n \n-pub type Mask8<const LANES: usize> = BitMask<LANES>;\n-pub type Mask16<const LANES: usize> = BitMask<LANES>;\n-pub type Mask32<const LANES: usize> = BitMask<LANES>;\n-pub type Mask64<const LANES: usize> = BitMask<LANES>;\n-pub type Mask128<const LANES: usize> = BitMask<LANES>;\n-pub type MaskSize<const LANES: usize> = BitMask<LANES>;\n+pub type Mask8<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type Mask16<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type Mask32<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type Mask64<T, const LANES: usize> = BitMask<T, LANES>;\n+pub type MaskSize<T, const LANES: usize> = BitMask<T, LANES>;"}, {"sha": "bd52a25551e2dda6fe39fa673e8554b204c88149", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -1,5 +1,8 @@\n //! Masks that take up full SIMD vector registers.\n \n+use crate::Mask;\n+use core::marker::PhantomData;\n+\n macro_rules! define_mask {\n     {\n         $(#[$attr:meta])*\n@@ -8,20 +11,19 @@ macro_rules! define_mask {\n         );\n     } => {\n         $(#[$attr])*\n-        #[derive(Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n         #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>(crate::$type<$lanes2>)\n+        pub struct $name<T: Mask, const $lanes: usize>(crate::$type<$lanes2>, PhantomData<T>)\n         where\n             crate::$type<LANES>: crate::LanesAtMost32;\n \n         impl_full_mask_reductions! { $name, $type }\n \n-        impl<const LANES: usize> Copy for $name<LANES>\n+        impl<T: Mask, const LANES: usize> Copy for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {}\n \n-        impl<const LANES: usize> Clone for $name<LANES>\n+        impl<T: Mask, const LANES: usize> Clone for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n@@ -31,18 +33,53 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> $name<LANES>\n+        impl<T: Mask, const LANES: usize> PartialEq for $name<T, LANES>\n+        where\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+        {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<T: Mask, const LANES: usize> PartialOrd for $name<T, LANES>\n+        where\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+        {\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n+            }\n+        }\n+\n+        impl<T: Mask, const LANES: usize> Eq for $name<T, LANES>\n+        where\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+        {}\n+\n+        impl<T: Mask, const LANES: usize> Ord for $name<T, LANES>\n+        where\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+        {\n+            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+                self.0.cmp(&other.0)\n+            }\n+        }\n+\n+        impl<T: Mask, const LANES: usize> $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             pub fn splat(value: bool) -> Self {\n-                Self(<crate::$type<LANES>>::splat(\n-                    if value {\n-                        -1\n-                    } else {\n-                        0\n-                    }\n-                ))\n+                Self(\n+                    <crate::$type<LANES>>::splat(\n+                        if value {\n+                            -1\n+                        } else {\n+                            0\n+                        }\n+                    ),\n+                    PhantomData,\n+                )\n             }\n \n             #[inline]\n@@ -66,96 +103,70 @@ macro_rules! define_mask {\n \n             #[inline]\n             pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n-                Self(value)\n+                Self(value, PhantomData)\n             }\n \n             #[inline]\n-            pub fn to_bitmask(self) -> u64 {\n-                let mask: <crate::$type<LANES> as crate::LanesAtMost32>::BitMask = unsafe { crate::intrinsics::simd_bitmask(self.0) };\n-                mask.into()\n+            pub fn to_bitmask<U: crate::Mask>(self) -> U::BitMask {\n+                unsafe {\n+                    // TODO remove the transmute when rustc is more flexible\n+                    assert_eq!(core::mem::size_of::<U::IntBitMask>(), core::mem::size_of::<U::BitMask>());\n+                    let mask: U::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n+                    core::mem::transmute_copy(&mask)\n+                }\n             }\n         }\n \n-        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n+        impl<T: Mask, const LANES: usize> core::convert::From<$name<T, LANES>> for crate::$type<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            fn from(value: $name<LANES>) -> Self {\n+            fn from(value: $name<T, LANES>) -> Self {\n                 value.0\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::BitAnd for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: Self) -> Self {\n-                Self(self.0 & rhs.0)\n+                Self(self.0 & rhs.0, PhantomData)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::BitOr for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: Self) -> Self {\n-                Self(self.0 | rhs.0)\n+                Self(self.0 | rhs.0, PhantomData)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::BitXor for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: Self) -> Self::Output {\n-                Self(self.0 ^ rhs.0)\n+                Self(self.0 ^ rhs.0, PhantomData)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::Not for $name<LANES>\n+        impl<T: Mask, const LANES: usize> core::ops::Not for $name<T, LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            type Output = $name<LANES>;\n+            type Output = Self;\n             #[inline]\n             fn not(self) -> Self::Output {\n-                Self(!self.0)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitand_assign(&mut self, rhs: Self) {\n-                self.0 &= rhs.0;\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitor_assign(&mut self, rhs: Self) {\n-                self.0 |= rhs.0;\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitxor_assign(&mut self, rhs: Self) {\n-                self.0 ^= rhs.0;\n+                Self(!self.0, PhantomData)\n             }\n         }\n     }"}, {"sha": "deaf2be5dca4407e7c9ab9e23c768da9af5f4f9f", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 93, "deletions": 53, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -2,16 +2,30 @@\n //! Types representing\n #![allow(non_camel_case_types)]\n \n-#[cfg_attr(not(all(target_arch = \"x86_64\", target_feature = \"avx512f\")), path = \"full_masks.rs\")]\n-#[cfg_attr(all(target_arch = \"x86_64\", target_feature = \"avx512f\"), path = \"bitmask.rs\")]\n+#[cfg_attr(\n+    not(all(target_arch = \"x86_64\", target_feature = \"avx512f\")),\n+    path = \"full_masks.rs\"\n+)]\n+#[cfg_attr(\n+    all(target_arch = \"x86_64\", target_feature = \"avx512f\"),\n+    path = \"bitmask.rs\"\n+)]\n mod mask_impl;\n \n use crate::{LanesAtMost32, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n-/// Converts masks to bitmasks, with one bit set for each lane.\n-pub trait ToBitMask {\n-    /// Converts this mask to a bitmask.\n-    fn to_bitmask(self) -> u64;\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+\n+/// Helper trait for mask types.\n+pub trait Mask: sealed::Sealed {\n+    /// The bitmask representation of a mask.\n+    type BitMask: Copy + Default + AsRef<[u8]> + AsMut<[u8]>;\n+\n+    // TODO remove this when rustc intrinsics are more flexible\n+    #[doc(hidden)]\n+    type IntBitMask;\n }\n \n macro_rules! define_opaque_mask {\n@@ -22,13 +36,47 @@ macro_rules! define_opaque_mask {\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name<const LANES: usize>($inner_ty) where $bits_ty<LANES>: LanesAtMost32;\n+        pub struct $name<const LANES: usize>($inner_ty)\n+        where\n+            $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask;\n+\n+        impl<const LANES: usize> sealed::Sealed for $name<LANES>\n+        where\n+            $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n+        {}\n+        impl Mask for $name<1> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<2> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<4> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<8> {\n+            type BitMask = [u8; 1];\n+            type IntBitMask = u8;\n+        }\n+        impl Mask for $name<16> {\n+            type BitMask = [u8; 2];\n+            type IntBitMask = u16;\n+        }\n+        impl Mask for $name<32> {\n+            type BitMask = [u8; 4];\n+            type IntBitMask = u32;\n+        }\n \n         impl_opaque_mask_reductions! { $name, $bits_ty }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32\n+            $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n@@ -125,48 +173,18 @@ macro_rules! define_opaque_mask {\n                 assert!(lane < LANES, \"lane index out of range\");\n                 unsafe { self.set_unchecked(lane, value); }\n             }\n-        }\n-\n-        impl ToBitMask for $name<1> {\n-            fn to_bitmask(self) -> u64 {\n-                self.0.to_bitmask()\n-            }\n-        }\n-\n-        impl ToBitMask for $name<2> {\n-            fn to_bitmask(self) -> u64 {\n-                self.0.to_bitmask()\n-            }\n-        }\n-\n-        impl ToBitMask for $name<4> {\n-            fn to_bitmask(self) -> u64 {\n-                self.0.to_bitmask()\n-            }\n-        }\n \n-        impl ToBitMask for $name<8> {\n-            fn to_bitmask(self) -> u64 {\n-                self.0.to_bitmask()\n-            }\n-        }\n-\n-        impl ToBitMask for $name<16> {\n-            fn to_bitmask(self) -> u64 {\n-                self.0.to_bitmask()\n-            }\n-        }\n-\n-        impl ToBitMask for $name<32> {\n-            fn to_bitmask(self) -> u64 {\n-                self.0.to_bitmask()\n+            /// Convert this mask to a bitmask, with one bit set per lane.\n+            pub fn to_bitmask(self) -> <Self as Mask>::BitMask {\n+                self.0.to_bitmask::<Self>()\n             }\n         }\n \n         // vector/array conversion\n         impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32\n+            $bits_ty<LANES>: crate::LanesAtMost32,\n+            Self: Mask,\n         {\n             fn from(array: [bool; LANES]) -> Self {\n                 Self::from_array(array)\n@@ -175,7 +193,8 @@ macro_rules! define_opaque_mask {\n \n         impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32\n+            $bits_ty<LANES>: crate::LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n@@ -184,13 +203,14 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $inner_ty: Copy,\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n@@ -201,6 +221,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> Default for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn default() -> Self {\n@@ -211,6 +232,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n@@ -221,6 +243,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n@@ -231,6 +254,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n             $bits_ty<LANES>: crate::LanesAtMost32,\n+            Self: Mask,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 f.debug_list()\n@@ -242,6 +266,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -253,6 +278,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -264,6 +290,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -275,6 +302,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -286,6 +314,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -297,6 +326,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -308,6 +338,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -319,6 +350,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = Self;\n             #[inline]\n@@ -330,6 +362,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            $name<LANES>: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -341,6 +374,7 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -352,16 +386,18 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n-                self.0 &= rhs.0;\n+                self.0 = self.0 & rhs.0;\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -372,16 +408,18 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n-                self.0 |= rhs.0;\n+                self.0 = self.0 | rhs.0;\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -392,16 +430,18 @@ macro_rules! define_opaque_mask {\n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n-                self.0 ^= rhs.0;\n+                self.0 = self.0 ^ rhs.0;\n             }\n         }\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32,\n+            Self: Mask,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -415,39 +455,39 @@ define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(mask_impl::Mask8<LANES>);\n+    struct Mask8<const LANES: usize>(mask_impl::Mask8<Self, LANES>);\n     @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(mask_impl::Mask16<LANES>);\n+    struct Mask16<const LANES: usize>(mask_impl::Mask16<Self, LANES>);\n     @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(mask_impl::Mask32<LANES>);\n+    struct Mask32<const LANES: usize>(mask_impl::Mask32<Self, LANES>);\n     @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(mask_impl::Mask64<LANES>);\n+    struct Mask64<const LANES: usize>(mask_impl::Mask64<Self, LANES>);\n     @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<LANES>);\n+    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<Self, LANES>);\n     @bits SimdIsize\n }\n "}, {"sha": "8687d1af51674740bc4dc13b03578f03696626b6", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -104,7 +104,7 @@ macro_rules! impl_float_reductions {\n \n macro_rules! impl_full_mask_reductions {\n     { $name:ident, $bits_ty:ident } => {\n-        impl<const LANES: usize> $name<LANES>\n+        impl<T: crate::Mask, const LANES: usize> $name<T, LANES>\n         where\n             crate::$bits_ty<LANES>: crate::LanesAtMost32\n         {\n@@ -125,7 +125,8 @@ macro_rules! impl_opaque_mask_reductions {\n     { $name:ident, $bits_ty:ident } => {\n         impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$bits_ty<LANES>: crate::LanesAtMost32\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32,\n+            $name<LANES>: crate::Mask,\n         {\n             /// Returns true if any lane is set, or false otherwise.\n             #[inline]"}, {"sha": "6371f88a40a21deef428d16ea527a1360841ee56", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -42,6 +42,7 @@ macro_rules! impl_float_vector {\n             Self: crate::LanesAtMost32,\n             crate::$bits_ty<LANES>: crate::LanesAtMost32,\n             crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n+            crate::$mask_ty<LANES>: crate::Mask,\n         {\n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity."}, {"sha": "a535fad7bc1d5fb041ccaeb10d514562c8e4dcc3", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -30,6 +30,7 @@ macro_rules! impl_integer_vector {\n         where\n             Self: crate::LanesAtMost32,\n             crate::$mask_impl_ty<LANES>: crate::LanesAtMost32,\n+            crate::$mask_ty<LANES>: crate::Mask,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             pub fn is_positive(self) -> crate::$mask_ty<LANES> {"}, {"sha": "db027b0941f22e779180ff7d5c66d0dac0f5013d", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -1,6 +1,5 @@\n #![allow(non_camel_case_types)]\n \n-\n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {"}, {"sha": "54427ec1ec0d0f63f91ef5751d3cc24a7d2b9096", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -68,10 +68,12 @@ macro_rules! test_mask_api {\n \n             #[test]\n             fn to_bitmask() {\n-                use core_simd::ToBitMask;\n-                let values = [true, false, false, true, false, false, true, false];\n-                let mask = core_simd::$name::<8>::from_array(values);\n-                assert_eq!(mask.to_bitmask(), 0b01001001);\n+                let values = [\n+                    true, false, false, true, false, false, true, false,\n+                    false, false, false, false, false, false, false, false,\n+                ];\n+                let mask = core_simd::$name::<16>::from_array(values);\n+                assert_eq!(mask.to_bitmask(), [0b01001001, 0]);\n             }\n         }\n     }"}, {"sha": "5ffc922697694948e5d12649bbbce9eeba4da966", "filename": "crates/test_helpers/src/array.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -3,14 +3,11 @@\n // Adapted from proptest's array code\n // Copyright 2017 Jason Lingle\n \n+use core::{marker::PhantomData, mem::MaybeUninit};\n use proptest::{\n     strategy::{NewTree, Strategy, ValueTree},\n     test_runner::TestRunner,\n };\n-use core::{\n-    marker::PhantomData,\n-    mem::MaybeUninit,\n-};\n \n #[must_use = \"strategies do nothing unless used\"]\n #[derive(Clone, Copy, Debug)]"}, {"sha": "fffd088f4da38d2ea4e8833e6a06ce4d043d6ea9", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98dad135268e0da590a162d24da6f7e2d8781648/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=98dad135268e0da590a162d24da6f7e2d8781648", "patch": "@@ -281,6 +281,11 @@ macro_rules! test_lanes {\n                     core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::Mask8<$lanes>: core_simd::Mask,\n+                    core_simd::Mask16<$lanes>: core_simd::Mask,\n+                    core_simd::Mask32<$lanes>: core_simd::Mask,\n+                    core_simd::Mask64<$lanes>: core_simd::Mask,\n+                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n@@ -350,6 +355,11 @@ macro_rules! test_lanes_panic {\n                     core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n+                    core_simd::Mask8<$lanes>: core_simd::Mask,\n+                    core_simd::Mask16<$lanes>: core_simd::Mask,\n+                    core_simd::Mask32<$lanes>: core_simd::Mask,\n+                    core_simd::Mask64<$lanes>: core_simd::Mask,\n+                    core_simd::MaskSize<$lanes>: core_simd::Mask,\n                 $body\n \n                 #[test]"}]}