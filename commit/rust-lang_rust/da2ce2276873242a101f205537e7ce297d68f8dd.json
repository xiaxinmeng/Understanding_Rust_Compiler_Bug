{"sha": "da2ce2276873242a101f205537e7ce297d68f8dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMmNlMjI3Njg3MzI0MmExMDFmMjA1NTM3ZTdjZTI5N2Q2OGY4ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-09T19:58:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-09T19:58:25Z"}, "message": "Auto merge of #37670 - eddyb:rollup, r=eddyb\n\nRollup of 15 pull requests\n\n- Successful merges: #36868, #37134, #37229, #37250, #37370, #37428, #37432, #37472, #37524, #37614, #37622, #37627, #37636, #37644, #37654\n- Failed merges: #37463, #37542, #37645", "tree": {"sha": "b0de0fa6de932ca2ebeb973b7c92014903edb54e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0de0fa6de932ca2ebeb973b7c92014903edb54e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da2ce2276873242a101f205537e7ce297d68f8dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da2ce2276873242a101f205537e7ce297d68f8dd", "html_url": "https://github.com/rust-lang/rust/commit/da2ce2276873242a101f205537e7ce297d68f8dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da2ce2276873242a101f205537e7ce297d68f8dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bca365e688f0424fb99d38d477a9b7863bb070d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca365e688f0424fb99d38d477a9b7863bb070d3", "html_url": "https://github.com/rust-lang/rust/commit/bca365e688f0424fb99d38d477a9b7863bb070d3"}, {"sha": "60c74b76c4698d0223223e42853c5a89fd33fd09", "url": "https://api.github.com/repos/rust-lang/rust/commits/60c74b76c4698d0223223e42853c5a89fd33fd09", "html_url": "https://github.com/rust-lang/rust/commit/60c74b76c4698d0223223e42853c5a89fd33fd09"}], "stats": {"total": 44023, "additions": 42643, "deletions": 1380}, "files": [{"sha": "1d4c6252f2c7503ddf6b6861250e31530d53f119", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -7,3 +7,4 @@\n src/etc/pkg/rust-logo.ico binary\n src/etc/pkg/rust-logo.png binary\n *.woff binary\n+src/vendor/* binary"}, {"sha": "bf66eabc1c800bd44ca12ed1932995bf8ca3955f", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -98,3 +98,4 @@ tmp.*.rs\n version.md\n version.ml\n version.texi\n+.cargo"}, {"sha": "144329caa71aa8c1afb018e24bf7bda37a7edde6", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,7 +15,7 @@ before_install:\n script:\n   - docker run -v `pwd`:/build rust\n     sh -c \"\n-      ./configure --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n+      ./configure --enable-vendor --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n       make tidy &&\n       make check -j4\n     \""}, {"sha": "9c055e7217aa329d63a6697780a4df5de645116a", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/configure", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -634,6 +634,7 @@ opt rustbuild 0 \"use the rust and cargo based build system\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n+opt vendor 0 \"enable usage of vendored Rust crates\"\n \n # Optimization and debugging options. These may be overridden by the release channel, etc.\n opt_nosave optimize 1 \"build optimized rust code\""}, {"sha": "238ba8acee42f894fb7aaae3648de1a5d0d91e65", "filename": "mk/dist.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -65,7 +65,8 @@ PKG_FILES := \\\n       stage0.txt                               \\\n       rust-installer                           \\\n       tools                                    \\\n-      test)                                    \\\n+      test                                     \\\n+      vendor)                                  \\\n     $(PKG_GITMODULES)                          \\\n     $(filter-out config.stamp, \\\n                  $(MKFILES_FOR_TARBALL))"}, {"sha": "d3517175d4cedb9309e14c64a5cf9171685c54a0", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -44,13 +44,11 @@ dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -149,25 +147,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"graphviz\"\n version = \"0.0.0\"\n \n-[[package]]\n-name = \"idna\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"libc\"\n version = \"0.0.0\"\n@@ -183,9 +162,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"linkchecker\"\n version = \"0.1.0\"\n-dependencies = [\n- \"url 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"log\"\n@@ -196,11 +172,6 @@ name = \"log\"\n version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"matches\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"md5\"\n version = \"0.1.1\"\n@@ -705,55 +676,15 @@ dependencies = [\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"unicode-bidi\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"unicode-normalization\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"url\"\n-version = \"1.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [metadata]\n \"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1053236e00ce4f668aeca4a769a09b3bf5a682d802abd6f3cb39374f6b162c11\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcc3ad8109fa4b522f9b0cd81440422781f564aaf8c195de6b9d6642177ad0dd\"\n \"checksum md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a5539a8dee9b4ae308c9c406a379838b435a8f2c84cf9fedc6d5a576be9888db\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n \"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n-\"checksum unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1f7ceb96afdfeedee42bade65a0d585a6a0106f681b6749c8ff4daa8df30b3f\"\n-\"checksum unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26643a2f83bac55f1976fb716c10234485f9202dcd65cfbdf9da49867b271172\"\n-\"checksum url 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48ccf7bd87a81b769cf84ad556e034541fb90e1cd6d4bc375c822ed9500cd9d7\"\n-\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "4c9b578c1349d9de291516207d8f0c7e75deae0c", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -27,10 +27,6 @@ num_cpus = \"0.2\"\n toml = \"0.1\"\n getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n-gcc = \"0.3.36\"\n+gcc = \"0.3.38\"\n libc = \"0.2\"\n md5 = \"0.1\"\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = \"0.2\"\n-kernel32-sys = \"0.2\""}, {"sha": "08a8ca5a631303a2e772420d77ea061a1afceb4d", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -259,9 +259,11 @@ def build_bootstrap(self):\n         env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n                       os.pathsep + env[\"PATH\"]\n-        self.run([self.cargo(), \"build\", \"--manifest-path\",\n-                  os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")],\n-                 env)\n+        args = [self.cargo(), \"build\", \"--manifest-path\",\n+                os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n+        if self.use_vendored_sources:\n+            args.append(\"--frozen\")\n+        self.run(args, env)\n \n     def run(self, args, env):\n         proc = subprocess.Popen(args, env=env)\n@@ -400,6 +402,25 @@ def main():\n     except:\n         pass\n \n+    rb.use_vendored_sources = '\\nvendor = true' in rb.config_toml or \\\n+                              'CFG_ENABLE_VENDOR' in rb.config_mk\n+\n+    if rb.use_vendored_sources:\n+        if not os.path.exists('.cargo'):\n+            os.makedirs('.cargo')\n+        f = open('.cargo/config','w')\n+        f.write(\"\"\"\n+            [source.crates-io]\n+            replace-with = 'vendored-sources'\n+            registry = 'https://example.com'\n+\n+            [source.vendored-sources]\n+            directory = '{}/src/vendor'\n+        \"\"\".format(rb.rust_root))\n+        f.close()\n+    else:\n+        if os.path.exists('.cargo'):\n+            shutil.rmtree('.cargo')\n     data = stage0_data(rb.rust_root)\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n     rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)"}, {"sha": "9a939fee43e8bcf06d2b8789a6b0e421fcce2e8a", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -44,6 +44,7 @@ pub struct Config {\n     pub submodules: bool,\n     pub compiler_docs: bool,\n     pub docs: bool,\n+    pub vendor: bool,\n     pub target_config: HashMap<String, Target>,\n \n     // llvm codegen options\n@@ -126,6 +127,7 @@ struct Build {\n     docs: Option<bool>,\n     submodules: Option<bool>,\n     gdb: Option<String>,\n+    vendor: Option<bool>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -234,6 +236,7 @@ impl Config {\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n+        set(&mut config.vendor, build.vendor);\n \n         if let Some(ref llvm) = toml.llvm {\n             set(&mut config.ccache, llvm.ccache);\n@@ -347,6 +350,7 @@ impl Config {\n                 (\"LOCAL_REBUILD\", self.local_rebuild),\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),\n+                (\"VENDOR\", self.vendor),\n             }\n \n             match key {"}, {"sha": "306708f9e4b68444ad4e9012d2d101c7a14456bc", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -82,6 +82,9 @@\n # The path to (or name of) the GDB executable to use\n #gdb = \"gdb\"\n \n+# Indicate whether the vendored sources are used for Rust dependencies or not\n+#vendor = false\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "b4d7aff97da6a30a6784865e732994b5ddc44095", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -37,15 +37,82 @@\n //! Note that this module has a #[cfg(windows)] above it as none of this logic\n //! is required on Unix.\n \n-extern crate kernel32;\n-extern crate winapi;\n+#![allow(bad_style, dead_code)]\n \n use std::env;\n use std::io;\n use std::mem;\n \n-use self::winapi::*;\n-use self::kernel32::*;\n+type HANDLE = *mut u8;\n+type BOOL = i32;\n+type DWORD = u32;\n+type LPHANDLE = *mut HANDLE;\n+type LPVOID = *mut u8;\n+type JOBOBJECTINFOCLASS = i32;\n+type SIZE_T = usize;\n+type LARGE_INTEGER = i64;\n+type ULONG_PTR = usize;\n+type ULONGLONG = u64;\n+\n+const FALSE: BOOL = 0;\n+const DUPLICATE_SAME_ACCESS: DWORD = 0x2;\n+const PROCESS_DUP_HANDLE: DWORD = 0x40;\n+const JobObjectExtendedLimitInformation: JOBOBJECTINFOCLASS = 9;\n+const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: DWORD = 0x2000;\n+\n+extern \"system\" {\n+    fn CreateJobObjectW(lpJobAttributes: *mut u8, lpName: *const u8) -> HANDLE;\n+    fn CloseHandle(hObject: HANDLE) -> BOOL;\n+    fn GetCurrentProcess() -> HANDLE;\n+    fn OpenProcess(dwDesiredAccess: DWORD,\n+                   bInheritHandle: BOOL,\n+                   dwProcessId: DWORD) -> HANDLE;\n+    fn DuplicateHandle(hSourceProcessHandle: HANDLE,\n+                       hSourceHandle: HANDLE,\n+                       hTargetProcessHandle: HANDLE,\n+                       lpTargetHandle: LPHANDLE,\n+                       dwDesiredAccess: DWORD,\n+                       bInheritHandle: BOOL,\n+                       dwOptions: DWORD) -> BOOL;\n+    fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;\n+    fn SetInformationJobObject(hJob: HANDLE,\n+                               JobObjectInformationClass: JOBOBJECTINFOCLASS,\n+                               lpJobObjectInformation: LPVOID,\n+                               cbJobObjectInformationLength: DWORD) -> BOOL;\n+}\n+\n+#[repr(C)]\n+struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {\n+    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,\n+    IoInfo: IO_COUNTERS,\n+    ProcessMemoryLimit: SIZE_T,\n+    JobMemoryLimit: SIZE_T,\n+    PeakProcessMemoryUsed: SIZE_T,\n+    PeakJobMemoryUsed: SIZE_T,\n+}\n+\n+#[repr(C)]\n+struct IO_COUNTERS {\n+    ReadOperationCount: ULONGLONG,\n+    WriteOperationCount: ULONGLONG,\n+    OtherOperationCount: ULONGLONG,\n+    ReadTransferCount: ULONGLONG,\n+    WriteTransferCount: ULONGLONG,\n+    OtherTransferCount: ULONGLONG,\n+}\n+\n+#[repr(C)]\n+struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n+    PerProcessUserTimeLimit: LARGE_INTEGER,\n+    PerJobUserTimeLimit: LARGE_INTEGER,\n+    LimitFlags: DWORD,\n+    MinimumWorkingsetSize: SIZE_T,\n+    MaximumWorkingsetSize: SIZE_T,\n+    ActiveProcessLimit: DWORD,\n+    Affinity: ULONG_PTR,\n+    PriorityClass: DWORD,\n+    SchedulingClass: DWORD,\n+}\n \n pub unsafe fn setup() {\n     // Create a new job object for us to use"}, {"sha": "e6b88ea58c9bc0de545265f2b17a43852fdde5b9", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -460,6 +460,9 @@ impl Build {\n         if self.config.rust_optimize {\n             cargo.arg(\"--release\");\n         }\n+        if self.config.vendor {\n+            cargo.arg(\"--frozen\");\n+        }\n         return cargo\n     }\n "}, {"sha": "f6b74a91c193b7110fb8561ae626f327bd960de4", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 92, "deletions": 54, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -35,11 +35,14 @@ pub trait Iterator {\n \n     /// Advances the iterator and returns the next value.\n     ///\n-    /// Returns `None` when iteration is finished. Individual iterator\n+    /// Returns [`None`] when iteration is finished. Individual iterator\n     /// implementations may choose to resume iteration, and so calling `next()`\n-    /// again may or may not eventually start returning `Some(Item)` again at some\n+    /// again may or may not eventually start returning [`Some(Item)`] again at some\n     /// point.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(Item)`]: ../../std/option/enum.Option.html#variant.Some\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -69,9 +72,9 @@ pub trait Iterator {\n     /// Specifically, `size_hint()` returns a tuple where the first element\n     /// is the lower bound, and the second element is the upper bound.\n     ///\n-    /// The second half of the tuple that is returned is an `Option<usize>`. A\n-    /// `None` here means that either there is no known upper bound, or the\n-    /// upper bound is larger than `usize`.\n+    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// A [`None`] here means that either there is no known upper bound, or the\n+    /// upper bound is larger than [`usize`].\n     ///\n     /// # Implementation notes\n     ///\n@@ -91,6 +94,10 @@ pub trait Iterator {\n     /// The default implementation returns `(0, None)` which is correct for any\n     /// iterator.\n     ///\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`Option`]: ../../std/option/enum.Option.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -134,23 +141,26 @@ pub trait Iterator {\n     /// Consumes the iterator, counting the number of iterations and returning it.\n     ///\n     /// This method will evaluate the iterator until its [`next()`] returns\n-    /// `None`. Once `None` is encountered, `count()` returns the number of\n+    /// [`None`]. Once [`None`] is encountered, `count()` returns the number of\n     /// times it called [`next()`].\n     ///\n     /// [`next()`]: #tymethod.next\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so counting elements of\n-    /// an iterator with more than `usize::MAX` elements either produces the\n+    /// an iterator with more than [`usize::MAX`] elements either produces the\n     /// wrong result or panics. If debug assertions are enabled, a panic is\n     /// guaranteed.\n     ///\n     /// # Panics\n     ///\n-    /// This function might panic if the iterator has more than `usize::MAX`\n+    /// This function might panic if the iterator has more than [`usize::MAX`]\n     /// elements.\n     ///\n+    /// [`usize::MAX`]: ../../std/isize/constant.MAX.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -172,10 +182,12 @@ pub trait Iterator {\n \n     /// Consumes the iterator, returning the last element.\n     ///\n-    /// This method will evaluate the iterator until it returns `None`. While\n-    /// doing so, it keeps track of the current element. After `None` is\n+    /// This method will evaluate the iterator until it returns [`None`]. While\n+    /// doing so, it keeps track of the current element. After [`None`] is\n     /// returned, `last()` will then return the last element it saw.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -202,9 +214,11 @@ pub trait Iterator {\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on.\n     ///\n-    /// `nth()` will return `None` if `n` is greater than or equal to the length of the\n+    /// `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n     /// iterator.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -306,8 +320,8 @@ pub trait Iterator {\n     ///\n     /// In other words, it zips two iterators together, into a single one.\n     ///\n-    /// When either iterator returns `None`, all further calls to `next()`\n-    /// will return `None`.\n+    /// When either iterator returns [`None`], all further calls to [`next()`]\n+    /// will return [`None`].\n     ///\n     /// # Examples\n     ///\n@@ -346,7 +360,7 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// `zip()` is often used to zip an infinite iterator to a finite one.\n-    /// This works because the finite iterator will eventually return `None`,\n+    /// This works because the finite iterator will eventually return [`None`],\n     /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate()`]:\n     ///\n     /// ```\n@@ -365,6 +379,8 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n+    /// [`next()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n@@ -501,23 +517,21 @@ pub trait Iterator {\n     ///\n     /// The closure must return an [`Option<T>`]. `filter_map()` creates an\n     /// iterator which calls this closure on each element. If the closure\n-    /// returns `Some(element)`, then that element is returned. If the\n-    /// closure returns `None`, it will try again, and call the closure on the\n-    /// next element, seeing if it will return `Some`.\n-    ///\n-    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    /// returns [`Some(element)`][`Some`], then that element is returned. If the\n+    /// closure returns [`None`], it will try again, and call the closure on the\n+    /// next element, seeing if it will return [`Some`].\n     ///\n     /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n     /// part:\n     ///\n     /// [`filter()`]: #method.filter\n     /// [`map()`]: #method.map\n     ///\n-    /// > If the closure returns `Some(element)`, then that element is returned.\n+    /// > If the closure returns [`Some(element)`][`Some`], then that element is returned.\n     ///\n     /// In other words, it removes the [`Option<T>`] layer automatically. If your\n     /// mapping is already returning an [`Option<T>`] and you want to skip over\n-    /// `None`s, then `filter_map()` is much, much nicer to use.\n+    /// [`None`]s, then `filter_map()` is much, much nicer to use.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +561,11 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), None);\n     /// ```\n     ///\n-    /// There's an extra layer of `Some` in there.\n+    /// There's an extra layer of [`Some`] in there.\n+    ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n@@ -567,21 +585,20 @@ pub trait Iterator {\n     /// different sized integer, the [`zip()`] function provides similar\n     /// functionality.\n     ///\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    /// [`zip()`]: #method.zip\n-    ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so enumerating more than\n     /// [`usize::MAX`] elements either produces the wrong result or panics. If\n     /// debug assertions are enabled, a panic is guaranteed.\n     ///\n-    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n-    ///\n     /// # Panics\n     ///\n     /// The returned iterator might panic if the to-be-returned index would\n-    /// overflow a `usize`.\n+    /// overflow a [`usize`].\n+    ///\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    /// [`usize`]: ../../std/primitive.usize.html\n+    /// [`zip()`]: #method.zip\n     ///\n     /// # Examples\n     ///\n@@ -607,12 +624,13 @@ pub trait Iterator {\n     /// Adds a [`peek()`] method to an iterator. See its documentation for\n     /// more information.\n     ///\n-    /// Note that the underlying iterator is still advanced when `peek` is\n+    /// Note that the underlying iterator is still advanced when [`peek()`] is\n     /// called for the first time: In order to retrieve the next element,\n-    /// `next` is called on the underlying iterator, hence any side effects of\n-    /// the `next` method will occur.\n+    /// [`next()`] is called on the underlying iterator, hence any side effects of\n+    /// the [`next()`] method will occur.\n     ///\n     /// [`peek()`]: struct.Peekable.html#method.peek\n+    /// [`next()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n     ///\n     /// # Examples\n     ///\n@@ -894,12 +912,12 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n-    /// [`map()`]: #method.map\n-    ///\n     /// Another way of thinking about `flat_map()`: [`map()`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n     /// iterator for each element.\n     ///\n+    /// [`map()`]: #method.map\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -921,11 +939,14 @@ pub trait Iterator {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n-    /// Creates an iterator which ends after the first `None`.\n+    /// Creates an iterator which ends after the first [`None`].\n     ///\n-    /// After an iterator returns `None`, future calls may or may not yield\n-    /// `Some(T)` again. `fuse()` adapts an iterator, ensuring that after a\n-    /// `None` is given, it will always return `None` forever.\n+    /// After an iterator returns [`None`], future calls may or may not yield\n+    /// [`Some(T)`] again. `fuse()` adapts an iterator, ensuring that after a\n+    /// [`None`] is given, it will always return [`None`] forever.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`Some(T)`]: ../../std/option/enum.Option.html#variant.Some\n     ///\n     /// # Examples\n     ///\n@@ -1082,19 +1103,15 @@ pub trait Iterator {\n     /// library, used in a variety of contexts.\n     ///\n     /// The most basic pattern in which `collect()` is used is to turn one\n-    /// collection into another. You take a collection, call `iter()` on it,\n+    /// collection into another. You take a collection, call [`iter()`] on it,\n     /// do a bunch of transformations, and then `collect()` at the end.\n     ///\n     /// One of the keys to `collect()`'s power is that many things you might\n     /// not think of as 'collections' actually are. For example, a [`String`]\n     /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n-    /// be thought of as single `Result<Collection<T>, E>`. See the examples\n+    /// be thought of as single [`Result`]`<Collection<T>, E>`. See the examples\n     /// below for more.\n     ///\n-    /// [`String`]: ../../std/string/struct.String.html\n-    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-    /// [`char`]: ../../std/primitive.char.html\n-    ///\n     /// Because `collect()` is so general, it can cause problems with type\n     /// inference. As such, `collect()` is one of the few times you'll see\n     /// the syntax affectionately known as the 'turbofish': `::<>`. This\n@@ -1172,7 +1189,7 @@ pub trait Iterator {\n     /// assert_eq!(\"hello\", hello);\n     /// ```\n     ///\n-    /// If you have a list of [`Result<T, E>`]s, you can use `collect()` to\n+    /// If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n     /// see if any of them failed:\n     ///\n     /// ```\n@@ -1190,6 +1207,11 @@ pub trait Iterator {\n     /// // gives us the list of answers\n     /// assert_eq!(Ok(vec![1, 3]), result);\n     /// ```\n+    ///\n+    /// [`iter()`]: ../../std/iter/trait.Iterator.html#tymethod.next\n+    /// [`String`]: ../../std/string/struct.String.html\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`Result`]: ../../std/result/enum.Result.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n@@ -1281,6 +1303,8 @@ pub trait Iterator {\n     /// use a `for` loop with a list of things to build up a result. Those\n     /// can be turned into `fold()`s:\n     ///\n+    /// [`for`]: ../../book/loops.html#for\n+    ///\n     /// ```\n     /// let numbers = [1, 2, 3, 4, 5];\n     ///\n@@ -1414,8 +1438,8 @@ pub trait Iterator {\n     ///\n     /// `find()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, and if any of them return\n-    /// `true`, then `find()` returns `Some(element)`. If they all return\n-    /// `false`, it returns `None`.\n+    /// `true`, then `find()` returns [`Some(element)`]. If they all return\n+    /// `false`, it returns [`None`].\n     ///\n     /// `find()` is short-circuiting; in other words, it will stop processing\n     /// as soon as the closure returns `true`.\n@@ -1425,6 +1449,9 @@ pub trait Iterator {\n     /// argument is a double reference. You can see this effect in the\n     /// examples below, with `&&x`.\n     ///\n+    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1465,16 +1492,16 @@ pub trait Iterator {\n     ///\n     /// `position()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, and if one of them\n-    /// returns `true`, then `position()` returns `Some(index)`. If all of\n-    /// them return `false`, it returns `None`.\n+    /// returns `true`, then `position()` returns [`Some(index)`]. If all of\n+    /// them return `false`, it returns [`None`].\n     ///\n     /// `position()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so if there are more\n-    /// than `usize::MAX` non-matching elements, it either produces the wrong\n+    /// than [`usize::MAX`] non-matching elements, it either produces the wrong\n     /// result or panics. If debug assertions are enabled, a panic is\n     /// guaranteed.\n     ///\n@@ -1483,6 +1510,10 @@ pub trait Iterator {\n     /// This function might panic if the iterator has more than `usize::MAX`\n     /// non-matching elements.\n     ///\n+    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1528,11 +1559,14 @@ pub trait Iterator {\n     /// `rposition()` takes a closure that returns `true` or `false`. It applies\n     /// this closure to each element of the iterator, starting from the end,\n     /// and if one of them returns `true`, then `rposition()` returns\n-    /// `Some(index)`. If all of them return `false`, it returns `None`.\n+    /// [`Some(index)`]. If all of them return `false`, it returns [`None`].\n     ///\n     /// `rposition()` is short-circuiting; in other words, it will stop\n     /// processing as soon as it finds a `true`.\n     ///\n+    /// [`Some(index)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1798,11 +1832,13 @@ pub trait Iterator {\n         (ts, us)\n     }\n \n-    /// Creates an iterator which `clone()`s all of its elements.\n+    /// Creates an iterator which [`clone()`]s all of its elements.\n     ///\n     /// This is useful when you have an iterator over `&T`, but you need an\n     /// iterator over `T`.\n     ///\n+    /// [`clone()`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1827,10 +1863,12 @@ pub trait Iterator {\n \n     /// Repeats an iterator endlessly.\n     ///\n-    /// Instead of stopping at `None`, the iterator will instead start again,\n+    /// Instead of stopping at [`None`], the iterator will instead start again,\n     /// from the beginning. After iterating again, it will start at the\n     /// beginning again. And again. And again. Forever.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1862,7 +1900,7 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// When calling `sum` and a primitive integer type is being returned, this\n+    /// When calling `sum()` and a primitive integer type is being returned, this\n     /// method will panic if the computation overflows and debug assertions are\n     /// enabled.\n     ///\n@@ -1890,7 +1928,7 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// When calling `product` and a primitive integer type is being returned,\n+    /// When calling `product()` and a primitive integer type is being returned,\n     /// method will panic if the computation overflows and debug assertions are\n     /// enabled.\n     ///"}, {"sha": "3cf32d1a559196d02c8048147beb1b8509528584", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -350,6 +350,21 @@ macro_rules! try {\n ///\n /// assert_eq!(w, b\"testformatted arguments\");\n /// ```\n+///\n+/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n+/// implementing either, as objects do not typically implement both. However, the module must\n+/// import the traits qualified so their names do not conflict:\n+///\n+/// ```\n+/// use std::fmt::Write as FmtWrite;\n+/// use std::io::Write as IoWrite;\n+///\n+/// let mut s = String::new();\n+/// let mut v = Vec::new();\n+/// write!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n+/// write!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n+/// assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! write {\n@@ -394,6 +409,21 @@ macro_rules! write {\n ///\n /// assert_eq!(&w[..], \"test\\nformatted arguments\\n\".as_bytes());\n /// ```\n+///\n+/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n+/// implementing either, as objects do not typically implement both. However, the module must\n+/// import the traits qualified so their names do not conflict:\n+///\n+/// ```\n+/// use std::fmt::Write as FmtWrite;\n+/// use std::io::Write as IoWrite;\n+///\n+/// let mut s = String::new();\n+/// let mut v = Vec::new();\n+/// writeln!(&mut s, \"{} {}\", \"abc\", 123).unwrap(); // uses fmt::Write::write_fmt\n+/// writeln!(&mut v, \"s = {:?}\", s).unwrap(); // uses io::Write::write_fmt\n+/// assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! writeln {"}, {"sha": "5ee9fecfb21b3ce0d9b70aead5a85a72da01c546", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -95,7 +95,8 @@ pub mod __internal {\n     pub trait Registry {\n         fn register_custom_derive(&mut self,\n                                   trait_name: &str,\n-                                  expand: fn(TokenStream) -> TokenStream);\n+                                  expand: fn(TokenStream) -> TokenStream,\n+                                  attributes: &[&'static str]);\n     }\n \n     // Emulate scoped_thread_local!() here essentially"}, {"sha": "50a478fcc2fd91d8da5b6e6bd6ecdbbe01de571f", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::ops::Index;\n use std::hash::Hash;\n@@ -24,7 +24,7 @@ use super::{DepNode, DepGraph};\n pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n     phantom: PhantomData<M>,\n     graph: DepGraph,\n-    map: FnvHashMap<M::Key, M::Value>,\n+    map: FxHashMap<M::Key, M::Value>,\n }\n \n pub trait DepTrackingMapConfig {\n@@ -38,7 +38,7 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         DepTrackingMap {\n             phantom: PhantomData,\n             graph: graph,\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n "}, {"sha": "8657a3e5a587899f80ebb536847bcb8f8a9a9f0c", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::fmt::Debug;\n use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n     nodes: Vec<DepNode<D>>,\n-    indices: FnvHashMap<DepNode<D>, IdIndex>,\n-    edges: FnvHashSet<(IdIndex, IdIndex)>,\n+    indices: FxHashMap<DepNode<D>, IdIndex>,\n+    edges: FxHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n \n@@ -46,8 +46,8 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     pub fn new() -> DepGraphEdges<D> {\n         DepGraphEdges {\n             nodes: vec![],\n-            indices: FnvHashMap(),\n-            edges: FnvHashSet(),\n+            indices: FxHashMap(),\n+            edges: FxHashSet(),\n             open_nodes: Vec::new()\n         }\n     }"}, {"sha": "2637d34c5c56e569d91a3e1bcff2ad47310efa50", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n@@ -34,19 +34,19 @@ struct DepGraphData {\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n-    previous_work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    previous_work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n \n     /// Work-products that we generate in this run.\n-    work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+    work_products: RefCell<FxHashMap<Arc<WorkProductId>, WorkProduct>>,\n }\n \n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n             data: Rc::new(DepGraphData {\n                 thread: DepGraphThreadData::new(enabled),\n-                previous_work_products: RefCell::new(FnvHashMap()),\n-                work_products: RefCell::new(FnvHashMap()),\n+                previous_work_products: RefCell::new(FxHashMap()),\n+                work_products: RefCell::new(FxHashMap()),\n             })\n         }\n     }\n@@ -117,7 +117,7 @@ impl DepGraph {\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n-    pub fn work_products(&self) -> Ref<FnvHashMap<Arc<WorkProductId>, WorkProduct>> {\n+    pub fn work_products(&self) -> Ref<FxHashMap<Arc<WorkProductId>, WorkProduct>> {\n         self.data.work_products.borrow()\n     }\n }"}, {"sha": "4c791f9655342e8fae1ad00a057766e67037f6f4", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -17,15 +17,15 @@ use super::DepNode;\n \n pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n     pub graph: Graph<DepNode<D>, ()>,\n-    pub indices: FnvHashMap<DepNode<D>, NodeIndex>,\n+    pub indices: FxHashMap<DepNode<D>, NodeIndex>,\n }\n \n impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n     pub fn new(nodes: &[DepNode<D>],\n                edges: &[(DepNode<D>, DepNode<D>)])\n                -> DepGraphQuery<D> {\n         let mut graph = Graph::new();\n-        let mut indices = FnvHashMap();\n+        let mut indices = FxHashMap();\n         for node in nodes {\n             indices.insert(node.clone(), graph.next_node_index());\n             graph.add_node(node.clone());"}, {"sha": "38157c7e565646c45b21a5dc985ad32606c56998", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n@@ -22,7 +22,7 @@ use util::nodemap::NodeMap;\n #[derive(Clone)]\n pub struct Definitions {\n     data: Vec<DefData>,\n-    key_map: FnvHashMap<DefKey, DefIndex>,\n+    key_map: FxHashMap<DefKey, DefIndex>,\n     node_map: NodeMap<DefIndex>,\n }\n \n@@ -219,7 +219,7 @@ impl Definitions {\n     pub fn new() -> Definitions {\n         Definitions {\n             data: vec![],\n-            key_map: FnvHashMap(),\n+            key_map: FxHashMap(),\n             node_map: NodeMap(),\n         }\n     }"}, {"sha": "cbd3e39f8703aa9735fc433a13870fcc1785af61", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -33,7 +33,7 @@ pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, respan, Spanned};\n@@ -1605,4 +1605,4 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n \n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n-pub type GlobMap = NodeMap<FnvHashSet<Name>>;\n+pub type GlobMap = NodeMap<FxHashSet<Name>>;"}, {"sha": "30e18a4c569b2fa7093c9b53b66aeb7c8cea8e81", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -32,7 +32,7 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use std::collections::hash_map::Entry;\n \n use super::InferCtxt;\n@@ -41,7 +41,7 @@ use super::unify_key::ToType;\n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n-    freshen_map: FnvHashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -50,7 +50,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n-            freshen_map: FnvHashMap(),\n+            freshen_map: FxHashMap(),\n         }\n     }\n "}, {"sha": "737ce8bdf681daf25cd0b3dc30e3888b9d1b3623", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -24,7 +24,7 @@ use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax_pos::Span;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n pub struct HrMatchResult<U> {\n     pub value: U,\n@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Map each skolemized region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n             // skolemized regions from `skol_map`.)\n-            let skol_resolution_map: FnvHashMap<_, _> =\n+            let skol_resolution_map: FxHashMap<_, _> =\n                 skol_map\n                 .iter()\n                 .map(|(&br, &skol)| {\n@@ -158,7 +158,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // `skol_map`. There should always be a representative if things\n             // are properly well-formed.\n             let mut unconstrained_regions = vec![];\n-            let skol_representatives: FnvHashMap<_, _> =\n+            let skol_representatives: FxHashMap<_, _> =\n                 skol_resolution_map\n                 .iter()\n                 .map(|(&skol, &(br, ref regions))| {\n@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                              r0: &'tcx ty::Region)\n                                              -> &'tcx ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n@@ -364,8 +364,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion,\n-                                                                &'tcx ty::Region>,\n+                                             a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n                                              r0: &'tcx ty::Region)\n@@ -434,7 +433,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n         fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                       span: Span,\n-                                      a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                      a_map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>,\n                                       r: &'tcx ty::Region) -> &'tcx ty::Region\n         {\n             for (a_br, a_r) in a_map {\n@@ -457,7 +456,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+                           map: &FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, &r)| match *r {\n@@ -504,7 +503,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        snapshot: &CombinedSnapshot,\n                        r: &'tcx ty::Region,\n                        directions: TaintDirections)\n-                       -> FnvHashSet<&'tcx ty::Region> {\n+                       -> FxHashSet<&'tcx ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -568,7 +567,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let escaping_types =\n             self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n \n-        let mut escaping_region_vars = FnvHashSet();\n+        let mut escaping_region_vars = FxHashSet();\n         for ty in &escaping_types {\n             self.tcx.collect_regions(ty, &mut escaping_region_vars);\n         }\n@@ -764,7 +763,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FnvHashMap<&'tcx ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FxHashMap<&'tcx ty::Region, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {\n@@ -837,7 +836,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                           snapshot: &CombinedSnapshot)\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n-        let skol_regions: FnvHashSet<_> = skol_map.values().cloned().collect();\n+        let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized("}, {"sha": "ebafd206e26e293e1dff442946ecd5efcaaa2d0e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -39,7 +39,7 @@ use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n@@ -134,7 +134,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // the set of predicates on which errors have been reported, to\n     // avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FnvHashSet<traits::TraitErrorKey<'tcx>>>,\n+    pub reported_trait_errors: RefCell<FxHashSet<traits::TraitErrorKey<'tcx>>>,\n \n     // Sadly, the behavior of projection varies a bit depending on the\n     // stage of compilation. The specifics are given in the\n@@ -170,7 +170,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = FnvHashMap<ty::BoundRegion, &'tcx ty::Region>;\n+pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n /// Why did we require that the two types be related?\n ///\n@@ -492,7 +492,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashSet()),\n             projection_mode: Reveal::NotSpecializable,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n@@ -531,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             parameter_environment: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashSet()),\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n@@ -1530,7 +1530,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions("}, {"sha": "95ce8d39ff488b0c7fc099d60528988f94b4ed37", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -23,7 +23,7 @@ use middle::region::CodeExtent;\n use super::Constraint;\n use infer::SubregionOrigin;\n use infer::region_inference::RegionVarBindings;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n@@ -122,8 +122,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n-    map: &'a FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FnvHashMap<Node, usize>,\n+    map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n+    node_ids: FxHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n-        let mut node_ids = FnvHashMap();\n+        let mut node_ids = FxHashMap();\n         {\n             let mut add_node = |node| {\n                 if let Vacant(e) = node_ids.entry(node) {\n@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        let mut set = FnvHashSet();\n+        let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n         }\n@@ -261,7 +261,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub type ConstraintMap<'tcx> = FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n+pub type ConstraintMap<'tcx> = FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,"}, {"sha": "af6f2c50e72fc2b0ebfbeefb59f76c99811ec4b3", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -19,7 +19,7 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n@@ -213,7 +213,7 @@ impl SameRegions {\n     }\n }\n \n-pub type CombineMap<'tcx> = FnvHashMap<TwoRegions<'tcx>, RegionVid>;\n+pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -222,7 +222,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n+    constraints: RefCell<FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n@@ -248,7 +248,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FnvHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -305,14 +305,14 @@ impl TaintDirections {\n \n struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FnvHashSet<&'tcx ty::Region>\n+    regions: FxHashSet<&'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n            initial_region: &'tcx ty::Region)\n            -> Self {\n-        let mut regions = FnvHashSet();\n+        let mut regions = FxHashSet();\n         regions.insert(initial_region);\n         TaintSet { directions: directions, regions: regions }\n     }\n@@ -362,7 +362,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n         }\n     }\n \n-    fn into_set(self) -> FnvHashSet<&'tcx ty::Region> {\n+    fn into_set(self) -> FxHashSet<&'tcx ty::Region> {\n         self.regions\n     }\n \n@@ -393,11 +393,11 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n             values: RefCell::new(None),\n-            constraints: RefCell::new(FnvHashMap()),\n+            constraints: RefCell::new(FxHashMap()),\n             verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(FnvHashSet()),\n-            lubs: RefCell::new(FnvHashMap()),\n-            glbs: RefCell::new(FnvHashMap()),\n+            givens: RefCell::new(FxHashSet()),\n+            lubs: RefCell::new(FxHashMap()),\n+            glbs: RefCell::new(FxHashMap()),\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n             undo_log: RefCell::new(Vec::new()),\n@@ -547,7 +547,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FnvHashSet<&'tcx ty::Region>,\n+                          skols: &FxHashSet<&'tcx ty::Region>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -601,7 +601,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint<'tcx>(skols: &FnvHashSet<&'tcx ty::Region>,\n+        fn kill_constraint<'tcx>(skols: &FxHashSet<&'tcx ty::Region>,\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n@@ -905,7 +905,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                    mark: &RegionSnapshot,\n                    r0: &'tcx Region,\n                    directions: TaintDirections)\n-                   -> FnvHashSet<&'tcx ty::Region> {\n+                   -> FxHashSet<&'tcx ty::Region> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n@@ -1414,13 +1414,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                 dup_vec: &mut [u32])\n                                 -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n         struct WalkState<'tcx> {\n-            set: FnvHashSet<RegionVid>,\n+            set: FxHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n             result: Vec<RegionAndOrigin<'tcx>>,\n             dup_found: bool,\n         }\n         let mut state = WalkState {\n-            set: FnvHashSet(),\n+            set: FxHashSet(),\n             stack: vec![orig_node_idx],\n             result: Vec::new(),\n             dup_found: false,"}, {"sha": "9cc2337e3dd1ede9f0d16879f0d978a35ad00fe4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -33,7 +33,7 @@ use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::cmp;\n use std::default::Default as StdDefault;\n@@ -64,18 +64,18 @@ pub struct LintStore {\n     late_passes: Option<Vec<LateLintPassObject>>,\n \n     /// Lints indexed by name.\n-    by_name: FnvHashMap<String, TargetLint>,\n+    by_name: FxHashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n-    levels: FnvHashMap<LintId, LevelSource>,\n+    levels: FxHashMap<LintId, LevelSource>,\n \n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n-    lint_groups: FnvHashMap<&'static str, (Vec<LintId>, bool)>,\n+    lint_groups: FxHashMap<&'static str, (Vec<LintId>, bool)>,\n \n     /// Extra info for future incompatibility lints, descibing the\n     /// issue or RFC that caused the incompatibility.\n-    future_incompatible: FnvHashMap<LintId, FutureIncompatibleInfo>,\n+    future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n \n     /// Maximum level a lint can be\n     lint_cap: Option<Level>,\n@@ -171,10 +171,10 @@ impl LintStore {\n             lints: vec![],\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n-            by_name: FnvHashMap(),\n-            levels: FnvHashMap(),\n-            future_incompatible: FnvHashMap(),\n-            lint_groups: FnvHashMap(),\n+            by_name: FxHashMap(),\n+            levels: FxHashMap(),\n+            future_incompatible: FxHashMap(),\n+            lint_groups: FxHashMap(),\n             lint_cap: None,\n         }\n     }\n@@ -304,8 +304,8 @@ impl LintStore {\n                 Err(FindLintError::Removed) => { }\n                 Err(_) => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n-                                                 .collect::<FnvHashMap<&'static str,\n-                                                                       Vec<LintId>>>()\n+                                                 .collect::<FxHashMap<&'static str,\n+                                                                      Vec<LintId>>>()\n                                                  .get(&lint_name[..]) {\n                         Some(v) => {\n                             v.iter()"}, {"sha": "7fc698fdbebf5150da582891e22fd75920686862", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -22,7 +22,7 @@ use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId};\n use lint;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n use syntax::attr;\n@@ -48,7 +48,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n+    live_symbols: Box<FxHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n-            live_symbols: box FnvHashSet(),\n+            live_symbols: box FxHashSet(),\n             struct_has_extern_repr: false,\n             ignore_non_const_paths: false,\n             inherited_pub_visibility: false,\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn mark_live_symbols(&mut self) {\n-        let mut scanned = FnvHashSet();\n+        let mut scanned = FxHashSet();\n         while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n@@ -396,7 +396,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n-                       -> Box<FnvHashSet<ast::NodeId>> {\n+                       -> Box<FxHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -414,7 +414,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    live_symbols: Box<FnvHashSet<ast::NodeId>>,\n+    live_symbols: Box<FxHashSet<ast::NodeId>>,\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {"}, {"sha": "c658f47ec1be0dbbfa58913ec02427b23d754d1b", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -66,7 +66,7 @@ use hir::def_id::CrateNum;\n use session;\n use session::config;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n@@ -80,7 +80,7 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = FnvHashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = FxHashMap<config::CrateType, DependencyList>;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Linkage {\n@@ -149,7 +149,7 @@ fn calculate_type(sess: &session::Session,\n         config::CrateTypeProcMacro => {},\n     }\n \n-    let mut formats = FnvHashMap();\n+    let mut formats = FxHashMap();\n \n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n@@ -240,7 +240,7 @@ fn calculate_type(sess: &session::Session,\n fn add_library(sess: &session::Session,\n                cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n+               m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library"}, {"sha": "3e7de79246b667b59b41ac7a0f3fdbd9d573757f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -27,7 +27,7 @@ use session::Session;\n use hir::def_id::DefId;\n use ty;\n use middle::weak_lang_items;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -146,7 +146,7 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n \n     session: &'a Session,\n \n-    item_refs: FnvHashMap<&'static str, usize>,\n+    item_refs: FxHashMap<&'static str, usize>,\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n@@ -169,7 +169,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     pub fn new(session: &'a Session, ast_map: &'a hir_map::Map<'tcx>)\n                -> LanguageItemCollector<'a, 'tcx> {\n-        let mut item_refs = FnvHashMap();\n+        let mut item_refs = FxHashMap();\n \n         $( item_refs.insert($name, $variant as usize); )*\n "}, {"sha": "1376886968f74a4b9535569bbe8133f774a32e5d", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,7 +12,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use util::nodemap::{DefIdSet, FnvHashMap};\n+use util::nodemap::{DefIdSet, FxHashMap};\n \n use std::hash::Hash;\n use std::fmt;\n@@ -35,7 +35,7 @@ pub enum AccessLevel {\n // Accessibility levels for reachable HIR nodes\n #[derive(Clone)]\n pub struct AccessLevels<Id = NodeId> {\n-    pub map: FnvHashMap<Id, AccessLevel>\n+    pub map: FxHashMap<Id, AccessLevel>\n }\n \n impl<Id: Hash + Eq> AccessLevels<Id> {"}, {"sha": "9898ec7597d90ca9d493a1a4876e7072278d6283", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -22,7 +22,7 @@ use hir::def_id::DefId;\n use ty::{self, TyCtxt};\n use middle::privacy;\n use session::config;\n-use util::nodemap::{NodeSet, FnvHashSet};\n+use util::nodemap::{NodeSet, FxHashSet};\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n-        let mut scanned = FnvHashSet();\n+        let mut scanned = FxHashSet();\n         loop {\n             let search_item = match self.worklist.pop() {\n                 Some(item) => item,"}, {"sha": "8d51fda0cf2b1fa27dbcd1fba91764a9a6f8e86e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -19,7 +19,7 @@\n use dep_graph::DepNode;\n use hir::map as ast_map;\n use session::Session;\n-use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n use std::cell::RefCell;\n@@ -251,7 +251,7 @@ impl CodeExtent {\n /// The region maps encode information about region relationships.\n pub struct RegionMaps {\n     code_extents: RefCell<Vec<CodeExtentData>>,\n-    code_extent_interner: RefCell<FnvHashMap<CodeExtentData, CodeExtent>>,\n+    code_extent_interner: RefCell<FxHashMap<CodeExtentData, CodeExtent>>,\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n@@ -1217,7 +1217,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n \n     let maps = RegionMaps {\n         code_extents: RefCell::new(vec![]),\n-        code_extent_interner: RefCell::new(FnvHashMap()),\n+        code_extent_interner: RefCell::new(FxHashMap()),\n         scope_map: RefCell::new(vec![]),\n         var_map: RefCell::new(NodeMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),"}, {"sha": "e6d960735299c069aac21a156bac913b4dc2ce0b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -31,7 +31,7 @@ use syntax::parse::token::keywords;\n use syntax_pos::Span;\n use util::nodemap::NodeMap;\n \n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fx::FxHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind};\n@@ -847,13 +847,13 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n                                generics: &hir::Generics) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n-    let mut constrained_by_input = ConstrainedCollector { regions: FnvHashSet() };\n+    let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n     for arg in &decl.inputs {\n         constrained_by_input.visit_ty(&arg.ty);\n     }\n \n     let mut appears_in_output = AllCollector {\n-        regions: FnvHashSet(),\n+        regions: FxHashSet(),\n         impl_trait: false\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n@@ -866,7 +866,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     // Subtle point: because we disallow nested bindings, we can just\n     // ignore binders here and scrape up all names we see.\n     let mut appears_in_where_clause = AllCollector {\n-        regions: FnvHashSet(),\n+        regions: FxHashSet(),\n         impl_trait: false\n     };\n     for ty_param in generics.ty_params.iter() {\n@@ -926,7 +926,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     return;\n \n     struct ConstrainedCollector {\n-        regions: FnvHashSet<ast::Name>,\n+        regions: FxHashSet<ast::Name>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -961,7 +961,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     struct AllCollector {\n-        regions: FnvHashSet<ast::Name>,\n+        regions: FxHashSet<ast::Name>,\n         impl_trait: bool\n     }\n "}, {"sha": "f1755c82b8cbd3f59b7fa2851556b613ac758ef6", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -27,7 +27,7 @@ use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n use syntax::attr::{self, Stability, Deprecation};\n-use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n+use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n use hir::{Item, Generics, StructField, Variant, PatKind};\n@@ -102,7 +102,7 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FnvHashMap<CrateNum, bool>\n+    staged_api: FxHashMap<CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index.\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> Index<'tcx> {\n             }\n         }\n \n-        let mut staged_api = FnvHashMap();\n+        let mut staged_api = FxHashMap();\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FnvHashMap<InternedString, attr::StabilityLevel> {\n+                                          -> FxHashMap<InternedString, attr::StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -367,7 +367,7 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     let mut checker = Checker {\n         tcx: tcx,\n         active_features: active_features,\n-        used_features: FnvHashMap(),\n+        used_features: FxHashMap(),\n         in_skip_block: 0,\n     };\n     intravisit::walk_crate(&mut checker, tcx.map.krate());\n@@ -377,8 +377,8 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FnvHashSet<InternedString>,\n-    used_features: FnvHashMap<InternedString, attr::StabilityLevel>,\n+    active_features: FxHashSet<InternedString>,\n+    used_features: FxHashMap<InternedString, attr::StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -746,10 +746,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FnvHashMap<InternedString,\n-                                                                      attr::StabilityLevel>) {\n+                                       lib_features_used: &FxHashMap<InternedString,\n+                                                                     attr::StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n-    let mut remaining_lib_features: FnvHashMap<InternedString, Span>\n+    let mut remaining_lib_features: FxHashMap<InternedString, Span>\n         = declared_lib_features.clone().into_iter().collect();\n \n     fn format_stable_since_msg(version: &str) -> String {"}, {"sha": "16522a73f56a514fa2b551f47545edc00014753f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -793,7 +793,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     remark: Passes = (SomePasses(Vec::new()), parse_passes, [UNTRACKED],\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n     no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n-        \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n+        \"the --no-stack-check flag is deprecated and does nothing\"),\n     debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n         \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n          2 = full debug info with variable and type information\"),"}, {"sha": "724b32d2cd7150e5aa377555921f04dc034fccd7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -17,7 +17,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n use ty::tls;\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n@@ -78,7 +78,7 @@ pub struct Session {\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n     /// that have been set once, but should not be set again, in order to avoid\n     /// redundantly verbose output (Issue #24690).\n-    pub one_time_diagnostics: RefCell<FnvHashSet<(lint::LintId, Span, String)>>,\n+    pub one_time_diagnostics: RefCell<FxHashSet<(lint::LintId, Span, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n@@ -603,12 +603,12 @@ pub fn build_session_(sopts: config::Options,\n         working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n-        one_time_diagnostics: RefCell::new(FnvHashSet()),\n+        one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n-        dependency_formats: RefCell::new(FnvHashMap()),\n+        dependency_formats: RefCell::new(FxHashMap()),\n         crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),"}, {"sha": "3522c738c160c524e562cc1d1466ee21a655265a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -33,7 +33,7 @@ use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n use std::cmp;\n use std::fmt;\n@@ -252,7 +252,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let generic_map = def.generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n-                    }).collect::<FnvHashMap<String, String>>();\n+                    }).collect::<FxHashMap<String, String>>();\n                     let parser = Parser::new(&istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {\n@@ -647,7 +647,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             \"the trait `{}` cannot be made into an object\", trait_str\n         ));\n \n-        let mut reported_violations = FnvHashSet();\n+        let mut reported_violations = FxHashSet();\n         for violation in violations {\n             if !reported_violations.insert(violation.clone()) {\n                 continue;\n@@ -786,7 +786,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n         impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n@@ -807,7 +807,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n-                var_map: FnvHashMap()\n+                var_map: FxHashMap()\n             });\n \n             let cleaned_pred = super::project::normalize("}, {"sha": "6de93adce3f8302ee80a23f9e6dcb424b11ca520", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -18,7 +18,7 @@ use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashSet, NodeMap};\n+use util::nodemap::{FxHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -37,7 +37,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n }\n \n pub struct GlobalFulfilledPredicates<'tcx> {\n-    set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n+    set: FxHashSet<ty::PolyTraitPredicate<'tcx>>,\n     dep_graph: DepGraph,\n }\n \n@@ -673,7 +673,7 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n     pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {\n-            set: FnvHashSet(),\n+            set: FxHashSet(),\n             dep_graph: dep_graph,\n         }\n     }"}, {"sha": "5e3f78b1208d51d096d1c360065787b9743ed091", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -51,7 +51,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n struct InferredObligationsSnapshotVecDelegate<'tcx> {\n     phantom: PhantomData<&'tcx i32>,\n@@ -104,8 +104,8 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<ty::TraitRef<'tcx>,\n-                                SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+    hashmap: RefCell<FxHashMap<ty::TraitRef<'tcx>,\n+                               SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -306,7 +306,7 @@ enum EvaluationResult {\n \n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n+    hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n@@ -2937,15 +2937,15 @@ impl<'tcx> TraitObligation<'tcx> {\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n-            hashmap: RefCell::new(FnvHashMap())\n+            hashmap: RefCell::new(FxHashMap())\n         }\n     }\n }\n \n impl<'tcx> EvaluationCache<'tcx> {\n     pub fn new() -> EvaluationCache<'tcx> {\n         EvaluationCache {\n-            hashmap: RefCell::new(FnvHashMap())\n+            hashmap: RefCell::new(FxHashMap())\n         }\n     }\n }"}, {"sha": "4eef6944974c0a6962b41f12b96ee8baa050fe32", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -20,7 +20,7 @@\n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk, TypeOrigin};\n use middle::region;\n@@ -270,13 +270,13 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n pub struct SpecializesCache {\n-    map: FnvHashMap<(DefId, DefId), bool>\n+    map: FxHashMap<(DefId, DefId), bool>\n }\n \n impl SpecializesCache {\n     pub fn new() -> Self {\n         SpecializesCache {\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n "}, {"sha": "c746145474c758fa497aeace12e1efe9bd31c8a3", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -17,7 +17,7 @@ use traits::{self, Reveal};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::nodemap::{DefIdMap, FxHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -57,7 +57,7 @@ struct Children {\n     // the specialization graph.\n \n     /// Impls of the trait.\n-    nonblanket_impls: FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n+    nonblanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n \n     /// Blanket impls associated with the trait.\n     blanket_impls: Vec<DefId>,\n@@ -78,7 +78,7 @@ enum Inserted {\n impl<'a, 'gcx, 'tcx> Children {\n     fn new() -> Children {\n         Children {\n-            nonblanket_impls: FnvHashMap(),\n+            nonblanket_impls: FxHashMap(),\n             blanket_impls: vec![],\n         }\n     }"}, {"sha": "52830164d1d91d3ad77b137c3d664065b0bee367", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -13,7 +13,7 @@ use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use ty::outlives::Component;\n use util::common::ErrorReported;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n@@ -50,12 +50,12 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    set: FnvHashSet<ty::Predicate<'tcx>>,\n+    set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PredicateSet<'a, 'gcx, 'tcx> {\n-        PredicateSet { tcx: tcx, set: FnvHashSet() }\n+        PredicateSet { tcx: tcx, set: FxHashSet() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n@@ -272,7 +272,7 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     stack: Vec<DefId>,\n-    visited: FnvHashSet<DefId>,\n+    visited: FxHashSet<DefId>,\n }\n \n pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,"}, {"sha": "7ed4de38be97eef26ceedafc418491b0e27a2859", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::{DefId};\n use ty::{self, Ty, TyCtxt};\n use util::common::MemoizationMap;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::fmt;\n use std::ops;\n@@ -141,11 +141,11 @@ impl fmt::Debug for TypeContents {\n \n impl<'a, 'tcx> ty::TyS<'tcx> {\n     pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n-        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n+        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FxHashMap()));\n \n         fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            ty: Ty<'tcx>,\n-                           cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+                           cache: &mut FxHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n             // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n             // private cache for this walk.  This is needed in the case of cyclic"}, {"sha": "b19f935123519be1fd0893d29e8e1e700dd5a6ca", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -36,7 +36,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::TypedArena;\n@@ -96,26 +96,26 @@ pub struct CtxtInterners<'tcx> {\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n-    type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FnvHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n-    substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n-    region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n-    stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n-    layout: RefCell<FnvHashSet<&'tcx Layout>>,\n+    type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n+    type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n+    substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    bare_fn: RefCell<FxHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n+    stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n+    layout: RefCell<FxHashSet<&'tcx Layout>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arenas: arenas,\n-            type_: RefCell::new(FnvHashSet()),\n-            type_list: RefCell::new(FnvHashSet()),\n-            substs: RefCell::new(FnvHashSet()),\n-            bare_fn: RefCell::new(FnvHashSet()),\n-            region: RefCell::new(FnvHashSet()),\n-            stability: RefCell::new(FnvHashSet()),\n-            layout: RefCell::new(FnvHashSet())\n+            type_: RefCell::new(FxHashSet()),\n+            type_list: RefCell::new(FxHashSet()),\n+            substs: RefCell::new(FxHashSet()),\n+            bare_fn: RefCell::new(FxHashSet()),\n+            region: RefCell::new(FxHashSet()),\n+            stability: RefCell::new(FxHashSet()),\n+            layout: RefCell::new(FxHashSet())\n         }\n     }\n \n@@ -244,11 +244,11 @@ pub struct Tables<'tcx> {\n impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n-            node_types: FnvHashMap(),\n+            node_types: FxHashMap(),\n             item_substs: NodeMap(),\n             adjustments: NodeMap(),\n-            method_map: FnvHashMap(),\n-            upvar_capture_map: FnvHashMap(),\n+            method_map: FxHashMap(),\n+            upvar_capture_map: FxHashMap(),\n             closure_tys: DefIdMap(),\n             closure_kinds: DefIdMap(),\n             liberated_fn_sigs: NodeMap(),\n@@ -451,16 +451,16 @@ pub struct GlobalCtxt<'tcx> {\n     pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n \n     // Internal cache for metadata decoding. No need to track deps on this.\n-    pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n     // Cache for the type-contents routine. FIXME -- track deps?\n-    pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+    pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n \n     // FIXME no dep tracking, but we should be able to remove this\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n \n     // FIXME dep tracking -- should be harmless enough\n-    pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+    pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n@@ -571,7 +571,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub data_layout: TargetDataLayout,\n \n     /// Cache for layouts computed from types.\n-    pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n+    pub layout_cache: RefCell<FxHashMap<Ty<'tcx>, &'tcx Layout>>,\n \n     /// Used to prevent layout from recursing too deeply.\n     pub layout_depth: Cell<usize>,\n@@ -801,7 +801,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             types: common_types,\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n-            free_region_maps: RefCell::new(FnvHashMap()),\n+            free_region_maps: RefCell::new(FxHashMap()),\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n@@ -820,13 +820,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            rcache: RefCell::new(FnvHashMap()),\n-            tc_cache: RefCell::new(FnvHashMap()),\n+            rcache: RefCell::new(FxHashMap()),\n+            tc_cache: RefCell::new(FxHashMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             impl_or_trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n-            normalized_cache: RefCell::new(FnvHashMap()),\n+            normalized_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n@@ -846,7 +846,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: token::intern_and_get_ident(crate_name),\n             data_layout: data_layout,\n-            layout_cache: RefCell::new(FnvHashMap()),\n+            layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n        }, f)"}, {"sha": "354658ec4397f3cd284e1a4a580f6db642616b87", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -45,7 +45,7 @@ use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n@@ -225,7 +225,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FnvHashSet<&'tcx ty::Region>)\n+        region_set: &mut FxHashSet<&'tcx ty::Region>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n@@ -319,14 +319,14 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n-    map: FnvHashMap<ty::BoundRegion, &'tcx ty::Region>\n+    map: FxHashMap<ty::BoundRegion, &'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        -> (T, FxHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n@@ -390,22 +390,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(&self, value: &Binder<T>)\n-                                                     -> FnvHashSet<ty::BoundRegion>\n+                                                     -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         self.collect_late_bound_regions(value, true)\n     }\n \n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(&self, value: &Binder<T>)\n-                                                    -> FnvHashSet<ty::BoundRegion>\n+                                                    -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         self.collect_late_bound_regions(value, false)\n     }\n \n     fn collect_late_bound_regions<T>(&self, value: &Binder<T>, just_constraint: bool)\n-                                     -> FnvHashSet<ty::BoundRegion>\n+                                     -> FxHashSet<ty::BoundRegion>\n         where T : TypeFoldable<'tcx>\n     {\n         let mut collector = LateBoundRegionsCollector::new(just_constraint);\n@@ -450,7 +450,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n             tcx: tcx,\n             current_depth: 1,\n             fld_r: fld_r,\n-            map: FnvHashMap()\n+            map: FxHashMap()\n         }\n     }\n }\n@@ -650,15 +650,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n /// Collects all the late-bound regions it finds into a hash set.\n struct LateBoundRegionsCollector {\n     current_depth: u32,\n-    regions: FnvHashSet<ty::BoundRegion>,\n+    regions: FxHashSet<ty::BoundRegion>,\n     just_constrained: bool,\n }\n \n impl LateBoundRegionsCollector {\n     fn new(just_constrained: bool) -> Self {\n         LateBoundRegionsCollector {\n             current_depth: 1,\n-            regions: FnvHashSet(),\n+            regions: FxHashSet(),\n             just_constrained: just_constrained,\n         }\n     }"}, {"sha": "fcf9b5ff2730cbd5b4bd5285e179685b52696318", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -418,7 +418,7 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n+pub type MethodMap<'tcx> = FxHashMap<MethodCall, MethodCallee<'tcx>>;\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n@@ -650,7 +650,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: &'tcx ty::Region,\n }\n \n-pub type UpvarCaptureMap<'tcx> = FnvHashMap<UpvarId, UpvarCapture<'tcx>>;\n+pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n@@ -1251,10 +1251,10 @@ pub struct ParameterEnvironment<'tcx> {\n     pub free_id_outlive: CodeExtent,\n \n     /// A cache for `moves_by_default`.\n-    pub is_copy_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n \n     /// A cache for `type_is_sized`\n-    pub is_sized_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub is_sized_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n@@ -1267,8 +1267,8 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             free_id_outlive: self.free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2752,8 +2752,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             caller_bounds: Vec::new(),\n             implicit_region_bound: self.mk_region(ty::ReEmpty),\n             free_id_outlive: free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -2824,8 +2824,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n-            is_copy_cache: RefCell::new(FnvHashMap()),\n-            is_sized_cache: RefCell::new(FnvHashMap()),\n+            is_copy_cache: RefCell::new(FxHashMap()),\n+            is_sized_cache: RefCell::new(FxHashMap()),\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));"}, {"sha": "fc32029948388d3046d37672b55e440e12d3a225", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -16,7 +16,7 @@ use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::cell::{Cell, RefCell};\n use hir;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n@@ -55,7 +55,7 @@ pub struct TraitDef<'tcx> {\n \n     /// Impls of the trait.\n     nonblanket_impls: RefCell<\n-        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+        FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n     >,\n \n     /// Blanket impls associated with the trait.\n@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             unsafety: unsafety,\n             generics: generics,\n             trait_ref: trait_ref,\n-            nonblanket_impls: RefCell::new(FnvHashMap()),\n+            nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),"}, {"sha": "b1aeaeb48d144c771aca644a7780a699754d01c8", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -20,7 +20,7 @@ use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n@@ -594,7 +594,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: &ParameterEnvironment<'tcx>,\n                    bound: ty::BuiltinBound,\n-                   cache: &RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+                   cache: &RefCell<FxHashMap<Ty<'tcx>, bool>>,\n                    span: Span) -> bool\n     {\n         if self.has_param_types() || self.has_self_ty() {"}, {"sha": "b03011fcb216dbc4e783f695fde007bc384936b5", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,17 +15,17 @@\n use hir::def_id::DefId;\n use syntax::ast;\n \n-pub use rustc_data_structures::fnv::FnvHashMap;\n-pub use rustc_data_structures::fnv::FnvHashSet;\n+pub use rustc_data_structures::fx::FxHashMap;\n+pub use rustc_data_structures::fx::FxHashSet;\n \n-pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n-pub type DefIdMap<T> = FnvHashMap<DefId, T>;\n+pub type NodeMap<T> = FxHashMap<ast::NodeId, T>;\n+pub type DefIdMap<T> = FxHashMap<DefId, T>;\n \n-pub type NodeSet = FnvHashSet<ast::NodeId>;\n-pub type DefIdSet = FnvHashSet<DefId>;\n+pub type NodeSet = FxHashSet<ast::NodeId>;\n+pub type DefIdSet = FxHashSet<DefId>;\n \n-pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n-pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n-pub fn NodeSet() -> NodeSet { FnvHashSet() }\n-pub fn DefIdSet() -> DefIdSet { FnvHashSet() }\n+pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n+pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn NodeSet() -> NodeSet { FxHashSet() }\n+pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n "}, {"sha": "be85069db3135d7b1e2ce6218fc6cd0d5a2b1467", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -21,7 +21,7 @@ use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n@@ -63,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 env: &env,\n                 flow_inits: flow_inits,\n                 flow_uninits: flow_uninits,\n-                drop_flags: FnvHashMap(),\n+                drop_flags: FxHashMap(),\n                 patch: MirPatch::new(mir),\n             }.elaborate()\n         };\n@@ -118,7 +118,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n-    drop_flags: FnvHashMap<MovePathIndex, Local>,\n+    drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }\n "}, {"sha": "02064b52cb1fb2c24b264f621bc879294d29e021", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -11,7 +11,7 @@\n \n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::mir::*;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n \n use syntax::codemap::DUMMY_SP;\n@@ -181,7 +181,7 @@ pub struct MovePathLookup<'tcx> {\n     /// subsequent search so that it is solely relative to that\n     /// base-lvalue). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FnvHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n }\n \n struct MoveDataBuilder<'a, 'tcx: 'a> {\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                     locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n                         Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n                     }).collect(),\n-                    projections: FnvHashMap(),\n+                    projections: FxHashMap(),\n                 },\n                 move_paths: move_paths,\n                 path_map: path_map,"}, {"sha": "afc4ccef0cc0fe11278a9a35fc97f78d6ac7c304", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{FnvHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -41,7 +41,7 @@ pub struct MoveData<'tcx> {\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FnvHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n+    pub path_map: RefCell<FxHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FnvHashMap()),\n+            path_map: RefCell::new(FxHashMap()),\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),"}, {"sha": "831d21b831042cd6d5f2a386e70183749c2453b6", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -17,7 +17,7 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n@@ -160,7 +160,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// associated types to get field types.\n     pub wild_pattern: &'a Pattern<'tcx>,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n-    pub byte_array_map: FnvHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n+    pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             tcx: tcx,\n             wild_pattern: &wild_pattern,\n             pattern_arena: &pattern_arena,\n-            byte_array_map: FnvHashMap(),\n+            byte_array_map: FxHashMap(),\n         })\n     }\n "}, {"sha": "1fb7673521d880029037f94d529df6025b8fccf3", "filename": "src/librustc_data_structures/fx.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::{HashMap, HashSet};\n+use std::default::Default;\n+use std::hash::{Hasher, Hash, BuildHasherDefault};\n+use std::ops::BitXor;\n+\n+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n+pub type FxHashSet<V> = HashSet<V, BuildHasherDefault<FxHasher>>;\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashMap<K: Hash + Eq, V>() -> FxHashMap<K, V> {\n+    HashMap::default()\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn FxHashSet<V: Hash + Eq>() -> FxHashSet<V> {\n+    HashSet::default()\n+}\n+\n+/// A speedy hash algorithm for use within rustc. The hashmap in libcollections\n+/// by default uses SipHash which isn't quite as speedy as we want. In the\n+/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// non-cryptographic hash.\n+///\n+/// This is the same as the algorithm used by Firefox -- which is a homespun\n+/// one not based on any widely-known algorithm -- though modified to produce\n+/// 64-bit hash values instead of 32-bit hash values. It consistently\n+/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n+/// similar or slightly worse than FNV, but the speed of the hash function\n+/// itself is much higher because it works on up to 8 bytes at a time.\n+pub struct FxHasher {\n+    hash: usize\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+const K: usize = 0x9e3779b9;\n+#[cfg(target_pointer_width = \"64\")]\n+const K: usize = 0x517cc1b727220a95;\n+\n+impl Default for FxHasher {\n+    #[inline]\n+    fn default() -> FxHasher {\n+        FxHasher { hash: 0 }\n+    }\n+}\n+\n+impl FxHasher {\n+    #[inline]\n+    fn add_to_hash(&mut self, i: usize) {\n+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n+    }\n+}\n+\n+impl Hasher for FxHasher {\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        for byte in bytes {\n+            let i = *byte;\n+            self.add_to_hash(i as usize);\n+        }\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+        self.add_to_hash((i >> 32) as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.add_to_hash(i);\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hash as u64\n+    }\n+}\n+\n+pub fn hash<T: Hash>(v: &T) -> u64 {\n+    let mut state = FxHasher::default();\n+    v.hash(&mut state);\n+    state.finish()\n+}"}, {"sha": "fdcbec6bac11a97f3867f70ce14eababca389755", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -60,6 +60,7 @@ pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;\n+pub mod fx;\n pub mod tuple_slice;\n pub mod veccell;\n pub mod control_flow_graph;"}, {"sha": "a46238309bb46a87e16b16ee72ee1505cbb65b65", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,7 +15,7 @@\n //! in the first place). See README.md for a general overview of how\n //! to use this class.\n \n-use fnv::{FnvHashMap, FnvHashSet};\n+use fx::{FxHashMap, FxHashSet};\n \n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n@@ -68,9 +68,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n     /// A cache of predicates that have been successfully completed.\n-    done_cache: FnvHashSet<O::Predicate>,\n+    done_cache: FxHashSet<O::Predicate>,\n     /// An cache of the nodes in `nodes`, indexed by predicate.\n-    waiting_cache: FnvHashMap<O::Predicate, NodeIndex>,\n+    waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n     /// A list of the obligations added in snapshots, to allow\n     /// for their removal.\n     cache_list: Vec<O::Predicate>,\n@@ -158,8 +158,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n             snapshots: vec![],\n-            done_cache: FnvHashSet(),\n-            waiting_cache: FnvHashMap(),\n+            done_cache: FxHashSet(),\n+            waiting_cache: FxHashMap(),\n             cache_list: vec![],\n             scratch: Some(vec![]),\n         }"}, {"sha": "cd7143ad3ce8470d05826d005c44c9ff3efeae3a", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fnv::FnvHashMap;\n+use fx::FxHashMap;\n use std::hash::Hash;\n use std::ops;\n use std::mem;\n@@ -19,7 +19,7 @@ mod test;\n pub struct SnapshotMap<K, V>\n     where K: Hash + Clone + Eq\n {\n-    map: FnvHashMap<K, V>,\n+    map: FxHashMap<K, V>,\n     undo_log: Vec<UndoLog<K, V>>,\n }\n \n@@ -40,7 +40,7 @@ impl<K, V> SnapshotMap<K, V>\n {\n     pub fn new() -> Self {\n         SnapshotMap {\n-            map: FnvHashMap(),\n+            map: FxHashMap(),\n             undo_log: vec![],\n         }\n     }"}, {"sha": "6551bad3bc92edc730e6a4d7a9dba098419a7453", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -75,7 +75,7 @@ use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n use rustc::session::config::nightly_options;\n-use rustc::session::early_error;\n+use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc_metadata::locator;\n@@ -1011,6 +1011,11 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n         return None;\n     }\n \n+    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n+        early_warn(ErrorOutputType::default(),\n+                   \"the --no-stack-check flag is deprecated and does nothing\");\n+    }\n+\n     if cg_flags.contains(&\"passes=list\".to_string()) {\n         unsafe {\n             ::llvm::LLVMRustPrintPasses();"}, {"sha": "37477da755c9fb24226b42936c91aa27fdaba7fe", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -48,7 +48,7 @@ use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n@@ -244,7 +244,7 @@ fn dump_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph<'q>(FnvHashSet<&'q DepNode<DefId>>,\n+pub struct GraphvizDepGraph<'q>(FxHashSet<&'q DepNode<DefId>>,\n                                 Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>);\n \n impl<'a, 'tcx, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n@@ -288,7 +288,7 @@ impl<'a, 'tcx, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n-                -> Option<FnvHashSet<&'q DepNode<DefId>>>\n+                -> Option<FxHashSet<&'q DepNode<DefId>>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n@@ -300,9 +300,9 @@ fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n }\n \n fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &Option<FnvHashSet<&'q DepNode<DefId>>>,\n-                    targets: &Option<FnvHashSet<&'q DepNode<DefId>>>)\n-                    -> FnvHashSet<&'q DepNode<DefId>>\n+                    sources: &Option<FxHashSet<&'q DepNode<DefId>>>,\n+                    targets: &Option<FxHashSet<&'q DepNode<DefId>>>)\n+                    -> FxHashSet<&'q DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -318,11 +318,11 @@ fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                  starts: &FnvHashSet<&'q DepNode<DefId>>,\n+                  starts: &FxHashSet<&'q DepNode<DefId>>,\n                   direction: Direction)\n-                  -> FnvHashSet<&'q DepNode<DefId>>\n+                  -> FxHashSet<&'q DepNode<DefId>>\n {\n-    let mut set = FnvHashSet();\n+    let mut set = FxHashSet();\n     for &start in starts {\n         debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n         if set.insert(start) {\n@@ -342,9 +342,9 @@ fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &FnvHashSet<&'q DepNode<DefId>>,\n-                    targets: &FnvHashSet<&'q DepNode<DefId>>)\n-                    -> FnvHashSet<&'q DepNode<DefId>>\n+                    sources: &FxHashSet<&'q DepNode<DefId>>,\n+                    targets: &FxHashSet<&'q DepNode<DefId>>)\n+                    -> FxHashSet<&'q DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -410,7 +410,7 @@ fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n }\n \n fn filter_edges<'q>(query: &'q DepGraphQuery<DefId>,\n-                    nodes: &FnvHashSet<&'q DepNode<DefId>>)\n+                    nodes: &FxHashSet<&'q DepNode<DefId>>)\n                     -> Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>\n {\n     query.edges()"}, {"sha": "58a21529974106bb65c538acda91c9fa7e185a13", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -35,7 +35,7 @@ use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n \n@@ -51,21 +51,21 @@ mod caching_codemap_view;\n pub mod hasher;\n \n pub struct IncrementalHashesMap {\n-    hashes: FnvHashMap<DepNode<DefId>, Fingerprint>,\n+    hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n \n     // These are the metadata hashes for the current crate as they were stored\n     // during the last compilation session. They are only loaded if\n     // -Z query-dep-graph was specified and are needed for auto-tests using\n     // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n     // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, Fingerprint>>,\n+    pub prev_metadata_hashes: RefCell<FxHashMap<DefId, Fingerprint>>,\n }\n \n impl IncrementalHashesMap {\n     pub fn new() -> IncrementalHashesMap {\n         IncrementalHashesMap {\n-            hashes: FnvHashMap(),\n-            prev_metadata_hashes: RefCell::new(FnvHashMap()),\n+            hashes: FxHashMap(),\n+            prev_metadata_hashes: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "f0e4f4f99ef08e2977bbf069262e598db9d8bb8a", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -13,7 +13,7 @@\n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use std::sync::Arc;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use ich::Fingerprint;\n \n use super::directory::DefPathIndex;\n@@ -106,7 +106,7 @@ pub struct SerializedMetadataHashes {\n     /// is only populated if -Z query-dep-graph is specified. It will be\n     /// empty otherwise. Importing crates are perfectly happy with just having\n     /// the DefIndex.\n-    pub index_map: FnvHashMap<DefIndex, DefPathIndex>\n+    pub index_map: FxHashMap<DefIndex, DefPathIndex>\n }\n \n /// The hash for some metadata that (when saving) will be exported"}, {"sha": "69b9be12de46c2de35a2438896546a3b81f80db8", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -47,7 +47,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n@@ -67,7 +67,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let dirty_inputs: FnvHashSet<DepNode<DefId>> =\n+    let dirty_inputs: FxHashSet<DepNode<DefId>> =\n         dirty_inputs.iter()\n                    .filter_map(|d| retraced.map(d))\n                    .collect();\n@@ -84,7 +84,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n-    dirty_inputs: FnvHashSet<DepNode<DefId>>,\n+    dirty_inputs: FxHashSet<DepNode<DefId>>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n@@ -187,8 +187,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  prev_metadata_hashes: &FnvHashMap<DefId, Fingerprint>,\n-                                  current_metadata_hashes: &FnvHashMap<DefId, Fingerprint>) {\n+                                  prev_metadata_hashes: &FxHashMap<DefId, Fingerprint>,\n+                                  current_metadata_hashes: &FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n@@ -205,8 +205,8 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    prev_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n-    current_metadata_hashes: &'m FnvHashMap<DefId, Fingerprint>,\n+    prev_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n+    current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n }\n \n impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "ca9c119202322038911521a217625f81e2fc56c6", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -120,7 +120,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n use rustc_data_structures::flock;\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use std::ffi::OsString;\n use std::fs as std_fs;\n@@ -195,7 +195,7 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n     debug!(\"crate-dir: {}\", crate_dir.display());\n     try!(create_dir(tcx.sess, &crate_dir, \"crate\"));\n \n-    let mut source_directories_already_tried = FnvHashSet();\n+    let mut source_directories_already_tried = FxHashSet();\n \n     loop {\n         // Generate a session directory of the form:\n@@ -490,7 +490,7 @@ fn delete_session_dir_lock_file(sess: &Session,\n /// Find the most recent published session directory that is not in the\n /// ignore-list.\n fn find_source_directory(crate_dir: &Path,\n-                         source_directories_already_tried: &FnvHashSet<PathBuf>)\n+                         source_directories_already_tried: &FxHashSet<PathBuf>)\n                          -> Option<PathBuf> {\n     let iter = crate_dir.read_dir()\n                         .unwrap() // FIXME\n@@ -500,7 +500,7 @@ fn find_source_directory(crate_dir: &Path,\n }\n \n fn find_source_directory_in_iter<I>(iter: I,\n-                                    source_directories_already_tried: &FnvHashSet<PathBuf>)\n+                                    source_directories_already_tried: &FxHashSet<PathBuf>)\n                                     -> Option<PathBuf>\n     where I: Iterator<Item=PathBuf>\n {\n@@ -704,8 +704,8 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n \n     // First do a pass over the crate directory, collecting lock files and\n     // session directories\n-    let mut session_directories = FnvHashSet();\n-    let mut lock_files = FnvHashSet();\n+    let mut session_directories = FxHashSet();\n+    let mut lock_files = FxHashSet();\n \n     for dir_entry in try!(crate_directory.read_dir()) {\n         let dir_entry = match dir_entry {\n@@ -731,7 +731,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Now map from lock files to session directories\n-    let lock_file_to_session_dir: FnvHashMap<String, Option<String>> =\n+    let lock_file_to_session_dir: FxHashMap<String, Option<String>> =\n         lock_files.into_iter()\n                   .map(|lock_file_name| {\n                         assert!(lock_file_name.ends_with(LOCK_FILE_EXT));\n@@ -774,7 +774,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Filter out `None` directories\n-    let lock_file_to_session_dir: FnvHashMap<String, String> =\n+    let lock_file_to_session_dir: FxHashMap<String, String> =\n         lock_file_to_session_dir.into_iter()\n                                 .filter_map(|(lock_file_name, directory_name)| {\n                                     directory_name.map(|n| (lock_file_name, n))\n@@ -898,7 +898,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n }\n \n fn all_except_most_recent(deletion_candidates: Vec<(SystemTime, PathBuf, Option<flock::Lock>)>)\n-                          -> FnvHashMap<PathBuf, Option<flock::Lock>> {\n+                          -> FxHashMap<PathBuf, Option<flock::Lock>> {\n     let most_recent = deletion_candidates.iter()\n                                          .map(|&(timestamp, ..)| timestamp)\n                                          .max();\n@@ -909,7 +909,7 @@ fn all_except_most_recent(deletion_candidates: Vec<(SystemTime, PathBuf, Option<\n                            .map(|(_, path, lock)| (path, lock))\n                            .collect()\n     } else {\n-        FnvHashMap()\n+        FxHashMap()\n     }\n }\n \n@@ -946,19 +946,19 @@ fn test_all_except_most_recent() {\n             (UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\"), None),\n             (UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\"), None),\n             (UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\"), None),\n-        ]).keys().cloned().collect::<FnvHashSet<PathBuf>>(),\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n         vec![\n             PathBuf::from(\"1\"),\n             PathBuf::from(\"2\"),\n             PathBuf::from(\"3\"),\n             PathBuf::from(\"4\"),\n-        ].into_iter().collect::<FnvHashSet<PathBuf>>()\n+        ].into_iter().collect::<FxHashSet<PathBuf>>()\n     );\n \n     assert_eq!(all_except_most_recent(\n         vec![\n-        ]).keys().cloned().collect::<FnvHashSet<PathBuf>>(),\n-        FnvHashSet()\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n+        FxHashSet()\n     );\n }\n \n@@ -973,7 +973,7 @@ fn test_timestamp_serialization() {\n \n #[test]\n fn test_find_source_directory_in_iter() {\n-    let already_visited = FnvHashSet();\n+    let already_visited = FxHashSet();\n \n     // Find newest\n     assert_eq!(find_source_directory_in_iter("}, {"sha": "73311ee96c5308712fae79aa667076efcbb20d63", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,7 +12,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n@@ -26,8 +26,8 @@ use super::file_format;\n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n-    item_metadata_hashes: FnvHashMap<DefId, Fingerprint>,\n-    crate_hashes: FnvHashMap<CrateNum, Svh>,\n+    item_metadata_hashes: FxHashMap<DefId, Fingerprint>,\n+    crate_hashes: FxHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -37,8 +37,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         HashContext {\n             tcx: tcx,\n             incremental_hashes_map: incremental_hashes_map,\n-            item_metadata_hashes: FnvHashMap(),\n-            crate_hashes: FnvHashMap(),\n+            item_metadata_hashes: FxHashMap(),\n+            crate_hashes: FxHashMap(),\n         }\n     }\n "}, {"sha": "12bf74c95116d508b197daf711a824071bcd511a", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::fs;\n@@ -30,7 +30,7 @@ use super::hash::*;\n use super::fs::*;\n use super::file_format;\n \n-pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n+pub type DirtyNodes = FxHashSet<DepNode<DefPathIndex>>;\n \n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n@@ -183,7 +183,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Compute which work-products have an input that has changed or\n     // been removed. Put the dirty ones into a set.\n-    let mut dirty_target_nodes = FnvHashSet();\n+    let mut dirty_target_nodes = FxHashSet();\n     for &(raw_source_node, ref target_node) in &retraced_edges {\n         if dirty_raw_source_nodes.contains(raw_source_node) {\n             if !dirty_target_nodes.contains(target_node) {\n@@ -239,7 +239,7 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          retraced: &RetracedDefIdDirectory)\n                          -> DirtyNodes {\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n-    let mut dirty_nodes = FnvHashSet();\n+    let mut dirty_nodes = FxHashSet();\n \n     for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n@@ -270,7 +270,7 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     dirty_target_nodes: &FnvHashSet<DepNode<DefId>>) {\n+                                     dirty_target_nodes: &FxHashSet<DepNode<DefId>>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n         if dirty_target_nodes.contains(&DepNode::WorkProduct(swp.id.clone())) {\n@@ -314,7 +314,7 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n \n fn load_prev_metadata_hashes(tcx: TyCtxt,\n                              retraced: &RetracedDefIdDirectory,\n-                             output: &mut FnvHashMap<DefId, Fingerprint>) {\n+                             output: &mut FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return\n     }"}, {"sha": "e1968ce8d7b6ad541234ed9ff990b36022941633", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n \n use super::hash::*;\n@@ -23,11 +23,11 @@ pub struct Predecessors<'query> {\n     //   nodes.\n     // - Values: transitive predecessors of the key that are hashable\n     //   (e.g., HIR nodes, input meta-data nodes)\n-    pub inputs: FnvHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n+    pub inputs: FxHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n \n     // - Keys: some hashable node\n     // - Values: the hash thereof\n-    pub hashes: FnvHashMap<&'query DepNode<DefId>, Fingerprint>,\n+    pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n }\n \n impl<'q> Predecessors<'q> {\n@@ -37,7 +37,7 @@ impl<'q> Predecessors<'q> {\n         let all_nodes = query.graph.all_nodes();\n         let tcx = hcx.tcx;\n \n-        let inputs: FnvHashMap<_, _> = all_nodes.iter()\n+        let inputs: FxHashMap<_, _> = all_nodes.iter()\n             .enumerate()\n             .filter(|&(_, node)| match node.data {\n                 DepNode::WorkProduct(_) => true,\n@@ -60,7 +60,7 @@ impl<'q> Predecessors<'q> {\n             })\n             .collect();\n \n-        let mut hashes = FnvHashMap();\n+        let mut hashes = FxHashMap();\n         for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n             hashes.entry(input)\n                   .or_insert_with(|| hcx.hash(input).unwrap());"}, {"sha": "289eebb2162083a1ee44de841288d95e5b45b918", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::hash::Hash;\n@@ -46,7 +46,7 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let query = tcx.dep_graph.query();\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let preds = Predecessors::new(&query, &mut hcx);\n-    let mut current_metadata_hashes = FnvHashMap();\n+    let mut current_metadata_hashes = FxHashMap();\n \n     // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n     //            since metadata-encoding might add new entries to the\n@@ -186,7 +186,7 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               preds: &Predecessors,\n                               builder: &mut DefIdDirectoryBuilder,\n-                              current_metadata_hashes: &mut FnvHashMap<DefId, Fingerprint>,\n+                              current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     // For each `MetaData(X)` node where `X` is local, accumulate a\n@@ -198,10 +198,10 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n     // (I initially wrote this with an iterator, but it seemed harder to read.)\n     let mut serialized_hashes = SerializedMetadataHashes {\n         hashes: vec![],\n-        index_map: FnvHashMap()\n+        index_map: FxHashMap()\n     };\n \n-    let mut def_id_hashes = FnvHashMap();\n+    let mut def_id_hashes = FxHashMap();\n \n     for (&target, sources) in &preds.inputs {\n         let def_id = match *target {"}, {"sha": "48471282672adf8563ba7d0de76ad0ca99fa21ab", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -18,7 +18,7 @@ use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n@@ -428,7 +428,7 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self, cache: &mut FnvHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n+    fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n         use self::FfiResult::*;\n         let cx = self.cx.tcx;\n \n@@ -639,7 +639,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_associated_type(&ty);\n \n-        match self.check_type_for_ffi(&mut FnvHashSet(), ty) {\n+        match self.check_type_for_ffi(&mut FxHashSet(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiUnsafe(s) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp, s);"}, {"sha": "d3fd638d6b5ff5a3f29056e8449008e0e9b2ebba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -11,15 +11,15 @@\n use rustc::hir::pat_util;\n use rustc::ty;\n use rustc::ty::adjustment;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -42,7 +42,7 @@ impl UnusedMut {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n-        let mut mutables = FnvHashMap();\n+        let mut mutables = FxHashMap();\n         for p in pats {\n             pat_util::pat_bindings(p, |mode, id, _, path1| {\n                 let name = path1.node;\n@@ -245,7 +245,7 @@ impl LateLintPass for UnusedAttributes {\n         debug!(\"checking attribute: {:?}\", attr);\n \n         // Note that check_name() marks the attribute as used if it matches.\n-        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n+        for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n                     debug!(\"{:?} is Whitelisted\", name);\n@@ -267,7 +267,7 @@ impl LateLintPass for UnusedAttributes {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter()\n+            let known_crate = BUILTIN_ATTRIBUTES.iter()\n                 .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n                 .is_some();\n "}, {"sha": "4385f024b4139ce727c3fd99a9fcf77ee92e95cf", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -22,7 +22,7 @@ use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc::hir::map::Definitions;\n \n use std::cell::{RefCell, Cell};\n@@ -50,7 +50,7 @@ pub struct CrateLoader<'a> {\n     pub sess: &'a Session,\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n-    foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n+    foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n }\n \n@@ -148,7 +148,7 @@ impl<'a> CrateLoader<'a> {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n-            foreign_item_map: FnvHashMap(),\n+            foreign_item_map: FxHashMap(),\n             local_crate_name: local_crate_name.to_owned(),\n         }\n     }\n@@ -401,7 +401,7 @@ impl<'a> CrateLoader<'a> {\n     fn update_extern_crate(&mut self,\n                            cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n-                           visited: &mut FnvHashSet<(CrateNum, bool)>)\n+                           visited: &mut FxHashSet<(CrateNum, bool)>)\n     {\n         if !visited.insert((cnum, extern_crate.direct)) { return }\n \n@@ -442,7 +442,7 @@ impl<'a> CrateLoader<'a> {\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         let deps = crate_root.crate_deps.decode(metadata);\n-        let map: FnvHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n+        let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, ..) = self.resolve_crate(root,\n                                                         &dep.name.as_str(),\n@@ -624,8 +624,12 @@ impl<'a> CrateLoader<'a> {\n         impl Registry for MyRegistrar {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream) {\n-                let derive = SyntaxExtension::CustomDerive(Box::new(CustomDerive::new(expand)));\n+                                      expand: fn(TokenStream) -> TokenStream,\n+                                      attributes: &[&'static str]) {\n+                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let derive = SyntaxExtension::CustomDerive(\n+                    Box::new(CustomDerive::new(expand, attrs))\n+                );\n                 self.0.push((intern(trait_name), derive));\n             }\n         }\n@@ -1021,7 +1025,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         let extern_crate =\n             ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n-        self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n \n         loaded_macros"}, {"sha": "f452cc23b7330433d25fd4af3c7a47359a4f5691", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n+use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n@@ -76,7 +76,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub key_map: FnvHashMap<DefKey, DefIndex>,\n+    pub key_map: FxHashMap<DefKey, DefIndex>,\n \n     /// Flag if this crate is required by an rlib version of this crate, or in\n     /// other words whether it was explicitly linked to. An example of a crate\n@@ -94,7 +94,7 @@ pub struct CachedInlinedItem {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<CrateNum, Rc<CrateMetadata>>>,\n+    metas: RefCell<FxHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n@@ -110,15 +110,15 @@ impl CStore {\n     pub fn new(dep_graph: &DepGraph) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n-            metas: RefCell::new(FnvHashMap()),\n-            extern_mod_crate_map: RefCell::new(FnvHashMap()),\n+            metas: RefCell::new(FxHashMap()),\n+            extern_mod_crate_map: RefCell::new(FxHashMap()),\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n-            visible_parent_map: RefCell::new(FnvHashMap()),\n-            inlined_item_cache: RefCell::new(FnvHashMap()),\n-            defid_for_inlined_node: RefCell::new(FnvHashMap()),\n+            visible_parent_map: RefCell::new(FxHashMap()),\n+            inlined_item_cache: RefCell::new(FxHashMap()),\n+            defid_for_inlined_node: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "630b07744249b425652d02e60116d09acd98d47b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -17,7 +17,7 @@ use schema::*;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n@@ -432,7 +432,7 @@ impl<'a, 'tcx> MetadataBlob {\n \n     /// Go through each item in the metadata and create a map from that\n     /// item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n+    pub fn load_key_map(&self, index: LazySeq<Index>) -> FxHashMap<DefKey, DefIndex> {\n         index.iter_enumerated(self.raw_bytes())\n             .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n             .collect()"}, {"sha": "fb4fb507296287d8d8dc84b87bf87dbc0ac37cc2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -23,7 +23,7 @@ use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FnvHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n use std::hash::Hash;\n@@ -52,8 +52,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     reachable: &'a NodeSet,\n \n     lazy_state: LazyState,\n-    type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n-    predicate_shorthands: FnvHashMap<ty::Predicate<'tcx>, usize>,\n+    type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n+    predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n }\n \n macro_rules! encoder_methods {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                                       variant: &U,\n                                       map: M)\n                                       -> Result<(), <Self as Encoder>::Error>\n-        where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n+        where M: for<'b> Fn(&'b mut Self) -> &'b mut FxHashMap<T, usize>,\n               T: Clone + Eq + Hash,\n               U: Encodable\n     {\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FnvHashMap<DefId, Vec<DefIndex>>,\n+    impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n@@ -1165,7 +1165,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n-            impls: FnvHashMap(),\n+            impls: FxHashMap(),\n         };\n         self.tcx.map.krate().visit_all_items(&mut visitor);\n "}, {"sha": "c31b209768c38518441099b4fd164beeaad9a06d", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -221,7 +221,7 @@ use rustc::session::Session;\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n use rustc::util::common;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n@@ -430,7 +430,7 @@ impl<'a> Context<'a> {\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n-        let mut candidates = FnvHashMap();\n+        let mut candidates = FxHashMap();\n         let mut staticlibs = vec![];\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n@@ -469,7 +469,7 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n+                .or_insert_with(|| (FxHashMap(), FxHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n@@ -492,7 +492,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n-        let mut libraries = FnvHashMap();\n+        let mut libraries = FxHashMap();\n         for (_hash, (rlibs, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n@@ -544,7 +544,7 @@ impl<'a> Context<'a> {\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n     fn extract_one(&mut self,\n-                   m: FnvHashMap<PathBuf, PathKind>,\n+                   m: FxHashMap<PathBuf, PathKind>,\n                    flavor: CrateFlavor,\n                    slot: &mut Option<(Svh, MetadataBlob)>)\n                    -> Option<(PathBuf, PathKind)> {\n@@ -690,8 +690,8 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut rlibs = FnvHashMap();\n-        let mut dylibs = FnvHashMap();\n+        let mut rlibs = FxHashMap();\n+        let mut dylibs = FxHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {"}, {"sha": "b75e52fd4b10d99ce80988d1178da245847d443c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -13,7 +13,7 @@\n use std;\n \n use rustc_const_math::{ConstMathErr, Op};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n-                let fields_map: FnvHashMap<_, _> =\n+                let fields_map: FxHashMap<_, _> =\n                     fields.into_iter()\n                           .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n                           .collect();"}, {"sha": "786299c370d82f964243d1790413dd3822f39f0d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -14,7 +14,7 @@\n //! details.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{AdtDef, Ty};\n@@ -309,7 +309,7 @@ enum TestKind<'tcx> {\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n         options: Vec<ConstVal>,\n-        indices: FnvHashMap<ConstVal, usize>,\n+        indices: FxHashMap<ConstVal, usize>,\n     },\n \n     // test for equality"}, {"sha": "948ba7338cddb9800335e76aac567e686e05a741", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -18,7 +18,7 @@\n use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         // these maps are empty to start; cases are\n                         // added below in add_cases_to_switch\n                         options: vec![],\n-                        indices: FnvHashMap(),\n+                        indices: FxHashMap(),\n                     }\n                 }\n             }\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<ConstVal>,\n-                                     indices: &mut FnvHashMap<ConstVal, usize>)\n+                                     indices: &mut FxHashMap<ConstVal, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {"}, {"sha": "b5343975a9cdf39f1826fdba24bf4c6fa15048ab", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -94,7 +94,7 @@ use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::*;\n use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -140,7 +140,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FnvHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -298,7 +298,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             needs_cleanup: false,\n             drops: vec![],\n             free: None,\n-            cached_exits: FnvHashMap()\n+            cached_exits: FxHashMap()\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,"}, {"sha": "d6f514cfb913616b15d8176a584376529bdef3f7", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n use std::fs;\n@@ -122,10 +122,10 @@ enum Annotation {\n }\n \n fn scope_entry_exit_annotations(auxiliary: Option<&ScopeAuxiliaryVec>)\n-                                -> FnvHashMap<Location, Vec<Annotation>>\n+                                -> FxHashMap<Location, Vec<Annotation>>\n {\n     // compute scope/entry exit annotations\n-    let mut annotations = FnvHashMap();\n+    let mut annotations = FxHashMap();\n     if let Some(auxiliary) = auxiliary {\n         for (scope_id, auxiliary) in auxiliary.iter_enumerated() {\n             annotations.entry(auxiliary.dom)\n@@ -166,7 +166,7 @@ fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write,\n-                     annotations: &FnvHashMap<Location, Vec<Annotation>>)\n+                     annotations: &FxHashMap<Location, Vec<Annotation>>)\n                      -> io::Result<()> {\n     let data = &mir[block];\n \n@@ -217,7 +217,7 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n /// Returns the total number of variables printed.\n fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n-                    scope_tree: &FnvHashMap<VisibilityScope, Vec<VisibilityScope>>,\n+                    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n                     w: &mut Write,\n                     parent: VisibilityScope,\n                     depth: usize)\n@@ -283,7 +283,7 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     writeln!(w, \" {{\")?;\n \n     // construct a scope tree and write it out\n-    let mut scope_tree: FnvHashMap<VisibilityScope, Vec<VisibilityScope>> = FnvHashMap();\n+    let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n     for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n             scope_tree.entry(parent)"}, {"sha": "c4a8d34bda008c8fa6f4ef2494e793ff519a4c98", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n \n@@ -107,5 +107,5 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n #[derive(Default)]\n struct OptimizationList {\n-    and_stars: FnvHashSet<Location>,\n+    and_stars: FxHashSet<Location>,\n }"}, {"sha": "84cf85e2fc4e6d46ccc21a8336ce068220504ad0", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,7 +15,7 @@\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n use rustc::util::common::to_readable_str;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use syntax::ast::{self, NodeId, AttrId};\n use syntax::visit as ast_visit;\n use syntax_pos::Span;\n@@ -34,15 +34,15 @@ struct NodeData {\n \n struct StatCollector<'k> {\n     krate: Option<&'k hir::Crate>,\n-    data: FnvHashMap<&'static str, NodeData>,\n-    seen: FnvHashSet<Id>,\n+    data: FxHashMap<&'static str, NodeData>,\n+    seen: FxHashSet<Id>,\n }\n \n pub fn print_hir_stats(krate: &hir::Crate) {\n     let mut collector = StatCollector {\n         krate: Some(krate),\n-        data: FnvHashMap(),\n-        seen: FnvHashSet(),\n+        data: FxHashMap(),\n+        seen: FxHashSet(),\n     };\n     hir_visit::walk_crate(&mut collector, krate);\n     collector.print(\"HIR STATS\");\n@@ -51,8 +51,8 @@ pub fn print_hir_stats(krate: &hir::Crate) {\n pub fn print_ast_stats(krate: &ast::Crate, title: &str) {\n     let mut collector = StatCollector {\n         krate: None,\n-        data: FnvHashMap(),\n-        seen: FnvHashSet(),\n+        data: FxHashMap(),\n+        seen: FxHashSet(),\n     };\n     ast_visit::walk_crate(&mut collector, krate);\n     collector.print(title);"}, {"sha": "1e998a2a4d5b0e8d9532fa4a0ac0f9634dad97d9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::cstore::LoadedMacros;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -539,7 +539,7 @@ impl<'b> Resolver<'b> {\n                     self.invocations.insert(mark, invocation);\n                 }\n \n-                let mut macros: FnvHashMap<_, _> = macros.into_iter().map(|mut def| {\n+                let mut macros: FxHashMap<_, _> = macros.into_iter().map(|mut def| {\n                     def.body = mark_tts(&def.body, mark);\n                     let ext = macro_rules::compile(&self.session.parse_sess, &def);\n                     (def.ident.name, (def, Rc::new(ext)))"}, {"sha": "0c7c1a55a618207477adaa43032d33dfaf8f7b06", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -51,7 +51,7 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n-use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n@@ -108,7 +108,7 @@ enum ResolutionError<'a> {\n     /// error E0403: the name is already used for a type parameter in this type parameter list\n     NameAlreadyUsedInTypeParameterList(Name, &'a Span),\n     /// error E0404: is not a trait\n-    IsNotATrait(&'a str),\n+    IsNotATrait(&'a str, &'a str),\n     /// error E0405: use of undeclared trait name\n     UndeclaredTraitName(&'a str, SuggestedCandidates),\n     /// error E0407: method is not a member of trait\n@@ -223,13 +223,13 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n              err\n \n         }\n-        ResolutionError::IsNotATrait(name) => {\n+        ResolutionError::IsNotATrait(name, kind_name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0404,\n                                            \"`{}` is not a trait\",\n                                            name);\n-            err.span_label(span, &format!(\"not a trait\"));\n+            err.span_label(span, &format!(\"expected trait, found {}\", kind_name));\n             err\n         }\n         ResolutionError::UndeclaredTraitName(name, candidates) => {\n@@ -498,7 +498,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = FnvHashMap<Ident, BindingInfo>;\n+type BindingMap = FxHashMap<Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -555,7 +555,7 @@ impl<'a> Visitor for Resolver<'a> {\n         self.resolve_type(ty);\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n-        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0) {\n+        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0, None) {\n             Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n             Err(_) => {\n                 // error already reported\n@@ -703,14 +703,14 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: FnvHashMap<Ident, Def>,\n+    bindings: FxHashMap<Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n impl<'a> Rib<'a> {\n     fn new(kind: RibKind<'a>) -> Rib<'a> {\n         Rib {\n-            bindings: FnvHashMap(),\n+            bindings: FxHashMap(),\n             kind: kind,\n         }\n     }\n@@ -769,7 +769,7 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n     no_implicit_prelude: bool,\n \n@@ -794,7 +794,7 @@ impl<'a> ModuleS<'a> {\n             kind: kind,\n             normal_ancestor_id: None,\n             extern_crate_id: None,\n-            resolutions: RefCell::new(FnvHashMap()),\n+            resolutions: RefCell::new(FxHashMap()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -950,12 +950,12 @@ impl<'a> NameBinding<'a> {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: FnvHashMap<Name, PrimTy>,\n+    primitive_types: FxHashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n-        let mut table = PrimitiveTypeTable { primitive_types: FnvHashMap() };\n+        let mut table = PrimitiveTypeTable { primitive_types: FxHashMap() };\n \n         table.intern(\"bool\", TyBool);\n         table.intern(\"char\", TyChar);\n@@ -989,17 +989,17 @@ pub struct Resolver<'a> {\n \n     // Maps the node id of a statement to the expansions of the `macro_rules!`s\n     // immediately above the statement (if appropriate).\n-    macros_at_scope: FnvHashMap<NodeId, Vec<Mark>>,\n+    macros_at_scope: FxHashMap<NodeId, Vec<Mark>>,\n \n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n \n-    trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n+    trait_item_map: FxHashMap<(Name, DefId), bool /* is static method? */>,\n \n     // Names of fields of an item `DefId` accessible with dot syntax.\n     // Used for hints during error reporting.\n-    field_names: FnvHashMap<DefId, Vec<Name>>,\n+    field_names: FxHashMap<DefId, Vec<Name>>,\n \n     // All imports known to succeed or fail.\n     determined_imports: Vec<&'a ImportDirective<'a>>,\n@@ -1061,8 +1061,8 @@ pub struct Resolver<'a> {\n     // all imports, but only glob imports are actually interesting).\n     pub glob_map: GlobMap,\n \n-    used_imports: FnvHashSet<(NodeId, Namespace)>,\n-    used_crates: FnvHashSet<CrateNum>,\n+    used_imports: FxHashSet<(NodeId, Namespace)>,\n+    used_crates: FxHashSet<CrateNum>,\n     pub maybe_unused_trait_imports: NodeSet,\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n@@ -1075,12 +1075,12 @@ pub struct Resolver<'a> {\n \n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n-    macro_names: FnvHashSet<Name>,\n-    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n+    macro_names: FxHashSet<Name>,\n+    builtin_macros: FxHashMap<Name, Rc<SyntaxExtension>>,\n     lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n+    invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1206,23 +1206,23 @@ impl<'a> Resolver<'a> {\n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n \n-        let mut invocations = FnvHashMap();\n+        let mut invocations = FxHashMap();\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         Resolver {\n             session: session,\n \n             definitions: definitions,\n-            macros_at_scope: FnvHashMap(),\n+            macros_at_scope: FxHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n             graph_root: graph_root,\n             prelude: None,\n \n-            trait_item_map: FnvHashMap(),\n-            field_names: FnvHashMap(),\n+            trait_item_map: FxHashMap(),\n+            field_names: FxHashMap(),\n \n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),\n@@ -1248,8 +1248,8 @@ impl<'a> Resolver<'a> {\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            used_imports: FnvHashSet(),\n-            used_crates: FnvHashSet(),\n+            used_imports: FxHashSet(),\n+            used_crates: FxHashSet(),\n             maybe_unused_trait_imports: NodeSet(),\n \n             privacy_errors: Vec::new(),\n@@ -1266,8 +1266,8 @@ impl<'a> Resolver<'a> {\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n-            macro_names: FnvHashSet(),\n-            builtin_macros: FnvHashMap(),\n+            macro_names: FxHashSet(),\n+            builtin_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             invocations: invocations,\n         }\n@@ -1340,7 +1340,7 @@ impl<'a> Resolver<'a> {\n \n     fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n         if self.make_glob_map {\n-            self.glob_map.entry(id).or_insert_with(FnvHashSet).insert(name);\n+            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(name);\n         }\n     }\n \n@@ -1699,7 +1699,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::DefaultImpl(_, ref trait_ref) => {\n-                self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n+                self.with_optional_trait_ref(Some(trait_ref), |_, _| {}, None);\n             }\n             ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n                 self.resolve_implementation(generics,\n@@ -1803,7 +1803,7 @@ impl<'a> Resolver<'a> {\n         match type_parameters {\n             HasTypeParameters(generics, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = FnvHashMap();\n+                let mut seen_bindings = FxHashMap();\n                 for type_parameter in &generics.ty_params {\n                     let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n@@ -1867,7 +1867,7 @@ impl<'a> Resolver<'a> {\n         self.label_ribs.push(Rib::new(rib_kind));\n \n         // Add each argument to the rib.\n-        let mut bindings_list = FnvHashMap();\n+        let mut bindings_list = FxHashMap();\n         for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n \n@@ -1889,7 +1889,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_path: &Path,\n-                               path_depth: usize)\n+                               path_depth: usize,\n+                               generics: Option<&Generics>)\n                                -> Result<PathResolution, ()> {\n         self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n             match path_res.base_def {\n@@ -1902,8 +1903,16 @@ impl<'a> Resolver<'a> {\n             }\n \n             let mut err = resolve_struct_error(self, trait_path.span, {\n-                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth))\n+                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth),\n+                                             path_res.base_def.kind_name())\n             });\n+            if let Some(generics) = generics {\n+                if let Some(span) = generics.span_for_name(\n+                    &path_names_to_string(trait_path, path_depth)) {\n+\n+                    err.span_label(span, &\"type parameter defined here\");\n+                }\n+            }\n \n             // If it's a typedef, give a note\n             if let Def::TyAlias(..) = path_res.base_def {\n@@ -1948,15 +1957,20 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n+    fn with_optional_trait_ref<T, F>(&mut self,\n+                                     opt_trait_ref: Option<&TraitRef>,\n+                                     f: F,\n+                                     generics: Option<&Generics>)\n+        -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n     {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             if let Ok(path_res) = self.resolve_trait_reference(trait_ref.ref_id,\n                                                                &trait_ref.path,\n-                                                               0) {\n+                                                               0,\n+                                                               generics) {\n                 assert!(path_res.depth == 0);\n                 self.record_def(trait_ref.ref_id, path_res);\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n@@ -2044,7 +2058,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     });\n                 });\n-            });\n+            }, Some(&generics));\n         });\n     }\n \n@@ -2069,15 +2083,15 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FnvHashMap());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut binding_map = FnvHashMap();\n+        let mut binding_map = FxHashMap();\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n@@ -2137,7 +2151,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n-        let mut bindings_list = FnvHashMap();\n+        let mut bindings_list = FxHashMap();\n         for pattern in &arm.pats {\n             self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n@@ -2278,7 +2292,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut FnvHashMap<Ident, NodeId>)\n+                     bindings: &mut FxHashMap<Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2391,7 +2405,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut FnvHashMap<Ident, NodeId>) {\n+                       bindings: &mut FxHashMap<Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -2494,7 +2508,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 max_assoc_types = path.segments.len() - qself.position;\n                 // Make sure the trait is valid.\n-                let _ = self.resolve_trait_reference(id, path, max_assoc_types);\n+                let _ = self.resolve_trait_reference(id, path, max_assoc_types, None);\n             }\n             None => {\n                 max_assoc_types = path.segments.len();\n@@ -3048,7 +3062,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3065,7 +3079,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n@@ -3075,7 +3089,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FnvHashMap());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n@@ -3337,7 +3351,7 @@ impl<'a> Resolver<'a> {\n \n     fn report_errors(&mut self) {\n         self.report_shadowing_errors();\n-        let mut reported_spans = FnvHashSet();\n+        let mut reported_spans = FxHashSet();\n \n         for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n@@ -3369,7 +3383,7 @@ impl<'a> Resolver<'a> {\n             self.resolve_macro_name(scope, name);\n         }\n \n-        let mut reported_errors = FnvHashSet();\n+        let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n             if self.resolve_macro_name(binding.parent, binding.name).is_some() &&\n                reported_errors.insert((binding.name, binding.span)) {"}, {"sha": "e1b67d211a33328396c052798f6e8623e7bb2b82", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -759,7 +759,11 @@ fn docs_for_attrs(attrs: &[Attribute]) -> String {\n     for attr in attrs {\n         if attr.name() == doc {\n             if let Some(ref val) = attr.value_str() {\n-                result.push_str(&strip_doc_comment_decoration(val));\n+                if attr.node.is_sugared_doc {\n+                    result.push_str(&strip_doc_comment_decoration(val));\n+                } else {\n+                    result.push_str(val);\n+                }\n                 result.push('\\n');\n             }\n         }"}, {"sha": "d50669272f726bf0be560f5839cd2975d54b7097", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -79,7 +79,7 @@ use type_::Type;\n use type_of;\n use value::Value;\n use Disr;\n-use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -1318,7 +1318,7 @@ fn write_metadata(cx: &SharedCrateContext,\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  ccxs: &CrateContextList<'a, 'tcx>,\n                                  symbol_map: &SymbolMap<'tcx>,\n-                                 reachable: &FnvHashSet<&str>) {\n+                                 reachable: &FxHashSet<&str>) {\n     let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n@@ -1332,7 +1332,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n     // 'unsafe' because we are holding on to CStr's from the LLVM module within\n     // this block.\n     unsafe {\n-        let mut referenced_somewhere = FnvHashSet();\n+        let mut referenced_somewhere = FxHashSet();\n \n         // Collect all symbols that need to stay externally visible because they\n         // are referenced via a declaration in some other codegen unit.\n@@ -1353,7 +1353,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n \n         // Also collect all symbols for which we cannot adjust linkage, because\n         // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n-        let linkage_fixed_explicitly: FnvHashSet<_> = scx\n+        let linkage_fixed_explicitly: FxHashSet<_> = scx\n             .translation_items()\n             .borrow()\n             .iter()\n@@ -1862,7 +1862,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     }\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n-        let mut item_to_cgus = FnvHashMap();\n+        let mut item_to_cgus = FxHashMap();\n \n         for cgu in &codegen_units {\n             for (&trans_item, &linkage) in cgu.items() {"}, {"sha": "0480bb82a998e902396d78f98b282d1f0ec00875", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -19,7 +19,7 @@ use common::*;\n use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use libc::{c_uint, c_char};\n \n use std::borrow::Cow;\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Build version of path with cycles removed.\n \n                 // Pass 1: scan table mapping str -> rightmost pos.\n-                let mut mm = FnvHashMap();\n+                let mut mm = FxHashMap();\n                 let len = v.len();\n                 let mut i = 0;\n                 while i < len {"}, {"sha": "548554af9727f933b3fb2b8242be3bf99c73ab33", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -211,7 +211,7 @@ use context::SharedCrateContext;\n use common::{fulfill_obligation, type_is_sized};\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n-use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n+use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, type_to_string, def_id_to_string};\n \n@@ -228,15 +228,15 @@ pub struct InliningMap<'tcx> {\n     // that are potentially inlined by LLVM into the source.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n-    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n }\n \n impl<'tcx> InliningMap<'tcx> {\n \n     fn new() -> InliningMap<'tcx> {\n         InliningMap {\n-            index: FnvHashMap(),\n+            index: FxHashMap(),\n             targets: Vec::new(),\n         }\n     }\n@@ -269,15 +269,15 @@ impl<'tcx> InliningMap<'tcx> {\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n-                                                 -> (FnvHashSet<TransItem<'tcx>>,\n+                                                 -> (FxHashSet<TransItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n         let roots = collect_roots(scx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n-        let mut visited = FnvHashSet();\n+        let mut visited = FxHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut inlining_map = InliningMap::new();\n \n@@ -318,7 +318,7 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n // Collect all monomorphized translation items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n-                                   visited: &mut FnvHashSet<TransItem<'tcx>>,\n+                                   visited: &mut FxHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n                                    inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n@@ -1179,9 +1179,9 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n-                let overridden_methods: FnvHashSet<_> = items.iter()\n-                                                             .map(|item| item.name)\n-                                                             .collect();\n+                let overridden_methods: FxHashSet<_> = items.iter()\n+                                                            .map(|item| item.name)\n+                                                            .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;"}, {"sha": "264d4940c17f91d4a4ff3c7c3b5e9b09773587ab", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -32,7 +32,7 @@ use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n use symbol_map::SymbolMap;\n-use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -52,7 +52,7 @@ pub struct Stats {\n     pub n_inlines: Cell<usize>,\n     pub n_closures: Cell<usize>,\n     pub n_llvm_insns: Cell<usize>,\n-    pub llvm_insns: RefCell<FnvHashMap<String, usize>>,\n+    pub llvm_insns: RefCell<FxHashMap<String, usize>>,\n     // (ident, llvm-instructions)\n     pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n@@ -74,7 +74,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n \n     use_dll_storage_attrs: bool,\n \n-    translation_items: RefCell<FnvHashSet<TransItem<'tcx>>>,\n+    translation_items: RefCell<FxHashSet<TransItem<'tcx>>>,\n     trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n     project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n@@ -89,15 +89,15 @@ pub struct LocalCrateContext<'tcx> {\n     previous_work_product: Option<WorkProduct>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n-    needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n-    fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n+    needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n+    fn_pointer_shims: RefCell<FxHashMap<Ty<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n-    instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n+    instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n+    vtables: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n-    const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n+    const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a ValueRef holding a *T,\n@@ -107,48 +107,48 @@ pub struct LocalCrateContext<'tcx> {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    const_unsized: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    const_globals: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const values\n-    const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n+    const_values: RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    statics: RefCell<FnvHashMap<ValueRef, DefId>>,\n+    statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n-    impl_method_cache: RefCell<FnvHashMap<(DefId, ast::Name), DefId>>,\n+    impl_method_cache: RefCell<FxHashMap<(DefId, ast::Name), DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n-    closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+    closure_bare_wrapper_cache: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n     /// to constants.)\n     statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n \n-    lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n-    type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    llsizingtypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n     eh_unwind_resume: Cell<Option<ValueRef>>,\n     rust_try_fn: Cell<Option<ValueRef>>,\n \n-    intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n+    intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n     /// Number of LLVM instructions translated into this `LocalCrateContext`.\n     /// This is used to perform some basic load-balancing to keep all LLVM\n@@ -502,12 +502,12 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                 n_inlines: Cell::new(0),\n                 n_closures: Cell::new(0),\n                 n_llvm_insns: Cell::new(0),\n-                llvm_insns: RefCell::new(FnvHashMap()),\n+                llvm_insns: RefCell::new(FxHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            translation_items: RefCell::new(FnvHashSet()),\n+            translation_items: RefCell::new(FxHashSet()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n             project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n@@ -557,7 +557,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         self.use_dll_storage_attrs\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n \n@@ -612,32 +612,32 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n-                needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n-                fn_pointer_shims: RefCell::new(FnvHashMap()),\n-                drop_glues: RefCell::new(FnvHashMap()),\n-                instances: RefCell::new(FnvHashMap()),\n-                vtables: RefCell::new(FnvHashMap()),\n-                const_cstr_cache: RefCell::new(FnvHashMap()),\n-                const_unsized: RefCell::new(FnvHashMap()),\n-                const_globals: RefCell::new(FnvHashMap()),\n-                const_values: RefCell::new(FnvHashMap()),\n+                needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n+                fn_pointer_shims: RefCell::new(FxHashMap()),\n+                drop_glues: RefCell::new(FxHashMap()),\n+                instances: RefCell::new(FxHashMap()),\n+                vtables: RefCell::new(FxHashMap()),\n+                const_cstr_cache: RefCell::new(FxHashMap()),\n+                const_unsized: RefCell::new(FxHashMap()),\n+                const_globals: RefCell::new(FxHashMap()),\n+                const_values: RefCell::new(FxHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n-                statics: RefCell::new(FnvHashMap()),\n-                impl_method_cache: RefCell::new(FnvHashMap()),\n-                closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n+                statics: RefCell::new(FxHashMap()),\n+                impl_method_cache: RefCell::new(FxHashMap()),\n+                closure_bare_wrapper_cache: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n-                lltypes: RefCell::new(FnvHashMap()),\n-                llsizingtypes: RefCell::new(FnvHashMap()),\n-                type_hashcodes: RefCell::new(FnvHashMap()),\n+                lltypes: RefCell::new(FxHashMap()),\n+                llsizingtypes: RefCell::new(FxHashMap()),\n+                type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                closure_vals: RefCell::new(FnvHashMap()),\n+                closure_vals: RefCell::new(FxHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: Cell::new(None),\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n-                intrinsics: RefCell::new(FnvHashMap()),\n+                intrinsics: RefCell::new(FxHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n                 symbol_map: symbol_map,\n@@ -794,16 +794,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, bool>> {\n+    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n \n-    pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+    pub fn fn_pointer_shims(&self) -> &RefCell<FxHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local().fn_pointer_shims\n     }\n \n     pub fn drop_glues<'a>(&'a self)\n-                          -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n+                          -> &'a RefCell<FxHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n         &self.local().drop_glues\n     }\n \n@@ -815,61 +815,61 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.sess().cstore.defid_for_inlined_node(node_id)\n     }\n \n-    pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+    pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().instances\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local().vtables\n     }\n \n-    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<InternedString, ValueRef>> {\n+    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<InternedString, ValueRef>> {\n         &self.local().const_cstr_cache\n     }\n \n-    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().const_unsized\n     }\n \n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n-                                                                ValueRef>> {\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n+                                                               ValueRef>> {\n         &self.local().const_values\n     }\n \n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local().extern_const_values\n     }\n \n-    pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n+    pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n         &self.local().statics\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n-            -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n+            -> &'a RefCell<FxHashMap<(DefId, ast::Name), DefId>> {\n         &self.local().impl_method_cache\n     }\n \n-    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+    pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n         &self.local().closure_bare_wrapper_cache\n     }\n \n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n         &self.local().statics_to_rauw\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n         &self.local().llsizingtypes\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }\n \n@@ -885,7 +885,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().opaque_vec_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local().closure_vals\n     }\n \n@@ -905,7 +905,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().rust_try_fn\n     }\n \n-    fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n+    fn intrinsics<'a>(&'a self) -> &'a RefCell<FxHashMap<&'static str, ValueRef>> {\n         &self.local().intrinsics\n     }\n \n@@ -958,7 +958,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &*self.local().symbol_map\n     }\n \n-    pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n+    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.shared.translation_items\n     }\n "}, {"sha": "e81461b662172ecf4eaadac326b09fc59bc0b0b7", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -36,7 +36,7 @@ use common::CrateContext;\n use type_::Type;\n use rustc::ty::{self, AdtKind, Ty, layout};\n use session::config;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n@@ -84,20 +84,20 @@ pub struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n+    unique_id_to_metadata: FxHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FnvHashMap<Ty<'tcx>, DIType>,\n+    type_to_metadata: FxHashMap<Ty<'tcx>, DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: FnvHashMap<Ty<'tcx>, UniqueTypeId>\n+    type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n impl<'tcx> TypeMap<'tcx> {\n     pub fn new() -> TypeMap<'tcx> {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n-            type_to_metadata: FnvHashMap(),\n-            unique_id_to_metadata: FnvHashMap(),\n-            type_to_unique_id: FnvHashMap(),\n+            type_to_metadata: FxHashMap(),\n+            unique_id_to_metadata: FxHashMap(),\n+            type_to_unique_id: FxHashMap(),\n         }\n     }\n "}, {"sha": "62fb40cc389c24393ed41146e515824e188e4813", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -34,7 +34,7 @@ use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -68,15 +68,15 @@ pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<InternalDebugLocation>,\n-    created_files: RefCell<FnvHashMap<String, DIFile>>,\n-    created_enum_disr_types: RefCell<FnvHashMap<(DefId, layout::Integer), DIType>>,\n+    created_files: RefCell<FxHashMap<String, DIFile>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<DefIdMap<DIScope>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n-    composite_types_completed: RefCell<FnvHashSet<DIType>>,\n+    composite_types_completed: RefCell<FxHashSet<DIType>>,\n }\n \n impl<'tcx> CrateDebugContext<'tcx> {\n@@ -89,11 +89,11 @@ impl<'tcx> CrateDebugContext<'tcx> {\n             llcontext: llcontext,\n             builder: builder,\n             current_debug_location: Cell::new(InternalDebugLocation::UnknownLocation),\n-            created_files: RefCell::new(FnvHashMap()),\n-            created_enum_disr_types: RefCell::new(FnvHashMap()),\n+            created_files: RefCell::new(FxHashMap()),\n+            created_enum_disr_types: RefCell::new(FxHashMap()),\n             type_map: RefCell::new(TypeMap::new()),\n             namespace_map: RefCell::new(DefIdMap()),\n-            composite_types_completed: RefCell::new(FnvHashSet()),\n+            composite_types_completed: RefCell::new(FxHashSet()),\n         };\n     }\n }"}, {"sha": "b22bcf9825a2aa4239b23fbe49a9b11a4e0d9e40", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -29,7 +29,7 @@ use type_of;\n use glue;\n use type_::Type;\n \n-use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::parse::token;\n \n use super::{MirContext, LocalRef};\n@@ -144,7 +144,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     adt::trans_get_discr(bcx, ty, discr_lvalue.llval, None, true)\n                 );\n \n-                let mut bb_hist = FnvHashMap();\n+                let mut bb_hist = FxHashMap();\n                 for target in targets {\n                     *bb_hist.entry(target).or_insert(0) += 1;\n                 }"}, {"sha": "c9c12fb6d4534deb2f2dbea251e38ca64fe09faa", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -134,7 +134,7 @@ use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::parse::token::{self, InternedString};\n use trans_item::TransItem;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -151,12 +151,12 @@ pub struct CodegenUnit<'tcx> {\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n \n-    items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    items: FxHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: InternedString,\n-               items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>)\n+               items: FxHashMap<TransItem<'tcx>, llvm::Linkage>)\n                -> Self {\n         CodegenUnit {\n             name: name,\n@@ -165,7 +165,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn empty(name: InternedString) -> Self {\n-        Self::new(name, FnvHashMap())\n+        Self::new(name, FxHashMap())\n     }\n \n     pub fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n@@ -176,7 +176,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &self.name\n     }\n \n-    pub fn items(&self) -> &FnvHashMap<TransItem<'tcx>, llvm::Linkage> {\n+    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, llvm::Linkage> {\n         &self.items\n     }\n \n@@ -297,7 +297,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n \n struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FnvHashSet<TransItem<'tcx>>,\n+    roots: FxHashSet<TransItem<'tcx>>,\n }\n \n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n@@ -308,8 +308,8 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let tcx = scx.tcx();\n-    let mut roots = FnvHashSet();\n-    let mut codegen_units = FnvHashMap();\n+    let mut roots = FxHashSet();\n+    let mut codegen_units = FxHashMap();\n \n     for trans_item in trans_items {\n         let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n@@ -419,7 +419,7 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n-        let mut reachable = FnvHashSet();\n+        let mut reachable = FxHashSet();\n         for root in codegen_unit.items.keys() {\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n@@ -465,7 +465,7 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n-                             visited: &mut FnvHashSet<TransItem<'tcx>>) {\n+                             visited: &mut FxHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }"}, {"sha": "c3e0ac1fee51578d33b238f3ebb4d3e4aba06265", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -14,15 +14,15 @@ use rustc::ty::TyCtxt;\n use std::borrow::Cow;\n use syntax::codemap::Span;\n use trans_item::TransItem;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n // In the SymbolMap we collect the symbol names of all translation items of\n // the current crate. This map exists as a performance optimization. Symbol\n // names of translation items are deterministic and fully defined by the item.\n // Thus they could also always be recomputed if needed.\n \n pub struct SymbolMap<'tcx> {\n-    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n     arena: String,\n }\n \n@@ -78,7 +78,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         }\n \n         let mut symbol_map = SymbolMap {\n-            index: FnvHashMap(),\n+            index: FxHashMap(),\n             arena: String::with_capacity(1024),\n         };\n "}, {"sha": "2a6f79d3ed57ae4fb5d3ceeb3a9ba5b314fcb58b", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,7 +15,7 @@ use llvm::{TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CrateContext;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use rustc::ty::layout;\n@@ -325,13 +325,13 @@ impl Type {\n /* Memory-managed object interface to type handles. */\n \n pub struct TypeNames {\n-    named_types: RefCell<FnvHashMap<String, TypeRef>>,\n+    named_types: RefCell<FxHashMap<String, TypeRef>>,\n }\n \n impl TypeNames {\n     pub fn new() -> TypeNames {\n         TypeNames {\n-            named_types: RefCell::new(FnvHashMap())\n+            named_types: RefCell::new(FxHashMap())\n         }\n     }\n "}, {"sha": "57936f8a4b3be67922429629260cecd50134fc77", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -66,7 +66,7 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ElisionFailureInfo, ElidedLifetime};\n use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n-use util::nodemap::{NodeMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashSet};\n \n use std::cell::RefCell;\n use syntax::{abi, ast};\n@@ -569,7 +569,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut possible_implied_output_region = None;\n \n         for input_type in input_tys.iter() {\n-            let mut regions = FnvHashSet();\n+            let mut regions = FxHashSet();\n             let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n             debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n@@ -1142,7 +1142,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut associated_types = FnvHashSet::default();\n+        let mut associated_types = FxHashSet::default();\n         for tr in traits::supertraits(tcx, principal) {\n             if let Some(trait_id) = tcx.map.as_local_node_id(tr.def_id()) {\n                 use collect::trait_associated_type_names;"}, {"sha": "15b29573ac4e8cc080259316ebe7709bf0a1dc73", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n@@ -633,10 +633,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let field_map = variant.fields\n             .iter()\n             .map(|field| (field.name, field))\n-            .collect::<FnvHashMap<_, _>>();\n+            .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n-        let mut used_fields = FnvHashMap();\n+        let mut used_fields = FxHashMap();\n \n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {"}, {"sha": "d28eb85ebb49d925780d711766bbef66240bf177", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -18,7 +18,7 @@ use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::traits::{self, Reveal};\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::ast;\n use syntax_pos::{self, Span};\n@@ -289,7 +289,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n             rcx: rcx,\n             span: span,\n             parent_scope: parent_scope,\n-            breadcrumbs: FnvHashSet()\n+            breadcrumbs: FxHashSet()\n         },\n         TypeContext::Root,\n         typ,\n@@ -347,7 +347,7 @@ enum TypeContext {\n struct DropckContext<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     rcx: &'a mut RegionCtxt<'b, 'gcx, 'tcx>,\n     /// types that have already been traversed\n-    breadcrumbs: FnvHashSet<Ty<'tcx>>,\n+    breadcrumbs: FxHashSet<Ty<'tcx>>,\n     /// span for error reporting\n     span: Span,\n     /// the scope reachable dtorck types must outlive"}, {"sha": "95d2b2211f5b418bb2bc3c0adf86a0c6a50d482d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use {CrateCtxt, require_same_types};\n \n use syntax::abi::Abi;\n@@ -372,7 +372,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                         return\n                     }\n \n-                    let mut structural_to_nomimal = FnvHashMap();\n+                    let mut structural_to_nomimal = FxHashMap();\n \n                     let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n                     if intr.inputs.len() != sig.inputs.len() {\n@@ -412,7 +412,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         ccx: &CrateCtxt<'a, 'tcx>,\n         position: &str,\n         span: Span,\n-        structural_to_nominal: &mut FnvHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        structural_to_nominal: &mut FxHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n         expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n {\n     use intrinsics::Type::*;"}, {"sha": "54b1b6c6807dbe887e172525542253cf773ed833", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir;\n@@ -40,7 +40,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n-    impl_dups: FnvHashSet<DefId>,\n+    impl_dups: FxHashSet<DefId>,\n     import_id: Option<ast::NodeId>,\n \n     /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n-            impl_dups: FnvHashSet(),\n+            impl_dups: FxHashSet(),\n             import_id: None,\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n@@ -568,7 +568,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n                                                          -> Result<(), MethodError<'tcx>> {\n-        let mut duplicates = FnvHashSet();\n+        let mut duplicates = FxHashSet();\n         let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits {\n@@ -585,7 +585,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n-        let mut duplicates = FnvHashSet();\n+        let mut duplicates = FxHashSet();\n         for trait_info in suggest::all_traits(self.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(trait_info.def_id)?;"}, {"sha": "98d3957db70599376575876a60da162e422e8cf9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -20,7 +20,7 @@ use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::traits::{Obligation, SelectionContext};\n-use util::nodemap::FnvHashSet;\n+use util::nodemap::FxHashSet;\n \n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -470,10 +470,10 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         });\n \n         // Cross-crate:\n-        let mut external_mods = FnvHashSet();\n+        let mut external_mods = FxHashSet();\n         fn handle_external_def(ccx: &CrateCtxt,\n                                traits: &mut AllTraitsVec,\n-                               external_mods: &mut FnvHashSet<DefId>,\n+                               external_mods: &mut FxHashSet<DefId>,\n                                def: Def) {\n             let def_id = def.def_id();\n             match def {"}, {"sha": "f7e05f4777ecce97d554d17c4f93bd0370079f5c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -103,7 +103,7 @@ use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n-use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n@@ -1131,24 +1131,33 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         if !is_implemented {\n             if !is_provided {\n-                missing_items.push(trait_item.name());\n+                missing_items.push(trait_item);\n             } else if associated_type_overridden {\n                 invalidated_items.push(trait_item.name());\n             }\n         }\n     }\n \n     if !missing_items.is_empty() {\n-        struct_span_err!(tcx.sess, impl_span, E0046,\n+        let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|name| name.to_string())\n-                  .collect::<Vec<_>>().join(\"`, `\"))\n-            .span_label(impl_span, &format!(\"missing `{}` in implementation\",\n+                  .map(|trait_item| trait_item.name().to_string())\n+                  .collect::<Vec<_>>().join(\"`, `\"));\n+        err.span_label(impl_span, &format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n-                    .map(|name| name.to_string())\n-                    .collect::<Vec<_>>().join(\"`, `\"))\n-            ).emit();\n+                    .map(|trait_item| trait_item.name().to_string())\n+                    .collect::<Vec<_>>().join(\"`, `\")));\n+        for trait_item in missing_items {\n+            if let Some(span) = tcx.map.span_if_local(trait_item.def_id()) {\n+                err.span_label(span, &format!(\"`{}` from trait\", trait_item.name()));\n+            } else {\n+                err.note(&format!(\"`{}` from trait: `{}`\",\n+                                  trait_item.name(),\n+                                  signature(trait_item)));\n+            }\n+        }\n+        err.emit();\n     }\n \n     if !invalidated_items.is_empty() {\n@@ -1163,6 +1172,14 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+fn signature<'a, 'tcx>(item: &ty::ImplOrTraitItem) -> String {\n+    match *item {\n+        ty::MethodTraitItem(ref item) => format!(\"{}\", item.fty.sig.0),\n+        ty::TypeTraitItem(ref item) => format!(\"type {};\", item.name.to_string()),\n+        ty::ConstTraitItem(ref item) => format!(\"const {}: {:?};\", item.name.to_string(), item.ty),\n+    }\n+}\n+\n /// Checks a constant with a given type.\n fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                    expr: &'tcx hir::Expr,\n@@ -1975,13 +1992,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // We must collect the defaults *before* we do any unification. Because we have\n             // directly attached defaults to the type variables any unification that occurs\n             // will erase defaults causing conflicting defaults to be completely ignored.\n-            let default_map: FnvHashMap<_, _> =\n+            let default_map: FxHashMap<_, _> =\n                 unsolved_variables\n                     .iter()\n                     .filter_map(|t| self.default(t).map(|d| (t, d)))\n                     .collect();\n \n-            let mut unbound_tyvars = FnvHashSet();\n+            let mut unbound_tyvars = FxHashSet();\n \n             debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n \n@@ -2129,8 +2146,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // table then apply defaults until we find a conflict. That default must be the one\n     // that caused conflict earlier.\n     fn find_conflicting_default(&self,\n-                                unbound_vars: &FnvHashSet<Ty<'tcx>>,\n-                                default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n+                                unbound_vars: &FxHashSet<Ty<'tcx>>,\n+                                default_map: &FxHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n                                 conflict: Ty<'tcx>)\n                                 -> Option<type_variable::Default<'tcx>> {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n@@ -3123,12 +3140,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n-        let mut remaining_fields = FnvHashMap();\n+        let mut remaining_fields = FxHashMap();\n         for field in &variant.fields {\n             remaining_fields.insert(field.name, field);\n         }\n \n-        let mut seen_fields = FnvHashMap();\n+        let mut seen_fields = FxHashMap();\n \n         let mut error_happened = false;\n \n@@ -3261,13 +3278,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some((variant, did, substs)) = variant {\n-            if variant.ctor_kind == CtorKind::Fn &&\n-                    !self.tcx.sess.features.borrow().relaxed_adts {\n-                emit_feature_err(&self.tcx.sess.parse_sess,\n-                                 \"relaxed_adts\", path.span, GateIssue::Language,\n-                                 \"tuple structs and variants in struct patterns are unstable\");\n-            }\n-\n             // Check bounds on type arguments used in the path.\n             let type_predicates = self.tcx.lookup_predicates(did);\n             let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);"}, {"sha": "741f327ac99e1a7f8b69d48ee1ca614af1119511", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -16,7 +16,7 @@ use middle::region::{CodeExtent};\n use rustc::infer::TypeOrigin;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::nodemap::{FnvHashSet, FnvHashMap};\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -529,7 +529,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         assert_eq!(ty_predicates.parent, None);\n         let variances = self.tcx().item_variances(item_def_id);\n \n-        let mut constrained_parameters: FnvHashSet<_> =\n+        let mut constrained_parameters: FxHashSet<_> =\n             variances.iter().enumerate()\n                      .filter(|&(_, &variance)| variance != ty::Bivariant)\n                      .map(|(index, _)| Parameter(index as u32))\n@@ -580,10 +580,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n     let parent = tcx.lookup_generics(generics.parent.unwrap());\n-    let impl_params: FnvHashMap<_, _> = parent.types\n-                                        .iter()\n-                                        .map(|tp| (tp.name, tp.def_id))\n-                                        .collect();\n+    let impl_params: FxHashMap<_, _> = parent.types\n+                                       .iter()\n+                                       .map(|tp| (tp.name, tp.def_id))\n+                                       .collect();\n \n     for method_param in &generics.types {\n         if impl_params.contains_key(&method_param.name) {"}, {"sha": "5c51877ae743ee09b9d6678003726e662c8e1606", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -72,7 +72,7 @@ use rustc::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n use {CrateCtxt, write_ty_to_tcx};\n \n use rustc_const_math::ConstInt;\n@@ -786,8 +786,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             // Convert all the associated consts.\n             // Also, check if there are any duplicate associated items\n-            let mut seen_type_items = FnvHashMap();\n-            let mut seen_value_items = FnvHashMap();\n+            let mut seen_type_items = FxHashMap();\n+            let mut seen_value_items = FxHashMap();\n \n             for impl_item in impl_items {\n                 let seen_items = match impl_item.node {\n@@ -1038,7 +1038,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     disr_val: ty::Disr,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDefData<'tcx, 'tcx> {\n-    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n     let node_id = ccx.tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = ccx.tcx.map.local_def_id(f.id);\n@@ -1952,9 +1952,9 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: FnvHashSet<_> = inline_bounds.into_iter()\n-                                                 .chain(where_bounds)\n-                                                 .collect();\n+    let all_bounds: FxHashSet<_> = inline_bounds.into_iter()\n+                                                .chain(where_bounds)\n+                                                .collect();\n     return if all_bounds.len() > 1 {\n         ty::ObjectLifetimeDefault::Ambiguous\n     } else if all_bounds.len() == 0 {\n@@ -2171,7 +2171,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n-    let mut input_parameters: FnvHashSet<_> =\n+    let mut input_parameters: FxHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n@@ -2200,15 +2200,15 @@ fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n-    let mut input_parameters: FnvHashSet<_> =\n+    let mut input_parameters: FxHashSet<_> =\n         ctp::parameters_for(&impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n     ctp::identify_constrained_type_params(\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n-    let lifetimes_in_associated_types: FnvHashSet<_> = impl_items.iter()\n+    let lifetimes_in_associated_types: FxHashSet<_> = impl_items.iter()\n         .map(|item| ccx.tcx.impl_or_trait_item(ccx.tcx.map.local_def_id(item.id)))\n         .filter_map(|item| match item {\n             ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,"}, {"sha": "7918537a6c08f7ec4173a51fe68814c8ff3aeb42", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::{self, Ty};\n use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Parameter(pub u32);\n@@ -76,7 +76,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n \n pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>],\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                              input_parameters: &mut FnvHashSet<Parameter>)\n+                                              input_parameters: &mut FxHashSet<Parameter>)\n {\n     let mut predicates = predicates.to_owned();\n     setup_constraining_predicates(&mut predicates, impl_trait_ref, input_parameters);\n@@ -125,7 +125,7 @@ pub fn identify_constrained_type_params<'tcx>(predicates: &[ty::Predicate<'tcx>]\n /// think of any.\n pub fn setup_constraining_predicates<'tcx>(predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                           input_parameters: &mut FnvHashSet<Parameter>)\n+                                           input_parameters: &mut FxHashSet<Parameter>)\n {\n     // The canonical way of doing the needed topological sort\n     // would be a DFS, but getting the graph and its ownership"}, {"sha": "1885b4276cc4168021dcec56770e5ce19d19271b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -460,7 +460,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 .into_iter()\n                 .map(|meth| meth.name.to_string())\n                 .collect()\n-    }).unwrap_or(FnvHashSet());\n+    }).unwrap_or(FxHashSet());\n \n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n@@ -496,7 +496,7 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n-        let mut visited = FnvHashSet();\n+        let mut visited = FxHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n             let def_id = item.def.def_id();\n             if tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {"}, {"sha": "df13e384d9615a4b926319a59284fb26da3e950e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -38,7 +38,7 @@ use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use rustc::hir;\n \n@@ -116,7 +116,7 @@ pub struct Crate {\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: FnvHashMap<DefId, Trait>,\n+    pub external_traits: FxHashMap<DefId, Trait>,\n }\n \n struct CrateNum(def_id::CrateNum);\n@@ -993,7 +993,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n         // Note that associated types also have a sized bound by default, but we\n         // don't actually know the set of associated types right here so that's\n         // handled in cleaning associated types\n-        let mut sized_params = FnvHashSet();\n+        let mut sized_params = FxHashSet();\n         where_predicates.retain(|pred| {\n             match *pred {\n                 WP::BoundPredicate { ty: Generic(ref g), ref bounds } => {\n@@ -1693,8 +1693,8 @@ impl Clean<Type> for hir::Ty {\n                 });\n                 if let Some((tcx, &hir::ItemTy(ref ty, ref generics))) = tcx_and_alias {\n                     let provided_params = &path.segments.last().unwrap().parameters;\n-                    let mut ty_substs = FnvHashMap();\n-                    let mut lt_substs = FnvHashMap();\n+                    let mut ty_substs = FxHashMap();\n+                    let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n                         let ty_param_def = tcx.expect_def(ty_param.id);\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n@@ -2368,7 +2368,7 @@ impl Clean<ImplPolarity> for hir::ImplPolarity {\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub generics: Generics,\n-    pub provided_trait_methods: FnvHashSet<String>,\n+    pub provided_trait_methods: FxHashSet<String>,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n     pub items: Vec<Item>,\n@@ -2394,7 +2394,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                    .map(|meth| meth.name.to_string())\n                    .collect()\n             })\n-        }).unwrap_or(FnvHashSet());\n+        }).unwrap_or(FxHashSet());\n \n         ret.push(Item {\n             name: None,"}, {"sha": "810bea4c5b0983d06981154ae60d49f9d646f0f0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -48,7 +48,7 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type ExternalPaths = FnvHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n+pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n@@ -65,15 +65,15 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n-    pub external_traits: RefCell<FnvHashMap<DefId, clean::Trait>>,\n+    pub external_traits: RefCell<FxHashMap<DefId, clean::Trait>>,\n \n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n \n     /// Table type parameter definition -> substituted type\n-    pub ty_substs: RefCell<FnvHashMap<Def, clean::Type>>,\n+    pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n-    pub lt_substs: RefCell<FnvHashMap<ast::NodeId, clean::Lifetime>>,\n+    pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -99,8 +99,8 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     pub fn enter_alias<F, R>(&self,\n-                             ty_substs: FnvHashMap<Def, clean::Type>,\n-                             lt_substs: FnvHashMap<ast::NodeId, clean::Lifetime>,\n+                             ty_substs: FxHashMap<Def, clean::Type>,\n+                             lt_substs: FxHashMap<ast::NodeId, clean::Lifetime>,\n                              f: F) -> R\n     where F: FnOnce() -> R {\n         let (old_tys, old_lts) ="}, {"sha": "2db771d771119c6192bde2af5b17fdfe9728469f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 83, "deletions": 37, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -59,7 +59,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::hir;\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n \n use clean::{self, Attributes, GetDefId, SelfTy, Mutability};\n@@ -111,9 +111,9 @@ pub struct SharedContext {\n     /// `true`.\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n-    pub local_sources: FnvHashMap<PathBuf, String>,\n+    pub local_sources: FxHashMap<PathBuf, String>,\n     /// All the passes that were run on this crate.\n-    pub passes: FnvHashSet<String>,\n+    pub passes: FxHashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n     pub issue_tracker_base_url: Option<String>,\n@@ -208,43 +208,43 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: FnvHashMap<DefId, String>,\n+    pub typarams: FxHashMap<DefId, String>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: FnvHashMap<DefId, Vec<Impl>>,\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: FnvHashMap<DefId, (Vec<String>, ItemType)>,\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FnvHashMap<DefId, (Vec<String>, ItemType)>,\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: FnvHashMap<DefId, clean::Trait>,\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FnvHashMap<DefId, Vec<Implementor>>,\n+    pub implementors: FxHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FnvHashMap<CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FxHashMap<CrateNum, (String, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FnvHashMap<clean::PrimitiveType, CrateNum>,\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, CrateNum>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -257,7 +257,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    seen_modules: FnvHashSet<DefId>,\n+    seen_modules: FxHashSet<DefId>,\n     seen_mod: bool,\n     stripped_mod: bool,\n     deref_trait_did: Option<DefId>,\n@@ -275,9 +275,9 @@ pub struct Cache {\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default)]\n pub struct RenderInfo {\n-    pub inlined: FnvHashSet<DefId>,\n+    pub inlined: FxHashSet<DefId>,\n     pub external_paths: ::core::ExternalPaths,\n-    pub external_typarams: FnvHashMap<DefId, String>,\n+    pub external_typarams: FxHashMap<DefId, String>,\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n }\n@@ -376,10 +376,10 @@ impl ToJson for IndexItemFunctionType {\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n                     RefCell::new(Vec::new()));\n-thread_local!(static USED_ID_MAP: RefCell<FnvHashMap<String, usize>> =\n+thread_local!(static USED_ID_MAP: RefCell<FxHashMap<String, usize>> =\n                     RefCell::new(init_ids()));\n \n-fn init_ids() -> FnvHashMap<String, usize> {\n+fn init_ids() -> FxHashMap<String, usize> {\n     [\n      \"main\",\n      \"search\",\n@@ -406,7 +406,7 @@ pub fn reset_ids(embedded: bool) {\n         *s.borrow_mut() = if embedded {\n             init_ids()\n         } else {\n-            FnvHashMap()\n+            FxHashMap()\n         };\n     });\n }\n@@ -431,7 +431,7 @@ pub fn derive_id(candidate: String) -> String {\n pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: PathBuf,\n-           passes: FnvHashSet<String>,\n+           passes: FxHashSet<String>,\n            css_file_extension: Option<PathBuf>,\n            renderinfo: RenderInfo) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n@@ -442,7 +442,7 @@ pub fn run(mut krate: clean::Crate,\n         src_root: src_root,\n         passes: passes,\n         include_sources: true,\n-        local_sources: FnvHashMap(),\n+        local_sources: FxHashMap(),\n         issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n@@ -510,22 +510,22 @@ pub fn run(mut krate: clean::Crate,\n         .collect();\n \n     let mut cache = Cache {\n-        impls: FnvHashMap(),\n+        impls: FxHashMap(),\n         external_paths: external_paths,\n-        paths: FnvHashMap(),\n-        implementors: FnvHashMap(),\n+        paths: FxHashMap(),\n+        implementors: FxHashMap(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n         parent_is_trait_impl: false,\n-        extern_locations: FnvHashMap(),\n-        primitive_locations: FnvHashMap(),\n-        seen_modules: FnvHashSet(),\n+        extern_locations: FxHashMap(),\n+        primitive_locations: FxHashMap(),\n+        seen_modules: FxHashSet(),\n         seen_mod: false,\n         stripped_mod: false,\n         access_levels: krate.access_levels.clone(),\n         orphan_impl_items: Vec::new(),\n-        traits: mem::replace(&mut krate.external_traits, FnvHashMap()),\n+        traits: mem::replace(&mut krate.external_traits, FxHashMap()),\n         deref_trait_did: deref_trait_did,\n         deref_mut_trait_did: deref_mut_trait_did,\n         typarams: external_typarams,\n@@ -572,7 +572,7 @@ pub fn run(mut krate: clean::Crate,\n \n /// Build the search index from the collected metadata\n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    let mut nodeid_to_pathid = FnvHashMap();\n+    let mut nodeid_to_pathid = FxHashMap();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = Vec::<Json>::new();\n \n@@ -1828,11 +1828,19 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 } else {\n                     String::new()\n                 };\n+\n+                let mut unsafety_flag = \"\";\n+                if let clean::FunctionItem(ref func) = myitem.inner {\n+                    if func.unsafety == hir::Unsafety::Unsafe {\n+                        unsafety_flag = \"<a title='unsafe function' href='#'><sup>\u26a0</sup></a>\";\n+                    }\n+                }\n+\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n                 write!(w, \"\n                        <tr class='{stab} module-item'>\n                            <td><a class='{class}' href='{href}'\n-                                  title='{title}'>{name}</a></td>\n+                                  title='{title}'>{name}</a>{unsafety_flag}</td>\n                            <td class='docblock-short'>\n                                {stab_docs} {docs}\n                            </td>\n@@ -1842,6 +1850,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        docs = shorter(Some(&Markdown(doc_value).to_string())),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class(),\n+                       unsafety_flag = unsafety_flag,\n                        href = item_path(myitem.type_(), myitem.name.as_ref().unwrap()),\n                        title = full_path(cx, myitem))?;\n             }\n@@ -2492,18 +2501,55 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n+fn attribute_without_value(s: &str) -> bool {\n+    [\"must_use\", \"no_mangle\", \"unsafe_destructor_blind_to_params\"].iter().any(|x| x == &s)\n+}\n+\n+fn attribute_with_value(s: &str) -> bool {\n+    [\"export_name\", \"lang\", \"link_section\", \"must_use\"].iter().any(|x| x == &s)\n+}\n+\n+fn attribute_with_values(s: &str) -> bool {\n+    [\"repr\"].iter().any(|x| x == &s)\n+}\n+\n+fn render_attribute(attr: &clean::Attribute, recurse: bool) -> Option<String> {\n+    match *attr {\n+        clean::Word(ref s) if attribute_without_value(&*s) || recurse => {\n+            Some(format!(\"{}\", s))\n+        }\n+        clean::NameValue(ref k, ref v) if attribute_with_value(&*k) => {\n+            Some(format!(\"{} = \\\"{}\\\"\", k, v))\n+        }\n+        clean::List(ref k, ref values) if attribute_with_values(&*k) => {\n+            let display: Vec<_> = values.iter()\n+                                        .filter_map(|value| render_attribute(value, true))\n+                                        .map(|entry| format!(\"{}\", entry))\n+                                        .collect();\n+\n+            if display.len() > 0 {\n+                Some(format!(\"{}({})\", k, display.join(\", \")))\n+            } else {\n+                None\n+            }\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+\n fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n+    let mut attrs = String::new();\n+\n     for attr in &it.attrs {\n-        match *attr {\n-            clean::Word(ref s) if *s == \"must_use\" => {\n-                write!(w, \"#[{}]\\n\", s)?;\n-            }\n-            clean::NameValue(ref k, ref v) if *k == \"must_use\" => {\n-                write!(w, \"#[{} = \\\"{}\\\"]\\n\", k, v)?;\n-            }\n-            _ => ()\n+        if let Some(s) = render_attribute(attr, false) {\n+            attrs.push_str(&format!(\"#[{}]\\n\", s));\n         }\n     }\n+    if attrs.len() > 0 {\n+        write!(w, \"<div class=\\\"docblock attributes\\\">{}</div>\", &attrs)?;\n+    }\n     Ok(())\n }\n \n@@ -2618,7 +2664,7 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n-    GotoSource(DefId, &'a FnvHashSet<String>),\n+    GotoSource(DefId, &'a FxHashSet<String>),\n }\n \n impl<'a> AssocItemLink<'a> {"}, {"sha": "474d2bbe7fcb54c6d4880a3b792f91c05b5968da", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -963,27 +963,35 @@\n         }\n     }\n \n-    $(\"#toggle-all-docs\").on(\"click\", toggleAllDocs);\n-\n-    $(document).on(\"click\", \".collapse-toggle\", function() {\n-        var toggle = $(this);\n+    function collapseDocs(toggle, animate) {\n         var relatedDoc = toggle.parent().next();\n         if (relatedDoc.is(\".stability\")) {\n             relatedDoc = relatedDoc.next();\n         }\n         if (relatedDoc.is(\".docblock\")) {\n             if (relatedDoc.is(\":visible\")) {\n-                relatedDoc.slideUp({duration: 'fast', easing: 'linear'});\n+                if (animate === true) {\n+                    relatedDoc.slideUp({duration: 'fast', easing: 'linear'});\n+                    toggle.children(\".toggle-label\").fadeIn();\n+                } else {\n+                    relatedDoc.hide();\n+                    toggle.children(\".toggle-label\").show();\n+                }\n                 toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n                 toggle.children(\".inner\").text(labelForToggleButton(true));\n-                toggle.children(\".toggle-label\").fadeIn();\n             } else {\n                 relatedDoc.slideDown({duration: 'fast', easing: 'linear'});\n                 toggle.parent(\".toggle-wrapper\").removeClass(\"collapsed\");\n                 toggle.children(\".inner\").text(labelForToggleButton(false));\n                 toggle.children(\".toggle-label\").hide();\n             }\n         }\n+    }\n+\n+    $(\"#toggle-all-docs\").on(\"click\", toggleAllDocs);\n+\n+    $(document).on(\"click\", \".collapse-toggle\", function() {\n+        collapseDocs($(this), true)\n     });\n \n     $(function() {\n@@ -999,12 +1007,22 @@\n         });\n \n         var mainToggle =\n-            $(toggle).append(\n+            $(toggle.clone()).append(\n                 $('<span/>', {'class': 'toggle-label'})\n                     .css('display', 'none')\n                     .html('&nbsp;Expand&nbsp;description'));\n         var wrapper = $(\"<div class='toggle-wrapper'>\").append(mainToggle);\n         $(\"#main > .docblock\").before(wrapper);\n+        var mainToggle =\n+            $(toggle).append(\n+                $('<span/>', {'class': 'toggle-label'})\n+                    .css('display', 'none')\n+                    .html('&nbsp;Expand&nbsp;attributes'));\n+        var wrapper = $(\"<div class='toggle-wrapper toggle-attributes'>\").append(mainToggle);\n+        $(\"#main > pre > .attributes\").each(function() {\n+            $(this).before(wrapper);\n+            collapseDocs($($(this).prev().children()[0]), false);\n+        });\n     });\n \n     $('pre.line-numbers').on('click', 'span', function() {"}, {"sha": "46b34b5a638b337876fd513601561115bee8091d", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 373, "deletions": 365, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -14,160 +14,160 @@\n \n /* See FiraSans-LICENSE.txt for the Fira Sans license. */\n @font-face {\n-    font-family: 'Fira Sans';\n-    font-style: normal;\n-    font-weight: 400;\n-    src: local('Fira Sans'), url(\"FiraSans-Regular.woff\") format('woff');\n+\tfont-family: 'Fira Sans';\n+\tfont-style: normal;\n+\tfont-weight: 400;\n+\tsrc: local('Fira Sans'), url(\"FiraSans-Regular.woff\") format('woff');\n }\n @font-face {\n-    font-family: 'Fira Sans';\n-    font-style: normal;\n-    font-weight: 500;\n-    src: local('Fira Sans Medium'), url(\"FiraSans-Medium.woff\") format('woff');\n+\tfont-family: 'Fira Sans';\n+\tfont-style: normal;\n+\tfont-weight: 500;\n+\tsrc: local('Fira Sans Medium'), url(\"FiraSans-Medium.woff\") format('woff');\n }\n \n /* See SourceSerifPro-LICENSE.txt for the Source Serif Pro license and\n  * Heuristica-LICENSE.txt for the Heuristica license. */\n @font-face {\n-    font-family: 'Source Serif Pro';\n-    font-style: normal;\n-    font-weight: 400;\n-    src: local('Source Serif Pro'), url(\"SourceSerifPro-Regular.woff\") format('woff');\n+\tfont-family: 'Source Serif Pro';\n+\tfont-style: normal;\n+\tfont-weight: 400;\n+\tsrc: local('Source Serif Pro'), url(\"SourceSerifPro-Regular.woff\") format('woff');\n }\n @font-face {\n-    font-family: 'Source Serif Pro';\n-    font-style: italic;\n-    font-weight: 400;\n-    src: url(\"Heuristica-Italic.woff\") format('woff');\n+\tfont-family: 'Source Serif Pro';\n+\tfont-style: italic;\n+\tfont-weight: 400;\n+\tsrc: url(\"Heuristica-Italic.woff\") format('woff');\n }\n @font-face {\n-    font-family: 'Source Serif Pro';\n-    font-style: normal;\n-    font-weight: 700;\n-    src: local('Source Serif Pro Bold'), url(\"SourceSerifPro-Bold.woff\") format('woff');\n+\tfont-family: 'Source Serif Pro';\n+\tfont-style: normal;\n+\tfont-weight: 700;\n+\tsrc: local('Source Serif Pro Bold'), url(\"SourceSerifPro-Bold.woff\") format('woff');\n }\n \n /* See SourceCodePro-LICENSE.txt for the Source Code Pro license. */\n @font-face {\n-    font-family: 'Source Code Pro';\n-    font-style: normal;\n-    font-weight: 400;\n-    src: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+\tfont-family: 'Source Code Pro';\n+\tfont-style: normal;\n+\tfont-weight: 400;\n+\tsrc: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n }\n @font-face {\n-    font-family: 'Source Code Pro';\n-    font-style: normal;\n-    font-weight: 600;\n-    src: local('Source Code Pro Semibold'), url(\"SourceCodePro-Semibold.woff\") format('woff');\n+\tfont-family: 'Source Code Pro';\n+\tfont-style: normal;\n+\tfont-weight: 600;\n+\tsrc: local('Source Code Pro Semibold'), url(\"SourceCodePro-Semibold.woff\") format('woff');\n }\n \n * {\n   -webkit-box-sizing: border-box;\n-     -moz-box-sizing: border-box;\n-          box-sizing: border-box;\n+\t -moz-box-sizing: border-box;\n+\t\t  box-sizing: border-box;\n }\n \n /* General structure and fonts */\n \n body {\n-    font: 16px/1.4 \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;\n-    margin: 0;\n-    position: relative;\n-    padding: 10px 15px 20px 15px;\n+\tfont: 16px/1.4 \"Source Serif Pro\", Georgia, Times, \"Times New Roman\", serif;\n+\tmargin: 0;\n+\tposition: relative;\n+\tpadding: 10px 15px 20px 15px;\n \n-    -webkit-font-feature-settings: \"kern\", \"liga\";\n-    -moz-font-feature-settings: \"kern\", \"liga\";\n-    font-feature-settings: \"kern\", \"liga\";\n+\t-webkit-font-feature-settings: \"kern\", \"liga\";\n+\t-moz-font-feature-settings: \"kern\", \"liga\";\n+\tfont-feature-settings: \"kern\", \"liga\";\n }\n \n h1 {\n-    font-size: 1.5em;\n+\tfont-size: 1.5em;\n }\n h2 {\n-    font-size: 1.4em;\n+\tfont-size: 1.4em;\n }\n h3 {\n-    font-size: 1.3em;\n+\tfont-size: 1.3em;\n }\n h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n-    font-weight: 500;\n-    margin: 20px 0 15px 0;\n-    padding-bottom: 6px;\n+\tfont-weight: 500;\n+\tmargin: 20px 0 15px 0;\n+\tpadding-bottom: 6px;\n }\n h1.fqn {\n-    border-bottom: 1px dashed;\n-    margin-top: 0;\n-    position: relative;\n+\tborder-bottom: 1px dashed;\n+\tmargin-top: 0;\n+\tposition: relative;\n }\n h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n-    border-bottom: 1px solid;\n+\tborder-bottom: 1px solid;\n }\n h3.impl, h3.method, h4.method, h3.type, h4.type {\n-    font-weight: 600;\n-    margin-top: 10px;\n-    margin-bottom: 10px;\n-    position: relative;\n+\tfont-weight: 600;\n+\tmargin-top: 10px;\n+\tmargin-bottom: 10px;\n+\tposition: relative;\n }\n h3.impl, h3.method, h3.type {\n-    margin-top: 15px;\n+\tmargin-top: 15px;\n }\n h1, h2, h3, h4, .sidebar, a.source, .search-input, .content table :not(code)>a, .collapse-toggle {\n-    font-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+\tfont-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n }\n \n ol, ul {\n-    padding-left: 25px;\n+\tpadding-left: 25px;\n }\n ul ul, ol ul, ul ol, ol ol {\n-    margin-bottom: 0;\n+\tmargin-bottom: 0;\n }\n \n p {\n-    margin: 0 0 .6em 0;\n+\tmargin: 0 0 .6em 0;\n }\n \n code, pre {\n-    font-family: \"Source Code Pro\", Menlo, Monaco, Consolas, \"DejaVu Sans Mono\", Inconsolata, monospace;\n-    white-space: pre-wrap;\n+\tfont-family: \"Source Code Pro\", Menlo, Monaco, Consolas, \"DejaVu Sans Mono\", Inconsolata, monospace;\n+\twhite-space: pre-wrap;\n }\n .docblock code, .docblock-short code {\n-    border-radius: 3px;\n-    padding: 0 0.2em;\n+\tborder-radius: 3px;\n+\tpadding: 0 0.2em;\n }\n .docblock pre code, .docblock-short pre code {\n-    padding: 0;\n+\tpadding: 0;\n }\n pre {\n-    padding: 14px;\n+\tpadding: 14px;\n }\n \n .source pre {\n-    padding: 20px;\n+\tpadding: 20px;\n }\n \n img {\n-    max-width: 100%;\n+\tmax-width: 100%;\n }\n \n .content.source {\n-    margin-top: 50px;\n-    max-width: none;\n-    overflow: visible;\n-    margin-left: 0px;\n-    min-width: 70em;\n+\tmargin-top: 50px;\n+\tmax-width: none;\n+\toverflow: visible;\n+\tmargin-left: 0px;\n+\tmin-width: 70em;\n }\n \n nav.sub {\n-    font-size: 16px;\n-    text-transform: uppercase;\n+\tfont-size: 16px;\n+\ttext-transform: uppercase;\n }\n \n .sidebar {\n-    width: 200px;\n-    position: absolute;\n-    left: 0;\n-    top: 0;\n-    min-height: 100%;\n+\twidth: 200px;\n+\tposition: absolute;\n+\tleft: 0;\n+\ttop: 0;\n+\tmin-height: 100%;\n }\n \n .content, nav { max-width: 960px; }\n@@ -177,188 +177,188 @@ nav.sub {\n .js-only, .hidden { display: none !important; }\n \n .sidebar {\n-    padding: 10px;\n+\tpadding: 10px;\n }\n .sidebar img {\n-    margin: 20px auto;\n-    display: block;\n+\tmargin: 20px auto;\n+\tdisplay: block;\n }\n \n .sidebar .location {\n-    font-size: 17px;\n-    margin: 30px 0 20px 0;\n-    text-align: center;\n+\tfont-size: 17px;\n+\tmargin: 30px 0 20px 0;\n+\ttext-align: center;\n }\n \n .location a:first-child { font-weight: 500; }\n \n .block {\n-    padding: 0 10px;\n-    margin-bottom: 14px;\n+\tpadding: 0 10px;\n+\tmargin-bottom: 14px;\n }\n .block h2, .block h3 {\n-    margin-top: 0;\n-    margin-bottom: 8px;\n-    text-align: center;\n+\tmargin-top: 0;\n+\tmargin-bottom: 8px;\n+\ttext-align: center;\n }\n .block ul, .block li {\n-    margin: 0;\n-    padding: 0;\n-    list-style: none;\n+\tmargin: 0;\n+\tpadding: 0;\n+\tlist-style: none;\n }\n \n .block a {\n-    display: block;\n-    text-overflow: ellipsis;\n-    overflow: hidden;\n-    line-height: 15px;\n-    padding: 7px 5px;\n-    font-size: 14px;\n-    font-weight: 300;\n-    transition: border 500ms ease-out;\n+\tdisplay: block;\n+\ttext-overflow: ellipsis;\n+\toverflow: hidden;\n+\tline-height: 15px;\n+\tpadding: 7px 5px;\n+\tfont-size: 14px;\n+\tfont-weight: 300;\n+\ttransition: border 500ms ease-out;\n }\n \n .content {\n-    padding: 15px 0;\n+\tpadding: 15px 0;\n }\n \n .content.source pre.rust {\n-    white-space: pre;\n-    overflow: auto;\n-    padding-left: 0;\n+\twhite-space: pre;\n+\toverflow: auto;\n+\tpadding-left: 0;\n }\n .content pre.line-numbers {\n-    float: left;\n-    border: none;\n-    position: relative;\n+\tfloat: left;\n+\tborder: none;\n+\tposition: relative;\n \n-    -webkit-user-select: none;\n-    -moz-user-select: none;\n-    -ms-user-select: none;\n-    user-select: none;\n+\t-webkit-user-select: none;\n+\t-moz-user-select: none;\n+\t-ms-user-select: none;\n+\tuser-select: none;\n }\n .line-numbers span { cursor: pointer; }\n \n .docblock-short p {\n-    display: inline;\n+\tdisplay: inline;\n }\n \n .docblock-short.nowrap {\n-    display: block;\n-    overflow: hidden;\n-    white-space: nowrap;\n-    text-overflow: ellipsis;\n+\tdisplay: block;\n+\toverflow: hidden;\n+\twhite-space: nowrap;\n+\ttext-overflow: ellipsis;\n }\n \n .docblock-short p {\n-    overflow: hidden;\n-    text-overflow: ellipsis;\n-    margin: 0;\n+\toverflow: hidden;\n+\ttext-overflow: ellipsis;\n+\tmargin: 0;\n }\n .docblock-short code { white-space: nowrap; }\n \n .docblock h1, .docblock h2, .docblock h3, .docblock h4, .docblock h5 {\n-    border-bottom: 1px solid;\n+\tborder-bottom: 1px solid;\n }\n \n .docblock h1 { font-size: 1.3em; }\n .docblock h2 { font-size: 1.15em; }\n .docblock h3, .docblock h4, .docblock h5 { font-size: 1em; }\n \n .docblock {\n-    margin-left: 24px;\n+\tmargin-left: 24px;\n }\n \n .content .out-of-band {\n-    font-size: 23px;\n-    margin: 0px;\n-    padding: 0px;\n-    text-align: right;\n-    display: inline-block;\n-    font-weight: normal;\n-    position: absolute;\n-    right: 0;\n+\tfont-size: 23px;\n+\tmargin: 0px;\n+\tpadding: 0px;\n+\ttext-align: right;\n+\tdisplay: inline-block;\n+\tfont-weight: normal;\n+\tposition: absolute;\n+\tright: 0;\n }\n \n h3.impl > .out-of-band {\n-    font-size: 21px;\n+\tfont-size: 21px;\n }\n \n h4 > code, h3 > code, .invisible > code {\n-    position: inherit;\n+\tposition: inherit;\n }\n \n .in-band, code {\n-    z-index: 5;\n+\tz-index: 5;\n }\n \n .invisible {\n-    background: rgba(0, 0, 0, 0);\n-    width: 100%;\n-    display: inline-block;\n+\tbackground: rgba(0, 0, 0, 0);\n+\twidth: 100%;\n+\tdisplay: inline-block;\n }\n \n .content .in-band {\n-    margin: 0px;\n-    padding: 0px;\n-    display: inline-block;\n+\tmargin: 0px;\n+\tpadding: 0px;\n+\tdisplay: inline-block;\n }\n \n #main { position: relative; }\n #main > .since {\n-    top: inherit;\n-    font-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+\ttop: inherit;\n+\tfont-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n }\n \n .content table {\n-    border-spacing: 0 5px;\n-    border-collapse: separate;\n+\tborder-spacing: 0 5px;\n+\tborder-collapse: separate;\n }\n .content td { vertical-align: top; }\n .content td:first-child { padding-right: 20px; }\n .content td p:first-child { margin-top: 0; }\n .content td h1, .content td h2 { margin-left: 0; font-size: 1.1em; }\n \n .docblock table {\n-    border: 1px solid;\n-    margin: .5em 0;\n-    border-collapse: collapse;\n-    width: 100%;\n+\tborder: 1px solid;\n+\tmargin: .5em 0;\n+\tborder-collapse: collapse;\n+\twidth: 100%;\n }\n \n .docblock table td {\n-    padding: .5em;\n-    border-top: 1px dashed;\n-    border-bottom: 1px dashed;\n+\tpadding: .5em;\n+\tborder-top: 1px dashed;\n+\tborder-bottom: 1px dashed;\n }\n \n .docblock table th {\n-    padding: .5em;\n-    text-align: left;\n-    border-top: 1px solid;\n-    border-bottom: 1px solid;\n+\tpadding: .5em;\n+\ttext-align: left;\n+\tborder-top: 1px solid;\n+\tborder-bottom: 1px solid;\n }\n \n .content .item-list {\n-    list-style-type: none;\n-    padding: 0;\n+\tlist-style-type: none;\n+\tpadding: 0;\n }\n \n .content .item-list li { margin-bottom: 3px; }\n \n .content .multi-column {\n-    -moz-column-count: 5;\n-    -moz-column-gap: 2.5em;\n-    -webkit-column-count: 5;\n-    -webkit-column-gap: 2.5em;\n-    column-count: 5;\n-    column-gap: 2.5em;\n+\t-moz-column-count: 5;\n+\t-moz-column-gap: 2.5em;\n+\t-webkit-column-count: 5;\n+\t-webkit-column-gap: 2.5em;\n+\tcolumn-count: 5;\n+\tcolumn-gap: 2.5em;\n }\n .content .multi-column li { width: 100%; display: inline-block; }\n \n .content .method {\n-    font-size: 1em;\n-    position: relative;\n+\tfont-size: 1em;\n+\tposition: relative;\n }\n /* Shift \"where ...\" part of method or fn definition down a line */\n .content .method .where, .content .fn .where { display: block; }\n@@ -368,54 +368,54 @@ h4 > code, h3 > code, .invisible > code {\n .content .methods > div { margin-left: 40px; }\n \n .content .impl-items .docblock, .content .impl-items .stability {\n-    margin-left: 40px;\n+\tmargin-left: 40px;\n }\n .content .impl-items .method, .content .impl-items > .type {\n-    margin-left: 20px;\n+\tmargin-left: 20px;\n }\n \n .content .stability code {\n-    font-size: 90%;\n+\tfont-size: 90%;\n }\n \n /* Shift where in trait listing down a line */\n pre.trait .where::before {\n-    content: '\\a         ';\n+\tcontent: '\\a         ';\n }\n \n nav {\n-    border-bottom: 1px solid;\n-    padding-bottom: 10px;\n-    margin-bottom: 10px;\n+\tborder-bottom: 1px solid;\n+\tpadding-bottom: 10px;\n+\tmargin-bottom: 10px;\n }\n nav.main {\n-    padding: 20px 0;\n-    text-align: center;\n+\tpadding: 20px 0;\n+\ttext-align: center;\n }\n nav.main .current {\n-    border-top: 1px solid;\n-    border-bottom: 1px solid;\n+\tborder-top: 1px solid;\n+\tborder-bottom: 1px solid;\n }\n nav.main .separator {\n-    border: 1px solid;\n-    display: inline-block;\n-    height: 23px;\n-    margin: 0 20px;\n+\tborder: 1px solid;\n+\tdisplay: inline-block;\n+\theight: 23px;\n+\tmargin: 0 20px;\n }\n nav.sum { text-align: right; }\n nav.sub form { display: inline; }\n \n nav.sub, .content {\n-    margin-left: 230px;\n+\tmargin-left: 230px;\n }\n \n a {\n-    text-decoration: none;\n-    background: transparent;\n+\ttext-decoration: none;\n+\tbackground: transparent;\n }\n \n .docblock a:hover, .docblock-short a:hover, .stability a {\n-    text-decoration: underline;\n+\ttext-decoration: underline;\n }\n \n .content span.enum, .content a.enum, .block a.current.enum { color: #5e9766; }\n@@ -425,40 +425,40 @@ a {\n .block a.current.crate { font-weight: 500; }\n \n .search-input {\n-    width: 100%;\n-    /* Override Normalize.css: we have margins and do\n-     not want to overflow - the `moz` attribute is necessary\n-     until Firefox 29, too early to drop at this point */\n-    -moz-box-sizing: border-box !important;\n-    box-sizing: border-box !important;\n-    outline: none;\n-    border: none;\n-    border-radius: 1px;\n-    margin-top: 5px;\n-    padding: 10px 16px;\n-    font-size: 17px;\n-    transition: border-color 300ms ease;\n-    transition: border-radius 300ms ease-in-out;\n-    transition: box-shadow 300ms ease-in-out;\n+\twidth: 100%;\n+\t/* Override Normalize.css: we have margins and do\n+\t not want to overflow - the `moz` attribute is necessary\n+\t until Firefox 29, too early to drop at this point */\n+\t-moz-box-sizing: border-box !important;\n+\tbox-sizing: border-box !important;\n+\toutline: none;\n+\tborder: none;\n+\tborder-radius: 1px;\n+\tmargin-top: 5px;\n+\tpadding: 10px 16px;\n+\tfont-size: 17px;\n+\ttransition: border-color 300ms ease;\n+\ttransition: border-radius 300ms ease-in-out;\n+\ttransition: box-shadow 300ms ease-in-out;\n }\n \n .search-input:focus {\n-    border-color: #66afe9;\n-    border-radius: 2px;\n-    border: 0;\n-    outline: 0;\n-    box-shadow: 0 0 8px #078dd8;\n+\tborder-color: #66afe9;\n+\tborder-radius: 2px;\n+\tborder: 0;\n+\toutline: 0;\n+\tbox-shadow: 0 0 8px #078dd8;\n }\n \n .search-results .desc {\n-    white-space: nowrap;\n-    text-overflow: ellipsis;\n-    overflow: hidden;\n-    display: block;\n+\twhite-space: nowrap;\n+\ttext-overflow: ellipsis;\n+\toverflow: hidden;\n+\tdisplay: block;\n }\n \n .search-results a {\n-    display: block;\n+\tdisplay: block;\n }\n \n .content .search-results td:first-child { padding-right: 0; }\n@@ -468,96 +468,96 @@ tr.result span.primitive::after { content: ' (primitive type)'; font-style: ital\n }\n \n body.blur > :not(#help) {\n-    filter: blur(8px);\n-    -webkit-filter: blur(8px);\n-    opacity: .7;\n+\tfilter: blur(8px);\n+\t-webkit-filter: blur(8px);\n+\topacity: .7;\n }\n \n #help {\n-    width: 100%;\n-    height: 100vh;\n-    position: fixed;\n-    top: 0;\n-    left: 0;\n-    display: flex;\n-    justify-content: center;\n-    align-items: center;\n+\twidth: 100%;\n+\theight: 100vh;\n+\tposition: fixed;\n+\ttop: 0;\n+\tleft: 0;\n+\tdisplay: flex;\n+\tjustify-content: center;\n+\talign-items: center;\n }\n #help > div {\n-    flex: 0 0 auto;\n-    background: #e9e9e9;\n-    box-shadow: 0 0 6px rgba(0,0,0,.2);\n-    width: 550px;\n-    height: 330px;\n-    border: 1px solid #bfbfbf;\n+\tflex: 0 0 auto;\n+\tbackground: #e9e9e9;\n+\tbox-shadow: 0 0 6px rgba(0,0,0,.2);\n+\twidth: 550px;\n+\theight: 330px;\n+\tborder: 1px solid #bfbfbf;\n }\n #help dt {\n-    float: left;\n-    border-radius: 4px;\n-    border: 1px solid #bfbfbf;\n-    background: #fff;\n-    width: 23px;\n-    text-align: center;\n-    clear: left;\n-    display: block;\n-    margin-top: -1px;\n+\tfloat: left;\n+\tborder-radius: 4px;\n+\tborder: 1px solid #bfbfbf;\n+\tbackground: #fff;\n+\twidth: 23px;\n+\ttext-align: center;\n+\tclear: left;\n+\tdisplay: block;\n+\tmargin-top: -1px;\n }\n #help dd { margin: 5px 33px; }\n #help .infos { padding-left: 0; }\n #help h1, #help h2 { margin-top: 0; }\n #help > div div {\n-    width: 50%;\n-    float: left;\n-    padding: 20px;\n+\twidth: 50%;\n+\tfloat: left;\n+\tpadding: 20px;\n }\n \n em.stab {\n-    display: inline-block;\n-    border-width: 1px;\n-    border-style: solid;\n-    padding: 3px;\n-    margin-bottom: 5px;\n-    font-size: 90%;\n-    font-style: normal;\n+\tdisplay: inline-block;\n+\tborder-width: 1px;\n+\tborder-style: solid;\n+\tpadding: 3px;\n+\tmargin-bottom: 5px;\n+\tfont-size: 90%;\n+\tfont-style: normal;\n }\n em.stab p {\n-    display: inline;\n+\tdisplay: inline;\n }\n \n .module-item .stab {\n-    border-width: 0;\n-    padding: 0;\n-    margin: 0;\n-    background: inherit !important;\n+\tborder-width: 0;\n+\tpadding: 0;\n+\tmargin: 0;\n+\tbackground: inherit !important;\n }\n \n .module-item.unstable {\n-    opacity: 0.65;\n+\topacity: 0.65;\n }\n \n .since {\n-    font-weight: normal;\n-    font-size: initial;\n-    color: grey;\n-    position: absolute;\n-    right: 0;\n-    top: 0;\n+\tfont-weight: normal;\n+\tfont-size: initial;\n+\tcolor: grey;\n+\tposition: absolute;\n+\tright: 0;\n+\ttop: 0;\n }\n \n .variants_table {\n-    width: 100%;\n+\twidth: 100%;\n }\n \n .variants_table tbody tr td:first-child {\n-    width: 1%; /* make the variant name as small as possible */\n+\twidth: 1%; /* make the variant name as small as possible */\n }\n \n td.summary-column {\n-    width: 100%;\n+\twidth: 100%;\n }\n \n .summary {\n-    padding-right: 0px;\n+\tpadding-right: 0px;\n }\n \n .line-numbers :target { background-color: transparent; }\n@@ -571,110 +571,118 @@ pre.rust .attribute, pre.rust .attribute .ident { color: #C82829; }\n pre.rust .macro, pre.rust .macro-nonterminal { color: #3E999F; }\n pre.rust .lifetime { color: #B76514; }\n pre.rust .question-mark {\n-    color: #ff9011;\n-    font-weight: bold;\n+\tcolor: #ff9011;\n+\tfont-weight: bold;\n }\n \n pre.rust { position: relative; }\n a.test-arrow {\n-    background-color: rgba(78, 139, 202, 0.2);\n-    display: inline-block;\n-    position: absolute;\n-    padding: 5px 10px 5px 10px;\n-    border-radius: 5px;\n-    font-size: 130%;\n-    top: 5px;\n-    right: 5px;\n+\tbackground-color: rgba(78, 139, 202, 0.2);\n+\tdisplay: inline-block;\n+\tposition: absolute;\n+\tpadding: 5px 10px 5px 10px;\n+\tborder-radius: 5px;\n+\tfont-size: 130%;\n+\ttop: 5px;\n+\tright: 5px;\n }\n a.test-arrow:hover{\n-    background-color: #4e8bca;\n-    text-decoration: none;\n+\tbackground-color: #4e8bca;\n+\ttext-decoration: none;\n }\n \n .section-header:hover a:after {\n-    content: '\\2002\\00a7\\2002';\n+\tcontent: '\\2002\\00a7\\2002';\n }\n \n .section-header:hover a {\n-    text-decoration: none;\n+\ttext-decoration: none;\n }\n \n .section-header a {\n-    color: inherit;\n+\tcolor: inherit;\n }\n \n .collapse-toggle {\n-    font-weight: 300;\n-    position: absolute;\n-    left: -23px;\n-    color: #999;\n-    top: 0;\n+\tfont-weight: 300;\n+\tposition: absolute;\n+\tleft: -23px;\n+\tcolor: #999;\n+\ttop: 0;\n }\n \n .toggle-wrapper > .collapse-toggle {\n-    left: -24px;\n-    margin-top: 0px;\n+\tleft: -24px;\n+\tmargin-top: 0px;\n }\n \n .toggle-wrapper {\n-    position: relative;\n+\tposition: relative;\n }\n \n .toggle-wrapper.collapsed {\n-    height: 1em;\n-    transition: height .2s;\n+\theight: 1em;\n+\ttransition: height .2s;\n }\n \n .collapse-toggle > .inner {\n-    display: inline-block;\n-    width: 1.2ch;\n-    text-align: center;\n+\tdisplay: inline-block;\n+\twidth: 1.2ch;\n+\ttext-align: center;\n }\n \n .toggle-label {\n-    color: #999;\n+\tcolor: #999;\n }\n \n .ghost {\n-    display: none;\n+\tdisplay: none;\n }\n \n .ghost + .since {\n-    position: initial;\n-    display: table-cell;\n+\tposition: initial;\n+\tdisplay: table-cell;\n }\n \n .since + .srclink {\n-    display: table-cell;\n-    padding-left: 10px;\n+\tdisplay: table-cell;\n+\tpadding-left: 10px;\n }\n \n span.since {\n-    position: initial;\n-    font-size: 20px;\n-    margin-right: 5px;\n+\tposition: initial;\n+\tfont-size: 20px;\n+\tmargin-right: 5px;\n }\n \n .toggle-wrapper > .collapse-toggle {\n-    left: 0;\n+\tleft: 0;\n }\n \n .variant + .toggle-wrapper > a {\n-    margin-top: 5px;\n+\tmargin-top: 5px;\n }\n \n .enum > .toggle-wrapper + .docblock, .struct > .toggle-wrapper + .docblock {\n-    margin-left: 30px;\n-    margin-bottom: 20px;\n-    margin-top: 5px;\n+\tmargin-left: 30px;\n+\tmargin-bottom: 20px;\n+\tmargin-top: 5px;\n }\n \n .enum > .collapsed, .struct > .collapsed {\n-    margin-bottom: 25px;\n+\tmargin-bottom: 25px;\n }\n \n .enum .variant, .struct .structfield {\n-    display: block;\n+\tdisplay: block;\n+}\n+\n+.attributes {\n+\tdisplay: block;\n+\tmargin: 0px 0px 0px 30px !important;\n+}\n+.toggle-attributes.collapsed {\n+\tmargin-bottom: 5px;\n }\n \n :target > code {\n@@ -685,71 +693,71 @@ span.since {\n /* Media Queries */\n \n @media (max-width: 700px) {\n-    body {\n-        padding-top: 0px;\n-    }\n-\n-    .sidebar {\n-        height: 40px;\n-        min-height: 40px;\n-        width: 100%;\n-        margin: 0px;\n-        padding: 0px;\n-        position: static;\n-    }\n-\n-    .sidebar .location {\n-        float: right;\n-        margin: 0px;\n-        padding: 3px 10px 1px 10px;\n-        min-height: 39px;\n-        background: inherit;\n-        text-align: left;\n-        font-size: 24px;\n-    }\n-\n-    .sidebar .location:empty {\n-        padding: 0;\n-    }\n-\n-    .sidebar img {\n-        width: 35px;\n-        margin-top: 5px;\n-        margin-bottom: 0px;\n-        float: left;\n-    }\n-\n-    nav.sub {\n-        margin: 0 auto;\n-    }\n-\n-    .sidebar .block {\n-        display: none;\n-    }\n-\n-    .content {\n-        margin-left: 0px;\n-    }\n-\n-    .content .in-band {\n-        width: 100%;\n-    }\n-\n-    .content .out-of-band {\n-        display: none;\n-    }\n-\n-    .toggle-wrapper > .collapse-toggle {\n-        left: 0px;\n-    }\n-\n-    .toggle-wrapper {\n-        height: 1.5em;\n-    }\n+\tbody {\n+\t\tpadding-top: 0px;\n+\t}\n+\n+\t.sidebar {\n+\t\theight: 40px;\n+\t\tmin-height: 40px;\n+\t\twidth: 100%;\n+\t\tmargin: 0px;\n+\t\tpadding: 0px;\n+\t\tposition: static;\n+\t}\n+\n+\t.sidebar .location {\n+\t\tfloat: right;\n+\t\tmargin: 0px;\n+\t\tpadding: 3px 10px 1px 10px;\n+\t\tmin-height: 39px;\n+\t\tbackground: inherit;\n+\t\ttext-align: left;\n+\t\tfont-size: 24px;\n+\t}\n+\n+\t.sidebar .location:empty {\n+\t\tpadding: 0;\n+\t}\n+\n+\t.sidebar img {\n+\t\twidth: 35px;\n+\t\tmargin-top: 5px;\n+\t\tmargin-bottom: 0px;\n+\t\tfloat: left;\n+\t}\n+\n+\tnav.sub {\n+\t\tmargin: 0 auto;\n+\t}\n+\n+\t.sidebar .block {\n+\t\tdisplay: none;\n+\t}\n+\n+\t.content {\n+\t\tmargin-left: 0px;\n+\t}\n+\n+\t.content .in-band {\n+\t\twidth: 100%;\n+\t}\n+\n+\t.content .out-of-band {\n+\t\tdisplay: none;\n+\t}\n+\n+\t.toggle-wrapper > .collapse-toggle {\n+\t\tleft: 0px;\n+\t}\n+\n+\t.toggle-wrapper {\n+\t\theight: 1.5em;\n+\t}\n }\n \n @media print {\n-    nav.sub, .content .out-of-band, .collapse-toggle {\n-        display: none;\n-    }\n+\tnav.sub, .content .out-of-band, .collapse-toggle {\n+\t\tdisplay: none;\n+\t}\n }"}, {"sha": "6e47c037ad3dbb2f1a900c78052a4ee94c710080", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -22,7 +22,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::privacy::AccessLevel;\n-use rustc::util::nodemap::FnvHashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n use rustc::hir;\n \n@@ -42,14 +42,14 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n-    view_item_stack: FnvHashSet<ast::NodeId>,\n+    view_item_stack: FxHashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn new(cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n-        let mut stack = FnvHashSet();\n+        let mut stack = FxHashSet();\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),"}, {"sha": "d1b8fcd74400310323417f0e51c97a0c6a981405", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -686,7 +686,7 @@ impl ToOwned for CStr {\n     type Owned = CString;\n \n     fn to_owned(&self) -> CString {\n-        unsafe { CString::from_vec_unchecked(self.to_bytes().to_vec()) }\n+        CString { inner: self.to_bytes_with_nul().to_vec().into_boxed_slice() }\n     }\n }\n "}, {"sha": "559250adac5ed24c47a7ac2fe7f5938d5bf14345", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -67,6 +67,9 @@ impl UdpSocket {\n     ///\n     /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n     /// documentation for concrete examples.\n+    /// This will return an error when the IP version of the local socket\n+    /// does not match that returned from `ToSocketAddrs`\n+    /// See https://github.com/rust-lang/rust/issues/34202 for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n                                      -> io::Result<usize> {"}, {"sha": "9751ad6aa43c3d5aec16fb6fa6607fd7f4f9a739", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -399,6 +399,14 @@ impl Generics {\n     pub fn is_parameterized(&self) -> bool {\n         self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n+    pub fn span_for_name(&self, name: &str) -> Option<Span> {\n+        for t in &self.ty_params {\n+            if t.ident.name.as_str() == name {\n+                return Some(t.span);\n+            }\n+        }\n+        None\n+    }\n }\n \n impl Default for Generics {"}, {"sha": "57a936bf9b0cf40c09b082571f186e698c28ab0a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -32,7 +32,8 @@ use std::cell::{RefCell, Cell};\n use std::collections::HashSet;\n \n thread_local! {\n-    static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n+    static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n+    static KNOWN_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n }\n \n enum AttrError {\n@@ -81,6 +82,29 @@ pub fn is_used(attr: &Attribute) -> bool {\n     })\n }\n \n+pub fn mark_known(attr: &Attribute) {\n+    debug!(\"Marking {:?} as known.\", attr);\n+    let AttrId(id) = attr.node.id;\n+    KNOWN_ATTRS.with(|slot| {\n+        let idx = (id / 64) as usize;\n+        let shift = id % 64;\n+        if slot.borrow().len() <= idx {\n+            slot.borrow_mut().resize(idx + 1, 0);\n+        }\n+        slot.borrow_mut()[idx] |= 1 << shift;\n+    });\n+}\n+\n+pub fn is_known(attr: &Attribute) -> bool {\n+    let AttrId(id) = attr.node.id;\n+    KNOWN_ATTRS.with(|slot| {\n+        let idx = (id / 64) as usize;\n+        let shift = id % 64;\n+        slot.borrow().get(idx).map(|bits| bits & (1 << shift) != 0)\n+            .unwrap_or(false)\n+    })\n+}\n+\n impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n     pub fn meta_item(&self) -> Option<&P<MetaItem>> {"}, {"sha": "a6493872338fa43595b6ec6e677bda679e491a6a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -271,7 +271,6 @@ declare_features! (\n     // Allows `impl Trait` in function return types.\n     (active, conservative_impl_trait, \"1.12.0\", Some(34511)),\n \n-    // Allows tuple structs and variants in more contexts,\n     // Permits numeric fields in struct expressions and patterns.\n     (active, relaxed_adts, \"1.12.0\", Some(35626)),\n \n@@ -422,11 +421,11 @@ macro_rules! cfg_fn {\n }\n \n pub fn deprecated_attributes() -> Vec<&'static (&'static str, AttributeType, AttributeGate)> {\n-    KNOWN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n+    BUILTIN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n }\n \n // Attributes that have a special meaning to rustc or rustdoc\n-pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n+pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n     // Normal attributes\n \n     (\"warn\", Normal, Ungated),\n@@ -801,12 +800,12 @@ impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n         let name = &*attr.name();\n-        for &(n, ty, ref gateage) in KNOWN_ATTRIBUTES {\n+        for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if n == name {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n                     gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n-                debug!(\"check_attribute: {:?} is known, {:?}, {:?}\", name, ty, gateage);\n+                debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", name, ty, gateage);\n                 return;\n             }\n         }\n@@ -826,6 +825,8 @@ impl<'a> Context<'a> {\n                            are reserved for internal compiler diagnostics\");\n         } else if name.starts_with(\"derive_\") {\n             gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n+        } else if attr::is_known(attr) {\n+            debug!(\"check_attribute: {:?} is known\", name);\n         } else {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs\n@@ -996,6 +997,10 @@ fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n     }\n }\n \n+fn starts_with_digit(s: &str) -> bool {\n+    s.as_bytes().first().cloned().map_or(false, |b| b >= b'0' && b <= b'9')\n+}\n+\n impl<'a> Visitor for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !self.context.cm.span_allows_unstable(attr.span) {\n@@ -1175,6 +1180,11 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                         gate_feature_post!(&self, field_init_shorthand, field.span,\n                                            \"struct field shorthands are unstable\");\n                     }\n+                    if starts_with_digit(&field.ident.node.name.as_str()) {\n+                        gate_feature_post!(&self, relaxed_adts,\n+                                          field.span,\n+                                          \"numeric fields in struct expressions are unstable\");\n+                    }\n                 }\n             }\n             _ => {}\n@@ -1201,10 +1211,14 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n-            PatKind::TupleStruct(_, ref fields, ddpos)\n-                    if ddpos.is_none() && fields.is_empty() => {\n-                gate_feature_post!(&self, relaxed_adts, pattern.span,\n-                                   \"empty tuple structs patterns are unstable\");\n+            PatKind::Struct(_, ref fields, _) => {\n+                for field in fields {\n+                    if starts_with_digit(&field.node.ident.name.as_str()) {\n+                        gate_feature_post!(&self, relaxed_adts,\n+                                          field.span,\n+                                          \"numeric fields in struct patterns are unstable\");\n+                    }\n+                }\n             }\n             _ => {}\n         }\n@@ -1287,19 +1301,6 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_variant_data(&mut self, vdata: &ast::VariantData, _: ast::Ident,\n-                          _: &ast::Generics, _: NodeId, span: Span) {\n-        if vdata.fields().is_empty() {\n-            if vdata.is_tuple() {\n-                gate_feature_post!(&self, relaxed_adts, span,\n-                                   \"empty tuple structs and enum variants are unstable, \\\n-                                    use unit structs and enum variants instead\");\n-            }\n-        }\n-\n-        visit::walk_struct_def(self, vdata)\n-    }\n-\n     fn visit_vis(&mut self, vis: &ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,"}, {"sha": "3305c1eae2b00ee6106ae8fab877fcddc4d2b463", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,28 +12,43 @@ use std::panic;\n \n use errors::FatalError;\n use proc_macro::{TokenStream, __internal};\n-use syntax::ast::{self, ItemKind};\n-use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan, Span};\n+use syntax::ast::{self, ItemKind, Attribute};\n+use syntax::attr::{mark_used, mark_known};\n+use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::fold::Folder;\n-use syntax::parse::token::intern;\n-use syntax::print::pprust;\n+use syntax::parse::token::InternedString;\n+use syntax::visit::Visitor;\n+\n+struct MarkAttrs<'a>(&'a [InternedString]);\n+\n+impl<'a> Visitor for MarkAttrs<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        if self.0.contains(&attr.name()) {\n+            mark_used(attr);\n+            mark_known(attr);\n+        }\n+    }\n+}\n \n pub struct CustomDerive {\n     inner: fn(TokenStream) -> TokenStream,\n+    attrs: Vec<InternedString>,\n }\n \n impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream) -> CustomDerive {\n-        CustomDerive { inner: inner }\n+    pub fn new(inner: fn(TokenStream) -> TokenStream,\n+               attrs: Vec<InternedString>)\n+               -> CustomDerive {\n+        CustomDerive { inner: inner, attrs: attrs }\n     }\n }\n \n impl MultiItemModifier for CustomDerive {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              meta_item: &ast::MetaItem,\n+              _meta_item: &ast::MetaItem,\n               item: Annotatable)\n               -> Vec<Annotatable> {\n         let item = match item {\n@@ -47,31 +62,23 @@ impl MultiItemModifier for CustomDerive {\n         };\n         match item.node {\n             ItemKind::Struct(..) |\n-            ItemKind::Enum(..) => {}\n+            ItemKind::Enum(..) => {},\n             _ => {\n                 ecx.span_err(span, \"custom derive attributes may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n         }\n \n-        let input_span = Span {\n-            expn_id: ecx.codemap().record_expansion(ExpnInfo {\n-                call_site: span,\n-                callee: NameAndSpan {\n-                    format: MacroAttribute(intern(&pprust::meta_item_to_string(meta_item))),\n-                    span: Some(span),\n-                    allow_internal_unstable: true,\n-                },\n-            }),\n-            ..item.span\n-        };\n-        let input = __internal::new_token_stream(item);\n+        // Mark attributes as known, and used.\n+        MarkAttrs(&self.attrs).visit_item(&item);\n+\n+        let input = __internal::new_token_stream(item.clone());\n         let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n             let inner = self.inner;\n             panic::catch_unwind(panic::AssertUnwindSafe(|| inner(input)))\n         });\n-        let item = match res {\n+        let new_items = match res {\n             Ok(stream) => __internal::token_stream_items(stream),\n             Err(e) => {\n                 let msg = \"custom derive attribute panicked\";\n@@ -88,12 +95,13 @@ impl MultiItemModifier for CustomDerive {\n             }\n         };\n \n-        // Right now we have no knowledge of spans at all in custom derive\n-        // macros, everything is just parsed as a string. Reassign all spans to\n-        // the input `item` for better errors here.\n-        item.into_iter().flat_map(|item| {\n-            ChangeSpan { span: input_span }.fold_item(item)\n-        }).map(Annotatable::Item).collect()\n+        let mut res = vec![Annotatable::Item(item)];\n+        // Reassign spans of all expanded items to the input `item`\n+        // for better errors here.\n+        res.extend(new_items.into_iter().flat_map(|item| {\n+            ChangeSpan { span: span }.fold_item(item)\n+        }).map(Annotatable::Item));\n+        res\n     }\n }\n "}, {"sha": "d6d31200a994fcbc29d99422c4c21c56e48085f0", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -30,6 +30,7 @@ struct CustomDerive {\n     trait_name: InternedString,\n     function_name: Ident,\n     span: Span,\n+    attrs: Vec<InternedString>,\n }\n \n struct CollectCustomDerives<'a> {\n@@ -144,7 +145,8 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n         }\n \n         // Once we've located the `#[proc_macro_derive]` attribute, verify\n-        // that it's of the form `#[proc_macro_derive(Foo)]`\n+        // that it's of the form `#[proc_macro_derive(Foo)]` or\n+        // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n         let list = match attr.meta_item_list() {\n             Some(list) => list,\n             None => {\n@@ -154,38 +156,69 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n                 return\n             }\n         };\n-        if list.len() != 1 {\n+        if list.len() != 1 && list.len() != 2 {\n             self.handler.span_err(attr.span(),\n-                                  \"attribute must only have one argument\");\n+                                  \"attribute must have either one or two arguments\");\n             return\n         }\n-        let attr = &list[0];\n-        let trait_name = match attr.name() {\n+        let trait_attr = &list[0];\n+        let attributes_attr = list.get(1);\n+        let trait_name = match trait_attr.name() {\n             Some(name) => name,\n             _ => {\n-                self.handler.span_err(attr.span(), \"not a meta item\");\n+                self.handler.span_err(trait_attr.span(), \"not a meta item\");\n                 return\n             }\n         };\n-        if !attr.is_word() {\n-            self.handler.span_err(attr.span(), \"must only be one word\");\n+        if !trait_attr.is_word() {\n+            self.handler.span_err(trait_attr.span(), \"must only be one word\");\n         }\n \n         if deriving::is_builtin_trait(&trait_name) {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(trait_attr.span(),\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n \n         if self.derives.iter().any(|d| d.trait_name == trait_name) {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(trait_attr.span(),\n                                   \"derive mode defined twice in this crate\");\n         }\n \n+        let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n+            if !attr.check_name(\"attributes\") {\n+                self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n+            }\n+            attr.meta_item_list().unwrap_or_else(|| {\n+                self.handler.span_err(attr.span(),\n+                                      \"attribute must be of form: \\\n+                                       `attributes(foo, bar)`\");\n+                &[]\n+            }).into_iter().filter_map(|attr| {\n+                let name = match attr.name() {\n+                    Some(name) => name,\n+                    _ => {\n+                        self.handler.span_err(attr.span(), \"not a meta item\");\n+                        return None;\n+                    },\n+                };\n+\n+                if !attr.is_word() {\n+                    self.handler.span_err(attr.span(), \"must only be one word\");\n+                    return None;\n+                }\n+\n+                Some(name)\n+            }).collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n         if self.in_root {\n             self.derives.push(CustomDerive {\n                 span: item.span,\n                 trait_name: trait_name,\n                 function_name: item.ident,\n+                attrs: proc_attrs,\n             });\n         } else {\n             let msg = \"functions tagged with `#[proc_macro_derive]` must \\\n@@ -219,8 +252,8 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n //\n //          #[plugin_registrar]\n //          fn registrar(registrar: &mut Registry) {\n-//              registrar.register_custom_derive($name_trait1, ::$name1);\n-//              registrar.register_custom_derive($name_trait2, ::$name2);\n+//              registrar.register_custom_derive($name_trait1, ::$name1, &[]);\n+//              registrar.register_custom_derive($name_trait2, ::$name2, &[\"attribute_name\"]);\n //              // ...\n //          }\n //      }\n@@ -249,14 +282,18 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n         let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n-        (path, trait_name)\n-    }).map(|(path, trait_name)| {\n+        let attrs = cx.expr_vec_slice(\n+            span,\n+            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.clone())).collect::<Vec<_>>()\n+        );\n+        (path, trait_name, attrs)\n+    }).map(|(path, trait_name, attrs)| {\n         let registrar = cx.expr_ident(span, registrar);\n         let ufcs_path = cx.path(span, vec![proc_macro, __internal, registry,\n                                            register_custom_derive]);\n         cx.expr_call(span,\n                      cx.expr_path(ufcs_path),\n-                     vec![registrar, trait_name, cx.expr_path(path)])\n+                     vec![registrar, trait_name, cx.expr_path(path), attrs])\n     }).map(|expr| {\n         cx.stmt_expr(expr)\n     }).collect::<Vec<_>>();"}, {"sha": "e22339694f9b002b910a138a6ce500e521229991", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -33,8 +33,8 @@ pub fn foo3(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n \n-#[proc_macro_derive(b, c)]\n-//~^ ERROR: attribute must only have one argument\n+#[proc_macro_derive(b, c, d)]\n+//~^ ERROR: attribute must have either one or two arguments\n pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n@@ -44,3 +44,21 @@ pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n pub fn foo5(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n+\n+#[proc_macro_derive(f, attributes(g = \"h\"))]\n+//~^ ERROR: must only be one word\n+pub fn foo6(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(i, attributes(j(k)))]\n+//~^ ERROR: must only be one word\n+pub fn foo7(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(l, attributes(m), n)]\n+//~^ ERROR: attribute must have either one or two arguments\n+pub fn foo8(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}"}, {"sha": "70b778b1030e7eb21228e345452b8a0a38718f9a", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(B, attributes(B))]\n+pub fn derive_b(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "4f4ed90f8fca2be697a1c707da5218aaa2431ad5", "filename": "src/test/compile-fail-fulldeps/proc-macro/expand-to-unstable-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable-2.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -17,8 +17,8 @@\n extern crate derive_unstable_2;\n \n #[derive(Unstable)]\n-struct A;\n //~^ ERROR: reserved for internal compiler\n+struct A;\n \n fn main() {\n     foo();"}, {"sha": "84ac776a765a2631f6505e54340482f7c1bfc620", "filename": "src/test/compile-fail-fulldeps/proc-macro/expand-to-unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -17,8 +17,8 @@\n extern crate derive_unstable;\n \n #[derive(Unstable)]\n-struct A;\n //~^ ERROR: use of unstable library feature\n+struct A;\n \n fn main() {\n     unsafe { foo(); }"}, {"sha": "2a68accf91f714ca5b824bde2e339382f5578632", "filename": "src/test/compile-fail-fulldeps/proc-macro/item-error.rs", "status": "renamed", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,20 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Z(u8, u8);\n+// aux-build:derive-b.rs\n \n-enum E {\n-    U(u8, u8),\n+#![feature(proc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(B)]\n+struct A {\n+    a: &u64\n+//~^ ERROR: missing lifetime specifier\n }\n \n fn main() {\n-    match Z(0, 1) {\n-        Z{..} => {} //~ ERROR tuple structs and variants in struct patterns are unstable\n-    }\n-    match E::U(0, 1) {\n-        E::U{..} => {} //~ ERROR tuple structs and variants in struct patterns are unstable\n-    }\n-\n-    let z1 = Z(0, 1);\n-    let z2 = Z { ..z1 }; //~ ERROR tuple structs and variants in struct patterns are unstable\n }", "previous_filename": "src/test/compile-fail/feature-gate-relaxed-adts-2.rs"}, {"sha": "651a277d4abd5eab31d98efce63c2ec8282046b2", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-attributes.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+\n+#![feature(proc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(B)]\n+#[B]\n+#[C] //~ ERROR: The attribute `C` is currently unknown to the compiler\n+#[B(D)]\n+#[B(E = \"foo\")]\n+struct B;\n+\n+fn main() {}"}, {"sha": "4a302865634224b5f541664e70f1fe5921c17f2e", "filename": "src/test/compile-fail/auxiliary/empty-struct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fempty-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fempty-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fempty-struct.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(relaxed_adts)]\n-\n pub struct XEmpty1 {}\n pub struct XEmpty2;\n pub struct XEmpty6();"}, {"sha": "d42c0ee1a4da5c14ecd7a8b6f9caed0a7991b446", "filename": "src/test/compile-fail/auxiliary/namespace-mix-new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-new.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(item_like_imports, relaxed_adts)]\n+#![feature(item_like_imports)]\n \n pub mod c {\n     pub struct S {}"}, {"sha": "29b139d771b0deebe0fa6054f8059831bee9fc3b", "filename": "src/test/compile-fail/auxiliary/namespace-mix-old.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fnamespace-mix-old.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,8 +10,6 @@\n \n // FIXME: Remove when `item_like_imports` is stabilized.\n \n-#![feature(relaxed_adts)]\n-\n pub mod c {\n     pub struct S {}\n     pub struct TS();"}, {"sha": "4349e72c5d73be4af2d24c2a54ba9232bbbfd518", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:empty-struct.rs\n \n-#![feature(relaxed_adts)]\n-\n extern crate empty_struct;\n use empty_struct::*;\n "}, {"sha": "d6c5b95349211e75e9c18eef9c96ec7597020c93", "filename": "src/test/compile-fail/empty-struct-braces-pat-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-3.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:empty-struct.rs\n \n-#![feature(relaxed_adts)]\n-\n extern crate empty_struct;\n use empty_struct::*;\n "}, {"sha": "5e683eafade8a311ed292becb5a7b63251ebc40d", "filename": "src/test/compile-fail/empty-struct-tuple-pat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-tuple-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-tuple-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-tuple-pat.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:empty-struct.rs\n \n-#![feature(relaxed_adts)]\n-\n extern crate empty_struct;\n use empty_struct::*;\n "}, {"sha": "532c2d85053f6b4d56ac6b7d1d8bdf37dcb527c1", "filename": "src/test/compile-fail/empty-struct-unit-pat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:empty-struct.rs\n \n-#![feature(relaxed_adts)]\n-\n extern crate empty_struct;\n use empty_struct::*;\n "}, {"sha": "f7cae91aa93a43e334e5812f19499aff4aae6897", "filename": "src/test/compile-fail/issue-17800.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(relaxed_adts)]\n-\n enum MyOption<T> {\n     MySome(T),\n     MyNone,"}, {"sha": "86906ed9af2063117182176dc1f828bff541cca6", "filename": "src/test/compile-fail/issue-3907.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -18,7 +18,7 @@ struct S {\n }\n \n impl Foo for S { //~ ERROR: `Foo` is not a trait\n-                 //~| NOTE: not a trait\n+                 //~| NOTE: expected trait, found type alias\n                  //~| NOTE: type aliases cannot be used for traits\n     fn bar() { }\n }"}, {"sha": "19803079d022493a9569996064f3d0d4ca4bc2f4", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(relaxed_adts)]\n-\n struct NonCopyable(());\n \n fn main() {"}, {"sha": "8ebcba47134001d32600e1bbac93ed552f91802b", "filename": "src/test/compile-fail/issue-5035.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-5035.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fissue-5035.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -11,7 +11,7 @@\n trait I {}\n type K = I;\n impl K for isize {} //~ ERROR: `K` is not a trait\n-                    //~| NOTE: not a trait\n+                    //~| NOTE: expected trait, found type alias\n                     //~| NOTE: aliases cannot be used for traits\n \n use ImportError; //~ ERROR unresolved import `ImportError` [E0432]"}, {"sha": "59592e3d737d8f6478b4c10a9c865054c8826da4", "filename": "src/test/compile-fail/namespace-mix-new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-new.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:namespace-mix-new.rs\n \n-#![feature(item_like_imports, relaxed_adts)]\n+#![feature(item_like_imports)]\n \n extern crate namespace_mix_new;\n use namespace_mix_new::*;"}, {"sha": "8cd82050814a001674d250edccb542fddc0e3b18", "filename": "src/test/compile-fail/namespace-mix-old.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix-old.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:namespace-mix-old.rs\n \n-#![feature(relaxed_adts)]\n-\n extern crate namespace_mix_old;\n use namespace_mix_old::{xm1, xm2, xm3, xm4, xm5, xm6, xm7, xm8, xm9, xmA, xmB, xmC};\n "}, {"sha": "3ce85813a9b519a9d351c1db38528c3145c01fde", "filename": "src/test/compile-fail/numeric-fields-feature-gate.rs", "status": "renamed", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fnumeric-fields-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fcompile-fail%2Fnumeric-fields-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnumeric-fields-feature-gate.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,19 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S(); //~ ERROR empty tuple structs and enum variants are unstable\n-struct Z(u8, u8);\n-\n-enum E {\n-    V(), //~ ERROR empty tuple structs and enum variants are unstable\n-    U(u8, u8),\n-}\n+struct S(u8);\n \n fn main() {\n-    match S() {\n-        S() => {} //~ ERROR empty tuple structs patterns are unstable\n-    }\n-    match E::V() {\n-        E::V() => {} //~ ERROR empty tuple structs patterns are unstable\n+    let s = S{0: 10}; //~ ERROR numeric fields in struct expressions are unstable\n+    match s {\n+        S{0: a, ..} => {} //~ ERROR numeric fields in struct patterns are unstable\n     }\n }", "previous_filename": "src/test/compile-fail/feature-gate-relaxed-adts.rs"}, {"sha": "7bfd8077a3da6abb117cc70edc8229724ecaa8ce", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,228 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for let expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+// Change Name -----------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_name() {\n+    let _x = 2u64;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_name() {\n+    let _y = 2u64;\n+}\n+\n+\n+\n+// Add Type --------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_type() {\n+    let _x = 2u32;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_type() {\n+    let _x: u32 = 2u32;\n+}\n+\n+\n+\n+// Change Type -----------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_type() {\n+    let _x: u64 = 2;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_type() {\n+    let _x: u8 = 2;\n+}\n+\n+\n+\n+// Change Mutability of Reference Type -----------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_mutability_of_reference_type() {\n+    let _x: &u64;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_mutability_of_reference_type() {\n+    let _x: &mut u64;\n+}\n+\n+\n+\n+// Change Mutability of Slot ---------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_mutability_of_slot() {\n+    let mut _x: u64 = 0;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_mutability_of_slot() {\n+    let _x: u64 = 0;\n+}\n+\n+\n+\n+// Change Simple Binding to Pattern --------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_simple_binding_to_pattern() {\n+    let _x = (0u8, 'x');\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_simple_binding_to_pattern() {\n+    let (_a, _b) = (0u8, 'x');\n+}\n+\n+\n+\n+// Change Name in Pattern ------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_name_in_pattern() {\n+    let (_a, _b) = (1u8, 'y');\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_name_in_pattern() {\n+    let (_a, _c) = (1u8, 'y');\n+}\n+\n+\n+\n+// Add `ref` in Pattern --------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_ref_in_pattern() {\n+    let (_a, _b) = (1u8, 'y');\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_ref_in_pattern() {\n+    let (ref _a, _b) = (1u8, 'y');\n+}\n+\n+\n+\n+// Add `&` in Pattern ----------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_amp_in_pattern() {\n+    let (_a, _b) = (&1u8, 'y');\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_amp_in_pattern() {\n+    let (&_a, _b) = (&1u8, 'y');\n+}\n+\n+\n+\n+// Change Mutability of Binding in Pattern -------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_mutability_of_binding_in_pattern() {\n+    let (_a, _b) = (99u8, 'q');\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_mutability_of_binding_in_pattern() {\n+    let (mut _a, _b) = (99u8, 'q');\n+}\n+\n+\n+\n+// Add Initializer -------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_initializer() {\n+    let _x: i16;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_initializer() {\n+    let _x: i16 = 3i16;\n+}\n+\n+\n+\n+// Change Initializer ----------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_initializer() {\n+    let _x = 4u16;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_initializer() {\n+    let _x = 5u16;\n+}"}, {"sha": "95e94a91c5bb1070c5ae1075a67c5673aa2297da", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,342 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for match expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+// Add Arm ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_arm(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        _ => 100,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_arm(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        2 => 2,\n+        _ => 100,\n+    }\n+}\n+\n+\n+\n+// Change Order Of Arms --------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_order_of_arms(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        _ => 100,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_order_of_arms(x: u32) -> u32 {\n+    match x {\n+        1 => 1,\n+        0 => 0,\n+        _ => 100,\n+    }\n+}\n+\n+\n+\n+// Add Guard Clause ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        _ => 100,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 if y => 1,\n+        _ => 100,\n+    }\n+}\n+\n+\n+\n+// Change Guard Clause ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 if y => 1,\n+        _ => 100,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 if !y => 1,\n+        _ => 100,\n+    }\n+}\n+\n+\n+\n+// Add @-Binding ---------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_at_binding(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        _ => x,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_at_binding(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        x @ _ => x,\n+    }\n+}\n+\n+\n+\n+// Change Name of @-Binding ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_name_of_at_binding(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        x @ _ => 7,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_name_of_at_binding(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        y @ _ => 7,\n+    }\n+}\n+\n+\n+\n+// Change Simple Binding To Pattern --------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (0, 0) => 0,\n+        a      => 1\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (0, 0) => 0,\n+        (x, y) => 1\n+    }\n+}\n+\n+\n+\n+// Change Name In Pattern ------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_name_in_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (a, 0) => 0,\n+        (a, 1) => a,\n+        _ => 100,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_name_in_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (b, 0) => 0,\n+        (a, 1) => a,\n+        _ => 100,\n+    }\n+}\n+\n+\n+\n+// Change Mutability Of Binding In Pattern -------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (a, 0) => 0,\n+        _      => 1\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (mut a, 0) => 0,\n+        _      => 1\n+    }\n+}\n+\n+\n+\n+// Add `ref` To Binding In Pattern -------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (a, 0) => 0,\n+        _      => 1\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n+    match (x, x & 1) {\n+        (ref a, 0) => 0,\n+        _      => 1,\n+    }\n+}\n+\n+\n+\n+// Add `&` To Binding In Pattern -------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n+    match (&x, x & 1) {\n+        (a, 0) => 0,\n+        _      => 1\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n+    match (&x, x & 1) {\n+        (&a, 0) => 0,\n+        _      => 1,\n+    }\n+}\n+\n+\n+\n+// Change RHS Of Arm -----------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn change_rhs_of_arm(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        _ => 2,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn change_rhs_of_arm(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 3,\n+        _ => 2,\n+    }\n+}\n+\n+\n+\n+// Add Alternative To Arm ------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn add_alternative_to_arm(x: u32) -> u32 {\n+    match x {\n+        0 => 0,\n+        1 => 1,\n+        _ => 2,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn add_alternative_to_arm(x: u32) -> u32 {\n+    match x {\n+        0 | 7 => 0,\n+        1 => 3,\n+        _ => 2,\n+    }\n+}"}, {"sha": "bcc9cdf2d65274404235126fb67183ca83bda50c", "filename": "src/test/run-make/missing-items/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-make%2Fmissing-items%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-make%2Fmissing-items%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmissing-items%2FMakefile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) m1.rs -C prefer-dynamic\n+\t$(RUSTC) m2.rs 2>&1 | grep \"error\\[E0046\\]: not all trait items implemented, missing: .*\"\n+\t$(RUSTC) m2.rs 2>&1 | grep \"  --> m2.rs:18:1\"\n+\t$(RUSTC) m2.rs 2>&1 | grep \"   | ^ missing .CONSTANT., .Type., .method. in implementation\"\n+\t$(RUSTC) m2.rs 2>&1 | grep \"   = note: .CONSTANT. from trait: .const CONSTANT: u32;.\"\n+\t$(RUSTC) m2.rs 2>&1 | grep \"   = note: .Type. from trait: .type Type;.\"\n+\t$(RUSTC) m2.rs 2>&1 | grep \"   = note: .method. from trait: .fn(&Self, std::string::String) -> <Self as m1::X>::Type.\""}, {"sha": "060c7a9571b7b61ffb4f9f1b8bac300fc94323fa", "filename": "src/test/run-make/missing-items/m1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-make%2Fmissing-items%2Fm1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-make%2Fmissing-items%2Fm1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmissing-items%2Fm1.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![crate_type = \"dylib\"]\n+pub trait X {\n+  const CONSTANT: u32;\n+  type Type;\n+  fn method(&self, s: String) -> Self::Type;\n+}"}, {"sha": "7055673acc9a91db82dff223b8d7c4b24aecb37a", "filename": "src/test/run-make/missing-items/m2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-make%2Fmissing-items%2Fm2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-make%2Fmissing-items%2Fm2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmissing-items%2Fm2.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![crate_type = \"dylib\"]\n+extern crate m1;\n+\n+struct X {\n+}\n+\n+impl m1::X for X {\n+}"}, {"sha": "79ce3cb68d4be7e1bbdac925fa2b879f64089ef7", "filename": "src/test/run-pass-fulldeps/empty-struct-braces-derive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,7 +10,6 @@\n \n // `#[derive(Trait)]` works for empty structs/variants with braces or parens.\n \n-#![feature(relaxed_adts)]\n #![feature(rustc_private)]\n \n extern crate serialize as rustc_serialize;"}, {"sha": "1d34049db249fa74ef531728ef38a0712bfbf604", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/add-impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -21,13 +21,12 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AddImpl)]\n // #[cfg(proc_macro)]\n pub fn derive(input: TokenStream) -> TokenStream {\n-    (input.to_string() + \"\n-        impl B {\n+    \"impl B {\n             fn foo(&self) {}\n         }\n \n         fn foo() {}\n \n         mod bar { pub fn foo() {} }\n-    \").parse().unwrap()\n+    \".parse().unwrap()\n }"}, {"sha": "7260bc4a5e7bb275b72059598f2c2ba56f56f954", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/append-impl.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -21,11 +21,8 @@ use proc_macro::TokenStream;\n \n #[proc_macro_derive(Append)]\n pub fn derive_a(input: TokenStream) -> TokenStream {\n-    let mut input = input.to_string();\n-    input.push_str(\"\n-        impl Append for A {\n-            fn foo(&self) {}\n-        }\n-    \");\n-    input.parse().unwrap()\n+    \"impl Append for A {\n+         fn foo(&self) {}\n+     }\n+    \".parse().unwrap()\n }"}, {"sha": "eaada5542274c148ac528e51b6ab56ca7c75dcd2", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -23,5 +23,5 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n     assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n-    \"#[derive(Debug, PartialEq, Eq, Copy, Clone)] struct A;\".parse().unwrap()\n+    \"\".parse().unwrap()\n }"}, {"sha": "a02b798c8023e3b21bd58b2d15861664c693d685", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(B, attributes(B, C))]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert!(input.contains(\"#[B]\"));\n+    assert!(input.contains(\"struct B {\"));\n+    assert!(input.contains(\"#[C]\"));\n+    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n+    \"\".parse().unwrap()\n+}"}, {"sha": "bc8a0d575913b083a695b0a13fe4d11263c8dcd0", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -21,7 +21,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive1(input: TokenStream) -> TokenStream {\n     println!(\"input1: {:?}\", input.to_string());\n-    assert_eq!(input.to_string(), \"#[derive(BToC)]\\nstruct A;\\n\");\n+    assert_eq!(input.to_string(), \"struct A;\\n\");\n     \"#[derive(BToC)] struct B;\".parse().unwrap()\n }\n "}, {"sha": "50eaf035962f13acdf8090a0fc1e7e250afb1401", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/expand-with-a-macro.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -24,8 +24,6 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n     r#\"\n-        struct A;\n-\n         impl A {\n             fn a(&self) {\n                 panic!(\"hello\");"}, {"sha": "f5bb93f012490d32f75fdb55dc68fcca8cf46b54", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-b.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(Debug, PartialEq, B, Eq, Copy, Clone)]\n+#[B]\n+struct B {\n+    #[C]\n+    a: u64\n+}\n+\n+fn main() {\n+    B { a: 3 };\n+    assert_eq!(B { a: 3 }, B { a: 3 });\n+    let b = B { a: 3 };\n+    let _d = b;\n+    let _e = b;\n+}"}, {"sha": "608f86bca576899a7ce06a11419baecb4c67869c", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -15,7 +15,7 @@\n #[macro_use]\n extern crate derive_same_struct;\n \n-#[derive(AToB, BToC)]\n+#[derive(AToB)]\n struct A;\n \n fn main() {"}, {"sha": "734e57a774d87935a50b08162effe599960a69e0", "filename": "src/test/run-pass/auxiliary/empty-struct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass%2Fauxiliary%2Fempty-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass%2Fauxiliary%2Fempty-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fempty-struct.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(relaxed_adts)]\n-\n pub struct XEmpty1 {}\n pub struct XEmpty2;\n pub struct XEmpty7();"}, {"sha": "7c161ba8dd96e71c84e6eab12aac3680ba05c58d", "filename": "src/test/run-pass/empty-struct-braces.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -13,8 +13,6 @@\n \n // aux-build:empty-struct.rs\n \n-#![feature(relaxed_adts)]\n-\n extern crate empty_struct;\n use empty_struct::*;\n "}, {"sha": "d05e6eb2bbe4da144b184bf1a3d8ddf5b8250ca7", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -2,7 +2,7 @@ error[E0404]: `Bar` is not a trait\n   --> $DIR/two_files.rs:15:6\n    |\n 15 | impl Bar for Baz { }\n-   |      ^^^ not a trait\n+   |      ^^^ expected trait, found type alias\n    |\n    = note: type aliases cannot be used for traits\n "}, {"sha": "9e757860a857b3f96309eb8a721b3c3ea94c637a", "filename": "src/test/ui/span/E0046.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2FE0046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2FE0046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0046.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,6 +10,7 @@\n \n trait Foo {\n     fn foo();\n+    //~^ NOTE `foo` from trait\n }\n \n struct Bar;", "previous_filename": "src/test/compile-fail/E0046.rs"}, {"sha": "729a515612463396cf588abc8c38f174ed0c092f", "filename": "src/test/ui/span/E0046.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2FE0046.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2FE0046.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0046.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,11 @@\n+error[E0046]: not all trait items implemented, missing: `foo`\n+  --> $DIR/E0046.rs:18:1\n+   |\n+12 |     fn foo();\n+   |     --------- `foo` from trait\n+...\n+18 | impl Foo for Bar {}\n+   | ^^^^^^^^^^^^^^^^^^^ missing `foo` in implementation\n+\n+error: aborting due to previous error\n+"}, {"sha": "54ed42af5d582028bd4b241ddbc32daebfddb9ae", "filename": "src/test/ui/span/impl-wrong-item-for-trait.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -10,11 +10,11 @@\n \n #![feature(associated_consts)]\n \n+use std::fmt::Debug;\n+\n trait Foo {\n     fn bar(&self);\n-    //~^ NOTE item in trait\n-    //~| NOTE item in trait\n-    const MY_CONST: u32; //~ NOTE item in trait\n+    const MY_CONST: u32;\n }\n \n pub struct FooConstForMethod;\n@@ -50,4 +50,7 @@ impl Foo for FooTypeForMethod {\n     const MY_CONST: u32 = 1;\n }\n \n+impl Debug for FooTypeForMethod {\n+}\n+\n fn main () {}", "previous_filename": "src/test/compile-fail/impl-wrong-item-for-trait.rs"}, {"sha": "244285e358453ee9737d9a238c5b612072b0407a", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,64 @@\n+error[E0323]: item `bar` is an associated const, which doesn't match its trait `<FooConstForMethod as Foo>`\n+  --> $DIR/impl-wrong-item-for-trait.rs:25:5\n+   |\n+16 |     fn bar(&self);\n+   |     -------------- item in trait\n+...\n+25 |     const bar: u64 = 1;\n+   |     ^^^^^^^^^^^^^^^^^^^ does not match trait\n+\n+error[E0046]: not all trait items implemented, missing: `bar`\n+  --> $DIR/impl-wrong-item-for-trait.rs:22:1\n+   |\n+16 |     fn bar(&self);\n+   |     -------------- `bar` from trait\n+...\n+22 | impl Foo for FooConstForMethod {\n+   | ^ missing `bar` in implementation\n+\n+error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `<FooMethodForConst as Foo>`\n+  --> $DIR/impl-wrong-item-for-trait.rs:37:5\n+   |\n+17 |     const MY_CONST: u32;\n+   |     -------------------- item in trait\n+...\n+37 |     fn MY_CONST() {}\n+   |     ^^^^^^^^^^^^^^^^ does not match trait\n+\n+error[E0046]: not all trait items implemented, missing: `MY_CONST`\n+  --> $DIR/impl-wrong-item-for-trait.rs:33:1\n+   |\n+17 |     const MY_CONST: u32;\n+   |     -------------------- `MY_CONST` from trait\n+...\n+33 | impl Foo for FooMethodForConst {\n+   | ^ missing `MY_CONST` in implementation\n+\n+error[E0325]: item `bar` is an associated type, which doesn't match its trait `<FooTypeForMethod as Foo>`\n+  --> $DIR/impl-wrong-item-for-trait.rs:47:5\n+   |\n+16 |     fn bar(&self);\n+   |     -------------- item in trait\n+...\n+47 |     type bar = u64;\n+   |     ^^^^^^^^^^^^^^^ does not match trait\n+\n+error[E0046]: not all trait items implemented, missing: `bar`\n+  --> $DIR/impl-wrong-item-for-trait.rs:44:1\n+   |\n+16 |     fn bar(&self);\n+   |     -------------- `bar` from trait\n+...\n+44 | impl Foo for FooTypeForMethod {\n+   | ^ missing `bar` in implementation\n+\n+error[E0046]: not all trait items implemented, missing: `fmt`\n+  --> $DIR/impl-wrong-item-for-trait.rs:53:1\n+   |\n+53 | impl Debug for FooTypeForMethod {\n+   | ^ missing `fmt` in implementation\n+   |\n+   = note: `fmt` from trait: `fn(&Self, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "66134a03baf41319a72d8af61edd68e9c0f663fc", "filename": "src/test/ui/span/issue-23729.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23729.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23729.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23729.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -20,6 +20,7 @@ fn main() {\n         impl Iterator for Recurrence {\n             //~^ ERROR E0046\n             //~| NOTE missing `Item` in implementation\n+            //~| NOTE `Item` from trait: `type Item;`\n             #[inline]\n             fn next(&mut self) -> Option<u64> {\n                 if self.pos < 2 {", "previous_filename": "src/test/compile-fail/issue-23729.rs"}, {"sha": "493ca01778bc15de42d55ce7865f1e381bc2f9cf", "filename": "src/test/ui/span/issue-23729.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,10 @@\n+error[E0046]: not all trait items implemented, missing: `Item`\n+  --> $DIR/issue-23729.rs:20:9\n+   |\n+20 |         impl Iterator for Recurrence {\n+   |         ^ missing `Item` in implementation\n+   |\n+   = note: `Item` from trait: `type Item;`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a5ab443597b9b71b059e0b365faaa28cd70bae05", "filename": "src/test/ui/span/issue-23827.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -36,6 +36,7 @@ impl<C: Component> FnMut<(C,)> for Prototype {\n impl<C: Component> FnOnce<(C,)> for Prototype {\n     //~^ ERROR E0046\n     //~| NOTE missing `Output` in implementation\n+    //~| NOTE `Output` from trait: `type Output;`\n     extern \"rust-call\" fn call_once(self, (comp,): (C,)) -> Prototype {\n         Fn::call(&self, (comp,))\n     }", "previous_filename": "src/test/compile-fail/issue-23827.rs"}, {"sha": "5130bb53a198bf2bb9ce01bd883ac44d1dbdb450", "filename": "src/test/ui/span/issue-23827.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,10 @@\n+error[E0046]: not all trait items implemented, missing: `Output`\n+  --> $DIR/issue-23827.rs:36:1\n+   |\n+36 | impl<C: Component> FnOnce<(C,)> for Prototype {\n+   | ^ missing `Output` in implementation\n+   |\n+   = note: `Output` from trait: `type Output;`\n+\n+error: aborting due to previous error\n+"}, {"sha": "0997dc802f88bfc7a9cc70c8959e278ea2576416", "filename": "src/test/ui/span/issue-24356.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-24356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-24356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24356.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -30,6 +30,7 @@ fn main() {\n         impl Deref for Thing {\n             //~^ ERROR E0046\n             //~| NOTE missing `Target` in implementation\n+            //~| NOTE `Target` from trait: `type Target;`\n             fn deref(&self) -> i8 { self.0 }\n         }\n ", "previous_filename": "src/test/compile-fail/issue-24356.rs"}, {"sha": "906ef25ca0e10b4d3d405ab839df60ffb2b6d4ac", "filename": "src/test/ui/span/issue-24356.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,10 @@\n+error[E0046]: not all trait items implemented, missing: `Target`\n+  --> $DIR/issue-24356.rs:30:9\n+   |\n+30 |         impl Deref for Thing {\n+   |         ^ missing `Target` in implementation\n+   |\n+   = note: `Target` from trait: `type Target;`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8ff5f3b83986ce14dd90cfc16ec10ced146ac349", "filename": "src/test/ui/span/issue-35987.rs", "status": "renamed", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-35987.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-35987.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-35987.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,19 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct TS ( //~ ERROR empty tuple structs and enum variants are unstable\n-    #[cfg(untrue)]\n-    i32,\n-);\n+struct Foo<T: Clone>(T);\n \n-enum E {\n-    TV ( //~ ERROR empty tuple structs and enum variants are unstable\n-        #[cfg(untrue)]\n-        i32,\n-    )\n-}\n+use std::ops::Add;\n+\n+impl<T: Clone, Add> Add for Foo<T> {\n+    type Output = usize;\n \n-fn main() {\n-    let s = TS;\n-    let tv = E::TV;\n+    fn add(self, rhs: Self) -> Self::Output {\n+        unimplemented!();\n+    }\n }", "previous_filename": "src/test/compile-fail/issue-16819.rs"}, {"sha": "2370b3d6c612edea41f0011319bc476cf7993022", "filename": "src/test/ui/span/issue-35987.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,12 @@\n+error[E0404]: `Add` is not a trait\n+  --> $DIR/issue-35987.rs:15:21\n+   |\n+15 | impl<T: Clone, Add> Add for Foo<T> {\n+   |                ---  ^^^ expected trait, found type parameter\n+   |                |\n+   |                type parameter defined here\n+\n+error: main function not found\n+\n+error: cannot continue compilation due to previous error\n+"}, {"sha": "d6b7dafea40e0135b4e6b1baef68036a2f23c553", "filename": "src/tools/linkchecker/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Flinkchecker%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Flinkchecker%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -3,9 +3,6 @@ name = \"linkchecker\"\n version = \"0.1.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n \n-[dependencies]\n-url = \"1.2\"\n-\n [[bin]]\n name = \"linkchecker\"\n path = \"main.rs\""}, {"sha": "0e70c2b432f20cf776921a88a32e3f5d9ac220ed", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -24,17 +24,13 @@\n //! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n //! but this should catch the majority of \"broken link\" cases.\n \n-extern crate url;\n-\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::{Path, PathBuf};\n+use std::path::{Path, PathBuf, Component};\n use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry;\n \n-use url::Url;\n-\n use Redirect::*;\n \n macro_rules! t {\n@@ -47,9 +43,8 @@ macro_rules! t {\n fn main() {\n     let docs = env::args().nth(1).unwrap();\n     let docs = env::current_dir().unwrap().join(docs);\n-    let mut url = Url::from_file_path(&docs).unwrap();\n     let mut errors = false;\n-    walk(&mut HashMap::new(), &docs, &docs, &mut url, &mut errors);\n+    walk(&mut HashMap::new(), &docs, &docs, &mut errors);\n     if errors {\n         panic!(\"found some broken links\");\n     }\n@@ -88,30 +83,27 @@ impl FileEntry {\n     }\n }\n \n-fn walk(cache: &mut Cache, root: &Path, dir: &Path, url: &mut Url, errors: &mut bool) {\n+fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n     for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n         let path = entry.path();\n         let kind = t!(entry.file_type());\n-        url.path_segments_mut().unwrap().push(entry.file_name().to_str().unwrap());\n         if kind.is_dir() {\n-            walk(cache, root, &path, url, errors);\n+            walk(cache, root, &path, errors);\n         } else {\n-            let pretty_path = check(cache, root, &path, url, errors);\n+            let pretty_path = check(cache, root, &path, errors);\n             if let Some(pretty_path) = pretty_path {\n                 let entry = cache.get_mut(&pretty_path).unwrap();\n                 // we don't need the source anymore,\n                 // so drop to reduce memory-usage\n                 entry.source = String::new();\n             }\n         }\n-        url.path_segments_mut().unwrap().pop();\n     }\n }\n \n fn check(cache: &mut Cache,\n          root: &Path,\n          file: &Path,\n-         base: &Url,\n          errors: &mut bool)\n          -> Option<PathBuf> {\n     // ignore js files as they are not prone to errors as the rest of the\n@@ -157,19 +149,28 @@ fn check(cache: &mut Cache,\n            url.starts_with(\"irc:\") || url.starts_with(\"data:\") {\n             return;\n         }\n+        let mut parts = url.splitn(2, \"#\");\n+        let url = parts.next().unwrap();\n+        if url.is_empty() {\n+            return\n+        }\n+        let fragment = parts.next();\n+        let mut parts = url.splitn(2, \"?\");\n+        let url = parts.next().unwrap();\n+\n         // Once we've plucked out the URL, parse it using our base url and\n         // then try to extract a file path.\n-        let (parsed_url, path) = match url_to_file_path(&base, url) {\n-            Some((url, path)) => (url, PathBuf::from(path)),\n-            None => {\n-                *errors = true;\n-                println!(\"{}:{}: invalid link - {}\",\n-                         pretty_file.display(),\n-                         i + 1,\n-                         url);\n-                return;\n+        let mut path = file.to_path_buf();\n+        path.pop();\n+        for part in Path::new(url).components() {\n+            match part {\n+                Component::Prefix(_) |\n+                Component::RootDir => panic!(),\n+                Component::CurDir => {}\n+                Component::ParentDir => { path.pop(); }\n+                Component::Normal(s) => { path.push(s); }\n             }\n-        };\n+        }\n \n         // Alright, if we've found a file name then this file had better\n         // exist! If it doesn't then we register and print an error.\n@@ -200,7 +201,7 @@ fn check(cache: &mut Cache,\n                 Err(LoadError::IsRedirect) => unreachable!(),\n             };\n \n-            if let Some(ref fragment) = parsed_url.fragment() {\n+            if let Some(ref fragment) = fragment {\n                 // Fragments like `#1-6` are most likely line numbers to be\n                 // interpreted by javascript, so we're ignoring these\n                 if fragment.splitn(2, '-')\n@@ -231,7 +232,7 @@ fn check(cache: &mut Cache,\n \n fn load_file(cache: &mut Cache,\n              root: &Path,\n-             file: PathBuf,\n+             mut file: PathBuf,\n              redirect: Redirect)\n              -> Result<(PathBuf, String), LoadError> {\n     let mut contents = String::new();\n@@ -266,10 +267,9 @@ fn load_file(cache: &mut Cache,\n             maybe\n         }\n     };\n-    let base = Url::from_file_path(&file).unwrap();\n-\n-    match maybe_redirect.and_then(|url| url_to_file_path(&base, &url)) {\n-        Some((_, redirect_file)) => {\n+    file.pop();\n+    match maybe_redirect.map(|url| file.join(url)) {\n+        Some(redirect_file) => {\n             let path = PathBuf::from(redirect_file);\n             load_file(cache, root, path, FromRedirect(true))\n         }\n@@ -293,12 +293,6 @@ fn maybe_redirect(source: &str) -> Option<String> {\n     })\n }\n \n-fn url_to_file_path(parser: &Url, url: &str) -> Option<(Url, PathBuf)> {\n-    parser.join(url)\n-          .ok()\n-          .and_then(|parsed_url| parsed_url.to_file_path().ok().map(|f| (parsed_url, f)))\n-}\n-\n fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str, attr: &str, mut f: F) {\n     for (i, mut line) in contents.lines().enumerate() {\n         while let Some(j) = line.find(attr) {"}, {"sha": "11acb64743a7ac04270fc0d3b6cf2feab7bae148", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -20,6 +20,9 @@ use std::fs::File;\n use std::path::Path;\n \n pub fn check(path: &Path, bad: &mut bool) {\n+    if path.ends_with(\"vendor\") {\n+        return\n+    }\n     for entry in t!(path.read_dir(), path).map(|e| t!(e)) {\n         // Look for `Cargo.toml` with a sibling `src/lib.rs` or `lib.rs`\n         if entry.file_name().to_str() == Some(\"Cargo.toml\") {"}, {"sha": "165dd52758ecc525b21ad7f66b982da99a37ae49", "filename": "src/tools/tidy/src/cargo_lock.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bca365e688f0424fb99d38d477a9b7863bb070d3/src%2Ftools%2Ftidy%2Fsrc%2Fcargo_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca365e688f0424fb99d38d477a9b7863bb070d3/src%2Ftools%2Ftidy%2Fsrc%2Fcargo_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo_lock.rs?ref=bca365e688f0424fb99d38d477a9b7863bb070d3", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::path::Path;\n-use std::ffi::OsStr;\n-\n-const CARGO_LOCK: &'static str = \"Cargo.lock\";\n-\n-pub fn check(path: &Path, bad: &mut bool) {\n-    use std::process::Command;\n-\n-    super::walk(path,\n-                &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n-                &mut |file| {\n-        if let Some(CARGO_LOCK) = file.file_name().and_then(OsStr::to_str) {\n-            let rel_path = file.strip_prefix(path).unwrap();\n-            let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n-            let ret_code = Command::new(\"git\")\n-                                        .arg(\"diff\")\n-                                        .arg(\"--exit-code\")\n-                                        .arg(\"--patch\")\n-                                        .arg(\"HEAD\")\n-                                        .arg(&git_friendly_path)\n-                                        .current_dir(path)\n-                                        .status()\n-                                        .unwrap_or_else(|e| {\n-                                            panic!(\"could not run git diff-index: {}\", e);\n-                                        });\n-            if !ret_code.success() {\n-                let parent_path = file.parent().unwrap().join(\"Cargo.toml\");\n-                print!(\"dirty lock file found at {} \", rel_path.display());\n-                println!(\"please commit your changes or update the lock file by running:\");\n-                println!(\"\\n\\tcargo update --manifest-path {}\", parent_path.display());\n-                *bad = true;\n-            }\n-        }\n-    });\n-}"}, {"sha": "cb11fe261c459a97351a4d8cd30708c8e6325749", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -35,7 +35,6 @@ mod style;\n mod errors;\n mod features;\n mod cargo;\n-mod cargo_lock;\n mod pal;\n \n fn main() {\n@@ -48,7 +47,6 @@ fn main() {\n     errors::check(&path, &mut bad);\n     cargo::check(&path, &mut bad);\n     features::check(&path, &mut bad);\n-    cargo_lock::check(&path, &mut bad);\n     pal::check(&path, &mut bad);\n \n     if bad {\n@@ -66,6 +64,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/rustllvm\",\n         \"src/rust-installer\",\n         \"src/liblibc\",\n+        \"src/vendor\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}, {"sha": "b81d7d2fa04ea3fc6774bcc2455bbdd44611107f", "filename": "src/vendor/cmake/.cargo-checksum.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2F.cargo-checksum.json?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1 @@\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"c1e953ee360e77de57f7b02f1b7880bd6a3dc22d1a69e953c2ac2c52cc52d247\",\".travis.yml\":\"5d83ed1ae0b80cd6cebfc6a25b1fdb58c893ead400f0f84cd0ebf08d9ad48b28\",\"Cargo.toml\":\"2266412ecb4504137a90d378ebdbf3a41f0e8b7188858cfb149da54792f7f8d9\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"8ca528d20639506546044c676ff9069e3e850937b02bff4194dcf9e5c3c50d64\",\"src/lib.rs\":\"dae5d93c005bf8d16427e29eb3bfb50c5527a1ec7c39a383d0694a8e8e38af90\",\"src/registry.rs\":\"ca16433f51b5e3aedb0560bba41370b0c42de9238926a5118d1c0a3a072b64b2\"},\"package\":\"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/vendor/cmake/.cargo-ok", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.cargo-ok", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.cargo-ok", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2F.cargo-ok?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "4fffb2f89cbd8f2169ce9914bd16bd43785bb368", "filename": "src/vendor/cmake/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2F.gitignore?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,2 @@\n+/target\n+/Cargo.lock"}, {"sha": "3ac040c5c0949651083e051c9a2062dd1c325d76", "filename": "src/vendor/cmake/.travis.yml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2F.travis.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,19 @@\n+language: rust\n+rust:\n+  - stable\n+  - beta\n+  - nightly\n+sudo: false\n+before_script:\n+  - pip install 'travis-cargo<0.2' --user && export PATH=$HOME/.local/bin:$PATH\n+script:\n+  - cargo test --verbose\n+  - cargo doc --no-deps\n+after_success:\n+  - travis-cargo --only nightly doc-upload\n+env:\n+  global:\n+    secure: WSQJRyheeMf7eRdivHextSEQzyFnTIw2yeemO2+ZkHVftp0XYsTXQVca3RGlQNsVmjI0RP8lbDVe7HG23uwbTMeRgm+9hzSwNMa0ndJZ06TNMpPM6nqcXFUaNGeuf7EqU370xcgVBO+ZA0cSh55pJkOBg5ALd9bfRWbjEAjHkx8=\n+notifications:\n+  email:\n+    on_success: never"}, {"sha": "c17bbff922582ed964f375787a74094e97fc7136", "filename": "src/vendor/cmake/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+\n+name = \"cmake\"\n+version = \"0.1.18\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+license = \"MIT/Apache-2.0\"\n+readme = \"README.md\"\n+keywords = [\"build-dependencies\"]\n+repository = \"https://github.com/alexcrichton/cmake-rs\"\n+homepage = \"https://github.com/alexcrichton/cmake-rs\"\n+documentation = \"http://alexcrichton.com/cmake-rs\"\n+description = \"\"\"\n+A build dependency for running `cmake` to build a native library\n+\"\"\"\n+\n+[dependencies]\n+gcc = \"0.3.17\""}, {"sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1", "filename": "src/vendor/cmake/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2FLICENSE-APACHE?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "39e0ed6602151f235148e6c08413aa7eda5b9038", "filename": "src/vendor/cmake/LICENSE-MIT", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2FLICENSE-MIT?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2014 Alex Crichton\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "8b2586eb01e25ed43220fe0646fb6904eb1bcacc", "filename": "src/vendor/cmake/README.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2FREADME.md?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,22 @@\n+# cmake\n+\n+[![Build Status](https://travis-ci.org/alexcrichton/cmake-rs.svg?branch=master)](https://travis-ci.org/alexcrichton/cmake-rs)\n+\n+[Documentation](http://alexcrichton.com/cmake-rs)\n+\n+A build dependency for running the `cmake` build tool to compile a native\n+library.\n+\n+```toml\n+# Cargo.toml\n+[build-dependencies]\n+cmake = \"0.2\"\n+```\n+\n+# License\n+\n+`cmake-rs` is primarily distributed under the terms of both the MIT license and\n+the Apache License (Version 2.0), with portions covered by various BSD-like\n+licenses.\n+\n+See LICENSE-APACHE, and LICENSE-MIT for details."}, {"sha": "3607d29026a0361211bc683098ae7266c875c38b", "filename": "src/vendor/cmake/src/lib.rs", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2Fsrc%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,522 @@\n+//! A build dependency for running `cmake` to build a native library\n+//!\n+//! This crate provides some necessary boilerplate and shim support for running\n+//! the system `cmake` command to build a native library. It will add\n+//! appropriate cflags for building code to link into Rust, handle cross\n+//! compilation, and use the necessary generator for the platform being\n+//! targeted.\n+//!\n+//! The builder-style configuration allows for various variables and such to be\n+//! passed down into the build as well.\n+//!\n+//! ## Installation\n+//!\n+//! Add this to your `Cargo.toml`:\n+//!\n+//! ```toml\n+//! [build-dependencies]\n+//! cmake = \"0.1\"\n+//! ```\n+//!\n+//! ## Examples\n+//!\n+//! ```no_run\n+//! use cmake;\n+//!\n+//! // Builds the project in the directory located in `libfoo`, installing it\n+//! // into $OUT_DIR\n+//! let dst = cmake::build(\"libfoo\");\n+//!\n+//! println!(\"cargo:rustc-link-search=native={}\", dst.display());\n+//! println!(\"cargo:rustc-link-lib=static=foo\");\n+//! ```\n+//!\n+//! ```no_run\n+//! use cmake::Config;\n+//!\n+//! let dst = Config::new(\"libfoo\")\n+//!                  .define(\"FOO\", \"BAR\")\n+//!                  .cflag(\"-foo\")\n+//!                  .build();\n+//! println!(\"cargo:rustc-link-search=native={}\", dst.display());\n+//! println!(\"cargo:rustc-link-lib=static=foo\");\n+//! ```\n+\n+#![deny(missing_docs)]\n+\n+extern crate gcc;\n+\n+use std::env;\n+use std::ffi::{OsString, OsStr};\n+use std::fs::{self, File};\n+use std::io::ErrorKind;\n+use std::io::prelude::*;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+#[cfg(windows)]\n+mod registry;\n+\n+/// Builder style configuration for a pending CMake build.\n+pub struct Config {\n+    path: PathBuf,\n+    generator: Option<OsString>,\n+    cflags: OsString,\n+    cxxflags: OsString,\n+    defines: Vec<(OsString, OsString)>,\n+    deps: Vec<String>,\n+    target: Option<String>,\n+    host: Option<String>,\n+    out_dir: Option<PathBuf>,\n+    profile: Option<String>,\n+    build_args: Vec<OsString>,\n+    cmake_target: Option<String>,\n+}\n+\n+/// Builds the native library rooted at `path` with the default cmake options.\n+/// This will return the directory in which the library was installed.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use cmake;\n+///\n+/// // Builds the project in the directory located in `libfoo`, installing it\n+/// // into $OUT_DIR\n+/// let dst = cmake::build(\"libfoo\");\n+///\n+/// println!(\"cargo:rustc-link-search=native={}\", dst.display());\n+/// println!(\"cargo:rustc-link-lib=static=foo\");\n+/// ```\n+///\n+pub fn build<P: AsRef<Path>>(path: P) -> PathBuf {\n+    Config::new(path.as_ref()).build()\n+}\n+\n+impl Config {\n+    /// Creates a new blank set of configuration to build the project specified\n+    /// at the path `path`.\n+    pub fn new<P: AsRef<Path>>(path: P) -> Config {\n+        Config {\n+            path: env::current_dir().unwrap().join(path),\n+            generator: None,\n+            cflags: OsString::new(),\n+            cxxflags: OsString::new(),\n+            defines: Vec::new(),\n+            deps: Vec::new(),\n+            profile: None,\n+            out_dir: None,\n+            target: None,\n+            host: None,\n+            build_args: Vec::new(),\n+            cmake_target: None,\n+        }\n+    }\n+\n+    /// Sets the build-tool generator (`-G`) for this compilation.\n+    pub fn generator<T: AsRef<OsStr>>(&mut self, generator: T) -> &mut Config {\n+        self.generator = Some(generator.as_ref().to_owned());\n+        self\n+    }\n+\n+    /// Adds a custom flag to pass down to the C compiler, supplementing those\n+    /// that this library already passes.\n+    pub fn cflag<P: AsRef<OsStr>>(&mut self, flag: P) -> &mut Config {\n+        self.cflags.push(\" \");\n+        self.cflags.push(flag.as_ref());\n+        self\n+    }\n+\n+    /// Adds a custom flag to pass down to the C++ compiler, supplementing those\n+    /// that this library already passes.\n+    pub fn cxxflag<P: AsRef<OsStr>>(&mut self, flag: P) -> &mut Config {\n+        self.cxxflags.push(\" \");\n+        self.cxxflags.push(flag.as_ref());\n+        self\n+    }\n+\n+    /// Adds a new `-D` flag to pass to cmake during the generation step.\n+    pub fn define<K, V>(&mut self, k: K, v: V) -> &mut Config\n+        where K: AsRef<OsStr>, V: AsRef<OsStr>\n+    {\n+        self.defines.push((k.as_ref().to_owned(), v.as_ref().to_owned()));\n+        self\n+    }\n+\n+    /// Registers a dependency for this compilation on the native library built\n+    /// by Cargo previously.\n+    ///\n+    /// This registration will modify the `CMAKE_PREFIX_PATH` environment\n+    /// variable for the build system generation step.\n+    pub fn register_dep(&mut self, dep: &str) -> &mut Config {\n+        self.deps.push(dep.to_string());\n+        self\n+    }\n+\n+    /// Sets the target triple for this compilation.\n+    ///\n+    /// This is automatically scraped from `$TARGET` which is set for Cargo\n+    /// build scripts so it's not necessary to call this from a build script.\n+    pub fn target(&mut self, target: &str) -> &mut Config {\n+        self.target = Some(target.to_string());\n+        self\n+    }\n+\n+    /// Sets the host triple for this compilation.\n+    ///\n+    /// This is automatically scraped from `$HOST` which is set for Cargo\n+    /// build scripts so it's not necessary to call this from a build script.\n+    pub fn host(&mut self, host: &str) -> &mut Config {\n+        self.host = Some(host.to_string());\n+        self\n+    }\n+\n+    /// Sets the output directory for this compilation.\n+    ///\n+    /// This is automatically scraped from `$OUT_DIR` which is set for Cargo\n+    /// build scripts so it's not necessary to call this from a build script.\n+    pub fn out_dir<P: AsRef<Path>>(&mut self, out: P) -> &mut Config {\n+        self.out_dir = Some(out.as_ref().to_path_buf());\n+        self\n+    }\n+\n+    /// Sets the profile for this compilation.\n+    ///\n+    /// This is automatically scraped from `$PROFILE` which is set for Cargo\n+    /// build scripts so it's not necessary to call this from a build script.\n+    pub fn profile(&mut self, profile: &str) -> &mut Config {\n+        self.profile = Some(profile.to_string());\n+        self\n+    }\n+\n+    /// Add an argument to the final `cmake` build step\n+    pub fn build_arg<A: AsRef<OsStr>>(&mut self, arg: A) -> &mut Config {\n+        self.build_args.push(arg.as_ref().to_owned());\n+        self\n+    }\n+\n+    /// Sets the build target for the final `cmake` build step, this will\n+    /// default to \"install\" if not specified.\n+    pub fn build_target(&mut self, target: &str) -> &mut Config {\n+        self.cmake_target = Some(target.to_string());\n+        self\n+    }\n+\n+    /// Run this configuration, compiling the library with all the configured\n+    /// options.\n+    ///\n+    /// This will run both the build system generator command as well as the\n+    /// command to build the library.\n+    pub fn build(&mut self) -> PathBuf {\n+        let target = self.target.clone().unwrap_or_else(|| {\n+            getenv_unwrap(\"TARGET\")\n+        });\n+        let host = self.host.clone().unwrap_or_else(|| {\n+            getenv_unwrap(\"HOST\")\n+        });\n+        let msvc = target.contains(\"msvc\");\n+        let c_compiler = gcc::Config::new().cargo_metadata(false)\n+                                         .opt_level(0)\n+                                         .debug(false)\n+                                         .target(&target)\n+                                         .host(&host)\n+                                         .get_compiler();\n+        let cxx_compiler = gcc::Config::new().cargo_metadata(false)\n+                                         .cpp(true)\n+                                         .opt_level(0)\n+                                         .debug(false)\n+                                         .target(&target)\n+                                         .host(&host)\n+                                         .get_compiler();\n+\n+        let dst = self.out_dir.clone().unwrap_or_else(|| {\n+            PathBuf::from(getenv_unwrap(\"OUT_DIR\"))\n+        });\n+        let build = dst.join(\"build\");\n+        self.maybe_clear(&build);\n+        let _ = fs::create_dir(&build);\n+\n+        // Add all our dependencies to our cmake paths\n+        let mut cmake_prefix_path = Vec::new();\n+        for dep in &self.deps {\n+            if let Some(root) = env::var_os(&format!(\"DEP_{}_ROOT\", dep)) {\n+                cmake_prefix_path.push(PathBuf::from(root));\n+            }\n+        }\n+        let system_prefix = env::var_os(\"CMAKE_PREFIX_PATH\")\n+                                .unwrap_or(OsString::new());\n+        cmake_prefix_path.extend(env::split_paths(&system_prefix)\n+                                     .map(|s| s.to_owned()));\n+        let cmake_prefix_path = env::join_paths(&cmake_prefix_path).unwrap();\n+\n+        // Build up the first cmake command to build the build system.\n+        let mut cmd = Command::new(\"cmake\");\n+        cmd.arg(&self.path)\n+           .current_dir(&build);\n+        if target.contains(\"windows-gnu\") {\n+            if host.contains(\"windows\") {\n+                // On MinGW we need to coerce cmake to not generate a visual\n+                // studio build system but instead use makefiles that MinGW can\n+                // use to build.\n+                if self.generator.is_none() {\n+                    cmd.arg(\"-G\").arg(\"MSYS Makefiles\");\n+                }\n+            } else {\n+                // If we're cross compiling onto windows, then set some\n+                // variables which will hopefully get things to succeed. Some\n+                // systems may need the `windres` or `dlltool` variables set, so\n+                // set them if possible.\n+                if !self.defined(\"CMAKE_SYSTEM_NAME\") {\n+                    cmd.arg(\"-DCMAKE_SYSTEM_NAME=Windows\");\n+                }\n+                if !self.defined(\"CMAKE_RC_COMPILER\") {\n+                    let exe = find_exe(c_compiler.path());\n+                    if let Some(name) = exe.file_name().unwrap().to_str() {\n+                        let name = name.replace(\"gcc\", \"windres\");\n+                        let windres = exe.with_file_name(name);\n+                        if windres.is_file() {\n+                            let mut arg = OsString::from(\"-DCMAKE_RC_COMPILER=\");\n+                            arg.push(&windres);\n+                            cmd.arg(arg);\n+                        }\n+                    }\n+                }\n+            }\n+        } else if msvc {\n+            // If we're on MSVC we need to be sure to use the right generator or\n+            // otherwise we won't get 32/64 bit correct automatically.\n+            if self.generator.is_none() {\n+                cmd.arg(\"-G\").arg(self.visual_studio_generator(&target));\n+            }\n+        }\n+        if let Some(ref generator) = self.generator {\n+            cmd.arg(\"-G\").arg(generator);\n+        }\n+        let profile = self.profile.clone().unwrap_or_else(|| {\n+            match &getenv_unwrap(\"PROFILE\")[..] {\n+                \"bench\" | \"release\" => \"Release\",\n+                // currently we need to always use the same CRT for MSVC\n+                _ if msvc => \"Release\",\n+                _ => \"Debug\",\n+            }.to_string()\n+        });\n+        for &(ref k, ref v) in &self.defines {\n+            let mut os = OsString::from(\"-D\");\n+            os.push(k);\n+            os.push(\"=\");\n+            os.push(v);\n+            cmd.arg(os);\n+        }\n+\n+        if !self.defined(\"CMAKE_INSTALL_PREFIX\") {\n+            let mut dstflag = OsString::from(\"-DCMAKE_INSTALL_PREFIX=\");\n+            dstflag.push(&dst);\n+            cmd.arg(dstflag);\n+        }\n+\n+        {\n+            let mut set_compiler = |kind: &str,\n+                                    compiler: &gcc::Tool,\n+                                    extra: &OsString| {\n+                let flag_var = format!(\"CMAKE_{}_FLAGS\", kind);\n+                let tool_var = format!(\"CMAKE_{}_COMPILER\", kind);\n+                if !self.defined(&flag_var) {\n+                    let mut flagsflag = OsString::from(\"-D\");\n+                    flagsflag.push(&flag_var);\n+                    flagsflag.push(\"=\");\n+                    flagsflag.push(extra);\n+                    for arg in compiler.args() {\n+                        flagsflag.push(\" \");\n+                        flagsflag.push(arg);\n+                    }\n+                    cmd.arg(flagsflag);\n+                }\n+\n+                // Apparently cmake likes to have an absolute path to the\n+                // compiler as otherwise it sometimes thinks that this variable\n+                // changed as it thinks the found compiler, /usr/bin/cc,\n+                // differs from the specified compiler, cc. Not entirely sure\n+                // what's up, but at least this means cmake doesn't get\n+                // confused?\n+                //\n+                // Also don't specify this on Windows as it's not needed for\n+                // MSVC and for MinGW it doesn't really vary.\n+                if !self.defined(\"CMAKE_TOOLCHAIN_FILE\")\n+                   && !self.defined(&tool_var)\n+                   && env::consts::FAMILY != \"windows\" {\n+                    let mut ccompiler = OsString::from(\"-D\");\n+                    ccompiler.push(&tool_var);\n+                    ccompiler.push(\"=\");\n+                    ccompiler.push(find_exe(compiler.path()));\n+                    cmd.arg(ccompiler);\n+                }\n+            };\n+\n+            set_compiler(\"C\", &c_compiler, &self.cflags);\n+            set_compiler(\"CXX\", &cxx_compiler, &self.cxxflags);\n+        }\n+\n+        if !self.defined(\"CMAKE_BUILD_TYPE\") {\n+            cmd.arg(&format!(\"-DCMAKE_BUILD_TYPE={}\", profile));\n+        }\n+\n+        if !self.defined(\"CMAKE_TOOLCHAIN_FILE\") {\n+            if let Ok(s) = env::var(\"CMAKE_TOOLCHAIN_FILE\") {\n+                cmd.arg(&format!(\"-DCMAKE_TOOLCHAIN_FILE={}\", s));\n+            }\n+        }\n+\n+        run(cmd.env(\"CMAKE_PREFIX_PATH\", cmake_prefix_path), \"cmake\");\n+\n+        let mut parallel_args = Vec::new();\n+        if fs::metadata(&dst.join(\"build/Makefile\")).is_ok() {\n+            if let Ok(s) = env::var(\"NUM_JOBS\") {\n+                parallel_args.push(format!(\"-j{}\", s));\n+            }\n+        }\n+\n+        // And build!\n+        let target = self.cmake_target.clone().unwrap_or(\"install\".to_string());\n+        run(Command::new(\"cmake\")\n+                    .arg(\"--build\").arg(\".\")\n+                    .arg(\"--target\").arg(target)\n+                    .arg(\"--config\").arg(profile)\n+                    .arg(\"--\").args(&self.build_args)\n+                    .args(&parallel_args)\n+                    .current_dir(&build), \"cmake\");\n+\n+        println!(\"cargo:root={}\", dst.display());\n+        return dst\n+    }\n+\n+    fn visual_studio_generator(&self, target: &str) -> String {\n+        let base = match std::env::var(\"VisualStudioVersion\") {\n+            Ok(version) => {\n+                match &version[..] {\n+                    \"15.0\" => \"Visual Studio 15\",\n+                    \"14.0\" => \"Visual Studio 14 2015\",\n+                    \"12.0\" => \"Visual Studio 12 2013\",\n+                    vers => panic!(\"\\n\\n\\\n+                        unsupported or unknown VisualStudio version: {}\\n\\\n+                        if another version is installed consider running \\\n+                        the appropriate vcvars script before building this \\\n+                        crate\\n\\\n+                    \", vers),\n+                }\n+            }\n+            _ => {\n+                // Check for the presense of a specific registry key\n+                // that indicates visual studio is installed.\n+                if self.has_msbuild_version(\"15.0\") {\n+                    \"Visual Studio 15\"\n+                } else if self.has_msbuild_version(\"14.0\") {\n+                    \"Visual Studio 14 2015\"\n+                } else if self.has_msbuild_version(\"12.0\") {\n+                    \"Visual Studio 12 2013\"\n+                } else {\n+                    panic!(\"\\n\\n\\\n+                        couldn't determine visual studio generator\\n\\\n+                        if VisualStudio is installed, however, consider \\\n+                        running the appropriate vcvars script before building \\\n+                        this crate\\n\\\n+                    \");\n+                }\n+            }\n+        };\n+\n+        if target.contains(\"i686\") {\n+            base.to_string()\n+        } else if target.contains(\"x86_64\") {\n+            format!(\"{} Win64\", base)\n+        } else {\n+            panic!(\"unsupported msvc target: {}\", target);\n+        }\n+    }\n+\n+    #[cfg(not(windows))]\n+    fn has_msbuild_version(&self, _version: &str) -> bool {\n+        false\n+    }\n+\n+    #[cfg(windows)]\n+    fn has_msbuild_version(&self, version: &str) -> bool {\n+        let key = format!(\"SOFTWARE\\\\Microsoft\\\\MSBuild\\\\ToolsVersions\\\\{}\",\n+                          version);\n+        registry::LOCAL_MACHINE.open(key.as_ref()).is_ok()\n+    }\n+\n+    fn defined(&self, var: &str) -> bool {\n+        self.defines.iter().any(|&(ref a, _)| a == var)\n+    }\n+\n+    // If a cmake project has previously been built (e.g. CMakeCache.txt already\n+    // exists), then cmake will choke if the source directory for the original\n+    // project being built has changed. Detect this situation through the\n+    // `CMAKE_HOME_DIRECTORY` variable that cmake emits and if it doesn't match\n+    // we blow away the build directory and start from scratch (the recommended\n+    // solution apparently [1]).\n+    //\n+    // [1]: https://cmake.org/pipermail/cmake/2012-August/051545.html\n+    fn maybe_clear(&self, dir: &Path) {\n+        // CMake will apparently store canonicalized paths which normally\n+        // isn't relevant to us but we canonicalize it here to ensure\n+        // we're both checking the same thing.\n+        let path = fs::canonicalize(&self.path).unwrap_or(self.path.clone());\n+        let src = match path.to_str() {\n+            Some(src) => src,\n+            None => return,\n+        };\n+        let mut f = match File::open(dir.join(\"CMakeCache.txt\")) {\n+            Ok(f) => f,\n+            Err(..) => return,\n+        };\n+        let mut u8contents = Vec::new();\n+        match f.read_to_end(&mut u8contents) {\n+            Ok(f) => f,\n+            Err(..) => return,\n+        };\n+        let contents = String::from_utf8_lossy(&u8contents);\n+        drop(f);\n+        for line in contents.lines() {\n+            if line.contains(\"CMAKE_HOME_DIRECTORY\") && !line.contains(src) {\n+                println!(\"detected home dir change, cleaning out entire build \\\n+                          directory\");\n+                fs::remove_dir_all(dir).unwrap();\n+                break\n+            }\n+        }\n+    }\n+}\n+\n+fn run(cmd: &mut Command, program: &str) {\n+    println!(\"running: {:?}\", cmd);\n+    let status = match cmd.status() {\n+        Ok(status) => status,\n+        Err(ref e) if e.kind() == ErrorKind::NotFound => {\n+            fail(&format!(\"failed to execute command: {}\\nis `{}` not installed?\",\n+                          e, program));\n+        }\n+        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+    };\n+    if !status.success() {\n+        fail(&format!(\"command did not execute successfully, got: {}\", status));\n+    }\n+}\n+\n+fn find_exe(path: &Path) -> PathBuf {\n+    env::split_paths(&env::var_os(\"PATH\").unwrap_or(OsString::new()))\n+        .map(|p| p.join(path))\n+        .find(|p| fs::metadata(p).is_ok())\n+        .unwrap_or(path.to_owned())\n+}\n+\n+fn getenv_unwrap(v: &str) -> String {\n+    match env::var(v) {\n+        Ok(s) => s,\n+        Err(..) => fail(&format!(\"environment variable `{}` not defined\", v)),\n+    }\n+}\n+\n+fn fail(s: &str) -> ! {\n+    panic!(\"\\n{}\\n\\nbuild script failed, must exit now\", s)\n+}"}, {"sha": "8819b094151e779465f71caeb551ef0c01a580ca", "filename": "src/vendor/cmake/src/registry.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fcmake%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fcmake%2Fsrc%2Fregistry.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ffi::OsStr;\n+use std::io;\n+use std::os::raw;\n+use std::os::windows::prelude::*;\n+\n+pub struct RegistryKey(Repr);\n+\n+type HKEY = *mut u8;\n+type DWORD = u32;\n+type LPDWORD = *mut DWORD;\n+type LPCWSTR = *const u16;\n+type LPWSTR = *mut u16;\n+type LONG = raw::c_long;\n+type PHKEY = *mut HKEY;\n+type PFILETIME = *mut u8;\n+type LPBYTE = *mut u8;\n+type REGSAM = u32;\n+\n+const ERROR_SUCCESS: DWORD = 0;\n+const HKEY_LOCAL_MACHINE: HKEY = 0x80000002 as HKEY;\n+const KEY_READ: DWORD = 0x20019;\n+const KEY_WOW64_32KEY: DWORD = 0x200;\n+\n+#[link(name = \"advapi32\")]\n+extern \"system\" {\n+    fn RegOpenKeyExW(key: HKEY,\n+                     lpSubKey: LPCWSTR,\n+                     ulOptions: DWORD,\n+                     samDesired: REGSAM,\n+                     phkResult: PHKEY) -> LONG;\n+    fn RegCloseKey(hKey: HKEY) -> LONG;\n+}\n+\n+struct OwnedKey(HKEY);\n+\n+enum Repr {\n+    Const(HKEY),\n+    Owned(OwnedKey),\n+}\n+\n+unsafe impl Sync for Repr {}\n+unsafe impl Send for Repr {}\n+\n+pub static LOCAL_MACHINE: RegistryKey =\n+    RegistryKey(Repr::Const(HKEY_LOCAL_MACHINE));\n+\n+impl RegistryKey {\n+    fn raw(&self) -> HKEY {\n+        match self.0 {\n+            Repr::Const(val) => val,\n+            Repr::Owned(ref val) => val.0,\n+        }\n+    }\n+\n+    pub fn open(&self, key: &OsStr) -> io::Result<RegistryKey> {\n+        let key = key.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+        let mut ret = 0 as *mut _;\n+        let err = unsafe {\n+            RegOpenKeyExW(self.raw(), key.as_ptr(), 0,\n+                          KEY_READ | KEY_WOW64_32KEY, &mut ret)\n+        };\n+        if err == ERROR_SUCCESS as LONG {\n+            Ok(RegistryKey(Repr::Owned(OwnedKey(ret))))\n+        } else {\n+            Err(io::Error::from_raw_os_error(err as i32))\n+        }\n+    }\n+}\n+\n+impl Drop for OwnedKey {\n+    fn drop(&mut self) {\n+        unsafe { RegCloseKey(self.0); }\n+    }\n+}"}, {"sha": "e3d83501ad079311dac30f019ffa4e53c5485af2", "filename": "src/vendor/env_logger/.cargo-checksum.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2F.cargo-checksum.json?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1 @@\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\"Cargo.toml\":\"4af0565a97a599bba727315d9aff1f57a350dcfee7d9f00986c851e54a24b4ca\",\"src/lib.rs\":\"484cec14a5f18a25b71d7b1842f7b184f0530165021b71b36dde9fc57b7fc15a\",\"src/regex.rs\":\"d8e2a6958d4ed8084867063aae4b5c77ffc5d271dc2e17909d56c5a5e1552034\",\"src/string.rs\":\"26ede9ab41a2673c3ad6001bc1802c005ce9a4f190f55860a24aa66b6b71bbc7\",\"tests/regexp_filter.rs\":\"a3f9c01623e90e54b247a62c53b25caf5f502d054f28c0bdf92abbea486a95b5\"},\"package\":\"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/vendor/env_logger/.cargo-ok", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2F.cargo-ok", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2F.cargo-ok", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2F.cargo-ok?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "5efadbf0d62938ea0a29d3776529f4124c35e77f", "filename": "src/vendor/env_logger/Cargo.toml", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,23 @@\n+[package]\n+name = \"env_logger\"\n+version = \"0.3.5\"\n+authors = [\"The Rust Project Developers\"]\n+license = \"MIT/Apache-2.0\"\n+repository = \"https://github.com/rust-lang/log\"\n+documentation = \"http://doc.rust-lang.org/log/env_logger\"\n+homepage = \"https://github.com/rust-lang/log\"\n+description = \"\"\"\n+An logging implementation for `log` which is configured via an environment\n+variable.\n+\"\"\"\n+\n+[dependencies]\n+log = { version = \"0.3\", path = \"..\" }\n+regex = { version = \"0.1\", optional = true }\n+\n+[[test]]\n+name = \"regexp_filter\"\n+harness = false\n+\n+[features]\n+default = [\"regex\"]"}, {"sha": "9105c19c65cd4a162ea86ac3386ceb11b0484aae", "filename": "src/vendor/env_logger/src/lib.rs", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2Fsrc%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,623 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A logger configured via an environment variable which writes to standard\n+//! error.\n+//!\n+//! ## Example\n+//!\n+//! ```\n+//! #[macro_use] extern crate log;\n+//! extern crate env_logger;\n+//!\n+//! use log::LogLevel;\n+//!\n+//! fn main() {\n+//!     env_logger::init().unwrap();\n+//!\n+//!     debug!(\"this is a debug {}\", \"message\");\n+//!     error!(\"this is printed by default\");\n+//!\n+//!     if log_enabled!(LogLevel::Info) {\n+//!         let x = 3 * 4; // expensive computation\n+//!         info!(\"the answer was: {}\", x);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Assumes the binary is `main`:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=error ./main\n+//! ERROR:main: this is printed by default\n+//! ```\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=info ./main\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=debug ./main\n+//! DEBUG:main: this is a debug message\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! You can also set the log level on a per module basis:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=main=info ./main\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! And enable all logging:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=main ./main\n+//! DEBUG:main: this is a debug message\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! See the documentation for the log crate for more information about its API.\n+//!\n+//! ## Enabling logging\n+//!\n+//! Log levels are controlled on a per-module basis, and by default all logging\n+//! is disabled except for `error!`. Logging is controlled via the `RUST_LOG`\n+//! environment variable. The value of this environment variable is a\n+//! comma-separated list of logging directives. A logging directive is of the\n+//! form:\n+//!\n+//! ```text\n+//! path::to::module=log_level\n+//! ```\n+//!\n+//! The path to the module is rooted in the name of the crate it was compiled\n+//! for, so if your program is contained in a file `hello.rs`, for example, to\n+//! turn on logging for this file you would use a value of `RUST_LOG=hello`.\n+//! Furthermore, this path is a prefix-search, so all modules nested in the\n+//! specified module will also have logging enabled.\n+//!\n+//! The actual `log_level` is optional to specify. If omitted, all logging will\n+//! be enabled. If specified, it must be one of the strings `debug`, `error`,\n+//! `info`, `warn`, or `trace`.\n+//!\n+//! As the log level for a module is optional, the module to enable logging for\n+//! is also optional. If only a `log_level` is provided, then the global log\n+//! level for all modules is set to this value.\n+//!\n+//! Some examples of valid values of `RUST_LOG` are:\n+//!\n+//! * `hello` turns on all logging for the 'hello' module\n+//! * `info` turns on all info logging\n+//! * `hello=debug` turns on debug logging for 'hello'\n+//! * `hello,std::option` turns on hello, and std's option logging\n+//! * `error,hello=warn` turn on global error logging and also warn for hello\n+//!\n+//! ## Filtering results\n+//!\n+//! A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n+//! followed by a regex. Each message is checked against the regex, and is only\n+//! logged if it matches. Note that the matching is done after formatting the\n+//! log string but before adding any logging meta-data. There is a single filter\n+//! for all modules.\n+//!\n+//! Some examples:\n+//!\n+//! * `hello/foo` turns on all logging for the 'hello' module where the log\n+//!   message includes 'foo'.\n+//! * `info/f.o` turns on all info logging where the log message includes 'foo',\n+//!   'f1o', 'fao', etc.\n+//! * `hello=debug/foo*foo` turns on debug logging for 'hello' where the log\n+//!   message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n+//! * `error,hello=warn/[0-9] scopes` turn on global error logging and also\n+//!   warn for hello. In both cases the log message must include a single digit\n+//!   number followed by 'scopes'.\n+\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/env_logger/\")]\n+#![cfg_attr(test, deny(warnings))]\n+\n+extern crate log;\n+\n+use std::env;\n+use std::io::prelude::*;\n+use std::io;\n+use std::mem;\n+\n+use log::{Log, LogLevel, LogLevelFilter, LogRecord, SetLoggerError, LogMetadata};\n+\n+#[cfg(feature = \"regex\")]\n+#[path = \"regex.rs\"]\n+mod filter;\n+\n+#[cfg(not(feature = \"regex\"))]\n+#[path = \"string.rs\"]\n+mod filter;\n+\n+/// The logger.\n+pub struct Logger {\n+    directives: Vec<LogDirective>,\n+    filter: Option<filter::Filter>,\n+    format: Box<Fn(&LogRecord) -> String + Sync + Send>,\n+}\n+\n+/// LogBuilder acts as builder for initializing the Logger.\n+/// It can be used to customize the log format, change the enviromental variable used\n+/// to provide the logging directives and also set the default log level filter.\n+///\n+/// ## Example\n+///\n+/// ```\n+/// #[macro_use]\n+/// extern crate log;\n+/// extern crate env_logger;\n+///\n+/// use std::env;\n+/// use log::{LogRecord, LogLevelFilter};\n+/// use env_logger::LogBuilder;\n+///\n+/// fn main() {\n+///     let format = |record: &LogRecord| {\n+///         format!(\"{} - {}\", record.level(), record.args())\n+///     };\n+///\n+///     let mut builder = LogBuilder::new();\n+///     builder.format(format).filter(None, LogLevelFilter::Info);\n+///\n+///     if env::var(\"RUST_LOG\").is_ok() {\n+///        builder.parse(&env::var(\"RUST_LOG\").unwrap());\n+///     }\n+///\n+///     builder.init().unwrap();\n+///\n+///     error!(\"error message\");\n+///     info!(\"info message\");\n+/// }\n+/// ```\n+pub struct LogBuilder {\n+    directives: Vec<LogDirective>,\n+    filter: Option<filter::Filter>,\n+    format: Box<Fn(&LogRecord) -> String + Sync + Send>,\n+}\n+\n+impl LogBuilder {\n+    /// Initializes the log builder with defaults\n+    pub fn new() -> LogBuilder {\n+        LogBuilder {\n+            directives: Vec::new(),\n+            filter: None,\n+            format: Box::new(|record: &LogRecord| {\n+                format!(\"{}:{}: {}\", record.level(),\n+                        record.location().module_path(), record.args())\n+            }),\n+        }\n+    }\n+\n+    /// Adds filters to the logger\n+    ///\n+    /// The given module (if any) will log at most the specified level provided.\n+    /// If no module is provided then the filter will apply to all log messages.\n+    pub fn filter(&mut self,\n+                  module: Option<&str>,\n+                  level: LogLevelFilter) -> &mut Self {\n+        self.directives.push(LogDirective {\n+            name: module.map(|s| s.to_string()),\n+            level: level,\n+        });\n+        self\n+    }\n+\n+    /// Sets the format function for formatting the log output.\n+    ///\n+    /// This function is called on each record logged to produce a string which\n+    /// is actually printed out.\n+    pub fn format<F: 'static>(&mut self, format: F) -> &mut Self\n+        where F: Fn(&LogRecord) -> String + Sync + Send\n+    {\n+        self.format = Box::new(format);\n+        self\n+    }\n+\n+    /// Parses the directives string in the same form as the RUST_LOG\n+    /// environment variable.\n+    ///\n+    /// See the module documentation for more details.\n+    pub fn parse(&mut self, filters: &str) -> &mut Self {\n+        let (directives, filter) = parse_logging_spec(filters);\n+\n+        self.filter = filter;\n+\n+        for directive in directives {\n+            self.directives.push(directive);\n+        }\n+        self\n+    }\n+\n+    /// Initializes the global logger with an env logger.\n+    ///\n+    /// This should be called early in the execution of a Rust program, and the\n+    /// global logger may only be initialized once. Future initialization\n+    /// attempts will return an error.\n+    pub fn init(&mut self) -> Result<(), SetLoggerError> {\n+        log::set_logger(|max_level| {\n+            let logger = self.build();\n+            max_level.set(logger.filter());\n+            Box::new(logger)\n+        })\n+    }\n+\n+    /// Build an env logger.\n+    pub fn build(&mut self) -> Logger {\n+        if self.directives.is_empty() {\n+            // Adds the default filter if none exist\n+            self.directives.push(LogDirective {\n+                name: None,\n+                level: LogLevelFilter::Error,\n+            });\n+        } else {\n+            // Sort the directives by length of their name, this allows a\n+            // little more efficient lookup at runtime.\n+            self.directives.sort_by(|a, b| {\n+                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);\n+                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);\n+                alen.cmp(&blen)\n+            });\n+        }\n+\n+        Logger {\n+            directives: mem::replace(&mut self.directives, Vec::new()),\n+            filter: mem::replace(&mut self.filter, None),\n+            format: mem::replace(&mut self.format, Box::new(|_| String::new())),\n+        }\n+    }\n+}\n+\n+impl Logger {\n+    pub fn new() -> Logger {\n+        let mut builder = LogBuilder::new();\n+\n+        if let Ok(s) = env::var(\"RUST_LOG\") {\n+            builder.parse(&s);\n+        }\n+\n+        builder.build()\n+    }\n+\n+    pub fn filter(&self) -> LogLevelFilter {\n+        self.directives.iter()\n+            .map(|d| d.level).max()\n+            .unwrap_or(LogLevelFilter::Off)\n+    }\n+\n+    fn enabled(&self, level: LogLevel, target: &str) -> bool {\n+        // Search for the longest match, the vector is assumed to be pre-sorted.\n+        for directive in self.directives.iter().rev() {\n+            match directive.name {\n+                Some(ref name) if !target.starts_with(&**name) => {},\n+                Some(..) | None => {\n+                    return level <= directive.level\n+                }\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl Log for Logger {\n+    fn enabled(&self, metadata: &LogMetadata) -> bool {\n+        self.enabled(metadata.level(), metadata.target())\n+    }\n+\n+    fn log(&self, record: &LogRecord) {\n+        if !Log::enabled(self, record.metadata()) {\n+            return;\n+        }\n+\n+        if let Some(filter) = self.filter.as_ref() {\n+            if !filter.is_match(&*record.args().to_string()) {\n+                return;\n+            }\n+        }\n+\n+        let _ = writeln!(&mut io::stderr(), \"{}\", (self.format)(record));\n+    }\n+}\n+\n+struct LogDirective {\n+    name: Option<String>,\n+    level: LogLevelFilter,\n+}\n+\n+/// Initializes the global logger with an env logger.\n+///\n+/// This should be called early in the execution of a Rust program, and the\n+/// global logger may only be initialized once. Future initialization attempts\n+/// will return an error.\n+pub fn init() -> Result<(), SetLoggerError> {\n+    let mut builder = LogBuilder::new();\n+\n+    if let Ok(s) = env::var(\"RUST_LOG\") {\n+        builder.parse(&s);\n+    }\n+\n+    builder.init()\n+}\n+\n+/// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=error/foo\")\n+/// and return a vector with log directives.\n+fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<filter::Filter>) {\n+    let mut dirs = Vec::new();\n+\n+    let mut parts = spec.split('/');\n+    let mods = parts.next();\n+    let filter = parts.next();\n+    if parts.next().is_some() {\n+        println!(\"warning: invalid logging spec '{}', \\\n+                 ignoring it (too many '/'s)\", spec);\n+        return (dirs, None);\n+    }\n+    mods.map(|m| { for s in m.split(',') {\n+        if s.len() == 0 { continue }\n+        let mut parts = s.split('=');\n+        let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n+            (Some(part0), None, None) => {\n+                // if the single argument is a log-level string or number,\n+                // treat that as a global fallback\n+                match part0.parse() {\n+                    Ok(num) => (num, None),\n+                    Err(_) => (LogLevelFilter::max(), Some(part0)),\n+                }\n+            }\n+            (Some(part0), Some(\"\"), None) => (LogLevelFilter::max(), Some(part0)),\n+            (Some(part0), Some(part1), None) => {\n+                match part1.parse() {\n+                    Ok(num) => (num, Some(part0)),\n+                    _ => {\n+                        println!(\"warning: invalid logging spec '{}', \\\n+                                 ignoring it\", part1);\n+                        continue\n+                    }\n+                }\n+            },\n+            _ => {\n+                println!(\"warning: invalid logging spec '{}', \\\n+                         ignoring it\", s);\n+                continue\n+            }\n+        };\n+        dirs.push(LogDirective {\n+            name: name.map(|s| s.to_string()),\n+            level: log_level,\n+        });\n+    }});\n+\n+    let filter = filter.map_or(None, |filter| {\n+        match filter::Filter::new(filter) {\n+            Ok(re) => Some(re),\n+            Err(e) => {\n+                println!(\"warning: invalid regex filter - {}\", e);\n+                None\n+            }\n+        }\n+    });\n+\n+    return (dirs, filter);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use log::{LogLevel, LogLevelFilter};\n+\n+    use super::{LogBuilder, Logger, LogDirective, parse_logging_spec};\n+\n+    fn make_logger(dirs: Vec<LogDirective>) -> Logger {\n+        let mut logger = LogBuilder::new().build();\n+        logger.directives = dirs;\n+        logger\n+    }\n+\n+    #[test]\n+    fn filter_info() {\n+        let logger = LogBuilder::new().filter(None, LogLevelFilter::Info).build();\n+        assert!(logger.enabled(LogLevel::Info, \"crate1\"));\n+        assert!(!logger.enabled(LogLevel::Debug, \"crate1\"));\n+    }\n+\n+    #[test]\n+    fn filter_beginning_longest_match() {\n+        let logger = LogBuilder::new()\n+                        .filter(Some(\"crate2\"), LogLevelFilter::Info)\n+                        .filter(Some(\"crate2::mod\"), LogLevelFilter::Debug)\n+                        .filter(Some(\"crate1::mod1\"), LogLevelFilter::Warn)\n+                        .build();\n+        assert!(logger.enabled(LogLevel::Debug, \"crate2::mod1\"));\n+        assert!(!logger.enabled(LogLevel::Debug, \"crate2\"));\n+    }\n+\n+    #[test]\n+    fn parse_default() {\n+        let logger = LogBuilder::new().parse(\"info,crate1::mod1=warn\").build();\n+        assert!(logger.enabled(LogLevel::Warn, \"crate1::mod1\"));\n+        assert!(logger.enabled(LogLevel::Info, \"crate2::mod2\"));\n+    }\n+\n+    #[test]\n+    fn match_full_path() {\n+        let logger = make_logger(vec![\n+            LogDirective {\n+                name: Some(\"crate2\".to_string()),\n+                level: LogLevelFilter::Info\n+            },\n+            LogDirective {\n+                name: Some(\"crate1::mod1\".to_string()),\n+                level: LogLevelFilter::Warn\n+            }\n+        ]);\n+        assert!(logger.enabled(LogLevel::Warn, \"crate1::mod1\"));\n+        assert!(!logger.enabled(LogLevel::Info, \"crate1::mod1\"));\n+        assert!(logger.enabled(LogLevel::Info, \"crate2\"));\n+        assert!(!logger.enabled(LogLevel::Debug, \"crate2\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        let logger = make_logger(vec![\n+            LogDirective { name: Some(\"crate2\".to_string()), level: LogLevelFilter::Info },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: LogLevelFilter::Warn }\n+        ]);\n+        assert!(!logger.enabled(LogLevel::Warn, \"crate3\"));\n+    }\n+\n+    #[test]\n+    fn match_beginning() {\n+        let logger = make_logger(vec![\n+            LogDirective { name: Some(\"crate2\".to_string()), level: LogLevelFilter::Info },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: LogLevelFilter::Warn }\n+        ]);\n+        assert!(logger.enabled(LogLevel::Info, \"crate2::mod1\"));\n+    }\n+\n+    #[test]\n+    fn match_beginning_longest_match() {\n+        let logger = make_logger(vec![\n+            LogDirective { name: Some(\"crate2\".to_string()), level: LogLevelFilter::Info },\n+            LogDirective { name: Some(\"crate2::mod\".to_string()), level: LogLevelFilter::Debug },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: LogLevelFilter::Warn }\n+        ]);\n+        assert!(logger.enabled(LogLevel::Debug, \"crate2::mod1\"));\n+        assert!(!logger.enabled(LogLevel::Debug, \"crate2\"));\n+    }\n+\n+    #[test]\n+    fn match_default() {\n+        let logger = make_logger(vec![\n+            LogDirective { name: None, level: LogLevelFilter::Info },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: LogLevelFilter::Warn }\n+        ]);\n+        assert!(logger.enabled(LogLevel::Warn, \"crate1::mod1\"));\n+        assert!(logger.enabled(LogLevel::Info, \"crate2::mod2\"));\n+    }\n+\n+    #[test]\n+    fn zero_level() {\n+        let logger = make_logger(vec![\n+            LogDirective { name: None, level: LogLevelFilter::Info },\n+            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: LogLevelFilter::Off }\n+        ]);\n+        assert!(!logger.enabled(LogLevel::Error, \"crate1::mod1\"));\n+        assert!(logger.enabled(LogLevel::Info, \"crate2::mod2\"));\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_valid() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=error,crate1::mod2,crate2=debug\");\n+        assert_eq!(dirs.len(), 3);\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::Error);\n+\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_string()));\n+        assert_eq!(dirs[1].level, LogLevelFilter::max());\n+\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[2].level, LogLevelFilter::Debug);\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_invalid_crate() {\n+        // test parse_logging_spec with multiple = in specification\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=warn=info,crate2=debug\");\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::Debug);\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_invalid_log_level() {\n+        // test parse_logging_spec with 'noNumber' as log level\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=noNumber,crate2=debug\");\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::Debug);\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_string_log_level() {\n+        // test parse_logging_spec with 'warn' as log level\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::Warn);\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_empty_log_level() {\n+        // test parse_logging_spec with '' as log level\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=\");\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::max());\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_global() {\n+        // test parse_logging_spec with no crate\n+        let (dirs, filter) = parse_logging_spec(\"warn,crate2=debug\");\n+        assert_eq!(dirs.len(), 2);\n+        assert_eq!(dirs[0].name, None);\n+        assert_eq!(dirs[0].level, LogLevelFilter::Warn);\n+        assert_eq!(dirs[1].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[1].level, LogLevelFilter::Debug);\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_valid_filter() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=error,crate1::mod2,crate2=debug/abc\");\n+        assert_eq!(dirs.len(), 3);\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::Error);\n+\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_string()));\n+        assert_eq!(dirs[1].level, LogLevelFilter::max());\n+\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[2].level, LogLevelFilter::Debug);\n+        assert!(filter.is_some() && filter.unwrap().to_string() == \"abc\");\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_invalid_crate_filter() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=error=warn,crate2=debug/a.c\");\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::Debug);\n+        assert!(filter.is_some() && filter.unwrap().to_string() == \"a.c\");\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_empty_with_filter() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1/a*c\");\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate1\".to_string()));\n+        assert_eq!(dirs[0].level, LogLevelFilter::max());\n+        assert!(filter.is_some() && filter.unwrap().to_string() == \"a*c\");\n+    }\n+}"}, {"sha": "0df03e673304d9e1bbb5101f31c082837a70ab06", "filename": "src/vendor/env_logger/src/regex.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2Fsrc%2Fregex.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,28 @@\n+extern crate regex;\n+\n+use std::fmt;\n+\n+use self::regex::Regex;\n+\n+pub struct Filter {\n+    inner: Regex,\n+}\n+\n+impl Filter {\n+    pub fn new(spec: &str) -> Result<Filter, String> {\n+        match Regex::new(spec){\n+            Ok(r) => Ok(Filter { inner: r }),\n+            Err(e) => Err(e.to_string()),\n+        }\n+    }\n+\n+    pub fn is_match(&self, s: &str) -> bool {\n+        self.inner.is_match(s)\n+    }\n+}\n+\n+impl fmt::Display for Filter {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.inner.fmt(f)\n+    }\n+}"}, {"sha": "74d0e04dbd6ed9ed0f1a4954dc7c28eda3bcb36a", "filename": "src/vendor/env_logger/src/string.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2Fsrc%2Fstring.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,21 @@\n+use std::fmt;\n+\n+pub struct Filter {\n+    inner: String,\n+}\n+\n+impl Filter {\n+    pub fn new(spec: &str) -> Result<Filter, String> {\n+        Ok(Filter { inner: spec.to_string() })\n+    }\n+\n+    pub fn is_match(&self, s: &str) -> bool {\n+        s.contains(&self.inner)\n+    }\n+}\n+\n+impl fmt::Display for Filter {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.inner.fmt(f)\n+    }\n+}"}, {"sha": "5036fb8e3c9c332a790eb8ce9a789bf7dea7df86", "filename": "src/vendor/env_logger/tests/regexp_filter.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Ftests%2Fregexp_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fenv_logger%2Ftests%2Fregexp_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fenv_logger%2Ftests%2Fregexp_filter.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,51 @@\n+#[macro_use] extern crate log;\n+extern crate env_logger;\n+\n+use std::process;\n+use std::env;\n+use std::str;\n+\n+fn main() {\n+    if env::var(\"LOG_REGEXP_TEST\").ok() == Some(String::from(\"1\")) {\n+        child_main();\n+    } else {\n+        parent_main()\n+    }\n+}\n+\n+fn child_main() {\n+    env_logger::init().unwrap();\n+    info!(\"XYZ Message\");\n+}\n+\n+fn run_child(rust_log: String) -> bool {\n+    let exe = env::current_exe().unwrap();\n+    let out = process::Command::new(exe)\n+        .env(\"LOG_REGEXP_TEST\", \"1\")\n+        .env(\"RUST_LOG\", rust_log)\n+        .output()\n+        .unwrap_or_else(|e| panic!(\"Unable to start child process: {}\", e));\n+    str::from_utf8(out.stderr.as_ref()).unwrap().contains(\"XYZ Message\")\n+}\n+\n+fn assert_message_printed(rust_log: &str) {\n+    if !run_child(rust_log.to_string()) {\n+        panic!(\"RUST_LOG={} should allow the test log message\", rust_log)\n+    }\n+}\n+\n+fn assert_message_not_printed(rust_log: &str) {\n+    if run_child(rust_log.to_string()) {\n+        panic!(\"RUST_LOG={} should not allow the test log message\", rust_log)\n+    }\n+}\n+\n+fn parent_main() {\n+    // test normal log severity levels\n+    assert_message_printed(\"info\");\n+    assert_message_not_printed(\"warn\");\n+\n+    // test of regular expression filters\n+    assert_message_printed(\"info/XYZ\");\n+    assert_message_not_printed(\"info/XXX\");\n+}"}, {"sha": "674ae31b296ba1b08dc5996634a82b1648ccc6c2", "filename": "src/vendor/filetime/.cargo-checksum.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2F.cargo-checksum.json?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1 @@\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"f9b1ca6ae27d1c18215265024629a8960c31379f206d9ed20f64e0b2dcf79805\",\".travis.yml\":\"c8cfe2c700e7b1d6500d0ad8084694be7009095e9572aaf54bf695c1fe7822d6\",\"Cargo.toml\":\"4e414fe72ef2afcae81fb5a89f39e59ec40844272b589381746623f612333305\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"fef1998633eb2f460e6b12bc1133a21f5674e0b53ae5914ba1e53f1b63a185c3\",\"appveyor.yml\":\"da991211b72fa6f231af7adb84c9fb72f5a9131d1c0a3d47b8ceffe5a82c8542\",\"src/lib.rs\":\"8fa03e69ab113e5a30c742f60b6beddc0b77ef41a1eb45e82f9df867c9265815\"},\"package\":\"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/vendor/filetime/.cargo-ok", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.cargo-ok", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.cargo-ok", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2F.cargo-ok?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "a9d37c560c6ab8d4afbf47eda643e8c42e857716", "filename": "src/vendor/filetime/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2F.gitignore?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,2 @@\n+target\n+Cargo.lock"}, {"sha": "001cdd259ecf330680172707ff3abe00ca9e8ad3", "filename": "src/vendor/filetime/.travis.yml", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2F.travis.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,26 @@\n+language: rust\n+rust:\n+  - stable\n+  - beta\n+  - nightly\n+sudo: false\n+script:\n+  - cargo build --verbose\n+  - cargo test --verbose\n+  - cargo doc --no-deps\n+after_success: |\n+  [ $TRAVIS_BRANCH = master ] &&\n+  [ $TRAVIS_PULL_REQUEST = false ] &&\n+  echo '<meta http-equiv=refresh content=0;url=filetime/index.html>' > target/doc/index.html &&\n+  pip install ghp-import --user $USER &&\n+  $HOME/.local/bin/ghp-import -n target/doc &&\n+  git push -qf https://${TOKEN}@github.com/${TRAVIS_REPO_SLUG}.git gh-pages\n+notifications:\n+  email:\n+    on_success: never\n+env:\n+  global:\n+    secure: dsIj09BQvGF872zKmqzG+WwCl7gfqwsnxcm3GZlAMgyLYm4juvHOwCRhIERCN3BCxPvdlSRKhe9Rwmp1RkiKuqTK3ITUTAy29Maf2vuL1T+zcdpZE0t6JSCU1gbEwzCA2foB1jzgy7Q47EzeJusmGNwibscjYmXKlH6JCFwTobM=\n+os:\n+  - linux\n+  - osx"}, {"sha": "971eaf601469d93f633ac0ab6480f84af6e6282a", "filename": "src/vendor/filetime/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+name = \"filetime\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+version = \"0.1.10\"\n+license = \"MIT/Apache-2.0\"\n+readme = \"README.md\"\n+keywords = [\"timestamp\", \"mtime\"]\n+repository = \"https://github.com/alexcrichton/filetime\"\n+homepage = \"https://github.com/alexcrichton/filetime\"\n+documentation = \"http://alexcrichton.com/filetime\"\n+description = \"\"\"\n+Platform-agnostic accessors of timestamps in File metadata\n+\"\"\"\n+\n+[dependencies]\n+libc = \"0.2\"\n+\n+[dev-dependencies]\n+tempdir = \"0.3\""}, {"sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1", "filename": "src/vendor/filetime/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2FLICENSE-APACHE?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "39e0ed6602151f235148e6c08413aa7eda5b9038", "filename": "src/vendor/filetime/LICENSE-MIT", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2FLICENSE-MIT?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2014 Alex Crichton\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "0422084e7e206afef8eb4bed8c7ee24e3f6bf3d6", "filename": "src/vendor/filetime/README.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2FREADME.md?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+# filetime\n+\n+[![Build Status](https://travis-ci.org/alexcrichton/filetime.svg?branch=master)](https://travis-ci.org/alexcrichton/filetime)\n+[![Build status](https://ci.appveyor.com/api/projects/status/9tatexq47i3ee13k?svg=true)](https://ci.appveyor.com/project/alexcrichton/filetime)\n+\n+[Documentation](http://alexcrichton.com/filetime/filetime/index.html)\n+\n+A helper library for inspecting the various timestamps of files in Rust. This\n+library takes into account cross-platform differences in terms of where the\n+timestamps are located, what they are called, and how to convert them into a\n+platform-independent representation.\n+\n+```toml\n+# Cargo.toml\n+[dependencies]\n+filetime = \"0.1\"\n+```\n+\n+# License\n+\n+`filetime` is primarily distributed under the terms of both the MIT license and\n+the Apache License (Version 2.0), with portions covered by various BSD-like\n+licenses.\n+\n+See LICENSE-APACHE, and LICENSE-MIT for details."}, {"sha": "6a1b8dc19c0393b9f64e98ca3701755ef39c34de", "filename": "src/vendor/filetime/appveyor.yml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2Fappveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2Fappveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2Fappveyor.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,17 @@\n+environment:\n+  matrix:\n+  - TARGET: x86_64-pc-windows-msvc\n+  - TARGET: i686-pc-windows-msvc\n+  - TARGET: i686-pc-windows-gnu\n+install:\n+  - ps: Start-FileDownload \"https://static.rust-lang.org/dist/rust-nightly-${env:TARGET}.exe\"\n+  - rust-nightly-%TARGET%.exe /VERYSILENT /NORESTART /DIR=\"C:\\Program Files (x86)\\Rust\"\n+  - SET PATH=%PATH%;C:\\Program Files (x86)\\Rust\\bin\n+  - SET PATH=%PATH%;C:\\MinGW\\bin\n+  - rustc -V\n+  - cargo -V\n+\n+build: false\n+\n+test_script:\n+  - cargo test --verbose"}, {"sha": "aa6bec1dfefe3dcfaf472b5f513a0ea313f3be24", "filename": "src/vendor/filetime/src/lib.rs", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Ffiletime%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Ffiletime%2Fsrc%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,305 @@\n+//! Timestamps for files in Rust\n+//!\n+//! This library provides platform-agnostic inspection of the various timestamps\n+//! present in the standard `fs::Metadata` structure.\n+//!\n+//! # Installation\n+//!\n+//! Add this to you `Cargo.toml`:\n+//!\n+//! ```toml\n+//! [dependencies]\n+//! filetime = \"0.1\"\n+//! ```\n+//!\n+//! # Usage\n+//!\n+//! ```no_run\n+//! use std::fs;\n+//! use filetime::FileTime;\n+//!\n+//! let metadata = fs::metadata(\"foo.txt\").unwrap();\n+//!\n+//! let mtime = FileTime::from_last_modification_time(&metadata);\n+//! println!(\"{}\", mtime);\n+//!\n+//! let atime = FileTime::from_last_access_time(&metadata);\n+//! assert!(mtime < atime);\n+//!\n+//! // Inspect values that can be interpreted across platforms\n+//! println!(\"{}\", mtime.seconds_relative_to_1970());\n+//! println!(\"{}\", mtime.nanoseconds());\n+//!\n+//! // Print the platform-specific value of seconds\n+//! println!(\"{}\", mtime.seconds());\n+//! ```\n+\n+extern crate libc;\n+\n+#[cfg(unix)] use std::os::unix::prelude::*;\n+#[cfg(windows)] use std::os::windows::prelude::*;\n+\n+use std::fmt;\n+use std::fs;\n+use std::io;\n+use std::path::Path;\n+\n+/// A helper structure to represent a timestamp for a file.\n+///\n+/// The actual value contined within is platform-specific and does not have the\n+/// same meaning across platforms, but comparisons and stringification can be\n+/// significant among the same platform.\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Copy, Clone, Hash)]\n+pub struct FileTime {\n+    seconds: u64,\n+    nanos: u32,\n+}\n+\n+impl FileTime {\n+    /// Creates a new timestamp representing a 0 time.\n+    ///\n+    /// Useful for creating the base of a cmp::max chain of times.\n+    pub fn zero() -> FileTime {\n+        FileTime { seconds: 0, nanos: 0 }\n+    }\n+\n+    /// Creates a new instance of `FileTime` with a number of seconds and\n+    /// nanoseconds relative to January 1, 1970.\n+    ///\n+    /// Note that this is typically the relative point that Unix time stamps are\n+    /// from, but on Windows the native time stamp is relative to January 1,\n+    /// 1601 so the return value of `seconds` from the returned `FileTime`\n+    /// instance may not be the same as that passed in.\n+    pub fn from_seconds_since_1970(seconds: u64, nanos: u32) -> FileTime {\n+        FileTime {\n+            seconds: seconds + if cfg!(windows) {11644473600} else {0},\n+            nanos: nanos,\n+        }\n+    }\n+\n+    /// Creates a new timestamp from the last modification time listed in the\n+    /// specified metadata.\n+    ///\n+    /// The returned value corresponds to the `mtime` field of `stat` on Unix\n+    /// platforms and the `ftLastWriteTime` field on Windows platforms.\n+    pub fn from_last_modification_time(meta: &fs::Metadata) -> FileTime {\n+        #[cfg(unix)]\n+        fn imp(meta: &fs::Metadata) -> FileTime {\n+            FileTime::from_os_repr(meta.mtime() as u64, meta.mtime_nsec() as u32)\n+        }\n+        #[cfg(windows)]\n+        fn imp(meta: &fs::Metadata) -> FileTime {\n+            FileTime::from_os_repr(meta.last_write_time())\n+        }\n+        imp(meta)\n+    }\n+\n+    /// Creates a new timestamp from the last access time listed in the\n+    /// specified metadata.\n+    ///\n+    /// The returned value corresponds to the `atime` field of `stat` on Unix\n+    /// platforms and the `ftLastAccessTime` field on Windows platforms.\n+    pub fn from_last_access_time(meta: &fs::Metadata) -> FileTime {\n+        #[cfg(unix)]\n+        fn imp(meta: &fs::Metadata) -> FileTime {\n+            FileTime::from_os_repr(meta.atime() as u64, meta.atime_nsec() as u32)\n+        }\n+        #[cfg(windows)]\n+        fn imp(meta: &fs::Metadata) -> FileTime {\n+            FileTime::from_os_repr(meta.last_access_time())\n+        }\n+        imp(meta)\n+    }\n+\n+    /// Creates a new timestamp from the creation time listed in the specified\n+    /// metadata.\n+    ///\n+    /// The returned value corresponds to the `birthtime` field of `stat` on\n+    /// Unix platforms and the `ftCreationTime` field on Windows platforms. Note\n+    /// that not all Unix platforms have this field available and may return\n+    /// `None` in some circumstances.\n+    pub fn from_creation_time(meta: &fs::Metadata) -> Option<FileTime> {\n+        macro_rules! birthtim {\n+            ($(($e:expr, $i:ident)),*) => {\n+                #[cfg(any($(target_os = $e),*))]\n+                fn imp(meta: &fs::Metadata) -> Option<FileTime> {\n+                    $(\n+                        #[cfg(target_os = $e)]\n+                        use std::os::$i::fs::MetadataExt;\n+                    )*\n+                    let raw = meta.as_raw_stat();\n+                    Some(FileTime::from_os_repr(raw.st_birthtime as u64,\n+                                                raw.st_birthtime_nsec as u32))\n+                }\n+\n+                #[cfg(all(not(windows),\n+                          $(not(target_os = $e)),*))]\n+                fn imp(_meta: &fs::Metadata) -> Option<FileTime> {\n+                    None\n+                }\n+            }\n+        }\n+\n+        birthtim! {\n+            (\"bitrig\", bitrig),\n+            (\"freebsd\", freebsd),\n+            (\"ios\", ios),\n+            (\"macos\", macos),\n+            (\"openbsd\", openbsd)\n+        }\n+\n+        #[cfg(windows)]\n+        fn imp(meta: &fs::Metadata) -> Option<FileTime> {\n+            Some(FileTime::from_os_repr(meta.last_access_time()))\n+        }\n+        imp(meta)\n+    }\n+\n+    #[cfg(windows)]\n+    fn from_os_repr(time: u64) -> FileTime {\n+        // Windows write times are in 100ns intervals, so do a little math to\n+        // get it into the right representation.\n+        FileTime {\n+            seconds: time / (1_000_000_000 / 100),\n+            nanos: ((time % (1_000_000_000 / 100)) * 100) as u32,\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn from_os_repr(seconds: u64, nanos: u32) -> FileTime {\n+        FileTime { seconds: seconds, nanos: nanos }\n+    }\n+\n+    /// Returns the whole number of seconds represented by this timestamp.\n+    ///\n+    /// Note that this value's meaning is **platform specific**. On Unix\n+    /// platform time stamps are typically relative to January 1, 1970, but on\n+    /// Windows platforms time stamps are relative to January 1, 1601.\n+    pub fn seconds(&self) -> u64 { self.seconds }\n+\n+    /// Returns the whole number of seconds represented by this timestamp,\n+    /// relative to the Unix epoch start of January 1, 1970.\n+    ///\n+    /// Note that this does not return the same value as `seconds` for Windows\n+    /// platforms as seconds are relative to a different date there.\n+    pub fn seconds_relative_to_1970(&self) -> u64 {\n+        self.seconds - if cfg!(windows) {11644473600} else {0}\n+    }\n+\n+    /// Returns the nanosecond precision of this timestamp.\n+    ///\n+    /// The returned value is always less than one billion and represents a\n+    /// portion of a second forward from the seconds returned by the `seconds`\n+    /// method.\n+    pub fn nanoseconds(&self) -> u32 { self.nanos }\n+}\n+\n+impl fmt::Display for FileTime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}.{:09}s\", self.seconds, self.nanos)\n+    }\n+}\n+\n+/// Set the last access and modification times for a file on the filesystem.\n+///\n+/// This function will set the `atime` and `mtime` metadata fields for a file\n+/// on the local filesystem, returning any error encountered.\n+pub fn set_file_times<P>(p: P, atime: FileTime, mtime: FileTime)\n+                         -> io::Result<()> where P: AsRef<Path> {\n+    set_file_times_(p.as_ref(), atime, mtime)\n+}\n+\n+#[cfg(unix)]\n+fn set_file_times_(p: &Path, atime: FileTime, mtime: FileTime) -> io::Result<()> {\n+    use std::ffi::CString;\n+    use libc::{timeval, time_t, suseconds_t, utimes};\n+\n+    let times = [to_timeval(&atime), to_timeval(&mtime)];\n+    let p = try!(CString::new(p.as_os_str().as_bytes()));\n+    return unsafe {\n+        if utimes(p.as_ptr() as *const _, times.as_ptr()) == 0 {\n+            Ok(())\n+        } else {\n+            Err(io::Error::last_os_error())\n+        }\n+    };\n+\n+    fn to_timeval(ft: &FileTime) -> timeval {\n+        timeval {\n+            tv_sec: ft.seconds() as time_t,\n+            tv_usec: (ft.nanoseconds() / 1000) as suseconds_t,\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+#[allow(bad_style)]\n+fn set_file_times_(p: &Path, atime: FileTime, mtime: FileTime) -> io::Result<()> {\n+    use std::fs::OpenOptions;\n+\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    type DWORD = u32;\n+    #[repr(C)]\n+    struct FILETIME {\n+        dwLowDateTime: u32,\n+        dwHighDateTime: u32,\n+    }\n+    extern \"system\" {\n+        fn SetFileTime(hFile: HANDLE,\n+                       lpCreationTime: *const FILETIME,\n+                       lpLastAccessTime: *const FILETIME,\n+                       lpLastWriteTime: *const FILETIME) -> BOOL;\n+    }\n+\n+    let f = try!(OpenOptions::new().write(true).open(p));\n+    let atime = to_filetime(&atime);\n+    let mtime = to_filetime(&mtime);\n+    return unsafe {\n+        let ret = SetFileTime(f.as_raw_handle() as *mut _,\n+                              0 as *const _,\n+                              &atime, &mtime);\n+        if ret != 0 {\n+            Ok(())\n+        } else {\n+            Err(io::Error::last_os_error())\n+        }\n+    };\n+\n+    fn to_filetime(ft: &FileTime) -> FILETIME {\n+        let intervals = ft.seconds() * (1_000_000_000 / 100) +\n+                        ((ft.nanoseconds() as u64) / 100);\n+        FILETIME {\n+            dwLowDateTime: intervals as DWORD,\n+            dwHighDateTime: (intervals >> 32) as DWORD,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate tempdir;\n+\n+    use std::fs::{self, File};\n+    use self::tempdir::TempDir;\n+    use super::{FileTime, set_file_times};\n+\n+    #[test]\n+    fn set_file_times_test() {\n+        let td = TempDir::new(\"filetime\").unwrap();\n+        let path = td.path().join(\"foo.txt\");\n+        File::create(&path).unwrap();\n+\n+        let metadata = fs::metadata(&path).unwrap();\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        let atime = FileTime::from_last_access_time(&metadata);\n+        set_file_times(&path, atime, mtime).unwrap();\n+\n+        let new_mtime = FileTime::from_seconds_since_1970(10_000, 0);\n+        set_file_times(&path, atime, new_mtime).unwrap();\n+\n+        let metadata = fs::metadata(&path).unwrap();\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        assert_eq!(mtime, new_mtime);\n+    }\n+}"}, {"sha": "efe1ebb7d44c3819c66e63944ab80203b78916cb", "filename": "src/vendor/gcc/.cargo-checksum.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.cargo-checksum.json?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1 @@\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"f9b1ca6ae27d1c18215265024629a8960c31379f206d9ed20f64e0b2dcf79805\",\".travis.yml\":\"5cee7774cf6d876246a0ae0f8362cceeecec5924b751049c945faac9342565ff\",\"Cargo.toml\":\"2634dedd87889b33a794e31b41a8d8d4713ef40382be3d464229707679bd83da\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"ecb2d93f4c81edbd48d8742ff7887dc0a4530a5890967839090bbc972d49bebe\",\"appveyor.yml\":\"46c77d913eaa45871296942c2cd96ef092c9dcaf19201cb5c500a5107faeb06f\",\"src/bin/gcc-shim.rs\":\"11edfe1fc6f932bd42ffffda5145833302bc163e0b87dc0d54f4bd0997ad4708\",\"src/lib.rs\":\"5eb0e311367226ed0420f5e2dac10cc35fc0a3be639a612b6e8ea6d24f646634\",\"src/registry.rs\":\"3e2a42581ebb82e325dd5600c6571cef937b35003b2927dc618967f5238a2058\",\"src/windows_registry.rs\":\"906653c020ffe9d572e435f3fc3a8892d9e0a13240ba297db01ce0a288e08cdb\",\"tests/cc_env.rs\":\"d92c5e3d3d43ac244e63b2cd2c93a521fcf124bf1ccf8d4c6bfa7f8333d88976\",\"tests/support/mod.rs\":\"d11ed0db4dda5ecf5fb970c9b0c56428cd47421a2742f07032e2cc6b0a0f07e2\",\"tests/test.rs\":\"164220f11be2eebc20315826513999970660a82feff8cc4b15b4e9d73d98324e\"},\"package\":\"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/vendor/gcc/.cargo-ok", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.cargo-ok", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.cargo-ok", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.cargo-ok?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "a9d37c560c6ab8d4afbf47eda643e8c42e857716", "filename": "src/vendor/gcc/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.gitignore?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,2 @@\n+target\n+Cargo.lock"}, {"sha": "6b508b9d8bc97c2dcbb5cbd9d1c59a9d4e99adf3", "filename": "src/vendor/gcc/.travis.yml", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.travis.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,40 @@\n+language: rust\n+rust:\n+  - stable\n+  - beta\n+  - nightly\n+sudo: false\n+install:\n+  - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then OS=unknown-linux-gnu; else OS=apple-darwin; fi\n+  - export TARGET=$ARCH-$OS\n+  - curl https://static.rust-lang.org/rustup.sh |\n+    sh -s -- --add-target=$TARGET --disable-sudo -y --prefix=`rustc --print sysroot`\n+before_script:\n+  - pip install 'travis-cargo<0.2' --user && export PATH=$HOME/.local/bin:$PATH\n+script:\n+  - cargo build --verbose\n+  - cargo test --verbose\n+  - cargo test --verbose --features parallel\n+  - cargo test --manifest-path gcc-test/Cargo.toml --target $TARGET\n+  - cargo test --manifest-path gcc-test/Cargo.toml --target $TARGET --features parallel\n+  - cargo test --manifest-path gcc-test/Cargo.toml --target $TARGET --release\n+  - cargo doc\n+  - rustdoc --test README.md -L target/debug -L target/debug/deps\n+after_success:\n+  - travis-cargo --only nightly doc-upload\n+env:\n+  global:\n+    secure: ilbcq9zX+UaiBcwqkBGldeanbEQus9npLsi0/nF1PUxKbQsoWSVtVOehAD8Hy92D3hX2npIRyNL8GxBn85XEcBYc1h7DiWUhLcXfZie79v8Ly/qboHCfZLXlB1ofbypbyQfouEdOE9zHf0ZILYVpAgUkliv6KuVShsrKNlbn4QE=\n+  matrix:\n+    - ARCH=x86_64\n+    - ARCH=i686\n+notifications:\n+  email:\n+    on_success: never\n+os:\n+  - linux\n+  - osx\n+addons:\n+  apt:\n+    packages:\n+      - g++-multilib"}, {"sha": "fd51ce0e9f457142d41bdc42d1d84f0989fdc68c", "filename": "src/vendor/gcc/Cargo.toml", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,23 @@\n+[package]\n+\n+name = \"gcc\"\n+version = \"0.3.38\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+license = \"MIT/Apache-2.0\"\n+repository = \"https://github.com/alexcrichton/gcc-rs\"\n+documentation = \"http://alexcrichton.com/gcc-rs\"\n+description = \"\"\"\n+A build-time dependency for Cargo build scripts to assist in invoking the native\n+C compiler to compile native C code into a static archive to be linked into Rust\n+code.\n+\"\"\"\n+keywords = [\"build-dependencies\"]\n+\n+[dependencies]\n+rayon = { version = \"0.4\", optional = true }\n+\n+[features]\n+parallel = [\"rayon\"]\n+\n+[dev-dependencies]\n+tempdir = \"0.3\""}, {"sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1", "filename": "src/vendor/gcc/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FLICENSE-APACHE?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "39e0ed6602151f235148e6c08413aa7eda5b9038", "filename": "src/vendor/gcc/LICENSE-MIT", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FLICENSE-MIT?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2014 Alex Crichton\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "ecc79c6735266dbfc64b510ecbcfb10e5bc3dd58", "filename": "src/vendor/gcc/README.md", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FREADME.md?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,161 @@\n+# gcc-rs\n+\n+A library to compile C/C++ code into a Rust library/application.\n+\n+[![Build Status](https://travis-ci.org/alexcrichton/gcc-rs.svg?branch=master)](https://travis-ci.org/alexcrichton/gcc-rs)\n+[![Build status](https://ci.appveyor.com/api/projects/status/onu270iw98h81nwv?svg=true)](https://ci.appveyor.com/project/alexcrichton/gcc-rs)\n+\n+[Documentation](http://alexcrichton.com/gcc-rs)\n+\n+A simple library meant to be used as a build dependency with Cargo packages in\n+order to build a set of C/C++ files into a static archive. Note that while this\n+crate is called \"gcc\", it actually calls out to the most relevant compile for\n+a platform, for example using `cl` on MSVC. That is, this crate does indeed work\n+on MSVC!\n+\n+## Using gcc-rs\n+\n+First, you'll want to both add a build script for your crate (`build.rs`) and\n+also add this crate to your `Cargo.toml` via:\n+\n+```toml\n+[package]\n+# ...\n+build = \"build.rs\"\n+\n+[build-dependencies]\n+gcc = \"0.3\"\n+```\n+\n+Next up, you'll want to write a build script like so:\n+\n+```rust,no_run\n+// build.rs\n+\n+extern crate gcc;\n+\n+fn main() {\n+    gcc::compile_library(\"libfoo.a\", &[\"foo.c\", \"bar.c\"]);\n+}\n+```\n+\n+And that's it! Running `cargo build` should take care of the rest and your Rust\n+application will now have the C files `foo.c` and `bar.c` compiled into it. You\n+can call the functions in Rust by declaring functions in your Rust code like so:\n+\n+```\n+extern {\n+    fn foo_function();\n+    fn bar_function();\n+}\n+\n+pub fn call() {\n+    unsafe {\n+        foo_function();\n+        bar_function();\n+    }\n+}\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+## External configuration via environment variables\n+\n+To control the programs and flags used for building, the builder can set a\n+number of different environment variables.\n+\n+* `CFLAGS` - a series of space separated flags passed to \"gcc\". Note that\n+             individual flags cannot currently contain spaces, so doing\n+             something like: \"-L=foo\\ bar\" is not possible.\n+* `CC` - the actual C compiler used. Note that this is used as an exact\n+         executable name, so (for example) no extra flags can be passed inside\n+         this variable, and the builder must ensure that there aren't any\n+         trailing spaces. This compiler must understand the `-c` flag. For\n+         certain `TARGET`s, it also is assumed to know about other flags (most\n+         common is `-fPIC`).\n+* `AR` - the `ar` (archiver) executable to use to build the static library.\n+\n+Each of these variables can also be supplied with certain prefixes and suffixes,\n+in the following prioritized order:\n+\n+1. `<var>_<target>` - for example, `CC_x86_64-unknown-linux-gnu`\n+2. `<var>_<target_with_underscores>` - for example, `CC_x86_64_unknown_linux_gnu`\n+3. `<build-kind>_<var>` - for example, `HOST_CC` or `TARGET_CFLAGS`\n+4. `<var>` - a plain `CC`, `AR` as above.\n+\n+If none of these variables exist, gcc-rs uses built-in defaults\n+\n+In addition to the the above optional environment variables, `gcc-rs` has some\n+functions with hard requirements on some variables supplied by [cargo's\n+build-script driver][cargo] that it has the `TARGET`, `OUT_DIR`, `OPT_LEVEL`,\n+and `HOST` variables.\n+\n+[cargo]: http://doc.crates.io/build-script.html#inputs-to-the-build-script\n+\n+## Optional features\n+\n+Currently gcc-rs supports parallel compilation (think `make -jN`) but this\n+feature is turned off by default. To enable gcc-rs to compile C/C++ in parallel,\n+you can change your dependency to:\n+\n+```toml\n+[build-dependencies]\n+gcc = { version = \"0.3\", features = [\"parallel\"] }\n+```\n+\n+By default gcc-rs will limit parallelism to `$NUM_JOBS`, or if not present it\n+will limit it to the number of cpus on the machine.\n+\n+## Compile-time Requirements\n+\n+To work properly this crate needs access to a C compiler when the build script\n+is being run. This crate does not ship a C compiler with it. The compiler\n+required varies per platform, but there are three broad categories:\n+\n+* Unix platforms require `cc` to be the C compiler. This can be found by\n+  installing gcc/clang on Linux distributions and Xcode on OSX, for example.\n+* Windows platforms targeting MSVC (e.g. your target triple ends in `-msvc`)\n+  require `cl.exe` to be available and in `PATH`. This is typically found in\n+  standard Visual Studio installations and the `PATH` can be set up by running\n+  the appropriate developer tools shell.\n+* Windows platforms targeting MinGW (e.g. your target triple ends in `-gnu`)\n+  require `gcc` to be available in `PATH`. We recommend the\n+  [MinGW-w64](http://mingw-w64.org) distribution, which is using the\n+  [Win-builds](http://win-builds.org) installation system.\n+  You may also acquire it via\n+  [MSYS2](http://msys2.github.io), as explained [here][msys2-help].  Make sure\n+  to install the appropriate architecture corresponding to your installation of\n+  rustc. GCC from older [MinGW](http://www.mingw.org) project is compatible\n+  only with 32-bit rust compiler.\n+\n+[msys2-help]: http://github.com/rust-lang/rust#building-on-windows\n+\n+## C++ support\n+\n+`gcc-rs` supports C++ libraries compilation by using the `cpp` method on\n+`Config`:\n+\n+```rust,no_run\n+extern crate gcc;\n+\n+fn main() {\n+    gcc::Config::new()\n+        .cpp(true) // Switch to C++ library compilation.\n+        .file(\"foo.cpp\")\n+        .compile(\"libfoo.a\");\n+}\n+```\n+\n+When using C++ library compilation switch, the `CXX` and `CXXFLAGS` env\n+variables are used instead of `CC` and `CFLAGS` and the C++ standard library is\n+linked to the crate target.\n+\n+## License\n+\n+`gcc-rs` is primarily distributed under the terms of both the MIT license and\n+the Apache License (Version 2.0), with portions covered by various BSD-like\n+licenses.\n+\n+See LICENSE-APACHE, and LICENSE-MIT for details."}, {"sha": "f6108c66514e995f469fd52683ae13c97640ee14", "filename": "src/vendor/gcc/appveyor.yml", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fappveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fappveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fappveyor.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,35 @@\n+environment:\n+  matrix:\n+  - TARGET: x86_64-pc-windows-msvc\n+    ARCH: amd64\n+    VS: C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\vcvarsall.bat\n+  - TARGET: x86_64-pc-windows-msvc\n+    ARCH: amd64\n+    VS: C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\n+  - TARGET: i686-pc-windows-msvc\n+    ARCH: x86\n+    VS: C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\vcvarsall.bat\n+  - TARGET: i686-pc-windows-msvc\n+    ARCH: x86\n+    VS: C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\n+  - TARGET: x86_64-pc-windows-gnu\n+    MSYS_BITS: 64\n+  - TARGET: i686-pc-windows-gnu\n+    MSYS_BITS: 32\n+install:\n+  - ps: Start-FileDownload \"https://static.rust-lang.org/dist/rust-nightly-${env:TARGET}.exe\"\n+  - rust-nightly-%TARGET%.exe /VERYSILENT /NORESTART /DIR=\"C:\\Program Files (x86)\\Rust\"\n+  - if defined VS call \"%VS%\" %ARCH%\n+  - set PATH=%PATH%;C:\\Program Files (x86)\\Rust\\bin\n+  - if defined MSYS_BITS set PATH=%PATH%;C:\\msys64\\mingw%MSYS_BITS%\\bin\n+  - rustc -V\n+  - cargo -V\n+\n+build: false\n+\n+test_script:\n+  - cargo test --target %TARGET%\n+  - cargo test --features parallel --target %TARGET%\n+  - cargo test --manifest-path gcc-test/Cargo.toml --target %TARGET%\n+  - cargo test --manifest-path gcc-test/Cargo.toml --features parallel --target %TARGET%\n+  - cargo test --manifest-path gcc-test/Cargo.toml --release --target %TARGET%"}, {"sha": "43fd811d3615b6728937c202df53e17307ff08d8", "filename": "src/vendor/gcc/src/bin/gcc-shim.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Fbin%2Fgcc-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Fbin%2Fgcc-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fbin%2Fgcc-shim.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,23 @@\n+#![cfg_attr(test, allow(dead_code))]\n+\n+use std::env;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    let out_dir = PathBuf::from(env::var_os(\"GCCTEST_OUT_DIR\").unwrap());\n+    for i in 0.. {\n+        let candidate = out_dir.join(format!(\"out{}\", i));\n+        if candidate.exists() {\n+            continue\n+        }\n+        let mut f = File::create(candidate).unwrap();\n+        for arg in env::args().skip(1) {\n+            writeln!(f, \"{}\", arg).unwrap();\n+        }\n+\n+        File::create(out_dir.join(\"libfoo.a\")).unwrap();\n+        break\n+    }\n+}"}, {"sha": "f319e9313ad7b8a3689466bf8335b134cb8dd901", "filename": "src/vendor/gcc/src/lib.rs", "status": "added", "additions": 959, "deletions": 0, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,959 @@\n+//! A library for build scripts to compile custom C code\n+//!\n+//! This library is intended to be used as a `build-dependencies` entry in\n+//! `Cargo.toml`:\n+//!\n+//! ```toml\n+//! [build-dependencies]\n+//! gcc = \"0.3\"\n+//! ```\n+//!\n+//! The purpose of this crate is to provide the utility functions necessary to\n+//! compile C code into a static archive which is then linked into a Rust crate.\n+//! The top-level `compile_library` function serves as a convenience and more\n+//! advanced configuration is available through the `Config` builder.\n+//!\n+//! This crate will automatically detect situations such as cross compilation or\n+//! other environment variables set by Cargo and will build code appropriately.\n+//!\n+//! # Examples\n+//!\n+//! Use the default configuration:\n+//!\n+//! ```no_run\n+//! extern crate gcc;\n+//!\n+//! fn main() {\n+//!     gcc::compile_library(\"libfoo.a\", &[\"src/foo.c\"]);\n+//! }\n+//! ```\n+//!\n+//! Use more advanced configuration:\n+//!\n+//! ```no_run\n+//! extern crate gcc;\n+//!\n+//! fn main() {\n+//!     gcc::Config::new()\n+//!                 .file(\"src/foo.c\")\n+//!                 .define(\"FOO\", Some(\"bar\"))\n+//!                 .include(\"src\")\n+//!                 .compile(\"libfoo.a\");\n+//! }\n+//! ```\n+\n+#![doc(html_root_url = \"http://alexcrichton.com/gcc-rs\")]\n+#![cfg_attr(test, deny(warnings))]\n+#![deny(missing_docs)]\n+\n+#[cfg(feature = \"parallel\")]\n+extern crate rayon;\n+\n+use std::env;\n+use std::ffi::{OsString, OsStr};\n+use std::fs;\n+use std::io;\n+use std::path::{PathBuf, Path};\n+use std::process::{Command, Stdio};\n+use std::io::{BufReader, BufRead, Write};\n+\n+#[cfg(windows)]\n+mod registry;\n+pub mod windows_registry;\n+\n+/// Extra configuration to pass to gcc.\n+pub struct Config {\n+    include_directories: Vec<PathBuf>,\n+    definitions: Vec<(String, Option<String>)>,\n+    objects: Vec<PathBuf>,\n+    flags: Vec<String>,\n+    files: Vec<PathBuf>,\n+    cpp: bool,\n+    cpp_link_stdlib: Option<Option<String>>,\n+    cpp_set_stdlib: Option<String>,\n+    target: Option<String>,\n+    host: Option<String>,\n+    out_dir: Option<PathBuf>,\n+    opt_level: Option<String>,\n+    debug: Option<bool>,\n+    env: Vec<(OsString, OsString)>,\n+    compiler: Option<PathBuf>,\n+    archiver: Option<PathBuf>,\n+    cargo_metadata: bool,\n+    pic: Option<bool>,\n+}\n+\n+/// Configuration used to represent an invocation of a C compiler.\n+///\n+/// This can be used to figure out what compiler is in use, what the arguments\n+/// to it are, and what the environment variables look like for the compiler.\n+/// This can be used to further configure other build systems (e.g. forward\n+/// along CC and/or CFLAGS) or the `to_command` method can be used to run the\n+/// compiler itself.\n+pub struct Tool {\n+    path: PathBuf,\n+    args: Vec<OsString>,\n+    env: Vec<(OsString, OsString)>,\n+}\n+\n+/// Compile a library from the given set of input C files.\n+///\n+/// This will simply compile all files into object files and then assemble them\n+/// into the output. This will read the standard environment variables to detect\n+/// cross compilations and such.\n+///\n+/// This function will also print all metadata on standard output for Cargo.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// gcc::compile_library(\"libfoo.a\", &[\"foo.c\", \"bar.c\"]);\n+/// ```\n+pub fn compile_library(output: &str, files: &[&str]) {\n+    let mut c = Config::new();\n+    for f in files.iter() {\n+        c.file(*f);\n+    }\n+    c.compile(output)\n+}\n+\n+impl Config {\n+    /// Construct a new instance of a blank set of configuration.\n+    ///\n+    /// This builder is finished with the `compile` function.\n+    pub fn new() -> Config {\n+        Config {\n+            include_directories: Vec::new(),\n+            definitions: Vec::new(),\n+            objects: Vec::new(),\n+            flags: Vec::new(),\n+            files: Vec::new(),\n+            cpp: false,\n+            cpp_link_stdlib: None,\n+            cpp_set_stdlib: None,\n+            target: None,\n+            host: None,\n+            out_dir: None,\n+            opt_level: None,\n+            debug: None,\n+            env: Vec::new(),\n+            compiler: None,\n+            archiver: None,\n+            cargo_metadata: true,\n+            pic: None,\n+        }\n+    }\n+\n+    /// Add a directory to the `-I` or include path for headers\n+    pub fn include<P: AsRef<Path>>(&mut self, dir: P) -> &mut Config {\n+        self.include_directories.push(dir.as_ref().to_path_buf());\n+        self\n+    }\n+\n+    /// Specify a `-D` variable with an optional value.\n+    pub fn define(&mut self, var: &str, val: Option<&str>) -> &mut Config {\n+        self.definitions.push((var.to_string(), val.map(|s| s.to_string())));\n+        self\n+    }\n+\n+    /// Add an arbitrary object file to link in\n+    pub fn object<P: AsRef<Path>>(&mut self, obj: P) -> &mut Config {\n+        self.objects.push(obj.as_ref().to_path_buf());\n+        self\n+    }\n+\n+    /// Add an arbitrary flag to the invocation of the compiler\n+    pub fn flag(&mut self, flag: &str) -> &mut Config {\n+        self.flags.push(flag.to_string());\n+        self\n+    }\n+\n+    /// Add a file which will be compiled\n+    pub fn file<P: AsRef<Path>>(&mut self, p: P) -> &mut Config {\n+        self.files.push(p.as_ref().to_path_buf());\n+        self\n+    }\n+\n+    /// Set C++ support.\n+    ///\n+    /// The other `cpp_*` options will only become active if this is set to\n+    /// `true`.\n+    pub fn cpp(&mut self, cpp: bool) -> &mut Config {\n+        self.cpp = cpp;\n+        self\n+    }\n+\n+    /// Set the standard library to link against when compiling with C++\n+    /// support.\n+    ///\n+    /// The default value of this property depends on the current target: On\n+    /// OS X `Some(\"c++\")` is used, when compiling for a Visual Studio based\n+    /// target `None` is used and for other targets `Some(\"stdc++\")` is used.\n+    ///\n+    /// A value of `None` indicates that no automatic linking should happen,\n+    /// otherwise cargo will link against the specified library.\n+    ///\n+    /// The given library name must not contain the `lib` prefix.\n+    pub fn cpp_link_stdlib(&mut self, cpp_link_stdlib: Option<&str>)\n+                           -> &mut Config {\n+        self.cpp_link_stdlib = Some(cpp_link_stdlib.map(|s| s.into()));\n+        self\n+    }\n+\n+    /// Force the C++ compiler to use the specified standard library.\n+    ///\n+    /// Setting this option will automatically set `cpp_link_stdlib` to the same\n+    /// value.\n+    ///\n+    /// The default value of this option is always `None`.\n+    ///\n+    /// This option has no effect when compiling for a Visual Studio based\n+    /// target.\n+    ///\n+    /// This option sets the `-stdlib` flag, which is only supported by some\n+    /// compilers (clang, icc) but not by others (gcc). The library will not\n+    /// detect which compiler is used, as such it is the responsibility of the\n+    /// caller to ensure that this option is only used in conjuction with a\n+    /// compiler which supports the `-stdlib` flag.\n+    ///\n+    /// A value of `None` indicates that no specific C++ standard library should\n+    /// be used, otherwise `-stdlib` is added to the compile invocation.\n+    ///\n+    /// The given library name must not contain the `lib` prefix.\n+    pub fn cpp_set_stdlib(&mut self, cpp_set_stdlib: Option<&str>)\n+                          -> &mut Config {\n+        self.cpp_set_stdlib = cpp_set_stdlib.map(|s| s.into());\n+        self.cpp_link_stdlib(cpp_set_stdlib);\n+        self\n+    }\n+\n+    /// Configures the target this configuration will be compiling for.\n+    ///\n+    /// This option is automatically scraped from the `TARGET` environment\n+    /// variable by build scripts, so it's not required to call this function.\n+    pub fn target(&mut self, target: &str) -> &mut Config {\n+        self.target = Some(target.to_string());\n+        self\n+    }\n+\n+    /// Configures the host assumed by this configuration.\n+    ///\n+    /// This option is automatically scraped from the `HOST` environment\n+    /// variable by build scripts, so it's not required to call this function.\n+    pub fn host(&mut self, host: &str) -> &mut Config {\n+        self.host = Some(host.to_string());\n+        self\n+    }\n+\n+    /// Configures the optimization level of the generated object files.\n+    ///\n+    /// This option is automatically scraped from the `OPT_LEVEL` environment\n+    /// variable by build scripts, so it's not required to call this function.\n+    pub fn opt_level(&mut self, opt_level: u32) -> &mut Config {\n+        self.opt_level = Some(opt_level.to_string());\n+        self\n+    }\n+\n+    /// Configures the optimization level of the generated object files.\n+    ///\n+    /// This option is automatically scraped from the `OPT_LEVEL` environment\n+    /// variable by build scripts, so it's not required to call this function.\n+    pub fn opt_level_str(&mut self, opt_level: &str) -> &mut Config {\n+        self.opt_level = Some(opt_level.to_string());\n+        self\n+    }\n+\n+    /// Configures whether the compiler will emit debug information when\n+    /// generating object files.\n+    ///\n+    /// This option is automatically scraped from the `PROFILE` environment\n+    /// variable by build scripts (only enabled when the profile is \"debug\"), so\n+    /// it's not required to call this function.\n+    pub fn debug(&mut self, debug: bool) -> &mut Config {\n+        self.debug = Some(debug);\n+        self\n+    }\n+\n+    /// Configures the output directory where all object files and static\n+    /// libraries will be located.\n+    ///\n+    /// This option is automatically scraped from the `OUT_DIR` environment\n+    /// variable by build scripts, so it's not required to call this function.\n+    pub fn out_dir<P: AsRef<Path>>(&mut self, out_dir: P) -> &mut Config {\n+        self.out_dir = Some(out_dir.as_ref().to_owned());\n+        self\n+    }\n+\n+    /// Configures the compiler to be used to produce output.\n+    ///\n+    /// This option is automatically determined from the target platform or a\n+    /// number of environment variables, so it's not required to call this\n+    /// function.\n+    pub fn compiler<P: AsRef<Path>>(&mut self, compiler: P) -> &mut Config {\n+        self.compiler = Some(compiler.as_ref().to_owned());\n+        self\n+    }\n+\n+    /// Configures the tool used to assemble archives.\n+    ///\n+    /// This option is automatically determined from the target platform or a\n+    /// number of environment variables, so it's not required to call this\n+    /// function.\n+    pub fn archiver<P: AsRef<Path>>(&mut self, archiver: P) -> &mut Config {\n+        self.archiver = Some(archiver.as_ref().to_owned());\n+        self\n+    }\n+    /// Define whether metadata should be emitted for cargo allowing it to\n+    /// automatically link the binary. Defaults to `true`.\n+    pub fn cargo_metadata(&mut self, cargo_metadata: bool) -> &mut Config {\n+        self.cargo_metadata = cargo_metadata;\n+        self\n+    }\n+\n+    /// Configures whether the compiler will emit position independent code.\n+    ///\n+    /// This option defaults to `false` for `i686` and `windows-gnu` targets and to `true` for all\n+    /// other targets.\n+    pub fn pic(&mut self, pic: bool) -> &mut Config {\n+        self.pic = Some(pic);\n+        self\n+    }\n+\n+\n+    #[doc(hidden)]\n+    pub fn __set_env<A, B>(&mut self, a: A, b: B) -> &mut Config\n+        where A: AsRef<OsStr>, B: AsRef<OsStr>\n+    {\n+        self.env.push((a.as_ref().to_owned(), b.as_ref().to_owned()));\n+        self\n+    }\n+\n+    /// Run the compiler, generating the file `output`\n+    ///\n+    /// The name `output` must begin with `lib` and end with `.a`\n+    pub fn compile(&self, output: &str) {\n+        assert!(output.starts_with(\"lib\"));\n+        assert!(output.ends_with(\".a\"));\n+        let lib_name = &output[3..output.len() - 2];\n+        let dst = self.get_out_dir();\n+\n+        let mut objects = Vec::new();\n+        let mut src_dst = Vec::new();\n+        for file in self.files.iter() {\n+            let obj = dst.join(file).with_extension(\"o\");\n+            let obj = if !obj.starts_with(&dst) {\n+                dst.join(obj.file_name().unwrap())\n+            } else {\n+                obj\n+            };\n+            fs::create_dir_all(&obj.parent().unwrap()).unwrap();\n+            src_dst.push((file.to_path_buf(), obj.clone()));\n+            objects.push(obj);\n+        }\n+        self.compile_objects(&src_dst);\n+        self.assemble(lib_name, &dst.join(output), &objects);\n+\n+        self.print(&format!(\"cargo:rustc-link-lib=static={}\",\n+                            &output[3..output.len() - 2]));\n+        self.print(&format!(\"cargo:rustc-link-search=native={}\", dst.display()));\n+\n+        // Add specific C++ libraries, if enabled.\n+        if self.cpp {\n+            if let Some(stdlib) = self.get_cpp_link_stdlib() {\n+                self.print(&format!(\"cargo:rustc-link-lib={}\", stdlib));\n+            }\n+        }\n+    }\n+\n+    #[cfg(feature = \"parallel\")]\n+    fn compile_objects(&self, objs: &[(PathBuf, PathBuf)]) {\n+        use self::rayon::prelude::*;\n+\n+        let mut cfg = rayon::Configuration::new();\n+        if let Ok(amt) = env::var(\"NUM_JOBS\") {\n+            if let Ok(amt) = amt.parse() {\n+                cfg = cfg.set_num_threads(amt);\n+            }\n+        }\n+        drop(rayon::initialize(cfg));\n+\n+        objs.par_iter().weight_max().for_each(|&(ref src, ref dst)| {\n+            self.compile_object(src, dst)\n+        })\n+    }\n+\n+    #[cfg(not(feature = \"parallel\"))]\n+    fn compile_objects(&self, objs: &[(PathBuf, PathBuf)]) {\n+        for &(ref src, ref dst) in objs {\n+            self.compile_object(src, dst);\n+        }\n+    }\n+\n+    fn compile_object(&self, file: &Path, dst: &Path) {\n+        let is_asm = file.extension().and_then(|s| s.to_str()) == Some(\"asm\");\n+        let msvc = self.get_target().contains(\"msvc\");\n+        let (mut cmd, name) = if msvc && is_asm {\n+            self.msvc_macro_assembler()\n+        } else {\n+            let compiler = self.get_compiler();\n+            let mut cmd = compiler.to_command();\n+            for &(ref a, ref b) in self.env.iter() {\n+                cmd.env(a, b);\n+            }\n+            (cmd, compiler.path.file_name().unwrap()\n+                          .to_string_lossy().into_owned())\n+        };\n+        if msvc && is_asm {\n+            cmd.arg(\"/Fo\").arg(dst);\n+        } else if msvc {\n+            let mut s = OsString::from(\"/Fo\");\n+            s.push(&dst);\n+            cmd.arg(s);\n+        } else {\n+            cmd.arg(\"-o\").arg(&dst);\n+        }\n+        cmd.arg(if msvc {\"/c\"} else {\"-c\"});\n+        cmd.arg(file);\n+\n+        run(&mut cmd, &name);\n+    }\n+\n+    /// Get the compiler that's in use for this configuration.\n+    ///\n+    /// This function will return a `Tool` which represents the culmination\n+    /// of this configuration at a snapshot in time. The returned compiler can\n+    /// be inspected (e.g. the path, arguments, environment) to forward along to\n+    /// other tools, or the `to_command` method can be used to invoke the\n+    /// compiler itself.\n+    ///\n+    /// This method will take into account all configuration such as debug\n+    /// information, optimization level, include directories, defines, etc.\n+    /// Additionally, the compiler binary in use follows the standard\n+    /// conventions for this path, e.g. looking at the explicitly set compiler,\n+    /// environment variables (a number of which are inspected here), and then\n+    /// falling back to the default configuration.\n+    pub fn get_compiler(&self) -> Tool {\n+        let opt_level = self.get_opt_level();\n+        let debug = self.get_debug();\n+        let target = self.get_target();\n+        let msvc = target.contains(\"msvc\");\n+        self.print(&format!(\"debug={} opt-level={}\", debug, opt_level));\n+\n+        let mut cmd = self.get_base_compiler();\n+        let nvcc = cmd.path.to_str()\n+            .map(|path| path.contains(\"nvcc\"))\n+            .unwrap_or(false);\n+\n+        if msvc {\n+            cmd.args.push(\"/nologo\".into());\n+            cmd.args.push(\"/MD\".into()); // link against msvcrt.dll for now\n+            match &opt_level[..] {\n+                \"z\" | \"s\" => cmd.args.push(\"/Os\".into()),\n+                \"2\" => cmd.args.push(\"/O2\".into()),\n+                \"1\" => cmd.args.push(\"/O1\".into()),\n+                _ => {}\n+            }\n+            if target.contains(\"i686\") {\n+                cmd.args.push(\"/SAFESEH\".into());\n+            } else if target.contains(\"i586\") {\n+                cmd.args.push(\"/SAFESEH\".into());\n+                cmd.args.push(\"/ARCH:IA32\".into());\n+            }\n+        } else if nvcc {\n+            cmd.args.push(format!(\"-O{}\", opt_level).into());\n+        } else {\n+            cmd.args.push(format!(\"-O{}\", opt_level).into());\n+            cmd.args.push(\"-ffunction-sections\".into());\n+            cmd.args.push(\"-fdata-sections\".into());\n+        }\n+        for arg in self.envflags(if self.cpp {\"CXXFLAGS\"} else {\"CFLAGS\"}) {\n+            cmd.args.push(arg.into());\n+        }\n+\n+        if debug {\n+            cmd.args.push(if msvc {\"/Z7\"} else {\"-g\"}.into());\n+        }\n+\n+        if target.contains(\"-ios\") {\n+            self.ios_flags(&mut cmd);\n+        } else if !msvc {\n+            if target.contains(\"i686\") || target.contains(\"i586\") {\n+                cmd.args.push(\"-m32\".into());\n+            } else if target.contains(\"x86_64\") || target.contains(\"powerpc64\") {\n+                cmd.args.push(\"-m64\".into());\n+            }\n+\n+            if !nvcc && self.pic.unwrap_or(!target.contains(\"i686\") && !target.contains(\"windows-gnu\")) {\n+                cmd.args.push(\"-fPIC\".into());\n+            } else if nvcc && self.pic.unwrap_or(false) {\n+                cmd.args.push(\"-Xcompiler\".into());\n+                cmd.args.push(\"\\'-fPIC\\'\".into());\n+            }\n+            if target.contains(\"musl\") {\n+                cmd.args.push(\"-static\".into());\n+            }\n+\n+            if target.starts_with(\"armv7-unknown-linux-\") {\n+                cmd.args.push(\"-march=armv7-a\".into());\n+            }\n+            if target.starts_with(\"armv7-linux-androideabi\") {\n+                cmd.args.push(\"-march=armv7-a\".into());\n+                cmd.args.push(\"-mfpu=vfpv3-d16\".into());\n+            }\n+            if target.starts_with(\"arm-unknown-linux-\") {\n+                cmd.args.push(\"-march=armv6\".into());\n+                cmd.args.push(\"-marm\".into());\n+            }\n+            if target.starts_with(\"i586-unknown-linux-\") {\n+                cmd.args.push(\"-march=pentium\".into());\n+            }\n+            if target.starts_with(\"i686-unknown-linux-\") {\n+                cmd.args.push(\"-march=i686\".into());\n+            }\n+            if target.starts_with(\"thumb\") {\n+                cmd.args.push(\"-mthumb\".into());\n+\n+                if target.ends_with(\"eabihf\") {\n+                    cmd.args.push(\"-mfloat-abi=hard\".into())\n+                }\n+            }\n+            if target.starts_with(\"thumbv6m\") {\n+                cmd.args.push(\"-march=armv6-m\".into());\n+            }\n+            if target.starts_with(\"thumbv7em\") {\n+                cmd.args.push(\"-march=armv7e-m\".into());\n+            }\n+            if target.starts_with(\"thumbv7m\") {\n+                cmd.args.push(\"-march=armv7-m\".into());\n+            }\n+        }\n+\n+        if self.cpp && !msvc {\n+            if let Some(ref stdlib) = self.cpp_set_stdlib {\n+                cmd.args.push(format!(\"-stdlib=lib{}\", stdlib).into());\n+            }\n+        }\n+\n+        for directory in self.include_directories.iter() {\n+            cmd.args.push(if msvc {\"/I\"} else {\"-I\"}.into());\n+            cmd.args.push(directory.into());\n+        }\n+\n+        for flag in self.flags.iter() {\n+            cmd.args.push(flag.into());\n+        }\n+\n+        for &(ref key, ref value) in self.definitions.iter() {\n+            let lead = if msvc {\"/\"} else {\"-\"};\n+            if let &Some(ref value) = value {\n+                cmd.args.push(format!(\"{}D{}={}\", lead, key, value).into());\n+            } else {\n+                cmd.args.push(format!(\"{}D{}\", lead, key).into());\n+            }\n+        }\n+        cmd\n+    }\n+\n+    fn msvc_macro_assembler(&self) -> (Command, String) {\n+        let target = self.get_target();\n+        let tool = if target.contains(\"x86_64\") {\"ml64.exe\"} else {\"ml.exe\"};\n+        let mut cmd = windows_registry::find(&target, tool).unwrap_or_else(|| {\n+            self.cmd(tool)\n+        });\n+        for directory in self.include_directories.iter() {\n+            cmd.arg(\"/I\").arg(directory);\n+        }\n+        for &(ref key, ref value) in self.definitions.iter() {\n+            if let &Some(ref value) = value {\n+                cmd.arg(&format!(\"/D{}={}\", key, value));\n+            } else {\n+                cmd.arg(&format!(\"/D{}\", key));\n+            }\n+        }\n+\n+        if target.contains(\"i686\") || target.contains(\"i586\") {\n+            cmd.arg(\"/safeseh\");\n+        }\n+        for flag in self.flags.iter() {\n+            cmd.arg(flag);\n+        }\n+\n+        (cmd, tool.to_string())\n+    }\n+\n+    fn assemble(&self, lib_name: &str, dst: &Path, objects: &[PathBuf]) {\n+        // Delete the destination if it exists as the `ar` tool at least on Unix\n+        // appends to it, which we don't want.\n+        let _ = fs::remove_file(&dst);\n+\n+        let target = self.get_target();\n+        if target.contains(\"msvc\") {\n+            let mut cmd = match self.archiver {\n+                Some(ref s) => self.cmd(s),\n+                None => windows_registry::find(&target, \"lib.exe\")\n+                                         .unwrap_or(self.cmd(\"lib.exe\")),\n+            };\n+            let mut out = OsString::from(\"/OUT:\");\n+            out.push(dst);\n+            run(cmd.arg(out).arg(\"/nologo\")\n+                   .args(objects)\n+                   .args(&self.objects), \"lib.exe\");\n+\n+            // The Rust compiler will look for libfoo.a and foo.lib, but the\n+            // MSVC linker will also be passed foo.lib, so be sure that both\n+            // exist for now.\n+            let lib_dst = dst.with_file_name(format!(\"{}.lib\", lib_name));\n+            let _ = fs::remove_file(&lib_dst);\n+            fs::hard_link(&dst, &lib_dst).or_else(|_| {\n+                //if hard-link fails, just copy (ignoring the number of bytes written)\n+                fs::copy(&dst, &lib_dst).map(|_| ())\n+            }).ok().expect(\"Copying from {:?} to {:?} failed.\");;\n+        } else {\n+            let ar = self.get_ar();\n+            let cmd = ar.file_name().unwrap().to_string_lossy();\n+            run(self.cmd(&ar).arg(\"crs\")\n+                                 .arg(dst)\n+                                 .args(objects)\n+                                 .args(&self.objects), &cmd);\n+        }\n+    }\n+\n+    fn ios_flags(&self, cmd: &mut Tool) {\n+        enum ArchSpec {\n+            Device(&'static str),\n+            Simulator(&'static str),\n+        }\n+\n+        let target = self.get_target();\n+        let arch = target.split('-').nth(0).unwrap();\n+        let arch = match arch {\n+            \"arm\" | \"armv7\" | \"thumbv7\" => ArchSpec::Device(\"armv7\"),\n+            \"armv7s\" | \"thumbv7s\" => ArchSpec::Device(\"armv7s\"),\n+            \"arm64\" | \"aarch64\" => ArchSpec::Device(\"arm64\"),\n+            \"i386\" | \"i686\" => ArchSpec::Simulator(\"-m32\"),\n+            \"x86_64\" => ArchSpec::Simulator(\"-m64\"),\n+            _ => fail(\"Unknown arch for iOS target\")\n+        };\n+\n+        let sdk = match arch {\n+            ArchSpec::Device(arch) => {\n+                cmd.args.push(\"-arch\".into());\n+                cmd.args.push(arch.into());\n+                cmd.args.push(\"-miphoneos-version-min=7.0\".into());\n+                \"iphoneos\"\n+            },\n+            ArchSpec::Simulator(arch) => {\n+                cmd.args.push(arch.into());\n+                cmd.args.push(\"-mios-simulator-version-min=7.0\".into());\n+                \"iphonesimulator\"\n+            }\n+        };\n+\n+        self.print(&format!(\"Detecting iOS SDK path for {}\", sdk));\n+        let sdk_path = self.cmd(\"xcrun\")\n+            .arg(\"--show-sdk-path\")\n+            .arg(\"--sdk\")\n+            .arg(sdk)\n+            .stderr(Stdio::inherit())\n+            .output()\n+            .unwrap()\n+            .stdout;\n+\n+        let sdk_path = String::from_utf8(sdk_path).unwrap();\n+\n+        cmd.args.push(\"-isysroot\".into());\n+        cmd.args.push(sdk_path.trim().into());\n+    }\n+\n+    fn cmd<P: AsRef<OsStr>>(&self, prog: P) -> Command {\n+        let mut cmd = Command::new(prog);\n+        for &(ref a, ref b) in self.env.iter() {\n+            cmd.env(a, b);\n+        }\n+        return cmd\n+    }\n+\n+    fn get_base_compiler(&self) -> Tool {\n+        if let Some(ref c) = self.compiler {\n+            return Tool::new(c.clone())\n+        }\n+        let host = self.get_host();\n+        let target = self.get_target();\n+        let (env, msvc, gnu, default) = if self.cpp {\n+            (\"CXX\", \"cl.exe\", \"g++\", \"c++\")\n+        } else {\n+            (\"CC\", \"cl.exe\", \"gcc\", \"cc\")\n+        };\n+        self.env_tool(env).map(|(tool, args)| {\n+            let mut t = Tool::new(PathBuf::from(tool));\n+            for arg in args {\n+                t.args.push(arg.into());\n+            }\n+            return t\n+        }).or_else(|| {\n+            if target.contains(\"emscripten\") {\n+                if self.cpp {\n+                    Some(Tool::new(PathBuf::from(\"em++\")))\n+                } else {\n+                    Some(Tool::new(PathBuf::from(\"emcc\")))\n+                }\n+            } else {\n+                None\n+            }\n+        }).or_else(|| {\n+            windows_registry::find_tool(&target, \"cl.exe\")\n+        }).unwrap_or_else(|| {\n+            let compiler = if host.contains(\"windows\") &&\n+                              target.contains(\"windows\") {\n+                if target.contains(\"msvc\") {\n+                    msvc.to_string()\n+                } else {\n+                    format!(\"{}.exe\", gnu)\n+                }\n+            } else if target.contains(\"android\") {\n+                format!(\"{}-{}\", target, gnu)\n+            } else if self.get_host() != target {\n+                // CROSS_COMPILE is of the form: \"arm-linux-gnueabi-\"\n+                let cc_env = self.getenv(\"CROSS_COMPILE\");\n+                let cross_compile = cc_env.as_ref().map(|s| s.trim_right_matches('-'));\n+                let prefix = cross_compile.or(match &target[..] {\n+                    \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu\"),\n+                    \"arm-unknown-linux-gnueabi\" => Some(\"arm-linux-gnueabi\"),\n+                    \"arm-unknown-linux-gnueabihf\"  => Some(\"arm-linux-gnueabihf\"),\n+                    \"arm-unknown-linux-musleabi\" => Some(\"arm-linux-musleabi\"),\n+                    \"arm-unknown-linux-musleabihf\"  => Some(\"arm-linux-musleabihf\"),\n+                    \"arm-unknown-netbsdelf-eabi\" => Some(\"arm--netbsdelf-eabi\"),\n+                    \"armv6-unknown-netbsdelf-eabihf\" => Some(\"armv6--netbsdelf-eabihf\"),\n+                    \"armv7-unknown-linux-gnueabihf\" => Some(\"arm-linux-gnueabihf\"),\n+                    \"armv7-unknown-linux-musleabihf\" => Some(\"arm-linux-musleabihf\"),\n+                    \"armv7-unknown-netbsdelf-eabihf\" => Some(\"armv7--netbsdelf-eabihf\"),\n+                    \"i686-pc-windows-gnu\" => Some(\"i686-w64-mingw32\"),\n+                    \"i686-unknown-linux-musl\" => Some(\"musl\"),\n+                    \"i686-unknown-netbsdelf\" => Some(\"i486--netbsdelf\"),\n+                    \"mips-unknown-linux-gnu\" => Some(\"mips-linux-gnu\"),\n+                    \"mipsel-unknown-linux-gnu\" => Some(\"mipsel-linux-gnu\"),\n+                    \"mips64-unknown-linux-gnuabi64\" => Some(\"mips64-linux-gnuabi64\"),\n+                    \"mips64el-unknown-linux-gnuabi64\" => Some(\"mips64el-linux-gnuabi64\"),\n+                    \"powerpc-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n+                    \"powerpc-unknown-netbsd\" => Some(\"powerpc--netbsd\"),\n+                    \"powerpc64-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n+                    \"powerpc64le-unknown-linux-gnu\" => Some(\"powerpc64le-linux-gnu\"),\n+                    \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu\"),\n+                    \"thumbv6m-none-eabi\" => Some(\"arm-none-eabi\"),\n+                    \"thumbv7em-none-eabi\" => Some(\"arm-none-eabi\"),\n+                    \"thumbv7em-none-eabihf\" => Some(\"arm-none-eabi\"),\n+                    \"thumbv7m-none-eabi\" => Some(\"arm-none-eabi\"),\n+                    \"x86_64-pc-windows-gnu\" => Some(\"x86_64-w64-mingw32\"),\n+                    \"x86_64-rumprun-netbsd\" => Some(\"x86_64-rumprun-netbsd\"),\n+                    \"x86_64-unknown-linux-musl\" => Some(\"musl\"),\n+                    \"x86_64-unknown-netbsd\" => Some(\"x86_64--netbsd\"),\n+                    _ => None,\n+                });\n+                match prefix {\n+                    Some(prefix) => format!(\"{}-{}\", prefix, gnu),\n+                    None => default.to_string(),\n+                }\n+            } else {\n+                default.to_string()\n+            };\n+            Tool::new(PathBuf::from(compiler))\n+        })\n+    }\n+\n+    fn get_var(&self, var_base: &str) -> Result<String, String> {\n+        let target = self.get_target();\n+        let host = self.get_host();\n+        let kind = if host == target {\"HOST\"} else {\"TARGET\"};\n+        let target_u = target.replace(\"-\", \"_\");\n+        let res = self.getenv(&format!(\"{}_{}\", var_base, target))\n+            .or_else(|| self.getenv(&format!(\"{}_{}\", var_base, target_u)))\n+            .or_else(|| self.getenv(&format!(\"{}_{}\", kind, var_base)))\n+            .or_else(|| self.getenv(var_base));\n+\n+        match res {\n+            Some(res) => Ok(res),\n+            None => Err(\"could not get environment variable\".to_string()),\n+        }\n+    }\n+\n+    fn envflags(&self, name: &str) -> Vec<String> {\n+        self.get_var(name).unwrap_or(String::new())\n+            .split(|c: char| c.is_whitespace()).filter(|s| !s.is_empty())\n+            .map(|s| s.to_string())\n+            .collect()\n+    }\n+\n+    fn env_tool(&self, name: &str) -> Option<(String, Vec<String>)> {\n+        self.get_var(name).ok().map(|tool| {\n+            let whitelist = [\"ccache\", \"distcc\"];\n+            for t in whitelist.iter() {\n+                if tool.starts_with(t) && tool[t.len()..].starts_with(\" \") {\n+                    return (t.to_string(),\n+                            vec![tool[t.len()..].trim_left().to_string()])\n+                }\n+            }\n+            (tool, Vec::new())\n+        })\n+    }\n+\n+    /// Returns the default C++ standard library for the current target: `libc++`\n+    /// for OS X and `libstdc++` for anything else.\n+    fn get_cpp_link_stdlib(&self) -> Option<String> {\n+        self.cpp_link_stdlib.clone().unwrap_or_else(|| {\n+            let target = self.get_target();\n+            if target.contains(\"msvc\") {\n+                None\n+            } else if target.contains(\"darwin\") {\n+                Some(\"c++\".to_string())\n+            } else {\n+                Some(\"stdc++\".to_string())\n+            }\n+        })\n+    }\n+\n+    fn get_ar(&self) -> PathBuf {\n+        self.archiver.clone().or_else(|| {\n+            self.get_var(\"AR\").map(PathBuf::from).ok()\n+        }).unwrap_or_else(|| {\n+            if self.get_target().contains(\"android\") {\n+                PathBuf::from(format!(\"{}-ar\", self.get_target()))\n+            } else if self.get_target().contains(\"emscripten\") {\n+                PathBuf::from(\"emar\")\n+            } else {\n+                PathBuf::from(\"ar\")\n+            }\n+        })\n+    }\n+\n+    fn get_target(&self) -> String {\n+        self.target.clone().unwrap_or_else(|| self.getenv_unwrap(\"TARGET\"))\n+    }\n+\n+    fn get_host(&self) -> String {\n+        self.host.clone().unwrap_or_else(|| self.getenv_unwrap(\"HOST\"))\n+    }\n+\n+    fn get_opt_level(&self) -> String {\n+        self.opt_level.as_ref().cloned().unwrap_or_else(|| {\n+            self.getenv_unwrap(\"OPT_LEVEL\")\n+        })\n+    }\n+\n+    fn get_debug(&self) -> bool {\n+        self.debug.unwrap_or_else(|| self.getenv_unwrap(\"PROFILE\") == \"debug\")\n+    }\n+\n+    fn get_out_dir(&self) -> PathBuf {\n+        self.out_dir.clone().unwrap_or_else(|| {\n+            env::var_os(\"OUT_DIR\").map(PathBuf::from).unwrap()\n+        })\n+    }\n+\n+    fn getenv(&self, v: &str) -> Option<String> {\n+        let r = env::var(v).ok();\n+        self.print(&format!(\"{} = {:?}\", v, r));\n+        r\n+    }\n+\n+    fn getenv_unwrap(&self, v: &str) -> String {\n+        match self.getenv(v) {\n+            Some(s) => s,\n+            None => fail(&format!(\"environment variable `{}` not defined\", v)),\n+        }\n+    }\n+\n+    fn print(&self, s: &str) {\n+        if self.cargo_metadata {\n+            println!(\"{}\", s);\n+        }\n+    }\n+}\n+\n+impl Tool {\n+    fn new(path: PathBuf) -> Tool {\n+        Tool {\n+            path: path,\n+            args: Vec::new(),\n+            env: Vec::new(),\n+        }\n+    }\n+\n+    /// Converts this compiler into a `Command` that's ready to be run.\n+    ///\n+    /// This is useful for when the compiler needs to be executed and the\n+    /// command returned will already have the initial arguments and environment\n+    /// variables configured.\n+    pub fn to_command(&self) -> Command {\n+        let mut cmd = Command::new(&self.path);\n+        cmd.args(&self.args);\n+        for &(ref k, ref v) in self.env.iter() {\n+            cmd.env(k, v);\n+        }\n+        return cmd\n+    }\n+\n+    /// Returns the path for this compiler.\n+    ///\n+    /// Note that this may not be a path to a file on the filesystem, e.g. \"cc\",\n+    /// but rather something which will be resolved when a process is spawned.\n+    pub fn path(&self) -> &Path {\n+        &self.path\n+    }\n+\n+    /// Returns the default set of arguments to the compiler needed to produce\n+    /// executables for the target this compiler generates.\n+    pub fn args(&self) -> &[OsString] {\n+        &self.args\n+    }\n+\n+    /// Returns the set of environment variables needed for this compiler to\n+    /// operate.\n+    ///\n+    /// This is typically only used for MSVC compilers currently.\n+    pub fn env(&self) -> &[(OsString, OsString)] {\n+        &self.env\n+    }\n+}\n+\n+fn run(cmd: &mut Command, program: &str) {\n+    println!(\"running: {:?}\", cmd);\n+    // Capture the standard error coming from these programs, and write it out\n+    // with cargo:warning= prefixes. Note that this is a bit wonky to avoid\n+    // requiring the output to be UTF-8, we instead just ship bytes from one\n+    // location to another.\n+    let spawn_result = match cmd.stderr(Stdio::piped()).spawn() {\n+        Ok(mut child) => {\n+            let stderr = BufReader::new(child.stderr.take().unwrap());\n+            for line in stderr.split(b'\\n').filter_map(|l| l.ok()) {\n+                print!(\"cargo:warning=\");\n+                std::io::stdout().write_all(&line).unwrap();\n+                println!(\"\");\n+            }\n+            child.wait()\n+        }\n+        Err(e) => Err(e),\n+    };\n+    let status = match spawn_result {\n+        Ok(status) => status,\n+        Err(ref e) if e.kind() == io::ErrorKind::NotFound => {\n+            let extra = if cfg!(windows) {\n+                \" (see https://github.com/alexcrichton/gcc-rs#compile-time-requirements \\\n+                   for help)\"\n+            } else {\n+                \"\"\n+            };\n+            fail(&format!(\"failed to execute command: {}\\nIs `{}` \\\n+                           not installed?{}\", e, program, extra));\n+        }\n+        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+    };\n+    println!(\"{:?}\", status);\n+    if !status.success() {\n+        fail(&format!(\"command did not execute successfully, got: {}\", status));\n+    }\n+}\n+\n+fn fail(s: &str) -> ! {\n+    println!(\"\\n\\n{}\\n\\n\", s);\n+    panic!()\n+}"}, {"sha": "d871cd21f3c06d69e40a3c332e91fd97323b1d8b", "filename": "src/vendor/gcc/src/registry.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fregistry.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ffi::{OsString, OsStr};\n+use std::io;\n+use std::ops::RangeFrom;\n+use std::os::raw;\n+use std::os::windows::prelude::*;\n+\n+pub struct RegistryKey(Repr);\n+\n+type HKEY = *mut u8;\n+type DWORD = u32;\n+type LPDWORD = *mut DWORD;\n+type LPCWSTR = *const u16;\n+type LPWSTR = *mut u16;\n+type LONG = raw::c_long;\n+type PHKEY = *mut HKEY;\n+type PFILETIME = *mut u8;\n+type LPBYTE = *mut u8;\n+type REGSAM = u32;\n+\n+const ERROR_SUCCESS: DWORD = 0;\n+const ERROR_NO_MORE_ITEMS: DWORD = 259;\n+const HKEY_LOCAL_MACHINE: HKEY = 0x80000002 as HKEY;\n+const REG_SZ: DWORD = 1;\n+const KEY_READ: DWORD = 0x20019;\n+const KEY_WOW64_32KEY: DWORD = 0x200;\n+\n+#[link(name = \"advapi32\")]\n+extern \"system\" {\n+    fn RegOpenKeyExW(key: HKEY,\n+                     lpSubKey: LPCWSTR,\n+                     ulOptions: DWORD,\n+                     samDesired: REGSAM,\n+                     phkResult: PHKEY) -> LONG;\n+    fn RegEnumKeyExW(key: HKEY,\n+                     dwIndex: DWORD,\n+                     lpName: LPWSTR,\n+                     lpcName: LPDWORD,\n+                     lpReserved: LPDWORD,\n+                     lpClass: LPWSTR,\n+                     lpcClass: LPDWORD,\n+                     lpftLastWriteTime: PFILETIME) -> LONG;\n+    fn RegQueryValueExW(hKey: HKEY,\n+                        lpValueName: LPCWSTR,\n+                        lpReserved: LPDWORD,\n+                        lpType: LPDWORD,\n+                        lpData: LPBYTE,\n+                        lpcbData: LPDWORD) -> LONG;\n+    fn RegCloseKey(hKey: HKEY) -> LONG;\n+}\n+\n+struct OwnedKey(HKEY);\n+\n+enum Repr {\n+    Const(HKEY),\n+    Owned(OwnedKey),\n+}\n+\n+pub struct Iter<'a> {\n+    idx: RangeFrom<DWORD>,\n+    key: &'a RegistryKey,\n+}\n+\n+unsafe impl Sync for Repr {}\n+unsafe impl Send for Repr {}\n+\n+pub static LOCAL_MACHINE: RegistryKey =\n+    RegistryKey(Repr::Const(HKEY_LOCAL_MACHINE));\n+\n+impl RegistryKey {\n+    fn raw(&self) -> HKEY {\n+        match self.0 {\n+            Repr::Const(val) => val,\n+            Repr::Owned(ref val) => val.0,\n+        }\n+    }\n+\n+    pub fn open(&self, key: &OsStr) -> io::Result<RegistryKey> {\n+        let key = key.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+        let mut ret = 0 as *mut _;\n+        let err = unsafe {\n+            RegOpenKeyExW(self.raw(), key.as_ptr(), 0,\n+                          KEY_READ | KEY_WOW64_32KEY, &mut ret)\n+        };\n+        if err == ERROR_SUCCESS as LONG {\n+            Ok(RegistryKey(Repr::Owned(OwnedKey(ret))))\n+        } else {\n+            Err(io::Error::from_raw_os_error(err as i32))\n+        }\n+    }\n+\n+    pub fn iter(&self) -> Iter {\n+        Iter { idx: 0.., key: self }\n+    }\n+\n+    pub fn query_str(&self, name: &str) -> io::Result<OsString> {\n+        let name: &OsStr = name.as_ref();\n+        let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+        let mut len = 0;\n+        let mut kind = 0;\n+        unsafe {\n+            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n+                                       &mut kind, 0 as *mut _, &mut len);\n+            if err != ERROR_SUCCESS as LONG {\n+                return Err(io::Error::from_raw_os_error(err as i32))\n+            }\n+            if kind != REG_SZ {\n+                return Err(io::Error::new(io::ErrorKind::Other,\n+                                          \"registry key wasn't a string\"))\n+            }\n+\n+            // The length here is the length in bytes, but we're using wide\n+            // characters so we need to be sure to halve it for the capacity\n+            // passed in.\n+            let mut v = Vec::with_capacity(len as usize / 2);\n+            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n+                                       0 as *mut _, v.as_mut_ptr() as *mut _,\n+                                       &mut len);\n+            if err != ERROR_SUCCESS as LONG {\n+                return Err(io::Error::from_raw_os_error(err as i32))\n+            }\n+            v.set_len(len as usize / 2);\n+\n+            // Some registry keys may have a terminating nul character, but\n+            // we're not interested in that, so chop it off if it's there.\n+            if v[v.len() - 1] == 0 {\n+                v.pop();\n+            }\n+            Ok(OsString::from_wide(&v))\n+        }\n+    }\n+}\n+\n+impl Drop for OwnedKey {\n+    fn drop(&mut self) {\n+        unsafe { RegCloseKey(self.0); }\n+    }\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = io::Result<OsString>;\n+\n+    fn next(&mut self) -> Option<io::Result<OsString>> {\n+        self.idx.next().and_then(|i| unsafe {\n+            let mut v = Vec::with_capacity(256);\n+            let mut len = v.capacity() as DWORD;\n+            let ret = RegEnumKeyExW(self.key.raw(), i, v.as_mut_ptr(), &mut len,\n+                                    0 as *mut _, 0 as *mut _, 0 as *mut _,\n+                                    0 as *mut _);\n+            if ret == ERROR_NO_MORE_ITEMS as LONG {\n+                None\n+            } else if ret != ERROR_SUCCESS as LONG {\n+                Some(Err(io::Error::from_raw_os_error(ret as i32)))\n+            } else {\n+                v.set_len(len as usize);\n+                Some(Ok(OsString::from_wide(&v)))\n+            }\n+        })\n+    }\n+}"}, {"sha": "b2c719d27ffdcd0b806a3cac11117805845cf075", "filename": "src/vendor/gcc/src/windows_registry.rs", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,425 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A helper module to probe the Windows Registry when looking for\n+//! windows-specific tools.\n+\n+use std::process::Command;\n+\n+use Tool;\n+\n+macro_rules! otry {\n+    ($expr:expr) => (match $expr {\n+        Some(val) => val,\n+        None => return None,\n+    })\n+}\n+\n+/// Attempts to find a tool within an MSVC installation using the Windows\n+/// registry as a point to search from.\n+///\n+/// The `target` argument is the target that the tool should work for (e.g.\n+/// compile or link for) and the `tool` argument is the tool to find (e.g.\n+/// `cl.exe` or `link.exe`).\n+///\n+/// This function will return `None` if the tool could not be found, or it will\n+/// return `Some(cmd)` which represents a command that's ready to execute the\n+/// tool with the appropriate environment variables set.\n+///\n+/// Note that this function always returns `None` for non-MSVC targets.\n+pub fn find(target: &str, tool: &str) -> Option<Command> {\n+    find_tool(target, tool).map(|c| c.to_command())\n+}\n+\n+/// Similar to the `find` function above, this function will attempt the same\n+/// operation (finding a MSVC tool in a local install) but instead returns a\n+/// `Tool` which may be introspected.\n+#[cfg(not(windows))]\n+pub fn find_tool(_target: &str, _tool: &str) -> Option<Tool> {\n+    None\n+}\n+\n+/// Documented above.\n+#[cfg(windows)]\n+pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n+    use std::env;\n+    use std::ffi::OsString;\n+    use std::mem;\n+    use std::path::{Path, PathBuf};\n+    use registry::{RegistryKey, LOCAL_MACHINE};\n+\n+    struct MsvcTool {\n+        tool: PathBuf,\n+        libs: Vec<PathBuf>,\n+        path: Vec<PathBuf>,\n+        include: Vec<PathBuf>,\n+    }\n+\n+    impl MsvcTool {\n+        fn new(tool: PathBuf) -> MsvcTool {\n+            MsvcTool {\n+                tool: tool,\n+                libs: Vec::new(),\n+                path: Vec::new(),\n+                include: Vec::new(),\n+            }\n+        }\n+\n+        fn into_tool(self) -> Tool {\n+            let MsvcTool { tool, libs, path, include } = self;\n+            let mut tool = Tool::new(tool.into());\n+            add_env(&mut tool, \"LIB\", libs);\n+            add_env(&mut tool, \"PATH\", path);\n+            add_env(&mut tool, \"INCLUDE\", include);\n+            return tool\n+        }\n+    }\n+\n+    // This logic is all tailored for MSVC, if we're not that then bail out\n+    // early.\n+    if !target.contains(\"msvc\") {\n+        return None\n+    }\n+\n+    // Looks like msbuild isn't located in the same location as other tools like\n+    // cl.exe and lib.exe. To handle this we probe for it manually with\n+    // dedicated registry keys.\n+    if tool.contains(\"msbuild\") {\n+        return find_msbuild(target)\n+    }\n+\n+    // If VCINSTALLDIR is set, then someone's probably already run vcvars and we\n+    // should just find whatever that indicates.\n+    if env::var_os(\"VCINSTALLDIR\").is_some() {\n+        return env::var_os(\"PATH\").and_then(|path| {\n+            env::split_paths(&path).map(|p| p.join(tool)).find(|p| p.exists())\n+        }).map(|path| {\n+            Tool::new(path.into())\n+        })\n+    }\n+\n+    // Ok, if we're here, now comes the fun part of the probing. Default shells\n+    // or shells like MSYS aren't really configured to execute `cl.exe` and the\n+    // various compiler tools shipped as part of Visual Studio. Here we try to\n+    // first find the relevant tool, then we also have to be sure to fill in\n+    // environment variables like `LIB`, `INCLUDE`, and `PATH` to ensure that\n+    // the tool is actually usable.\n+\n+    return find_msvc_latest(tool, target, \"15.0\").or_else(|| {\n+        find_msvc_latest(tool, target, \"14.0\")\n+    }).or_else(|| {\n+        find_msvc_12(tool, target)\n+    }).or_else(|| {\n+        find_msvc_11(tool, target)\n+    });\n+\n+    // For MSVC 14 or newer we need to find the Universal CRT as well as either\n+    // the Windows 10 SDK or Windows 8.1 SDK.\n+    fn find_msvc_latest(tool: &str, target: &str, ver: &str) -> Option<Tool> {\n+        let vcdir = otry!(get_vc_dir(ver));\n+        let mut tool = otry!(get_tool(tool, &vcdir, target));\n+        let sub = otry!(lib_subdir(target));\n+        let (ucrt, ucrt_version) = otry!(get_ucrt_dir());\n+\n+        let ucrt_include = ucrt.join(\"include\").join(&ucrt_version);\n+        tool.include.push(ucrt_include.join(\"ucrt\"));\n+\n+        let ucrt_lib = ucrt.join(\"lib\").join(&ucrt_version);\n+        tool.libs.push(ucrt_lib.join(\"ucrt\").join(sub));\n+\n+        if let Some((sdk, version)) = get_sdk10_dir() {\n+            tool.path.push(sdk.join(\"bin\").join(sub));\n+            let sdk_lib = sdk.join(\"lib\").join(&version);\n+            tool.libs.push(sdk_lib.join(\"um\").join(sub));\n+            let sdk_include = sdk.join(\"include\").join(&version);\n+            tool.include.push(sdk_include.join(\"um\"));\n+            tool.include.push(sdk_include.join(\"winrt\"));\n+            tool.include.push(sdk_include.join(\"shared\"));\n+        } else if let Some(sdk) = get_sdk81_dir() {\n+            tool.path.push(sdk.join(\"bin\").join(sub));\n+            let sdk_lib = sdk.join(\"lib\").join(\"winv6.3\");\n+            tool.libs.push(sdk_lib.join(\"um\").join(sub));\n+            let sdk_include = sdk.join(\"include\");\n+            tool.include.push(sdk_include.join(\"um\"));\n+            tool.include.push(sdk_include.join(\"winrt\"));\n+            tool.include.push(sdk_include.join(\"shared\"));\n+        } else {\n+            return None\n+        }\n+        Some(tool.into_tool())\n+    }\n+\n+    // For MSVC 12 we need to find the Windows 8.1 SDK.\n+    fn find_msvc_12(tool: &str, target: &str) -> Option<Tool> {\n+        let vcdir = otry!(get_vc_dir(\"12.0\"));\n+        let mut tool = otry!(get_tool(tool, &vcdir, target));\n+        let sub = otry!(lib_subdir(target));\n+        let sdk81 = otry!(get_sdk81_dir());\n+        tool.path.push(sdk81.join(\"bin\").join(sub));\n+        let sdk_lib = sdk81.join(\"lib\").join(\"winv6.3\");\n+        tool.libs.push(sdk_lib.join(\"um\").join(sub));\n+        let sdk_include = sdk81.join(\"include\");\n+        tool.include.push(sdk_include.join(\"shared\"));\n+        tool.include.push(sdk_include.join(\"um\"));\n+        tool.include.push(sdk_include.join(\"winrt\"));\n+        Some(tool.into_tool())\n+    }\n+\n+    // For MSVC 11 we need to find the Windows 8 SDK.\n+    fn find_msvc_11(tool: &str, target: &str) -> Option<Tool> {\n+        let vcdir = otry!(get_vc_dir(\"11.0\"));\n+        let mut tool = otry!(get_tool(tool, &vcdir, target));\n+        let sub = otry!(lib_subdir(target));\n+        let sdk8 = otry!(get_sdk8_dir());\n+        tool.path.push(sdk8.join(\"bin\").join(sub));\n+        let sdk_lib = sdk8.join(\"lib\").join(\"win8\");\n+        tool.libs.push(sdk_lib.join(\"um\").join(sub));\n+        let sdk_include = sdk8.join(\"include\");\n+        tool.include.push(sdk_include.join(\"shared\"));\n+        tool.include.push(sdk_include.join(\"um\"));\n+        tool.include.push(sdk_include.join(\"winrt\"));\n+        Some(tool.into_tool())\n+    }\n+\n+    fn add_env(tool: &mut Tool, env: &str, paths: Vec<PathBuf>) {\n+        let prev = env::var_os(env).unwrap_or(OsString::new());\n+        let prev = env::split_paths(&prev);\n+        let new = paths.into_iter().chain(prev);\n+        tool.env.push((env.to_string().into(), env::join_paths(new).unwrap()));\n+    }\n+\n+    // Given a possible MSVC installation directory, we look for the linker and\n+    // then add the MSVC library path.\n+    fn get_tool(tool: &str, path: &Path, target: &str) -> Option<MsvcTool> {\n+        bin_subdir(target).into_iter().map(|(sub, host)| {\n+            (path.join(\"bin\").join(sub).join(tool),\n+             path.join(\"bin\").join(host))\n+        }).filter(|&(ref path, _)| {\n+            path.is_file()\n+        }).map(|(path, host)| {\n+            let mut tool = MsvcTool::new(path);\n+            tool.path.push(host);\n+            tool\n+        }).filter_map(|mut tool| {\n+            let sub = otry!(vc_lib_subdir(target));\n+            tool.libs.push(path.join(\"lib\").join(sub));\n+            tool.include.push(path.join(\"include\"));\n+            Some(tool)\n+        }).next()\n+    }\n+\n+    // To find MSVC we look in a specific registry key for the version we are\n+    // trying to find.\n+    fn get_vc_dir(ver: &str) -> Option<PathBuf> {\n+        let key = r\"SOFTWARE\\Microsoft\\VisualStudio\\SxS\\VC7\";\n+        let key = otry!(LOCAL_MACHINE.open(key.as_ref()).ok());\n+        let path = otry!(key.query_str(ver).ok());\n+        Some(path.into())\n+    }\n+\n+    // To find the Universal CRT we look in a specific registry key for where\n+    // all the Universal CRTs are located and then sort them asciibetically to\n+    // find the newest version. While this sort of sorting isn't ideal,  it is\n+    // what vcvars does so that's good enough for us.\n+    //\n+    // Returns a pair of (root, version) for the ucrt dir if found\n+    fn get_ucrt_dir() -> Option<(PathBuf, String)> {\n+        let key = r\"SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\";\n+        let key = otry!(LOCAL_MACHINE.open(key.as_ref()).ok());\n+        let root = otry!(key.query_str(\"KitsRoot10\").ok());\n+        let readdir = otry!(Path::new(&root).join(\"lib\").read_dir().ok());\n+        let max_libdir = otry!(readdir.filter_map(|dir| {\n+            dir.ok()\n+        }).map(|dir| {\n+            dir.path()\n+        }).filter(|dir| {\n+            dir.components().last().and_then(|c| {\n+                c.as_os_str().to_str()\n+            }).map(|c| {\n+                c.starts_with(\"10.\") && dir.join(\"ucrt\").is_dir()\n+            }).unwrap_or(false)\n+        }).max());\n+        let version = max_libdir.components().last().unwrap();\n+        let version = version.as_os_str().to_str().unwrap().to_string();\n+        Some((root.into(), version))\n+    }\n+\n+    // Vcvars finds the correct version of the Windows 10 SDK by looking\n+    // for the include `um\\Windows.h` because sometimes a given version will\n+    // only have UCRT bits without the rest of the SDK. Since we only care about\n+    // libraries and not includes, we instead look for `um\\x64\\kernel32.lib`.\n+    // Since the 32-bit and 64-bit libraries are always installed together we\n+    // only need to bother checking x64, making this code a tiny bit simpler.\n+    // Like we do for the Universal CRT, we sort the possibilities\n+    // asciibetically to find the newest one as that is what vcvars does.\n+    fn get_sdk10_dir() -> Option<(PathBuf, String)> {\n+        let key = r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0\";\n+        let key = otry!(LOCAL_MACHINE.open(key.as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        let readdir = otry!(Path::new(&root).join(\"lib\").read_dir().ok());\n+        let mut dirs = readdir.filter_map(|dir| dir.ok())\n+                              .map(|dir| dir.path())\n+                              .collect::<Vec<_>>();\n+        dirs.sort();\n+        let dir = otry!(dirs.into_iter().rev().filter(|dir| {\n+            dir.join(\"um\").join(\"x64\").join(\"kernel32.lib\").is_file()\n+        }).next());\n+        let version = dir.components().last().unwrap();\n+        let version = version.as_os_str().to_str().unwrap().to_string();\n+        Some((root.into(), version))\n+    }\n+\n+    // Interestingly there are several subdirectories, `win7` `win8` and\n+    // `winv6.3`. Vcvars seems to only care about `winv6.3` though, so the same\n+    // applies to us. Note that if we were targetting kernel mode drivers\n+    // instead of user mode applications, we would care.\n+    fn get_sdk81_dir() -> Option<PathBuf> {\n+        let key = r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.1\";\n+        let key = otry!(LOCAL_MACHINE.open(key.as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        Some(root.into())\n+    }\n+\n+    fn get_sdk8_dir() -> Option<PathBuf> {\n+        let key = r\"SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v8.0\";\n+        let key = otry!(LOCAL_MACHINE.open(key.as_ref()).ok());\n+        let root = otry!(key.query_str(\"InstallationFolder\").ok());\n+        Some(root.into())\n+    }\n+\n+    const PROCESSOR_ARCHITECTURE_INTEL: u16 = 0;\n+    const PROCESSOR_ARCHITECTURE_AMD64: u16 = 9;\n+    const X86: u16 = PROCESSOR_ARCHITECTURE_INTEL;\n+    const X86_64: u16 = PROCESSOR_ARCHITECTURE_AMD64;\n+\n+    // When choosing the tool to use, we have to choose the one which matches\n+    // the target architecture. Otherwise we end up in situations where someone\n+    // on 32-bit Windows is trying to cross compile to 64-bit and it tries to\n+    // invoke the native 64-bit compiler which won't work.\n+    //\n+    // For the return value of this function, the first member of the tuple is\n+    // the folder of the tool we will be invoking, while the second member is\n+    // the folder of the host toolchain for that tool which is essential when\n+    // using a cross linker. We return a Vec since on x64 there are often two\n+    // linkers that can target the architecture we desire. The 64-bit host\n+    // linker is preferred, and hence first, due to 64-bit allowing it more\n+    // address space to work with and potentially being faster.\n+    fn bin_subdir(target: &str) -> Vec<(&'static str, &'static str)> {\n+        let arch = target.split('-').next().unwrap();\n+        match (arch, host_arch()) {\n+            (\"i586\", X86) |\n+            (\"i686\", X86) => vec![(\"\", \"\")],\n+            (\"i586\", X86_64) |\n+            (\"i686\", X86_64) => vec![(\"amd64_x86\", \"amd64\"), (\"\", \"\")],\n+            (\"x86_64\", X86) => vec![(\"x86_amd64\", \"\")],\n+            (\"x86_64\", X86_64) => vec![(\"amd64\", \"amd64\"), (\"x86_amd64\", \"\")],\n+            (\"arm\", X86) => vec![(\"x86_arm\", \"\")],\n+            (\"arm\", X86_64) => vec![(\"amd64_arm\", \"amd64\"), (\"x86_arm\", \"\")],\n+            _ => vec![],\n+        }\n+    }\n+\n+    fn lib_subdir(target: &str) -> Option<&'static str> {\n+        let arch = target.split('-').next().unwrap();\n+        match arch {\n+            \"i586\" | \"i686\" => Some(\"x86\"),\n+            \"x86_64\" => Some(\"x64\"),\n+            \"arm\" => Some(\"arm\"),\n+            _ => None,\n+        }\n+    }\n+\n+    // MSVC's x86 libraries are not in a subfolder\n+    fn vc_lib_subdir(target: &str) -> Option<&'static str> {\n+        let arch = target.split('-').next().unwrap();\n+        match arch {\n+            \"i586\" | \"i686\" => Some(\"\"),\n+            \"x86_64\" => Some(\"amd64\"),\n+            \"arm\" => Some(\"arm\"),\n+            _ => None,\n+        }\n+    }\n+\n+    #[allow(bad_style)]\n+    fn host_arch() -> u16 {\n+        type DWORD = u32;\n+        type WORD = u16;\n+        type LPVOID = *mut u8;\n+        type DWORD_PTR = usize;\n+\n+        #[repr(C)]\n+        struct SYSTEM_INFO {\n+            wProcessorArchitecture: WORD,\n+            _wReserved: WORD,\n+            _dwPageSize: DWORD,\n+            _lpMinimumApplicationAddress: LPVOID,\n+            _lpMaximumApplicationAddress: LPVOID,\n+            _dwActiveProcessorMask: DWORD_PTR,\n+            _dwNumberOfProcessors: DWORD,\n+            _dwProcessorType: DWORD,\n+            _dwAllocationGranularity: DWORD,\n+            _wProcessorLevel: WORD,\n+            _wProcessorRevision: WORD,\n+        }\n+\n+        extern \"system\" {\n+            fn GetNativeSystemInfo(lpSystemInfo: *mut SYSTEM_INFO);\n+        }\n+\n+        unsafe {\n+            let mut info = mem::zeroed();\n+            GetNativeSystemInfo(&mut info);\n+            info.wProcessorArchitecture\n+        }\n+    }\n+\n+    // Given a registry key, look at all the sub keys and find the one which has\n+    // the maximal numeric value.\n+    //\n+    // Returns the name of the maximal key as well as the opened maximal key.\n+    fn max_version(key: &RegistryKey) -> Option<(OsString, RegistryKey)> {\n+        let mut max_vers = 0;\n+        let mut max_key = None;\n+        for subkey in key.iter().filter_map(|k| k.ok()) {\n+            let val = subkey.to_str().and_then(|s| {\n+                s.trim_left_matches(\"v\").replace(\".\", \"\").parse().ok()\n+            });\n+            let val = match val {\n+                Some(s) => s,\n+                None => continue,\n+            };\n+            if val > max_vers {\n+                if let Ok(k) = key.open(&subkey) {\n+                    max_vers = val;\n+                    max_key = Some((subkey, k));\n+                }\n+            }\n+        }\n+        return max_key\n+    }\n+\n+    // see http://stackoverflow.com/questions/328017/path-to-msbuild\n+    fn find_msbuild(target: &str) -> Option<Tool> {\n+        let key = r\"SOFTWARE\\Microsoft\\MSBuild\\ToolsVersions\";\n+        LOCAL_MACHINE.open(key.as_ref()).ok().and_then(|key| {\n+            max_version(&key).and_then(|(_vers, key)| {\n+                key.query_str(\"MSBuildToolsPath\").ok()\n+            })\n+        }).map(|path| {\n+            let mut path = PathBuf::from(path);\n+            path.push(\"MSBuild.exe\");\n+            let mut tool = Tool::new(path);\n+            if target.contains(\"x86_64\") {\n+                tool.env.push((\"Platform\".into(), \"X64\".into()));\n+            }\n+            tool\n+        })\n+    }\n+}"}, {"sha": "559dbe8ad4e50cf7118bd88b743c79c82d24ceb2", "filename": "src/vendor/gcc/tests/cc_env.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Ftests%2Fcc_env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Ftests%2Fcc_env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Ftests%2Fcc_env.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,49 @@\n+extern crate tempdir;\n+extern crate gcc;\n+\n+use std::env;\n+\n+mod support;\n+use support::Test;\n+\n+#[test]\n+fn main() {\n+    ccache();\n+    distcc();\n+    ccache_spaces();\n+}\n+\n+fn ccache() {\n+    let test = Test::gnu();\n+    test.shim(\"ccache\");\n+\n+    env::set_var(\"CC\", \"ccache lol-this-is-not-a-compiler foo\");\n+    test.gcc().file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0)\n+        .must_have(\"lol-this-is-not-a-compiler foo\")\n+        .must_have(\"foo.c\")\n+        .must_not_have(\"ccache\");\n+}\n+\n+fn ccache_spaces() {\n+    let test = Test::gnu();\n+    test.shim(\"ccache\");\n+\n+    env::set_var(\"CC\", \"ccache        lol-this-is-not-a-compiler foo\");\n+    test.gcc().file(\"foo.c\").compile(\"libfoo.a\");\n+    test.cmd(0).must_have(\"lol-this-is-not-a-compiler foo\");\n+}\n+\n+fn distcc() {\n+    let test = Test::gnu();\n+    test.shim(\"distcc\");\n+\n+    env::set_var(\"CC\", \"distcc lol-this-is-not-a-compiler foo\");\n+    test.gcc().file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0)\n+        .must_have(\"lol-this-is-not-a-compiler foo\")\n+        .must_have(\"foo.c\")\n+        .must_not_have(\"distcc\");\n+}"}, {"sha": "b5703d2fd8b1afab5fcbb7b8cef90db35af444f2", "filename": "src/vendor/gcc/tests/support/mod.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,111 @@\n+#![allow(dead_code)]\n+\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::path::PathBuf;\n+\n+use gcc;\n+use tempdir::TempDir;\n+\n+pub struct Test {\n+    pub td: TempDir,\n+    pub gcc: PathBuf,\n+    pub msvc: bool,\n+}\n+\n+pub struct Execution {\n+    args: Vec<String>,\n+}\n+\n+impl Test {\n+    pub fn new() -> Test {\n+        let mut gcc = PathBuf::from(env::current_exe().unwrap());\n+        gcc.pop();\n+        gcc.push(format!(\"gcc-shim{}\", env::consts::EXE_SUFFIX));\n+        Test {\n+            td: TempDir::new(\"gcc-test\").unwrap(),\n+            gcc: gcc,\n+            msvc: false,\n+        }\n+    }\n+\n+    pub fn gnu() -> Test {\n+        let t = Test::new();\n+        t.shim(\"cc\").shim(\"ar\");\n+        return t\n+    }\n+\n+    pub fn msvc() -> Test {\n+        let mut t = Test::new();\n+        t.shim(\"cl\").shim(\"lib.exe\");\n+        t.msvc = true;\n+        return t\n+    }\n+\n+    pub fn shim(&self, name: &str) -> &Test {\n+        let fname = format!(\"{}{}\", name, env::consts::EXE_SUFFIX);\n+        fs::hard_link(&self.gcc, self.td.path().join(&fname)).or_else(|_| {\n+            fs::copy(&self.gcc, self.td.path().join(&fname)).map(|_| ())\n+        }).unwrap();\n+        self\n+    }\n+\n+    pub fn gcc(&self) -> gcc::Config {\n+        let mut cfg = gcc::Config::new();\n+        let mut path = env::split_paths(&env::var_os(\"PATH\").unwrap())\n+                           .collect::<Vec<_>>();\n+        path.insert(0, self.td.path().to_owned());\n+        let target = if self.msvc {\n+            \"x86_64-pc-windows-msvc\"\n+        } else {\n+            \"x86_64-unknown-linux-gnu\"\n+        };\n+\n+        cfg.target(target).host(target)\n+           .opt_level(2)\n+           .debug(false)\n+           .out_dir(self.td.path())\n+           .__set_env(\"PATH\", env::join_paths(path).unwrap())\n+           .__set_env(\"GCCTEST_OUT_DIR\", self.td.path());\n+        if self.msvc {\n+            cfg.compiler(self.td.path().join(\"cl\"));\n+            cfg.archiver(self.td.path().join(\"lib.exe\"));\n+        }\n+        return cfg\n+    }\n+\n+    pub fn cmd(&self, i: u32) -> Execution {\n+        let mut s = String::new();\n+        File::open(self.td.path().join(format!(\"out{}\", i))).unwrap()\n+             .read_to_string(&mut s).unwrap();\n+        Execution {\n+            args: s.lines().map(|s| s.to_string()).collect(),\n+        }\n+    }\n+}\n+\n+impl Execution {\n+    pub fn must_have<P: AsRef<OsStr>>(&self, p: P) -> &Execution {\n+        if !self.has(p.as_ref()) {\n+            panic!(\"didn't find {:?} in {:?}\", p.as_ref(), self.args);\n+        } else {\n+            self\n+        }\n+    }\n+\n+    pub fn must_not_have<P: AsRef<OsStr>>(&self, p: P) -> &Execution {\n+        if self.has(p.as_ref()) {\n+            panic!(\"found {:?}\", p.as_ref());\n+        } else {\n+            self\n+        }\n+    }\n+\n+    pub fn has(&self, p: &OsStr) -> bool {\n+        self.args.iter().any(|arg| {\n+            OsStr::new(arg) == p\n+        })\n+    }\n+}"}, {"sha": "1b6a0bd0d10a6b92cfc8c68f0dac89724d19ee90", "filename": "src/vendor/gcc/tests/test.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgcc%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Ftests%2Ftest.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,207 @@\n+extern crate gcc;\n+extern crate tempdir;\n+\n+use support::Test;\n+\n+mod support;\n+\n+#[test]\n+fn gnu_smoke() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"-O2\")\n+               .must_have(\"foo.c\")\n+               .must_not_have(\"-g\")\n+               .must_have(\"-c\")\n+               .must_have(\"-ffunction-sections\")\n+               .must_have(\"-fdata-sections\");\n+    test.cmd(1).must_have(test.td.path().join(\"foo.o\"));\n+}\n+\n+#[test]\n+fn gnu_opt_level_1() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .opt_level(1)\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"-O1\")\n+               .must_not_have(\"-O2\");\n+}\n+\n+#[test]\n+fn gnu_opt_level_s() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .opt_level_str(\"s\")\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"-Os\")\n+               .must_not_have(\"-O1\")\n+               .must_not_have(\"-O2\")\n+               .must_not_have(\"-O3\")\n+               .must_not_have(\"-Oz\");\n+}\n+\n+#[test]\n+fn gnu_debug() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .debug(true)\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+    test.cmd(0).must_have(\"-g\");\n+}\n+\n+#[test]\n+fn gnu_x86_64() {\n+    for vendor in &[\"unknown-linux-gnu\", \"apple-darwin\"] {\n+        let target = format!(\"x86_64-{}\", vendor);\n+        let test = Test::gnu();\n+        test.gcc()\n+            .target(&target)\n+            .host(&target)\n+            .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+        test.cmd(0).must_have(\"-fPIC\")\n+                   .must_have(\"-m64\");\n+    }\n+}\n+\n+#[test]\n+fn gnu_x86_64_no_pic() {\n+    for vendor in &[\"unknown-linux-gnu\", \"apple-darwin\"] {\n+        let target = format!(\"x86_64-{}\", vendor);\n+        let test = Test::gnu();\n+        test.gcc()\n+            .pic(false)\n+            .target(&target)\n+            .host(&target)\n+            .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+        test.cmd(0).must_not_have(\"-fPIC\");\n+    }\n+}\n+\n+#[test]\n+fn gnu_i686() {\n+    for vendor in &[\"unknown-linux-gnu\", \"apple-darwin\"] {\n+        let target = format!(\"i686-{}\", vendor);\n+        let test = Test::gnu();\n+        test.gcc()\n+            .target(&target)\n+            .host(&target)\n+            .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+        test.cmd(0).must_not_have(\"-fPIC\")\n+                   .must_have(\"-m32\");\n+    }\n+}\n+\n+#[test]\n+fn gnu_i686_pic() {\n+    for vendor in &[\"unknown-linux-gnu\", \"apple-darwin\"] {\n+        let target = format!(\"i686-{}\", vendor);\n+        let test = Test::gnu();\n+        test.gcc()\n+            .pic(true)\n+            .target(&target)\n+            .host(&target)\n+            .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+        test.cmd(0).must_have(\"-fPIC\");\n+    }\n+}\n+\n+#[test]\n+fn gnu_set_stdlib() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .cpp_set_stdlib(Some(\"foo\"))\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_not_have(\"-stdlib=foo\");\n+}\n+\n+#[test]\n+fn gnu_include() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .include(\"foo/bar\")\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"-I\").must_have(\"foo/bar\");\n+}\n+\n+#[test]\n+fn gnu_define() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .define(\"FOO\", Some(\"bar\"))\n+        .define(\"BAR\", None)\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"-DFOO=bar\").must_have(\"-DBAR\");\n+}\n+\n+#[test]\n+fn gnu_compile_assembly() {\n+    let test = Test::gnu();\n+    test.gcc()\n+        .file(\"foo.S\").compile(\"libfoo.a\");\n+    test.cmd(0).must_have(\"foo.S\");\n+}\n+\n+#[test]\n+fn msvc_smoke() {\n+    let test = Test::msvc();\n+    test.gcc()\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"/O2\")\n+               .must_have(\"foo.c\")\n+               .must_not_have(\"/Z7\")\n+               .must_have(\"/c\");\n+    test.cmd(1).must_have(test.td.path().join(\"foo.o\"));\n+}\n+\n+#[test]\n+fn msvc_opt_level_0() {\n+    let test = Test::msvc();\n+    test.gcc()\n+        .opt_level(0)\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_not_have(\"/O2\");\n+}\n+\n+#[test]\n+fn msvc_debug() {\n+    let test = Test::msvc();\n+    test.gcc()\n+        .debug(true)\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+    test.cmd(0).must_have(\"/Z7\");\n+}\n+\n+#[test]\n+fn msvc_include() {\n+    let test = Test::msvc();\n+    test.gcc()\n+        .include(\"foo/bar\")\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"/I\").must_have(\"foo/bar\");\n+}\n+\n+#[test]\n+fn msvc_define() {\n+    let test = Test::msvc();\n+    test.gcc()\n+        .define(\"FOO\", Some(\"bar\"))\n+        .define(\"BAR\", None)\n+        .file(\"foo.c\").compile(\"libfoo.a\");\n+\n+    test.cmd(0).must_have(\"/DFOO=bar\").must_have(\"/DBAR\");\n+}"}, {"sha": "0c13fda1c11687ac16411b7c6127048076150553", "filename": "src/vendor/getopts/.cargo-checksum.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2F.cargo-checksum.json?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1 @@\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"c1e953ee360e77de57f7b02f1b7880bd6a3dc22d1a69e953c2ac2c52cc52d247\",\".travis.yml\":\"f01015154ac55bebd8ff25742496135c40395959f772005bdf7c63bc9b373c12\",\"Cargo.toml\":\"a027aa6d21622b42c545707ba04f78341cc28079b46da775827ab1ec37fe3ca7\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb\",\"README.md\":\"4002d78e71c4e1fb82c77590eddb999371f40dce037d895f96e6d6df42c728d3\",\"appveyor.yml\":\"da991211b72fa6f231af7adb84c9fb72f5a9131d1c0a3d47b8ceffe5a82c8542\",\"src/lib.rs\":\"9512dd4ec1053c9fc61f630d869053ca50c55e0839e3ab7091246a8654423bf0\",\"tests/smoke.rs\":\"26a95ac42e42b766ae752fe8531fb740fd147d5cdff352dec0763d175ce91806\"},\"package\":\"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/vendor/getopts/.cargo-ok", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.cargo-ok", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.cargo-ok", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2F.cargo-ok?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "4fffb2f89cbd8f2169ce9914bd16bd43785bb368", "filename": "src/vendor/getopts/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2F.gitignore?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,2 @@\n+/target\n+/Cargo.lock"}, {"sha": "d7e3f4787aea5c8eb389baf2cbd216477be4e635", "filename": "src/vendor/getopts/.travis.yml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2F.travis.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,20 @@\n+language: rust\n+rust:\n+  - 1.0.0\n+  - beta\n+  - nightly\n+sudo: false\n+before_script:\n+  - pip install 'travis-cargo<0.2' --user && export PATH=$HOME/.local/bin:$PATH\n+script:\n+  - cargo build --verbose\n+  - cargo test --verbose\n+  - cargo doc --no-deps\n+after_success:\n+  - travis-cargo --only nightly doc-upload\n+env:\n+  global:\n+    secure: by+Jo/boBPbcF5c1N6RNCA008oJm2aRFE5T0SUc3OIfTXxY08dZc0WCBJCHrplp44VjpeKRp/89Y+k1CKncIeU8LiS6ZgsKqaQcCglE2O1KS90B6FYB7+rBqT3ib25taq1nW38clnBHYHV9nz4gOElSdKGRxCcBy+efQ5ZXr2tY=\n+notifications:\n+  email:\n+    on_success: never"}, {"sha": "f84899fe8120ecc0fc719854976a4b4569fd50f1", "filename": "src/vendor/getopts/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+\n+name = \"getopts\"\n+version = \"0.2.14\"\n+authors = [\"The Rust Project Developers\"]\n+license = \"MIT/Apache-2.0\"\n+readme = \"README.md\"\n+repository = \"https://github.com/rust-lang/getopts\"\n+documentation = \"http://doc.rust-lang.org/getopts\"\n+homepage = \"https://github.com/rust-lang/getopts\"\n+description = \"\"\"\n+getopts-like option parsing.\n+\"\"\"\n+\n+[dev-dependencies]\n+log = \"0.3\""}, {"sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1", "filename": "src/vendor/getopts/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2FLICENSE-APACHE?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "39d4bdb5acd313c1a92dbeaa1c379aaf0596a315", "filename": "src/vendor/getopts/LICENSE-MIT", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2FLICENSE-MIT?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2014 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "c19f48fb06b5c65d4e02cad3dee57ae9f9dc5571", "filename": "src/vendor/getopts/README.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2FREADME.md?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,23 @@\n+getopts\n+===\n+\n+A Rust library for option parsing for CLI utilities.\n+\n+[![Build Status](https://travis-ci.org/rust-lang/getopts.svg?branch=master)](https://travis-ci.org/rust-lang/getopts)\n+\n+[Documentation](http://doc.rust-lang.org/getopts)\n+\n+## Usage\n+\n+Add this to your `Cargo.toml`:\n+\n+```toml\n+[dependencies]\n+getopts = \"0.2.4\"\n+```\n+\n+and this to your crate root:\n+\n+```rust\n+extern crate getopts;\n+```"}, {"sha": "6a1b8dc19c0393b9f64e98ca3701755ef39c34de", "filename": "src/vendor/getopts/appveyor.yml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2Fappveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2Fappveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2Fappveyor.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,17 @@\n+environment:\n+  matrix:\n+  - TARGET: x86_64-pc-windows-msvc\n+  - TARGET: i686-pc-windows-msvc\n+  - TARGET: i686-pc-windows-gnu\n+install:\n+  - ps: Start-FileDownload \"https://static.rust-lang.org/dist/rust-nightly-${env:TARGET}.exe\"\n+  - rust-nightly-%TARGET%.exe /VERYSILENT /NORESTART /DIR=\"C:\\Program Files (x86)\\Rust\"\n+  - SET PATH=%PATH%;C:\\Program Files (x86)\\Rust\\bin\n+  - SET PATH=%PATH%;C:\\MinGW\\bin\n+  - rustc -V\n+  - cargo -V\n+\n+build: false\n+\n+test_script:\n+  - cargo test --verbose"}, {"sha": "8f0c866fae90664975e1758cb8f6eec1f243bc95", "filename": "src/vendor/getopts/src/lib.rs", "status": "added", "additions": 1831, "deletions": 0, "changes": 1831, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2Fsrc%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,1831 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15677\n+\n+//! Simple getopt alternative.\n+//!\n+//! Construct a vector of options, either by using `reqopt`, `optopt`, and\n+//! `optflag` or by building them from components yourself, and pass them to\n+//! `getopts`, along with a vector of actual arguments (not including\n+//! `argv[0]`). You'll either get a failure code back, or a match. You'll have\n+//! to verify whether the amount of 'free' arguments in the match is what you\n+//! expect. Use `opt_*` accessors to get argument values out of the matches\n+//! object.\n+//!\n+//! Single-character options are expected to appear on the command line with a\n+//! single preceding dash; multiple-character options are expected to be\n+//! proceeded by two dashes. Options that expect an argument accept their\n+//! argument following either a space or an equals sign. Single-character\n+//! options don't require the space.\n+//!\n+//! # Usage\n+//!\n+//! This crate is [on crates.io](https://crates.io/crates/getopts) and can be\n+//! used by adding `getopts` to the dependencies in your project's `Cargo.toml`.\n+//!\n+//! ```toml\n+//! [dependencies]\n+//! getopts = \"0.2\"\n+//! ```\n+//!\n+//! and this to your crate root:\n+//!\n+//! ```rust\n+//! extern crate getopts;\n+//! ```\n+//!\n+//! # Example\n+//!\n+//! The following example shows simple command line parsing for an application\n+//! that requires an input file to be specified, accepts an optional output file\n+//! name following `-o`, and accepts both `-h` and `--help` as optional flags.\n+//!\n+//! ```{.rust}\n+//! extern crate getopts;\n+//! use getopts::Options;\n+//! use std::env;\n+//!\n+//! fn do_work(inp: &str, out: Option<String>) {\n+//!     println!(\"{}\", inp);\n+//!     match out {\n+//!         Some(x) => println!(\"{}\", x),\n+//!         None => println!(\"No Output\"),\n+//!     }\n+//! }\n+//!\n+//! fn print_usage(program: &str, opts: Options) {\n+//!     let brief = format!(\"Usage: {} FILE [options]\", program);\n+//!     print!(\"{}\", opts.usage(&brief));\n+//! }\n+//!\n+//! fn main() {\n+//!     let args: Vec<String> = env::args().collect();\n+//!     let program = args[0].clone();\n+//!\n+//!     let mut opts = Options::new();\n+//!     opts.optopt(\"o\", \"\", \"set output file name\", \"NAME\");\n+//!     opts.optflag(\"h\", \"help\", \"print this help menu\");\n+//!     let matches = match opts.parse(&args[1..]) {\n+//!         Ok(m) => { m }\n+//!         Err(f) => { panic!(f.to_string()) }\n+//!     };\n+//!     if matches.opt_present(\"h\") {\n+//!         print_usage(&program, opts);\n+//!         return;\n+//!     }\n+//!     let output = matches.opt_str(\"o\");\n+//!     let input = if !matches.free.is_empty() {\n+//!         matches.free[0].clone()\n+//!     } else {\n+//!         print_usage(&program, opts);\n+//!         return;\n+//!     };\n+//!     do_work(&input, output);\n+//! }\n+//! ```\n+\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/getopts/\")]\n+#![deny(missing_docs)]\n+#![cfg_attr(test, deny(warnings))]\n+#![cfg_attr(rust_build, feature(staged_api))]\n+#![cfg_attr(rust_build, staged_api)]\n+#![cfg_attr(rust_build,\n+            unstable(feature = \"rustc_private\",\n+                     reason = \"use the crates.io `getopts` library instead\"))]\n+\n+#[cfg(test)] #[macro_use] extern crate log;\n+\n+use self::Name::*;\n+use self::HasArg::*;\n+use self::Occur::*;\n+use self::Fail::*;\n+use self::Optval::*;\n+use self::SplitWithinState::*;\n+use self::Whitespace::*;\n+use self::LengthLimit::*;\n+\n+use std::error::Error;\n+use std::ffi::OsStr;\n+use std::fmt;\n+use std::iter::{repeat, IntoIterator};\n+use std::result;\n+\n+/// A description of the options that a program can handle.\n+pub struct Options {\n+    grps: Vec<OptGroup>,\n+    parsing_style : ParsingStyle\n+}\n+\n+impl Options {\n+    /// Create a blank set of options.\n+    pub fn new() -> Options {\n+        Options {\n+            grps: Vec::new(),\n+            parsing_style: ParsingStyle::FloatingFrees\n+        }\n+    }\n+\n+    /// Set the parsing style.\n+    pub fn parsing_style(&mut self, style: ParsingStyle) -> &mut Options {\n+        self.parsing_style = style;\n+        self\n+    }\n+\n+    /// Create a generic option group, stating all parameters explicitly.\n+    pub fn opt(&mut self, short_name: &str, long_name: &str, desc: &str,\n+                       hint: &str, hasarg: HasArg, occur: Occur) -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: hint.to_string(),\n+            desc: desc.to_string(),\n+            hasarg: hasarg,\n+            occur: occur\n+        });\n+        self\n+    }\n+\n+    /// Create a long option that is optional and does not take an argument.\n+    ///\n+    /// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+    /// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+    /// * `desc` - Description for usage help\n+    pub fn optflag(&mut self, short_name: &str, long_name: &str, desc: &str)\n+                           -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: \"\".to_string(),\n+            desc: desc.to_string(),\n+            hasarg: No,\n+            occur: Optional\n+        });\n+        self\n+    }\n+\n+    /// Create a long option that can occur more than once and does not\n+    /// take an argument.\n+    ///\n+    /// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+    /// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+    /// * `desc` - Description for usage help\n+    pub fn optflagmulti(&mut self, short_name: &str, long_name: &str, desc: &str)\n+                                -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: \"\".to_string(),\n+            desc: desc.to_string(),\n+            hasarg: No,\n+            occur: Multi\n+        });\n+        self\n+    }\n+\n+    /// Create a long option that is optional and takes an optional argument.\n+    ///\n+    /// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+    /// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+    /// * `desc` - Description for usage help\n+    /// * `hint` - Hint that is used in place of the argument in the usage help,\n+    ///   e.g. `\"FILE\"` for a `-o FILE` option\n+    pub fn optflagopt(&mut self, short_name: &str, long_name: &str, desc: &str,\n+                              hint: &str) -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: hint.to_string(),\n+            desc: desc.to_string(),\n+            hasarg: Maybe,\n+            occur: Optional\n+        });\n+        self\n+    }\n+\n+    /// Create a long option that is optional, takes an argument, and may occur\n+    /// multiple times.\n+    ///\n+    /// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+    /// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+    /// * `desc` - Description for usage help\n+    /// * `hint` - Hint that is used in place of the argument in the usage help,\n+    ///   e.g. `\"FILE\"` for a `-o FILE` option\n+    pub fn optmulti(&mut self, short_name: &str, long_name: &str, desc: &str, hint: &str)\n+                            -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: hint.to_string(),\n+            desc: desc.to_string(),\n+            hasarg: Yes,\n+            occur: Multi\n+        });\n+        self\n+    }\n+\n+    /// Create a long option that is optional and takes an argument.\n+    ///\n+    /// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+    /// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+    /// * `desc` - Description for usage help\n+    /// * `hint` - Hint that is used in place of the argument in the usage help,\n+    ///   e.g. `\"FILE\"` for a `-o FILE` option\n+    pub fn optopt(&mut self, short_name: &str, long_name: &str, desc: &str, hint: &str)\n+                          -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: hint.to_string(),\n+            desc: desc.to_string(),\n+            hasarg: Yes,\n+            occur: Optional\n+        });\n+        self\n+    }\n+\n+    /// Create a long option that is required and takes an argument.\n+    ///\n+    /// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+    /// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+    /// * `desc` - Description for usage help\n+    /// * `hint` - Hint that is used in place of the argument in the usage help,\n+    ///   e.g. `\"FILE\"` for a `-o FILE` option\n+    pub fn reqopt(&mut self, short_name: &str, long_name: &str, desc: &str, hint: &str)\n+                          -> &mut Options {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        self.grps.push(OptGroup {\n+            short_name: short_name.to_string(),\n+            long_name: long_name.to_string(),\n+            hint: hint.to_string(),\n+            desc: desc.to_string(),\n+            hasarg: Yes,\n+            occur: Req\n+        });\n+        self\n+    }\n+\n+    /// Parse command line arguments according to the provided options.\n+    ///\n+    /// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n+    /// `opt_str`, etc. to interrogate results.\n+    /// # Panics\n+    ///\n+    /// Returns `Err(Fail)` on failure: use the `Debug` implementation of `Fail`\n+    /// to display information about it.\n+    pub fn parse<C: IntoIterator>(&self, args: C) -> Result\n+        where C::Item: AsRef<OsStr>\n+    {\n+        let opts: Vec<Opt> = self.grps.iter().map(|x| x.long_to_short()).collect();\n+        let n_opts = opts.len();\n+\n+        fn f(_x: usize) -> Vec<Optval> { return Vec::new(); }\n+\n+        let mut vals = (0 .. n_opts).map(f).collect::<Vec<_>>();\n+        let mut free: Vec<String> = Vec::new();\n+        let args = try!(args.into_iter().map(|i| {\n+            i.as_ref().to_str().ok_or_else(|| {\n+                Fail::UnrecognizedOption(format!(\"{:?}\", i.as_ref()))\n+            }).map(|s| s.to_owned())\n+        }).collect::<::std::result::Result<Vec<_>, _>>());\n+        let l = args.len();\n+        let mut i = 0;\n+        while i < l {\n+            let cur = args[i].clone();\n+            let curlen = cur.len();\n+            if !is_arg(&cur) {\n+                match self.parsing_style {\n+                    ParsingStyle::FloatingFrees => free.push(cur),\n+                    ParsingStyle::StopAtFirstFree => {\n+                        while i < l {\n+                            free.push(args[i].clone());\n+                            i += 1;\n+                        }\n+                        break;\n+                    }\n+                }\n+            } else if cur == \"--\" {\n+                let mut j = i + 1;\n+                while j < l { free.push(args[j].clone()); j += 1; }\n+                break;\n+            } else {\n+                let mut names;\n+                let mut i_arg = None;\n+                if cur.as_bytes()[1] == b'-' {\n+                    let tail = &cur[2..curlen];\n+                    let tail_eq: Vec<&str> = tail.splitn(2, '=').collect();\n+                    if tail_eq.len() <= 1 {\n+                        names = vec!(Long(tail.to_string()));\n+                    } else {\n+                        names =\n+                            vec!(Long(tail_eq[0].to_string()));\n+                        i_arg = Some(tail_eq[1].to_string());\n+                    }\n+                } else {\n+                    names = Vec::new();\n+                    for (j, ch) in cur.char_indices().skip(1) {\n+                        let opt = Short(ch);\n+\n+                        /* In a series of potential options (eg. -aheJ), if we\n+                           see one which takes an argument, we assume all\n+                           subsequent characters make up the argument. This\n+                           allows options such as -L/usr/local/lib/foo to be\n+                           interpreted correctly\n+                        */\n+\n+                        let opt_id = match find_opt(&opts, opt.clone()) {\n+                          Some(id) => id,\n+                          None => return Err(UnrecognizedOption(opt.to_string()))\n+                        };\n+\n+                        names.push(opt);\n+\n+                        let arg_follows = match opts[opt_id].hasarg {\n+                            Yes | Maybe => true,\n+                            No => false\n+                        };\n+\n+                        if arg_follows {\n+                            let next = j + ch.len_utf8();\n+                            if next < curlen {\n+                                i_arg = Some(cur[next..curlen].to_string());\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                let mut name_pos = 0;\n+                for nm in names.iter() {\n+                    name_pos += 1;\n+                    let optid = match find_opt(&opts, (*nm).clone()) {\n+                      Some(id) => id,\n+                      None => return Err(UnrecognizedOption(nm.to_string()))\n+                    };\n+                    match opts[optid].hasarg {\n+                      No => {\n+                        if name_pos == names.len() && !i_arg.is_none() {\n+                            return Err(UnexpectedArgument(nm.to_string()));\n+                        }\n+                        vals[optid].push(Given);\n+                      }\n+                      Maybe => {\n+                        if !i_arg.is_none() {\n+                            vals[optid]\n+                                .push(Val((i_arg.clone())\n+                                .unwrap()));\n+                        } else if name_pos < names.len() || i + 1 == l ||\n+                                is_arg(&args[i + 1]) {\n+                            vals[optid].push(Given);\n+                        } else {\n+                            i += 1;\n+                            vals[optid].push(Val(args[i].clone()));\n+                        }\n+                      }\n+                      Yes => {\n+                        if !i_arg.is_none() {\n+                            vals[optid].push(Val(i_arg.clone().unwrap()));\n+                        } else if i + 1 == l {\n+                            return Err(ArgumentMissing(nm.to_string()));\n+                        } else {\n+                            i += 1;\n+                            vals[optid].push(Val(args[i].clone()));\n+                        }\n+                      }\n+                    }\n+                }\n+            }\n+            i += 1;\n+        }\n+        for i in 0 .. n_opts {\n+            let n = vals[i].len();\n+            let occ = opts[i].occur;\n+            if occ == Req && n == 0 {\n+                return Err(OptionMissing(opts[i].name.to_string()));\n+            }\n+            if occ != Multi && n > 1 {\n+                return Err(OptionDuplicated(opts[i].name.to_string()));\n+            }\n+        }\n+        Ok(Matches {\n+            opts: opts,\n+            vals: vals,\n+            free: free\n+        })\n+    }\n+\n+    /// Derive a short one-line usage summary from a set of long options.\n+    #[allow(deprecated)] // connect => join in 1.3\n+    pub fn short_usage(&self, program_name: &str) -> String {\n+        let mut line = format!(\"Usage: {} \", program_name);\n+        line.push_str(&self.grps.iter()\n+                           .map(format_option)\n+                           .collect::<Vec<String>>()\n+                           .connect(\" \"));\n+        line\n+    }\n+\n+    /// Derive a usage message from a set of options.\n+    #[allow(deprecated)] // connect => join in 1.3\n+    pub fn usage(&self, brief: &str) -> String {\n+        let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n+\n+        let any_short = self.grps.iter().any(|optref| {\n+            optref.short_name.len() > 0\n+        });\n+\n+        let rows = self.grps.iter().map(|optref| {\n+            let OptGroup{short_name,\n+                         long_name,\n+                         hint,\n+                         desc,\n+                         hasarg,\n+                         ..} = (*optref).clone();\n+\n+            let mut row = \"    \".to_string();\n+\n+            // short option\n+            match short_name.len() {\n+                0 => {\n+                    if any_short {\n+                        row.push_str(\"    \");\n+                    }\n+                }\n+                1 => {\n+                    row.push('-');\n+                    row.push_str(&short_name);\n+                    if long_name.len() > 0 {\n+                        row.push_str(\", \");\n+                    } else {\n+                        // Only a single space here, so that any\n+                        // argument is printed in the correct spot.\n+                        row.push(' ');\n+                    }\n+                }\n+                _ => panic!(\"the short name should only be 1 ascii char long\"),\n+            }\n+\n+            // long option\n+            match long_name.len() {\n+                0 => {}\n+                _ => {\n+                    row.push_str(\"--\");\n+                    row.push_str(&long_name);\n+                    row.push(' ');\n+                }\n+            }\n+\n+            // arg\n+            match hasarg {\n+                No => {}\n+                Yes => row.push_str(&hint),\n+                Maybe => {\n+                    row.push('[');\n+                    row.push_str(&hint);\n+                    row.push(']');\n+                }\n+            }\n+\n+            // FIXME: #5516 should be graphemes not codepoints\n+            // here we just need to indent the start of the description\n+            let rowlen = row.chars().count();\n+            if rowlen < 24 {\n+                for _ in 0 .. 24 - rowlen {\n+                    row.push(' ');\n+                }\n+            } else {\n+                row.push_str(&desc_sep)\n+            }\n+\n+            // Normalize desc to contain words separated by one space character\n+            let mut desc_normalized_whitespace = String::new();\n+            for word in desc.split(|c: char| c.is_whitespace())\n+                            .filter(|s| !s.is_empty()) {\n+                desc_normalized_whitespace.push_str(word);\n+                desc_normalized_whitespace.push(' ');\n+            }\n+\n+            // FIXME: #5516 should be graphemes not codepoints\n+            let mut desc_rows = Vec::new();\n+            each_split_within(&desc_normalized_whitespace,\n+                              54,\n+                              |substr| {\n+                desc_rows.push(substr.to_string());\n+                true\n+            });\n+\n+            // FIXME: #5516 should be graphemes not codepoints\n+            // wrapped description\n+            row.push_str(&desc_rows.connect(&desc_sep));\n+\n+            row\n+        });\n+\n+        format!(\"{}\\n\\nOptions:\\n{}\\n\", brief,\n+                rows.collect::<Vec<String>>().connect(\"\\n\"))\n+    }\n+}\n+\n+/// What parsing style to use when parsing arguments.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum ParsingStyle {\n+    /// Flags and \"free\" arguments can be freely inter-mixed.\n+    FloatingFrees,\n+    /// As soon as a \"free\" argument (i.e. non-flag) is encountered, stop\n+    /// considering any remaining arguments as flags.\n+    StopAtFirstFree\n+}\n+\n+/// Name of an option. Either a string or a single char.\n+#[derive(Clone, PartialEq, Eq)]\n+enum Name {\n+    /// A string representing the long name of an option.\n+    /// For example: \"help\"\n+    Long(String),\n+    /// A char representing the short name of an option.\n+    /// For example: 'h'\n+    Short(char),\n+}\n+\n+/// Describes whether an option has an argument.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum HasArg {\n+    /// The option requires an argument.\n+    Yes,\n+    /// The option takes no argument.\n+    No,\n+    /// The option argument is optional.\n+    Maybe,\n+}\n+\n+/// Describes how often an option may occur.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum Occur {\n+    /// The option occurs once.\n+    Req,\n+    /// The option occurs at most once.\n+    Optional,\n+    /// The option occurs zero or more times.\n+    Multi,\n+}\n+\n+/// A description of a possible option.\n+#[derive(Clone, PartialEq, Eq)]\n+struct Opt {\n+    /// Name of the option\n+    name: Name,\n+    /// Whether it has an argument\n+    hasarg: HasArg,\n+    /// How often it can occur\n+    occur: Occur,\n+    /// Which options it aliases\n+    aliases: Vec<Opt>,\n+}\n+\n+/// One group of options, e.g., both `-h` and `--help`, along with\n+/// their shared description and properties.\n+#[derive(Clone, PartialEq, Eq)]\n+struct OptGroup {\n+    /// Short name of the option, e.g. `h` for a `-h` option\n+    short_name: String,\n+    /// Long name of the option, e.g. `help` for a `--help` option\n+    long_name: String,\n+    /// Hint for argument, e.g. `FILE` for a `-o FILE` option\n+    hint: String,\n+    /// Description for usage help text\n+    desc: String,\n+    /// Whether option has an argument\n+    hasarg: HasArg,\n+    /// How often it can occur\n+    occur: Occur\n+}\n+\n+/// Describes whether an option is given at all or has a value.\n+#[derive(Clone, PartialEq, Eq)]\n+enum Optval {\n+    Val(String),\n+    Given,\n+}\n+\n+/// The result of checking command line arguments. Contains a vector\n+/// of matches and a vector of free strings.\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct Matches {\n+    /// Options that matched\n+    opts: Vec<Opt>,\n+    /// Values of the Options that matched\n+    vals: Vec<Vec<Optval>>,\n+    /// Free string fragments\n+    pub free: Vec<String>,\n+}\n+\n+/// The type returned when the command line does not conform to the\n+/// expected format. Use the `Debug` implementation to output detailed\n+/// information.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum Fail {\n+    /// The option requires an argument but none was passed.\n+    ArgumentMissing(String),\n+    /// The passed option is not declared among the possible options.\n+    UnrecognizedOption(String),\n+    /// A required option is not present.\n+    OptionMissing(String),\n+    /// A single occurrence option is being used multiple times.\n+    OptionDuplicated(String),\n+    /// There's an argument being passed to a non-argument option.\n+    UnexpectedArgument(String),\n+}\n+\n+impl Error for Fail {\n+    fn description(&self) -> &str {\n+        match *self {\n+            ArgumentMissing(_) => \"missing argument\",\n+            UnrecognizedOption(_) => \"unrecognized option\",\n+            OptionMissing(_) => \"missing option\",\n+            OptionDuplicated(_) => \"duplicated option\",\n+            UnexpectedArgument(_) => \"unexpected argument\",\n+        }\n+    }\n+}\n+\n+/// The type of failure that occurred.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+#[allow(missing_docs)]\n+pub enum FailType {\n+    ArgumentMissing_,\n+    UnrecognizedOption_,\n+    OptionMissing_,\n+    OptionDuplicated_,\n+    UnexpectedArgument_,\n+}\n+\n+/// The result of parsing a command line with a set of options.\n+pub type Result = result::Result<Matches, Fail>;\n+\n+impl Name {\n+    fn from_str(nm: &str) -> Name {\n+        if nm.len() == 1 {\n+            Short(nm.as_bytes()[0] as char)\n+        } else {\n+            Long(nm.to_string())\n+        }\n+    }\n+\n+    fn to_string(&self) -> String {\n+        match *self {\n+            Short(ch) => ch.to_string(),\n+            Long(ref s) => s.to_string()\n+        }\n+    }\n+}\n+\n+impl OptGroup {\n+    /// Translate OptGroup into Opt.\n+    /// (Both short and long names correspond to different Opts).\n+    fn long_to_short(&self) -> Opt {\n+        let OptGroup {\n+            short_name,\n+            long_name,\n+            hasarg,\n+            occur,\n+            ..\n+        } = (*self).clone();\n+\n+        match (short_name.len(), long_name.len()) {\n+            (0,0) => panic!(\"this long-format option was given no name\"),\n+            (0,_) => Opt {\n+                name: Long((long_name)),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: Vec::new()\n+            },\n+            (1,0) => Opt {\n+                name: Short(short_name.as_bytes()[0] as char),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: Vec::new()\n+            },\n+            (1,_) => Opt {\n+                name: Long((long_name)),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: vec!(\n+                    Opt {\n+                        name: Short(short_name.as_bytes()[0] as char),\n+                        hasarg: hasarg,\n+                        occur:  occur,\n+                        aliases: Vec::new()\n+                    }\n+                )\n+            },\n+            (_,_) => panic!(\"something is wrong with the long-form opt\")\n+        }\n+    }\n+}\n+\n+impl Matches {\n+    fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n+        match find_opt(&self.opts, Name::from_str(nm)) {\n+            Some(id) => self.vals[id].clone(),\n+            None => panic!(\"No option '{}' defined\", nm)\n+        }\n+    }\n+\n+    fn opt_val(&self, nm: &str) -> Option<Optval> {\n+        self.opt_vals(nm).into_iter().next()\n+    }\n+\n+    /// Returns true if an option was matched.\n+    pub fn opt_present(&self, nm: &str) -> bool {\n+        !self.opt_vals(nm).is_empty()\n+    }\n+\n+    /// Returns the number of times an option was matched.\n+    pub fn opt_count(&self, nm: &str) -> usize {\n+        self.opt_vals(nm).len()\n+    }\n+\n+    /// Returns true if any of several options were matched.\n+    pub fn opts_present(&self, names: &[String]) -> bool {\n+        names.iter().any(|nm| {\n+            match find_opt(&self.opts, Name::from_str(&nm)) {\n+                Some(id) if !self.vals[id].is_empty() => true,\n+                _ => false,\n+            }\n+        })\n+    }\n+\n+    /// Returns the string argument supplied to one of several matching options or `None`.\n+    pub fn opts_str(&self, names: &[String]) -> Option<String> {\n+        names.iter().filter_map(|nm| {\n+            match self.opt_val(&nm) {\n+                Some(Val(s)) => Some(s),\n+                _ => None,\n+            }\n+        }).next()\n+    }\n+\n+    /// Returns a vector of the arguments provided to all matches of the given\n+    /// option.\n+    ///\n+    /// Used when an option accepts multiple values.\n+    pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n+        self.opt_vals(nm).into_iter().filter_map(|v| {\n+            match v {\n+                Val(s) => Some(s),\n+                _ => None,\n+            }\n+        }).collect()\n+    }\n+\n+    /// Returns the string argument supplied to a matching option or `None`.\n+    pub fn opt_str(&self, nm: &str) -> Option<String> {\n+        match self.opt_val(nm) {\n+            Some(Val(s)) => Some(s),\n+            _ => None,\n+        }\n+    }\n+\n+\n+    /// Returns the matching string, a default, or `None`.\n+    ///\n+    /// Returns `None` if the option was not present, `def` if the option was\n+    /// present but no argument was provided, and the argument if the option was\n+    /// present and an argument was provided.\n+    pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n+        match self.opt_val(nm) {\n+            Some(Val(s)) => Some(s),\n+            Some(_) => Some(def.to_string()),\n+            None => None,\n+        }\n+    }\n+\n+}\n+\n+fn is_arg(arg: &str) -> bool {\n+    arg.as_bytes().get(0) == Some(&b'-') && arg.len() > 1\n+}\n+\n+fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n+    // Search main options.\n+    let pos = opts.iter().position(|opt| opt.name == nm);\n+    if pos.is_some() {\n+        return pos\n+    }\n+\n+    // Search in aliases.\n+    for candidate in opts.iter() {\n+        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n+            return opts.iter().position(|opt| opt.name == candidate.name);\n+        }\n+    }\n+\n+    None\n+}\n+\n+impl fmt::Display for Fail {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ArgumentMissing(ref nm) => {\n+                write!(f, \"Argument to option '{}' missing.\", *nm)\n+            }\n+            UnrecognizedOption(ref nm) => {\n+                write!(f, \"Unrecognized option: '{}'.\", *nm)\n+            }\n+            OptionMissing(ref nm) => {\n+                write!(f, \"Required option '{}' missing.\", *nm)\n+            }\n+            OptionDuplicated(ref nm) => {\n+                write!(f, \"Option '{}' given more than once.\", *nm)\n+            }\n+            UnexpectedArgument(ref nm) => {\n+                write!(f, \"Option '{}' does not take an argument.\", *nm)\n+            }\n+        }\n+    }\n+}\n+\n+fn format_option(opt: &OptGroup) -> String {\n+    let mut line = String::new();\n+\n+    if opt.occur != Req {\n+        line.push('[');\n+    }\n+\n+    // Use short_name if possible, but fall back to long_name.\n+    if opt.short_name.len() > 0 {\n+        line.push('-');\n+        line.push_str(&opt.short_name);\n+    } else {\n+        line.push_str(\"--\");\n+        line.push_str(&opt.long_name);\n+    }\n+\n+    if opt.hasarg != No {\n+        line.push(' ');\n+        if opt.hasarg == Maybe {\n+            line.push('[');\n+        }\n+        line.push_str(&opt.hint);\n+        if opt.hasarg == Maybe {\n+            line.push(']');\n+        }\n+    }\n+\n+    if opt.occur != Req {\n+        line.push(']');\n+    }\n+    if opt.occur == Multi {\n+        line.push_str(\"..\");\n+    }\n+\n+    line\n+}\n+\n+#[derive(Clone, Copy)]\n+enum SplitWithinState {\n+    A,  // leading whitespace, initial state\n+    B,  // words\n+    C,  // internal and trailing whitespace\n+}\n+\n+#[derive(Clone, Copy)]\n+enum Whitespace {\n+    Ws, // current char is whitespace\n+    Cr  // current char is not whitespace\n+}\n+\n+#[derive(Clone, Copy)]\n+enum LengthLimit {\n+    UnderLim, // current char makes current substring still fit in limit\n+    OverLim   // current char makes current substring no longer fit in limit\n+}\n+\n+\n+/// Splits a string into substrings with possibly internal whitespace,\n+/// each of them at most `lim` bytes long. The substrings have leading and trailing\n+/// whitespace removed, and are only cut at whitespace boundaries.\n+///\n+/// Note: Function was moved here from `std::str` because this module is the only place that\n+/// uses it, and because it was too specific for a general string function.\n+///\n+/// # Panics\n+///\n+/// Panics during iteration if the string contains a non-whitespace\n+/// sequence longer than the limit.\n+fn each_split_within<'a, F>(ss: &'a str, lim: usize, mut it: F)\n+                            -> bool where F: FnMut(&'a str) -> bool {\n+    // Just for fun, let's write this as a state machine:\n+\n+    let mut slice_start = 0;\n+    let mut last_start = 0;\n+    let mut last_end = 0;\n+    let mut state = A;\n+    let mut fake_i = ss.len();\n+    let mut lim = lim;\n+\n+    let mut cont = true;\n+\n+    // if the limit is larger than the string, lower it to save cycles\n+    if lim >= fake_i {\n+        lim = fake_i;\n+    }\n+\n+    let mut machine = |cont: &mut bool, (i, c): (usize, char)| {\n+        let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n+        let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n+\n+        state = match (state, whitespace, limit) {\n+            (A, Ws, _)        => { A }\n+            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n+\n+            (B, Cr, UnderLim) => { B }\n+            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n+                            => panic!(\"word starting with {} longer than limit!\",\n+                                      &ss[last_start..i + 1]),\n+            (B, Cr, OverLim)  => {\n+                *cont = it(&ss[slice_start..last_end]);\n+                slice_start = last_start;\n+                B\n+            }\n+            (B, Ws, UnderLim) => {\n+                last_end = i;\n+                C\n+            }\n+            (B, Ws, OverLim)  => {\n+                last_end = i;\n+                *cont = it(&ss[slice_start..last_end]);\n+                A\n+            }\n+\n+            (C, Cr, UnderLim) => {\n+                last_start = i;\n+                B\n+            }\n+            (C, Cr, OverLim)  => {\n+                *cont = it(&ss[slice_start..last_end]);\n+                slice_start = i;\n+                last_start = i;\n+                last_end = i;\n+                B\n+            }\n+            (C, Ws, OverLim)  => {\n+                *cont = it(&ss[slice_start..last_end]);\n+                A\n+            }\n+            (C, Ws, UnderLim) => {\n+                C\n+            }\n+        };\n+\n+        *cont\n+    };\n+\n+    ss.char_indices().all(|x| machine(&mut cont, x));\n+\n+    // Let the automaton 'run out' by supplying trailing whitespace\n+    while cont && match state { B | C => true, A => false } {\n+        machine(&mut cont, (fake_i, ' '));\n+        fake_i += 1;\n+    }\n+    return cont;\n+}\n+\n+#[test]\n+fn test_split_within() {\n+    fn t(s: &str, i: usize, u: &[String]) {\n+        let mut v = Vec::new();\n+        each_split_within(s, i, |s| { v.push(s.to_string()); true });\n+        assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n+    }\n+    t(\"\", 0, &[]);\n+    t(\"\", 15, &[]);\n+    t(\"hello\", 15, &[\"hello\".to_string()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, &[\n+        \"Mary had a\".to_string(),\n+        \"little lamb\".to_string(),\n+        \"Little lamb\".to_string()\n+    ]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::usize::MAX,\n+        &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{HasArg, Name, Occur, Opt, Options, ParsingStyle};\n+    use super::Fail::*;\n+\n+    // Tests for reqopt\n+    #[test]\n+    fn test_reqopt() {\n+        let long_args = vec!(\"--test=20\".to_string());\n+        let mut opts = Options::new();\n+        opts.reqopt(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+            assert!(m.opt_present(\"t\"));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+          }\n+          _ => { panic!(\"test_reqopt failed (long arg)\"); }\n+        }\n+        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        match opts.parse(&short_args) {\n+          Ok(ref m) => {\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+          }\n+          _ => { panic!(\"test_reqopt failed (short arg)\"); }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_missing() {\n+        let args = vec!(\"blah\".to_string());\n+        match Options::new()\n+                      .reqopt(\"t\", \"test\", \"testing\", \"TEST\")\n+                      .parse(&args) {\n+          Err(OptionMissing(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_no_arg() {\n+        let long_args = vec!(\"--test\".to_string());\n+        let mut opts = Options::new();\n+        opts.reqopt(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Err(ArgumentMissing(_)) => {},\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string());\n+        match opts.parse(&short_args) {\n+          Err(ArgumentMissing(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_multi() {\n+        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n+        match Options::new()\n+                      .reqopt(\"t\", \"test\", \"testing\", \"TEST\")\n+                      .parse(&args) {\n+          Err(OptionDuplicated(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    // Tests for optopt\n+    #[test]\n+    fn test_optopt() {\n+        let long_args = vec!(\"--test=20\".to_string());\n+        let mut opts = Options::new();\n+        opts.optopt(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+          }\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        match opts.parse(&short_args) {\n+          Ok(ref m) => {\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_missing() {\n+        let args = vec!(\"blah\".to_string());\n+        match Options::new()\n+                      .optopt(\"t\", \"test\", \"testing\", \"TEST\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_no_arg() {\n+        let long_args = vec!(\"--test\".to_string());\n+        let mut opts = Options::new();\n+        opts.optopt(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Err(ArgumentMissing(_)) => {},\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string());\n+        match opts.parse(&short_args) {\n+          Err(ArgumentMissing(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_multi() {\n+        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n+        match Options::new()\n+                      .optopt(\"t\", \"test\", \"testing\", \"TEST\")\n+                      .parse(&args) {\n+          Err(OptionDuplicated(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    // Tests for optflag\n+    #[test]\n+    fn test_optflag() {\n+        let long_args = vec!(\"--test\".to_string());\n+        let mut opts = Options::new();\n+        opts.optflag(\"t\", \"test\", \"testing\");\n+        match opts.parse(&long_args) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert!(m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string());\n+        match opts.parse(&short_args) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert!(m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_missing() {\n+        let args = vec!(\"blah\".to_string());\n+        match Options::new()\n+                      .optflag(\"t\", \"test\", \"testing\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_long_arg() {\n+        let args = vec!(\"--test=20\".to_string());\n+        match Options::new()\n+                      .optflag(\"t\", \"test\", \"testing\")\n+                      .parse(&args) {\n+          Err(UnexpectedArgument(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_multi() {\n+        let args = vec!(\"--test\".to_string(), \"-t\".to_string());\n+        match Options::new()\n+                      .optflag(\"t\", \"test\", \"testing\")\n+                      .parse(&args) {\n+          Err(OptionDuplicated(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_short_arg() {\n+        let args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        match Options::new()\n+                      .optflag(\"t\", \"test\", \"testing\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            // The next variable after the flag is just a free argument\n+\n+            assert!(m.free[0] == \"20\");\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    // Tests for optflagmulti\n+    #[test]\n+    fn test_optflagmulti_short1() {\n+        let args = vec!(\"-v\".to_string());\n+        match Options::new()\n+                      .optflagmulti(\"v\", \"verbose\", \"verbosity\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert_eq!(m.opt_count(\"v\"), 1);\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflagmulti_short2a() {\n+        let args = vec!(\"-v\".to_string(), \"-v\".to_string());\n+        match Options::new()\n+                      .optflagmulti(\"v\", \"verbose\", \"verbosity\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert_eq!(m.opt_count(\"v\"), 2);\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflagmulti_short2b() {\n+        let args = vec!(\"-vv\".to_string());\n+        match Options::new()\n+                      .optflagmulti(\"v\", \"verbose\", \"verbosity\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert_eq!(m.opt_count(\"v\"), 2);\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflagmulti_long1() {\n+        let args = vec!(\"--verbose\".to_string());\n+        match Options::new()\n+                      .optflagmulti(\"v\", \"verbose\", \"verbosity\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert_eq!(m.opt_count(\"verbose\"), 1);\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflagmulti_long2() {\n+        let args = vec!(\"--verbose\".to_string(), \"--verbose\".to_string());\n+        match Options::new()\n+                      .optflagmulti(\"v\", \"verbose\", \"verbosity\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert_eq!(m.opt_count(\"verbose\"), 2);\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflagmulti_mix() {\n+        let args = vec!(\"--verbose\".to_string(), \"-v\".to_string(),\n+                        \"-vv\".to_string(), \"verbose\".to_string());\n+        match Options::new()\n+                      .optflagmulti(\"v\", \"verbose\", \"verbosity\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert_eq!(m.opt_count(\"verbose\"), 4);\n+            assert_eq!(m.opt_count(\"v\"), 4);\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    // Tests for optflagopt\n+    #[test]\n+    fn test_optflagopt() {\n+        let long_args = vec!(\"--test\".to_string());\n+        let mut opts = Options::new();\n+        opts.optflag(\"t\", \"test\", \"testing\");\n+        match opts.parse(&long_args) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert!(m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string());\n+        match opts.parse(&short_args) {\n+          Ok(ref m) => {\n+            assert!(m.opt_present(\"test\"));\n+            assert!(m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+        let no_args: Vec<String> = vec!();\n+        match opts.parse(&no_args) {\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    // Tests for optmulti\n+    #[test]\n+    fn test_optmulti() {\n+        let long_args = vec!(\"--test=20\".to_string());\n+        let mut opts = Options::new();\n+        opts.optmulti(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Ok(ref m) => {\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+          }\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        match opts.parse(&short_args) {\n+          Ok(ref m) => {\n+            assert!((m.opt_present(\"test\")));\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+            assert!((m.opt_present(\"t\")));\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_missing() {\n+        let args = vec!(\"blah\".to_string());\n+        match Options::new()\n+                      .optmulti(\"t\", \"test\", \"testing\", \"TEST\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert!(!m.opt_present(\"test\"));\n+            assert!(!m.opt_present(\"t\"));\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_no_arg() {\n+        let long_args = vec!(\"--test\".to_string());\n+        let mut opts = Options::new();\n+        opts.optmulti(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Err(ArgumentMissing(_)) => {},\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-t\".to_string());\n+        match opts.parse(&short_args) {\n+          Err(ArgumentMissing(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_multi() {\n+        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n+        match Options::new()\n+                      .optmulti(\"t\", \"test\", \"testing\", \"TEST\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+              assert!(m.opt_present(\"test\"));\n+              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+              assert!(m.opt_present(\"t\"));\n+              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+              let pair = m.opt_strs(\"test\");\n+              assert!(pair[0] == \"20\");\n+              assert!(pair[1] == \"30\");\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_free_argument_is_hyphen() {\n+        let args = vec!(\"-\".to_string());\n+        match Options::new().parse(&args) {\n+            Ok(ref m) => {\n+                assert_eq!(m.free.len(), 1);\n+                assert_eq!(m.free[0], \"-\");\n+            }\n+            _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unrecognized_option() {\n+        let long_args = vec!(\"--untest\".to_string());\n+        let mut opts = Options::new();\n+        opts.optmulti(\"t\", \"test\", \"testing\", \"TEST\");\n+        match opts.parse(&long_args) {\n+          Err(UnrecognizedOption(_)) => {},\n+          _ => panic!()\n+        }\n+        let short_args = vec!(\"-u\".to_string());\n+        match opts.parse(&short_args) {\n+          Err(UnrecognizedOption(_)) => {},\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_combined() {\n+        let args =\n+            vec!(\"prog\".to_string(),\n+                 \"free1\".to_string(),\n+                 \"-s\".to_string(),\n+                 \"20\".to_string(),\n+                 \"free2\".to_string(),\n+                 \"--flag\".to_string(),\n+                 \"--long=30\".to_string(),\n+                 \"-f\".to_string(),\n+                 \"-m\".to_string(),\n+                 \"40\".to_string(),\n+                 \"-m\".to_string(),\n+                 \"50\".to_string(),\n+                 \"-n\".to_string(),\n+                 \"-A B\".to_string(),\n+                 \"-n\".to_string(),\n+                 \"-60 70\".to_string());\n+        match Options::new()\n+                      .optopt(\"s\", \"something\", \"something\", \"SOMETHING\")\n+                      .optflag(\"\", \"flag\", \"a flag\")\n+                      .reqopt(\"\", \"long\", \"hi\", \"LONG\")\n+                      .optflag(\"f\", \"\", \"another flag\")\n+                      .optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\")\n+                      .optmulti(\"n\", \"\", \"nothing\", \"NOTHING\")\n+                      .optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")\n+                      .parse(&args) {\n+          Ok(ref m) => {\n+            assert!(m.free[0] == \"prog\");\n+            assert!(m.free[1] == \"free1\");\n+            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n+            assert!(m.free[2] == \"free2\");\n+            assert!((m.opt_present(\"flag\")));\n+            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n+            assert!((m.opt_present(\"f\")));\n+            let pair = m.opt_strs(\"m\");\n+            assert!(pair[0] == \"40\");\n+            assert!(pair[1] == \"50\");\n+            let pair = m.opt_strs(\"n\");\n+            assert!(pair[0] == \"-A B\");\n+            assert!(pair[1] == \"-60 70\");\n+            assert!((!m.opt_present(\"notpresent\")));\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mixed_stop() {\n+        let args =\n+            vec!(\"-a\".to_string(),\n+                 \"b\".to_string(),\n+                 \"-c\".to_string(),\n+                 \"d\".to_string());\n+        match Options::new()\n+              .parsing_style(ParsingStyle::StopAtFirstFree)\n+              .optflag(\"a\", \"\", \"\")\n+              .optopt(\"c\", \"\", \"\", \"\")\n+              .parse(&args) {\n+          Ok(ref m) => {\n+            println!(\"{}\", m.opt_present(\"c\"));\n+            assert!(m.opt_present(\"a\"));\n+            assert!(!m.opt_present(\"c\"));\n+            assert_eq!(m.free.len(), 3);\n+            assert_eq!(m.free[0], \"b\");\n+            assert_eq!(m.free[1], \"-c\");\n+            assert_eq!(m.free[2], \"d\");\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mixed_stop_hyphen() {\n+        let args =\n+            vec!(\"-a\".to_string(),\n+                 \"-\".to_string(),\n+                 \"-c\".to_string(),\n+                 \"d\".to_string());\n+        match Options::new()\n+              .parsing_style(ParsingStyle::StopAtFirstFree)\n+              .optflag(\"a\", \"\", \"\")\n+              .optopt(\"c\", \"\", \"\", \"\")\n+              .parse(&args) {\n+          Ok(ref m) => {\n+            println!(\"{}\", m.opt_present(\"c\"));\n+            assert!(m.opt_present(\"a\"));\n+            assert!(!m.opt_present(\"c\"));\n+            assert_eq!(m.free.len(), 3);\n+            assert_eq!(m.free[0], \"-\");\n+            assert_eq!(m.free[1], \"-c\");\n+            assert_eq!(m.free[2], \"d\");\n+          }\n+          _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_multi() {\n+        let mut opts = Options::new();\n+        opts.optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\");\n+        opts.optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\");\n+        opts.optopt(\"f\", \"\", \"flag\", \"FLAG\");\n+\n+        let args_single = vec!(\"-e\".to_string(), \"foo\".to_string());\n+        let matches_single = &match opts.parse(&args_single) {\n+          Ok(m) => m,\n+          Err(_) => panic!()\n+        };\n+        assert!(matches_single.opts_present(&[\"e\".to_string()]));\n+        assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n+        assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n+        assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n+        assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n+        assert!(!matches_single.opts_present(&[]));\n+\n+        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n+        assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n+                   \"foo\");\n+        assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n+                   \"foo\");\n+\n+        let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n+                             \"foo\".to_string());\n+        let matches_both = &match opts.parse(&args_both) {\n+          Ok(m) => m,\n+          Err(_) => panic!()\n+        };\n+        assert!(matches_both.opts_present(&[\"e\".to_string()]));\n+        assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n+        assert!(matches_both.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n+        assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n+        assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n+        assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n+        assert!(!matches_both.opts_present(&[]));\n+\n+        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\");\n+        assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n+                   \"foo\");\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n+                   \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_nospace() {\n+        let args = vec!(\"-Lfoo\".to_string(), \"-M.\".to_string());\n+        let matches = &match Options::new()\n+                                     .optmulti(\"L\", \"\", \"library directory\", \"LIB\")\n+                                     .optmulti(\"M\", \"\", \"something\", \"MMMM\")\n+                                     .parse(&args) {\n+          Ok(m) => m,\n+          Err(_) => panic!()\n+        };\n+        assert!(matches.opts_present(&[\"L\".to_string()]));\n+        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n+        assert!(matches.opts_present(&[\"M\".to_string()]));\n+        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\");\n+\n+    }\n+\n+    #[test]\n+    fn test_nospace_conflict() {\n+        let args = vec!(\"-vvLverbose\".to_string(), \"-v\".to_string() );\n+        let matches = &match Options::new()\n+                                     .optmulti(\"L\", \"\", \"library directory\", \"LIB\")\n+                                     .optflagmulti(\"v\", \"verbose\", \"Verbose\")\n+                                     .parse(&args) {\n+          Ok(m) => m,\n+          Err(e) => panic!( \"{}\", e )\n+        };\n+        assert!(matches.opts_present(&[\"L\".to_string()]));\n+        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n+        assert!(matches.opts_present(&[\"v\".to_string()]));\n+        assert_eq!(3, matches.opt_count(\"v\"));\n+    }\n+\n+    #[test]\n+    fn test_long_to_short() {\n+        let mut short = Opt {\n+            name: Name::Long(\"banana\".to_string()),\n+            hasarg: HasArg::Yes,\n+            occur: Occur::Req,\n+            aliases: Vec::new(),\n+        };\n+        short.aliases = vec!(Opt { name: Name::Short('b'),\n+                                hasarg: HasArg::Yes,\n+                                occur: Occur::Req,\n+                                aliases: Vec::new() });\n+        let mut opts = Options::new();\n+        opts.reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n+        let ref verbose = opts.grps[0];\n+        assert!(verbose.long_to_short() == short);\n+    }\n+\n+    #[test]\n+    fn test_aliases_long_and_short() {\n+        let args = vec!(\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string());\n+\n+        let matches = Options::new()\n+                              .optflagmulti(\"a\", \"apple\", \"Desc\")\n+                              .parse(&args)\n+                              .unwrap();\n+        assert_eq!(3, matches.opt_count(\"a\"));\n+        assert_eq!(3, matches.opt_count(\"apple\"));\n+    }\n+\n+    #[test]\n+    fn test_usage() {\n+        let mut opts = Options::new();\n+        opts.reqopt(\"b\", \"banana\", \"Desc\", \"VAL\");\n+        opts.optopt(\"a\", \"012345678901234567890123456789\",\n+                             \"Desc\", \"VAL\");\n+        opts.optflag(\"k\", \"kiwi\", \"Desc\");\n+        opts.optflagopt(\"p\", \"\", \"Desc\", \"VAL\");\n+        opts.optmulti(\"l\", \"\", \"Desc\", \"VAL\");\n+        opts.optflag(\"\", \"starfruit\", \"Starfruit\");\n+\n+        let expected =\n+\"Usage: fruits\n+\n+Options:\n+    -b, --banana VAL    Desc\n+    -a, --012345678901234567890123456789 VAL\n+                        Desc\n+    -k, --kiwi          Desc\n+    -p [VAL]            Desc\n+    -l VAL              Desc\n+        --starfruit     Starfruit\n+\";\n+\n+        let generated_usage = opts.usage(\"Usage: fruits\");\n+\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", generated_usage);\n+        assert_eq!(generated_usage, expected);\n+    }\n+\n+    #[test]\n+    fn test_usage_description_wrapping() {\n+        // indentation should be 24 spaces\n+        // lines wrap after 78: or rather descriptions wrap after 54\n+\n+        let mut opts = Options::new();\n+        opts.optflag(\"k\", \"kiwi\",\n+            \"This is a long description which won't be wrapped..+..\"); // 54\n+        opts.optflag(\"a\", \"apple\",\n+            \"This is a long description which _will_ be wrapped..+..\");\n+\n+        let expected =\n+\"Usage: fruits\n+\n+Options:\n+    -k, --kiwi          This is a long description which won't be wrapped..+..\n+    -a, --apple         This is a long description which _will_ be\n+                        wrapped..+..\n+\";\n+\n+        let usage = opts.usage(\"Usage: fruits\");\n+\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", usage);\n+        assert!(usage == expected)\n+    }\n+\n+    #[test]\n+    fn test_usage_description_multibyte_handling() {\n+        let mut opts = Options::new();\n+        opts.optflag(\"k\", \"k\\u{2013}w\\u{2013}\",\n+            \"The word kiwi is normally spelled with two i's\");\n+        opts.optflag(\"a\", \"apple\",\n+            \"This \\u{201C}description\\u{201D} has some characters that could \\\n+confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\");\n+\n+        let expected =\n+\"Usage: fruits\n+\n+Options:\n+    -k, --k\u2013w\u2013          The word kiwi is normally spelled with two i's\n+    -a, --apple         This \u201cdescription\u201d has some characters that could\n+                        confuse the line wrapping; an apple costs 0.51\u20ac in\n+                        some parts of Europe.\n+\";\n+\n+        let usage = opts.usage(\"Usage: fruits\");\n+\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", usage);\n+        assert!(usage == expected)\n+    }\n+\n+    #[test]\n+    fn test_usage_short_only() {\n+        let mut opts = Options::new();\n+        opts.optopt(\"k\", \"\", \"Kiwi\", \"VAL\");\n+        opts.optflag(\"s\", \"\", \"Starfruit\");\n+        opts.optflagopt(\"a\", \"\", \"Apple\", \"TYPE\");\n+\n+        let expected =\n+\"Usage: fruits\n+\n+Options:\n+    -k VAL              Kiwi\n+    -s                  Starfruit\n+    -a [TYPE]           Apple\n+\";\n+\n+        let usage = opts.usage(\"Usage: fruits\");\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", usage);\n+        assert!(usage == expected)\n+    }\n+\n+    #[test]\n+    fn test_usage_long_only() {\n+        let mut opts = Options::new();\n+        opts.optopt(\"\", \"kiwi\", \"Kiwi\", \"VAL\");\n+        opts.optflag(\"\", \"starfruit\", \"Starfruit\");\n+        opts.optflagopt(\"\", \"apple\", \"Apple\", \"TYPE\");\n+\n+        let expected =\n+\"Usage: fruits\n+\n+Options:\n+    --kiwi VAL          Kiwi\n+    --starfruit         Starfruit\n+    --apple [TYPE]      Apple\n+\";\n+\n+        let usage = opts.usage(\"Usage: fruits\");\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", usage);\n+        assert!(usage == expected)\n+    }\n+\n+    #[test]\n+    fn test_short_usage() {\n+        let mut opts = Options::new();\n+        opts.reqopt(\"b\", \"banana\", \"Desc\", \"VAL\");\n+        opts.optopt(\"a\", \"012345678901234567890123456789\",\n+                     \"Desc\", \"VAL\");\n+        opts.optflag(\"k\", \"kiwi\", \"Desc\");\n+        opts.optflagopt(\"p\", \"\", \"Desc\", \"VAL\");\n+        opts.optmulti(\"l\", \"\", \"Desc\", \"VAL\");\n+\n+        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n+        let generated_usage = opts.short_usage(\"fruits\");\n+\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", generated_usage);\n+        assert_eq!(generated_usage, expected);\n+    }\n+\n+    #[test]\n+    fn test_args_with_equals() {\n+        let mut opts = Options::new();\n+        opts.optopt(\"o\", \"one\", \"One\", \"INFO\");\n+        opts.optopt(\"t\", \"two\", \"Two\", \"INFO\");\n+\n+        let args = vec!(\"--one\".to_string(), \"A=B\".to_string(),\n+                        \"--two=C=D\".to_string());\n+        let matches = &match opts.parse(&args) {\n+            Ok(m) => m,\n+            Err(e) => panic!(\"{}\", e)\n+        };\n+        assert_eq!(matches.opts_str(&[\"o\".to_string()]).unwrap(), \"A=B\");\n+        assert_eq!(matches.opts_str(&[\"t\".to_string()]).unwrap(), \"C=D\");\n+    }\n+}"}, {"sha": "a46f9c0167ab307f66515911b3b5ae246b38a61a", "filename": "src/vendor/getopts/tests/smoke.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2Ftests%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Fgetopts%2Ftests%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgetopts%2Ftests%2Fsmoke.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,8 @@\n+extern crate getopts;\n+\n+use std::env;\n+\n+#[test]\n+fn main() {\n+    getopts::Options::new().parse(env::args()).unwrap();\n+}"}, {"sha": "56c0bb8d2559c0b1f93761f405551e035fb92cb0", "filename": "src/vendor/libc/.cargo-checksum.json", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2F.cargo-checksum.json?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1 @@\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"7150ee9391a955b2ef7e0762fc61c0c1aab167620ca36d88d78062d93b8334ba\",\".travis.yml\":\"ca5e05b688a8c9a3215de3b38f22f4b468f73d26738a80bd939af503ddb222e1\",\"Cargo.toml\":\"4b1f0d59b5fb939877a639d1d4cac5a12440c6e2d366edf2abcb45c46e3dcd3e\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"6485b8ed310d3f0340bf1ad1f47645069ce4069dcc6bb46c7d5c6faf41de1fdb\",\"README.md\":\"c1f46480074340f17f1c3ea989b28e6b632b9d324e57792293a60399b90bfda0\",\"appveyor.yml\":\"c0d70c650b6231e6ff78a352224f1a522a9be69d9da4251adbaddb3f0393294d\",\"ci/README.md\":\"be804f15e2128e5fd4b160cb0b13cff5f19e7d77b55ec5254aa6fd8731c84f0d\",\"ci/docker/aarch64-unknown-linux-gnu/Dockerfile\":\"62ca7317439f9c303990e897450a91cd467be05eb75dfc01456d417932ac8672\",\"ci/docker/arm-linux-androideabi/Dockerfile\":\"c3d60f2ba389e60e59cb6973542751c66a0e7bd484e11589c8ee7346e9ff2bab\",\"ci/docker/arm-unknown-linux-gnueabihf/Dockerfile\":\"e349f7caa463adbde8d6ec4d2b9f7720ed81c77f48d75bbfb78c89751f55c2dc\",\"ci/docker/i686-unknown-linux-gnu/Dockerfile\":\"07e9df6ba91025cbec7ae81ade63f8cfb8a54c5e1e5a8f8def0617e17bd59db0\",\"ci/docker/i686-unknown-linux-musl/Dockerfile\":\"1a4d064adff4a8f58773305567cfe5d915bcd0762bcb0e101cf6f4ca628a96da\",\"ci/docker/mips-unknown-linux-gnu/Dockerfile\":\"860299d96ee50ebdbd788e65eb6ba1f561ef66107647bddffcb2567ac350896b\",\"ci/docker/mips-unknown-linux-musl/Dockerfile\":\"b5917a15c0998adb79ebfdb8aff9ab0e5c4098c4bd5ca78e90ee05859dcfbda3\",\"ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile\":\"163776e0fd38f66df7415421202ac29efc7d345a628947434e573c3885594ab5\",\"ci/docker/mipsel-unknown-linux-musl/Dockerfile\":\"b2dd4c26890c1070228df9694adde8fdb1fe78d7d5a71a8cb5c1b54835f93c46\",\"ci/docker/powerpc-unknown-linux-gnu/Dockerfile\":\"08b846a338c2ee70100f4e80db812668dc58bfb536c44a95cd1cf004d965186b\",\"ci/docker/powerpc64-unknown-linux-gnu/Dockerfile\":\"4da285ffd035d16f5da9e3701841eb86049c8cfa417fa81e53da4ef74152eac0\",\"ci/docker/x86_64-rumprun-netbsd/Dockerfile\":\"44c3107fb30380785aaed6ff73fa334017a5bb4e3b5c7d4876154f09023a2b99\",\"ci/docker/x86_64-unknown-freebsd/Dockerfile\":\"56fce89ceb70792be9005425f3e896361f5ba8a0553db659da87daced93f9785\",\"ci/docker/x86_64-unknown-linux-gnu/Dockerfile\":\"67fabbc8c6ac02376cf9344251ad49ecdac396b71accb572fd1ae65225325bc0\",\"ci/docker/x86_64-unknown-linux-musl/Dockerfile\":\"f71019fed5204b950843ef5e56144161fda7e27fad68ed0e8bc4353c388c7bcf\",\"ci/docker/x86_64-unknown-openbsd/Dockerfile\":\"4a5583797a613056d87f6ae0b1d7a3d3a55552efa7c30e1e0aa67e34d69b4d9c\",\"ci/dox.sh\":\"2161cb17ee0d6a2279a64149c6b7c73a5b2eab344f248ea1fa0e6c8f6335ec5f\",\"ci/landing-page-footer.html\":\"b70b3112c2147f5c967e7481061ef38bc2d79a28dd55a16fb916d9c9426da2c4\",\"ci/landing-page-head.html\":\"ad69663fac7924f27d0209bc519d55838e86edfc4133713a6fd08caadac1b142\",\"ci/run-docker.sh\":\"325648a92ff4d74f18fdf3d190a5cd483306ed2a98479c0742ca7284acd6b948\",\"ci/run-qemu.sh\":\"bb859421170871ef23a8940c5e150efec0c01b95e32d2ce2d37b79a45d9d346c\",\"ci/run.sh\":\"3bb839c2d28986c6915b8f11ed820ff6c62e755fb96bd921a18899ee5f7efd32\",\"ci/style.rs\":\"60564abc1d5197ed1598426dd0d6ee9939a16d2875b03373538f58843bb616c4\",\"src/dox.rs\":\"eb6fbcc0b8b59430271bb71ee023961fd165337fc5fd6ca433882457a3c735bd\",\"src/lib.rs\":\"4cece0e880ec8731913e5110b58d1b134148b0a43e72d6b990c1d999916fc706\",\"src/macros.rs\":\"bd9802772b0e5c8b3c550d1c24307f06c0d1e4ce656b4ae1cf092142bbe5412c\",\"src/unix/bsd/apple/b32.rs\":\"110ecff78da0e8d405d861447904da403d8b3f6da1f0f9dc9987633f3f04fe46\",\"src/unix/bsd/apple/b64.rs\":\"e6808081c0b276cca3189628716f507c7c0d00b62417cd44addbdaefe848cec7\",\"src/unix/bsd/apple/mod.rs\":\"6691f81221d455b882d68d1102de049d5b9729bb4b59050c1d62c835dcaddafb\",\"src/unix/bsd/freebsdlike/dragonfly/mod.rs\":\"d87f02c64649ce63367d9f0e39de7213bd30366bbd5e497f7d88f0dc3c319294\",\"src/unix/bsd/freebsdlike/freebsd/mod.rs\":\"0a675c4b7f54b410547e10e433503487eb1e738394ab81cac82112a96d275bdc\",\"src/unix/bsd/freebsdlike/freebsd/x86.rs\":\"54311d3ebf2bb091ab22361e377e6ef9224aec2ecfe459fbfcedde4932db9c58\",\"src/unix/bsd/freebsdlike/freebsd/x86_64.rs\":\"c7f46b9ae23fde5a9e245a28ed1380066e67f081323b4d253a18e9da3b97b860\",\"src/unix/bsd/freebsdlike/mod.rs\":\"574f7a1368058fad551cdebea4f576fe672f9bbe95a85468c91f9ff5661908c3\",\"src/unix/bsd/mod.rs\":\"bd422d4bca87a3e8ea4bd78b9ae019643399807d036913f42fdd7476f260297d\",\"src/unix/bsd/netbsdlike/mod.rs\":\"7b62b89c6ba0d5a8e0cf0937587a81e0314f9c5dabb0c9a9164106b677cf4dd8\",\"src/unix/bsd/netbsdlike/netbsd/mod.rs\":\"d62a02a78275ed705b2080cae452eb8954ef0f66ac9acb0f44c819d453904c5c\",\"src/unix/bsd/netbsdlike/netbsd/other/b32/mod.rs\":\"bd251a102bed65d5cb3459275f6ec3310fe5803ff4c9651212115548f86256d0\",\"src/unix/bsd/netbsdlike/netbsd/other/b64/mod.rs\":\"927eeccaf3269d299db4c2a55f8010807bf43dfa894aea6a783215f5d3560baa\",\"src/unix/bsd/netbsdlike/netbsd/other/mod.rs\":\"8ce39030f3e4fb45a3d676ade97da8f6d1b3d5f6d8d141224d341c993c57e090\",\"src/unix/bsd/netbsdlike/openbsdlike/bitrig.rs\":\"f8cd05dacd3a3136c58da5a2fbe26f703767823b28e74fe8a2b57a7bd98d6d5c\",\"src/unix/bsd/netbsdlike/openbsdlike/mod.rs\":\"769647209be7b8fc5b7e5c1970f16d5cf9cc3fba04bb456c9584f19a5c406e08\",\"src/unix/bsd/netbsdlike/openbsdlike/openbsd.rs\":\"b1b9cf7be9f0e4d294a57092594074ad03a65fe0eeac9d1104fa874c313e7900\",\"src/unix/haiku/b32.rs\":\"bd251a102bed65d5cb3459275f6ec3310fe5803ff4c9651212115548f86256d0\",\"src/unix/haiku/b64.rs\":\"b422430c550c0ba833c9206d1350861e344e3a2eb33d7d58693efb35044be1cc\",\"src/unix/haiku/mod.rs\":\"d14c45d536f24cd9cd8d5170b9829026da4c782ff2d5855644cc217553e309cf\",\"src/unix/mod.rs\":\"82952d405742b8b21bfbc29648115b3909d9c64422ad04fb6aca443c16ddaa99\",\"src/unix/notbsd/android/b32.rs\":\"148e1b4ed8b4f700d5aa24178af925164176e1c18b54db877ced4b55ba9f03d4\",\"src/unix/notbsd/android/b64.rs\":\"302caf0aa95fa022030717c58de17d85d814b04350eca081a722ec435bc4f217\",\"src/unix/notbsd/android/mod.rs\":\"f7c0145110a406c5cb14243dc71b98af8971674aa7620e5f55dabfa5c8b344c8\",\"src/unix/notbsd/linux/mips.rs\":\"7736e565499b04560bc7e6f8636fd39c74f4a588c671ece931d27de8ca263963\",\"src/unix/notbsd/linux/mips64.rs\":\"f269d516e0f5203fbfd18ff6b22ff33f206be1584d9df03c35743f5e80127d8b\",\"src/unix/notbsd/linux/mod.rs\":\"81dbebd7dd798dc57e5b5b84cec69af2b6027a415262f4ad07b8c609ad2c95ee\",\"src/unix/notbsd/linux/musl/b32/arm.rs\":\"a8416bc6e36460f3c60e2f7730dad7c43466790d11214441ef227ffb05ea450f\",\"src/unix/notbsd/linux/musl/b32/asmjs.rs\":\"c660c5eef21a5f7580e9258eb44881014d2aeba5928af431dfc782b6c4393f33\",\"src/unix/notbsd/linux/musl/b32/mips.rs\":\"76d835acd06c7bcd07a293a6f141b715ac88b959b633df9af3610e8d6eeb1ab4\",\"src/unix/notbsd/linux/musl/b32/mod.rs\":\"bd29a02c67b69791e7cabd7666503c35ed5322d244a005b9cc7fd0cb28b552a8\",\"src/unix/notbsd/linux/musl/b32/x86.rs\":\"da2e557a6afa9d15649d8862a5d17032597c924cd8bb290105500905fe975133\",\"src/unix/notbsd/linux/musl/b64/aarch64.rs\":\"4009c7eaf703472daef2a70bdac910d9fc395a33689ef2e8cf1c4e692445d3f0\",\"src/unix/notbsd/linux/musl/b64/mod.rs\":\"20f34e48124d8ca2a08cc0d28353b310238d37a345dfa0d58993e2e930a1ae23\",\"src/unix/notbsd/linux/musl/b64/powerpc64.rs\":\"dc28f5b7284235d6cf5519053cac59a1c16dc39223b71cca0871e4880755f852\",\"src/unix/notbsd/linux/musl/b64/x86_64.rs\":\"43291acc0dfc92c2fec8ba6ce77ee9ca3c20bcdccec18e149f95ba911cee704b\",\"src/unix/notbsd/linux/musl/mod.rs\":\"c195e04167d26f82885f9157e32a28caccfd4eabe807af683708f33e28562021\",\"src/unix/notbsd/linux/other/b32/arm.rs\":\"f5cb989075fa3b5f997e7101495532c8d5c9f3577412d4c07e4c8c1a16f7b43c\",\"src/unix/notbsd/linux/other/b32/mod.rs\":\"8b774feb5510b963ed031db7ab3d7e24f1ba5524a6396db0b851d237ccc16fd3\",\"src/unix/notbsd/linux/other/b32/powerpc.rs\":\"3b62052bb9741afa5349098e6e9c675b60e822e41fed6b5e1b694be1872097b1\",\"src/unix/notbsd/linux/other/b32/x86.rs\":\"1eda37736f5966c7968b594f74f5018f56b6b8c67bbdeb31fc3db1b6e4ac31b4\",\"src/unix/notbsd/linux/other/b64/aarch64.rs\":\"a978e82d037a9c8127b2f704323864aff42ac910e721ecc69c255671ca96b950\",\"src/unix/notbsd/linux/other/b64/mod.rs\":\"efb7740c2fb925ea98977a6a3ff52bc0b72205c1f88a9ba281a939b66b7f0efe\",\"src/unix/notbsd/linux/other/b64/powerpc64.rs\":\"06a795bca8e91a0143ef1787b034201ed7a21d01960ce9fe869d18c274d5bdb4\",\"src/unix/notbsd/linux/other/b64/x86_64.rs\":\"0ed128e93f212c0d65660bd95e29190a2dae7c9d15d6fa0d3c4c6656f89e9bdc\",\"src/unix/notbsd/linux/other/mod.rs\":\"0f7b29425273101ce90a9565637e5f7f61905db2a1e8f5360b285c73b1287da1\",\"src/unix/notbsd/linux/s390x.rs\":\"6eddef139e18191bc3894f759ca8bd83c59b547bc572ad8938dc61fb5a97d2e9\",\"src/unix/notbsd/mod.rs\":\"6ba17e2e9a6d05d4470ba595fd38dc55f70fea874a46425a4733ae52d93ee8ff\",\"src/unix/solaris/mod.rs\":\"6d1f023b637467fe26385d23b32219dbb4573ea177d159e32dad75e4a6ff95de\",\"src/windows.rs\":\"08f351462388566dcdc6566fb183a467942db63a1caa1bc97f85284fb7a74063\"},\"package\":\"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"}\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/vendor/libc/.cargo-ok", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.cargo-ok", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.cargo-ok", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2F.cargo-ok?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "f0ff2599d09b56baf64cb3af4906408f5212e00e", "filename": "src/vendor/libc/.gitignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2F.gitignore?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,3 @@\n+target\n+Cargo.lock\n+*~"}, {"sha": "703329b70572757115337c633e3d72b952d90843", "filename": "src/vendor/libc/.travis.yml", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2F.travis.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,125 @@\n+language: rust\n+sudo: required\n+dist: trusty\n+services:\n+  - docker\n+install:\n+  - curl https://static.rust-lang.org/rustup.sh |\n+    sh -s -- --add-target=$TARGET --disable-sudo -y --prefix=`rustc --print sysroot`\n+script:\n+  - cargo build\n+  - cargo build --no-default-features\n+  - cargo generate-lockfile --manifest-path libc-test/Cargo.toml\n+  - if [[ $TRAVIS_OS_NAME = \"linux\" ]]; then\n+      sh ci/run-docker.sh $TARGET;\n+    else\n+      export CARGO_TARGET_DIR=`pwd`/target;\n+      sh ci/run.sh $TARGET;\n+    fi\n+  - rustc ci/style.rs && ./style src\n+osx_image: xcode7.3\n+env:\n+  global:\n+    secure: eIDEoQdTyglcsTD13zSGotAX2HDhRSXIaaTnVZTThqLSrySOc3/6KY3qmOc2Msf7XaBqfFy9QA+alk7OwfePp253eiy1Kced67ffjjFOytEcRT7FlQiYpcYQD6WNHZEj62/bJBO4LTM9sGtWNCTJVEDKW0WM8mUK7qNuC+honPM=\n+matrix:\n+  include:\n+    # 1.0.0 compat\n+    - os: linux\n+      env: TARGET=x86_64-unknown-linux-gnu\n+      rust: 1.0.0\n+      script: cargo build\n+      install:\n+\n+    # build documentation\n+    - os: linux\n+      env: TARGET=x86_64-unknown-linux-gnu\n+      rust: stable\n+      script: sh ci/dox.sh\n+\n+    # stable compat\n+    - os: linux\n+      env: TARGET=x86_64-unknown-linux-gnu\n+      rust: stable\n+    - os: linux\n+      env: TARGET=i686-unknown-linux-gnu\n+      rust: stable\n+    - os: osx\n+      env: TARGET=x86_64-apple-darwin\n+      rust: stable\n+    - os: osx\n+      env: TARGET=i686-apple-darwin\n+      rust: stable\n+    - os: linux\n+      env: TARGET=arm-linux-androideabi\n+      rust: stable\n+    - os: linux\n+      env: TARGET=x86_64-unknown-linux-musl\n+      rust: stable\n+    - os: linux\n+      env: TARGET=i686-unknown-linux-musl\n+      rust: stable\n+    - os: linux\n+      env: TARGET=arm-unknown-linux-gnueabihf\n+      rust: stable\n+    - os: linux\n+      env: TARGET=aarch64-unknown-linux-gnu\n+      rust: stable\n+    - os: osx\n+      env: TARGET=i386-apple-ios\n+      rust: stable\n+    - os: osx\n+      env: TARGET=x86_64-apple-ios\n+      rust: stable\n+    - os: linux\n+      env: TARGET=x86_64-rumprun-netbsd\n+      rust: stable\n+    - os: linux\n+      env: TARGET=powerpc-unknown-linux-gnu\n+      rust: stable\n+    - os: linux\n+      env: TARGET=powerpc64-unknown-linux-gnu\n+      rust: stable\n+    - os: linux\n+      env: TARGET=mips-unknown-linux-musl\n+      rust: stable\n+    - os: linux\n+      env: TARGET=mipsel-unknown-linux-musl\n+      rust: stable\n+    - os: linux\n+      env: TARGET=mips64-unknown-linux-gnuabi64\n+      rust: nightly\n+\n+    # beta\n+    - os: linux\n+      env: TARGET=x86_64-unknown-linux-gnu\n+      rust: beta\n+    - os: osx\n+      env: TARGET=x86_64-apple-darwin\n+      rust: beta\n+\n+    # nightly\n+    - os: linux\n+      env: TARGET=x86_64-unknown-linux-gnu\n+      rust: nightly\n+    - os: osx\n+      env: TARGET=x86_64-apple-darwin\n+      rust: nightly\n+    - os: linux\n+      env: TARGET=mips-unknown-linux-gnu\n+      # not sure why this has to be nightly...\n+      rust: nightly\n+\n+    # QEMU based targets that compile in an emulator\n+    - os: linux\n+      env: TARGET=x86_64-unknown-freebsd\n+      rust: stable\n+    - os: linux\n+      env: TARGET=x86_64-unknown-openbsd QEMU=openbsd.qcow2\n+      rust: stable\n+      script: sh ci/run-docker.sh $TARGET\n+      install:\n+\n+notifications:\n+  email:\n+    on_success: never\n+  webhooks: https://buildbot.rust-lang.org/homu/travis"}, {"sha": "c08ab3aab9da44fae578fef235f9d9e690319e2f", "filename": "src/vendor/libc/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2FCargo.toml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,21 @@\n+[package]\n+\n+name = \"libc\"\n+version = \"0.2.17\"\n+authors = [\"The Rust Project Developers\"]\n+license = \"MIT/Apache-2.0\"\n+readme = \"README.md\"\n+repository = \"https://github.com/rust-lang/libc\"\n+homepage = \"https://github.com/rust-lang/libc\"\n+documentation = \"http://doc.rust-lang.org/libc\"\n+description = \"\"\"\n+A library for types and bindings to native C functions often found in libc or\n+other common platform libraries.\n+\"\"\"\n+\n+[features]\n+default = [\"use_std\"]\n+use_std = []\n+\n+[workspace]\n+members = [\"libc-test\", \"libc-test/generate-files\"]"}, {"sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1", "filename": "src/vendor/libc/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2FLICENSE-APACHE?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "39d4bdb5acd313c1a92dbeaa1c379aaf0596a315", "filename": "src/vendor/libc/LICENSE-MIT", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2FLICENSE-MIT?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2014 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "5ea812320f05f112b0c9e8823a2326fe4559a05e", "filename": "src/vendor/libc/README.md", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2FREADME.md?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,137 @@\n+libc\n+====\n+\n+A Rust library with native bindings to the types and functions commonly found on\n+various systems, including libc.\n+\n+[![Build Status](https://travis-ci.org/rust-lang/libc.svg?branch=master)](https://travis-ci.org/rust-lang/libc)\n+[![Build status](https://ci.appveyor.com/api/projects/status/34csq3uurnw7c0rl?svg=true)](https://ci.appveyor.com/project/alexcrichton/libc)\n+\n+[Documentation](#platforms-and-documentation)\n+\n+## Usage\n+\n+First, add the following to your `Cargo.toml`:\n+\n+```toml\n+[dependencies]\n+libc = \"0.2\"\n+```\n+\n+Next, add this to your crate root:\n+\n+```rust\n+extern crate libc;\n+```\n+\n+Currently libc by default links to the standard library, but if you would\n+instead like to use libc in a `#![no_std]` situation or crate you can request\n+this via:\n+\n+```toml\n+[dependencies]\n+libc = { version = \"0.2\", default-features = false }\n+```\n+\n+## What is libc?\n+\n+The primary purpose of this crate is to provide all of the definitions necessary\n+to easily interoperate with C code (or \"C-like\" code) on each of the platforms\n+that Rust supports. This includes type definitions (e.g. `c_int`), constants\n+(e.g. `EINVAL`) as well as function headers (e.g. `malloc`).\n+\n+This crate does not strive to have any form of compatibility across platforms,\n+but rather it is simply a straight binding to the system libraries on the\n+platform in question.\n+\n+## Public API\n+\n+This crate exports all underlying platform types, functions, and constants under\n+the crate root, so all items are accessible as `libc::foo`. The types and values\n+of all the exported APIs match the platform that libc is compiled for.\n+\n+More detailed information about the design of this library can be found in its\n+[associated RFC][rfc].\n+\n+[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1291-promote-libc.md\n+\n+## Adding an API\n+\n+Want to use an API which currently isn't bound in `libc`? It's quite easy to add\n+one!\n+\n+The internal structure of this crate is designed to minimize the number of\n+`#[cfg]` attributes in order to easily be able to add new items which apply\n+to all platforms in the future. As a result, the crate is organized\n+hierarchically based on platform. Each module has a number of `#[cfg]`'d\n+children, but only one is ever actually compiled. Each module then reexports all\n+the contents of its children.\n+\n+This means that for each platform that libc supports, the path from a\n+leaf module to the root will contain all bindings for the platform in question.\n+Consequently, this indicates where an API should be added! Adding an API at a\n+particular level in the hierarchy means that it is supported on all the child\n+platforms of that level. For example, when adding a Unix API it should be added\n+to `src/unix/mod.rs`, but when adding a Linux-only API it should be added to\n+`src/unix/notbsd/linux/mod.rs`.\n+\n+If you're not 100% sure at what level of the hierarchy an API should be added\n+at, fear not! This crate has CI support which tests any binding against all\n+platforms supported, so you'll see failures if an API is added at the wrong\n+level or has different signatures across platforms.\n+\n+With that in mind, the steps for adding a new API are:\n+\n+1. Determine where in the module hierarchy your API should be added.\n+2. Add the API.\n+3. Send a PR to this repo.\n+4. Wait for CI to pass, fixing errors.\n+5. Wait for a merge!\n+\n+### Test before you commit\n+\n+We have two automated tests running on [Travis](https://travis-ci.org/rust-lang/libc):\n+\n+1. [`libc-test`](https://github.com/alexcrichton/ctest)\n+  - `cd libc-test && cargo run`\n+  - Use the `skip_*()` functions in `build.rs` if you really need a workaround.\n+2. Style checker\n+  - `rustc ci/style.rs && ./style src`\n+\n+## Platforms and Documentation\n+\n+The following platforms are currently tested and have documentation available:\n+\n+Tested:\n+  * [`i686-pc-windows-msvc`](https://doc.rust-lang.org/libc/i686-pc-windows-msvc/libc/)\n+  * [`x86_64-pc-windows-msvc`](https://doc.rust-lang.org/libc/x86_64-pc-windows-msvc/libc/)\n+    (Windows)\n+  * [`i686-pc-windows-gnu`](https://doc.rust-lang.org/libc/i686-pc-windows-gnu/libc/)\n+  * [`x86_64-pc-windows-gnu`](https://doc.rust-lang.org/libc/x86_64-pc-windows-gnu/libc/)\n+  * [`i686-apple-darwin`](https://doc.rust-lang.org/libc/i686-apple-darwin/libc/)\n+  * [`x86_64-apple-darwin`](https://doc.rust-lang.org/libc/x86_64-apple-darwin/libc/)\n+    (OSX)\n+  * `i686-apple-ios`\n+  * `x86_64-apple-ios`\n+  * [`i686-unknown-linux-gnu`](https://doc.rust-lang.org/libc/i686-unknown-linux-gnu/libc/)\n+  * [`x86_64-unknown-linux-gnu`](https://doc.rust-lang.org/libc/x86_64-unknown-linux-gnu/libc/)\n+    (Linux)\n+  * [`x86_64-unknown-linux-musl`](https://doc.rust-lang.org/libc/x86_64-unknown-linux-musl/libc/)\n+    (Linux MUSL)\n+  * [`aarch64-unknown-linux-gnu`](https://doc.rust-lang.org/libc/aarch64-unknown-linux-gnu/libc/)\n+  * [`mips-unknown-linux-gnu`](https://doc.rust-lang.org/libc/mips-unknown-linux-gnu/libc/)\n+  * [`arm-unknown-linux-gnueabihf`](https://doc.rust-lang.org/libc/arm-unknown-linux-gnueabihf/libc/)\n+  * [`arm-linux-androideabi`](https://doc.rust-lang.org/libc/arm-linux-androideabi/libc/)\n+    (Android)\n+  * [`x86_64-unknown-freebsd`](https://doc.rust-lang.org/libc/x86_64-unknown-freebsd/libc/)\n+  * [`x86_64-unknown-openbsd`](https://doc.rust-lang.org/libc/x86_64-unknown-openbsd/libc/)\n+  * [`x86_64-rumprun-netbsd`](https://doc.rust-lang.org/libc/x86_64-unknown-netbsd/libc/)\n+\n+The following may be supported, but are not guaranteed to always work:\n+\n+  * `i686-unknown-freebsd`\n+  * [`x86_64-unknown-bitrig`](https://doc.rust-lang.org/libc/x86_64-unknown-bitrig/libc/)\n+  * [`x86_64-unknown-dragonfly`](https://doc.rust-lang.org/libc/x86_64-unknown-dragonfly/libc/)\n+  * `i686-unknown-haiku`\n+  * `x86_64-unknown-haiku`\n+  * [`x86_64-unknown-netbsd`](https://doc.rust-lang.org/libc/x86_64-unknown-netbsd/libc/)"}, {"sha": "a851bb87b6c3b116e1ed16ec318ac779014a1aff", "filename": "src/vendor/libc/appveyor.yml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fappveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fappveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fappveyor.yml?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,25 @@\n+environment:\n+  matrix:\n+  - TARGET: x86_64-pc-windows-gnu\n+    MSYS2_BITS: 64\n+  - TARGET: i686-pc-windows-gnu\n+    MSYS2_BITS: 32\n+  - TARGET: x86_64-pc-windows-msvc\n+  - TARGET: i686-pc-windows-msvc\n+install:\n+  - curl -sSf -o rustup-init.exe https://win.rustup.rs/\n+  - rustup-init.exe -y --default-host %TARGET%\n+  - set PATH=%PATH%;C:\\Users\\appveyor\\.cargo\\bin\n+  - if defined MSYS2_BITS set PATH=%PATH%;C:\\msys64\\mingw%MSYS2_BITS%\\bin\n+  - rustc -V\n+  - cargo -V\n+\n+build: false\n+\n+test_script:\n+  - cargo test --target %TARGET%\n+  - cargo run --manifest-path libc-test/Cargo.toml --target %TARGET%\n+\n+cache:\n+  - target\n+  - C:\\Users\\appveyor\\.cargo\\registry"}, {"sha": "13c7c8da52fc5d622a4ec1249a985f46e6309c9c", "filename": "src/vendor/libc/ci/README.md", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2FREADME.md?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,203 @@\n+The goal of the libc crate is to have CI running everywhere to have the\n+strongest guarantees about the definitions that this library contains, and as a\n+result the CI is pretty complicated and also pretty large! Hopefully this can\n+serve as a guide through the sea of scripts in this directory and elsewhere in\n+this project.\n+\n+# Files\n+\n+First up, let's talk about the files in this directory:\n+\n+* `run-travis.sh` - a shell script run by all Travis builders, this is\n+  responsible for setting up the rest of the environment such as installing new\n+  packages, downloading Rust target libraries, etc.\n+\n+* `run.sh` - the actual script which runs tests for a particular architecture.\n+  Called from the `run-travis.sh` script this will run all tests for the target\n+  specified.\n+\n+* `cargo-config` - Cargo configuration of linkers to use copied into place by\n+  the `run-travis.sh` script before builds are run.\n+\n+* `dox.sh` - script called from `run-travis.sh` on only the linux 64-bit nightly\n+  Travis bots to build documentation for this crate.\n+\n+* `landing-page-*.html` - used by `dox.sh` to generate a landing page for all\n+  architectures' documentation.\n+\n+* `run-qemu.sh` - see discussion about QEMU below\n+\n+* `mips`, `rumprun` - instructions to build the docker image for each respective\n+  CI target\n+\n+# CI Systems\n+\n+Currently this repository leverages a combination of Travis CI and AppVeyor for\n+running tests. The triples tested are:\n+\n+* AppVeyor\n+  * `{i686,x86_64}-pc-windows-{msvc,gnu}`\n+* Travis\n+  * `{i686,x86_64,mips,aarch64}-unknown-linux-gnu`\n+  * `x86_64-unknown-linux-musl`\n+  * `arm-unknown-linux-gnueabihf`\n+  * `arm-linux-androideabi`\n+  * `{i686,x86_64}-apple-{darwin,ios}`\n+  * `x86_64-rumprun-netbsd`\n+  * `x86_64-unknown-freebsd`\n+  * `x86_64-unknown-openbsd`\n+\n+The Windows triples are all pretty standard, they just set up their environment\n+then run tests, no need for downloading any extra target libs (we just download\n+the right installer). The Intel Linux/OSX builds are similar in that we just\n+download the right target libs and run tests. Note that the Intel Linux/OSX\n+builds are run on stable/beta/nightly, but are the only ones that do so.\n+\n+The remaining architectures look like:\n+\n+* Android runs in a [docker image][android-docker] with an emulator, the NDK,\n+  and the SDK already set up. The entire build happens within the docker image.\n+* The MIPS, ARM, and AArch64 builds all use the QEMU userspace emulator to run\n+  the generated binary to actually verify the tests pass.\n+* The MUSL build just has to download a MUSL compiler and target libraries and\n+  then otherwise runs tests normally.\n+* iOS builds need an extra linker flag currently, but beyond that they're built\n+  as standard as everything else.\n+* The rumprun target builds an entire kernel from the test suite and then runs\n+  it inside QEMU using the serial console to test whether it succeeded or\n+  failed.\n+* The BSD builds, currently OpenBSD and FreeBSD, use QEMU to boot up a system\n+  and compile/run tests. More information on that below.\n+\n+[android-docker]: https://github.com/rust-lang/rust-buildbot/blob/master/slaves/android/Dockerfile\n+\n+## QEMU\n+\n+Lots of the architectures tested here use QEMU in the tests, so it's worth going\n+over all the crazy capabilities QEMU has and the various flavors in which we use\n+it!\n+\n+First up, QEMU has userspace emulation where it doesn't boot a full kernel, it\n+just runs a binary from another architecture (using the `qemu-<arch>` wrappers).\n+We provide it the runtime path for the dynamically loaded system libraries,\n+however. This strategy is used for all Linux architectures that aren't intel.\n+Note that one downside of this QEMU system is that threads are barely\n+implemented, so we're careful to not spawn many threads.\n+\n+For the rumprun target the only output is a kernel image, so we just use that\n+plus the `rumpbake` command to create a full kernel image which is then run from\n+within QEMU.\n+\n+Finally, the fun part, the BSDs. Quite a few hoops are jumped through to get CI\n+working for these platforms, but the gist of it looks like:\n+\n+* Cross compiling from Linux to any of the BSDs seems to be quite non-standard.\n+  We may be able to get it working but it might be difficult at that point to\n+  ensure that the libc definitions align with what you'd get on the BSD itself.\n+  As a result, we try to do compiles within the BSD distro.\n+* On Travis we can't run a VM-in-a-VM, so we resort to userspace emulation\n+  (QEMU).\n+* Unfortunately on Travis we also can't use KVM, so the emulation is super slow.\n+\n+With all that in mind, the way BSD is tested looks like:\n+\n+1. Download a pre-prepared image for the OS being tested.\n+2. Generate the tests for the OS being tested. This involves running the `ctest`\n+   library over libc to generate a Rust file and a C file which will then be\n+   compiled into the final test.\n+3. Generate a disk image which will later be mounted by the OS being tested.\n+   This image is mostly just the libc directory, but some modifications are made\n+   to compile the generated files from step 2.\n+4. The kernel is booted in QEMU, and it is configured to detect the libc-test\n+   image being available, run the test script, and then shut down afterwards.\n+5. Look for whether the tests passed in the serial console output of the kernel.\n+\n+There's some pretty specific instructions for setting up each image (detailed\n+below), but the main gist of this is that we must avoid a vanilla `cargo run`\n+inside of the `libc-test` directory (which is what it's intended for) because\n+that would compile `syntex_syntax`, a large library, with userspace emulation.\n+This invariably times out on Travis, so we can't do that.\n+\n+Once all those hoops are jumped through, however, we can be happy that we're\n+testing almost everything!\n+\n+Below are some details of how to set up the initial OS images which are\n+downloaded. Each image must be enabled have input/output over the serial\n+console, log in automatically at the serial console, detect if a second drive in\n+QEMU is available, and if so mount it, run a script (it'll specifically be\n+`run-qemu.sh` in this folder which is copied into the generated image talked\n+about above), and then shut down.\n+\n+### QEMU setup - FreeBSD\n+\n+1. Download CD installer (most minimal is fine)\n+2. `qemu-img create -f qcow2 foo.qcow2 2G`\n+3. `qemu -cdrom foo.iso -drive if=virtio,file=foo.qcow2 -net nic,model=virtio -net user`\n+4. run installer\n+5. `echo 'console=\"comconsole\"' >> /boot/loader.conf`\n+6. `echo 'autoboot_delay=\"0\"' >> /boot/loader.conf`\n+7. look at /etc/ttys, see what getty argument is for ttyu0\n+8. edit /etc/gettytab, look for ttyu0 argument, prepend `:al=root` to line\n+   beneath\n+\n+(note that the current image has a `freebsd` user, but this isn't really\n+necessary)\n+\n+Once that's done, arrange for this script to run at login:\n+\n+```\n+#!/bin/sh\n+\n+sudo kldload ext2fs\n+[ -e /dev/vtbd1 ] || exit 0\n+sudo mount -t ext2fs /dev/vtbd1 /mnt\n+sh /mnt/run.sh /mnt\n+sudo poweroff\n+```\n+\n+Helpful links\n+\n+* https://en.wikibooks.org/wiki/QEMU/Images\n+* https://blog.nekoconeko.nl/blog/2015/06/04/creating-an-openstack-freebsd-image.html\n+* https://www.freebsd.org/doc/handbook/serialconsole-setup.html\n+\n+\n+### QEMU setup - OpenBSD\n+\n+1. Download CD installer\n+2. `qemu-img create -f qcow2 foo.qcow2 2G`\n+3. `qemu -cdrom foo.iso -drive if=virtio,file=foo.qcow2 -net nic,model=virtio -net user`\n+4. run installer\n+5. `echo 'set tty com0' >> /etc/boot.conf`\n+6. `echo 'boot' >> /etc/boot.conf`\n+7. Modify /etc/ttys, change the `tty00` at the end from 'unknown off' to\n+   'vt220 on secure'\n+8. Modify same line in /etc/ttys to have `\"/root/foo.sh\"` as the shell\n+9. Add this script to `/root/foo.sh`\n+\n+```\n+#!/bin/sh\n+exec 1>/dev/tty00\n+exec 2>&1\n+\n+if mount -t ext2fs /dev/sd1c /mnt; then\n+  sh /mnt/run.sh /mnt\n+  shutdown -ph now\n+fi\n+\n+# limited shell...\n+exec /bin/sh < /dev/tty00\n+```\n+\n+10. `chmod +x /root/foo.sh`\n+\n+Helpful links:\n+\n+* https://en.wikibooks.org/wiki/QEMU/Images\n+* http://www.openbsd.org/faq/faq7.html#SerCon\n+\n+# Questions?\n+\n+Hopefully that's at least somewhat of an introduction to everything going on\n+here, and feel free to ping @alexcrichton with questions!\n+"}, {"sha": "2ba69e15442f38f9964975337928aac80b1dc678", "filename": "src/vendor/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Faarch64-unknown-linux-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Faarch64-unknown-linux-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Faarch64-unknown-linux-gnu%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,7 @@\n+FROM ubuntu:16.10\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev ca-certificates \\\n+  gcc-aarch64-linux-gnu libc6-dev-arm64-cross qemu-user\n+ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"}, {"sha": "0e41ba6dbee66dc1301797cecb7c73a4bc4e1b56", "filename": "src/vendor/libc/ci/docker/arm-linux-androideabi/Dockerfile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Farm-linux-androideabi%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Farm-linux-androideabi%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Farm-linux-androideabi%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,4 @@\n+FROM alexcrichton/rust-slave-android:2015-11-22\n+ENV CARGO_TARGET_ARM_LINUX_ANDROIDEABI_LINKER=arm-linux-androideabi-gcc \\\n+    PATH=$PATH:/rust/bin\n+ENTRYPOINT [\"sh\"]"}, {"sha": "3824c0466401fda4c631aba150d80fd544a34914", "filename": "src/vendor/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Farm-unknown-linux-gnueabihf%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Farm-unknown-linux-gnueabihf%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Farm-unknown-linux-gnueabihf%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,7 @@\n+FROM ubuntu:16.10\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev ca-certificates \\\n+  gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user\n+ENV CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_LINKER=arm-linux-gnueabihf-gcc \\\n+    PATH=$PATH:/rust/bin"}, {"sha": "c149d84072912a2bbb38b6f82f987d92c5847eff", "filename": "src/vendor/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fi686-unknown-linux-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fi686-unknown-linux-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fi686-unknown-linux-gnu%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,5 @@\n+FROM ubuntu:16.10\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc-multilib libc6-dev ca-certificates\n+ENV PATH=$PATH:/rust/bin"}, {"sha": "87459a1672bdc4921ed26d7f5000b34bf3fe2765", "filename": "src/vendor/libc/ci/docker/i686-unknown-linux-musl/Dockerfile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fi686-unknown-linux-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fi686-unknown-linux-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fi686-unknown-linux-musl%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,22 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates\n+# Below we're cross-compiling musl for i686 using the system compiler on an\n+# x86_64 system. This is an awkward thing to be doing and so we have to jump\n+# through a couple hoops to get musl to be happy. In particular:\n+#\n+# * We specifically pass -m32 in CFLAGS and override CC when running ./configure,\n+#   since otherwise the script will fail to find a compiler.\n+# * We manually unset CROSS_COMPILE when running make; otherwise the makefile\n+#   will call the non-existent binary 'i686-ar'.\n+RUN curl https://www.musl-libc.org/releases/musl-1.1.15.tar.gz | \\\n+    tar xzf - && \\\n+    cd musl-1.1.15 && \\\n+    CC=gcc CFLAGS=-m32 ./configure --prefix=/musl-i686 --disable-shared --target=i686 && \\\n+    make CROSS_COMPILE= install -j4 && \\\n+    cd .. && \\\n+    rm -rf musl-1.1.15\n+ENV PATH=$PATH:/musl-i686/bin:/rust/bin \\\n+    CC_i686_unknown_linux_musl=musl-gcc"}, {"sha": "eea1f652c3cbd8e17d3652177e304ebdba9a6eb7", "filename": "src/vendor/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips-unknown-linux-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips-unknown-linux-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips-unknown-linux-gnu%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,10 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-mips-linux-gnu libc6-dev-mips-cross \\\n+        qemu-system-mips\n+\n+ENV CARGO_TARGET_MIPS_UNKNOWN_LINUX_GNU_LINKER=mips-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"}, {"sha": "77c6adb435f1d51e3850d0583819d369934c4d18", "filename": "src/vendor/libc/ci/docker/mips-unknown-linux-musl/Dockerfile", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips-unknown-linux-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips-unknown-linux-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips-unknown-linux-musl%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,14 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates qemu-system-mips curl \\\n+        bzip2\n+\n+RUN mkdir /toolchain\n+RUN curl -L https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/OpenWrt-SDK-ar71xx-generic_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2 | \\\n+      tar xjf - -C /toolchain --strip-components=1\n+\n+ENV PATH=$PATH:/rust/bin:/toolchain/staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.15/bin \\\n+    CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_MUSL_LINKER=mips-openwrt-linux-gcc"}, {"sha": "2eb5de2453800ef39b1782a50b35bb1a72c08fc3", "filename": "src/vendor/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips64-unknown-linux-gnuabi64%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips64-unknown-linux-gnuabi64%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmips64-unknown-linux-gnuabi64%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-mips64-linux-gnuabi64 libc6-dev-mips64-cross \\\n+        qemu-system-mips64\n+\n+ENV CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_LINKER=mips64-linux-gnuabi64-gcc \\\n+    CC_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-gcc \\\n+    PATH=$PATH:/rust/bin"}, {"sha": "36c4d90ef68f665b99f64382d45b4e7dcabab48a", "filename": "src/vendor/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmipsel-unknown-linux-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmipsel-unknown-linux-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fmipsel-unknown-linux-musl%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,14 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates qemu-system-mips curl \\\n+        bzip2\n+\n+RUN mkdir /toolchain\n+RUN curl -L https://downloads.openwrt.org/snapshots/trunk/malta/generic/OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2 | \\\n+      tar xjf - -C /toolchain --strip-components=2\n+\n+ENV PATH=$PATH:/rust/bin:/toolchain/bin \\\n+    CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n+    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_LINKER=mipsel-openwrt-linux-gcc"}, {"sha": "d9d7db0f41dd234d2dacc9999eb5ddca85a54045", "filename": "src/vendor/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fpowerpc-unknown-linux-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fpowerpc-unknown-linux-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fpowerpc-unknown-linux-gnu%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,10 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \\\n+        qemu-system-ppc\n+\n+ENV CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_LINKER=powerpc-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"}, {"sha": "df0e6057b4f7fad86233d81947f7fbce66af0878", "filename": "src/vendor/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fpowerpc64-unknown-linux-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fpowerpc64-unknown-linux-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fpowerpc64-unknown-linux-gnu%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-powerpc64-linux-gnu libc6-dev-ppc64-cross \\\n+        qemu-system-ppc\n+\n+ENV CARGO_TARGET_POWERPC64_UNKNOWN_LINUX_GNU_LINKER=powerpc64-linux-gnu-gcc \\\n+    CC=powerpc64-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"}, {"sha": "129771e76b74d7b843ca9e30f378146ea97e2ec2", "filename": "src/vendor/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-rumprun-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-rumprun-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-rumprun-netbsd%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,6 @@\n+FROM mato/rumprun-toolchain-hw-x86_64\n+USER root\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  qemu\n+ENV PATH=$PATH:/rust/bin"}, {"sha": "b1273382223637a3e8ccf25cafaf34faef71e822", "filename": "src/vendor/libc/ci/docker/x86_64-unknown-freebsd/Dockerfile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-freebsd%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,13 @@\n+FROM alexcrichton/rust-slave-linux-cross:2016-04-15\n+USER root\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  qemu genext2fs\n+\n+ENTRYPOINT [\"sh\"]\n+\n+ENV PATH=$PATH:/rust/bin \\\n+    QEMU=freebsd.qcow2.gz \\\n+    CAN_CROSS=1 \\\n+    CARGO_TARGET_X86_64_UNKNOWN_FREEBSD_LINKER=x86_64-unknown-freebsd10-gcc"}, {"sha": "4af3f834cbe6efff89ec6c67b40fc03d16bad92a", "filename": "src/vendor/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-linux-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-linux-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-linux-gnu%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,5 @@\n+FROM ubuntu:16.10\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev ca-certificates\n+ENV PATH=$PATH:/rust/bin"}, {"sha": "9c2499948a287aba5c00ad538ee7eb58917d3260", "filename": "src/vendor/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-linux-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-linux-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-linux-musl%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,13 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates\n+RUN curl https://www.musl-libc.org/releases/musl-1.1.15.tar.gz | \\\n+    tar xzf - && \\\n+    cd musl-1.1.15 && \\\n+    ./configure --prefix=/musl-x86_64 && \\\n+    make install -j4 && \\\n+    cd .. && \\\n+    rm -rf musl-1.1.15\n+ENV PATH=$PATH:/musl-x86_64/bin:/rust/bin"}, {"sha": "26340a5ed1ecaa71ce390850f8a22c09e6c1c686", "filename": "src/vendor/libc/ci/docker/x86_64-unknown-openbsd/Dockerfile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-openbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-openbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdocker%2Fx86_64-unknown-openbsd%2FDockerfile?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,8 @@\n+FROM ubuntu:16.10\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev qemu curl ca-certificates \\\n+  genext2fs\n+ENV PATH=$PATH:/rust/bin \\\n+    QEMU=2016-09-07/openbsd-6.0-without-pkgs.qcow2"}, {"sha": "88d882dcacdd3cbf28304e7b37d156150c3621b8", "filename": "src/vendor/libc/ci/dox.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdox.sh", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fdox.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fdox.sh?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/sh\n+\n+# Builds documentation for all target triples that we have a registered URL for\n+# in liblibc. This scrapes the list of triples to document from `src/lib.rs`\n+# which has a bunch of `html_root_url` directives we pick up.\n+\n+set -e\n+\n+TARGETS=`grep html_root_url src/lib.rs | sed 's/.*\".*\\/\\(.*\\)\"/\\1/'`\n+\n+rm -rf target/doc\n+mkdir -p target/doc\n+\n+cp ci/landing-page-head.html target/doc/index.html\n+\n+for target in $TARGETS; do\n+  echo documenting $target\n+\n+  rustdoc -o target/doc/$target --target $target src/lib.rs --cfg dox \\\n+    --crate-name libc\n+\n+  echo \"<li><a href=\"/libc/$target/libc/index.html\">$target</a></li>\" \\\n+    >> target/doc/index.html\n+done\n+\n+cat ci/landing-page-footer.html >> target/doc/index.html\n+\n+# If we're on travis, not a PR, and on the right branch, publish!\n+if [ \"$TRAVIS_PULL_REQUEST\" = \"false\" ] && [ \"$TRAVIS_BRANCH\" = \"master\" ]; then\n+  pip install ghp-import --user $USER\n+  $HOME/.local/bin/ghp-import -n target/doc\n+  git push -qf https://${GH_TOKEN}@github.com/${TRAVIS_REPO_SLUG}.git gh-pages\n+fi"}, {"sha": "941cc8d2b40307cc0a5911984505cf6b48cd82aa", "filename": "src/vendor/libc/ci/landing-page-footer.html", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Flanding-page-footer.html", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Flanding-page-footer.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Flanding-page-footer.html?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,3 @@\n+    </ul>\n+  </body>\n+</html>"}, {"sha": "fc69fa88eb5ce6fc8724ac195827278df5cdcdbd", "filename": "src/vendor/libc/ci/landing-page-head.html", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Flanding-page-head.html", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Flanding-page-head.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Flanding-page-head.html?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,7 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+  <head>\n+    <meta charset=\"utf-8\">\n+  </head>\n+  <body>\n+    <ul>"}, {"sha": "e34e65ffcdc0cd5ce8cb77d356d96325a1977b9c", "filename": "src/vendor/libc/ci/run-docker.sh", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Frun-docker.sh", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Frun-docker.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Frun-docker.sh?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,26 @@\n+# Small script to run tests for a target (or all targets) inside all the\n+# respective docker images.\n+\n+set -ex\n+\n+run() {\n+    echo $1\n+    docker build -t libc ci/docker/$1\n+    docker run \\\n+      --rm \\\n+      -v `rustc --print sysroot`:/rust:ro \\\n+      -v `pwd`:/checkout:ro \\\n+      -e CARGO_TARGET_DIR=/tmp/target \\\n+      -w /checkout \\\n+      --privileged \\\n+      -it libc \\\n+      ci/run.sh $1\n+}\n+\n+if [ -z \"$1\" ]; then\n+  for d in `ls ci/docker/`; do\n+    run $d\n+  done\n+else\n+  run $1\n+fi"}, {"sha": "b2f457df916f85688dce328af91b06543fad6ff6", "filename": "src/vendor/libc/ci/run-qemu.sh", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Frun-qemu.sh", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Frun-qemu.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Frun-qemu.sh?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,32 @@\n+# Initial script which is run inside of all qemu images. The first argument to\n+# this script (as arranged by the qemu image itself) is the path to where the\n+# libc crate is mounted.\n+#\n+# For qemu images we currently need to install Rust manually as this wasn't done\n+# by the initial run-travis.sh script\n+#\n+# FIXME: feels like run-travis.sh should be responsible for downloading the\n+#        compiler.\n+\n+set -ex\n+\n+ROOT=$1\n+cp -r $ROOT/libc /tmp/libc\n+cd /tmp/libc\n+\n+TARGET=$(cat $ROOT/TARGET)\n+export CARGO_TARGET_DIR=/tmp\n+\n+case $TARGET in\n+  *-openbsd)\n+    pkg_add cargo gcc%4.9 rust\n+    export CC=egcc\n+    ;;\n+\n+  *)\n+    echo \"Unknown target: $TARGET\"\n+    exit 1\n+    ;;\n+esac\n+\n+exec sh ci/run.sh $TARGET"}, {"sha": "15721ab965d262a56d1fa07edfbe108198abbddb", "filename": "src/vendor/libc/ci/run.sh", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Frun.sh?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,160 @@\n+#!/bin/sh\n+\n+# Builds and runs tests for a particular target passed as an argument to this\n+# script.\n+\n+set -ex\n+\n+TARGET=$1\n+\n+# If we're going to run tests inside of a qemu image, then we don't need any of\n+# the scripts below. Instead, download the image, prepare a filesystem which has\n+# the current state of this repository, and then run the image.\n+#\n+# It's assume that all images, when run with two disks, will run the `run.sh`\n+# script from the second which we place inside.\n+if [ \"$QEMU\" != \"\" ]; then\n+  tmpdir=/tmp/qemu-img-creation\n+  mkdir -p $tmpdir\n+\n+  if [ -z \"${QEMU#*.gz}\" ]; then\n+    # image is .gz : download and uncompress it\n+    qemufile=$(echo ${QEMU%.gz} | sed 's/\\//__/g')\n+    if [ ! -f $tmpdir/$qemufile ]; then\n+      curl https://people.mozilla.org/~acrichton/libc-test/qemu/$QEMU | \\\n+        gunzip -d > $tmpdir/$qemufile\n+    fi\n+  else\n+    # plain qcow2 image: just download it\n+    qemufile=$(echo ${QEMU} | sed 's/\\//__/g')\n+    if [ ! -f $tmpdir/$qemufile ]; then\n+      curl https://people.mozilla.org/~acrichton/libc-test/qemu/$QEMU \\\n+        > $tmpdir/$qemufile\n+    fi\n+  fi\n+\n+  # Create a mount a fresh new filesystem image that we'll later pass to QEMU.\n+  # This will have a `run.sh` script will which use the artifacts inside to run\n+  # on the host.\n+  rm -f $tmpdir/libc-test.img\n+  mkdir $tmpdir/mount\n+\n+  # If we have a cross compiler, then we just do the standard rigamarole of\n+  # cross-compiling an executable and then the script to run just executes the\n+  # binary.\n+  #\n+  # If we don't have a cross-compiler, however, then we need to do some crazy\n+  # acrobatics to get this to work.  Generate all.{c,rs} on the host which will\n+  # be compiled inside QEMU. Do this here because compiling syntex_syntax in\n+  # QEMU would time out basically everywhere.\n+  if [ \"$CAN_CROSS\" = \"1\" ]; then\n+    cargo build --manifest-path libc-test/Cargo.toml --target $TARGET\n+    cp $CARGO_TARGET_DIR/$TARGET/debug/libc-test $tmpdir/mount/\n+    echo 'exec $1/libc-test' > $tmpdir/mount/run.sh\n+  else\n+    rm -rf $tmpdir/generated\n+    mkdir -p $tmpdir/generated\n+    cargo build --manifest-path libc-test/generate-files/Cargo.toml\n+    (cd libc-test && TARGET=$TARGET OUT_DIR=$tmpdir/generated SKIP_COMPILE=1 \\\n+      $CARGO_TARGET_DIR/debug/generate-files)\n+\n+    # Copy this folder into the mounted image, the `run.sh` entry point, and\n+    # overwrite the standard libc-test Cargo.toml with the overlay one which will\n+    # assume the all.{c,rs} test files have already been generated\n+    mkdir $tmpdir/mount/libc\n+    cp -r Cargo.* libc-test src ci $tmpdir/mount/libc/\n+    ln -s libc-test/target $tmpdir/mount/libc/target\n+    cp ci/run-qemu.sh $tmpdir/mount/run.sh\n+    echo $TARGET | tee -a $tmpdir/mount/TARGET\n+    cp $tmpdir/generated/* $tmpdir/mount/libc/libc-test\n+    cp libc-test/run-generated-Cargo.toml $tmpdir/mount/libc/libc-test/Cargo.toml\n+  fi\n+\n+  du -sh $tmpdir/mount\n+  genext2fs \\\n+      --root $tmpdir/mount \\\n+      --size-in-blocks 100000 \\\n+      $tmpdir/libc-test.img\n+\n+  # Pass -snapshot to prevent tampering with the disk images, this helps when\n+  # running this script in development. The two drives are then passed next,\n+  # first is the OS and second is the one we just made. Next the network is\n+  # configured to work (I'm not entirely sure how), and then finally we turn off\n+  # graphics and redirect the serial console output to out.log.\n+  qemu-system-x86_64 \\\n+    -m 1024 \\\n+    -snapshot \\\n+    -drive if=virtio,file=$tmpdir/$qemufile \\\n+    -drive if=virtio,file=$tmpdir/libc-test.img \\\n+    -net nic,model=virtio \\\n+    -net user \\\n+    -nographic \\\n+    -vga none 2>&1 | tee $CARGO_TARGET_DIR/out.log\n+  exec grep \"^PASSED .* tests\" $CARGO_TARGET_DIR/out.log\n+fi\n+\n+case \"$TARGET\" in\n+  *-apple-ios)\n+    cargo rustc --manifest-path libc-test/Cargo.toml --target $TARGET -- \\\n+        -C link-args=-mios-simulator-version-min=7.0\n+    ;;\n+\n+  *)\n+    cargo build --manifest-path libc-test/Cargo.toml --target $TARGET\n+    ;;\n+esac\n+\n+case \"$TARGET\" in\n+  arm-linux-androideabi)\n+    emulator @arm-21 -no-window &\n+    adb wait-for-device\n+    adb push $CARGO_TARGET_DIR/$TARGET/debug/libc-test /data/libc-test\n+    adb shell /data/libc-test 2>&1 | tee /tmp/out\n+    grep \"^PASSED .* tests\" /tmp/out\n+    ;;\n+\n+  arm-unknown-linux-gnueabihf)\n+    qemu-arm -L /usr/arm-linux-gnueabihf $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  mips-unknown-linux-gnu)\n+    qemu-mips -L /usr/mips-linux-gnu $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  mips64-unknown-linux-gnuabi64)\n+    qemu-mips64 -L /usr/mips64-linux-gnuabi64 $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  mips-unknown-linux-musl)\n+    qemu-mips -L /toolchain/staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.15 \\\n+              $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  mipsel-unknown-linux-musl)\n+      qemu-mipsel -L /toolchain $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+      ;;\n+\n+  powerpc-unknown-linux-gnu)\n+    qemu-ppc -L /usr/powerpc-linux-gnu $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  powerpc64-unknown-linux-gnu)\n+    qemu-ppc64 -L /usr/powerpc64-linux-gnu $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  aarch64-unknown-linux-gnu)\n+    qemu-aarch64 -L /usr/aarch64-linux-gnu/ $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+\n+  *-rumprun-netbsd)\n+    rumprun-bake hw_virtio /tmp/libc-test.img $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    qemu-system-x86_64 -nographic -vga none -m 64 \\\n+        -kernel /tmp/libc-test.img 2>&1 | tee /tmp/out &\n+    sleep 5\n+    grep \"^PASSED .* tests\" /tmp/out\n+    ;;\n+\n+  *)\n+    $CARGO_TARGET_DIR/$TARGET/debug/libc-test\n+    ;;\n+esac"}, {"sha": "32e4ba772c5b73c293ab4936937176bde0f71d0c", "filename": "src/vendor/libc/ci/style.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fci%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fci%2Fstyle.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,204 @@\n+//! Simple script to verify the coding style of this library\n+//!\n+//! ## How to run\n+//!\n+//! The first argument to this script is the directory to run on, so running\n+//! this script should be as simple as:\n+//!\n+//! ```notrust\n+//! rustc ci/style.rs\n+//! ./style src\n+//! ```\n+//!\n+//! ## Guidelines\n+//!\n+//! The current style is:\n+//!\n+//! * No trailing whitespace\n+//! * No tabs\n+//! * 80-character lines\n+//! * `extern` instead of `extern \"C\"`\n+//! * Specific module layout:\n+//!     1. use directives\n+//!     2. typedefs\n+//!     3. structs\n+//!     4. constants\n+//!     5. f! { ... } functions\n+//!     6. extern functions\n+//!     7. modules + pub use\n+//!\n+//! Things not verified:\n+//!\n+//! * alignment\n+//! * 4-space tabs\n+//! * leading colons on paths\n+\n+use std::env;\n+use std::fs;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+fn main() {\n+    let arg = env::args().skip(1).next().unwrap_or(\".\".to_string());\n+\n+    let mut errors = Errors { errs: false };\n+    walk(Path::new(&arg), &mut errors);\n+\n+    if errors.errs {\n+        panic!(\"found some lint errors\");\n+    } else {\n+        println!(\"good style!\");\n+    }\n+}\n+\n+fn walk(path: &Path, err: &mut Errors) {\n+    for entry in t!(path.read_dir()).map(|e| t!(e)) {\n+        let path = entry.path();\n+        if t!(entry.file_type()).is_dir() {\n+            walk(&path, err);\n+            continue\n+        }\n+\n+        let name = entry.file_name().into_string().unwrap();\n+        match &name[..] {\n+            n if !n.ends_with(\".rs\") => continue,\n+\n+            \"dox.rs\" |\n+            \"lib.rs\" |\n+            \"macros.rs\" => continue,\n+\n+            _ => {}\n+        }\n+\n+        let mut contents = String::new();\n+        t!(t!(fs::File::open(&path)).read_to_string(&mut contents));\n+\n+        check_style(&contents, &path, err);\n+    }\n+}\n+\n+struct Errors {\n+    errs: bool,\n+}\n+\n+#[derive(Clone, Copy, PartialEq)]\n+enum State {\n+    Start,\n+    Imports,\n+    Typedefs,\n+    Structs,\n+    Constants,\n+    FunctionDefinitions,\n+    Functions,\n+    Modules,\n+}\n+\n+fn check_style(file: &str, path: &Path, err: &mut Errors) {\n+    let mut state = State::Start;\n+    let mut s_macros = 0;\n+    let mut f_macros = 0;\n+    let mut prev_blank = false;\n+\n+    for (i, line) in file.lines().enumerate() {\n+        if line == \"\" {\n+            if prev_blank {\n+                err.error(path, i, \"double blank line\");\n+            }\n+            prev_blank = true;\n+        } else {\n+            prev_blank = false;\n+        }\n+        if line != line.trim_right() {\n+            err.error(path, i, \"trailing whitespace\");\n+        }\n+        if line.contains(\"\\t\") {\n+            err.error(path, i, \"tab character\");\n+        }\n+        if line.len() > 80 {\n+            err.error(path, i, \"line longer than 80 chars\");\n+        }\n+        if line.contains(\"extern \\\"C\\\"\") {\n+            err.error(path, i, \"use `extern` instead of `extern \\\"C\\\"\");\n+        }\n+        if line.contains(\"#[cfg(\") && !line.contains(\" if \") {\n+            if state != State::Structs {\n+                err.error(path, i, \"use cfg_if! and submodules \\\n+                                    instead of #[cfg]\");\n+            }\n+        }\n+\n+        let line = line.trim_left();\n+        let is_pub = line.starts_with(\"pub \");\n+        let line = if is_pub {&line[4..]} else {line};\n+\n+        let line_state = if line.starts_with(\"use \") {\n+            if is_pub {\n+                State::Modules\n+            } else {\n+                State::Imports\n+            }\n+        } else if line.starts_with(\"const \") {\n+            State::Constants\n+        } else if line.starts_with(\"type \") {\n+            State::Typedefs\n+        } else if line.starts_with(\"s! {\") {\n+            s_macros += 1;\n+            State::Structs\n+        } else if line.starts_with(\"f! {\") {\n+            f_macros += 1;\n+            State::FunctionDefinitions\n+        } else if line.starts_with(\"extern \") {\n+            State::Functions\n+        } else if line.starts_with(\"mod \") {\n+            State::Modules\n+        } else {\n+            continue\n+        };\n+\n+        if state as usize > line_state as usize {\n+            err.error(path, i, &format!(\"{} found after {} when \\\n+                                         it belongs before\",\n+                                        line_state.desc(), state.desc()));\n+        }\n+\n+        if f_macros == 2 {\n+            f_macros += 1;\n+            err.error(path, i, \"multiple f! macros in one module\");\n+        }\n+        if s_macros == 2 {\n+            s_macros += 1;\n+            err.error(path, i, \"multiple s! macros in one module\");\n+        }\n+\n+        state = line_state;\n+    }\n+}\n+\n+impl State {\n+    fn desc(&self) -> &str {\n+        match *self {\n+            State::Start => \"start\",\n+            State::Imports => \"import\",\n+            State::Typedefs => \"typedef\",\n+            State::Structs => \"struct\",\n+            State::Constants => \"constant\",\n+            State::FunctionDefinitions => \"function definition\",\n+            State::Functions => \"extern function\",\n+            State::Modules => \"module\",\n+        }\n+    }\n+}\n+\n+impl Errors {\n+    fn error(&mut self, path: &Path, line: usize, msg: &str) {\n+        self.errs = true;\n+        println!(\"{}:{} - {}\", path.display(), line + 1, msg);\n+    }\n+}"}, {"sha": "c7d3dc9c2deba67253d7e0f9a5c72495cbae1a2d", "filename": "src/vendor/libc/src/dox.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Fdox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Fdox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Fdox.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,134 @@\n+pub use self::imp::*;\n+\n+#[cfg(not(dox))]\n+mod imp {\n+    pub use core::option::Option;\n+    pub use core::clone::Clone;\n+    pub use core::marker::Copy;\n+    pub use core::mem;\n+}\n+\n+#[cfg(dox)]\n+mod imp {\n+    pub enum Option<T> {\n+        Some(T),\n+        None,\n+    }\n+    impl<T: Copy> Copy for Option<T> {}\n+    impl<T: Clone> Clone for Option<T> {\n+        fn clone(&self) -> Option<T> { loop {} }\n+    }\n+\n+    pub trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+\n+    #[lang = \"copy\"]\n+    pub trait Copy {}\n+\n+    #[lang = \"sync\"]\n+    pub trait Sync {}\n+    impl<T> Sync for T {}\n+\n+    #[lang = \"sized\"]\n+    pub trait Sized {}\n+\n+    macro_rules! each_int {\n+        ($mac:ident) => (\n+            $mac!(u8);\n+            $mac!(u16);\n+            $mac!(u32);\n+            $mac!(u64);\n+            $mac!(usize);\n+            $mac!(i8);\n+            $mac!(i16);\n+            $mac!(i32);\n+            $mac!(i64);\n+            $mac!(isize);\n+        )\n+    }\n+\n+    #[lang = \"div\"]\n+    pub trait Div<RHS> {\n+        type Output;\n+        fn div(self, rhs: RHS) -> Self::Output;\n+    }\n+\n+    macro_rules! impl_div {\n+        ($($i:ident)*) => ($(\n+            impl Div<$i> for $i {\n+                type Output = $i;\n+                fn div(self, rhs: $i) -> $i { self / rhs }\n+            }\n+        )*)\n+    }\n+    each_int!(impl_div);\n+\n+    #[lang = \"shl\"]\n+    pub trait Shl<RHS> {\n+        type Output;\n+        fn shl(self, rhs: RHS) -> Self::Output;\n+    }\n+\n+    macro_rules! impl_shl {\n+        ($($i:ident)*) => ($(\n+            impl Shl<$i> for $i {\n+                type Output = $i;\n+                fn shl(self, rhs: $i) -> $i { self << rhs }\n+            }\n+        )*)\n+    }\n+    each_int!(impl_shl);\n+\n+    #[lang = \"mul\"]\n+    pub trait Mul<RHS=Self> {\n+        type Output;\n+        fn mul(self, rhs: RHS) -> Self::Output;\n+    }\n+\n+    macro_rules! impl_mul {\n+        ($($i:ident)*) => ($(\n+            impl Mul for $i {\n+                type Output = $i;\n+                fn mul(self, rhs: $i) -> $i { self * rhs }\n+            }\n+        )*)\n+    }\n+    each_int!(impl_mul);\n+\n+    #[lang = \"sub\"]\n+    pub trait Sub<RHS=Self> {\n+        type Output;\n+        fn sub(self, rhs: RHS) -> Self::Output;\n+    }\n+\n+    macro_rules! impl_sub {\n+        ($($i:ident)*) => ($(\n+            impl Sub for $i {\n+                type Output = $i;\n+                fn sub(self, rhs: $i) -> $i { self - rhs }\n+            }\n+        )*)\n+    }\n+    each_int!(impl_sub);\n+\n+    #[lang = \"bitor\"]\n+    pub trait Bitor<RHS=Self> {\n+        type Output;\n+        fn bitor(self, rhs: RHS) -> Self::Output;\n+    }\n+\n+    macro_rules! impl_bitor {\n+        ($($i:ident)*) => ($(\n+            impl Bitor for $i {\n+                type Output = $i;\n+                fn bitor(self, rhs: $i) -> $i { self | rhs }\n+            }\n+        )*)\n+    }\n+    each_int!(impl_bitor);\n+\n+    pub mod mem {\n+        pub fn size_of_val<T>(_: &T) -> usize { 4 }\n+    }\n+}"}, {"sha": "dcc4791f9af0bf23a46a97713562f7a6fd5f1c5d", "filename": "src/vendor/libc/src/lib.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Flib.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,274 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Crate docs\n+\n+#![allow(bad_style, overflowing_literals, improper_ctypes)]\n+#![crate_type = \"rlib\"]\n+#![crate_name = \"libc\"]\n+#![cfg_attr(dox, feature(no_core, lang_items))]\n+#![cfg_attr(dox, no_core)]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\")]\n+\n+#![cfg_attr(all(target_os = \"linux\", target_arch = \"x86_64\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-linux-gnu\"\n+))]\n+#![cfg_attr(all(target_os = \"linux\", target_arch = \"x86\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/i686-unknown-linux-gnu\"\n+))]\n+#![cfg_attr(all(target_os = \"linux\", target_arch = \"arm\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/arm-unknown-linux-gnueabihf\"\n+))]\n+#![cfg_attr(all(target_os = \"linux\", target_arch = \"mips\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/mips-unknown-linux-gnu\"\n+))]\n+#![cfg_attr(all(target_os = \"linux\", target_arch = \"aarch64\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/aarch64-unknown-linux-gnu\"\n+))]\n+#![cfg_attr(all(target_os = \"linux\", target_env = \"musl\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-linux-musl\"\n+))]\n+#![cfg_attr(all(target_os = \"macos\", target_arch = \"x86_64\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-apple-darwin\"\n+))]\n+#![cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/i686-apple-darwin\"\n+))]\n+#![cfg_attr(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-pc-windows-gnu\"\n+))]\n+#![cfg_attr(all(windows, target_arch = \"x86\", target_env = \"gnu\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/i686-pc-windows-gnu\"\n+))]\n+#![cfg_attr(all(windows, target_arch = \"x86_64\", target_env = \"msvc\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-pc-windows-msvc\"\n+))]\n+#![cfg_attr(all(windows, target_arch = \"x86\", target_env = \"msvc\"), doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/i686-pc-windows-msvc\"\n+))]\n+#![cfg_attr(target_os = \"android\", doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/arm-linux-androideabi\"\n+))]\n+#![cfg_attr(target_os = \"freebsd\", doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-freebsd\"\n+))]\n+#![cfg_attr(target_os = \"openbsd\", doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-openbsd\"\n+))]\n+#![cfg_attr(target_os = \"bitrig\", doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-bitrig\"\n+))]\n+#![cfg_attr(target_os = \"netbsd\", doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-netbsd\"\n+))]\n+#![cfg_attr(target_os = \"dragonfly\", doc(\n+    html_root_url = \"https://doc.rust-lang.org/libc/x86_64-unknown-dragonfly\"\n+))]\n+\n+// Attributes needed when building as part of the standard library\n+#![cfg_attr(stdbuild, feature(no_std, core, core_slice_ext, staged_api, custom_attribute, cfg_target_vendor))]\n+#![cfg_attr(stdbuild, no_std)]\n+#![cfg_attr(stdbuild, staged_api)]\n+#![cfg_attr(stdbuild, allow(warnings))]\n+#![cfg_attr(stdbuild, unstable(feature = \"libc\",\n+                               reason = \"use `libc` from crates.io\",\n+                               issue = \"27783\"))]\n+\n+#![cfg_attr(not(feature = \"use_std\"), no_std)]\n+\n+#[cfg(all(not(stdbuild), not(dox), feature = \"use_std\"))]\n+extern crate std as core;\n+\n+#[macro_use] mod macros;\n+mod dox;\n+\n+// Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help enable\n+// more optimization opportunities around it recognizing things like\n+// malloc/free.\n+#[repr(u8)]\n+pub enum c_void {\n+    // Two dummy variants so the #[repr] attribute can be used.\n+    #[doc(hidden)]\n+    __variant1,\n+    #[doc(hidden)]\n+    __variant2,\n+}\n+\n+pub type int8_t = i8;\n+pub type int16_t = i16;\n+pub type int32_t = i32;\n+pub type int64_t = i64;\n+pub type uint8_t = u8;\n+pub type uint16_t = u16;\n+pub type uint32_t = u32;\n+pub type uint64_t = u64;\n+\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type intmax_t = i64;\n+pub type uintmax_t = u64;\n+\n+pub type size_t = usize;\n+pub type ptrdiff_t = isize;\n+pub type intptr_t = isize;\n+pub type uintptr_t = usize;\n+pub type ssize_t = isize;\n+\n+pub enum FILE {}\n+pub enum fpos_t {} // TODO: fill this out with a struct\n+\n+extern {\n+    pub fn isalnum(c: c_int) -> c_int;\n+    pub fn isalpha(c: c_int) -> c_int;\n+    pub fn iscntrl(c: c_int) -> c_int;\n+    pub fn isdigit(c: c_int) -> c_int;\n+    pub fn isgraph(c: c_int) -> c_int;\n+    pub fn islower(c: c_int) -> c_int;\n+    pub fn isprint(c: c_int) -> c_int;\n+    pub fn ispunct(c: c_int) -> c_int;\n+    pub fn isspace(c: c_int) -> c_int;\n+    pub fn isupper(c: c_int) -> c_int;\n+    pub fn isxdigit(c: c_int) -> c_int;\n+    pub fn tolower(c: c_int) -> c_int;\n+    pub fn toupper(c: c_int) -> c_int;\n+\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"fopen$UNIX2003\")]\n+    pub fn fopen(filename: *const c_char,\n+                 mode: *const c_char) -> *mut FILE;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"freopen$UNIX2003\")]\n+    pub fn freopen(filename: *const c_char, mode: *const c_char,\n+                   file: *mut FILE) -> *mut FILE;\n+    pub fn fflush(file: *mut FILE) -> c_int;\n+    pub fn fclose(file: *mut FILE) -> c_int;\n+    pub fn remove(filename: *const c_char) -> c_int;\n+    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;\n+    pub fn tmpfile() -> *mut FILE;\n+    pub fn setvbuf(stream: *mut FILE,\n+                   buffer: *mut c_char,\n+                   mode: c_int,\n+                   size: size_t) -> c_int;\n+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n+    pub fn getchar() -> c_int;\n+    pub fn putchar(c: c_int) -> c_int;\n+    pub fn fgetc(stream: *mut FILE) -> c_int;\n+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE) -> *mut c_char;\n+    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"fputs$UNIX2003\")]\n+    pub fn fputs(s: *const c_char, stream: *mut FILE)-> c_int;\n+    pub fn puts(s: *const c_char) -> c_int;\n+    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n+    pub fn fread(ptr: *mut c_void,\n+                 size: size_t,\n+                 nobj: size_t,\n+                 stream: *mut FILE)\n+                 -> size_t;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"fwrite$UNIX2003\")]\n+    pub fn fwrite(ptr: *const c_void,\n+                  size: size_t,\n+                  nobj: size_t,\n+                  stream: *mut FILE)\n+                  -> size_t;\n+    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;\n+    pub fn ftell(stream: *mut FILE) -> c_long;\n+    pub fn rewind(stream: *mut FILE);\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__fgetpos50\")]\n+    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__fsetpos50\")]\n+    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;\n+    pub fn feof(stream: *mut FILE) -> c_int;\n+    pub fn ferror(stream: *mut FILE) -> c_int;\n+    pub fn perror(s: *const c_char);\n+    pub fn atoi(s: *const c_char) -> c_int;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"strtod$UNIX2003\")]\n+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;\n+    pub fn strtol(s: *const c_char,\n+                  endp: *mut *mut c_char, base: c_int) -> c_long;\n+    pub fn strtoul(s: *const c_char, endp: *mut *mut c_char,\n+                   base: c_int) -> c_ulong;\n+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n+    pub fn malloc(size: size_t) -> *mut c_void;\n+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n+    pub fn free(p: *mut c_void);\n+    pub fn abort() -> !;\n+    pub fn exit(status: c_int) -> !;\n+    pub fn _exit(status: c_int) -> !;\n+    pub fn atexit(cb: extern fn()) -> c_int;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"system$UNIX2003\")]\n+    pub fn system(s: *const c_char) -> c_int;\n+    pub fn getenv(s: *const c_char) -> *mut c_char;\n+\n+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;\n+    pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t)\n+                   -> *mut c_char;\n+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n+    pub fn strncat(s: *mut c_char, ct: *const c_char, n: size_t) -> *mut c_char;\n+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;\n+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+    pub fn strdup(cs: *const c_char) -> *mut c_char;\n+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n+    pub fn strlen(cs: *const c_char) -> size_t;\n+    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"strerror$UNIX2003\")]\n+    pub fn strerror(n: c_int) -> *mut c_char;\n+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;\n+    pub fn wcslen(buf: *const wchar_t) -> size_t;\n+\n+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;\n+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;\n+    pub fn memcpy(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n+    pub fn memmove(dest: *mut c_void, src: *const c_void, n: size_t) -> *mut c_void;\n+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;\n+}\n+\n+// These are all inline functions on android, so they end up just being entirely\n+// missing on that platform.\n+#[cfg(not(target_os = \"android\"))]\n+extern {\n+    pub fn abs(i: c_int) -> c_int;\n+    pub fn atof(s: *const c_char) -> c_double;\n+    pub fn labs(i: c_long) -> c_long;\n+    pub fn rand() -> c_int;\n+    pub fn srand(seed: c_uint);\n+}\n+\n+cfg_if! {\n+    if #[cfg(windows)] {\n+        mod windows;\n+        pub use windows::*;\n+    } else if #[cfg(unix)] {\n+        mod unix;\n+        pub use unix::*;\n+    } else {\n+        // Unknown target_family\n+    }\n+}"}, {"sha": "5811c84c3aaa541010b7e363b52ffb311d1cd5f2", "filename": "src/vendor/libc/src/macros.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Fmacros.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,108 @@\n+/// A macro for defining #[cfg] if-else statements.\n+///\n+/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n+/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n+/// first.\n+///\n+/// This allows you to conveniently provide a long list #[cfg]'d blocks of code\n+/// without having to rewrite each clause multiple times.\n+macro_rules! cfg_if {\n+    ($(\n+        if #[cfg($($meta:meta),*)] { $($it:item)* }\n+    ) else * else {\n+        $($it2:item)*\n+    }) => {\n+        __cfg_if_items! {\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    }\n+}\n+\n+macro_rules! __cfg_if_items {\n+    (($($not:meta,)*) ; ) => {};\n+    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n+        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+    }\n+}\n+\n+macro_rules! __cfg_if_apply {\n+    ($m:meta, $($it:item)*) => {\n+        $(#[$m] $it)*\n+    }\n+}\n+\n+macro_rules! s {\n+    ($($(#[$attr:meta])* pub struct $i:ident { $($field:tt)* })*) => ($(\n+        __item! {\n+            #[repr(C)]\n+            $(#[$attr])*\n+            pub struct $i { $($field)* }\n+        }\n+        impl ::dox::Copy for $i {}\n+        impl ::dox::Clone for $i {\n+            fn clone(&self) -> $i { *self }\n+        }\n+    )*)\n+}\n+\n+macro_rules! f {\n+    ($(pub fn $i:ident($($arg:ident: $argty:ty),*) -> $ret:ty {\n+        $($body:stmt);*\n+    })*) => ($(\n+        #[inline]\n+        #[cfg(not(dox))]\n+        pub unsafe extern fn $i($($arg: $argty),*) -> $ret {\n+            $($body);*\n+        }\n+\n+        #[cfg(dox)]\n+        #[allow(dead_code)]\n+        pub unsafe extern fn $i($($arg: $argty),*) -> $ret {\n+            loop {}\n+        }\n+    )*)\n+}\n+\n+macro_rules! __item {\n+    ($i:item) => ($i)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    cfg_if! {\n+        if #[cfg(test)] {\n+            use std::option::Option as Option2;\n+            fn works1() -> Option2<u32> { Some(1) }\n+        } else {\n+            fn works1() -> Option<u32> { None }\n+        }\n+    }\n+\n+    cfg_if! {\n+        if #[cfg(foo)] {\n+            fn works2() -> bool { false }\n+        } else if #[cfg(test)] {\n+            fn works2() -> bool { true }\n+        } else {\n+            fn works2() -> bool { false }\n+        }\n+    }\n+\n+    cfg_if! {\n+        if #[cfg(foo)] {\n+            fn works3() -> bool { false }\n+        } else {\n+            fn works3() -> bool { true }\n+        }\n+    }\n+\n+    #[test]\n+    fn it_works() {\n+        assert!(works1().is_some());\n+        assert!(works2());\n+        assert!(works3());\n+    }\n+}"}, {"sha": "8ca02544973ec5db0337d8f1820ccdbb37064b60", "filename": "src/vendor/libc/src/unix/bsd/apple/b32.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fb32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fb32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fb32.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,19 @@\n+//! 32-bit specific Apple (ios/darwin) definitions\n+\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+\n+s! {\n+    pub struct pthread_attr_t {\n+        __sig: c_long,\n+        __opaque: [::c_char; 36]\n+    }\n+}\n+\n+pub const __PTHREAD_MUTEX_SIZE__: usize = 40;\n+pub const __PTHREAD_COND_SIZE__: usize = 24;\n+pub const __PTHREAD_CONDATTR_SIZE__: usize = 4;\n+pub const __PTHREAD_RWLOCK_SIZE__: usize = 124;\n+\n+pub const TIOCTIMESTAMP: ::c_ulong = 0x40087459;\n+pub const TIOCDCDTIMESTAMP: ::c_ulong = 0x40087458;"}, {"sha": "327a4b63116b076b16ee8af45d5a09b4c4ebd0e6", "filename": "src/vendor/libc/src/unix/bsd/apple/b64.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fb64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fb64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fb64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,19 @@\n+//! 64-bit specific Apple (ios/darwin) definitions\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+\n+s! {\n+    pub struct pthread_attr_t {\n+        __sig: c_long,\n+        __opaque: [::c_char; 56]\n+    }\n+}\n+\n+pub const __PTHREAD_MUTEX_SIZE__: usize = 56;\n+pub const __PTHREAD_COND_SIZE__: usize = 40;\n+pub const __PTHREAD_CONDATTR_SIZE__: usize = 8;\n+pub const __PTHREAD_RWLOCK_SIZE__: usize = 192;\n+\n+pub const TIOCTIMESTAMP: ::c_ulong = 0x40107459;\n+pub const TIOCDCDTIMESTAMP: ::c_ulong = 0x40107458;"}, {"sha": "aa4d1ac74575e9f96fac8ec3313765ce54b243a1", "filename": "src/vendor/libc/src/unix/bsd/apple/mod.rs", "status": "added", "additions": 1500, "deletions": 0, "changes": 1500, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fapple%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,1500 @@\n+//! Apple (ios/darwin)-specific definitions\n+//!\n+//! This covers *-apple-* triples currently\n+\n+pub type clock_t = c_ulong;\n+pub type time_t = c_long;\n+pub type suseconds_t = i32;\n+pub type dev_t = i32;\n+pub type ino_t = u64;\n+pub type mode_t = u16;\n+pub type nlink_t = u16;\n+pub type blksize_t = i32;\n+pub type rlim_t = u64;\n+pub type mach_timebase_info_data_t = mach_timebase_info;\n+pub type pthread_key_t = c_ulong;\n+pub type sigset_t = u32;\n+pub type fsblkcnt_t = ::c_uint;\n+pub type fsfilcnt_t = ::c_uint;\n+pub type speed_t = ::c_ulong;\n+pub type tcflag_t = ::c_ulong;\n+pub type nl_item = ::c_int;\n+pub type id_t = ::c_uint;\n+pub type sem_t = ::c_int;\n+\n+pub enum timezone {}\n+\n+s! {\n+    pub struct utmpx {\n+        pub ut_user: [::c_char; _UTX_USERSIZE],\n+        pub ut_id: [::c_char; _UTX_IDSIZE],\n+        pub ut_line: [::c_char; _UTX_LINESIZE],\n+        pub ut_pid: ::pid_t,\n+        pub ut_type: ::c_short,\n+        pub ut_tv: ::timeval,\n+        pub ut_host: [::c_char; _UTX_HOSTSIZE],\n+        ut_pad: [::uint32_t; 16],\n+    }\n+\n+    pub struct glob_t {\n+        pub gl_pathc:  ::size_t,\n+        __unused1: ::c_int,\n+        pub gl_offs:   ::size_t,\n+        __unused2: ::c_int,\n+        pub gl_pathv:  *mut *mut ::c_char,\n+\n+        __unused3: *mut ::c_void,\n+\n+        __unused4: *mut ::c_void,\n+        __unused5: *mut ::c_void,\n+        __unused6: *mut ::c_void,\n+        __unused7: *mut ::c_void,\n+        __unused8: *mut ::c_void,\n+    }\n+\n+    pub struct sockaddr_storage {\n+        pub ss_len: u8,\n+        pub ss_family: ::sa_family_t,\n+        __ss_pad1: [u8; 6],\n+        __ss_align: i64,\n+        __ss_pad2: [u8; 112],\n+    }\n+\n+    pub struct addrinfo {\n+        pub ai_flags: ::c_int,\n+        pub ai_family: ::c_int,\n+        pub ai_socktype: ::c_int,\n+        pub ai_protocol: ::c_int,\n+        pub ai_addrlen: ::socklen_t,\n+        pub ai_canonname: *mut ::c_char,\n+        pub ai_addr: *mut ::sockaddr,\n+        pub ai_next: *mut addrinfo,\n+    }\n+\n+    pub struct mach_timebase_info {\n+        pub numer: u32,\n+        pub denom: u32,\n+    }\n+\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_ino: ino_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: dev_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_birthtime: time_t,\n+        pub st_birthtime_nsec: c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: blksize_t,\n+        pub st_flags: ::uint32_t,\n+        pub st_gen: ::uint32_t,\n+        pub st_lspare: ::int32_t,\n+        pub st_qspare: [::int64_t; 2],\n+    }\n+\n+    pub struct dirent {\n+        pub d_ino: u64,\n+        pub d_seekoff: u64,\n+        pub d_reclen: u16,\n+        pub d_namlen: u16,\n+        pub d_type: u8,\n+        pub d_name: [::c_char; 1024],\n+    }\n+\n+    pub struct pthread_mutex_t {\n+        __sig: ::c_long,\n+        __opaque: [u8; __PTHREAD_MUTEX_SIZE__],\n+    }\n+\n+    pub struct pthread_mutexattr_t {\n+        __sig: ::c_long,\n+        __opaque: [u8; 8],\n+    }\n+\n+    pub struct pthread_cond_t {\n+        __sig: ::c_long,\n+        __opaque: [u8; __PTHREAD_COND_SIZE__],\n+    }\n+\n+    pub struct pthread_condattr_t {\n+        __sig: ::c_long,\n+        __opaque: [u8; __PTHREAD_CONDATTR_SIZE__],\n+    }\n+\n+    pub struct pthread_rwlock_t {\n+        __sig: ::c_long,\n+        __opaque: [u8; __PTHREAD_RWLOCK_SIZE__],\n+    }\n+\n+    pub struct siginfo_t {\n+        pub si_signo: ::c_int,\n+        pub si_errno: ::c_int,\n+        pub si_code: ::c_int,\n+        pub si_pid: ::pid_t,\n+        pub si_uid: ::uid_t,\n+        pub si_status: ::c_int,\n+        pub si_addr: *mut ::c_void,\n+        _pad: [usize; 9],\n+    }\n+\n+    pub struct sigaction {\n+        pub sa_sigaction: ::sighandler_t,\n+        pub sa_mask: sigset_t,\n+        pub sa_flags: ::c_int,\n+    }\n+\n+    pub struct stack_t {\n+        pub ss_sp: *mut ::c_void,\n+        pub ss_size: ::size_t,\n+        pub ss_flags: ::c_int,\n+    }\n+\n+    pub struct fstore_t {\n+        pub fst_flags: ::c_uint,\n+        pub fst_posmode: ::c_int,\n+        pub fst_offset: ::off_t,\n+        pub fst_length: ::off_t,\n+        pub fst_bytesalloc: ::off_t,\n+    }\n+\n+    pub struct radvisory {\n+        pub ra_offset: ::off_t,\n+        pub ra_count: ::c_int,\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bsize: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_fsid: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+    }\n+\n+    pub struct Dl_info {\n+        pub dli_fname: *const ::c_char,\n+        pub dli_fbase: *mut ::c_void,\n+        pub dli_sname: *const ::c_char,\n+        pub dli_saddr: *mut ::c_void,\n+    }\n+\n+    pub struct sockaddr_in {\n+        pub sin_len: u8,\n+        pub sin_family: ::sa_family_t,\n+        pub sin_port: ::in_port_t,\n+        pub sin_addr: ::in_addr,\n+        pub sin_zero: [::c_char; 8],\n+    }\n+\n+    pub struct statfs {\n+        pub f_bsize: ::uint32_t,\n+        pub f_iosize: ::int32_t,\n+        pub f_blocks: ::uint64_t,\n+        pub f_bfree: ::uint64_t,\n+        pub f_bavail: ::uint64_t,\n+        pub f_files: ::uint64_t,\n+        pub f_ffree: ::uint64_t,\n+        pub f_fsid: ::fsid_t,\n+        pub f_owner: ::uid_t,\n+        pub f_type: ::uint32_t,\n+        pub f_flags: ::uint32_t,\n+        pub f_fssubtype: ::uint32_t,\n+        pub f_fstypename: [::c_char; 16],\n+        pub f_mntonname: [::c_char; 1024],\n+        pub f_mntfromname: [::c_char; 1024],\n+        pub f_reserved: [::uint32_t; 8],\n+    }\n+\n+    // FIXME: this should have align 4 but it's got align 8 on 64-bit\n+    pub struct kevent {\n+        pub ident: ::uintptr_t,\n+        pub filter: ::int16_t,\n+        pub flags: ::uint16_t,\n+        pub fflags: ::uint32_t,\n+        pub data: ::intptr_t,\n+        pub udata: *mut ::c_void,\n+    }\n+\n+    pub struct kevent64_s {\n+        pub ident: ::uint64_t,\n+        pub filter: ::int16_t,\n+        pub flags: ::uint16_t,\n+        pub fflags: ::uint32_t,\n+        pub data: ::int64_t,\n+        pub udata: ::uint64_t,\n+        pub ext: [::uint64_t; 2],\n+    }\n+\n+    pub struct dqblk {\n+        pub dqb_bhardlimit: ::uint64_t,\n+        pub dqb_bsoftlimit: ::uint64_t,\n+        pub dqb_curbytes: ::uint64_t,\n+        pub dqb_ihardlimit: ::uint32_t,\n+        pub dqb_isoftlimit: ::uint32_t,\n+        pub dqb_curinodes: ::uint32_t,\n+        pub dqb_btime: ::uint32_t,\n+        pub dqb_itime: ::uint32_t,\n+        pub dqb_id: ::uint32_t,\n+        pub dqb_spare: [::uint32_t; 4],\n+    }\n+\n+    pub struct termios {\n+        pub c_iflag: ::tcflag_t,\n+        pub c_oflag: ::tcflag_t,\n+        pub c_cflag: ::tcflag_t,\n+        pub c_lflag: ::tcflag_t,\n+        pub c_cc: [::cc_t; ::NCCS],\n+        pub c_ispeed: ::speed_t,\n+        pub c_ospeed: ::speed_t,\n+    }\n+\n+    pub struct flock {\n+        pub l_start: ::off_t,\n+        pub l_len: ::off_t,\n+        pub l_pid: ::pid_t,\n+        pub l_type: ::c_short,\n+        pub l_whence: ::c_short,\n+    }\n+\n+    pub struct sf_hdtr {\n+        pub headers: *mut ::iovec,\n+        pub hdr_cnt: ::c_int,\n+        pub trailers: *mut ::iovec,\n+        pub trl_cnt: ::c_int,\n+    }\n+\n+    pub struct lconv {\n+        pub decimal_point: *mut ::c_char,\n+        pub thousands_sep: *mut ::c_char,\n+        pub grouping: *mut ::c_char,\n+        pub int_curr_symbol: *mut ::c_char,\n+        pub currency_symbol: *mut ::c_char,\n+        pub mon_decimal_point: *mut ::c_char,\n+        pub mon_thousands_sep: *mut ::c_char,\n+        pub mon_grouping: *mut ::c_char,\n+        pub positive_sign: *mut ::c_char,\n+        pub negative_sign: *mut ::c_char,\n+        pub int_frac_digits: ::c_char,\n+        pub frac_digits: ::c_char,\n+        pub p_cs_precedes: ::c_char,\n+        pub p_sep_by_space: ::c_char,\n+        pub n_cs_precedes: ::c_char,\n+        pub n_sep_by_space: ::c_char,\n+        pub p_sign_posn: ::c_char,\n+        pub n_sign_posn: ::c_char,\n+        pub int_p_cs_precedes: ::c_char,\n+        pub int_n_cs_precedes: ::c_char,\n+        pub int_p_sep_by_space: ::c_char,\n+        pub int_n_sep_by_space: ::c_char,\n+        pub int_p_sign_posn: ::c_char,\n+        pub int_n_sign_posn: ::c_char,\n+    }\n+}\n+\n+pub const _UTX_USERSIZE: usize = 256;\n+pub const _UTX_LINESIZE: usize = 32;\n+pub const _UTX_IDSIZE: usize = 4;\n+pub const _UTX_HOSTSIZE: usize = 256;\n+\n+pub const EMPTY: ::c_short = 0;\n+pub const RUN_LVL: ::c_short = 1;\n+pub const BOOT_TIME: ::c_short = 2;\n+pub const OLD_TIME: ::c_short = 3;\n+pub const NEW_TIME: ::c_short = 4;\n+pub const INIT_PROCESS: ::c_short = 5;\n+pub const LOGIN_PROCESS: ::c_short = 6;\n+pub const USER_PROCESS: ::c_short = 7;\n+pub const DEAD_PROCESS: ::c_short = 8;\n+pub const ACCOUNTING: ::c_short = 9;\n+pub const SIGNATURE: ::c_short = 10;\n+pub const SHUTDOWN_TIME: ::c_short = 11;\n+\n+pub const LC_COLLATE_MASK: ::c_int = (1 << 0);\n+pub const LC_CTYPE_MASK: ::c_int = (1 << 1);\n+pub const LC_MESSAGES_MASK: ::c_int = (1 << 2);\n+pub const LC_MONETARY_MASK: ::c_int = (1 << 3);\n+pub const LC_NUMERIC_MASK: ::c_int = (1 << 4);\n+pub const LC_TIME_MASK: ::c_int = (1 << 5);\n+pub const LC_ALL_MASK: ::c_int = LC_COLLATE_MASK\n+                               | LC_CTYPE_MASK\n+                               | LC_MESSAGES_MASK\n+                               | LC_MONETARY_MASK\n+                               | LC_NUMERIC_MASK\n+                               | LC_TIME_MASK;\n+\n+pub const CODESET: ::nl_item = 0;\n+pub const D_T_FMT: ::nl_item = 1;\n+pub const D_FMT: ::nl_item = 2;\n+pub const T_FMT: ::nl_item = 3;\n+pub const T_FMT_AMPM: ::nl_item = 4;\n+pub const AM_STR: ::nl_item = 5;\n+pub const PM_STR: ::nl_item = 6;\n+\n+pub const DAY_1: ::nl_item = 7;\n+pub const DAY_2: ::nl_item = 8;\n+pub const DAY_3: ::nl_item = 9;\n+pub const DAY_4: ::nl_item = 10;\n+pub const DAY_5: ::nl_item = 11;\n+pub const DAY_6: ::nl_item = 12;\n+pub const DAY_7: ::nl_item = 13;\n+\n+pub const ABDAY_1: ::nl_item = 14;\n+pub const ABDAY_2: ::nl_item = 15;\n+pub const ABDAY_3: ::nl_item = 16;\n+pub const ABDAY_4: ::nl_item = 17;\n+pub const ABDAY_5: ::nl_item = 18;\n+pub const ABDAY_6: ::nl_item = 19;\n+pub const ABDAY_7: ::nl_item = 20;\n+\n+pub const MON_1: ::nl_item = 21;\n+pub const MON_2: ::nl_item = 22;\n+pub const MON_3: ::nl_item = 23;\n+pub const MON_4: ::nl_item = 24;\n+pub const MON_5: ::nl_item = 25;\n+pub const MON_6: ::nl_item = 26;\n+pub const MON_7: ::nl_item = 27;\n+pub const MON_8: ::nl_item = 28;\n+pub const MON_9: ::nl_item = 29;\n+pub const MON_10: ::nl_item = 30;\n+pub const MON_11: ::nl_item = 31;\n+pub const MON_12: ::nl_item = 32;\n+\n+pub const ABMON_1: ::nl_item = 33;\n+pub const ABMON_2: ::nl_item = 34;\n+pub const ABMON_3: ::nl_item = 35;\n+pub const ABMON_4: ::nl_item = 36;\n+pub const ABMON_5: ::nl_item = 37;\n+pub const ABMON_6: ::nl_item = 38;\n+pub const ABMON_7: ::nl_item = 39;\n+pub const ABMON_8: ::nl_item = 40;\n+pub const ABMON_9: ::nl_item = 41;\n+pub const ABMON_10: ::nl_item = 42;\n+pub const ABMON_11: ::nl_item = 43;\n+pub const ABMON_12: ::nl_item = 44;\n+\n+pub const ERA: ::nl_item = 45;\n+pub const ERA_D_FMT: ::nl_item = 46;\n+pub const ERA_D_T_FMT: ::nl_item = 47;\n+pub const ERA_T_FMT: ::nl_item = 48;\n+pub const ALT_DIGITS: ::nl_item = 49;\n+\n+pub const RADIXCHAR: ::nl_item = 50;\n+pub const THOUSEP: ::nl_item = 51;\n+\n+pub const YESEXPR: ::nl_item = 52;\n+pub const NOEXPR: ::nl_item = 53;\n+\n+pub const YESSTR: ::nl_item = 54;\n+pub const NOSTR: ::nl_item = 55;\n+\n+pub const CRNCYSTR: ::nl_item = 56;\n+\n+pub const D_MD_ORDER: ::nl_item = 57;\n+\n+pub const EXIT_FAILURE: ::c_int = 1;\n+pub const EXIT_SUCCESS: ::c_int = 0;\n+pub const RAND_MAX: ::c_int = 2147483647;\n+pub const EOF: ::c_int = -1;\n+pub const SEEK_SET: ::c_int = 0;\n+pub const SEEK_CUR: ::c_int = 1;\n+pub const SEEK_END: ::c_int = 2;\n+pub const _IOFBF: ::c_int = 0;\n+pub const _IONBF: ::c_int = 2;\n+pub const _IOLBF: ::c_int = 1;\n+pub const BUFSIZ: ::c_uint = 1024;\n+pub const FOPEN_MAX: ::c_uint = 20;\n+pub const FILENAME_MAX: ::c_uint = 1024;\n+pub const L_tmpnam: ::c_uint = 1024;\n+pub const TMP_MAX: ::c_uint = 308915776;\n+pub const _PC_LINK_MAX: ::c_int = 1;\n+pub const _PC_MAX_CANON: ::c_int = 2;\n+pub const _PC_MAX_INPUT: ::c_int = 3;\n+pub const _PC_NAME_MAX: ::c_int = 4;\n+pub const _PC_PATH_MAX: ::c_int = 5;\n+pub const _PC_PIPE_BUF: ::c_int = 6;\n+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;\n+pub const _PC_NO_TRUNC: ::c_int = 8;\n+pub const _PC_VDISABLE: ::c_int = 9;\n+pub const O_RDONLY: ::c_int = 0;\n+pub const O_WRONLY: ::c_int = 1;\n+pub const O_RDWR: ::c_int = 2;\n+pub const O_APPEND: ::c_int = 8;\n+pub const O_CREAT: ::c_int = 512;\n+pub const O_EXCL: ::c_int = 2048;\n+pub const O_NOCTTY: ::c_int = 131072;\n+pub const O_TRUNC: ::c_int = 1024;\n+pub const O_CLOEXEC: ::c_int = 0x1000000;\n+pub const O_DIRECTORY: ::c_int = 0x100000;\n+pub const S_IFIFO: mode_t = 4096;\n+pub const S_IFCHR: mode_t = 8192;\n+pub const S_IFBLK: mode_t = 24576;\n+pub const S_IFDIR: mode_t = 16384;\n+pub const S_IFREG: mode_t = 32768;\n+pub const S_IFLNK: mode_t = 40960;\n+pub const S_IFSOCK: mode_t = 49152;\n+pub const S_IFMT: mode_t = 61440;\n+pub const S_IEXEC: mode_t = 64;\n+pub const S_IWRITE: mode_t = 128;\n+pub const S_IREAD: mode_t = 256;\n+pub const S_IRWXU: mode_t = 448;\n+pub const S_IXUSR: mode_t = 64;\n+pub const S_IWUSR: mode_t = 128;\n+pub const S_IRUSR: mode_t = 256;\n+pub const S_IRWXG: mode_t = 56;\n+pub const S_IXGRP: mode_t = 8;\n+pub const S_IWGRP: mode_t = 16;\n+pub const S_IRGRP: mode_t = 32;\n+pub const S_IRWXO: mode_t = 7;\n+pub const S_IXOTH: mode_t = 1;\n+pub const S_IWOTH: mode_t = 2;\n+pub const S_IROTH: mode_t = 4;\n+pub const F_OK: ::c_int = 0;\n+pub const R_OK: ::c_int = 4;\n+pub const W_OK: ::c_int = 2;\n+pub const X_OK: ::c_int = 1;\n+pub const STDIN_FILENO: ::c_int = 0;\n+pub const STDOUT_FILENO: ::c_int = 1;\n+pub const STDERR_FILENO: ::c_int = 2;\n+pub const F_LOCK: ::c_int = 1;\n+pub const F_TEST: ::c_int = 3;\n+pub const F_TLOCK: ::c_int = 2;\n+pub const F_ULOCK: ::c_int = 0;\n+pub const F_GETLK: ::c_int = 7;\n+pub const F_SETLK: ::c_int = 8;\n+pub const F_SETLKW: ::c_int = 9;\n+pub const SIGHUP: ::c_int = 1;\n+pub const SIGINT: ::c_int = 2;\n+pub const SIGQUIT: ::c_int = 3;\n+pub const SIGILL: ::c_int = 4;\n+pub const SIGABRT: ::c_int = 6;\n+pub const SIGEMT: ::c_int = 7;\n+pub const SIGFPE: ::c_int = 8;\n+pub const SIGKILL: ::c_int = 9;\n+pub const SIGSEGV: ::c_int = 11;\n+pub const SIGPIPE: ::c_int = 13;\n+pub const SIGALRM: ::c_int = 14;\n+pub const SIGTERM: ::c_int = 15;\n+\n+pub const PROT_NONE: ::c_int = 0;\n+pub const PROT_READ: ::c_int = 1;\n+pub const PROT_WRITE: ::c_int = 2;\n+pub const PROT_EXEC: ::c_int = 4;\n+\n+pub const MAP_FILE: ::c_int = 0x0000;\n+pub const MAP_SHARED: ::c_int = 0x0001;\n+pub const MAP_PRIVATE: ::c_int = 0x0002;\n+pub const MAP_FIXED: ::c_int = 0x0010;\n+pub const MAP_ANON: ::c_int = 0x1000;\n+\n+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;\n+\n+pub const MCL_CURRENT: ::c_int = 0x0001;\n+pub const MCL_FUTURE: ::c_int = 0x0002;\n+\n+pub const MS_ASYNC: ::c_int = 0x0001;\n+pub const MS_INVALIDATE: ::c_int = 0x0002;\n+pub const MS_SYNC: ::c_int = 0x0010;\n+\n+pub const MS_KILLPAGES: ::c_int = 0x0004;\n+pub const MS_DEACTIVATE: ::c_int = 0x0008;\n+\n+pub const EPERM: ::c_int = 1;\n+pub const ENOENT: ::c_int = 2;\n+pub const ESRCH: ::c_int = 3;\n+pub const EINTR: ::c_int = 4;\n+pub const EIO: ::c_int = 5;\n+pub const ENXIO: ::c_int = 6;\n+pub const E2BIG: ::c_int = 7;\n+pub const ENOEXEC: ::c_int = 8;\n+pub const EBADF: ::c_int = 9;\n+pub const ECHILD: ::c_int = 10;\n+pub const EDEADLK: ::c_int = 11;\n+pub const ENOMEM: ::c_int = 12;\n+pub const EACCES: ::c_int = 13;\n+pub const EFAULT: ::c_int = 14;\n+pub const ENOTBLK: ::c_int = 15;\n+pub const EBUSY: ::c_int = 16;\n+pub const EEXIST: ::c_int = 17;\n+pub const EXDEV: ::c_int = 18;\n+pub const ENODEV: ::c_int = 19;\n+pub const ENOTDIR: ::c_int = 20;\n+pub const EISDIR: ::c_int = 21;\n+pub const EINVAL: ::c_int = 22;\n+pub const ENFILE: ::c_int = 23;\n+pub const EMFILE: ::c_int = 24;\n+pub const ENOTTY: ::c_int = 25;\n+pub const ETXTBSY: ::c_int = 26;\n+pub const EFBIG: ::c_int = 27;\n+pub const ENOSPC: ::c_int = 28;\n+pub const ESPIPE: ::c_int = 29;\n+pub const EROFS: ::c_int = 30;\n+pub const EMLINK: ::c_int = 31;\n+pub const EPIPE: ::c_int = 32;\n+pub const EDOM: ::c_int = 33;\n+pub const ERANGE: ::c_int = 34;\n+pub const EAGAIN: ::c_int = 35;\n+pub const EWOULDBLOCK: ::c_int = EAGAIN;\n+pub const EINPROGRESS: ::c_int = 36;\n+pub const EALREADY: ::c_int = 37;\n+pub const ENOTSOCK: ::c_int = 38;\n+pub const EDESTADDRREQ: ::c_int = 39;\n+pub const EMSGSIZE: ::c_int = 40;\n+pub const EPROTOTYPE: ::c_int = 41;\n+pub const ENOPROTOOPT: ::c_int = 42;\n+pub const EPROTONOSUPPORT: ::c_int = 43;\n+pub const ESOCKTNOSUPPORT: ::c_int = 44;\n+pub const ENOTSUP: ::c_int = 45;\n+pub const EPFNOSUPPORT: ::c_int = 46;\n+pub const EAFNOSUPPORT: ::c_int = 47;\n+pub const EADDRINUSE: ::c_int = 48;\n+pub const EADDRNOTAVAIL: ::c_int = 49;\n+pub const ENETDOWN: ::c_int = 50;\n+pub const ENETUNREACH: ::c_int = 51;\n+pub const ENETRESET: ::c_int = 52;\n+pub const ECONNABORTED: ::c_int = 53;\n+pub const ECONNRESET: ::c_int = 54;\n+pub const ENOBUFS: ::c_int = 55;\n+pub const EISCONN: ::c_int = 56;\n+pub const ENOTCONN: ::c_int = 57;\n+pub const ESHUTDOWN: ::c_int = 58;\n+pub const ETOOMANYREFS: ::c_int = 59;\n+pub const ETIMEDOUT: ::c_int = 60;\n+pub const ECONNREFUSED: ::c_int = 61;\n+pub const ELOOP: ::c_int = 62;\n+pub const ENAMETOOLONG: ::c_int = 63;\n+pub const EHOSTDOWN: ::c_int = 64;\n+pub const EHOSTUNREACH: ::c_int = 65;\n+pub const ENOTEMPTY: ::c_int = 66;\n+pub const EPROCLIM: ::c_int = 67;\n+pub const EUSERS: ::c_int = 68;\n+pub const EDQUOT: ::c_int = 69;\n+pub const ESTALE: ::c_int = 70;\n+pub const EREMOTE: ::c_int = 71;\n+pub const EBADRPC: ::c_int = 72;\n+pub const ERPCMISMATCH: ::c_int = 73;\n+pub const EPROGUNAVAIL: ::c_int = 74;\n+pub const EPROGMISMATCH: ::c_int = 75;\n+pub const EPROCUNAVAIL: ::c_int = 76;\n+pub const ENOLCK: ::c_int = 77;\n+pub const ENOSYS: ::c_int = 78;\n+pub const EFTYPE: ::c_int = 79;\n+pub const EAUTH: ::c_int = 80;\n+pub const ENEEDAUTH: ::c_int = 81;\n+pub const EPWROFF: ::c_int = 82;\n+pub const EDEVERR: ::c_int = 83;\n+pub const EOVERFLOW: ::c_int = 84;\n+pub const EBADEXEC: ::c_int = 85;\n+pub const EBADARCH: ::c_int = 86;\n+pub const ESHLIBVERS: ::c_int = 87;\n+pub const EBADMACHO: ::c_int = 88;\n+pub const ECANCELED: ::c_int = 89;\n+pub const EIDRM: ::c_int = 90;\n+pub const ENOMSG: ::c_int = 91;\n+pub const EILSEQ: ::c_int = 92;\n+pub const ENOATTR: ::c_int = 93;\n+pub const EBADMSG: ::c_int = 94;\n+pub const EMULTIHOP: ::c_int = 95;\n+pub const ENODATA: ::c_int = 96;\n+pub const ENOLINK: ::c_int = 97;\n+pub const ENOSR: ::c_int = 98;\n+pub const ENOSTR: ::c_int = 99;\n+pub const EPROTO: ::c_int = 100;\n+pub const ETIME: ::c_int = 101;\n+pub const EOPNOTSUPP: ::c_int = 102;\n+pub const ENOPOLICY: ::c_int = 103;\n+pub const ENOTRECOVERABLE: ::c_int = 104;\n+pub const EOWNERDEAD: ::c_int = 105;\n+pub const EQFULL: ::c_int = 106;\n+pub const ELAST: ::c_int = 106;\n+\n+pub const EAI_SYSTEM: ::c_int = 11;\n+\n+pub const F_DUPFD: ::c_int = 0;\n+pub const F_DUPFD_CLOEXEC: ::c_int = 67;\n+pub const F_GETFD: ::c_int = 1;\n+pub const F_SETFD: ::c_int = 2;\n+pub const F_GETFL: ::c_int = 3;\n+pub const F_SETFL: ::c_int = 4;\n+pub const F_PREALLOCATE: ::c_int = 42;\n+pub const F_RDADVISE: ::c_int = 44;\n+pub const F_RDAHEAD: ::c_int = 45;\n+pub const F_NOCACHE: ::c_int = 48;\n+pub const F_GETPATH: ::c_int = 50;\n+pub const F_FULLFSYNC: ::c_int = 51;\n+pub const F_FREEZE_FS: ::c_int = 53;\n+pub const F_THAW_FS: ::c_int = 54;\n+pub const F_GLOBAL_NOCACHE: ::c_int = 55;\n+pub const F_NODIRECT: ::c_int = 62;\n+\n+pub const F_ALLOCATECONTIG: ::c_uint = 0x02;\n+pub const F_ALLOCATEALL: ::c_uint = 0x04;\n+\n+pub const F_PEOFPOSMODE: ::c_int = 3;\n+pub const F_VOLPOSMODE: ::c_int = 4;\n+\n+pub const O_ACCMODE: ::c_int = 3;\n+\n+pub const TIOCMODG: ::c_ulong = 0x40047403;\n+pub const TIOCMODS: ::c_ulong = 0x80047404;\n+pub const TIOCM_LE: ::c_int = 0x1;\n+pub const TIOCM_DTR: ::c_int = 0x2;\n+pub const TIOCM_RTS: ::c_int = 0x4;\n+pub const TIOCM_ST: ::c_int = 0x8;\n+pub const TIOCM_SR: ::c_int = 0x10;\n+pub const TIOCM_CTS: ::c_int = 0x20;\n+pub const TIOCM_CAR: ::c_int = 0x40;\n+pub const TIOCM_CD: ::c_int = 0x40;\n+pub const TIOCM_RNG: ::c_int = 0x80;\n+pub const TIOCM_RI: ::c_int = 0x80;\n+pub const TIOCM_DSR: ::c_int = 0x100;\n+pub const TIOCEXCL: ::c_int = 0x2000740d;\n+pub const TIOCNXCL: ::c_int = 0x2000740e;\n+pub const TIOCFLUSH: ::c_ulong = 0x80047410;\n+pub const TIOCGETD: ::c_ulong = 0x4004741a;\n+pub const TIOCSETD: ::c_ulong = 0x8004741b;\n+pub const TIOCIXON: ::c_uint = 0x20007481;\n+pub const TIOCIXOFF: ::c_uint = 0x20007480;\n+pub const TIOCSBRK: ::c_uint = 0x2000747b;\n+pub const TIOCCBRK: ::c_uint = 0x2000747a;\n+pub const TIOCSDTR: ::c_uint = 0x20007479;\n+pub const TIOCCDTR: ::c_uint = 0x20007478;\n+pub const TIOCGPGRP: ::c_ulong = 0x40047477;\n+pub const TIOCSPGRP: ::c_ulong = 0x80047476;\n+pub const TIOCOUTQ: ::c_ulong = 0x40047473;\n+pub const TIOCSTI: ::c_ulong = 0x80017472;\n+pub const TIOCNOTTY: ::c_uint = 0x20007471;\n+pub const TIOCPKT: ::c_ulong = 0x80047470;\n+pub const TIOCPKT_DATA: ::c_int = 0x0;\n+pub const TIOCPKT_FLUSHREAD: ::c_int = 0x1;\n+pub const TIOCPKT_FLUSHWRITE: ::c_int = 0x2;\n+pub const TIOCPKT_STOP: ::c_int = 0x4;\n+pub const TIOCPKT_START: ::c_int = 0x8;\n+pub const TIOCPKT_NOSTOP: ::c_int = 0x10;\n+pub const TIOCPKT_DOSTOP: ::c_int = 0x20;\n+pub const TIOCPKT_IOCTL: ::c_int = 0x40;\n+pub const TIOCSTOP: ::c_uint = 0x2000746f;\n+pub const TIOCSTART: ::c_uint = 0x2000746e;\n+pub const TIOCMSET: ::c_ulong = 0x8004746d;\n+pub const TIOCMBIS: ::c_ulong = 0x8004746c;\n+pub const TIOCMBIC: ::c_ulong = 0x8004746b;\n+pub const TIOCMGET: ::c_ulong = 0x4004746a;\n+pub const TIOCREMOTE: ::c_ulong = 0x80047469;\n+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;\n+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;\n+pub const TIOCUCNTL: ::c_ulong = 0x80047466;\n+pub const TIOCSTAT: ::c_uint = 0x20007465;\n+pub const TIOCSCONS: ::c_uint = 0x20007463;\n+pub const TIOCCONS: ::c_ulong = 0x80047462;\n+pub const TIOCSCTTY: ::c_uint = 0x20007461;\n+pub const TIOCEXT: ::c_ulong = 0x80047460;\n+pub const TIOCSIG: ::c_uint = 0x2000745f;\n+pub const TIOCDRAIN: ::c_uint = 0x2000745e;\n+pub const TIOCMSDTRWAIT: ::c_ulong = 0x8004745b;\n+pub const TIOCMGDTRWAIT: ::c_ulong = 0x4004745a;\n+pub const TIOCSDRAINWAIT: ::c_ulong = 0x80047457;\n+pub const TIOCGDRAINWAIT: ::c_ulong = 0x40047456;\n+pub const TIOCDSIMICROCODE: ::c_uint = 0x20007455;\n+pub const TIOCPTYGRANT: ::c_uint = 0x20007454;\n+pub const TIOCPTYGNAME: ::c_uint = 0x40807453;\n+pub const TIOCPTYUNLK: ::c_uint = 0x20007452;\n+\n+pub const SIGTRAP: ::c_int = 5;\n+\n+pub const GLOB_APPEND  : ::c_int = 0x0001;\n+pub const GLOB_DOOFFS  : ::c_int = 0x0002;\n+pub const GLOB_ERR     : ::c_int = 0x0004;\n+pub const GLOB_MARK    : ::c_int = 0x0008;\n+pub const GLOB_NOCHECK : ::c_int = 0x0010;\n+pub const GLOB_NOSORT  : ::c_int = 0x0020;\n+pub const GLOB_NOESCAPE: ::c_int = 0x2000;\n+\n+pub const GLOB_NOSPACE : ::c_int = -1;\n+pub const GLOB_ABORTED : ::c_int = -2;\n+pub const GLOB_NOMATCH : ::c_int = -3;\n+\n+pub const POSIX_MADV_NORMAL: ::c_int = 0;\n+pub const POSIX_MADV_RANDOM: ::c_int = 1;\n+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;\n+pub const POSIX_MADV_WILLNEED: ::c_int = 3;\n+pub const POSIX_MADV_DONTNEED: ::c_int = 4;\n+\n+pub const _SC_IOV_MAX: ::c_int = 56;\n+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 70;\n+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 71;\n+pub const _SC_LOGIN_NAME_MAX: ::c_int = 73;\n+pub const _SC_MQ_PRIO_MAX: ::c_int = 75;\n+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 82;\n+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 83;\n+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 85;\n+pub const _SC_THREAD_KEYS_MAX: ::c_int = 86;\n+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 87;\n+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 88;\n+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 89;\n+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 90;\n+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 91;\n+pub const _SC_THREAD_STACK_MIN: ::c_int = 93;\n+pub const _SC_THREAD_THREADS_MAX: ::c_int = 94;\n+pub const _SC_THREADS: ::c_int = 96;\n+pub const _SC_TTY_NAME_MAX: ::c_int = 101;\n+pub const _SC_ATEXIT_MAX: ::c_int = 107;\n+pub const _SC_XOPEN_CRYPT: ::c_int = 108;\n+pub const _SC_XOPEN_ENH_I18N: ::c_int = 109;\n+pub const _SC_XOPEN_LEGACY: ::c_int = 110;\n+pub const _SC_XOPEN_REALTIME: ::c_int = 111;\n+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 112;\n+pub const _SC_XOPEN_SHM: ::c_int = 113;\n+pub const _SC_XOPEN_UNIX: ::c_int = 115;\n+pub const _SC_XOPEN_VERSION: ::c_int = 116;\n+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 121;\n+\n+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 1;\n+pub const PTHREAD_CREATE_DETACHED: ::c_int = 2;\n+pub const PTHREAD_STACK_MIN: ::size_t = 8192;\n+\n+pub const RLIMIT_CPU: ::c_int = 0;\n+pub const RLIMIT_FSIZE: ::c_int = 1;\n+pub const RLIMIT_DATA: ::c_int = 2;\n+pub const RLIMIT_STACK: ::c_int = 3;\n+pub const RLIMIT_CORE: ::c_int = 4;\n+pub const RLIMIT_AS: ::c_int = 5;\n+pub const RLIMIT_RSS: ::c_int = RLIMIT_AS;\n+pub const RLIMIT_MEMLOCK: ::c_int = 6;\n+pub const RLIMIT_NPROC: ::c_int = 7;\n+pub const RLIMIT_NOFILE: ::c_int = 8;\n+pub const RLIM_NLIMITS: ::c_int = 9;\n+pub const _RLIMIT_POSIX_FLAG: ::c_int = 0x1000;\n+\n+pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;\n+\n+pub const RUSAGE_SELF: ::c_int = 0;\n+pub const RUSAGE_CHILDREN: ::c_int = -1;\n+\n+pub const MADV_NORMAL: ::c_int = 0;\n+pub const MADV_RANDOM: ::c_int = 1;\n+pub const MADV_SEQUENTIAL: ::c_int = 2;\n+pub const MADV_WILLNEED: ::c_int = 3;\n+pub const MADV_DONTNEED: ::c_int = 4;\n+pub const MADV_FREE: ::c_int = 5;\n+pub const MADV_ZERO_WIRED_PAGES: ::c_int = 6;\n+pub const MADV_FREE_REUSABLE: ::c_int = 7;\n+pub const MADV_FREE_REUSE: ::c_int = 8;\n+pub const MADV_CAN_REUSE: ::c_int = 9;\n+\n+pub const MINCORE_INCORE: ::c_int =  0x1;\n+pub const MINCORE_REFERENCED: ::c_int = 0x2;\n+pub const MINCORE_MODIFIED: ::c_int = 0x4;\n+pub const MINCORE_REFERENCED_OTHER: ::c_int = 0x8;\n+pub const MINCORE_MODIFIED_OTHER: ::c_int = 0x10;\n+\n+pub const AF_UNIX: ::c_int = 1;\n+pub const AF_INET: ::c_int = 2;\n+pub const AF_INET6: ::c_int = 30;\n+pub const SOCK_STREAM: ::c_int = 1;\n+pub const SOCK_DGRAM: ::c_int = 2;\n+pub const SOCK_RAW: ::c_int = 3;\n+pub const SOCK_SEQPACKET: ::c_int = 5;\n+pub const IPPROTO_TCP: ::c_int = 6;\n+pub const IPPROTO_IP: ::c_int = 0;\n+pub const IPPROTO_IPV6: ::c_int = 41;\n+pub const IP_MULTICAST_TTL: ::c_int = 10;\n+pub const IP_MULTICAST_LOOP: ::c_int = 11;\n+pub const IP_TTL: ::c_int = 4;\n+pub const IP_HDRINCL: ::c_int = 2;\n+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;\n+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;\n+pub const IPV6_JOIN_GROUP: ::c_int = 12;\n+pub const IPV6_LEAVE_GROUP: ::c_int = 13;\n+\n+pub const TCP_NODELAY: ::c_int = 0x01;\n+pub const TCP_KEEPALIVE: ::c_int = 0x10;\n+pub const SOL_SOCKET: ::c_int = 0xffff;\n+\n+pub const SO_DEBUG: ::c_int = 0x01;\n+pub const SO_ACCEPTCONN: ::c_int = 0x0002;\n+pub const SO_REUSEADDR: ::c_int = 0x0004;\n+pub const SO_KEEPALIVE: ::c_int = 0x0008;\n+pub const SO_DONTROUTE: ::c_int = 0x0010;\n+pub const SO_BROADCAST: ::c_int = 0x0020;\n+pub const SO_USELOOPBACK: ::c_int = 0x0040;\n+pub const SO_LINGER: ::c_int = 0x0080;\n+pub const SO_OOBINLINE: ::c_int = 0x0100;\n+pub const SO_REUSEPORT: ::c_int = 0x0200;\n+pub const SO_SNDBUF: ::c_int = 0x1001;\n+pub const SO_RCVBUF: ::c_int = 0x1002;\n+pub const SO_SNDLOWAT: ::c_int = 0x1003;\n+pub const SO_RCVLOWAT: ::c_int = 0x1004;\n+pub const SO_SNDTIMEO: ::c_int = 0x1005;\n+pub const SO_RCVTIMEO: ::c_int = 0x1006;\n+pub const SO_ERROR: ::c_int = 0x1007;\n+pub const SO_TYPE: ::c_int = 0x1008;\n+\n+pub const IFF_LOOPBACK: ::c_int = 0x8;\n+\n+pub const SHUT_RD: ::c_int = 0;\n+pub const SHUT_WR: ::c_int = 1;\n+pub const SHUT_RDWR: ::c_int = 2;\n+\n+pub const LOCK_SH: ::c_int = 1;\n+pub const LOCK_EX: ::c_int = 2;\n+pub const LOCK_NB: ::c_int = 4;\n+pub const LOCK_UN: ::c_int = 8;\n+\n+pub const O_DSYNC: ::c_int = 4194304;\n+pub const O_SYNC: ::c_int = 128;\n+pub const O_NONBLOCK: ::c_int = 4;\n+\n+pub const MAP_COPY: ::c_int = 0x0002;\n+pub const MAP_RENAME: ::c_int = 0x0020;\n+pub const MAP_NORESERVE: ::c_int = 0x0040;\n+pub const MAP_NOEXTEND: ::c_int = 0x0100;\n+pub const MAP_HASSEMAPHORE: ::c_int = 0x0200;\n+pub const MAP_NOCACHE: ::c_int = 0x0400;\n+pub const MAP_JIT: ::c_int = 0x0800;\n+\n+pub const IPPROTO_RAW: ::c_int = 255;\n+\n+pub const SO_NREAD: ::c_int = 0x1020;\n+pub const SO_NKE: ::c_int = 0x1021;\n+pub const SO_NOSIGPIPE: ::c_int = 0x1022;\n+pub const SO_NOADDRERR: ::c_int = 0x1023;\n+pub const SO_NWRITE: ::c_int = 0x1024;\n+pub const SO_DONTTRUNC: ::c_int = 0x2000;\n+pub const SO_WANTMORE: ::c_int = 0x4000;\n+pub const SO_WANTOOBFLAG: ::c_int = 0x8000;\n+\n+pub const _SC_ARG_MAX: ::c_int = 1;\n+pub const _SC_CHILD_MAX: ::c_int = 2;\n+pub const _SC_CLK_TCK: ::c_int = 3;\n+pub const _SC_NGROUPS_MAX: ::c_int = 4;\n+pub const _SC_OPEN_MAX: ::c_int = 5;\n+pub const _SC_JOB_CONTROL: ::c_int = 6;\n+pub const _SC_SAVED_IDS: ::c_int = 7;\n+pub const _SC_VERSION: ::c_int = 8;\n+pub const _SC_BC_BASE_MAX: ::c_int = 9;\n+pub const _SC_BC_DIM_MAX: ::c_int = 10;\n+pub const _SC_BC_SCALE_MAX: ::c_int = 11;\n+pub const _SC_BC_STRING_MAX: ::c_int = 12;\n+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 13;\n+pub const _SC_EXPR_NEST_MAX: ::c_int = 14;\n+pub const _SC_LINE_MAX: ::c_int = 15;\n+pub const _SC_RE_DUP_MAX: ::c_int = 16;\n+pub const _SC_2_VERSION: ::c_int = 17;\n+pub const _SC_2_C_BIND: ::c_int = 18;\n+pub const _SC_2_C_DEV: ::c_int = 19;\n+pub const _SC_2_CHAR_TERM: ::c_int = 20;\n+pub const _SC_2_FORT_DEV: ::c_int = 21;\n+pub const _SC_2_FORT_RUN: ::c_int = 22;\n+pub const _SC_2_LOCALEDEF: ::c_int = 23;\n+pub const _SC_2_SW_DEV: ::c_int = 24;\n+pub const _SC_2_UPE: ::c_int = 25;\n+pub const _SC_STREAM_MAX: ::c_int = 26;\n+pub const _SC_TZNAME_MAX: ::c_int = 27;\n+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 28;\n+pub const _SC_PAGESIZE: ::c_int = 29;\n+pub const _SC_MEMLOCK: ::c_int = 30;\n+pub const _SC_MEMLOCK_RANGE: ::c_int = 31;\n+pub const _SC_MEMORY_PROTECTION: ::c_int = 32;\n+pub const _SC_MESSAGE_PASSING: ::c_int = 33;\n+pub const _SC_PRIORITIZED_IO: ::c_int = 34;\n+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 35;\n+pub const _SC_REALTIME_SIGNALS: ::c_int = 36;\n+pub const _SC_SEMAPHORES: ::c_int = 37;\n+pub const _SC_FSYNC: ::c_int = 38;\n+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 39;\n+pub const _SC_SYNCHRONIZED_IO: ::c_int = 40;\n+pub const _SC_TIMERS: ::c_int = 41;\n+pub const _SC_AIO_LISTIO_MAX: ::c_int = 42;\n+pub const _SC_AIO_MAX: ::c_int = 43;\n+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 44;\n+pub const _SC_DELAYTIMER_MAX: ::c_int = 45;\n+pub const _SC_MQ_OPEN_MAX: ::c_int = 46;\n+pub const _SC_MAPPED_FILES: ::c_int = 47;\n+pub const _SC_RTSIG_MAX: ::c_int = 48;\n+pub const _SC_SEM_NSEMS_MAX: ::c_int = 49;\n+pub const _SC_SEM_VALUE_MAX: ::c_int = 50;\n+pub const _SC_SIGQUEUE_MAX: ::c_int = 51;\n+pub const _SC_TIMER_MAX: ::c_int = 52;\n+pub const _SC_NPROCESSORS_CONF: ::c_int = 57;\n+pub const _SC_NPROCESSORS_ONLN: ::c_int = 58;\n+pub const _SC_2_PBS: ::c_int = 59;\n+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 60;\n+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 61;\n+pub const _SC_2_PBS_LOCATE: ::c_int = 62;\n+pub const _SC_2_PBS_MESSAGE: ::c_int = 63;\n+pub const _SC_2_PBS_TRACK: ::c_int = 64;\n+pub const _SC_ADVISORY_INFO: ::c_int = 65;\n+pub const _SC_BARRIERS: ::c_int = 66;\n+pub const _SC_CLOCK_SELECTION: ::c_int = 67;\n+pub const _SC_CPUTIME: ::c_int = 68;\n+pub const _SC_FILE_LOCKING: ::c_int = 69;\n+pub const _SC_HOST_NAME_MAX: ::c_int = 72;\n+pub const _SC_MONOTONIC_CLOCK: ::c_int = 74;\n+pub const _SC_READER_WRITER_LOCKS: ::c_int = 76;\n+pub const _SC_REGEXP: ::c_int = 77;\n+pub const _SC_SHELL: ::c_int = 78;\n+pub const _SC_SPAWN: ::c_int = 79;\n+pub const _SC_SPIN_LOCKS: ::c_int = 80;\n+pub const _SC_SPORADIC_SERVER: ::c_int = 81;\n+pub const _SC_THREAD_CPUTIME: ::c_int = 84;\n+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 92;\n+pub const _SC_TIMEOUTS: ::c_int = 95;\n+pub const _SC_TRACE: ::c_int = 97;\n+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 98;\n+pub const _SC_TRACE_INHERIT: ::c_int = 99;\n+pub const _SC_TRACE_LOG: ::c_int = 100;\n+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 102;\n+pub const _SC_V6_ILP32_OFF32: ::c_int = 103;\n+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 104;\n+pub const _SC_V6_LP64_OFF64: ::c_int = 105;\n+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 106;\n+pub const _SC_IPV6: ::c_int = 118;\n+pub const _SC_RAW_SOCKETS: ::c_int = 119;\n+pub const _SC_SYMLOOP_MAX: ::c_int = 120;\n+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;\n+pub const _SC_XOPEN_STREAMS: ::c_int = 114;\n+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 122;\n+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 123;\n+pub const _SC_XBS5_LP64_OFF64: ::c_int = 124;\n+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 125;\n+pub const _SC_SS_REPL_MAX: ::c_int = 126;\n+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 127;\n+pub const _SC_TRACE_NAME_MAX: ::c_int = 128;\n+pub const _SC_TRACE_SYS_MAX: ::c_int = 129;\n+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 130;\n+pub const _SC_PASS_MAX: ::c_int = 131;\n+\n+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;\n+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;\n+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;\n+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;\n+pub const _PTHREAD_MUTEX_SIG_init: ::c_long = 0x32AAABA7;\n+pub const _PTHREAD_COND_SIG_init: ::c_long = 0x3CB0B1BB;\n+pub const _PTHREAD_RWLOCK_SIG_init: ::c_long = 0x2DA8B3B4;\n+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+    __sig: _PTHREAD_MUTEX_SIG_init,\n+    __opaque: [0; __PTHREAD_MUTEX_SIZE__],\n+};\n+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+    __sig: _PTHREAD_COND_SIG_init,\n+    __opaque: [0; __PTHREAD_COND_SIZE__],\n+};\n+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n+    __sig: _PTHREAD_RWLOCK_SIG_init,\n+    __opaque: [0; __PTHREAD_RWLOCK_SIZE__],\n+};\n+\n+pub const SIGSTKSZ: ::size_t = 131072;\n+\n+pub const FD_SETSIZE: usize = 1024;\n+\n+pub const ST_NOSUID: ::c_ulong = 2;\n+\n+pub const EVFILT_READ: ::int16_t = -1;\n+pub const EVFILT_WRITE: ::int16_t = -2;\n+pub const EVFILT_AIO: ::int16_t = -3;\n+pub const EVFILT_VNODE: ::int16_t = -4;\n+pub const EVFILT_PROC: ::int16_t = -5;\n+pub const EVFILT_SIGNAL: ::int16_t = -6;\n+pub const EVFILT_TIMER: ::int16_t = -7;\n+pub const EVFILT_MACHPORT: ::int16_t = -8;\n+pub const EVFILT_FS: ::int16_t = -9;\n+pub const EVFILT_USER: ::int16_t = -10;\n+pub const EVFILT_VM: ::int16_t = -12;\n+\n+pub const EV_ADD: ::uint16_t = 0x1;\n+pub const EV_DELETE: ::uint16_t = 0x2;\n+pub const EV_ENABLE: ::uint16_t = 0x4;\n+pub const EV_DISABLE: ::uint16_t = 0x8;\n+pub const EV_ONESHOT: ::uint16_t = 0x10;\n+pub const EV_CLEAR: ::uint16_t = 0x20;\n+pub const EV_RECEIPT: ::uint16_t = 0x40;\n+pub const EV_DISPATCH: ::uint16_t = 0x80;\n+pub const EV_FLAG0: ::uint16_t = 0x1000;\n+pub const EV_POLL: ::uint16_t = 0x1000;\n+pub const EV_FLAG1: ::uint16_t = 0x2000;\n+pub const EV_OOBAND: ::uint16_t = 0x2000;\n+pub const EV_ERROR: ::uint16_t = 0x4000;\n+pub const EV_EOF: ::uint16_t = 0x8000;\n+pub const EV_SYSFLAGS: ::uint16_t = 0xf000;\n+\n+pub const NOTE_TRIGGER: ::uint32_t = 0x01000000;\n+pub const NOTE_FFNOP: ::uint32_t = 0x00000000;\n+pub const NOTE_FFAND: ::uint32_t = 0x40000000;\n+pub const NOTE_FFOR: ::uint32_t = 0x80000000;\n+pub const NOTE_FFCOPY: ::uint32_t = 0xc0000000;\n+pub const NOTE_FFCTRLMASK: ::uint32_t = 0xc0000000;\n+pub const NOTE_FFLAGSMASK: ::uint32_t = 0x00ffffff;\n+pub const NOTE_LOWAT: ::uint32_t = 0x00000001;\n+pub const NOTE_DELETE: ::uint32_t = 0x00000001;\n+pub const NOTE_WRITE: ::uint32_t = 0x00000002;\n+pub const NOTE_EXTEND: ::uint32_t = 0x00000004;\n+pub const NOTE_ATTRIB: ::uint32_t = 0x00000008;\n+pub const NOTE_LINK: ::uint32_t = 0x00000010;\n+pub const NOTE_RENAME: ::uint32_t = 0x00000020;\n+pub const NOTE_REVOKE: ::uint32_t = 0x00000040;\n+pub const NOTE_NONE: ::uint32_t = 0x00000080;\n+pub const NOTE_EXIT: ::uint32_t = 0x80000000;\n+pub const NOTE_FORK: ::uint32_t = 0x40000000;\n+pub const NOTE_EXEC: ::uint32_t = 0x20000000;\n+pub const NOTE_REAP: ::uint32_t = 0x10000000;\n+pub const NOTE_SIGNAL: ::uint32_t = 0x08000000;\n+pub const NOTE_EXITSTATUS: ::uint32_t = 0x04000000;\n+pub const NOTE_EXIT_DETAIL: ::uint32_t = 0x02000000;\n+pub const NOTE_PDATAMASK: ::uint32_t = 0x000fffff;\n+pub const NOTE_PCTRLMASK: ::uint32_t = 0xfff00000;\n+pub const NOTE_EXIT_REPARENTED: ::uint32_t = 0x00080000;\n+pub const NOTE_EXIT_DETAIL_MASK: ::uint32_t = 0x00070000;\n+pub const NOTE_EXIT_DECRYPTFAIL: ::uint32_t = 0x00010000;\n+pub const NOTE_EXIT_MEMORY: ::uint32_t = 0x00020000;\n+pub const NOTE_EXIT_CSERROR: ::uint32_t = 0x00040000;\n+pub const NOTE_VM_PRESSURE: ::uint32_t = 0x80000000;\n+pub const NOTE_VM_PRESSURE_TERMINATE: ::uint32_t = 0x40000000;\n+pub const NOTE_VM_PRESSURE_SUDDEN_TERMINATE: ::uint32_t = 0x20000000;\n+pub const NOTE_VM_ERROR: ::uint32_t = 0x10000000;\n+pub const NOTE_SECONDS: ::uint32_t = 0x00000001;\n+pub const NOTE_USECONDS: ::uint32_t = 0x00000002;\n+pub const NOTE_NSECONDS: ::uint32_t = 0x00000004;\n+pub const NOTE_ABSOLUTE: ::uint32_t = 0x00000008;\n+pub const NOTE_LEEWAY: ::uint32_t = 0x00000010;\n+pub const NOTE_CRITICAL: ::uint32_t = 0x00000020;\n+pub const NOTE_BACKGROUND: ::uint32_t = 0x00000040;\n+pub const NOTE_TRACK: ::uint32_t = 0x00000001;\n+pub const NOTE_TRACKERR: ::uint32_t = 0x00000002;\n+pub const NOTE_CHILD: ::uint32_t = 0x00000004;\n+\n+pub const NL0: ::c_int  = 0x00000000;\n+pub const NL1: ::c_int  = 0x00000100;\n+pub const TAB0: ::c_int = 0x00000000;\n+pub const TAB1: ::c_int = 0x00000400;\n+pub const TAB2: ::c_int = 0x00000800;\n+pub const CR0: ::c_int  = 0x00000000;\n+pub const CR1: ::c_int  = 0x00001000;\n+pub const CR2: ::c_int  = 0x00002000;\n+pub const CR3: ::c_int  = 0x00003000;\n+pub const FF0: ::c_int  = 0x00000000;\n+pub const FF1: ::c_int  = 0x00004000;\n+pub const BS0: ::c_int  = 0x00000000;\n+pub const BS1: ::c_int  = 0x00008000;\n+pub const TAB3: ::c_int = 0x00000004;\n+pub const VT0: ::c_int  = 0x00000000;\n+pub const VT1: ::c_int  = 0x00010000;\n+pub const IUTF8: ::tcflag_t = 0x00004000;\n+pub const CRTSCTS: ::tcflag_t = 0x00030000;\n+\n+pub const NI_MAXHOST: ::socklen_t = 1025;\n+\n+pub const Q_GETQUOTA: ::c_int = 0x300;\n+pub const Q_SETQUOTA: ::c_int = 0x400;\n+\n+pub const RTLD_LOCAL: ::c_int = 0x4;\n+pub const RTLD_FIRST: ::c_int = 0x100;\n+pub const RTLD_NODELETE: ::c_int = 0x80;\n+pub const RTLD_NOLOAD: ::c_int = 0x10;\n+pub const RTLD_GLOBAL: ::c_int = 0x8;\n+\n+pub const _WSTOPPED: ::c_int = 0o177;\n+\n+pub const LOG_NETINFO: ::c_int = 12 << 3;\n+pub const LOG_REMOTEAUTH: ::c_int = 13 << 3;\n+pub const LOG_INSTALL: ::c_int = 14 << 3;\n+pub const LOG_RAS: ::c_int = 15 << 3;\n+pub const LOG_LAUNCHD: ::c_int = 24 << 3;\n+pub const LOG_NFACILITIES: ::c_int = 25;\n+\n+pub const CTLTYPE: ::c_int = 0xf;\n+pub const CTLTYPE_NODE: ::c_int = 1;\n+pub const CTLTYPE_INT: ::c_int = 2;\n+pub const CTLTYPE_STRING: ::c_int = 3;\n+pub const CTLTYPE_QUAD: ::c_int = 4;\n+pub const CTLTYPE_OPAQUE: ::c_int = 5;\n+pub const CTLTYPE_STRUCT: ::c_int = CTLTYPE_OPAQUE;\n+pub const CTLFLAG_RD: ::c_int = 0x80000000;\n+pub const CTLFLAG_WR: ::c_int = 0x40000000;\n+pub const CTLFLAG_RW: ::c_int = CTLFLAG_RD | CTLFLAG_WR;\n+pub const CTLFLAG_NOLOCK: ::c_int = 0x20000000;\n+pub const CTLFLAG_ANYBODY: ::c_int = 0x10000000;\n+pub const CTLFLAG_SECURE: ::c_int = 0x08000000;\n+pub const CTLFLAG_MASKED: ::c_int = 0x04000000;\n+pub const CTLFLAG_NOAUTO: ::c_int = 0x02000000;\n+pub const CTLFLAG_KERN: ::c_int = 0x01000000;\n+pub const CTLFLAG_LOCKED: ::c_int = 0x00800000;\n+pub const CTLFLAG_OID2: ::c_int = 0x00400000;\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_VFS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_USER: ::c_int = 8;\n+pub const CTL_MAXID: ::c_int = 9;\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_VNODE: ::c_int = 13;\n+pub const KERN_PROC: ::c_int = 14;\n+pub const KERN_FILE: ::c_int = 15;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_BOOTTIME: ::c_int = 21;\n+pub const KERN_NISDOMAINNAME: ::c_int = 22;\n+pub const KERN_DOMAINNAME: ::c_int = KERN_NISDOMAINNAME;\n+pub const KERN_MAXPARTITIONS: ::c_int = 23;\n+pub const KERN_KDEBUG: ::c_int = 24;\n+pub const KERN_UPDATEINTERVAL: ::c_int = 25;\n+pub const KERN_OSRELDATE: ::c_int = 26;\n+pub const KERN_NTP_PLL: ::c_int = 27;\n+pub const KERN_BOOTFILE: ::c_int = 28;\n+pub const KERN_MAXFILESPERPROC: ::c_int = 29;\n+pub const KERN_MAXPROCPERUID: ::c_int = 30;\n+pub const KERN_DUMPDEV: ::c_int = 31;\n+pub const KERN_IPC: ::c_int = 32;\n+pub const KERN_DUMMY: ::c_int = 33;\n+pub const KERN_PS_STRINGS: ::c_int = 34;\n+pub const KERN_USRSTACK32: ::c_int = 35;\n+pub const KERN_LOGSIGEXIT: ::c_int = 36;\n+pub const KERN_SYMFILE: ::c_int = 37;\n+pub const KERN_PROCARGS: ::c_int = 38;\n+pub const KERN_NETBOOT: ::c_int = 40;\n+pub const KERN_SYSV: ::c_int = 42;\n+pub const KERN_AFFINITY: ::c_int = 43;\n+pub const KERN_TRANSLATE: ::c_int = 44;\n+pub const KERN_CLASSIC: ::c_int = KERN_TRANSLATE;\n+pub const KERN_EXEC: ::c_int = 45;\n+pub const KERN_CLASSICHANDLER: ::c_int = KERN_EXEC;\n+pub const KERN_AIOMAX: ::c_int = 46;\n+pub const KERN_AIOPROCMAX: ::c_int = 47;\n+pub const KERN_AIOTHREADS: ::c_int = 48;\n+pub const KERN_COREFILE: ::c_int = 50;\n+pub const KERN_COREDUMP: ::c_int = 51;\n+pub const KERN_SUGID_COREDUMP: ::c_int = 52;\n+pub const KERN_PROCDELAYTERM: ::c_int = 53;\n+pub const KERN_SHREG_PRIVATIZABLE: ::c_int = 54;\n+pub const KERN_LOW_PRI_WINDOW: ::c_int = 56;\n+pub const KERN_LOW_PRI_DELAY: ::c_int = 57;\n+pub const KERN_POSIX: ::c_int = 58;\n+pub const KERN_USRSTACK64: ::c_int = 59;\n+pub const KERN_NX_PROTECTION: ::c_int = 60;\n+pub const KERN_TFP: ::c_int = 61;\n+pub const KERN_PROCNAME: ::c_int = 62;\n+pub const KERN_THALTSTACK: ::c_int = 63;\n+pub const KERN_SPECULATIVE_READS: ::c_int = 64;\n+pub const KERN_OSVERSION: ::c_int = 65;\n+pub const KERN_SAFEBOOT: ::c_int = 66;\n+pub const KERN_RAGEVNODE: ::c_int = 68;\n+pub const KERN_TTY: ::c_int = 69;\n+pub const KERN_CHECKOPENEVT: ::c_int = 70;\n+pub const KERN_THREADNAME: ::c_int = 71;\n+pub const KERN_MAXID: ::c_int = 72;\n+pub const KERN_RAGE_PROC: ::c_int = 1;\n+pub const KERN_RAGE_THREAD: ::c_int = 2;\n+pub const KERN_UNRAGE_PROC: ::c_int = 3;\n+pub const KERN_UNRAGE_THREAD: ::c_int = 4;\n+pub const KERN_OPENEVT_PROC: ::c_int = 1;\n+pub const KERN_UNOPENEVT_PROC: ::c_int = 2;\n+pub const KERN_TFP_POLICY: ::c_int = 1;\n+pub const KERN_TFP_POLICY_DENY: ::c_int = 0;\n+pub const KERN_TFP_POLICY_DEFAULT: ::c_int = 2;\n+pub const KERN_KDEFLAGS: ::c_int = 1;\n+pub const KERN_KDDFLAGS: ::c_int = 2;\n+pub const KERN_KDENABLE: ::c_int = 3;\n+pub const KERN_KDSETBUF: ::c_int = 4;\n+pub const KERN_KDGETBUF: ::c_int = 5;\n+pub const KERN_KDSETUP: ::c_int = 6;\n+pub const KERN_KDREMOVE: ::c_int = 7;\n+pub const KERN_KDSETREG: ::c_int = 8;\n+pub const KERN_KDGETREG: ::c_int = 9;\n+pub const KERN_KDREADTR: ::c_int = 10;\n+pub const KERN_KDPIDTR: ::c_int = 11;\n+pub const KERN_KDTHRMAP: ::c_int = 12;\n+pub const KERN_KDPIDEX: ::c_int = 14;\n+pub const KERN_KDSETRTCDEC: ::c_int = 15;\n+pub const KERN_KDGETENTROPY: ::c_int = 16;\n+pub const KERN_KDWRITETR: ::c_int = 17;\n+pub const KERN_KDWRITEMAP: ::c_int = 18;\n+pub const KERN_KDENABLE_BG_TRACE: ::c_int = 19;\n+pub const KERN_KDDISABLE_BG_TRACE: ::c_int = 20;\n+pub const KERN_KDREADCURTHRMAP: ::c_int = 21;\n+pub const KERN_KDSET_TYPEFILTER: ::c_int = 22;\n+pub const KERN_KDBUFWAIT: ::c_int = 23;\n+pub const KERN_KDCPUMAP: ::c_int = 24;\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_LCID: ::c_int = 7;\n+pub const KIPC_MAXSOCKBUF: ::c_int = 1;\n+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;\n+pub const KIPC_SOMAXCONN: ::c_int = 3;\n+pub const KIPC_MAX_LINKHDR: ::c_int = 4;\n+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;\n+pub const KIPC_MAX_HDR: ::c_int = 6;\n+pub const KIPC_MAX_DATALEN: ::c_int = 7;\n+pub const KIPC_MBSTAT: ::c_int = 8;\n+pub const KIPC_NMBCLUSTERS: ::c_int = 9;\n+pub const KIPC_SOQLIMITCOMPAT: ::c_int = 10;\n+pub const VM_METER: ::c_int = 1;\n+pub const VM_LOADAVG: ::c_int = 2;\n+pub const VM_MACHFACTOR: ::c_int = 4;\n+pub const VM_SWAPUSAGE: ::c_int = 5;\n+pub const VM_MAXID: ::c_int = 6;\n+pub const HW_MACHINE: ::c_int = 1;\n+pub const HW_MODEL: ::c_int = 2;\n+pub const HW_NCPU: ::c_int = 3;\n+pub const HW_BYTEORDER: ::c_int = 4;\n+pub const HW_PHYSMEM: ::c_int = 5;\n+pub const HW_USERMEM: ::c_int = 6;\n+pub const HW_PAGESIZE: ::c_int = 7;\n+pub const HW_DISKNAMES: ::c_int = 8;\n+pub const HW_DISKSTATS: ::c_int = 9;\n+pub const HW_EPOCH: ::c_int = 10;\n+pub const HW_FLOATINGPT: ::c_int = 11;\n+pub const HW_MACHINE_ARCH: ::c_int = 12;\n+pub const HW_VECTORUNIT: ::c_int = 13;\n+pub const HW_BUS_FREQ: ::c_int = 14;\n+pub const HW_CPU_FREQ: ::c_int = 15;\n+pub const HW_CACHELINE: ::c_int = 16;\n+pub const HW_L1ICACHESIZE: ::c_int = 17;\n+pub const HW_L1DCACHESIZE: ::c_int = 18;\n+pub const HW_L2SETTINGS: ::c_int = 19;\n+pub const HW_L2CACHESIZE: ::c_int = 20;\n+pub const HW_L3SETTINGS: ::c_int = 21;\n+pub const HW_L3CACHESIZE: ::c_int = 22;\n+pub const HW_TB_FREQ: ::c_int = 23;\n+pub const HW_MEMSIZE: ::c_int = 24;\n+pub const HW_AVAILCPU: ::c_int = 25;\n+pub const HW_MAXID: ::c_int = 26;\n+pub const USER_CS_PATH: ::c_int = 1;\n+pub const USER_BC_BASE_MAX: ::c_int = 2;\n+pub const USER_BC_DIM_MAX: ::c_int = 3;\n+pub const USER_BC_SCALE_MAX: ::c_int = 4;\n+pub const USER_BC_STRING_MAX: ::c_int = 5;\n+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;\n+pub const USER_EXPR_NEST_MAX: ::c_int = 7;\n+pub const USER_LINE_MAX: ::c_int = 8;\n+pub const USER_RE_DUP_MAX: ::c_int = 9;\n+pub const USER_POSIX2_VERSION: ::c_int = 10;\n+pub const USER_POSIX2_C_BIND: ::c_int = 11;\n+pub const USER_POSIX2_C_DEV: ::c_int = 12;\n+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;\n+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;\n+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;\n+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;\n+pub const USER_POSIX2_SW_DEV: ::c_int = 17;\n+pub const USER_POSIX2_UPE: ::c_int = 18;\n+pub const USER_STREAM_MAX: ::c_int = 19;\n+pub const USER_TZNAME_MAX: ::c_int = 20;\n+pub const USER_MAXID: ::c_int = 21;\n+pub const CTL_DEBUG_NAME: ::c_int = 0;\n+pub const CTL_DEBUG_VALUE: ::c_int = 1;\n+pub const CTL_DEBUG_MAXID: ::c_int = 20;\n+\n+pub const POLLRDNORM: ::c_short = 0x040;\n+pub const POLLWRNORM: ::c_short = 0x004;\n+pub const POLLRDBAND: ::c_short = 0x080;\n+pub const POLLWRBAND: ::c_short = 0x100;\n+\n+pub const PRIO_DARWIN_THREAD: ::c_int = 3;\n+pub const PRIO_DARWIN_PROCESS: ::c_int = 4;\n+pub const PRIO_DARWIN_BG: ::c_int = 0x1000;\n+pub const PRIO_DARWIN_NONUI: ::c_int = 0x1001;\n+\n+pub const SEM_FAILED: *mut sem_t = -1isize as *mut ::sem_t;\n+\n+f! {\n+    pub fn WSTOPSIG(status: ::c_int) -> ::c_int {\n+        status >> 8\n+    }\n+\n+    pub fn _WSTATUS(status: ::c_int) -> ::c_int {\n+        status & 0x7f\n+    }\n+\n+    pub fn WIFCONTINUED(status: ::c_int) -> bool {\n+        _WSTATUS(status) == _WSTOPPED && WSTOPSIG(status) == 0x13\n+    }\n+\n+    pub fn WIFSIGNALED(status: ::c_int) -> bool {\n+        _WSTATUS(status) != _WSTOPPED && _WSTATUS(status) != 0\n+    }\n+\n+    pub fn WIFSTOPPED(status: ::c_int) -> bool {\n+        _WSTATUS(status) == _WSTOPPED && WSTOPSIG(status) != 0x13\n+    }\n+}\n+\n+extern {\n+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;\n+\n+    pub fn getutxent() -> *mut utmpx;\n+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;\n+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;\n+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;\n+    pub fn setutxent();\n+    pub fn endutxent();\n+    pub fn utmpxname(file: *const ::c_char) -> ::c_int;\n+\n+    pub fn getnameinfo(sa: *const ::sockaddr,\n+                       salen: ::socklen_t,\n+                       host: *mut ::c_char,\n+                       hostlen: ::socklen_t,\n+                       serv: *mut ::c_char,\n+                       sevlen: ::socklen_t,\n+                       flags: ::c_int) -> ::c_int;\n+    pub fn mincore(addr: *const ::c_void, len: ::size_t,\n+                   vec: *mut ::c_char) -> ::c_int;\n+    pub fn sysctlnametomib(name: *const ::c_char,\n+                           mibp: *mut ::c_int,\n+                           sizep: *mut ::size_t)\n+                           -> ::c_int;\n+    #[cfg_attr(all(target_os = \"macos\", target_arch = \"x86\"),\n+               link_name = \"mprotect$UNIX2003\")]\n+    pub fn mprotect(addr: *mut ::c_void, len: ::size_t, prot: ::c_int)\n+                    -> ::c_int;\n+    pub fn shm_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::c_int;\n+    pub fn sysctl(name: *mut ::c_int,\n+                  namelen: ::c_uint,\n+                  oldp: *mut ::c_void,\n+                  oldlenp: *mut ::size_t,\n+                  newp: *mut ::c_void,\n+                  newlen: ::size_t)\n+                  -> ::c_int;\n+    pub fn sysctlbyname(name: *const ::c_char,\n+                        oldp: *mut ::c_void,\n+                        oldlenp: *mut ::size_t,\n+                        newp: *mut ::c_void,\n+                        newlen: ::size_t)\n+                        -> ::c_int;\n+    pub fn mach_absolute_time() -> u64;\n+    pub fn mach_timebase_info(info: *mut ::mach_timebase_info) -> ::c_int;\n+    pub fn pthread_setname_np(name: *const ::c_char) -> ::c_int;\n+    pub fn pthread_get_stackaddr_np(thread: ::pthread_t) -> *mut ::c_void;\n+    pub fn pthread_get_stacksize_np(thread: ::pthread_t) -> ::size_t;\n+    pub fn __error() -> *mut ::c_int;\n+    pub fn backtrace(buf: *mut *mut ::c_void,\n+                     sz: ::c_int) -> ::c_int;\n+    #[cfg_attr(target_os = \"macos\", link_name = \"statfs$INODE64\")]\n+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n+    #[cfg_attr(target_os = \"macos\", link_name = \"fstatfs$INODE64\")]\n+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n+    pub fn kevent(kq: ::c_int,\n+                  changelist: *const ::kevent,\n+                  nchanges: ::c_int,\n+                  eventlist: *mut ::kevent,\n+                  nevents: ::c_int,\n+                  timeout: *const ::timespec) -> ::c_int;\n+    pub fn kevent64(kq: ::c_int,\n+                    changelist: *const ::kevent64_s,\n+                    nchanges: ::c_int,\n+                    eventlist: *mut ::kevent64_s,\n+                    nevents: ::c_int,\n+                    flags: ::c_uint,\n+                    timeout: *const ::timespec) -> ::c_int;\n+    pub fn mount(src: *const ::c_char,\n+                 target: *const ::c_char,\n+                 flags: ::c_int,\n+                 data: *mut ::c_void) -> ::c_int;\n+    pub fn ptrace(requeset: ::c_int,\n+                  pid: ::pid_t,\n+                  addr: *mut ::c_char,\n+                  data: ::c_int) -> ::c_int;\n+    pub fn quotactl(special: *const ::c_char,\n+                    cmd: ::c_int,\n+                    id: ::c_int,\n+                    data: *mut ::c_char) -> ::c_int;\n+    pub fn sethostname(name: *const ::c_char, len: ::c_int) -> ::c_int;\n+    pub fn sendfile(fd: ::c_int,\n+                    s: ::c_int,\n+                    offset: ::off_t,\n+                    len: *mut ::off_t,\n+                    hdtr: *mut ::sf_hdtr,\n+                    flags: ::c_int) -> ::c_int;\n+    pub fn openpty(amaster: *mut ::c_int,\n+                   aslave: *mut ::c_int,\n+                   name: *mut ::c_char,\n+                   termp: *mut termios,\n+                   winp: *mut ::winsize) -> ::c_int;\n+    pub fn forkpty(amaster: *mut ::c_int,\n+                   name: *mut ::c_char,\n+                   termp: *mut termios,\n+                   winp: *mut ::winsize) -> ::pid_t;\n+    pub fn duplocale(base: ::locale_t) -> ::locale_t;\n+    pub fn freelocale(loc: ::locale_t) -> ::c_int;\n+    pub fn localeconv_l(loc: ::locale_t) -> *mut lconv;\n+    pub fn newlocale(mask: ::c_int,\n+                     locale: *const ::c_char,\n+                     base: ::locale_t) -> ::locale_t;\n+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;\n+    pub fn querylocale(mask: ::c_int, loc: ::locale_t) -> *const ::c_char;\n+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;\n+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;\n+\n+    pub fn openat(dirfd: ::c_int, pathname: *const ::c_char,\n+                  flags: ::c_int, ...) -> ::c_int;\n+    pub fn faccessat(dirfd: ::c_int, pathname: *const ::c_char,\n+                     mode: ::c_int, flags: ::c_int) -> ::c_int;\n+    pub fn fchmodat(dirfd: ::c_int, pathname: *const ::c_char,\n+                    mode: ::mode_t, flags: ::c_int) -> ::c_int;\n+    pub fn fchownat(dirfd: ::c_int, pathname: *const ::c_char,\n+                    owner: ::uid_t, group: ::gid_t,\n+                    flags: ::c_int) -> ::c_int;\n+    #[cfg_attr(target_os = \"macos\", link_name = \"fstatat$INODE64\")]\n+    pub fn fstatat(dirfd: ::c_int, pathname: *const ::c_char,\n+                   buf: *mut stat, flags: ::c_int) -> ::c_int;\n+    pub fn linkat(olddirfd: ::c_int, oldpath: *const ::c_char,\n+                  newdirfd: ::c_int, newpath: *const ::c_char,\n+                  flags: ::c_int) -> ::c_int;\n+   pub fn mkdirat(dirfd: ::c_int, pathname: *const ::c_char,\n+                  mode: ::mode_t) -> ::c_int;\n+   pub fn readlinkat(dirfd: ::c_int, pathname: *const ::c_char,\n+                     buf: *mut ::c_char, bufsiz: ::size_t) -> ::ssize_t;\n+   pub fn renameat(olddirfd: ::c_int, oldpath: *const ::c_char,\n+                   newdirfd: ::c_int, newpath: *const ::c_char)\n+                   -> ::c_int;\n+   pub fn symlinkat(target: *const ::c_char, newdirfd: ::c_int,\n+                    linkpath: *const ::c_char) -> ::c_int;\n+   pub fn unlinkat(dirfd: ::c_int, pathname: *const ::c_char,\n+                   flags: ::c_int) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(any(target_arch = \"arm\", target_arch = \"x86\"))] {\n+        mod b32;\n+        pub use self::b32::*;\n+    } else if #[cfg(any(target_arch = \"x86_64\", target_arch = \"aarch64\"))] {\n+        mod b64;\n+        pub use self::b64::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}"}, {"sha": "179cd913b3862e402c92a9211225de6425d19bd6", "filename": "src/vendor/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Fdragonfly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Fdragonfly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Fdragonfly%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,303 @@\n+pub type clock_t = u64;\n+pub type ino_t = u64;\n+pub type nlink_t = u32;\n+pub type blksize_t = i64;\n+pub type clockid_t = ::c_ulong;\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type time_t = i64;\n+pub type suseconds_t = i64;\n+\n+pub type uuid_t = ::uuid;\n+\n+pub type fsblkcnt_t = u64;\n+pub type fsfilcnt_t = u64;\n+\n+s! {\n+    pub struct dirent {\n+        pub d_fileno: ::ino_t,\n+        pub d_namlen: u16,\n+        pub d_type: u8,\n+        __unused1: u8,\n+        __unused2: u32,\n+        pub d_name: [::c_char; 256],\n+    }\n+\n+    pub struct uuid {\n+        pub time_low: u32,\n+        pub time_mid: u16,\n+        pub time_hi_and_version: u16,\n+        pub clock_seq_hi_and_reserved: u8,\n+        pub clock_seq_low: u8,\n+        pub node: [u8; 6],\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bsize: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_fsid: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+        pub f_owner: ::uid_t,\n+        pub f_type: ::c_uint,\n+        pub f_syncreads: u64,\n+        pub f_syncwrites: u64,\n+        pub f_asyncreads: u64,\n+        pub f_asyncwrites: u64,\n+        pub f_fsid_uuid: ::uuid_t,\n+        pub f_uid_uuid: ::uuid_t,\n+    }\n+\n+    pub struct stat {\n+        pub st_ino: ::ino_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_dev: ::dev_t,\n+        pub st_mode: ::mode_t,\n+        pub st_padding1: ::uint16_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::int64_t,\n+        pub st_blksize: ::uint32_t,\n+        pub st_flags: ::uint32_t,\n+        pub st_gen: ::uint32_t,\n+        pub st_lspare: ::int32_t,\n+        pub st_qspare1: ::int64_t,\n+        pub st_qspare2: ::int64_t,\n+    }\n+}\n+\n+pub const RAND_MAX: ::c_int = 0x7fff_ffff;\n+pub const PTHREAD_STACK_MIN: ::size_t = 1024;\n+pub const SIGSTKSZ: ::size_t = 40960;\n+pub const MADV_INVAL: ::c_int = 10;\n+pub const O_CLOEXEC: ::c_int = 0x00020000;\n+pub const F_GETLK: ::c_int = 7;\n+pub const F_SETLK: ::c_int = 8;\n+pub const F_SETLKW: ::c_int = 9;\n+pub const ELAST: ::c_int = 99;\n+pub const RLIMIT_POSIXLOCKS: ::c_int = 11;\n+pub const RLIM_NLIMITS: ::rlim_t = 12;\n+\n+pub const Q_GETQUOTA: ::c_int = 0x300;\n+pub const Q_SETQUOTA: ::c_int = 0x400;\n+\n+pub const CLOCK_REALTIME: clockid_t = 0;\n+pub const CLOCK_VIRTUAL: clockid_t = 1;\n+pub const CLOCK_PROF: clockid_t = 2;\n+pub const CLOCK_MONOTONIC: clockid_t = 4;\n+pub const CLOCK_UPTIME: clockid_t = 5;\n+pub const CLOCK_UPTIME_PRECISE: clockid_t = 7;\n+pub const CLOCK_UPTIME_FAST: clockid_t = 8;\n+pub const CLOCK_REALTIME_PRECISE: clockid_t = 9;\n+pub const CLOCK_REALTIME_FAST: clockid_t = 10;\n+pub const CLOCK_MONOTONIC_PRECISE: clockid_t = 11;\n+pub const CLOCK_MONOTONIC_FAST: clockid_t = 12;\n+pub const CLOCK_SECOND: clockid_t = 13;\n+pub const CLOCK_THREAD_CPUTIME_ID: clockid_t = 14;\n+pub const CLOCK_PROCESS_CPUTIME_ID: clockid_t = 15;\n+\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_VFS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_USER: ::c_int = 8;\n+pub const CTL_P1003_1B: ::c_int = 9;\n+pub const CTL_LWKT: ::c_int = 10;\n+pub const CTL_MAXID: ::c_int = 11;\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_VNODE: ::c_int = 13;\n+pub const KERN_PROC: ::c_int = 14;\n+pub const KERN_FILE: ::c_int = 15;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_BOOTTIME: ::c_int = 21;\n+pub const KERN_NISDOMAINNAME: ::c_int = 22;\n+pub const KERN_UPDATEINTERVAL: ::c_int = 23;\n+pub const KERN_OSRELDATE: ::c_int = 24;\n+pub const KERN_NTP_PLL: ::c_int = 25;\n+pub const KERN_BOOTFILE: ::c_int = 26;\n+pub const KERN_MAXFILESPERPROC: ::c_int = 27;\n+pub const KERN_MAXPROCPERUID: ::c_int = 28;\n+pub const KERN_DUMPDEV: ::c_int = 29;\n+pub const KERN_IPC: ::c_int = 30;\n+pub const KERN_DUMMY: ::c_int = 31;\n+pub const KERN_PS_STRINGS: ::c_int = 32;\n+pub const KERN_USRSTACK: ::c_int = 33;\n+pub const KERN_LOGSIGEXIT: ::c_int = 34;\n+pub const KERN_IOV_MAX: ::c_int = 35;\n+pub const KERN_MAXPOSIXLOCKSPERUID: ::c_int = 36;\n+pub const KERN_MAXID: ::c_int = 37;\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_ARGS: ::c_int = 7;\n+pub const KERN_PROC_CWD: ::c_int = 8;\n+pub const KERN_PROC_PATHNAME: ::c_int = 9;\n+pub const KERN_PROC_FLAGMASK: ::c_int = 0x10;\n+pub const KERN_PROC_FLAG_LWP: ::c_int = 0x10;\n+pub const KIPC_MAXSOCKBUF: ::c_int = 1;\n+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;\n+pub const KIPC_SOMAXCONN: ::c_int = 3;\n+pub const KIPC_MAX_LINKHDR: ::c_int = 4;\n+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;\n+pub const KIPC_MAX_HDR: ::c_int = 6;\n+pub const KIPC_MAX_DATALEN: ::c_int = 7;\n+pub const KIPC_MBSTAT: ::c_int = 8;\n+pub const KIPC_NMBCLUSTERS: ::c_int = 9;\n+pub const HW_MACHINE: ::c_int = 1;\n+pub const HW_MODEL: ::c_int = 2;\n+pub const HW_NCPU: ::c_int = 3;\n+pub const HW_BYTEORDER: ::c_int = 4;\n+pub const HW_PHYSMEM: ::c_int = 5;\n+pub const HW_USERMEM: ::c_int = 6;\n+pub const HW_PAGESIZE: ::c_int = 7;\n+pub const HW_DISKNAMES: ::c_int = 8;\n+pub const HW_DISKSTATS: ::c_int = 9;\n+pub const HW_FLOATINGPT: ::c_int = 10;\n+pub const HW_MACHINE_ARCH: ::c_int = 11;\n+pub const HW_MACHINE_PLATFORM: ::c_int = 12;\n+pub const HW_SENSORS: ::c_int = 13;\n+pub const HW_MAXID: ::c_int = 14;\n+pub const USER_CS_PATH: ::c_int = 1;\n+pub const USER_BC_BASE_MAX: ::c_int = 2;\n+pub const USER_BC_DIM_MAX: ::c_int = 3;\n+pub const USER_BC_SCALE_MAX: ::c_int = 4;\n+pub const USER_BC_STRING_MAX: ::c_int = 5;\n+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;\n+pub const USER_EXPR_NEST_MAX: ::c_int = 7;\n+pub const USER_LINE_MAX: ::c_int = 8;\n+pub const USER_RE_DUP_MAX: ::c_int = 9;\n+pub const USER_POSIX2_VERSION: ::c_int = 10;\n+pub const USER_POSIX2_C_BIND: ::c_int = 11;\n+pub const USER_POSIX2_C_DEV: ::c_int = 12;\n+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;\n+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;\n+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;\n+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;\n+pub const USER_POSIX2_SW_DEV: ::c_int = 17;\n+pub const USER_POSIX2_UPE: ::c_int = 18;\n+pub const USER_STREAM_MAX: ::c_int = 19;\n+pub const USER_TZNAME_MAX: ::c_int = 20;\n+pub const USER_MAXID: ::c_int = 21;\n+pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::c_int = 1;\n+pub const CTL_P1003_1B_MAPPED_FILES: ::c_int = 2;\n+pub const CTL_P1003_1B_MEMLOCK: ::c_int = 3;\n+pub const CTL_P1003_1B_MEMLOCK_RANGE: ::c_int = 4;\n+pub const CTL_P1003_1B_MEMORY_PROTECTION: ::c_int = 5;\n+pub const CTL_P1003_1B_MESSAGE_PASSING: ::c_int = 6;\n+pub const CTL_P1003_1B_PRIORITIZED_IO: ::c_int = 7;\n+pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::c_int = 8;\n+pub const CTL_P1003_1B_REALTIME_SIGNALS: ::c_int = 9;\n+pub const CTL_P1003_1B_SEMAPHORES: ::c_int = 10;\n+pub const CTL_P1003_1B_FSYNC: ::c_int = 11;\n+pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::c_int = 12;\n+pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::c_int = 13;\n+pub const CTL_P1003_1B_TIMERS: ::c_int = 14;\n+pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::c_int = 15;\n+pub const CTL_P1003_1B_AIO_MAX: ::c_int = 16;\n+pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::c_int = 17;\n+pub const CTL_P1003_1B_DELAYTIMER_MAX: ::c_int = 18;\n+pub const CTL_P1003_1B_UNUSED1: ::c_int = 19;\n+pub const CTL_P1003_1B_PAGESIZE: ::c_int = 20;\n+pub const CTL_P1003_1B_RTSIG_MAX: ::c_int = 21;\n+pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::c_int = 22;\n+pub const CTL_P1003_1B_SEM_VALUE_MAX: ::c_int = 23;\n+pub const CTL_P1003_1B_SIGQUEUE_MAX: ::c_int = 24;\n+pub const CTL_P1003_1B_TIMER_MAX: ::c_int = 25;\n+pub const CTL_P1003_1B_MAXID: ::c_int = 26;\n+\n+pub const EVFILT_READ: ::int16_t = -1;\n+pub const EVFILT_WRITE: ::int16_t = -2;\n+pub const EVFILT_AIO: ::int16_t = -3;\n+pub const EVFILT_VNODE: ::int16_t = -4;\n+pub const EVFILT_PROC: ::int16_t = -5;\n+pub const EVFILT_SIGNAL: ::int16_t = -6;\n+pub const EVFILT_TIMER: ::int16_t = -7;\n+pub const EVFILT_PROCDESC: ::int16_t = -8;\n+pub const EVFILT_USER: ::int16_t = -9;\n+pub const EVFILT_FS: ::int16_t = -10;\n+\n+pub const EV_ADD: ::uint16_t = 0x1;\n+pub const EV_DELETE: ::uint16_t = 0x2;\n+pub const EV_ENABLE: ::uint16_t = 0x4;\n+pub const EV_DISABLE: ::uint16_t = 0x8;\n+pub const EV_ONESHOT: ::uint16_t = 0x10;\n+pub const EV_CLEAR: ::uint16_t = 0x20;\n+pub const EV_RECEIPT: ::uint16_t = 0x40;\n+pub const EV_DISPATCH: ::uint16_t = 0x80;\n+pub const EV_NODATA: ::uint16_t = 0x1000;\n+pub const EV_FLAG1: ::uint16_t = 0x2000;\n+pub const EV_ERROR: ::uint16_t = 0x4000;\n+pub const EV_EOF: ::uint16_t = 0x8000;\n+pub const EV_SYSFLAGS: ::uint16_t = 0xf000;\n+\n+pub const NOTE_TRIGGER: ::uint32_t = 0x01000000;\n+pub const NOTE_FFNOP: ::uint32_t = 0x00000000;\n+pub const NOTE_FFAND: ::uint32_t = 0x40000000;\n+pub const NOTE_FFOR: ::uint32_t = 0x80000000;\n+pub const NOTE_FFCOPY: ::uint32_t = 0xc0000000;\n+pub const NOTE_FFCTRLMASK: ::uint32_t = 0xc0000000;\n+pub const NOTE_FFLAGSMASK: ::uint32_t = 0x00ffffff;\n+pub const NOTE_LOWAT: ::uint32_t = 0x00000001;\n+pub const NOTE_OOB: ::uint32_t = 0x00000002;\n+pub const NOTE_DELETE: ::uint32_t = 0x00000001;\n+pub const NOTE_WRITE: ::uint32_t = 0x00000002;\n+pub const NOTE_EXTEND: ::uint32_t = 0x00000004;\n+pub const NOTE_ATTRIB: ::uint32_t = 0x00000008;\n+pub const NOTE_LINK: ::uint32_t = 0x00000010;\n+pub const NOTE_RENAME: ::uint32_t = 0x00000020;\n+pub const NOTE_REVOKE: ::uint32_t = 0x00000040;\n+pub const NOTE_EXIT: ::uint32_t = 0x80000000;\n+pub const NOTE_FORK: ::uint32_t = 0x40000000;\n+pub const NOTE_EXEC: ::uint32_t = 0x20000000;\n+pub const NOTE_PDATAMASK: ::uint32_t = 0x000fffff;\n+pub const NOTE_PCTRLMASK: ::uint32_t = 0xf0000000;\n+pub const NOTE_TRACK: ::uint32_t = 0x00000001;\n+pub const NOTE_TRACKERR: ::uint32_t = 0x00000002;\n+pub const NOTE_CHILD: ::uint32_t = 0x00000004;\n+\n+pub const MSG_NOSIGNAL: ::uint32_t = 0x400;\n+\n+extern {\n+    pub fn mprotect(addr: *mut ::c_void, len: ::size_t, prot: ::c_int)\n+                    -> ::c_int;\n+    pub fn clock_getres(clk_id: clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_gettime(clk_id: clockid_t, tp: *mut ::timespec) -> ::c_int;\n+}"}, {"sha": "a89440ebdebace111efc454cb2e7216967078a27", "filename": "src/vendor/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,306 @@\n+pub type fflags_t = u32;\n+pub type clock_t = i32;\n+pub type ino_t = u32;\n+pub type nlink_t = u16;\n+pub type blksize_t = u32;\n+pub type clockid_t = ::c_int;\n+\n+pub type fsblkcnt_t = ::uint64_t;\n+pub type fsfilcnt_t = ::uint64_t;\n+\n+s! {\n+    pub struct dirent {\n+        pub d_fileno: u32,\n+        pub d_reclen: u16,\n+        pub d_type: u8,\n+        pub d_namlen: u8,\n+        pub d_name: [::c_char; 256],\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_bsize: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_fsid: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+    }\n+}\n+\n+pub const RAND_MAX: ::c_int = 0x7fff_fffd;\n+pub const PTHREAD_STACK_MIN: ::size_t = 2048;\n+pub const SIGSTKSZ: ::size_t = 34816;\n+pub const SF_NODISKIO: ::c_int = 0x00000001;\n+pub const SF_MNOWAIT: ::c_int = 0x00000002;\n+pub const SF_SYNC: ::c_int = 0x00000004;\n+pub const O_CLOEXEC: ::c_int = 0x00100000;\n+pub const F_GETLK: ::c_int = 11;\n+pub const F_SETLK: ::c_int = 12;\n+pub const F_SETLKW: ::c_int = 13;\n+pub const ELAST: ::c_int = 96;\n+pub const RLIMIT_NPTS: ::c_int = 11;\n+pub const RLIMIT_SWAP: ::c_int = 12;\n+pub const RLIM_NLIMITS: ::rlim_t = 13;\n+\n+pub const Q_GETQUOTA: ::c_int = 0x700;\n+pub const Q_SETQUOTA: ::c_int = 0x800;\n+\n+pub const POSIX_FADV_NORMAL: ::c_int = 0;\n+pub const POSIX_FADV_RANDOM: ::c_int = 1;\n+pub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;\n+pub const POSIX_FADV_WILLNEED: ::c_int = 3;\n+pub const POSIX_FADV_DONTNEED: ::c_int = 4;\n+pub const POSIX_FADV_NOREUSE: ::c_int = 5;\n+\n+pub const EVFILT_READ: ::int16_t = -1;\n+pub const EVFILT_WRITE: ::int16_t = -2;\n+pub const EVFILT_AIO: ::int16_t = -3;\n+pub const EVFILT_VNODE: ::int16_t = -4;\n+pub const EVFILT_PROC: ::int16_t = -5;\n+pub const EVFILT_SIGNAL: ::int16_t = -6;\n+pub const EVFILT_TIMER: ::int16_t = -7;\n+pub const EVFILT_FS: ::int16_t = -9;\n+pub const EVFILT_LIO: ::int16_t = -10;\n+pub const EVFILT_USER: ::int16_t = -11;\n+\n+pub const EV_ADD: ::uint16_t = 0x1;\n+pub const EV_DELETE: ::uint16_t = 0x2;\n+pub const EV_ENABLE: ::uint16_t = 0x4;\n+pub const EV_DISABLE: ::uint16_t = 0x8;\n+pub const EV_ONESHOT: ::uint16_t = 0x10;\n+pub const EV_CLEAR: ::uint16_t = 0x20;\n+pub const EV_RECEIPT: ::uint16_t = 0x40;\n+pub const EV_DISPATCH: ::uint16_t = 0x80;\n+pub const EV_DROP: ::uint16_t = 0x1000;\n+pub const EV_FLAG1: ::uint16_t = 0x2000;\n+pub const EV_ERROR: ::uint16_t = 0x4000;\n+pub const EV_EOF: ::uint16_t = 0x8000;\n+pub const EV_SYSFLAGS: ::uint16_t = 0xf000;\n+\n+pub const NOTE_TRIGGER: ::uint32_t = 0x01000000;\n+pub const NOTE_FFNOP: ::uint32_t = 0x00000000;\n+pub const NOTE_FFAND: ::uint32_t = 0x40000000;\n+pub const NOTE_FFOR: ::uint32_t = 0x80000000;\n+pub const NOTE_FFCOPY: ::uint32_t = 0xc0000000;\n+pub const NOTE_FFCTRLMASK: ::uint32_t = 0xc0000000;\n+pub const NOTE_FFLAGSMASK: ::uint32_t = 0x00ffffff;\n+pub const NOTE_LOWAT: ::uint32_t = 0x00000001;\n+pub const NOTE_DELETE: ::uint32_t = 0x00000001;\n+pub const NOTE_WRITE: ::uint32_t = 0x00000002;\n+pub const NOTE_EXTEND: ::uint32_t = 0x00000004;\n+pub const NOTE_ATTRIB: ::uint32_t = 0x00000008;\n+pub const NOTE_LINK: ::uint32_t = 0x00000010;\n+pub const NOTE_RENAME: ::uint32_t = 0x00000020;\n+pub const NOTE_REVOKE: ::uint32_t = 0x00000040;\n+pub const NOTE_EXIT: ::uint32_t = 0x80000000;\n+pub const NOTE_FORK: ::uint32_t = 0x40000000;\n+pub const NOTE_EXEC: ::uint32_t = 0x20000000;\n+pub const NOTE_PDATAMASK: ::uint32_t = 0x000fffff;\n+pub const NOTE_PCTRLMASK: ::uint32_t = 0xf0000000;\n+pub const NOTE_TRACK: ::uint32_t = 0x00000001;\n+pub const NOTE_TRACKERR: ::uint32_t = 0x00000002;\n+pub const NOTE_CHILD: ::uint32_t = 0x00000004;\n+pub const NOTE_SECONDS: ::uint32_t = 0x00000001;\n+pub const NOTE_MSECONDS: ::uint32_t = 0x00000002;\n+pub const NOTE_USECONDS: ::uint32_t = 0x00000004;\n+pub const NOTE_NSECONDS: ::uint32_t = 0x00000008;\n+\n+pub const MADV_PROTECT: ::c_int = 10;\n+pub const RUSAGE_THREAD: ::c_int = 1;\n+\n+pub const CLOCK_REALTIME: clockid_t = 0;\n+pub const CLOCK_VIRTUAL: clockid_t = 1;\n+pub const CLOCK_PROF: clockid_t = 2;\n+pub const CLOCK_MONOTONIC: clockid_t = 4;\n+pub const CLOCK_UPTIME: clockid_t = 5;\n+pub const CLOCK_UPTIME_PRECISE: clockid_t = 7;\n+pub const CLOCK_UPTIME_FAST: clockid_t = 8;\n+pub const CLOCK_REALTIME_PRECISE: clockid_t = 9;\n+pub const CLOCK_REALTIME_FAST: clockid_t = 10;\n+pub const CLOCK_MONOTONIC_PRECISE: clockid_t = 11;\n+pub const CLOCK_MONOTONIC_FAST: clockid_t = 12;\n+pub const CLOCK_SECOND: clockid_t = 13;\n+pub const CLOCK_THREAD_CPUTIME_ID: clockid_t = 14;\n+pub const CLOCK_PROCESS_CPUTIME_ID: clockid_t = 15;\n+\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_VFS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_USER: ::c_int = 8;\n+pub const CTL_P1003_1B: ::c_int = 9;\n+pub const CTL_MAXID: ::c_int = 10;\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_VNODE: ::c_int = 13;\n+pub const KERN_PROC: ::c_int = 14;\n+pub const KERN_FILE: ::c_int = 15;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_BOOTTIME: ::c_int = 21;\n+pub const KERN_NISDOMAINNAME: ::c_int = 22;\n+pub const KERN_UPDATEINTERVAL: ::c_int = 23;\n+pub const KERN_OSRELDATE: ::c_int = 24;\n+pub const KERN_NTP_PLL: ::c_int = 25;\n+pub const KERN_BOOTFILE: ::c_int = 26;\n+pub const KERN_MAXFILESPERPROC: ::c_int = 27;\n+pub const KERN_MAXPROCPERUID: ::c_int = 28;\n+pub const KERN_DUMPDEV: ::c_int = 29;\n+pub const KERN_IPC: ::c_int = 30;\n+pub const KERN_DUMMY: ::c_int = 31;\n+pub const KERN_PS_STRINGS: ::c_int = 32;\n+pub const KERN_USRSTACK: ::c_int = 33;\n+pub const KERN_LOGSIGEXIT: ::c_int = 34;\n+pub const KERN_IOV_MAX: ::c_int = 35;\n+pub const KERN_HOSTUUID: ::c_int = 36;\n+pub const KERN_ARND: ::c_int = 37;\n+pub const KERN_MAXID: ::c_int = 38;\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_ARGS: ::c_int = 7;\n+pub const KERN_PROC_PROC: ::c_int = 8;\n+pub const KERN_PROC_SV_NAME: ::c_int = 9;\n+pub const KERN_PROC_RGID: ::c_int = 10;\n+pub const KERN_PROC_GID: ::c_int = 11;\n+pub const KERN_PROC_PATHNAME: ::c_int = 12;\n+pub const KERN_PROC_OVMMAP: ::c_int = 13;\n+pub const KERN_PROC_OFILEDESC: ::c_int = 14;\n+pub const KERN_PROC_KSTACK: ::c_int = 15;\n+pub const KERN_PROC_INC_THREAD: ::c_int = 0x10;\n+pub const KERN_PROC_VMMAP: ::c_int = 32;\n+pub const KERN_PROC_FILEDESC: ::c_int = 33;\n+pub const KERN_PROC_GROUPS: ::c_int = 34;\n+pub const KERN_PROC_ENV: ::c_int = 35;\n+pub const KERN_PROC_AUXV: ::c_int = 36;\n+pub const KERN_PROC_RLIMIT: ::c_int = 37;\n+pub const KERN_PROC_PS_STRINGS: ::c_int = 38;\n+pub const KERN_PROC_UMASK: ::c_int = 39;\n+pub const KERN_PROC_OSREL: ::c_int = 40;\n+pub const KERN_PROC_SIGTRAMP: ::c_int = 41;\n+pub const KIPC_MAXSOCKBUF: ::c_int = 1;\n+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;\n+pub const KIPC_SOMAXCONN: ::c_int = 3;\n+pub const KIPC_MAX_LINKHDR: ::c_int = 4;\n+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;\n+pub const KIPC_MAX_HDR: ::c_int = 6;\n+pub const KIPC_MAX_DATALEN: ::c_int = 7;\n+pub const HW_MACHINE: ::c_int = 1;\n+pub const HW_MODEL: ::c_int = 2;\n+pub const HW_NCPU: ::c_int = 3;\n+pub const HW_BYTEORDER: ::c_int = 4;\n+pub const HW_PHYSMEM: ::c_int = 5;\n+pub const HW_USERMEM: ::c_int = 6;\n+pub const HW_PAGESIZE: ::c_int = 7;\n+pub const HW_DISKNAMES: ::c_int = 8;\n+pub const HW_DISKSTATS: ::c_int = 9;\n+pub const HW_FLOATINGPT: ::c_int = 10;\n+pub const HW_MACHINE_ARCH: ::c_int = 11;\n+pub const HW_REALMEM: ::c_int = 12;\n+pub const HW_MAXID: ::c_int = 13;\n+pub const USER_CS_PATH: ::c_int = 1;\n+pub const USER_BC_BASE_MAX: ::c_int = 2;\n+pub const USER_BC_DIM_MAX: ::c_int = 3;\n+pub const USER_BC_SCALE_MAX: ::c_int = 4;\n+pub const USER_BC_STRING_MAX: ::c_int = 5;\n+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;\n+pub const USER_EXPR_NEST_MAX: ::c_int = 7;\n+pub const USER_LINE_MAX: ::c_int = 8;\n+pub const USER_RE_DUP_MAX: ::c_int = 9;\n+pub const USER_POSIX2_VERSION: ::c_int = 10;\n+pub const USER_POSIX2_C_BIND: ::c_int = 11;\n+pub const USER_POSIX2_C_DEV: ::c_int = 12;\n+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;\n+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;\n+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;\n+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;\n+pub const USER_POSIX2_SW_DEV: ::c_int = 17;\n+pub const USER_POSIX2_UPE: ::c_int = 18;\n+pub const USER_STREAM_MAX: ::c_int = 19;\n+pub const USER_TZNAME_MAX: ::c_int = 20;\n+pub const USER_MAXID: ::c_int = 21;\n+pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::c_int = 1;\n+pub const CTL_P1003_1B_MAPPED_FILES: ::c_int = 2;\n+pub const CTL_P1003_1B_MEMLOCK: ::c_int = 3;\n+pub const CTL_P1003_1B_MEMLOCK_RANGE: ::c_int = 4;\n+pub const CTL_P1003_1B_MEMORY_PROTECTION: ::c_int = 5;\n+pub const CTL_P1003_1B_MESSAGE_PASSING: ::c_int = 6;\n+pub const CTL_P1003_1B_PRIORITIZED_IO: ::c_int = 7;\n+pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::c_int = 8;\n+pub const CTL_P1003_1B_REALTIME_SIGNALS: ::c_int = 9;\n+pub const CTL_P1003_1B_SEMAPHORES: ::c_int = 10;\n+pub const CTL_P1003_1B_FSYNC: ::c_int = 11;\n+pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::c_int = 12;\n+pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::c_int = 13;\n+pub const CTL_P1003_1B_TIMERS: ::c_int = 14;\n+pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::c_int = 15;\n+pub const CTL_P1003_1B_AIO_MAX: ::c_int = 16;\n+pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::c_int = 17;\n+pub const CTL_P1003_1B_DELAYTIMER_MAX: ::c_int = 18;\n+pub const CTL_P1003_1B_MQ_OPEN_MAX: ::c_int = 19;\n+pub const CTL_P1003_1B_PAGESIZE: ::c_int = 20;\n+pub const CTL_P1003_1B_RTSIG_MAX: ::c_int = 21;\n+pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::c_int = 22;\n+pub const CTL_P1003_1B_SEM_VALUE_MAX: ::c_int = 23;\n+pub const CTL_P1003_1B_SIGQUEUE_MAX: ::c_int = 24;\n+pub const CTL_P1003_1B_TIMER_MAX: ::c_int = 25;\n+pub const CTL_P1003_1B_MAXID: ::c_int = 26;\n+\n+pub const MSG_NOSIGNAL: ::c_int = 0x20000;\n+\n+extern {\n+    pub fn __error() -> *mut ::c_int;\n+\n+    pub fn mprotect(addr: *const ::c_void, len: ::size_t, prot: ::c_int)\n+                    -> ::c_int;\n+\n+    pub fn clock_getres(clk_id: clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_gettime(clk_id: clockid_t, tp: *mut ::timespec) -> ::c_int;\n+\n+    pub fn posix_fallocate(fd: ::c_int, offset: ::off_t,\n+                           len: ::off_t) -> ::c_int;\n+    pub fn posix_fadvise(fd: ::c_int, offset: ::off_t, len: ::off_t,\n+                         advise: ::c_int) -> ::c_int;\n+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;\n+    pub fn mkostemps(template: *mut ::c_char,\n+                     suffixlen: ::c_int,\n+                     flags: ::c_int) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"x86\")] {\n+        mod x86;\n+        pub use self::x86::*;\n+    } else if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}"}, {"sha": "8a5e5f9fb8d28fb9b624e02af35b244b95a4f7c0", "filename": "src/vendor/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fx86.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,31 @@\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type time_t = i32;\n+pub type suseconds_t = i32;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: ::fflags_t,\n+        pub st_gen: ::uint32_t,\n+        pub st_lspare: ::int32_t,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+        __unused: [u8; 8],\n+    }\n+}"}, {"sha": "a2da8452c4d341f0d43736c244226fd723b6f55d", "filename": "src/vendor/libc/src/unix/bsd/freebsdlike/freebsd/x86_64.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Ffreebsd%2Fx86_64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd", "patch": "@@ -0,0 +1,30 @@\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type time_t = i64;\n+pub type suseconds_t = i64;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: ::fflags_t,\n+        pub st_gen: ::uint32_t,\n+        pub st_lspare: ::int32_t,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+    }\n+}"}, {"sha": "2cfb323c061d6ac44935991492c93c735ff4df9a", "filename": "src/vendor/libc/src/unix/bsd/freebsdlike/mod.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Ffreebsdlike%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "0616cd3518428cb8447133c477cf30c0848c1442", "filename": "src/vendor/libc/src/unix/bsd/mod.rs", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "6604ec03b2cb23be55191fcd2841523b73f48b5f", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/mod.rs", "status": "added", "additions": 547, "deletions": 0, "changes": 547, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "aa46aff191037b9b18f300336f525e21bb571292", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs", "status": "added", "additions": 618, "deletions": 0, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "9b0b338b91e5b52050c6d0edab5b3d5ea0263037", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/netbsd/other/b32/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fb32%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fb32%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fb32%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "b07c476aa49d963c7476fa17418927e5ffc9c2e4", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/netbsd/other/b64/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fb64%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fb64%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fb64%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "f4e7cc406125bdf6e2d18e5a10bf2c8fce410127", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/netbsd/other/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fnetbsd%2Fother%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "695cf68dc5a4e9ac87c2962674a1c3990ffab01d", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/openbsdlike/bitrig.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fbitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fbitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fbitrig.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "d7afb11eddd808306d074431289d511559975bec", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/openbsdlike/mod.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "b7fed64ede5b0d1d8ebe6089bc8b308dc5c70452", "filename": "src/vendor/libc/src/unix/bsd/netbsdlike/openbsdlike/openbsd.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fopenbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fopenbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fbsd%2Fnetbsdlike%2Fopenbsdlike%2Fopenbsd.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "9b0b338b91e5b52050c6d0edab5b3d5ea0263037", "filename": "src/vendor/libc/src/unix/haiku/b32.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fb32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fb32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fb32.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "5d63ce9ce43e04c7801a6944fc9bb5cfb8db0d3b", "filename": "src/vendor/libc/src/unix/haiku/b64.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fb64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fb64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fb64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "a241a020548109e43428d9dcc363c4bdcfd0ec38", "filename": "src/vendor/libc/src/unix/haiku/mod.rs", "status": "added", "additions": 748, "deletions": 0, "changes": 748, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fhaiku%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "e822b063d9f7aed10cf0b2167115c5f4bbf6a7dc", "filename": "src/vendor/libc/src/unix/mod.rs", "status": "added", "additions": 862, "deletions": 0, "changes": 862, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "bd69ccf37d571b910d0ba5ca0836dadf02f43416", "filename": "src/vendor/libc/src/unix/notbsd/android/b32.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fb32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fb32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fb32.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "b35dde4216059931eec5370c719f7fbfa8909b25", "filename": "src/vendor/libc/src/unix/notbsd/android/b64.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fb64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fb64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fb64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "efc136817db6f1c4d95112d86dab07eae2798d6e", "filename": "src/vendor/libc/src/unix/notbsd/android/mod.rs", "status": "added", "additions": 779, "deletions": 0, "changes": 779, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Fandroid%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "085f2b31ce65c1620a9aaf31b549c6a80e0299ef", "filename": "src/vendor/libc/src/unix/notbsd/linux/mips.rs", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmips.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "30c336e6904d47e877a1bc0731c2d31e6a1d0458", "filename": "src/vendor/libc/src/unix/notbsd/linux/mips64.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmips64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "ea820ea5c6c2cc9205499016151ede67dea5659c", "filename": "src/vendor/libc/src/unix/notbsd/linux/mod.rs", "status": "added", "additions": 747, "deletions": 0, "changes": 747, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "998580d3e21a4d12a717e08be1f0b6f495f9616c", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b32/arm.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Farm.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "91a96c185a91feb79e6528f16ebbfe94fcc2480e", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b32/asmjs.rs", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fasmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fasmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fasmjs.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "9ebfe4a68fea81aa7efdd2ffcc3ca492bd11dd5f", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b32/mips.rs", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fmips.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "899bc69310906c8acdb806584cfe3c9de90a6ba2", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b32/mod.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "194b8fd8bdc2d603e1ef414fb6d455cfdd7dc093", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b32/x86.rs", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb32%2Fx86.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "23f7dd35e5c98a45e9e7eea2abdd1205900a5e92", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b64/aarch64.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Faarch64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "fdaf52e166c6eaa07924878d4181eb48c5c73b8b", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b64/mod.rs", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "4b8ca10aab57bbf76ad767ec4753b834a40e87e8", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b64/powerpc64.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fpowerpc64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "2cfd903ca84fbe30b8c8ef9f282391ced5e7a733", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/b64/x86_64.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fb64%2Fx86_64.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}, {"sha": "69a85b86eaa33448d5ec143ba486159e99227f0c", "filename": "src/vendor/libc/src/unix/notbsd/linux/musl/mod.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da2ce2276873242a101f205537e7ce297d68f8dd/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Flibc%2Fsrc%2Funix%2Fnotbsd%2Flinux%2Fmusl%2Fmod.rs?ref=da2ce2276873242a101f205537e7ce297d68f8dd"}]}