{"sha": "a2bca90077962e513330ca4a6b729f8262ccf8d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYmNhOTAwNzc5NjJlNTEzMzMwY2E0YTZiNzI5ZjgyNjJjY2Y4ZDI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-13T15:23:42Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-03-19T14:22:55Z"}, "message": "Make metadata prefetching more accurate", "tree": {"sha": "e78962599e24507a9d7bfb7ed98f701f512e0e1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e78962599e24507a9d7bfb7ed98f701f512e0e1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2bca90077962e513330ca4a6b729f8262ccf8d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2bca90077962e513330ca4a6b729f8262ccf8d2", "html_url": "https://github.com/rust-lang/rust/commit/a2bca90077962e513330ca4a6b729f8262ccf8d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2bca90077962e513330ca4a6b729f8262ccf8d2/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d59c0ee38e1f1796e3ae9e6124f0b257a9983f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d59c0ee38e1f1796e3ae9e6124f0b257a9983f4", "html_url": "https://github.com/rust-lang/rust/commit/3d59c0ee38e1f1796e3ae9e6124f0b257a9983f4"}], "stats": {"total": 82, "additions": 75, "deletions": 7}, "files": [{"sha": "0e735eeb01c8eedd0901d41b64f310e13a6804ba", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a2bca90077962e513330ca4a6b729f8262ccf8d2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2bca90077962e513330ca4a6b729f8262ccf8d2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=a2bca90077962e513330ca4a6b729f8262ccf8d2", "patch": "@@ -18,12 +18,13 @@ use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::{join, par_for_each_in, Lrc};\n+use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_index::vec::Idx;\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n@@ -1697,6 +1698,66 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     }\n }\n \n+/// Used to prefetch queries which will be needed later by metadata encoding.\n+struct PrefetchVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mir_keys: &'tcx DefIdSet,\n+}\n+\n+impl<'tcx> PrefetchVisitor<'tcx> {\n+    fn prefetch_mir(&self, def_id: DefId) {\n+        if self.mir_keys.contains(&def_id) {\n+            self.tcx.optimized_mir(def_id);\n+            self.tcx.promoted_mir(def_id);\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n+    fn visit_item(&self, item: &hir::Item<'_>) {\n+        let tcx = self.tcx;\n+        match item.kind {\n+            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n+                self.prefetch_mir(tcx.hir().local_def_id(item.hir_id))\n+            }\n+            hir::ItemKind::Fn(ref sig, ..) => {\n+                let def_id = tcx.hir().local_def_id(item.hir_id);\n+                let generics = tcx.generics_of(def_id);\n+                let needs_inline = generics.requires_monomorphization(tcx)\n+                    || tcx.codegen_fn_attrs(def_id).requests_inline();\n+                if needs_inline || sig.header.constness == hir::Constness::Const {\n+                    self.prefetch_mir(def_id)\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    fn visit_trait_item(&self, trait_item: &'v hir::TraitItem<'v>) {\n+        self.prefetch_mir(self.tcx.hir().local_def_id(trait_item.hir_id));\n+    }\n+\n+    fn visit_impl_item(&self, impl_item: &'v hir::ImplItem<'v>) {\n+        let tcx = self.tcx;\n+        match impl_item.kind {\n+            hir::ImplItemKind::Const(..) => {\n+                self.prefetch_mir(tcx.hir().local_def_id(impl_item.hir_id))\n+            }\n+            hir::ImplItemKind::Fn(ref sig, _) => {\n+                let def_id = tcx.hir().local_def_id(impl_item.hir_id);\n+                let generics = tcx.generics_of(def_id);\n+                let needs_inline = generics.requires_monomorphization(tcx)\n+                    || tcx.codegen_fn_attrs(def_id).requests_inline();\n+                let is_const_fn = sig.header.constness == hir::Constness::Const;\n+                if needs_inline || is_const_fn {\n+                    self.prefetch_mir(def_id)\n+                }\n+            }\n+            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => (),\n+        }\n+    }\n+}\n+\n // NOTE(eddyb) The following comment was preserved for posterity, even\n // though it's no longer relevant as EBML (which uses nested & tagged\n // \"documents\") was replaced with a scheme that can't go out of bounds.\n@@ -1724,14 +1785,21 @@ pub(super) fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     join(\n         || encode_metadata_impl(tcx),\n         || {\n-            // Prefetch some queries used by metadata encoding\n+            if tcx.sess.threads() == 1 {\n+                return;\n+            }\n+            // Prefetch some queries used by metadata encoding.\n             tcx.dep_graph.with_ignore(|| {\n                 join(\n                     || {\n-                        par_for_each_in(tcx.mir_keys(LOCAL_CRATE), |&def_id| {\n-                            tcx.optimized_mir(def_id);\n-                            tcx.promoted_mir(def_id);\n-                        })\n+                        if !tcx.sess.opts.output_types.should_codegen() {\n+                            // We won't emit MIR, so don't prefetch it.\n+                            return;\n+                        }\n+                        tcx.hir().krate().par_visit_all_item_likes(&PrefetchVisitor {\n+                            tcx,\n+                            mir_keys: tcx.mir_keys(LOCAL_CRATE),\n+                        });\n                     },\n                     || tcx.exported_symbols(LOCAL_CRATE),\n                 );"}]}