{"sha": "f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MGJjM2FjMGMyMGY3YjNhYjg1ZGYxZTVlMmUzMjE3YTdhOTU2MzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-19T22:43:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-19T22:43:58Z"}, "message": "Auto merge of #44505 - nikomatsakis:lotsa-comments, r=steveklabnik\n\nrework the README.md for rustc and add other readmes\n\nOK, so, long ago I committed to the idea of trying to write some high-level documentation for rustc. This has proved to be much harder for me to get done than I thought it would! This PR is far from as complete as I had hoped, but I wanted to open it so that people can give me feedback on the conventions that it establishes. If this seems like a good way forward, we can land it and I will open an issue with a good check-list of things to write (and try to take down some of them myself).\n\nHere are the conventions I established on which I would like feedback.\n\n**Use README.md files**. First off, I'm aiming to keep most of the high-level docs in `README.md` files, rather than entries on forge. My thought is that such files are (a) more discoverable than forge and (b) closer to the code, and hence can be edited in a single PR. However, since they are not *in the code*, they will naturally get out of date, so the intention is to focus on the highest-level details, which are least likely to bitrot. I've included a few examples of common functions and so forth, but never tried to (e.g.) exhaustively list the names of functions and so forth.\n    - I would like to use the tidy scripts to try and check that these do not go out of date. Future work.\n\n**librustc/README.md as the main entrypoint.** This seems like the most natural place people will look first. It lays out how the crates are structured and **is intended** to give pointers to the main data structures of the compiler (I didn't update that yet; the existing material is terribly dated).\n\n**A glossary listing abbreviations and things.** It's much harder to read code if you don't know what some obscure set of letters like `infcx` stands for.\n\n**Major modules each have their own README.md that documents the high-level idea.** For example, I wrote some stuff about `hir` and `ty`. Both of them have many missing topics, but I think that is roughly the level of depth that would be good. The idea is to give people a \"feeling\" for what the code does.\n\nWhat is missing primarily here is lots of content. =) Here are some things I'd like to see:\n\n- A description of what a QUERY is and how to define one\n    - Some comments for `librustc/ty/maps.rs`\n- An overview of how compilation proceeds now (i.e., the hybrid demand-driven and forward model) and how we would like to see it going in the future (all demand-driven)\n- Some coverage of how incremental will work under red-green\n- An updated list of the major IRs in use of the compiler (AST, HIR, TypeckTables, MIR) and major bits of interesting code (typeck, borrowck, etc)\n- More advice on how to use `x.py`, or at least pointers to that\n- Good choice for `config.toml`\n- How to use `RUST_LOG` and other debugging flags (e.g., `-Zverbose`, `-Ztreat-err-as-bug`)\n- Helpful conventions for `debug!` statement formatting\n\ncc @rust-lang/compiler @mgattozzi", "tree": {"sha": "471ca5db34286826e74ef1506f07ad3c9e31f0dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/471ca5db34286826e74ef1506f07ad3c9e31f0dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "html_url": "https://github.com/rust-lang/rust/commit/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "325ba23d5525ecdd555f19c7f527bce913dfd756", "url": "https://api.github.com/repos/rust-lang/rust/commits/325ba23d5525ecdd555f19c7f527bce913dfd756", "html_url": "https://github.com/rust-lang/rust/commit/325ba23d5525ecdd555f19c7f527bce913dfd756"}, {"sha": "638958bd1310f790b2c7b92e14d9dc423226226c", "url": "https://api.github.com/repos/rust-lang/rust/commits/638958bd1310f790b2c7b92e14d9dc423226226c", "html_url": "https://github.com/rust-lang/rust/commit/638958bd1310f790b2c7b92e14d9dc423226226c"}], "stats": {"total": 4328, "additions": 2571, "deletions": 1757}, "files": [{"sha": "59d346db4af4d438f02bdcee83c789b54d5d4367", "filename": "src/librustc/README.md", "status": "modified", "additions": 185, "deletions": 156, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -13,162 +13,191 @@ https://github.com/rust-lang/rust/issues\n \n Your concerns are probably the same as someone else's.\n \n+You may also be interested in the\n+[Rust Forge](https://forge.rust-lang.org/), which includes a number of\n+interesting bits of information.\n+\n+Finally, at the end of this file is a GLOSSARY defining a number of\n+common (and not necessarily obvious!) names that are used in the Rust\n+compiler code. If you see some funky name and you'd like to know what\n+it stands for, check there!\n+\n The crates of rustc\n ===================\n \n-Rustc consists of a number of crates, including `libsyntax`,\n-`librustc`, `librustc_back`, `librustc_trans`, and `librustc_driver`\n-(the names and divisions are not set in stone and may change;\n-in general, a finer-grained division of crates is preferable):\n-\n-- [`libsyntax`][libsyntax] contains those things concerned purely with syntax \u2013\n-  that is, the AST, parser, pretty-printer, lexer, macro expander, and\n-  utilities for traversing ASTs \u2013 are in a separate crate called\n-  \"syntax\", whose files are in `./../libsyntax`, where `.` is the\n-  current directory (that is, the parent directory of front/, middle/,\n-  back/, and so on).\n-\n-- `librustc` (the current directory) contains the high-level analysis\n-  passes, such as the type checker, borrow checker, and so forth.\n-  It is the heart of the compiler.\n-\n-- [`librustc_back`][back] contains some very low-level details that are\n-  specific to different LLVM targets and so forth.\n-\n-- [`librustc_trans`][trans] contains the code to convert from Rust IR into LLVM\n-  IR, and then from LLVM IR into machine code, as well as the main\n-  driver that orchestrates all the other passes and various other bits\n-  of miscellany. In general it contains code that runs towards the\n-  end of the compilation process.\n-\n-- [`librustc_driver`][driver] invokes the compiler from\n-  [`libsyntax`][libsyntax], then the analysis phases from `librustc`, and\n-  finally the lowering and codegen passes from [`librustc_trans`][trans].\n-\n-Roughly speaking the \"order\" of the three crates is as follows:\n-\n-              librustc_driver\n-                      |\n-    +-----------------+-------------------+\n-    |                                     |\n-    libsyntax -> librustc -> librustc_trans\n-\n-\n-The compiler process:\n-=====================\n-\n-The Rust compiler is comprised of six main compilation phases.\n-\n-1. Parsing input\n-2. Configuration & expanding (cfg rules & syntax extension expansion)\n-3. Running analysis passes\n-4. Translation to LLVM\n-5. LLVM passes\n-6. Linking\n-\n-Phase one is responsible for parsing & lexing the input to the compiler. The\n-output of this phase is an abstract syntax tree (AST). The AST at this point\n-includes all macro uses & attributes. This means code which will be later\n-expanded and/or removed due to `cfg` attributes is still present in this\n-version of the AST. Parsing abstracts away details about individual files which\n-have been read into the AST.\n-\n-Phase two handles configuration and macro expansion. You can think of this\n-phase as a function acting on the AST from the previous phase. The input for\n-this phase is the unexpanded AST from phase one, and the output is an expanded\n-version of the same AST. This phase will expand all macros & syntax\n-extensions and will evaluate all `cfg` attributes, potentially removing some\n-code. The resulting AST will not contain any macros or `macro_use` statements.\n-\n-The code for these first two phases is in [`libsyntax`][libsyntax].\n-\n-After this phase, the compiler allocates IDs to each node in the AST\n-(technically not every node, but most of them). If we are writing out\n-dependencies, that happens now.\n-\n-The third phase is analysis. This is the most complex phase in the compiler,\n-and makes up much of the code. This phase included name resolution, type\n-checking, borrow checking, type & lifetime inference, trait selection, method\n-selection, linting and so on. Most of the error detection in the compiler comes\n-from this phase (with the exception of parse errors which arise during\n-parsing). The \"output\" of this phase is a set of side tables containing\n-semantic information about the source program. The analysis code is in\n-[`librustc`][rustc] and some other crates with the `librustc_` prefix.\n-\n-The fourth phase is translation. This phase translates the AST (and the side\n-tables from the previous phase) into LLVM IR (intermediate representation).\n-This is achieved by calling into the LLVM libraries. The code for this is in\n-[`librustc_trans`][trans].\n-\n-Phase five runs the LLVM backend. This runs LLVM's optimization passes on the\n-generated IR and generates machine code resulting in object files. This phase\n-is not really part of the Rust compiler, as LLVM carries out all the work.\n-The interface between LLVM and Rust is in [`librustc_llvm`][llvm].\n-\n-The final phase, phase six, links the object files into an executable. This is\n-again outsourced to other tools and not performed by the Rust compiler\n-directly. The interface is in [`librustc_back`][back] (which also contains some\n-things used primarily during translation).\n-\n-A module called the driver coordinates all these phases. It handles all the\n-highest level coordination of compilation from parsing command line arguments\n-all the way to invoking the linker to produce an executable.\n-\n-Modules in the librustc crate\n-=============================\n-\n-The librustc crate itself consists of the following submodules\n-(mostly, but not entirely, in their own directories):\n-\n-- session: options and data that pertain to the compilation session as\n-  a whole\n-- middle: middle-end: name resolution, typechecking, LLVM code\n-  generation\n-- metadata: encoder and decoder for data required by separate\n-  compilation\n-- plugin: infrastructure for compiler plugins\n-- lint: infrastructure for compiler warnings\n-- util: ubiquitous types and helper functions\n-- lib: bindings to LLVM\n-\n-The entry-point for the compiler is main() in the [`librustc_driver`][driver]\n-crate.\n-\n-The 3 central data structures:\n-------------------------------\n-\n-1. `./../libsyntax/ast.rs` defines the AST. The AST is treated as\n-   immutable after parsing, but it depends on mutable context data\n-   structures (mainly hash maps) to give it meaning.\n-\n-   - Many \u2013 though not all \u2013 nodes within this data structure are\n-     wrapped in the type `spanned<T>`, meaning that the front-end has\n-     marked the input coordinates of that node. The member `node` is\n-     the data itself, the member `span` is the input location (file,\n-     line, column; both low and high).\n-\n-   - Many other nodes within this data structure carry a\n-     `def_id`. These nodes represent the 'target' of some name\n-     reference elsewhere in the tree. When the AST is resolved, by\n-     `middle/resolve.rs`, all names wind up acquiring a def that they\n-     point to. So anything that can be pointed-to by a name winds\n-     up with a `def_id`.\n-\n-2. `middle/ty.rs` defines the datatype `sty`. This is the type that\n-   represents types after they have been resolved and normalized by\n-   the middle-end. The typeck phase converts every ast type to a\n-   `ty::sty`, and the latter is used to drive later phases of\n-   compilation. Most variants in the `ast::ty` tag have a\n-   corresponding variant in the `ty::sty` tag.\n-\n-3. `./../librustc_llvm/lib.rs` defines the exported types\n-   `ValueRef`, `TypeRef`, `BasicBlockRef`, and several others.\n-   Each of these is an opaque pointer to an LLVM type,\n-   manipulated through the `lib::llvm` interface.\n-\n-[libsyntax]: https://github.com/rust-lang/rust/tree/master/src/libsyntax/\n-[trans]: https://github.com/rust-lang/rust/tree/master/src/librustc_trans/\n-[llvm]: https://github.com/rust-lang/rust/tree/master/src/librustc_llvm/\n-[back]: https://github.com/rust-lang/rust/tree/master/src/librustc_back/\n-[rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc/\n-[driver]: https://github.com/rust-lang/rust/tree/master/src/librustc_driver\n+Rustc consists of a number of crates, including `syntax`,\n+`rustc`, `rustc_back`, `rustc_trans`, `rustc_driver`, and\n+many more. The source for each crate can be found in a directory\n+like `src/libXXX`, where `XXX` is the crate name.\n+\n+(NB. The names and divisions of these crates are not set in\n+stone and may change over time -- for the time being, we tend towards\n+a finer-grained division to help with compilation time, though as\n+incremental improves that may change.)\n+\n+The dependency structure of these crates is roughly a diamond:\n+\n+````\n+                  rustc_driver\n+                /      |       \\\n+              /        |         \\\n+            /          |           \\\n+          /            v             \\\n+rustc_trans    rustc_borrowck   ...  rustc_metadata\n+          \\            |            /\n+            \\          |          /\n+              \\        |        /\n+                \\      v      /\n+                    rustc\n+                       |\n+                       v\n+                    syntax\n+                    /    \\\n+                  /       \\\n+           syntax_pos  syntax_ext\n+```                    \n+\n+The `rustc_driver` crate, at the top of this lattice, is effectively\n+the \"main\" function for the rust compiler. It doesn't have much \"real\n+code\", but instead ties together all of the code defined in the other\n+crates and defines the overall flow of execution. (As we transition\n+more and more to the [query model](ty/maps/README.md), however, the\n+\"flow\" of compilation is becoming less centrally defined.)\n+\n+At the other extreme, the `rustc` crate defines the common and\n+pervasive data structures that all the rest of the compiler uses\n+(e.g., how to represent types, traits, and the program itself). It\n+also contains some amount of the compiler itself, although that is\n+relatively limited.\n+\n+Finally, all the crates in the bulge in the middle define the bulk of\n+the compiler -- they all depend on `rustc`, so that they can make use\n+of the various types defined there, and they export public routines\n+that `rustc_driver` will invoke as needed (more and more, what these\n+crates export are \"query definitions\", but those are covered later\n+on).\n+\n+Below `rustc` lie various crates that make up the parser and error\n+reporting mechanism. For historical reasons, these crates do not have\n+the `rustc_` prefix, but they are really just as much an internal part\n+of the compiler and not intended to be stable (though they do wind up\n+getting used by some crates in the wild; a practice we hope to\n+gradually phase out).\n+\n+Each crate has a `README.md` file that describes, at a high-level,\n+what it contains, and tries to give some kind of explanation (some\n+better than others).\n+\n+The compiler process\n+====================\n+\n+The Rust compiler is in a bit of transition right now. It used to be a\n+purely \"pass-based\" compiler, where we ran a number of passes over the\n+entire program, and each did a particular check of transformation.\n+\n+We are gradually replacing this pass-based code with an alternative\n+setup based on on-demand **queries**. In the query-model, we work\n+backwards, executing a *query* that expresses our ultimate goal (e.g.,\n+\"compiler this crate\"). This query in turn may make other queries\n+(e.g., \"get me a list of all modules in the crate\"). Those queries\n+make other queries that ultimately bottom out in the base operations,\n+like parsing the input, running the type-checker, and so forth. This\n+on-demand model permits us to do exciting things like only do the\n+minimal amount of work needed to type-check a single function. It also\n+helps with incremental compilation. (For details on defining queries,\n+check out `src/librustc/ty/maps/README.md`.)\n+\n+Regardless of the general setup, the basic operations that the\n+compiler must perform are the same. The only thing that changes is\n+whether these operations are invoked front-to-back, or on demand.  In\n+order to compile a Rust crate, these are the general steps that we\n+take:\n+\n+1. **Parsing input**\n+    - this processes the `.rs` files and produces the AST (\"abstract syntax tree\")\n+    - the AST is defined in `syntax/ast.rs`. It is intended to match the lexical\n+      syntax of the Rust language quite closely.\n+2. **Name resolution, macro expansion, and configuration**\n+    - once parsing is complete, we process the AST recursively, resolving paths\n+      and expanding macros. This same process also processes `#[cfg]` nodes, and hence\n+      may strip things out of the AST as well.\n+3. **Lowering to HIR**\n+    - Once name resolution completes, we convert the AST into the HIR,\n+      or \"high-level IR\". The HIR is defined in `src/librustc/hir/`; that module also includes\n+      the lowering code.\n+    - The HIR is a lightly desugared variant of the AST. It is more processed than the\n+      AST and more suitable for the analyses that follow. It is **not** required to match\n+      the syntax of the Rust language.\n+    - As a simple example, in the **AST**, we preserve the parentheses\n+      that the user wrote, so `((1 + 2) + 3)` and `1 + 2 + 3` parse\n+      into distinct trees, even though they are equivalent. In the\n+      HIR, however, parentheses nodes are removed, and those two\n+      expressions are represented in the same way.\n+3. **Type-checking and subsequent analyses**\n+    - An important step in processing the HIR is to perform type\n+      checking. This process assigns types to every HIR expression,\n+      for example, and also is responsible for resolving some\n+      \"type-dependent\" paths, such as field accesses (`x.f` -- we\n+      can't know what field `f` is being accessed until we know the\n+      type of `x`) and associated type references (`T::Item` -- we\n+      can't know what type `Item` is until we know what `T` is).\n+    - Type checking creates \"side-tables\" (`TypeckTables`) that include\n+      the types of expressions, the way to resolve methods, and so forth.\n+    - After type-checking, we can do other analyses, such as privacy checking.\n+4. **Lowering to MIR and post-processing**\n+    - Once type-checking is done, we can lower the HIR into MIR (\"middle IR\"), which\n+      is a **very** desugared version of Rust, well suited to the borrowck but also\n+      certain high-level optimizations. \n+5. **Translation to LLVM and LLVM optimizations**\n+    - From MIR, we can produce LLVM IR.\n+    - LLVM then runs its various optimizations, which produces a number of `.o` files\n+      (one for each \"codegen unit\").\n+6. **Linking**\n+    - Finally, those `.o` files are linke together.\n+\n+Glossary\n+========\n+\n+The compiler uses a number of...idiosyncratic abbreviations and\n+things. This glossary attempts to list them and give you a few\n+pointers for understanding them better.\n+\n+- AST -- the **abstract syntax tree** produced the `syntax` crate; reflects user syntax\n+  very closely. \n+- codegen unit -- when we produce LLVM IR, we group the Rust code into a number of codegen\n+  units. Each of these units is processed by LLVM independently from one another,\n+  enabling parallelism. They are also the unit of incremental re-use. \n+- cx -- we tend to use \"cx\" as an abbrevation for context. See also tcx, infcx, etc.\n+- `DefId` -- an index identifying a **definition** (see `librustc/hir/def_id.rs`). Uniquely\n+  identifies a `DefPath`.\n+- HIR -- the **High-level IR**, created by lowering and desugaring the AST. See `librustc/hir`.\n+- `HirId` -- identifies a particular node in the HIR by combining a\n+  def-id with an \"intra-definition offset\".\n+- `'gcx` -- the lifetime of the global arena (see `librustc/ty`).\n+- generics -- the set of generic type parameters defined on a type or item\n+- ICE -- internal compiler error. When the compiler crashes.\n+- infcx -- the inference context (see `librustc/infer`)\n+- MIR -- the **Mid-level IR** that is created after type-checking for use by borrowck and trans.\n+  Defined in the `src/librustc/mir/` module, but much of the code that manipulates it is\n+  found in `src/librustc_mir`.\n+- obligation -- something that must be proven by the trait system; see `librustc/traits`.\n+- local crate -- the crate currently being compiled.\n+- node-id or `NodeId` -- an index identifying a particular node in the\n+  AST or HIR; gradually being phased out and replaced with `HirId`.\n+- query -- perhaps some sub-computation during compilation; see `librustc/maps`.\n+- provider -- the function that executes a query; see `librustc/maps`.\n+- sess -- the **compiler session**, which stores global data used throughout compilation\n+- side tables -- because the AST and HIR are immutable once created, we often carry extra\n+  information about them in the form of hashtables, indexed by the id of a particular node.\n+- span -- a location in the user's source code, used for error\n+  reporting primarily.  These are like a file-name/line-number/column\n+  tuple on steroids: they carry a start/end point, and also track\n+  macro expansions and compiler desugaring. All while being packed\n+  into a few bytes (really, it's an index into a table). See the\n+  `Span` datatype for more.\n+- substs -- the **substitutions** for a given generic type or item\n+  (e.g., the `i32, u32` in `HashMap<i32, u32>`)\n+- tcx -- the \"typing context\", main data structure of the compiler (see `librustc/ty`).\n+- trans -- the code to **translate** MIR into LLVM IR.\n+- trait reference -- a trait and values for its type parameters (see `librustc/ty`).\n+- ty -- the internal representation of a **type** (see `librustc/ty`)."}, {"sha": "c832a897dee8b69389bea5402cef5b42b526afa9", "filename": "src/librustc/hir/README.md", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,119 @@\n+# Introduction to the HIR\n+\n+The HIR -- \"High-level IR\" -- is the primary IR used in most of\n+rustc. It is a desugared version of the \"abstract syntax tree\" (AST)\n+that is generated after parsing, macro expansion, and name resolution\n+have completed. Many parts of HIR resemble Rust surface syntax quite\n+closely, with the exception that some of Rust's expression forms have\n+been desugared away (as an example, `for` loops are converted into a\n+`loop` and do not appear in the HIR).\n+\n+This README covers the main concepts of the HIR.\n+\n+### Out-of-band storage and the `Crate` type\n+\n+The top-level data-structure in the HIR is the `Crate`, which stores\n+the contents of the crate currently being compiled (we only ever\n+construct HIR for the current crate). Whereas in the AST the crate\n+data structure basically just contains the root module, the HIR\n+`Crate` structure contains a number of maps and other things that\n+serve to organize the content of the crate for easier access.\n+\n+For example, the contents of individual items (e.g., modules,\n+functions, traits, impls, etc) in the HIR are not immediately\n+accessible in the parents. So, for example, if had a module item `foo`\n+containing a function `bar()`:\n+\n+```\n+mod foo {\n+  fn bar() { }\n+}\n+```\n+\n+Then in the HIR the representation of module `foo` (the `Mod`\n+stuct) would have only the **`ItemId`** `I` of `bar()`. To get the\n+details of the function `bar()`, we would lookup `I` in the\n+`items` map.\n+\n+One nice result from this representation is that one can iterate\n+over all items in the crate by iterating over the key-value pairs\n+in these maps (without the need to trawl through the IR in total).\n+There are similar maps for things like trait items and impl items,\n+as well as \"bodies\" (explained below).\n+\n+The other reason to setup the representation this way is for better\n+integration with incremental compilation. This way, if you gain access\n+to a `&hir::Item` (e.g. for the mod `foo`), you do not immediately\n+gain access to the contents of the function `bar()`. Instead, you only\n+gain access to the **id** for `bar()`, and you must invoke some\n+function to lookup the contents of `bar()` given its id; this gives us\n+a chance to observe that you accessed the data for `bar()` and record\n+the dependency.\n+\n+### Identifiers in the HIR\n+\n+Most of the code that has to deal with things in HIR tends not to\n+carry around references into the HIR, but rather to carry around\n+*identifier numbers* (or just \"ids\"). Right now, you will find four\n+sorts of identifiers in active use:\n+\n+- `DefId`, which primarily name \"definitions\" or top-level items.\n+  - You can think of a `DefId` as being shorthand for a very explicit\n+    and complete path, like `std::collections::HashMap`. However,\n+    these paths are able to name things that are not nameable in\n+    normal Rust (e.g., impls), and they also include extra information\n+    about the crate (such as its version number, as two versions of\n+    the same crate can co-exist).\n+  - A `DefId` really consists of two parts, a `CrateNum` (which\n+    identifies the crate) and a `DefIndex` (which indixes into a list\n+    of items that is maintained per crate).\n+- `HirId`, which combines the index of a particular item with an\n+  offset within that item.\n+  - the key point of a `HirId` is that it is *relative* to some item (which is named\n+    via a `DefId`).\n+- `BodyId`, this is an absolute identifier that refers to a specific\n+  body (definition of a function or constant) in the crate. It is currently\n+  effectively a \"newtype'd\" `NodeId`.\n+- `NodeId`, which is an absolute id that identifies a single node in the HIR tree.\n+  - While these are still in common use, **they are being slowly phased out**.\n+  - Since they are absolute within the crate, adding a new node\n+    anywhere in the tree causes the node-ids of all subsequent code in\n+    the crate to change. This is terrible for incremental compilation,\n+    as you can perhaps imagine.\n+\n+### HIR Map\n+\n+Most of the time when you are working with the HIR, you will do so via\n+the **HIR Map**, accessible in the tcx via `tcx.hir` (and defined in\n+the `hir::map` module). The HIR map contains a number of methods to\n+convert between ids of various kinds and to lookup data associated\n+with a HIR node.\n+\n+For example, if you have a `DefId`, and you would like to convert it\n+to a `NodeId`, you can use `tcx.hir.as_local_node_id(def_id)`. This\n+returns an `Option<NodeId>` -- this will be `None` if the def-id\n+refers to something outside of the current crate (since then it has no\n+HIR node), but otherwise returns `Some(n)` where `n` is the node-id of\n+the definition.\n+\n+Similarly, you can use `tcx.hir.find(n)` to lookup the node for a\n+`NodeId`. This returns a `Option<Node<'tcx>>`, where `Node` is an enum\n+defined in the map; by matching on this you can find out what sort of\n+node the node-id referred to and also get a pointer to the data\n+itself. Often, you know what sort of node `n` is -- e.g., if you know\n+that `n` must be some HIR expression, you can do\n+`tcx.hir.expect_expr(n)`, which will extract and return the\n+`&hir::Expr`, panicking if `n` is not in fact an expression.\n+\n+Finally, you can use the HIR map to find the parents of nodes, via\n+calls like `tcx.hir.get_parent_node(n)`.\n+\n+### HIR Bodies\n+\n+A **body** represents some kind of executable code, such as the body\n+of a function/closure or the definition of a constant. Bodies are\n+associated with an **owner**, which is typically some kind of item\n+(e.g., a `fn()` or `const`), but could also be a closure expression\n+(e.g., `|x, y| x + y`). You can use the HIR map to find find the body\n+associated with a given def-id (`maybe_body_owned_by()`) or to find\n+the owner of a body (`body_owner_def_id()`)."}, {"sha": "34ed325705ab98c231f0ae9ac578fd252c6a6f1d", "filename": "src/librustc/hir/map/README.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,4 @@\n+The HIR map, accessible via `tcx.hir`, allows you to quickly navigate the\n+HIR and convert between various forms of identifiers. See [the HIR README] for more information.\n+\n+[the HIR README]: ../README.md"}, {"sha": "c250695f361a644076fae40eb196ff9f660f5226", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -413,6 +413,10 @@ pub struct WhereEqPredicate {\n \n pub type CrateConfig = HirVec<P<MetaItem>>;\n \n+/// The top-level data structure that stores the entire contents of\n+/// the crate currently being compiled.\n+///\n+/// For more details, see [the module-level README](README.md).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n@@ -927,7 +931,27 @@ pub struct BodyId {\n     pub node_id: NodeId,\n }\n \n-/// The body of a function or constant value.\n+/// The body of a function, closure, or constant value. In the case of\n+/// a function, the body contains not only the function body itself\n+/// (which is an expression), but also the argument patterns, since\n+/// those are something that the caller doesn't really care about.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn foo((x, y): (u32, u32)) -> u32 {\n+///     x + y\n+/// }\n+/// ```\n+///\n+/// Here, the `Body` associated with `foo()` would contain:\n+///\n+/// - an `arguments` array containing the `(x, y)` pattern\n+/// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n+/// - `is_generator` would be false\n+///\n+/// All bodies have an **owner**, which can be accessed via the HIR\n+/// map using `body_owner_def_id()`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,"}, {"sha": "cd39ef70946329857b49dfef39fcc973ef4112d9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -8,7 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The Rust compiler.\n+//! The \"main crate\" of the Rust compiler. This crate contains common\n+//! type definitions that are used by the other crates in the rustc\n+//! \"family\". Some prominent examples (note that each of these modules\n+//! has their own README with further details).\n+//!\n+//! - **HIR.** The \"high-level (H) intermediate representation (IR)\" is\n+//!   defined in the `hir` module.\n+//! - **MIR.** The \"mid-level (M) intermediate representation (IR)\" is\n+//!   defined in the `mir` module. This module contains only the\n+//!   *definition* of the MIR; the passes that transform and operate\n+//!   on MIR are found in `librustc_mir` crate.\n+//! - **Types.** The internal representation of types used in rustc is\n+//!   defined in the `ty` module. This includes the **type context**\n+//!   (or `tcx`), which is the central context during most of\n+//!   compilation, containing the interners and other things.\n+//! - **Traits.** Trait resolution is implemented in the `traits` module.\n+//! - **Type inference.** The type inference code can be found in the `infer` module;\n+//!   this code handles low-level equality and subtyping operations. The\n+//!   type check pass in the compiler is found in the `librustc_typeck` crate.\n+//!\n+//! For a deeper explanation of how the compiler works and is\n+//! organized, see the README.md file in this directory.\n //!\n //! # Note\n //!"}, {"sha": "4f63912a1e0d1a8f8269a5a6d491d4e6827bd322", "filename": "src/librustc/ty/README.md", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,165 @@\n+# Types and the Type Context\n+\n+The `ty` module defines how the Rust compiler represents types\n+internally. It also defines the *typing context* (`tcx` or `TyCtxt`),\n+which is the central data structure in the compiler.\n+\n+## The tcx and how it uses lifetimes\n+\n+The `tcx` (\"typing context\") is the central data structure in the\n+compiler. It is the context that you use to perform all manner of\n+queries. The struct `TyCtxt` defines a reference to this shared context:\n+\n+```rust\n+tcx: TyCtxt<'a, 'gcx, 'tcx>\n+//          --  ----  ----\n+//          |   |     |\n+//          |   |     innermost arena lifetime (if any)\n+//          |   \"global arena\" lifetime\n+//          lifetime of this reference\n+```\n+\n+As you can see, the `TyCtxt` type takes three lifetime parameters.\n+These lifetimes are perhaps the most complex thing to understand about\n+the tcx. During Rust compilation, we allocate most of our memory in\n+**arenas**, which are basically pools of memory that get freed all at\n+once. When you see a reference with a lifetime like `'tcx` or `'gcx`,\n+you know that it refers to arena-allocated data (or data that lives as\n+long as the arenas, anyhow).\n+\n+We use two distinct levels of arenas. The outer level is the \"global\n+arena\". This arena lasts for the entire compilation: so anything you\n+allocate in there is only freed once compilation is basically over\n+(actually, when we shift to executing LLVM).\n+\n+To reduce peak memory usage, when we do type inference, we also use an\n+inner level of arena. These arenas get thrown away once type inference\n+is over. This is done because type inference generates a lot of\n+\"throw-away\" types that are not particularly interesting after type\n+inference completes, so keeping around those allocations would be\n+wasteful.\n+\n+Often, we wish to write code that explicitly asserts that it is not\n+taking place during inference. In that case, there is no \"local\"\n+arena, and all the types that you can access are allocated in the\n+global arena.  To express this, the idea is to us the same lifetime\n+for the `'gcx` and `'tcx` parameters of `TyCtxt`. Just to be a touch\n+confusing, we tend to use the name `'tcx` in such contexts. Here is an\n+example:\n+\n+```rust\n+fn not_in_inference<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    //                                        ----  ----\n+    //                                        Using the same lifetime here asserts\n+    //                                        that the innermost arena accessible through\n+    //                                        this reference *is* the global arena.\n+}\n+```\n+\n+In contrast, if we want to code that can be usable during type inference, then you\n+need to declare a distinct `'gcx` and `'tcx` lifetime parameter:\n+\n+```rust\n+fn maybe_in_inference<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) {\n+    //                                                ----  ----\n+    //                                        Using different lifetimes here means that\n+    //                                        the innermost arena *may* be distinct\n+    //                                        from the global arena (but doesn't have to be).\n+}\n+```\n+\n+### Allocating and working with types\n+\n+Rust types are represented using the `Ty<'tcx>` defined in the `ty`\n+module (not to be confused with the `Ty` struct from [the HIR]). This\n+is in fact a simple type alias for a reference with `'tcx` lifetime:\n+\n+```rust\n+pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n+```\n+\n+[the HIR]: ../hir/README.md\n+\n+You can basically ignore the `TyS` struct -- you will basically never\n+access it explicitly. We always pass it by reference using the\n+`Ty<'tcx>` alias -- the only exception I think is to define inherent\n+methods on types. Instances of `TyS` are only ever allocated in one of\n+the rustc arenas (never e.g. on the stack).\n+\n+One common operation on types is to **match** and see what kinds of\n+types they are. This is done by doing `match ty.sty`, sort of like this:\n+\n+```rust\n+fn test_type<'tcx>(ty: Ty<'tcx>) {\n+    match ty.sty {\n+        ty::TyArray(elem_ty, len) => { ... }\n+        ...\n+    }\n+}\n+```\n+\n+The `sty` field (the origin of this name is unclear to me; perhaps\n+structural type?) is of type `TypeVariants<'tcx>`, which is an enum\n+definined all of the different kinds of types in the compiler.\n+\n+> NB: inspecting the `sty` field on types during type inference can be\n+> risky, as there are may be inference variables and other things to\n+> consider, or sometimes types are not yet known that will become\n+> known later.).\n+\n+To allocate a new type, you can use the various `mk_` methods defined\n+on the `tcx`. These have names that correpond mostly to the various kinds\n+of type variants. For example:\n+\n+```rust\n+let array_ty = tcx.mk_array(elem_ty, len * 2);\n+```\n+\n+These methods all return a `Ty<'tcx>` -- note that the lifetime you\n+get back is the lifetime of the innermost arena that this `tcx` has\n+access to. In fact, types are always canonicalized and interned (so we\n+never allocate exactly the same type twice) and are always allocated\n+in the outermost arena where they can be (so, if they do not contain\n+any inference variables or other \"temporary\" types, they will be\n+allocated in the global arena). However, the lifetime `'tcx` is always\n+a safe approximation, so that is what you get back.\n+\n+> NB. Because types are interned, it is possible to compare them for\n+> equality efficiently using `==` -- however, this is almost never what\n+> you want to do unless you happen to be hashing and looking for\n+> duplicates. This is because often in Rust there are multiple ways to\n+> represent the same type, particularly once inference is involved. If\n+> you are going to be testing for type equality, you probably need to\n+> start looking into the inference code to do it right.\n+\n+You can also find various common types in the tcx itself by accessing\n+`tcx.types.bool`, `tcx.types.char`, etc (see `CommonTypes` for more).\n+\n+### Beyond types: Other kinds of arena-allocated data structures\n+\n+In addition to types, there are a number of other arena-allocated data\n+structures that you can allocate, and which are found in this\n+module. Here are a few examples:\n+\n+- `Substs`, allocated with `mk_substs` -- this will intern a slice of types, often used to\n+  specify the values to be substituted for generics (e.g., `HashMap<i32, u32>`\n+  would be represented as a slice `&'tcx [tcx.types.i32, tcx.types.u32]`.\n+- `TraitRef`, typically passed by value -- a **trait reference**\n+  consists of a reference to a trait along with its various type\n+  parameters (including `Self`), like `i32: Display` (here, the def-id\n+  would reference the `Display` trait, and the substs would contain\n+  `i32`).\n+- `Predicate` defines something the trait system has to prove (see `traits` module).\n+\n+### Import conventions\n+\n+Although there is no hard and fast rule, the `ty` module tends to be used like so:\n+\n+```rust\n+use ty::{self, Ty, TyCtxt};\n+```\n+\n+In particular, since they are so common, the `Ty` and `TyCtxt` types\n+are imported directly. Other types are often referenced with an\n+explicit `ty::` prefix (e.g., `ty::TraitRef<'tcx>`). But some modules\n+choose to import a larger or smaller set of names explicitly."}, {"sha": "874bb426dc509f893006e180f2a9a270deb4057f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -793,9 +793,10 @@ impl<'tcx> CommonTypes<'tcx> {\n     }\n }\n \n-/// The data structure to keep track of all the information that typechecker\n-/// generates so that so that it can be reused and doesn't have to be redone\n-/// later on.\n+/// The central data structure of the compiler. It stores references\n+/// to the various **arenas** and also houses the results of the\n+/// various **compiler queries** that have been performed. See [the\n+/// README](README.md) for more deatils.\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     gcx: &'a GlobalCtxt<'gcx>,"}, {"sha": "c0045483ced47fbeaa712f6c181f4bd5b645cb4a", "filename": "src/librustc/ty/maps.rs", "status": "removed", "additions": 0, "deletions": 1551, "changes": 1551, "blob_url": "https://github.com/rust-lang/rust/blob/325ba23d5525ecdd555f19c7f527bce913dfd756/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325ba23d5525ecdd555f19c7f527bce913dfd756/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=325ba23d5525ecdd555f19c7f527bce913dfd756", "patch": "@@ -1,1551 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n-use errors::{Diagnostic, DiagnosticBuilder};\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n-use hir::def::{Def, Export};\n-use hir::{self, TraitCandidate, ItemLocalId};\n-use hir::svh::Svh;\n-use lint;\n-use middle::const_val;\n-use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n-                     ExternBodyNestedBodies};\n-use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n-use middle::privacy::AccessLevels;\n-use middle::reachable::ReachableSet;\n-use middle::region;\n-use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n-use middle::stability::{self, DeprecationEntry};\n-use middle::lang_items::{LanguageItems, LangItem};\n-use middle::exported_symbols::SymbolExportLevel;\n-use middle::trans::{CodegenUnit, Stats};\n-use mir;\n-use mir::transform::{MirSuite, MirPassIndex};\n-use session::CompileResult;\n-use session::config::OutputFilenames;\n-use traits::specialization_graph;\n-use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n-use ty::layout::{Layout, LayoutError};\n-use ty::item_path;\n-use ty::steal::Steal;\n-use ty::subst::Substs;\n-use ty::fast_reject::SimplifiedType;\n-use util::nodemap::{DefIdSet, DefIdMap};\n-use util::common::{profq_msg, ProfileQueriesMsg};\n-\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n-use rustc_back::PanicStrategy;\n-use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use std::cell::{RefCell, RefMut, Cell};\n-\n-use std::fmt::Debug;\n-use std::hash::Hash;\n-use std::marker::PhantomData;\n-use std::mem;\n-use std::ops::Deref;\n-use std::rc::Rc;\n-use std::sync::Arc;\n-use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::symbol::InternedString;\n-use syntax::attr;\n-use syntax::ast;\n-use syntax::symbol::Symbol;\n-\n-pub trait Key: Clone + Hash + Eq + Debug {\n-    fn map_crate(&self) -> CrateNum;\n-    fn default_span(&self, tcx: TyCtxt) -> Span;\n-}\n-\n-impl<'tcx> Key for ty::InstanceDef<'tcx> {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        tcx.def_span(self.def_id())\n-    }\n-}\n-\n-impl<'tcx> Key for ty::Instance<'tcx> {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        tcx.def_span(self.def_id())\n-    }\n-}\n-\n-impl Key for CrateNum {\n-    fn map_crate(&self) -> CrateNum {\n-        *self\n-    }\n-    fn default_span(&self, _: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl Key for DefIndex {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _tcx: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl Key for DefId {\n-    fn map_crate(&self) -> CrateNum {\n-        self.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        tcx.def_span(*self)\n-    }\n-}\n-\n-impl Key for (DefId, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (CrateNum, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (DefId, SimplifiedType) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.0.default_span(tcx)\n-    }\n-}\n-\n-impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.0.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (MirSuite, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.1.map_crate()\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (MirSuite, MirPassIndex, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.2.map_crate()\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.2.default_span(tcx)\n-    }\n-}\n-\n-impl<'tcx> Key for Ty<'tcx> {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n-    fn map_crate(&self) -> CrateNum {\n-        self.value.map_crate()\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.value.default_span(tcx)\n-    }\n-}\n-\n-impl Key for InternedString {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _tcx: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-trait Value<'tcx>: Sized {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx, T> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n-        tcx.sess.abort_if_errors();\n-        bug!(\"Value::from_cycle_error called without errors\");\n-    }\n-}\n-\n-impl<'tcx, T: Default> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n-        T::default()\n-    }\n-}\n-\n-impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.types.err\n-    }\n-}\n-\n-impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        Self::empty()\n-    }\n-}\n-\n-impl<'tcx> Value<'tcx> for ty::SymbolName {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n-    }\n-}\n-\n-struct QueryMap<D: QueryDescription> {\n-    phantom: PhantomData<D>,\n-    map: FxHashMap<D::Key, QueryValue<D::Value>>,\n-}\n-\n-struct QueryValue<T> {\n-    value: T,\n-    index: DepNodeIndex,\n-    diagnostics: Option<Box<QueryDiagnostics>>,\n-}\n-\n-struct QueryDiagnostics {\n-    diagnostics: Vec<Diagnostic>,\n-    emitted_diagnostics: Cell<bool>,\n-}\n-\n-impl<M: QueryDescription> QueryMap<M> {\n-    fn new() -> QueryMap<M> {\n-        QueryMap {\n-            phantom: PhantomData,\n-            map: FxHashMap(),\n-        }\n-    }\n-}\n-\n-struct CycleError<'a, 'tcx: 'a> {\n-    span: Span,\n-    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    fn report_cycle(self, CycleError { span, cycle }: CycleError)\n-        -> DiagnosticBuilder<'a>\n-    {\n-        // Subtle: release the refcell lock before invoking `describe()`\n-        // below by dropping `cycle`.\n-        let stack = cycle.to_vec();\n-        mem::drop(cycle);\n-\n-        assert!(!stack.is_empty());\n-\n-        // Disable naming impls with types in this path, since that\n-        // sometimes cycles itself, leading to extra cycle errors.\n-        // (And cycle errors around impls tend to occur during the\n-        // collect/coherence phases anyhow.)\n-        item_path::with_forced_impl_filename_line(|| {\n-            let mut err =\n-                struct_span_err!(self.sess, span, E0391,\n-                                 \"unsupported cyclic reference between types/traits detected\");\n-            err.span_label(span, \"cyclic reference\");\n-\n-            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n-                                               stack[0].1.describe(self)));\n-\n-            for &(span, ref query) in &stack[1..] {\n-                err.span_note(span, &format!(\"...which then requires {}...\",\n-                                             query.describe(self)));\n-            }\n-\n-            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                              stack[0].1.describe(self)));\n-\n-            return err\n-        })\n-    }\n-\n-    fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n-                         -> Result<R, CycleError<'a, 'gcx>>\n-        where F: FnOnce() -> R\n-    {\n-        {\n-            let mut stack = self.maps.query_stack.borrow_mut();\n-            if let Some((i, _)) = stack.iter().enumerate().rev()\n-                                       .find(|&(_, &(_, ref q))| *q == query) {\n-                return Err(CycleError {\n-                    span,\n-                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n-                });\n-            }\n-            stack.push((span, query));\n-        }\n-\n-        let result = compute();\n-\n-        self.maps.query_stack.borrow_mut().pop();\n-\n-        Ok(result)\n-    }\n-}\n-\n-pub trait QueryConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value;\n-}\n-\n-trait QueryDescription: QueryConfig {\n-    fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n-}\n-\n-impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n-    default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_copy_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Copy`\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_sized_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Sized`\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is freeze\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` needs drop\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing layout of `{}`\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"computing the supertraits of `{}`\",\n-                tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir.ty_param_name(id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n-    fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n-        format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n-    fn describe(_: TyCtxt, k: CrateNum) -> String {\n-        format!(\"all inherent impls defined in crate `{:?}`\", k)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"check for overlap between inherent impls defined in this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"computing the variances for items in this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n-    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n-        format!(\"generating MIR shim for `{}`\",\n-                tcx.item_path_str(def.def_id()))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::privacy_access_levels<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"privacy access levels\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::typeck_item_bodies<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"type-checking all item bodies\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"reachability\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n-    fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>) -> String {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.0))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"getting a list of all mir_keys\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n-    fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n-        format!(\"computing the symbol for `{}`\", instance)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::describe_def<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"describe_def\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"def_span\")\n-    }\n-}\n-\n-\n-impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"stability\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"deprecation\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::item_attrs<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"item_attrs\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_exported_symbol<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"is_exported_symbol\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::fn_arg_names<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"fn_arg_names\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::impl_parent<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"impl_parent\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::trait_of_item<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"trait_of_item\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::item_body_nested_bodies<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"checking if item is mir available: `{}`\",\n-            tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"dylib dependency formats of crate\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"checking if the crate is_panic_runtime\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"checking if the crate is_compiler_builtins\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"checking if the crate has_global_allocator\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        \"getting crate's ExternCrateData\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"computing the lint levels for items in this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: (DefId, DefId)) -> String {\n-        format!(\"computing whether impls specialize one another\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::in_scope_traits_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"traits in scope at a block\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"test whether a crate has #![no_builtins]\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"query a crate's configured panic strategy\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"query a crate is #![profiler_runtime]\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"query a crate is #![sanitizer_runtime]\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the exported symbols of a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the native libraries of a linked crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the plugin registrar for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the derive registrar for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the disambiguator a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the hash a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the original name a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n-        format!(\"looking up implementations of a trait in a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up all (?) trait implementations\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up link arguments for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::named_region_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"looking up a named region\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_late_bound_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"testing if a region is late boudn\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::object_lifetime_defaults_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"looking up lifetime defaults for a region\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"fetching what a dependency looks like\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"fetching what a crate is named\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the lang items map\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the lang items defined in a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the missing lang items in a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the visible parent map\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"seeing if we're missing an `extern crate` item for this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking at the source for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"generating a postorder list of CrateNums\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up all possibly unused extern crates\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the stability index for the local crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"fetching all foreign CrateNum instances\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"exported_symbols\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::collect_and_partition_translation_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"collect_and_partition_translation_items\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n-        format!(\"codegen_unit\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::compile_codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n-        format!(\"compile_codegen_unit\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::output_filenames<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"output_filenames\")\n-    }\n-}\n-\n-// If enabled, send a message to the profile-queries thread\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if  $tcx.sess.profile_queries() {\n-                profq_msg($msg)\n-            }\n-        }\n-    }\n-}\n-\n-// If enabled, format a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_key {\n-    ($tcx:expr, $key:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None }\n-    }\n-}\n-\n-macro_rules! define_maps {\n-    (<$tcx:tt>\n-     $($(#[$attr:meta])*\n-       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n-        }\n-\n-        impl<$tcx> Maps<$tcx> {\n-            pub fn new(providers: IndexVec<CrateNum, Providers<$tcx>>)\n-                       -> Self {\n-                Maps {\n-                    providers,\n-                    query_stack: RefCell::new(vec![]),\n-                    $($name: RefCell::new(QueryMap::new())),*\n-                }\n-            }\n-        }\n-\n-        #[allow(bad_style)]\n-        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-        pub enum Query<$tcx> {\n-            $($(#[$attr])* $name($K)),*\n-        }\n-\n-        #[allow(bad_style)]\n-        #[derive(Clone, Debug, PartialEq, Eq)]\n-        pub enum QueryMsg {\n-            $($name(Option<String>)),*\n-        }\n-\n-        impl<$tcx> Query<$tcx> {\n-            pub fn describe(&self, tcx: TyCtxt) -> String {\n-                let (r, name) = match *self {\n-                    $(Query::$name(key) => {\n-                        (queries::$name::describe(tcx, key), stringify!($name))\n-                    })*\n-                };\n-                if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name)\n-                } else {\n-                    r\n-                }\n-            }\n-        }\n-\n-        pub mod queries {\n-            use std::marker::PhantomData;\n-\n-            $(#[allow(bad_style)]\n-            pub struct $name<$tcx> {\n-                data: PhantomData<&$tcx ()>\n-            })*\n-        }\n-\n-        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n-            type Key = $K;\n-            type Value = $V;\n-        }\n-\n-        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n-            #[allow(unused)]\n-            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n-                use dep_graph::DepConstructor::*;\n-\n-                DepNode::new(tcx, $node(*key))\n-            }\n-\n-            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                  mut span: Span,\n-                                  key: $K,\n-                                  f: F)\n-                                  -> Result<R, CycleError<'a, $tcx>>\n-                where F: FnOnce(&$V) -> R\n-            {\n-                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n-                       stringify!($name),\n-                       key,\n-                       span);\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        span.clone(),\n-                        QueryMsg::$name(profq_key!(tcx, key))\n-                    )\n-                );\n-\n-                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n-                    if let Some(ref d) = value.diagnostics {\n-                        if !d.emitted_diagnostics.get() {\n-                            d.emitted_diagnostics.set(true);\n-                            let handle = tcx.sess.diagnostic();\n-                            for diagnostic in d.diagnostics.iter() {\n-                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n-                                    .emit();\n-                            }\n-                        }\n-                    }\n-                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                    tcx.dep_graph.read_index(value.index);\n-                    return Ok(f(&value.value));\n-                }\n-                // else, we are going to run the provider:\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n-                // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necessary to prevent a recursive loop,\n-                // default_span calls def_span query internally.\n-                if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n-                    span = key.default_span(tcx)\n-                }\n-\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-                let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    tcx.sess.diagnostic().track_diagnostics(|| {\n-                        if dep_node.kind.is_anon() {\n-                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                                provider(tcx.global_tcx(), key)\n-                            })\n-                        } else {\n-                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n-                                                            key: $K)\n-                                                            -> $V {\n-                                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                                provider(tcx.global_tcx(), key)\n-                            }\n-\n-                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n-                        }\n-                    })\n-                })?;\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                let ((result, dep_node_index), diagnostics) = res;\n-\n-                tcx.dep_graph.read_index(dep_node_index);\n-\n-                let value = QueryValue {\n-                    value: result,\n-                    index: dep_node_index,\n-                    diagnostics: if diagnostics.len() == 0 {\n-                        None\n-                    } else {\n-                        Some(Box::new(QueryDiagnostics {\n-                            diagnostics,\n-                            emitted_diagnostics: Cell::new(true),\n-                        }))\n-                    },\n-                };\n-\n-                Ok(f(&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value))\n-            }\n-\n-            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, DiagnosticBuilder<'a>> {\n-                match Self::try_get_with(tcx, span, key, Clone::clone) {\n-                    Ok(e) => Ok(e),\n-                    Err(e) => Err(tcx.report_cycle(e)),\n-                }\n-            }\n-\n-            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n-                // Ignore dependencies, since we not reading the computed value\n-                let _task = tcx.dep_graph.in_ignore();\n-\n-                match Self::try_get_with(tcx, span, key, |_| ()) {\n-                    Ok(()) => {}\n-                    Err(e) => tcx.report_cycle(e).emit(),\n-                }\n-            }\n-        })*\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-            pub span: Span,\n-        }\n-\n-        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n-            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n-            fn deref(&self) -> &Self::Target {\n-                &self.tcx\n-            }\n-        }\n-\n-        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n-            /// Return a transparent wrapper for `TyCtxt` which uses\n-            /// `span` as the location of queries performed through it.\n-            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n-                TyCtxtAt {\n-                    tcx: self,\n-                    span\n-                }\n-            }\n-\n-            $($(#[$attr])*\n-            pub fn $name(self, key: $K) -> $V {\n-                self.at(DUMMY_SP).$name(key)\n-            })*\n-        }\n-\n-        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n-            $($(#[$attr])*\n-            pub fn $name(self, key: $K) -> $V {\n-                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n-                    e.emit();\n-                    Value::from_cycle_error(self.global_tcx())\n-                })\n-            })*\n-        }\n-\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n-            output: ()\n-        }\n-\n-        impl<$tcx> Copy for Providers<$tcx> {}\n-        impl<$tcx> Clone for Providers<$tcx> {\n-            fn clone(&self) -> Self { *self }\n-        }\n-    }\n-}\n-\n-macro_rules! define_map_struct {\n-    // Initial state\n-    (tcx: $tcx:tt,\n-     input: $input:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final output\n-    (tcx: $tcx:tt,\n-     input: (),\n-     output: ($($output:tt)*)) => {\n-        pub struct Maps<$tcx> {\n-            providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($output)*\n-        }\n-    };\n-\n-    // Field recognized and ready to shift into the output\n-    (tcx: $tcx:tt,\n-     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)*\n-                     $(#[$attr])* $($pub)* $name: RefCell<QueryMap<queries::$name<$tcx>>>,)\n-        }\n-    };\n-\n-    // No modifiers left? This is a private item.\n-    (tcx: $tcx:tt,\n-     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip other modifiers\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n-        }\n-    };\n-}\n-\n-macro_rules! define_provider_struct {\n-    // Initial state:\n-    (tcx: $tcx:tt, input: $input:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final state:\n-    (tcx: $tcx:tt,\n-     input: (),\n-     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n-        pub struct Providers<$tcx> {\n-            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n-        }\n-\n-        impl<$tcx> Default for Providers<$tcx> {\n-            fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n-                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n-                         stringify!($name), key);\n-                })*\n-                Providers { $($name),* }\n-            }\n-        }\n-    };\n-\n-    // Something ready to shift:\n-    (tcx: $tcx:tt,\n-     ready: ($name:tt $K:tt $V:tt),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)* ($name $K $V))\n-        }\n-    };\n-\n-    // Regular queries produce a `V` only.\n-    (tcx: $tcx:tt,\n-     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            ready: ($name $K $V),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip modifiers.\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n-        }\n-    };\n-}\n-\n-// Each of these maps also corresponds to a method on a\n-// `Provider` trait for requesting a value of that type,\n-// and a method on `Maps` itself for doing that in a\n-// a way that memoizes and does dep-graph tracking,\n-// wrapping around the actual chain of providers that\n-// the driver creates (using several `rustc_*` crates).\n-define_maps! { <'tcx>\n-    /// Records the type of every item.\n-    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-\n-    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated generics and predicates.\n-    [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n-    [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n-\n-    /// Maps from the def-id of a trait to the list of\n-    /// super-predicates. This is a subset of the full list of\n-    /// predicates. We store these in a separate map because we must\n-    /// evaluate them even during type conversion, often before the\n-    /// full predicates are available (note that supertraits have\n-    /// additional acyclicity requirements).\n-    [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n-\n-    /// To avoid cycles within the predicates of a single item we compute\n-    /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n-        -> ty::GenericPredicates<'tcx>,\n-\n-    [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-    [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-    [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n-\n-    /// True if this is a const fn\n-    [] fn is_const_fn: IsConstFn(DefId) -> bool,\n-\n-    /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n-\n-    /// True if this is a default impl (aka impl Foo for ..)\n-    [] fn is_default_impl: IsDefaultImpl(DefId) -> bool,\n-\n-    /// Get a map with the variance of every item; use `item_variance`\n-    /// instead.\n-    [] fn crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n-\n-    /// Maps from def-id of a type or region parameter to its\n-    /// (inferred) variance.\n-    [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n-\n-    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n-\n-    /// Maps from a trait item to the trait item \"descriptor\"\n-    [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n-\n-    [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n-\n-    /// Maps a DefId of a type to a list of its inherent impls.\n-    /// Contains implementations of methods that are inherent to a type.\n-    /// Methods in these implementations don't need to be exported.\n-    [] fn inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n-\n-    /// Set of all the def-ids in this crate that have MIR associated with\n-    /// them. This includes all the body owners, but also things like struct\n-    /// constructors.\n-    [] fn mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n-\n-    /// Maps DefId's that have an associated Mir to the result\n-    /// of the MIR qualify_consts pass. The actual meaning of\n-    /// the value isn't known except to the pass itself.\n-    [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Rc<IdxSetBuf<mir::Local>>),\n-\n-    /// Fetch the MIR for a given def-id up till the point where it is\n-    /// ready for const evaluation.\n-    ///\n-    /// See the README for the `mir` module for details.\n-    [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-    [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-    /// MIR after our optimization passes have run. This is MIR that is ready\n-    /// for trans. This is also the only query that can fetch non-local MIR, at present.\n-    [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n-\n-    /// Type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n-\n-    /// The signature of functions and closures.\n-    [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n-\n-    /// Records the signature of each generator. The def ID is the ID of the\n-    /// expression defining the closure.\n-    [] fn generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n-\n-    /// Caches CoerceUnsized kinds for impls on custom types.\n-    [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n-        -> ty::adjustment::CoerceUnsizedInfo,\n-\n-    [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n-\n-    [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n-\n-    [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n-\n-    [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n-\n-    [] fn borrowck: BorrowCheck(DefId) -> (),\n-    // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n-\n-    /// Gets a complete map from all types to their inherent impls.\n-    /// Not meant to be used directly outside of coherence.\n-    /// (Defined only for LOCAL_CRATE)\n-    [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n-\n-    /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n-    /// Not meant to be used directly outside of coherence.\n-    /// (Defined only for LOCAL_CRATE)\n-    [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n-\n-    /// Results of evaluating const items or constants embedded in\n-    /// other items (such as enum variant explicit discriminants).\n-    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n-        -> const_val::EvalResult<'tcx>,\n-\n-    /// Performs the privacy check and computes \"access levels\".\n-    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n-\n-    [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n-\n-    /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n-    /// in the case of closures, this will be redirected to the enclosing function.\n-    [] fn region_scope_tree: RegionScopeTree(DefId) -> Rc<region::ScopeTree>,\n-\n-    [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-    [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-    [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n-    [] fn def_span: DefSpan(DefId) -> Span,\n-    [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n-    [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n-    [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n-    [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-    [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n-    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n-    [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-    [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n-\n-    [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n-    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n-    [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n-\n-    // Get the ParameterEnvironment for a given item; this environment\n-    // will be in \"user-facing\" mode, meaning that it is suitabe for\n-    // type-checking etc, and it does not normalize specializable\n-    // associated types. This is almost always what you want,\n-    // unless you are doing MIR optimizations, in which case you\n-    // might want to use `reveal_all()` method to change modes.\n-    [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n-\n-    // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n-    // `ty.is_copy()`, etc, since that will prune the environment where possible.\n-    [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                  -> Result<&'tcx Layout, LayoutError<'tcx>>,\n-\n-    [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n-                                    -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n-\n-    [] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n-    [] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n-    [] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n-    [] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n-    [] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n-    [] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n-    [] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n-\n-    [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n-\n-    [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n-    [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n-    [] fn module_exports: ModuleExports(DefId) -> Option<Rc<Vec<Export>>>,\n-    [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n-\n-    [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<DefIdSet>,\n-    [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n-    [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n-    [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n-    [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> Symbol,\n-    [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n-    [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n-\n-    [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n-        -> Rc<Vec<DefId>>,\n-    [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n-        -> Rc<Vec<DefId>>,\n-\n-    [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n-    [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n-    [] fn native_library_kind: NativeLibraryKind(DefId)\n-        -> Option<NativeLibraryKind>,\n-    [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n-\n-    [] fn named_region_map: NamedRegion(DefIndex) ->\n-        Option<Rc<FxHashMap<ItemLocalId, Region>>>,\n-    [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n-        Option<Rc<FxHashSet<ItemLocalId>>>,\n-    [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n-        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n-\n-    [] fn visibility: Visibility(DefId) -> ty::Visibility,\n-    [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n-    [] fn crate_name: CrateName(CrateNum) -> Symbol,\n-    [] fn item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n-    [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n-\n-    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n-    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefId, usize)>>,\n-    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n-    [] fn extern_const_body: ExternConstBody(DefId) -> ExternConstBody<'tcx>,\n-    [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n-        -> Rc<DefIdMap<DefId>>,\n-    [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n-    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n-    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n-\n-    [] fn freevars: Freevars(DefId) -> Option<Rc<Vec<hir::Freevar>>>,\n-    [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n-    [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n-        -> Rc<Vec<(DefId, Span)>>,\n-\n-    [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n-    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n-\n-    [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n-    [] fn collect_and_partition_translation_items:\n-        collect_and_partition_translation_items_node(CrateNum)\n-        -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-    [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n-    [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n-    [] fn is_translated_function: IsTranslatedFunction(DefId) -> bool,\n-    [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n-    [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n-    [] fn output_filenames: output_filenames_node(CrateNum)\n-        -> Arc<OutputFilenames>,\n-}\n-\n-fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::TypeParamPredicates {\n-        item_id,\n-        param_id\n-    }\n-}\n-\n-fn coherent_trait_dep_node<'tcx>((_, def_id): (CrateNum, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::CoherenceCheckTrait(def_id)\n-}\n-\n-fn crate_inherent_impls_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Coherence\n-}\n-\n-fn inherent_impls_overlap_check_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CoherenceInherentImplOverlapCheck\n-}\n-\n-fn reachability_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::Reachability\n-}\n-\n-fn mir_shim_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::MirShim {\n-        instance_def\n-    }\n-}\n-\n-fn symbol_name_dep_node<'tcx>(instance: ty::Instance<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::InstanceSymbolName { instance }\n-}\n-\n-fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::TypeckBodiesKrate\n-}\n-\n-fn const_eval_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n-                             -> DepConstructor<'tcx> {\n-    DepConstructor::ConstEval\n-}\n-\n-fn mir_keys<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::MirKeys\n-}\n-\n-fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CrateVariances\n-}\n-\n-fn is_copy_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsCopy\n-}\n-\n-fn is_sized_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsSized\n-}\n-\n-fn is_freeze_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::IsFreeze\n-}\n-\n-fn needs_drop_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::NeedsDrop\n-}\n-\n-fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    DepConstructor::Layout\n-}\n-\n-fn lint_levels_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::LintLevels\n-}\n-\n-fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n-    DepConstructor::Specializes { impl1: a, impl2: b }\n-}\n-\n-fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n-    -> DepConstructor<'tcx>\n-{\n-    DepConstructor::ImplementationsOfTrait { krate, trait_id }\n-}\n-\n-fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::LinkArgs\n-}\n-\n-fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::GetLangItems\n-}\n-\n-fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::VisibleParentMap\n-}\n-\n-fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::PostorderCnums\n-}\n-\n-fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::MaybeUnusedExternCrates\n-}\n-\n-fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::StabilityIndex\n-}\n-\n-fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::AllCrateNums\n-}\n-\n-fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::CollectAndPartitionTranslationItems\n-}\n-\n-fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::OutputFilenames\n-}"}, {"sha": "8abc68d431a53df8cd43998af0341025bd03e8d7", "filename": "src/librustc/ty/maps/README.md", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,302 @@\n+# The Rust Compiler Query System\n+\n+The Compiler Query System is the key to our new demand-driven\n+organization.  The idea is pretty simple. You have various queries\n+that compute things about the input -- for example, there is a query\n+called `type_of(def_id)` that, given the def-id of some item, will\n+compute the type of that item and return it to you.\n+\n+Query execution is **memoized** -- so the first time you invoke a\n+query, it will go do the computation, but the next time, the result is\n+returned from a hashtable. Moreover, query execution fits nicely into\n+**incremental computation**; the idea is roughly that, when you do a\n+query, the result **may** be returned to you by loading stored data\n+from disk (but that's a separate topic we won't discuss further here).\n+\n+The overall vision is that, eventually, the entire compiler\n+control-flow will be query driven. There will effectively be one\n+top-level query (\"compile\") that will run compilation on a crate; this\n+will in turn demand information about that crate, starting from the\n+*end*.  For example:\n+\n+- This \"compile\" query might demand to get a list of codegen-units\n+  (i.e., modules that need to be compiled by LLVM).\n+- But computing the list of codegen-units would invoke some subquery\n+  that returns the list of all modules defined in the Rust source.\n+- That query in turn would invoke something asking for the HIR.\n+- This keeps going further and further back until we wind up doing the\n+  actual parsing.\n+\n+However, that vision is not fully realized. Still, big chunks of the\n+compiler (for example, generating MIR) work exactly like this.\n+\n+### Invoking queries\n+\n+To invoke a query is simple. The tcx (\"type context\") offers a method\n+for each defined query. So, for example, to invoke the `type_of`\n+query, you would just do this:\n+\n+```rust\n+let ty = tcx.type_of(some_def_id);\n+```\n+\n+### Cycles between queries\n+\n+Currently, cycles during query execution should always result in a\n+compilation error. Typically, they arise because of illegal programs\n+that contain cyclic references they shouldn't (though sometimes they\n+arise because of compiler bugs, in which case we need to factor our\n+queries in a more fine-grained fashion to avoid them).\n+\n+However, it is nonetheless often useful to *recover* from a cycle\n+(after reporting an error, say) and try to soldier on, so as to give a\n+better user experience. In order to recover from a cycle, you don't\n+get to use the nice method-call-style syntax. Instead, you invoke\n+using the `try_get` method, which looks roughly like this:\n+\n+```rust\n+use ty::maps::queries;\n+...\n+match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {\n+  Ok(result) => {\n+    // no cycle occurred! You can use `result`\n+  }\n+  Err(err) => {\n+    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,\n+    // meaning essentially an \"in-progress\", not-yet-reported error message.\n+    // See below for more details on what to do here.\n+  }\n+}\n+```\n+\n+So, if you get back an `Err` from `try_get`, then a cycle *did* occur. This means that\n+you must ensure that a compiler error message is reported. You can do that in two ways:\n+\n+The simplest is to invoke `err.emit()`. This will emit the cycle error to the user.\n+\n+However, often cycles happen because of an illegal program, and you\n+know at that point that an error either already has been reported or\n+will be reported due to this cycle by some other bit of code. In that\n+case, you can invoke `err.cancel()` to not emit any error. It is\n+traditional to then invoke:\n+\n+```\n+tcx.sess.delay_span_bug(some_span, \"some message\")\n+```\n+\n+`delay_span_bug()` is a helper that says: we expect a compilation\n+error to have happened or to happen in the future; so, if compilation\n+ultimately succeeds, make an ICE with the message `\"some\n+message\"`. This is basically just a precaution in case you are wrong.\n+\n+### How the compiler executes a query\n+\n+So you may be wondering what happens when you invoke a query\n+method. The answer is that, for each query, the compiler maintains a\n+cache -- if your query has already been executed, then, the answer is\n+simple: we clone the return value out of the cache and return it\n+(therefore, you should try to ensure that the return types of queries\n+are cheaply cloneable; insert a `Rc` if necessary).\n+\n+#### Providers\n+\n+If, however, the query is *not* in the cache, then the compiler will\n+try to find a suitable **provider**. A provider is a function that has\n+been defined and linked into the compiler somewhere that contains the\n+code to compute the result of the query.\n+\n+**Providers are defined per-crate.** The compiler maintains,\n+internally, a table of providers for every crate, at least\n+conceptually. Right now, there are really two sets: the providers for\n+queries about the **local crate** (that is, the one being compiled)\n+and providers for queries about **external crates** (that is,\n+dependencies of the local crate). Note that what determines the crate\n+that a query is targeting is not the *kind* of query, but the *key*.\n+For example, when you invoke `tcx.type_of(def_id)`, that could be a\n+local query or an external query, depending on what crate the `def_id`\n+is referring to (see the `self::keys::Key` trait for more information\n+on how that works).\n+\n+Providers always have the same signature:\n+\n+```rust\n+fn provider<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+                       key: QUERY_KEY)\n+                       -> QUERY_RESULT\n+{\n+    ...\n+}\n+```\n+\n+Providers take two arguments: the `tcx` and the query key. Note also\n+that they take the *global* tcx (i.e., they use the `'tcx` lifetime\n+twice), rather than taking a tcx with some active inference context.\n+They return the result of the query.\n+\n+####  How providers are setup\n+\n+When the tcx is created, it is given the providers by its creator using\n+the `Providers` struct. This struct is generate by the macros here, but it\n+is basically a big list of function pointers:\n+\n+```rust\n+struct Providers {\n+    type_of: for<'cx, 'tcx> fn(TyCtxt<'cx, 'tcx, 'tcx>, DefId) -> Ty<'tcx>,\n+    ...\n+}\n+```\n+\n+At present, we have one copy of the struct for local crates, and one\n+for external crates, though the plan is that we may eventually have\n+one per crate.\n+\n+These `Provider` structs are ultimately created and populated by\n+`librustc_driver`, but it does this by distributing the work\n+throughout the other `rustc_*` crates. This is done by invoking\n+various `provide` functions. These functions tend to look something\n+like this:\n+\n+```rust\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        type_of,\n+        ..*providers\n+    };\n+}\n+```\n+\n+That is, they take an `&mut Providers` and mutate it in place. Usually\n+we use the formulation above just because it looks nice, but you could\n+as well do `providers.type_of = type_of`, which would be equivalent.\n+(Here, `type_of` would be a top-level function, defined as we saw\n+before.) So, if we wanted to have add a provider for some other query,\n+let's call it `fubar`, into the crate above, we might modify the `provide()`\n+function like so:\n+\n+```rust\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        type_of,\n+        fubar,\n+        ..*providers\n+    };\n+}\n+\n+fn fubar<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>, key: DefId) -> Fubar<'tcx> { .. }\n+```\n+\n+NB. Most of the `rustc_*` crate only provide **local\n+providers**. Almost all **extern providers** wind up going through the\n+`rustc_metadata` crate, which loads the information from the crate\n+metadata.  But in some cases there are crates that provide queries for\n+*both* local and external crates, in which case they define both a\n+`provide` and a `provide_extern` function that `rustc_driver` can\n+invoke.\n+\n+### Adding a new kind of query\n+\n+So suppose you want to add a new kind of query, how do you do so?\n+Well, defining a query takes place in two steps:\n+\n+1. first, you have to specify the query name and arguments; and then,\n+2. you have to supply query providers where needed.\n+\n+The specify the query name and arguments, you simply add an entry\n+to the big macro invocation in `mod.rs`. This will probably have changed\n+by the time you read this README, but at present it looks something\n+like:\n+\n+```\n+define_maps! { <'tcx>\n+    /// Records the type of every item.\n+    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+\n+    ...\n+}\n+```\n+\n+Each line of the macro defines one query. The name is broken up like this:\n+\n+```\n+[] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^\n+|     |        |          |         |\n+|     |        |          |         result type of query\n+|     |        |          query key type\n+|     |        dep-node constructor\n+|     name of query\n+query flags\n+```\n+\n+Let's go over them one by one:\n+\n+- **Query flags:** these are largely unused right now, but the intention\n+  is that we'll be able to customize various aspects of how the query is\n+  processed.\n+- **Name of query:** the name of the query method\n+  (`tcx.type_of(..)`). Also used as the name of a struct\n+  (`ty::maps::queries::type_of`) that will be generated to represent\n+  this query.\n+- **Dep-node constructor:** indicates the constructor function that\n+  connects this query to incremental compilation. Typically, this is a\n+  `DepNode` variant, which can be added by modifying the\n+  `define_dep_nodes!` macro invocation in\n+  `librustc/dep_graph/dep_node.rs`.\n+  - However, sometimes we use a custom function, in which case the\n+    name will be in snake case and the function will be defined at the\n+    bottom of the file. This is typically used when the query key is\n+    not a def-id, or just not the type that the dep-node expects.\n+- **Query key type:** the type of the argument to this query.\n+  This type must implement the `ty::maps::keys::Key` trait, which\n+  defines (for example) how to map it to a crate, and so forth.\n+- **Result type of query:** the type produced by this query. This type\n+  should (a) not use `RefCell` or other interior mutability and (b) be\n+  cheaply cloneable. Interning or using `Rc` or `Arc` is recommended for\n+  non-trivial data types.\n+  - The one exception to those rules is the `ty::steal::Steal` type,\n+    which is used to cheaply modify MIR in place. See the definition\n+    of `Steal` for more details. New uses of `Steal` should **not** be\n+    added without alerting `@rust-lang/compiler`.\n+\n+So, to add a query:\n+\n+- Add an entry to `define_maps!` using the format above.\n+- Possibly add a corresponding entry to the dep-node macro.\n+- Link the provider by modifying the appropriate `provide` method;\n+  or add a new one if needed and ensure that `rustc_driver` is invoking it.\n+\n+#### Query structs and descriptions\n+\n+For each kind, the `define_maps` macro will generate a \"query struct\"\n+named after the query. This struct is a kind of a place-holder\n+describing the query. Each such struct implements the\n+`self::config::QueryConfig` trait, which has associated types for the\n+key/value of that particular query. Basically the code generated looks something\n+like this:\n+\n+```rust\n+// Dummy struct representing a particular kind of query:\n+pub struct type_of<'tcx> { phantom: PhantomData<&'tcx ()> }\n+\n+impl<'tcx> QueryConfig for type_of<'tcx> {\n+  type Key = DefId;\n+  type Value = Ty<'tcx>;\n+}\n+```\n+\n+There is an additional trait that you may wish to implement called\n+`self::config::QueryDescription`. This trait is used during cycle\n+errors to give a \"human readable\" name for the query, so that we can\n+summarize what was happening when the cycle occurred. Implementing\n+this trait is optional if the query key is `DefId`, but if you *don't*\n+implement it, you get a pretty generic error (\"processing `foo`...\").\n+You can put new impls into the `config` module. They look something like this:\n+\n+```rust\n+impl<'tcx> QueryDescription for queries::type_of<'tcx> {\n+    fn describe(tcx: TyCtxt, key: DefId) -> String {\n+        format!(\"computing the type of `{}`\", tcx.item_path_str(key))\n+    }\n+}\n+```\n+"}, {"sha": "461b81a5c055f0f7acb2bdeee72a76817c456524", "filename": "src/librustc/ty/maps/config.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,492 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n+use ty::{self, Ty, TyCtxt};\n+use ty::maps::queries;\n+use ty::subst::Substs;\n+\n+use std::hash::Hash;\n+use syntax_pos::symbol::InternedString;\n+\n+/// Query configuration and description traits.\n+\n+pub trait QueryConfig {\n+    type Key: Eq + Hash + Clone;\n+    type Value;\n+}\n+\n+pub(super) trait QueryDescription: QueryConfig {\n+    fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n+}\n+\n+impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n+    default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_copy_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is `Copy`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sized_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is `Sized`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is freeze\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` needs drop\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing layout of `{}`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"computing the supertraits of `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        format!(\"computing the bounds for type parameter `{}`\",\n+                tcx.hir.ty_param_name(id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n+        format!(\"coherence checking all impls of trait `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, k: CrateNum) -> String {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"check for overlap between inherent impls defined in this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the variances for items in this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n+    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n+        format!(\"generating MIR shim for `{}`\",\n+                tcx.item_path_str(def.def_id()))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::privacy_access_levels<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"privacy access levels\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::typeck_item_bodies<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"type-checking all item bodies\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"reachability\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n+    fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>) -> String {\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.0))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"getting a list of all mir_keys\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n+        format!(\"computing the symbol for `{}`\", instance)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::describe_def<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"describe_def\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"def_span\")\n+    }\n+}\n+\n+\n+impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"stability\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"deprecation\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::item_attrs<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"item_attrs\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_exported_symbol<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"is_exported_symbol\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::fn_arg_names<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"fn_arg_names\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::impl_parent<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"impl_parent\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::trait_of_item<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"trait_of_item\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::item_body_nested_bodies<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"const checking if rvalue is promotable to static `{}`\",\n+            tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking if item is mir available: `{}`\",\n+            tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"dylib dependency formats of crate\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"checking if the crate is_panic_runtime\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"checking if the crate is_compiler_builtins\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"checking if the crate has_global_allocator\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"getting crate's ExternCrateData\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the lint levels for items in this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (DefId, DefId)) -> String {\n+        format!(\"computing whether impls specialize one another\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::in_scope_traits_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"traits in scope at a block\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"test whether a crate has #![no_builtins]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate's configured panic strategy\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![profiler_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![sanitizer_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the exported symbols of a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the native libraries of a linked crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the plugin registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the derive registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the disambiguator a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the hash a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the original name a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n+        format!(\"looking up implementations of a trait in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all (?) trait implementations\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up link arguments for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::named_region_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"looking up a named region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_late_bound_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"testing if a region is late boudn\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::object_lifetime_defaults_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"looking up lifetime defaults for a region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a dependency looks like\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a crate is named\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items defined in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the missing lang items in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the visible parent map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"seeing if we're missing an `extern crate` item for this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking at the source for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"generating a postorder list of CrateNums\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all possibly unused extern crates\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the stability index for the local crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching all foreign CrateNum instances\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"exported_symbols\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::collect_and_partition_translation_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"collect_and_partition_translation_items\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::codegen_unit<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n+        format!(\"codegen_unit\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::compile_codegen_unit<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n+        format!(\"compile_codegen_unit\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::output_filenames<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"output_filenames\")\n+    }\n+}"}, {"sha": "e37cf6697978196c5b2c4fb0c8fbcb2429156675", "filename": "src/librustc/ty/maps/keys.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Defines the set of legal keys that can be used in queries.\n+\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use mir::transform::{MirSuite, MirPassIndex};\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Substs;\n+use ty::fast_reject::SimplifiedType;\n+\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::symbol::InternedString;\n+\n+/// The `Key` trait controls what types can legally be used as the key\n+/// for a query.\n+pub trait Key: Clone + Hash + Eq + Debug {\n+    /// Given an instance of this key, what crate is it referring to?\n+    /// This is used to find the provider.\n+    fn map_crate(&self) -> CrateNum;\n+\n+    /// In the event that a cycle occurs, if no explicit span has been\n+    /// given for a query with key `self`, what span should we use?\n+    fn default_span(&self, tcx: TyCtxt) -> Span;\n+}\n+\n+impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n+impl<'tcx> Key for ty::Instance<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n+impl Key for CrateNum {\n+    fn map_crate(&self) -> CrateNum {\n+        *self\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl Key for DefIndex {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl Key for DefId {\n+    fn map_crate(&self) -> CrateNum {\n+        self.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(*self)\n+    }\n+}\n+\n+impl Key for (DefId, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (CrateNum, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (DefId, SimplifiedType) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n+impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirSuite, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirSuite, MirPassIndex, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.2.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.2.default_span(tcx)\n+    }\n+}\n+\n+impl<'tcx> Key for Ty<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    fn map_crate(&self) -> CrateNum {\n+        self.value.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.value.default_span(tcx)\n+    }\n+}\n+\n+impl Key for InternedString {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "c08ad68eddd06b1eab5683af66116a416ea3bfc4", "filename": "src/librustc/ty/maps/mod.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,453 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::{DepConstructor, DepNode};\n+use errors::DiagnosticBuilder;\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def::{Def, Export};\n+use hir::{self, TraitCandidate, ItemLocalId};\n+use hir::svh::Svh;\n+use lint;\n+use middle::const_val;\n+use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n+                     ExternBodyNestedBodies};\n+use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n+use middle::privacy::AccessLevels;\n+use middle::reachable::ReachableSet;\n+use middle::region;\n+use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n+use middle::stability::{self, DeprecationEntry};\n+use middle::lang_items::{LanguageItems, LangItem};\n+use middle::exported_symbols::SymbolExportLevel;\n+use middle::trans::{CodegenUnit, Stats};\n+use mir;\n+use session::CompileResult;\n+use session::config::OutputFilenames;\n+use traits::specialization_graph;\n+use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::layout::{Layout, LayoutError};\n+use ty::steal::Steal;\n+use ty::subst::Substs;\n+use util::nodemap::{DefIdSet, DefIdMap};\n+use util::common::{profq_msg, ProfileQueriesMsg};\n+\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_back::PanicStrategy;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use std::cell::{RefCell, Cell};\n+\n+use std::ops::Deref;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::symbol::InternedString;\n+use syntax::attr;\n+use syntax::ast;\n+use syntax::symbol::Symbol;\n+\n+#[macro_use]\n+mod plumbing;\n+use self::plumbing::*;\n+\n+mod keys;\n+pub use self::keys::Key;\n+\n+mod values;\n+use self::values::Value;\n+\n+mod config;\n+pub use self::config::QueryConfig;\n+use self::config::QueryDescription;\n+\n+// Each of these maps also corresponds to a method on a\n+// `Provider` trait for requesting a value of that type,\n+// and a method on `Maps` itself for doing that in a\n+// a way that memoizes and does dep-graph tracking,\n+// wrapping around the actual chain of providers that\n+// the driver creates (using several `rustc_*` crates).\n+define_maps! { <'tcx>\n+    /// Records the type of every item.\n+    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+    /// associated generics and predicates.\n+    [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+    [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// To avoid cycles within the predicates of a single item we compute\n+    /// per-type-parameter predicates for resolving `T::AssocTy`.\n+    [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n+        -> ty::GenericPredicates<'tcx>,\n+\n+    [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n+    [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n+    [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+    [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+\n+    /// True if this is a const fn\n+    [] fn is_const_fn: IsConstFn(DefId) -> bool,\n+\n+    /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+    [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n+\n+    /// True if this is a default impl (aka impl Foo for ..)\n+    [] fn is_default_impl: IsDefaultImpl(DefId) -> bool,\n+\n+    /// Get a map with the variance of every item; use `item_variance`\n+    /// instead.\n+    [] fn crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+\n+    /// Maps from def-id of a type or region parameter to its\n+    /// (inferred) variance.\n+    [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n+\n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+\n+    [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n+\n+    /// Maps a DefId of a type to a list of its inherent impls.\n+    /// Contains implementations of methods that are inherent to a type.\n+    /// Methods in these implementations don't need to be exported.\n+    [] fn inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+\n+    /// Set of all the def-ids in this crate that have MIR associated with\n+    /// them. This includes all the body owners, but also things like struct\n+    /// constructors.\n+    [] fn mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n+\n+    /// Maps DefId's that have an associated Mir to the result\n+    /// of the MIR qualify_consts pass. The actual meaning of\n+    /// the value isn't known except to the pass itself.\n+    [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Rc<IdxSetBuf<mir::Local>>),\n+\n+    /// Fetch the MIR for a given def-id up till the point where it is\n+    /// ready for const evaluation.\n+    ///\n+    /// See the README for the `mir` module for details.\n+    [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+    [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+    /// MIR after our optimization passes have run. This is MIR that is ready\n+    /// for trans. This is also the only query that can fetch non-local MIR, at present.\n+    [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n+\n+    /// Type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n+\n+    /// The signature of functions and closures.\n+    [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+\n+    /// Records the signature of each generator. The def ID is the ID of the\n+    /// expression defining the closure.\n+    [] fn generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n+        -> ty::adjustment::CoerceUnsizedInfo,\n+\n+    [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+\n+    [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+\n+    [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n+\n+    [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+\n+    [] fn borrowck: BorrowCheck(DefId) -> (),\n+    // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n+\n+    /// Gets a complete map from all types to their inherent impls.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+\n+    /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n+\n+    /// Results of evaluating const items or constants embedded in\n+    /// other items (such as enum variant explicit discriminants).\n+    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+        -> const_val::EvalResult<'tcx>,\n+\n+    /// Performs the privacy check and computes \"access levels\".\n+    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+\n+    [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n+\n+    /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n+    /// in the case of closures, this will be redirected to the enclosing function.\n+    [] fn region_scope_tree: RegionScopeTree(DefId) -> Rc<region::ScopeTree>,\n+\n+    [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n+\n+    [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+\n+    [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n+    [] fn def_span: DefSpan(DefId) -> Span,\n+    [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n+    [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n+    [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n+    [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n+    [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n+    [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n+    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n+    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n+    [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+    [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n+    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n+\n+    // Get the ParameterEnvironment for a given item; this environment\n+    // will be in \"user-facing\" mode, meaning that it is suitabe for\n+    // type-checking etc, and it does not normalize specializable\n+    // associated types. This is almost always what you want,\n+    // unless you are doing MIR optimizations, in which case you\n+    // might want to use `reveal_all()` method to change modes.\n+    [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n+\n+    // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n+    // `ty.is_copy()`, etc, since that will prune the environment where possible.\n+    [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                                  -> Result<&'tcx Layout, LayoutError<'tcx>>,\n+\n+    [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n+                                    -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n+\n+    [] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n+    [] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n+    [] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n+    [] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n+    [] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n+    [] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n+    [] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n+\n+    [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+\n+    [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n+    [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n+        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n+    [] fn module_exports: ModuleExports(DefId) -> Option<Rc<Vec<Export>>>,\n+    [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n+\n+    [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n+    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Rc<DefIdSet>,\n+    [] fn native_libraries: NativeLibraries(CrateNum) -> Rc<Vec<NativeLibrary>>,\n+    [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n+    [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n+    [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> Symbol,\n+    [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n+    [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n+\n+    [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n+        -> Rc<Vec<DefId>>,\n+    [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n+        -> Rc<Vec<DefId>>,\n+\n+    [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n+    [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n+    [] fn native_library_kind: NativeLibraryKind(DefId)\n+        -> Option<NativeLibraryKind>,\n+    [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n+\n+    [] fn named_region_map: NamedRegion(DefIndex) ->\n+        Option<Rc<FxHashMap<ItemLocalId, Region>>>,\n+    [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n+        Option<Rc<FxHashSet<ItemLocalId>>>,\n+    [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n+        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n+\n+    [] fn visibility: Visibility(DefId) -> ty::Visibility,\n+    [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n+    [] fn crate_name: CrateName(CrateNum) -> Symbol,\n+    [] fn item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n+    [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n+\n+    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefId, usize)>>,\n+    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n+    [] fn extern_const_body: ExternConstBody(DefId) -> ExternConstBody<'tcx>,\n+    [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n+        -> Rc<DefIdMap<DefId>>,\n+    [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n+    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n+    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+\n+    [] fn freevars: Freevars(DefId) -> Option<Rc<Vec<hir::Freevar>>>,\n+    [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n+    [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n+        -> Rc<Vec<(DefId, Span)>>,\n+\n+    [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n+    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+\n+    [] fn exported_symbols: ExportedSymbols(CrateNum)\n+        -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+    [] fn collect_and_partition_translation_items:\n+        collect_and_partition_translation_items_node(CrateNum)\n+        -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n+    [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n+    [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n+    [] fn is_translated_function: IsTranslatedFunction(DefId) -> bool,\n+    [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n+    [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n+    [] fn output_filenames: output_filenames_node(CrateNum)\n+        -> Arc<OutputFilenames>,\n+}\n+\n+//////////////////////////////////////////////////////////////////////\n+// These functions are little shims used to find the dep-node for a\n+// given query when there is not a *direct* mapping:\n+\n+fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n+    DepConstructor::TypeParamPredicates {\n+        item_id,\n+        param_id\n+    }\n+}\n+\n+fn coherent_trait_dep_node<'tcx>((_, def_id): (CrateNum, DefId)) -> DepConstructor<'tcx> {\n+    DepConstructor::CoherenceCheckTrait(def_id)\n+}\n+\n+fn crate_inherent_impls_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::Coherence\n+}\n+\n+fn inherent_impls_overlap_check_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::CoherenceInherentImplOverlapCheck\n+}\n+\n+fn reachability_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::Reachability\n+}\n+\n+fn mir_shim_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::MirShim {\n+        instance_def\n+    }\n+}\n+\n+fn symbol_name_dep_node<'tcx>(instance: ty::Instance<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::InstanceSymbolName { instance }\n+}\n+\n+fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::TypeckBodiesKrate\n+}\n+\n+fn const_eval_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+                             -> DepConstructor<'tcx> {\n+    DepConstructor::ConstEval\n+}\n+\n+fn mir_keys<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::MirKeys\n+}\n+\n+fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::CrateVariances\n+}\n+\n+fn is_copy_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::IsCopy\n+}\n+\n+fn is_sized_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::IsSized\n+}\n+\n+fn is_freeze_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::IsFreeze\n+}\n+\n+fn needs_drop_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::NeedsDrop\n+}\n+\n+fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::Layout\n+}\n+\n+fn lint_levels_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LintLevels\n+}\n+\n+fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n+    DepConstructor::Specializes { impl1: a, impl2: b }\n+}\n+\n+fn implementations_of_trait_node<'tcx>((krate, trait_id): (CrateNum, DefId))\n+    -> DepConstructor<'tcx>\n+{\n+    DepConstructor::ImplementationsOfTrait { krate, trait_id }\n+}\n+\n+fn link_args_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LinkArgs\n+}\n+\n+fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::GetLangItems\n+}\n+\n+fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::VisibleParentMap\n+}\n+\n+fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::PostorderCnums\n+}\n+\n+fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::MaybeUnusedExternCrates\n+}\n+\n+fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::StabilityIndex\n+}\n+\n+fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::AllCrateNums\n+}\n+\n+fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::CollectAndPartitionTranslationItems\n+}\n+\n+fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::OutputFilenames\n+}"}, {"sha": "87a9eef0de5329fe99f80db7d903e7eecf5e2848", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,494 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The implementation of the query system itself. Defines the macros\n+//! that generate the actual methods on tcx which find and execute the\n+//! provider, manage the caches, and so forth.\n+\n+use dep_graph::{DepNodeIndex};\n+use errors::{Diagnostic, DiagnosticBuilder};\n+use ty::{TyCtxt};\n+use ty::maps::Query; // NB: actually generated by the macros in this file\n+use ty::maps::config::QueryDescription;\n+use ty::item_path;\n+\n+use rustc_data_structures::fx::{FxHashMap};\n+use std::cell::{RefMut, Cell};\n+use std::marker::PhantomData;\n+use std::mem;\n+use syntax_pos::Span;\n+\n+pub(super) struct QueryMap<D: QueryDescription> {\n+    phantom: PhantomData<D>,\n+    pub(super) map: FxHashMap<D::Key, QueryValue<D::Value>>,\n+}\n+\n+pub(super) struct QueryValue<T> {\n+    pub(super) value: T,\n+    pub(super) index: DepNodeIndex,\n+    pub(super) diagnostics: Option<Box<QueryDiagnostics>>,\n+}\n+\n+pub(super) struct QueryDiagnostics {\n+    pub(super) diagnostics: Vec<Diagnostic>,\n+    pub(super) emitted_diagnostics: Cell<bool>,\n+}\n+\n+impl<M: QueryDescription> QueryMap<M> {\n+    pub(super) fn new() -> QueryMap<M> {\n+        QueryMap {\n+            phantom: PhantomData,\n+            map: FxHashMap(),\n+        }\n+    }\n+}\n+\n+pub(super) struct CycleError<'a, 'tcx: 'a> {\n+    span: Span,\n+    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub(super) fn report_cycle(self, CycleError { span, cycle }: CycleError)\n+        -> DiagnosticBuilder<'a>\n+    {\n+        // Subtle: release the refcell lock before invoking `describe()`\n+        // below by dropping `cycle`.\n+        let stack = cycle.to_vec();\n+        mem::drop(cycle);\n+\n+        assert!(!stack.is_empty());\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        item_path::with_forced_impl_filename_line(|| {\n+            let mut err =\n+                struct_span_err!(self.sess, span, E0391,\n+                                 \"unsupported cyclic reference between types/traits detected\");\n+            err.span_label(span, \"cyclic reference\");\n+\n+            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n+                                               stack[0].1.describe(self)));\n+\n+            for &(span, ref query) in &stack[1..] {\n+                err.span_note(span, &format!(\"...which then requires {}...\",\n+                                             query.describe(self)));\n+            }\n+\n+            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                              stack[0].1.describe(self)));\n+\n+            return err\n+        })\n+    }\n+\n+    pub(super) fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n+                                    -> Result<R, CycleError<'a, 'gcx>>\n+        where F: FnOnce() -> R\n+    {\n+        {\n+            let mut stack = self.maps.query_stack.borrow_mut();\n+            if let Some((i, _)) = stack.iter().enumerate().rev()\n+                                       .find(|&(_, &(_, ref q))| *q == query) {\n+                return Err(CycleError {\n+                    span,\n+                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n+                });\n+            }\n+            stack.push((span, query));\n+        }\n+\n+        let result = compute();\n+\n+        self.maps.query_stack.borrow_mut().pop();\n+\n+        Ok(result)\n+    }\n+}\n+\n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if  $tcx.sess.profile_queries() {\n+                profq_msg($msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_key {\n+    ($tcx:expr, $key:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None }\n+    }\n+}\n+\n+macro_rules! define_maps {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n+        }\n+\n+        impl<$tcx> Maps<$tcx> {\n+            pub fn new(providers: IndexVec<CrateNum, Providers<$tcx>>)\n+                       -> Self {\n+                Maps {\n+                    providers,\n+                    query_stack: RefCell::new(vec![]),\n+                    $($name: RefCell::new(QueryMap::new())),*\n+                }\n+            }\n+        }\n+\n+        #[allow(bad_style)]\n+        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+        pub enum Query<$tcx> {\n+            $($(#[$attr])* $name($K)),*\n+        }\n+\n+        #[allow(bad_style)]\n+        #[derive(Clone, Debug, PartialEq, Eq)]\n+        pub enum QueryMsg {\n+            $($name(Option<String>)),*\n+        }\n+\n+        impl<$tcx> Query<$tcx> {\n+            pub fn describe(&self, tcx: TyCtxt) -> String {\n+                let (r, name) = match *self {\n+                    $(Query::$name(key) => {\n+                        (queries::$name::describe(tcx, key), stringify!($name))\n+                    })*\n+                };\n+                if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", r, name)\n+                } else {\n+                    r\n+                }\n+            }\n+        }\n+\n+        pub mod queries {\n+            use std::marker::PhantomData;\n+\n+            $(#[allow(bad_style)]\n+            pub struct $name<$tcx> {\n+                data: PhantomData<&$tcx ()>\n+            })*\n+        }\n+\n+        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n+            type Key = $K;\n+            type Value = $V;\n+        }\n+\n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+            #[allow(unused)]\n+            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n+                use dep_graph::DepConstructor::*;\n+\n+                DepNode::new(tcx, $node(*key))\n+            }\n+\n+            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                                  mut span: Span,\n+                                  key: $K,\n+                                  f: F)\n+                                  -> Result<R, CycleError<'a, $tcx>>\n+                where F: FnOnce(&$V) -> R\n+            {\n+                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+                       stringify!($name),\n+                       key,\n+                       span);\n+\n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(\n+                        span.clone(),\n+                        QueryMsg::$name(profq_key!(tcx, key))\n+                    )\n+                );\n+\n+                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n+                    if let Some(ref d) = value.diagnostics {\n+                        if !d.emitted_diagnostics.get() {\n+                            d.emitted_diagnostics.set(true);\n+                            let handle = tcx.sess.diagnostic();\n+                            for diagnostic in d.diagnostics.iter() {\n+                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n+                                    .emit();\n+                            }\n+                        }\n+                    }\n+                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                    tcx.dep_graph.read_index(value.index);\n+                    return Ok(f(&value.value));\n+                }\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n+\n+                // FIXME(eddyb) Get more valid Span's on queries.\n+                // def_span guard is necessary to prevent a recursive loop,\n+                // default_span calls def_span query internally.\n+                if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n+                    span = key.default_span(tcx)\n+                }\n+\n+                let dep_node = Self::to_dep_node(tcx, &key);\n+                let res = tcx.cycle_check(span, Query::$name(key), || {\n+                    tcx.sess.diagnostic().track_diagnostics(|| {\n+                        if dep_node.kind.is_anon() {\n+                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            })\n+                        } else {\n+                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n+                                                            key: $K)\n+                                                            -> $V {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            }\n+\n+                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n+                        }\n+                    })\n+                })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n+                let ((result, dep_node_index), diagnostics) = res;\n+\n+                tcx.dep_graph.read_index(dep_node_index);\n+\n+                let value = QueryValue {\n+                    value: result,\n+                    index: dep_node_index,\n+                    diagnostics: if diagnostics.len() == 0 {\n+                        None\n+                    } else {\n+                        Some(Box::new(QueryDiagnostics {\n+                            diagnostics,\n+                            emitted_diagnostics: Cell::new(true),\n+                        }))\n+                    },\n+                };\n+\n+                Ok(f(&tcx.maps\n+                         .$name\n+                         .borrow_mut()\n+                         .map\n+                         .entry(key)\n+                         .or_insert(value)\n+                         .value))\n+            }\n+\n+            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n+                           -> Result<$V, DiagnosticBuilder<'a>> {\n+                match Self::try_get_with(tcx, span, key, Clone::clone) {\n+                    Ok(e) => Ok(e),\n+                    Err(e) => Err(tcx.report_cycle(e)),\n+                }\n+            }\n+\n+            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n+                // Ignore dependencies, since we not reading the computed value\n+                let _task = tcx.dep_graph.in_ignore();\n+\n+                match Self::try_get_with(tcx, span, key, |_| ()) {\n+                    Ok(()) => {}\n+                    Err(e) => tcx.report_cycle(e).emit(),\n+                }\n+            }\n+        })*\n+\n+        #[derive(Copy, Clone)]\n+        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            pub span: Span,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n+            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+            fn deref(&self) -> &Self::Target {\n+                &self.tcx\n+            }\n+        }\n+\n+        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n+            /// Return a transparent wrapper for `TyCtxt` which uses\n+            /// `span` as the location of queries performed through it.\n+            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n+                TyCtxtAt {\n+                    tcx: self,\n+                    span\n+                }\n+            }\n+\n+            $($(#[$attr])*\n+            pub fn $name(self, key: $K) -> $V {\n+                self.at(DUMMY_SP).$name(key)\n+            })*\n+        }\n+\n+        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n+            $($(#[$attr])*\n+            pub fn $name(self, key: $K) -> $V {\n+                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n+                    e.emit();\n+                    Value::from_cycle_error(self.global_tcx())\n+                })\n+            })*\n+        }\n+\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n+            output: ()\n+        }\n+\n+        impl<$tcx> Copy for Providers<$tcx> {}\n+        impl<$tcx> Clone for Providers<$tcx> {\n+            fn clone(&self) -> Self { *self }\n+        }\n+    }\n+}\n+\n+macro_rules! define_map_struct {\n+    // Initial state\n+    (tcx: $tcx:tt,\n+     input: $input:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final output\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($($output:tt)*)) => {\n+        pub struct Maps<$tcx> {\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n+            $($output)*\n+        }\n+    };\n+\n+    // Field recognized and ready to shift into the output\n+    (tcx: $tcx:tt,\n+     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)*\n+                     $(#[$attr])* $($pub)* $name: RefCell<QueryMap<queries::$name<$tcx>>>,)\n+        }\n+    };\n+\n+    // No modifiers left? This is a private item.\n+    (tcx: $tcx:tt,\n+     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            ready: ([] $attrs $name),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip other modifiers\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n+}\n+\n+macro_rules! define_provider_struct {\n+    // Initial state:\n+    (tcx: $tcx:tt, input: $input:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final state:\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n+        pub struct Providers<$tcx> {\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+        }\n+\n+        impl<$tcx> Default for Providers<$tcx> {\n+            fn default() -> Self {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n+                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n+                         stringify!($name), key);\n+                })*\n+                Providers { $($name),* }\n+            }\n+        }\n+    };\n+\n+    // Something ready to shift:\n+    (tcx: $tcx:tt,\n+     ready: ($name:tt $K:tt $V:tt),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)* ($name $K $V))\n+        }\n+    };\n+\n+    // Regular queries produce a `V` only.\n+    (tcx: $tcx:tt,\n+     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            ready: ($name $K $V),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip modifiers.\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n+}"}, {"sha": "165798d19f196439adc319b40d2dfcbac3545a91", "filename": "src/librustc/ty/maps/values.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, Ty, TyCtxt};\n+\n+use syntax::symbol::Symbol;\n+\n+pub(super) trait Value<'tcx>: Sized {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n+}\n+\n+impl<'tcx, T> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        tcx.sess.abort_if_errors();\n+        bug!(\"Value::from_cycle_error called without errors\");\n+    }\n+}\n+\n+impl<'tcx, T: Default> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        T::default()\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for Ty<'tcx> {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.types.err\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        Self::empty()\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for ty::SymbolName {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n+    }\n+}\n+"}, {"sha": "bd99c687bb6ad91597414b3d491eecd40381ce82", "filename": "src/librustc_back/README.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_back%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_back%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,6 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+`librustc_back` contains some very low-level details that are\n+specific to different LLVM targets and so forth."}, {"sha": "5331a05b5cd8e4dd475f60aa78479731923c3eb2", "filename": "src/librustc_driver/README.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,12 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `driver` crate is effectively the \"main\" function for the rust\n+compiler.  It orchstrates the compilation process and \"knits together\"\n+the code from the other crates within rustc. This crate itself does\n+not contain any of the \"main logic\" of the compiler (though it does\n+have some code related to pretty printing or other minor compiler\n+options).\n+\n+"}, {"sha": "b69d632a6a0dfba36adbed00195a8b32583e04f2", "filename": "src/librustc_trans/README.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -1 +1,7 @@\n-See [librustc/README.md](../librustc/README.md).\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `trans` crate contains the code to convert from MIR into LLVM IR,\n+and then from LLVM IR into machine code. In general it contains code\n+that runs towards the end of the compilation process."}, {"sha": "a38f04e304b6c38d5b1da48341d48ec7e0e59003", "filename": "src/librustc_typeck/README.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_typeck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_typeck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,48 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `rustc_typeck` crate contains the source for \"type collection\" and\n+\"type checking\", as well as a few other bits of related functionality.\n+(It draws heavily on the [type inferencing][infer] and\n+[trait solving][traits] code found in librustc.)\n+\n+[infer]: ../librustc/infer/README.md\n+[traits]: ../librustc/traits/README.md\n+\n+## Type collection\n+\n+Type \"collection\" is the process of convering the types found in the\n+HIR (`hir::Ty`), which represent the syntactic things that the user\n+wrote, into the **internal representation** used by the compiler\n+(`Ty<'tcx>`) -- we also do similar conversions for where-clauses and\n+other bits of the function signature.\n+\n+To try and get a sense for the difference, consider this function:\n+\n+```rust\n+struct Foo { }\n+fn foo(x: Foo, y: self::Foo) { .. }\n+//        ^^^     ^^^^^^^^^\n+```\n+\n+Those two parameters `x` and `y` each have the same type: but they\n+will have distinct `hir::Ty` nodes. Those nodes will have different\n+spans, and of course they encode the path somewhat differently. But\n+once they are \"collected\" into `Ty<'tcx>` nodes, they will be\n+represented by the exact same internal type.\n+\n+Collection is defined as a bundle of queries (e.g., `type_of`) for\n+computing information about the various functions, traits, and other\n+items in the crate being compiled. Note that each of these queries is\n+concerned with *interprocedural* things -- for example, for a function\n+definition, collection will figure out the type and signature of the\n+function, but it will not visit the *body* of the function in any way,\n+nor examine type annotations on local variables (that's the job of\n+type *checking*).\n+\n+For more details, see the `collect` module.\n+\n+## Type checking\n+\n+TODO"}, {"sha": "79cb9147c185bcc5455223edd0740742df131c21", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -8,50 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n-\n-# Collect phase\n-\n-The collect phase of type check has the job of visiting all items,\n-determining their type, and writing that type into the `tcx.types`\n-table.  Despite its name, this table does not really operate as a\n-*cache*, at least not for the types of items defined within the\n-current crate: we assume that after the collect phase, the types of\n-all local items will be present in the table.\n-\n-Unlike most of the types that are present in Rust, the types computed\n-for each item are in fact type schemes. This means that they are\n-generic types that may have type parameters. TypeSchemes are\n-represented by a pair of `Generics` and `Ty`.  Type\n-parameters themselves are represented as `ty_param()` instances.\n-\n-The phasing of type conversion is somewhat complicated. There is no\n-clear set of phases we can enforce (e.g., converting traits first,\n-then types, or something like that) because the user can introduce\n-arbitrary interdependencies. So instead we generally convert things\n-lazilly and on demand, and include logic that checks for cycles.\n-Demand is driven by calls to `AstConv::get_item_type_scheme` or\n-`AstConv::trait_def`.\n-\n-Currently, we \"convert\" types and traits in two phases (note that\n-conversion only affects the types of items / enum variants / methods;\n-it does not e.g. compute the types of individual expressions):\n-\n-0. Intrinsics\n-1. Trait/Type definitions\n-\n-Conversion itself is done by simply walking each of the items in turn\n-and invoking an appropriate function (e.g., `trait_def_of_item` or\n-`convert_item`). However, it is possible that while converting an\n-item, we may need to compute the *type scheme* or *trait definition*\n-for other items.\n-\n-There are some shortcomings in this design:\n-- Because the item generics include defaults, cycles through type\n-  parameter defaults are illegal even if those defaults are never\n-  employed. This is not necessarily a bug.\n-\n-*/\n+//! \"Collection\" is the process of determining the type and other external\n+//! details of each item in Rust. Collection is specifically concerned\n+//! with *interprocedural* things -- for example, for a function\n+//! definition, collection will figure out the type and signature of the\n+//! function, but it will not visit the *body* of the function in any way,\n+//! nor examine type annotations on local variables (that's the job of\n+//! type *checking*).\n+//!\n+//! Collecting is ultimately defined by a bundle of queries that\n+//! inquire after various facts about the items in the crate (e.g.,\n+//! `type_of`, `generics_of`, `predicates_of`, etc). See the `provide` function\n+//! for the full set.\n+//!\n+//! At present, however, we do run collection across all items in the\n+//! crate as a kind of pass. This should eventually be factored away.\n \n use astconv::{AstConv, Bounds};\n use lint;"}, {"sha": "3bf735ee868037f96feeb19c59b306d42583e959", "filename": "src/libsyntax/README.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibsyntax%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630/src%2Flibsyntax%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FREADME.md?ref=f60bc3ac0c20f7b3ab85df1e5e2e3217a7a95630", "patch": "@@ -0,0 +1,7 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `syntax` crate contains those things concerned purely with syntax\n+\u2013 that is, the AST (\"abstract syntax tree\"), parser, pretty-printer,\n+lexer, macro expander, and utilities for traversing ASTs."}]}