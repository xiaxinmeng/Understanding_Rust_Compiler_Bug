{"sha": "fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNmI1OGQwYTgwOWI0OTk0Y2QxYTYzM2NjYjA0ZTg5MjM0ZmYwYjg=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-10-26T05:41:17Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:35:08Z"}, "message": "Simplify BodyCache impl and fix all remaining type errors in librustc_mir (lifetime errors still exist)", "tree": {"sha": "61c0f5dd280467c5f8e3e16c527711732bf682d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61c0f5dd280467c5f8e3e16c527711732bf682d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "html_url": "https://github.com/rust-lang/rust/commit/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c0887c769b227c827c76d80fa76fc5e4493516", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c0887c769b227c827c76d80fa76fc5e4493516", "html_url": "https://github.com/rust-lang/rust/commit/38c0887c769b227c827c76d80fa76fc5e4493516"}], "stats": {"total": 1200, "additions": 588, "deletions": 612}, "files": [{"sha": "364a35f1b6faa1ed0328b2d7c1790ea26b0a6342", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -23,17 +23,17 @@ macro_rules! arena_types {\n             [] generics: rustc::ty::Generics,\n             [] trait_def: rustc::ty::TraitDef,\n             [] adt_def: rustc::ty::AdtDef,\n-            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n-            [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_mir: rustc::ty::steal::Steal<rustc::mir::BodyCache<$tcx>>,\n+            [] mir: rustc::mir::BodyCache<$tcx>,\n             [] steal_promoted: rustc::ty::steal::Steal<\n                 rustc_index::vec::IndexVec<\n                     rustc::mir::Promoted,\n-                    rustc::mir::Body<$tcx>\n+                    rustc::mir::BodyCache<$tcx>\n                 >\n             >,\n             [] promoted: rustc_index::vec::IndexVec<\n                 rustc::mir::Promoted,\n-                rustc::mir::Body<$tcx>\n+                rustc::mir::BodyCache<$tcx>\n             >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,"}, {"sha": "8958a31b51cb56c6567c2b79242dc9287d9a06c4", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 78, "deletions": 106, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -1,7 +1,7 @@\n use rustc_index::vec::IndexVec;\n-//use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-//use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n-//use crate::ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+use crate::ich::StableHashingContext;\n use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n@@ -14,23 +14,23 @@ pub struct Cache {\n     predecessors: Option<IndexVec<BasicBlock, Vec<BasicBlock>>>,\n }\n \n-//impl<'tcx, T> rustc_serialize::Encodable for Cache<'tcx, T> {\n-//    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-//        Encodable::encode(&(), s)\n-//    }\n-//}\n-//\n-//impl<'tcx, T> rustc_serialize::Decodable for Cache<'tcx, T> {\n-//    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-//        Decodable::decode(d).map(|_v: ()| Self::new())\n-//    }\n-//}\n-//\n-//impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for Cache<'tcx, T> {\n-//    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n-//        // Do nothing.\n-//    }\n-//}\n+impl rustc_serialize::Encodable for Cache {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl rustc_serialize::Decodable for Cache {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        Decodable::decode(d).map(|_v: ()| Self::new())\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n+    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n+        // Do nothing.\n+    }\n+}\n \n macro_rules! get_predecessors {\n     (mut $self:ident, $block:expr, $body:expr) => {\n@@ -98,13 +98,13 @@ impl Cache {\n \n     #[inline]\n     /// This will recompute the predecessors cache if it is not available\n-    pub fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n         self.ensure_predecessors(body);\n         self.predecessors.as_ref().unwrap()\n     }\n \n     #[inline]\n-    pub fn predecessors_for(&mut self, bb: BasicBlock, body: &Body<'_>) -> &[BasicBlock] {\n+    fn predecessors_for(&mut self, bb: BasicBlock, body: &Body<'_>) -> &[BasicBlock] {\n         &self.predecessors(body)[bb]\n     }\n \n@@ -136,55 +136,58 @@ impl Cache {\n     }\n }\n \n-pub struct BodyCache<T> {\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct BodyCache<'tcx> {\n     cache: Cache,\n-    body: T,\n+    body: Body<'tcx>,\n }\n \n-impl<T> BodyCache<T> {\n-    pub fn new(body: T) -> Self {\n+impl BodyCache<'tcx> {\n+    pub fn new(body: Body<'tcx>) -> Self {\n         Self {\n             cache: Cache::new(),\n-            body\n+            body,\n         }\n     }\n }\n \n-impl<'a, 'tcx> BodyCache<&'a Body<'tcx>> {\n-    #[inline]\n-    pub fn predecessors_for(&mut self, bb: BasicBlock) -> &[BasicBlock] {\n-        self.cache.predecessors_for(bb, self.body)\n+impl BodyCache<'tcx> {\n+    pub fn ensure_predecessors(&mut self) {\n+        self.cache.ensure_predecessors(&self.body);\n     }\n \n-    #[inline]\n-    pub fn body(&self) -> &'a Body<'tcx> {\n-        self.body\n+    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        self.cache.predecessors(&self.body)\n     }\n \n-    #[inline]\n-    pub fn read_only(mut self) -> ReadOnlyBodyCache<'a, 'tcx> {\n-        self.cache.ensure_predecessors(self.body);\n+    pub fn read_only(&self) -> ReadOnlyBodyCache<'_, '_> {\n+        assert!(self.cache.predecessors.is_some(), \"\");\n         ReadOnlyBodyCache {\n-            cache: self.cache,\n-            body: self.body,\n+            cache: &self.cache,\n+            body: &self.body,\n         }\n     }\n \n-    #[inline]\n-    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        &self.body.basic_blocks\n+    pub fn body(&self) -> &Body<'tcx> {\n+        &self.body\n     }\n-}\n \n-impl<'a, 'tcx> Deref for BodyCache<&'a Body<'tcx>> {\n-    type Target = Body<'tcx>;\n+    pub fn body_mut(&mut self) -> &mut Body<'tcx> {\n+        &mut self.body\n+    }\n \n-    fn deref(&self) -> &Self::Target {\n-        self.body\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.cache.basic_blocks_mut(&mut self.body)\n+    }\n+\n+    pub fn basic_blocks_and_local_decls_mut(\n+        &mut self\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n+        self.cache.basic_blocks_and_local_decls_mut(&mut self.body)\n     }\n }\n \n-impl<'a, 'tcx> Index<BasicBlock> for BodyCache<&'a Body<'tcx>> {\n+impl<'tcx> Index<BasicBlock> for BodyCache<'tcx> {\n     type Output = BasicBlockData<'tcx>;\n \n     #[inline]\n@@ -193,69 +196,29 @@ impl<'a, 'tcx> Index<BasicBlock> for BodyCache<&'a Body<'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx> BodyCache<&'a mut Body<'tcx>> {\n-    #[inline]\n-    pub fn body(&self) -> &Body<'tcx> {\n-        self.body\n-    }\n-\n-    #[inline]\n-    pub fn body_mut(&mut self) -> &mut Body<'tcx> {\n-        self.body\n-    }\n-\n-    #[inline]\n-    pub fn read_only(mut self) -> ReadOnlyBodyCache<'a, 'tcx> {\n-        self.cache.ensure_predecessors(self.body);\n-        ReadOnlyBodyCache {\n-            cache: self.cache,\n-            body: self.body,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        &self.body.basic_blocks\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        self.cache.basic_blocks_mut(&mut self.body)\n+impl<'tcx> IndexMut<BasicBlock> for BodyCache<'tcx> {\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n+        &mut self.basic_blocks_mut()[index]\n     }\n }\n \n-impl<'a, 'tcx> Deref for BodyCache<&'a mut Body<'tcx>> {\n+impl<'tcx> Deref for BodyCache<'tcx> {\n     type Target = Body<'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        self.body\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefMut for BodyCache<&'a mut Body<'tcx>> {\n-    fn deref_mut(&mut self) -> &mut Body<'tcx> {\n-        self.body\n-    }\n-}\n-\n-impl<'a, 'tcx> Index<BasicBlock> for BodyCache<&'a mut Body<'tcx>> {\n-    type Output = BasicBlockData<'tcx>;\n-\n-    #[inline]\n-    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n-        &self.body[index]\n+        &self.body\n     }\n }\n \n-impl<'a, 'tcx> IndexMut<BasicBlock> for BodyCache<&'a mut Body<'tcx>> {\n-    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n-        self.cache.invalidate_predecessors();\n-        &mut self.body.basic_blocks[index]\n+impl<'tcx> DerefMut for BodyCache<'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.body\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n pub struct ReadOnlyBodyCache<'a, 'tcx> {\n-    cache: Cache,\n+    cache: &'a Cache,\n     body: &'a Body<'tcx>,\n }\n \n@@ -289,13 +252,6 @@ impl ReadOnlyBodyCache<'a, 'tcx> {\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n         dominators(self)\n     }\n-\n-    pub fn to_owned(self) -> BodyCache<&'a Body<'tcx>> {\n-        BodyCache {\n-            cache: self.cache,\n-            body: self.body,\n-        }\n-    }\n }\n \n impl graph::DirectedGraph for ReadOnlyBodyCache<'a, 'tcx> {\n@@ -358,4 +314,20 @@ impl Index<BasicBlock> for ReadOnlyBodyCache<'a, 'tcx> {\n     fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n         &self.body[index]\n     }\n-}\n\\ No newline at end of file\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    Cache,\n+}\n+\n+impl_stable_hash_for!(struct BodyCache<'tcx> {\n+    cache,\n+    body,\n+});\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for BodyCache<'tcx> {\n+        cache,\n+        body\n+    }\n+}"}, {"sha": "b6d1c78cc4f575465bee2859ba7f7be13b3748d9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -107,7 +107,7 @@ pub struct Body<'tcx> {\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue.\n-    pub generator_drop: Option<Box<Body<'tcx>>>,\n+    pub generator_drop: Option<Box<BodyCache<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n@@ -2600,7 +2600,7 @@ impl Location {\n     pub fn is_predecessor_of<'tcx>(\n         &self,\n         other: Location,\n-        body_cache: &ReadOnlyBodyCache<'_, 'tcx>\n+        body_cache: ReadOnlyBodyCache<'_, 'tcx>\n     ) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`."}, {"sha": "68694f1b71711cc0fd5da632d6c4dc869664dc43", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -67,10 +67,10 @@ use syntax_pos::Span;\n \n macro_rules! body_cache_type {\n     (mut $a:lifetime, $tcx:lifetime) => {\n-        &mut BodyCache<& $a mut Body<$tcx>>\n+        &mut BodyCache<$tcx>\n     };\n     ($a:lifetime, $tcx:lifetime) => {\n-        &ReadOnlyBodyCache<$a, $tcx>\n+        ReadOnlyBodyCache<$a, $tcx>\n     };\n }\n "}, {"sha": "cdfdcee5823ec55023ae9d84bf41bf4f6def74c7", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -106,42 +106,46 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {}\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyCache<'tcx>> {}\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_const(_: DefId) -> &'tcx Steal<mir::BodyCache<'tcx>> {\n             no_hash\n         }\n \n         query mir_validated(_: DefId) ->\n             (\n-                &'tcx Steal<mir::Body<'tcx>>,\n-                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+                &'tcx Steal<mir::BodyCache<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::BodyCache<'tcx>>>\n             ) {\n             no_hash\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n+        query optimized_mir(key: DefId) -> &'tcx mir::BodyCache<'tcx> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n-                let mir: Option<crate::mir::Body<'tcx>> = tcx.queries.on_disk_cache\n-                                                            .try_load_query_result(tcx, id);\n-                mir.map(|x| &*tcx.arena.alloc(x))\n+                let mir: Option<crate::mir::BodyCache<'tcx>>\n+                    = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n+                mir.map(|x| {\n+                    let cache = tcx.arena.alloc(x);\n+                    cache.ensure_predecessors();\n+                    &*cache\n+                })\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::BodyCache<'tcx>> {\n             cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let promoted: Option<\n                     rustc_index::vec::IndexVec<\n                         crate::mir::Promoted,\n-                        crate::mir::Body<'tcx>\n+                        crate::mir::BodyCache<'tcx>\n                     >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n                 promoted.map(|p| &*tcx.arena.alloc(p))\n             }\n@@ -502,7 +506,7 @@ rustc_queries! {\n         /// in the case of closures, this will be redirected to the enclosing function.\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n-        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyCache<'tcx> {\n             no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }"}, {"sha": "07d86a5f86a4f0ca9550238a7ced1fda24ae22a1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -22,7 +22,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::{BodyCache, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -1083,17 +1083,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self.hir_map\n     }\n \n-    pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n-        self.arena.alloc(Steal::new(mir))\n+    pub fn alloc_steal_mir(self, mir_cache: BodyCache<'tcx>) -> &'tcx Steal<BodyCache<'tcx>> {\n+        self.arena.alloc(Steal::new(mir_cache))\n     }\n \n-    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n-        &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n+    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, BodyCache<'tcx>>) ->\n+        &'tcx Steal<IndexVec<Promoted, BodyCache<'tcx>>> {\n         self.arena.alloc(Steal::new(promoted))\n     }\n \n-    pub fn intern_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n-        &'tcx IndexVec<Promoted, Body<'tcx>> {\n+    pub fn intern_promoted(self, promoted: IndexVec<Promoted, BodyCache<'tcx>>) ->\n+        &'tcx IndexVec<Promoted, BodyCache<'tcx>> {\n         self.arena.alloc(promoted)\n     }\n "}, {"sha": "f8feff0def97257100f410a86ce50280ff8ad2ea", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -18,7 +18,7 @@ use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n-use crate::mir::Body;\n+use crate::mir::ReadOnlyBodyCache;\n use crate::mir::interpret::{GlobalId, ErrorHandled};\n use crate::mir::GeneratorLayout;\n use crate::session::CrateDisambiguator;\n@@ -2985,10 +2985,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n-    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+    pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> ReadOnlyBodyCache<'tcx, 'tcx> {\n         match instance {\n             ty::InstanceDef::Item(did) => {\n-                self.optimized_mir(did)\n+                self.optimized_mir(did).read_only()\n             }\n             ty::InstanceDef::VtableShim(..) |\n             ty::InstanceDef::ReifyShim(..) |\n@@ -2998,7 +2998,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::InstanceDef::ClosureOnceShim { .. } |\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) => {\n-                self.mir_shims(instance)\n+                self.mir_shims(instance).read_only()\n             }\n         }\n     }\n@@ -3023,7 +3023,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn generator_layout(self, def_id: DefId) -> &'tcx GeneratorLayout<'tcx> {\n-        self.optimized_mir(def_id).generator_layout.as_ref().unwrap()\n+        self.optimized_mir(def_id).body().generator_layout.as_ref().unwrap()\n     }\n \n     /// Given the `DefId` of an impl, returns the `DefId` of the trait it implements."}, {"sha": "e460a4a2e8c97a57bb7ea2082571e9e467451828", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -31,7 +31,6 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::BodyCache;\n use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit, MonoItem};\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n@@ -375,8 +374,6 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let lldecl = cx.get_fn(instance);\n \n     let mir = cx.tcx().instance_mir(instance.def);\n-    // TODO(nashenas88) move this into instance_mir before merging PR\n-    let mir = BodyCache::new(mir);\n     mir::codegen_mir::<Bx>(cx, lldecl, mir, instance, sig);\n }\n "}, {"sha": "830b7da8c0373b23b16f86bb7828c434031af484", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -16,8 +16,8 @@ use syntax_pos::DUMMY_SP;\n use super::FunctionCx;\n use crate::traits::*;\n \n-pub fn non_ssa_locals<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    fx: &FunctionCx<'a, 'b, 'tcx, Bx>\n+pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    fx: &FunctionCx<'a, 'tcx, Bx>\n ) -> BitSet<mir::Local> {\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -56,17 +56,17 @@ pub fn non_ssa_locals<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     analyzer.non_ssa_locals\n }\n \n-struct LocalAnalyzer<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n-    fx: &'mir FunctionCx<'a, 'b, 'tcx, Bx>,\n+struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n+    fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitSet<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>,\n }\n \n-impl<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'b, 'tcx, Bx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'b, 'tcx, Bx>) -> Self {\n+impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>) -> Self {\n         let invalid_location =\n             mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n         let dominators = fx.mir.dominators();\n@@ -232,8 +232,8 @@ impl<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, '\n \n }\n \n-impl<'mir, 'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n-    for LocalAnalyzer<'mir, 'a, 'b, 'tcx, Bx>\n+impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n+    for LocalAnalyzer<'mir, 'a, 'tcx, Bx>\n {\n     fn visit_assign(&mut self,\n                     place: &mir::Place<'tcx>,"}, {"sha": "f661e7bba806fd5f7d9dace27fc4aaf17df72d43", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -33,19 +33,19 @@ struct TerminatorCodegenHelper<'a, 'tcx> {\n impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     /// Returns the associated funclet from `FunctionCx::funclets` for the\n     /// `funclet_bb` member if it is not `None`.\n-    fn funclet<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn funclet<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n-        fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n-    ) -> Option<&'d Bx::Funclet> {\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n+    ) -> Option<&'c Bx::Funclet> {\n         match self.funclet_bb {\n             Some(funcl) => fx.funclets[funcl].as_ref(),\n             None => None,\n         }\n     }\n \n-    fn lltarget<'b, 'c, 'd, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn lltarget<'b, 'c, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n-        fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n         target: mir::BasicBlock\n     ) -> (Bx::BasicBlock, bool) {\n         let span = self.terminator.source_info.span;\n@@ -63,9 +63,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     }\n \n     /// Create a basic block.\n-    fn llblock<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn llblock<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n-        fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n         target: mir::BasicBlock\n     ) -> Bx::BasicBlock {\n         let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n@@ -83,9 +83,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n         }\n     }\n \n-    fn funclet_br<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn funclet_br<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n-        fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n@@ -101,9 +101,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n \n     /// Call `fn_ptr` of `fn_abi` with the arguments `llargs`, the optional\n     /// return destination `destination` and the cleanup function `cleanup`.\n-    fn do_call<'d, 'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n+    fn do_call<'c, 'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &self,\n-        fx: &'d mut FunctionCx<'b, 'c, 'tcx, Bx>,\n+        fx: &'c mut FunctionCx<'b, 'tcx, Bx>,\n         bx: &mut Bx,\n         fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n         fn_ptr: Bx::Value,\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n     // a loop.\n     fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n         &self,\n-        mir: &mir::ReadOnlyBodyCache<'_, 'tcx>,\n+        mir: mir::ReadOnlyBodyCache<'_, 'tcx>,\n         bx: &mut Bx,\n         targets: &[mir::BasicBlock],\n     ) {\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n }\n \n /// Codegen implementations for some terminator variants.\n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Generates code for a `Resume` terminator.\n     fn codegen_resume_terminator<'c>(\n         &mut self,\n@@ -216,7 +216,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             let lltrue = helper.llblock(self, targets[0]);\n             let llfalse = helper.llblock(self, targets[1]);\n             if switch_ty == bx.tcx().types.bool {\n-                helper.maybe_sideeffect(&self.mir, &mut bx, targets.as_slice());\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n                 if let [0] = values[..] {\n                     bx.cond_br(discr.immediate(), llfalse, lltrue);\n@@ -230,11 +230,11 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 );\n                 let llval = bx.const_uint_big(switch_llty, values[0]);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n-                helper.maybe_sideeffect(&self.mir, &mut bx, targets.as_slice());\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n-            helper.maybe_sideeffect(&self.mir, &mut bx, targets.as_slice());\n+            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n             let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n@@ -330,7 +330,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return\n         }\n@@ -361,7 +361,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                  FnAbi::of_instance(&bx, drop_fn))\n             }\n         };\n-        helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n@@ -397,7 +397,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -408,7 +408,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n-        helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -493,7 +493,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n-                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -521,7 +521,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n-                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n@@ -553,7 +553,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n                 let llfn = bx.get_fn_addr(instance);\n \n                 if let Some((_, target)) = destination.as_ref() {\n-                    helper.maybe_sideeffect(&self.mir, &mut bx, &[*target]);\n+                    helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n                 }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n@@ -568,7 +568,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             } else {\n                 // a NOP\n                 let target = destination.as_ref().unwrap().1;\n-                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, destination.as_ref().unwrap().1)\n             }\n             return;\n@@ -682,7 +682,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             if let Some((_, target)) = *destination {\n-                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 bx.unreachable();\n@@ -776,21 +776,21 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n         };\n \n         if let Some((_, target)) = destination.as_ref() {\n-            helper.maybe_sideeffect(&self.mir, &mut bx, &[*target]);\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n         }\n         helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                        cleanup);\n     }\n }\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_block(\n         &mut self,\n         bb: mir::BasicBlock,\n     ) {\n         let mut bx = self.build_block(bb);\n-        let data = &self.mir[bb];\n+        let data = &self.mir.body()[bb];\n \n         debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n@@ -827,7 +827,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.maybe_sideeffect(&self.mir, &mut bx, &[target]);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "27891be6b82c5e45093cc7c9c6cac7c52c040cb8", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -9,7 +9,7 @@ use crate::mir::operand::OperandRef;\n \n use super::FunctionCx;\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn eval_mir_constant_to_operand(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "2a012cd2ed94307f663262b7940f041d2c215752", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnAbiExt};\n-use rustc::mir::{self, Body, BodyCache};\n+use rustc::mir::{self, Body, ReadOnlyBodyCache};\n use rustc_target::abi::call::{FnAbi, PassMode};\n use crate::base;\n use crate::traits::*;\n@@ -18,10 +18,10 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n-pub struct FunctionCx<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n+pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: &'b mir::ReadOnlyBodyCache<'a, 'tcx>,\n+    mir: mir::ReadOnlyBodyCache<'a, 'tcx>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n@@ -79,7 +79,7 @@ pub struct FunctionCx<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<&'a mir::VarDebugInfo<'tcx>>>>,\n }\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -122,7 +122,7 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     llfn: Bx::Function,\n-    mut mir: BodyCache<&'a Body<'tcx>>,\n+    mir: ReadOnlyBodyCache<'a, 'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n@@ -157,10 +157,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n     let mir_body = mir.body();\n-    let readonly_mir = mir.read_only();\n     let mut fx = FunctionCx {\n         instance,\n-        mir: &readonly_mir,\n+        mir,\n         llfn,\n         fn_abi,\n         cx,\n@@ -319,9 +318,9 @@ fn create_funclets<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n /// Produces, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    fx: &FunctionCx<'a, 'b, 'tcx, Bx>,\n+    fx: &FunctionCx<'a, 'tcx, Bx>,\n     memory_locals: &BitSet<mir::Local>,\n ) -> Vec<LocalRef<'tcx, Bx::Value>> {\n     let mut idx = 0;"}, {"sha": "310b8aeb4db09d3de5830959c55dae1f72f9fcd5", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -377,7 +377,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n     }\n }\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn maybe_codegen_consume_direct(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "281539277cb77c8576a4ba303c6d532db7b3f85a", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -435,7 +435,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n }\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "680c5b873b02e6d003378bed17c16844876397f0", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -18,7 +18,7 @@ use syntax::source_map::{DUMMY_SP, Span};\n \n use std::{u128, i128};\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_rvalue(\n         &mut self,\n         mut bx: Bx,\n@@ -695,7 +695,7 @@ impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(\n         &self,\n         rvalue: &mir::Rvalue<'tcx>,"}, {"sha": "0b82edea157902dac27eddf078ecc4c2521128e0", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -8,7 +8,7 @@ use crate::traits::*;\n \n use rustc_error_codes::*;\n \n-impl<'a, 'b, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'b, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_statement(\n         &mut self,\n         mut bx: Bx,"}, {"sha": "30dad03648c91861c3d754acacacd64bd96ea141", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -18,12 +18,11 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc::dep_graph::{self, DepNodeIndex};\n use rustc::middle::lang_items;\n-use rustc::mir::{self, interpret};\n+use rustc::mir::{self, BodyCache, interpret, Promoted};\n use rustc::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::mir::{Body, Promoted};\n use rustc::util::common::record_time;\n use rustc::util::captures::Captures;\n \n@@ -1080,7 +1079,7 @@ impl<'a, 'tcx> CrateMetadata {\n             self.root.per_def.mir.get(self, id).is_some()\n     }\n \n-    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n+    fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> BodyCache<'tcx> {\n         self.root.per_def.mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {\n@@ -1093,7 +1092,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> IndexVec<Promoted, Body<'tcx>> {\n+    ) -> IndexVec<Promoted, BodyCache<'tcx>> {\n         self.root.per_def.promoted_mir.get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n             .unwrap_or_else(|| {"}, {"sha": "fdf43f06eb10f65dcbb4b2606db21cf07acfb42f", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -276,8 +276,8 @@ define_per_def_tables! {\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n     inferred_outlives: Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>,\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    mir: Table<DefIndex, Lazy!(mir::BodyCache<'tcx>)>,\n+    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::BodyCache<'tcx>>)>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "d1af7461f4754131ca7ec7bdf85f7e24b8244028", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+        body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -123,7 +123,7 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'tcx>,\n-        body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+        body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>,\n     ) -> Self {\n@@ -139,7 +139,7 @@ impl<'tcx> BorrowSet<'tcx> {\n                 LocalsStateAtExit::build(locals_are_invalidated_at_exit, body_cache, move_data),\n         };\n \n-        for (block, block_data) in traversal::preorder(body_cache) {\n+        for (block, block_data) in traversal::preorder(&body_cache) {\n             visitor.visit_basic_block_data(block, block_data);\n         }\n "}, {"sha": "0170cc8b42abf62e982c8aec52e9dae89c4d5df8", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -102,7 +102,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n-    input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    input_promoted: &IndexVec<Promoted, BodyCache<'tcx>>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -162,14 +162,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n-    let mut body: Body<'tcx> = input_body.clone();\n+    let body: Body<'tcx> = input_body.clone();\n     let mut promoted = input_promoted.clone();\n-    let mut promoted_cache: IndexVec<Promoted, BodyCache<&mut Body<'tcx>>> = input_promoted.clone().iter_mut().map(|body| BodyCache::new(body)).collect();\n-    let mut body_cache = BodyCache::new(&mut body);\n+    let mut body_cache = BodyCache::new(body);\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body_cache, &mut promoted_cache);\n-    let body_cache = BodyCache::new(&body).read_only(); // no further changes\n-    let promoted: IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>> = promoted_cache.into_iter().map(|body_cache| body_cache.read_only()).collect();\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body_cache, &mut promoted);\n+    let body_cache = body_cache.read_only(); // no further changes\n+    let promoted: IndexVec<_, _> = promoted.iter().map(|body_cache| body_cache.read_only()).collect();\n \n     let location_table = &LocationTable::new(&body_cache);\n \n@@ -198,14 +197,14 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n-            tcx, &body_cache, locals_are_invalidated_at_exit, &mdpe.move_data));\n+            tcx, body_cache, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n         infcx,\n         def_id,\n         free_regions,\n-        &body_cache,\n+        body_cache,\n         &promoted,\n         &local_names,\n         &upvars,\n@@ -1338,7 +1337,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => bug!(\"temporary initialized in arguments\"),\n                         };\n \n-                        let bbd = &self.body_cache[loc.block];\n+                        let bbd = &self.body_cache.body()[loc.block];\n                         let stmt = &bbd.statements[loc.statement_index];\n                         debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n@@ -1860,7 +1859,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n-                                location, &this.body_cache,\n+                                location, this.body_cache,\n                             )\n                         }) {\n                             return;"}, {"sha": "feaa5fd3a5519fd73a87fb77d65140306ba0aa41", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -377,7 +377,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         },\n                     ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n-                        &self.body_cache,\n+                        self.body_cache,\n                         *local,\n                         local_decl,\n                         opt_ty_info,\n@@ -529,7 +529,7 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n     opt_ty_info: Option<Span>,"}, {"sha": "8d5466e545d528da09198acd1b21c4ff28d146dd", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -22,7 +22,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -41,7 +41,7 @@ pub(super) fn generate_invalidates<'tcx>(\n             body: body_cache.body(),\n             dominators,\n         };\n-        ig.visit_body(&body_cache);\n+        ig.visit_body(body_cache);\n     }\n }\n "}, {"sha": "bf11d348409ca9f2fa315fbf194a88256f3a49f3", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -55,8 +55,8 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_cache: &mut BodyCache<&mut Body<'tcx>>,\n-    promoted: &mut IndexVec<Promoted, BodyCache<&mut Body<'tcx>>>,\n+    body_cache: &mut BodyCache<'tcx>,\n+    promoted: &mut IndexVec<Promoted, BodyCache<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n@@ -158,7 +158,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     promoted_cache: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     local_names: &IndexVec<Local, Option<Symbol>>,\n     upvars: &[Upvar],\n@@ -181,7 +181,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     let universal_regions = Rc::new(universal_regions);\n \n-    let elements = &Rc::new(RegionValueElements::new(body_cache));\n+    let elements = &Rc::new(RegionValueElements::new(body_cache.body()));\n \n     // Run the MIR type-checker.\n     let MirTypeckResults {\n@@ -206,7 +206,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n-        populate_polonius_move_facts(all_facts, move_data, location_table, body_cache);\n+        populate_polonius_move_facts(all_facts, move_data, location_table, body_cache.body());\n     }\n \n     // Create the region inference context, taking ownership of the\n@@ -230,7 +230,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,\n-        body_cache,\n+        body_cache.body(),\n         borrow_set,\n     );\n \n@@ -239,7 +239,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         universal_regions,\n         placeholder_indices,\n         universal_region_relations,\n-        body_cache,\n+        body_cache.body(),\n         outlives_constraints,\n         member_constraints,\n         closure_bounds_mapping,\n@@ -284,21 +284,21 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, body_cache, local_names, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, body_cache.body(), local_names, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n         MirSource::item(def_id),\n-        body_cache,\n+        body_cache.body(),\n         &regioncx,\n         &closure_region_requirements,\n     );\n \n     // We also have a `#[rustc_nll]` annotation that causes us to dump\n     // information\n-    dump_annotation(infcx, body_cache, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n+    dump_annotation(infcx, body_cache.body(), def_id, &regioncx, &closure_region_requirements, errors_buffer);\n \n     (regioncx, polonius_output, closure_region_requirements)\n }"}, {"sha": "16d2eca8f20e48bdf069aee90d095bbfbcb5bc7a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -92,7 +92,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        body_cache: &ReadOnlyBodyCache<'_, '_>,\n+        body_cache: ReadOnlyBodyCache<'_, '_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {"}, {"sha": "882b825c5284e322a1c1e50e6926d363a0c86b6c", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::mir::{Body, BodyCache, Location, PlaceElem, Promoted};\n+use rustc::mir::{BodyCache, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc_index::vec::IndexVec;\n@@ -9,8 +9,8 @@ use rustc_index::vec::IndexVec;\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    body_cache: &mut BodyCache<&mut Body<'tcx>>,\n-    promoted: &mut IndexVec<Promoted, BodyCache<&mut Body<'tcx>>>,\n+    body_cache: &mut BodyCache<'tcx>,\n+    promoted: &mut IndexVec<Promoted, BodyCache<'tcx>>,\n ) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body_cache.arg_count);"}, {"sha": "0cd5dd8059495e407fdecc2b806948bba05d033a", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -60,7 +60,7 @@ impl LocalUseMap {\n     crate fn build(\n         live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n-        body_cache: &ReadOnlyBodyCache<'_, '_>,\n+        body_cache: ReadOnlyBodyCache<'_, '_>,\n     ) -> Self {\n         let nones = IndexVec::from_elem_n(None, body_cache.local_decls.len());\n         let mut local_use_map = LocalUseMap {"}, {"sha": "2dea6797ec7488f00b2564c0d3919460b2ad9818", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -28,7 +28,7 @@ mod trace;\n /// performed before\n pub(super) fn generate<'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -48,7 +48,7 @@ pub(super) fn generate<'tcx>(\n         let mut drop_used = Vec::new();\n         polonius::populate_access_facts(\n             typeck,\n-            &body_cache,\n+            body_cache,\n             location_table,\n             move_data,\n             &mut drop_used,"}, {"sha": "c17fbf0cdc9f89dc15c5532cb62b671475fe6853", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -97,7 +97,7 @@ fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty\n \n pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     location_table: &LocationTable,\n     move_data: &MoveData<'_>,\n     drop_used: &mut Vec<(Local, Location)>,"}, {"sha": "9a0392ab1d83676aefc7ccf6eba955d084361b22", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -32,7 +32,7 @@ use std::rc::Rc;\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -41,7 +41,7 @@ pub(super) fn trace(\n ) {\n     debug!(\"trace()\");\n \n-    let local_use_map = &LocalUseMap::build(&live_locals, elements, &body_cache);\n+    let local_use_map = &LocalUseMap::build(&live_locals, elements, body_cache);\n \n     let cx = LivenessContext {\n         typeck,\n@@ -71,7 +71,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     elements: &'me RegionValueElements,\n \n     /// MIR we are analyzing.\n-    body_cache: &'me ReadOnlyBodyCache<'me, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'me, 'tcx>,\n \n     /// Mapping to/from the various indices used for initialization tracking.\n     move_data: &'me MoveData<'tcx>,\n@@ -211,7 +211,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n \n             if self.use_live_at.insert(p) {\n-                self.cx.elements.push_predecessors(&self.cx.body_cache, p, &mut self.stack)\n+                self.cx.elements.push_predecessors(self.cx.body_cache, p, &mut self.stack)\n             }\n         }\n     }"}, {"sha": "92efd383c3c81b00a442fb551bd84d7d40f13615", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -115,7 +115,7 @@ mod relate_tys;\n pub(crate) fn type_check<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'_, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     promoted_cache: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n@@ -168,7 +168,7 @@ pub(crate) fn type_check<'tcx>(\n         &mut borrowck_context,\n         &universal_region_relations,\n         |mut cx| {\n-            cx.equate_inputs_and_outputs(body_cache, universal_regions, &normalized_inputs_and_output);\n+            cx.equate_inputs_and_outputs(body_cache.body(), universal_regions, &normalized_inputs_and_output);\n             liveness::generate(&mut cx, body_cache, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(cx.borrowck_context);\n@@ -185,7 +185,7 @@ fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_cache: &ReadOnlyBodyCache<'a, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'a, 'tcx>,\n     promoted_cache: &'a IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n@@ -195,7 +195,7 @@ fn type_check_internal<'a, 'tcx, R>(\n ) -> R where {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        body_cache,\n+        body_cache.body(),\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -204,14 +204,14 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body_cache, promoted_cache);\n+        let mut verifier = TypeVerifier::new(&mut checker, body_cache.body(), promoted_cache);\n         verifier.visit_body(body_cache);\n         verifier.errors_reported\n     };\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(body_cache);\n+        checker.typeck_mir(body_cache.body());\n     }\n \n     extra(&mut checker)\n@@ -385,7 +385,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_body(&mut self, body_cache: &ReadOnlyBodyCache<'_, 'tcx>) {\n+    fn visit_body(&mut self, body_cache: ReadOnlyBodyCache<'_, 'tcx>) {\n         self.sanitize_type(&\"return type\", body_cache.return_ty());\n         for local_decl in &body_cache.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n@@ -464,7 +464,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 match kind {\n                     StaticKind::Promoted(promoted, _) => {\n                         if !self.errors_reported {\n-                            let promoted_body_cache = &self.promoted_cache[*promoted];\n+                            let promoted_body_cache = self.promoted_cache[*promoted];\n                             self.sanitize_promoted(promoted_body_cache, location);\n \n                             let promoted_ty = promoted_body_cache.return_ty();\n@@ -535,7 +535,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         place_ty\n     }\n \n-    fn sanitize_promoted(&mut self, promoted_body_cache: &ReadOnlyBodyCache<'b, 'tcx>, location: Location) {\n+    fn sanitize_promoted(&mut self, promoted_body_cache: ReadOnlyBodyCache<'b, 'tcx>, location: Location) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location."}, {"sha": "27e6d803bd0abadbfd42294410e2ac9f7dc995c4", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -32,7 +32,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 never_initialized_mut_locals: &mut never_initialized_mut_locals,\n                 mbcx: self,\n             };\n-            visitor.visit_body(&visitor.mbcx.body_cache);\n+            visitor.visit_body(visitor.mbcx.body_cache);\n         }\n \n         // Take the union of the existed `used_mut` set with those variables we've found were"}, {"sha": "28b4c9fd09b37779af12befa4cfb0bba686d8a9b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -24,7 +24,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n+pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyCache<'_> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -196,7 +196,7 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n         lints::check(tcx, &body, def_id);\n \n-        body\n+        BodyCache::new(body)\n     })\n }\n "}, {"sha": "0a205be0c58deb542b9489ebf0d79b43b1765225", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -354,7 +354,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body) => body,\n+            Ok(body_cache) => body_cache.body(),\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n                     return Err(\n@@ -697,7 +697,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(\n-        |body| eval_body_using_ecx(&mut ecx, cid, body)\n+        |body_cache| eval_body_using_ecx(&mut ecx, cid, body_cache.body())\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.ptr.assert_ptr().alloc_id,"}, {"sha": "fc344f9b252598d8c86c47c87ee3b3019b25d778", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -75,19 +75,19 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n pub struct RequiresStorage<'mir, 'tcx> {\n-    body_cache: &'mir ReadOnlyBodyCache<'mir, 'tcx>,\n+    body_cache: ReadOnlyBodyCache<'mir, 'tcx>,\n     borrowed_locals:\n         RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n }\n \n impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n     pub fn new(\n-        body_cache: &'mir ReadOnlyBodyCache<'mir, 'tcx>,\n+        body_cache: ReadOnlyBodyCache<'mir, 'tcx>,\n         borrowed_locals: &'mir DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n     ) -> Self {\n         RequiresStorage {\n             body_cache,\n-            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, body_cache)),\n+            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, body_cache.body())),\n         }\n     }\n \n@@ -187,7 +187,7 @@ impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n             sets,\n             borrowed_locals: &self.borrowed_locals,\n         };\n-        visitor.visit_location(&self.body_cache, loc);\n+        visitor.visit_location(self.body_cache, loc);\n     }\n \n     /// Gen locals that are newly borrowed. This includes borrowing any part of"}, {"sha": "043ba09f52a9afdf6e43e82687dd94a8f03d43aa", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -292,7 +292,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n         promoted: Option<mir::Promoted>,\n-    ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n+    ) -> InterpResult<'tcx, mir::ReadOnlyBodyCache<'tcx, 'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if did.is_local()\n@@ -303,11 +303,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(&self.tcx.promoted_mir(did)[promoted]);\n+            return Ok(self.tcx.promoted_mir(did)[promoted].read_only());\n         }\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n-                Ok(self.tcx.optimized_mir(did))\n+                Ok(self.tcx.optimized_mir(did).read_only())\n             } else {\n                 throw_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },"}, {"sha": "ecfbe529b9566ab184467ca59ee606a12f120381", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -186,7 +186,7 @@ use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind, Instance};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::session::config::EntryFnType;\n-use rustc::mir::{self, BodyCache, Location, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, Location, PlaceBase, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::{MonoItem, InstantiationMode};\n use rustc::mir::interpret::{Scalar, GlobalId, GlobalAlloc, ErrorHandled};\n@@ -1248,15 +1248,15 @@ fn collect_neighbours<'tcx>(\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     debug!(\"collect_neighbours: {:?}\", instance.def_id());\n-    let body = tcx.instance_mir(instance.def);\n-    let body_cache = BodyCache::new(body).read_only();\n+    let body_cache = tcx.instance_mir(instance.def);\n+    let body = body_cache.body();\n \n     MirNeighborCollector {\n         tcx,\n         body: &body,\n         output,\n         param_substs: instance.substs,\n-    }.visit_body(&body_cache);\n+    }.visit_body(body_cache);\n }\n \n fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {"}, {"sha": "8f97a4e7f5c89c3e0d6536b5a6449ac2aa6b0624", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -26,7 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx BodyCache<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -113,7 +113,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n         }\n     };\n-    debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n+    debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result.body());\n \n     run_passes(tcx, &mut result, instance, None, MirPhase::Const, &[\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n@@ -123,7 +123,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         &add_call_guards::CriticalCallEdges,\n     ]);\n \n-    debug!(\"make_shim({:?}) = {:?}\", instance, result);\n+    debug!(\"make_shim({:?}) = {:?}\", instance, result.body());\n \n     tcx.arena.alloc(result)\n }\n@@ -164,7 +164,7 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>) -> Body<'tcx> {\n+fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>) -> BodyCache<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n@@ -202,7 +202,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n         sig.inputs().len(),\n         span);\n \n-    let mut body_cache = BodyCache::new(&mut body);\n+    let mut body_cache = BodyCache::new(body);\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n@@ -238,8 +238,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n         patch.apply(&mut body_cache);\n     }\n \n-    // TODO(pfaia) return owning body cache...\n-    body\n+    body_cache\n }\n \n fn new_body<'tcx>(\n@@ -317,7 +316,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n+fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> BodyCache<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let param_env = tcx.param_env(def_id);\n@@ -346,7 +345,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n         }\n     };\n \n-    builder.into_mir()\n+    BodyCache::new(builder.into_mir())\n }\n \n struct CloneShimBuilder<'tcx> {\n@@ -707,7 +706,7 @@ fn build_call_shim<'tcx>(\n     rcvr_adjustment: Adjustment,\n     call_kind: CallKind,\n     untuple_args: Option<&[Ty<'tcx>]>,\n-) -> Body<'tcx> {\n+) -> BodyCache<'tcx> {\n     debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n@@ -842,10 +841,10 @@ fn build_call_shim<'tcx>(\n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n     }\n-    body\n+    BodyCache::new(body)\n }\n \n-pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n+pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &BodyCache<'_> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span = tcx.hir().span_if_local(ctor_id)\n@@ -929,5 +928,5 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         |_, _| Ok(()),\n     );\n \n-    tcx.arena.alloc(body)\n+    tcx.arena.alloc(BodyCache::new(body))\n }"}, {"sha": "071ad002c169d8d10a160adcf2ba833778ccb386", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -31,22 +31,22 @@ pub use self::AddCallGuards::*;\n  */\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        self.add_call_guards(body);\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        self.add_call_guards(body_cache);\n     }\n }\n \n impl AddCallGuards {\n-    pub fn add_call_guards(&self, body: &mut Body<'_>) {\n+    pub fn add_call_guards(&self, body_cache: &mut BodyCache<'_>) {\n         let pred_count: IndexVec<_, _> =\n-            body.predecessors().iter().map(|ps| ps.len()).collect();\n+            body_cache.predecessors().iter().map(|ps| ps.len()).collect();\n \n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n-        let cur_len = body.basic_blocks().len();\n+        let cur_len = body_cache.basic_blocks().len();\n \n-        for block in body.basic_blocks_mut() {\n+        for block in body_cache.basic_blocks_mut() {\n             match block.terminator {\n                 Some(Terminator {\n                     kind: TerminatorKind::Call {\n@@ -78,6 +78,6 @@ impl AddCallGuards {\n \n         debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        body.basic_blocks_mut().extend(new_blocks);\n+        body_cache.basic_blocks_mut().extend(new_blocks);\n     }\n }"}, {"sha": "aebd632978ad1ad53e5f33fe0c4bfcf7e0447060", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -40,15 +40,15 @@ use crate::util;\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n-        add_moves_for_packed_drops(tcx, body, src.def_id());\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body_cache.span);\n+        add_moves_for_packed_drops(tcx, body_cache, src.def_id());\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, def_id: DefId) {\n-    let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n-    patch.apply(body);\n+pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>, def_id: DefId) {\n+    let patch = add_moves_for_packed_drops_patch(tcx, body_cache, def_id);\n+    patch.apply(body_cache);\n }\n \n fn add_moves_for_packed_drops_patch<'tcx>("}, {"sha": "25594ab20a91c8eab782717eec22847a2fe03c62", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -59,12 +59,12 @@ fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n }\n \n impl<'tcx> MirPass<'tcx> for AddRetag {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }\n-        let (span, arg_count) = (body.span, body.arg_count);\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+        let (span, arg_count) = (body_cache.span, body_cache.arg_count);\n+        let (basic_blocks, local_decls) = body_cache.basic_blocks_and_local_decls_mut();\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that."}, {"sha": "78628474bce97a3b1d499c14e48890f5aeb76723", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -528,7 +528,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n         hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n-    checker.visit_body(body);\n+    checker.visit_body(body.read_only());\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n     UnsafetyCheckResult {"}, {"sha": "3ea41816ebefe6da29d506174ed5de4b833fb7bf", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -16,7 +16,7 @@\n //! [`FakeRead`]: rustc::mir::StatementKind::FakeRead\n //! [`Nop`]: rustc::mir::StatementKind::Nop\n \n-use rustc::mir::{BorrowKind, Rvalue, Location, Body};\n+use rustc::mir::{BodyCache, BorrowKind, Rvalue, Location};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -29,9 +29,9 @@ pub struct DeleteNonCodegenStatements<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n-        delete.visit_body(body);\n+        delete.visit_body(body_cache);\n     }\n }\n "}, {"sha": "f79f375a7e8469bd172a93f23b6df9a4173ca8d6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -7,9 +7,10 @@ use std::cell::Cell;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n-    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n-    StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n-    BinOp, SourceScope, SourceScopeData, LocalDecl, BasicBlock, RETURN_PLACE,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Body, BodyCache, Operand, Local, UnOp,\n+    Rvalue. StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate,\n+    SourceInfo, BinOp, SourceScope, SourceScopeData, LocalDecl, BasicBlock, ReadOnlyBodyCache,\n+    RETURN_PLACE\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -41,7 +42,7 @@ const MAX_ALLOC_LIMIT: u64 = 1024;\n pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -76,28 +77,28 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n \n         let dummy_body =\n             &Body::new(\n-                body.basic_blocks().clone(),\n-                body.source_scopes.clone(),\n-                body.local_decls.clone(),\n+                body_cache.basic_blocks().clone(),\n+                body_cache.source_scopes.clone(),\n+                body_cache.local_decls.clone(),\n                 Default::default(),\n-                body.arg_count,\n+                body_cache.arg_count,\n                 Default::default(),\n                 tcx.def_span(source.def_id()),\n                 Default::default(),\n-                body.generator_kind,\n+                body_cache.generator_kind,\n             );\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = ConstPropagator::new(\n-            body,\n+            body_cache.read_only(),\n             dummy_body,\n             tcx,\n             source\n         );\n-        optimization_finder.visit_body(body);\n+        optimization_finder.visit_body(body_cache);\n \n         trace!(\"ConstProp done for {:?}\", source.def_id());\n     }\n@@ -284,7 +285,7 @@ impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n-        body: &Body<'tcx>,\n+        body_cache: ReadOnlyBodyCache<'mir, 'tcx>,\n         dummy_body: &'mir Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n@@ -293,7 +294,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id);\n         let span = tcx.def_span(def_id);\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n-        let can_const_prop = CanConstProp::check(body);\n+        let can_const_prop = CanConstProp::check(body_cache);\n \n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n \n@@ -325,9 +326,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             can_const_prop,\n             // FIXME(eddyb) avoid cloning these two fields more than once,\n             // by accessing them through `ecx` instead.\n-            source_scopes: body.source_scopes.clone(),\n+            source_scopes: body_cache.source_scopes.clone(),\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n-            local_decls: body.local_decls.clone(),\n+            local_decls: body_cache.local_decls.clone(),\n             ret: ret.map(Into::into),\n         }\n     }\n@@ -678,25 +679,25 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// returns true if `local` can be propagated\n-    fn check(body: &Body<'_>) -> IndexVec<Local, bool> {\n+    fn check(body_cache: ReadOnlyBodyCache<'_, '_>) -> IndexVec<Local, bool> {\n         let mut cpv = CanConstProp {\n-            can_const_prop: IndexVec::from_elem(true, &body.local_decls),\n-            found_assignment: IndexVec::from_elem(false, &body.local_decls),\n+            can_const_prop: IndexVec::from_elem(true, &body_cache.local_decls),\n+            found_assignment: IndexVec::from_elem(false, &body_cache.local_decls),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n             // cannot use args at all\n             // cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n-            let local_kind = body.local_kind(local);\n+            let local_kind = body_cache.local_kind(local);\n             *val = local_kind == LocalKind::Temp || local_kind == LocalKind::ReturnPointer;\n \n             if !*val {\n                 trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n             }\n         }\n-        cpv.visit_body(body);\n+        cpv.visit_body(body_cache);\n         cpv.can_const_prop\n     }\n }"}, {"sha": "637f4792029a23cf53981723766a9b44c8cb2115", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -19,7 +19,10 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::mir::{Constant, Local, LocalKind, Location, Place, Body, Operand, Rvalue, StatementKind};\n+use rustc::mir::{\n+    Constant, Local, LocalKind, Location, Place, Body, BodyCache, Operand, Rvalue,\n+    StatementKind\n+};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -28,23 +31,23 @@ use crate::util::def_use::DefUseAnalysis;\n pub struct CopyPropagation;\n \n impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n             return;\n         }\n \n-        let mut def_use_analysis = DefUseAnalysis::new(body);\n+        let mut def_use_analysis = DefUseAnalysis::new(body_cache);\n         loop {\n-            def_use_analysis.analyze(body);\n+            def_use_analysis.analyze(body_cache.read_only());\n \n-            if eliminate_self_assignments(body, &def_use_analysis) {\n-                def_use_analysis.analyze(body);\n+            if eliminate_self_assignments(body_cache, &def_use_analysis) {\n+                def_use_analysis.analyze(body_cache.read_only());\n             }\n \n             let mut changed = false;\n-            for dest_local in body.local_decls.indices() {\n+            for dest_local in body_cache.local_decls.indices() {\n                 debug!(\"considering destination local: {:?}\", dest_local);\n \n                 let action;\n@@ -71,15 +74,15 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                     // Conservatively gives up if the dest is an argument,\n                     // because there may be uses of the original argument value.\n-                    if body.local_kind(dest_local) == LocalKind::Arg {\n+                    if body_cache.local_kind(dest_local) == LocalKind::Arg {\n                         debug!(\"  Can't copy-propagate local: dest {:?} (argument)\",\n                             dest_local);\n                         continue;\n                     }\n                     let dest_place_def = dest_use_info.defs_not_including_drop().next().unwrap();\n                     location = dest_place_def.location;\n \n-                    let basic_block = &body[location.block];\n+                    let basic_block = &body_cache[location.block];\n                     let statement_index = location.statement_index;\n                     let statement = match basic_block.statements.get(statement_index) {\n                         Some(statement) => statement,\n@@ -97,7 +100,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                                     let maybe_action = match operand {\n                                         Operand::Copy(ref src_place) |\n                                         Operand::Move(ref src_place) => {\n-                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                            Action::local_copy(&body_cache, &def_use_analysis, src_place)\n                                         }\n                                         Operand::Constant(ref src_constant) => {\n                                             Action::constant(src_constant)\n@@ -127,7 +130,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                 }\n \n                 changed =\n-                    action.perform(body, &def_use_analysis, dest_local, location, tcx) || changed;\n+                    action.perform(body_cache, &def_use_analysis, dest_local, location, tcx) || changed;\n                 // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n                 // regenerating the chains.\n                 break\n@@ -242,7 +245,7 @@ impl<'tcx> Action<'tcx> {\n     }\n \n     fn perform(self,\n-               body: &mut Body<'tcx>,\n+               body_cache: &mut BodyCache<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n                location: Location,\n@@ -260,21 +263,21 @@ impl<'tcx> Action<'tcx> {\n                        src_local);\n                 for place_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        body.make_statement_nop(place_use.location)\n+                        body_cache.make_statement_nop(place_use.location)\n                     }\n                 }\n                 for place_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        body.make_statement_nop(place_use.location)\n+                        body_cache.make_statement_nop(place_use.location)\n                     }\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body_cache, src_local, tcx);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");\n-                body.make_statement_nop(location);\n+                body_cache.make_statement_nop(location);\n \n                 true\n             }\n@@ -288,7 +291,7 @@ impl<'tcx> Action<'tcx> {\n                 let dest_local_info = def_use_analysis.local_info(dest_local);\n                 for place_use in &dest_local_info.defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        body.make_statement_nop(place_use.location)\n+                        body_cache.make_statement_nop(place_use.location)\n                     }\n                 }\n \n@@ -297,7 +300,7 @@ impl<'tcx> Action<'tcx> {\n                                                                   src_constant,\n                                                                   tcx);\n                 for dest_place_use in &dest_local_info.defs_and_uses {\n-                    visitor.visit_location(body, dest_place_use.location)\n+                    visitor.visit_location(body_cache, dest_place_use.location)\n                 }\n \n                 // Zap the assignment instruction if we eliminated all the uses. We won't have been\n@@ -308,7 +311,7 @@ impl<'tcx> Action<'tcx> {\n                     debug!(\"  {} of {} use(s) replaced; deleting assignment\",\n                            visitor.uses_replaced,\n                            use_count);\n-                    body.make_statement_nop(location);\n+                    body_cache.make_statement_nop(location);\n                     true\n                 } else if visitor.uses_replaced == 0 {\n                     debug!(\"  No uses replaced; not deleting assignment\");"}, {"sha": "3d0bf6192dc4986a180f8284f9af9675c676f966", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -6,8 +6,8 @@ use crate::util::expand_aggregate;\n pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        let (basic_blocks, local_decls) = body_cache.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {"}, {"sha": "987f0fde2e379cdf86d5de1aca7d00faf826ad75", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n \n-use rustc::mir::Body;\n+use rustc::mir::{Body, BodyCache};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -18,7 +18,7 @@ impl<'tcx> MirPass<'tcx> for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut Body<'tcx>) {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body_cache: &mut BodyCache<'tcx>) {\n     }\n }\n "}, {"sha": "378d991025a8f7ea888f744d01ef385f47d1c33e", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -21,17 +21,17 @@ use syntax_pos::Span;\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        debug!(\"elaborate_drops({:?} @ {:?})\", src, body_cache.span);\n \n         let def_id = src.def_id();\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n-        let move_data = match MoveData::gather_moves(body, tcx) {\n+        let move_data = match MoveData::gather_moves(body_cache, tcx) {\n             Ok(move_data) => move_data,\n             Err(_) => bug!(\"No `move_errors` should be allowed in MIR borrowck\"),\n         };\n         let elaborate_patch = {\n-            let body = &*body;\n+            let body = &*body_cache;\n             let env = MoveDataParamEnv {\n                 move_data,\n                 param_env,\n@@ -56,7 +56,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 patch: MirPatch::new(body),\n             }.elaborate()\n         };\n-        elaborate_patch.apply(body);\n+        elaborate_patch.apply(body_cache);\n     }\n }\n "}, {"sha": "ff07f65d22c432c8ddc177e13ce2016deddc04c5", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -62,7 +62,7 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n pub struct EraseRegions;\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_body(body);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        EraseRegionsVisitor::new(tcx).visit_body(body_cache);\n     }\n }"}, {"sha": "503d24e56ae7ba058efcc62e878ed71e3b850605", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 108, "deletions": 107, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -378,9 +378,9 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n fn make_generator_state_argument_indirect<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n ) {\n-    let gen_ty = body.local_decls.raw[1].ty;\n+    let gen_ty = body_cache.local_decls.raw[1].ty;\n \n     let region = ty::ReFree(ty::FreeRegion {\n         scope: def_id,\n@@ -395,33 +395,33 @@ fn make_generator_state_argument_indirect<'tcx>(\n     });\n \n     // Replace the by value generator argument\n-    body.local_decls.raw[1].ty = ref_gen_ty;\n+    body_cache.local_decls.raw[1].ty = ref_gen_ty;\n \n     // Add a deref to accesses of the generator state\n-    DerefArgVisitor { tcx }.visit_body(body);\n+    DerefArgVisitor { tcx }.visit_body(body_cache);\n }\n \n-fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let ref_gen_ty = body.local_decls.raw[1].ty;\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+    let ref_gen_ty = body_cache.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n     let pin_adt_ref = tcx.adt_def(pin_did);\n     let substs = tcx.intern_substs(&[ref_gen_ty.into()]);\n     let pin_ref_gen_ty = tcx.mk_adt(pin_adt_ref, substs);\n \n     // Replace the by ref generator argument\n-    body.local_decls.raw[1].ty = pin_ref_gen_ty;\n+    body_cache.local_decls.raw[1].ty = pin_ref_gen_ty;\n \n     // Add the Pin field access to accesses of the generator state\n-    PinArgVisitor { ref_gen_ty, tcx }.visit_body(body);\n+    PinArgVisitor { ref_gen_ty, tcx }.visit_body(body_cache);\n }\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Local {\n-    let source_info = source_info(body);\n+    let source_info = source_info(body_cache);\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n@@ -431,15 +431,15 @@ fn replace_result_variable<'tcx>(\n         is_block_tail: None,\n         local_info: LocalInfo::Other\n     };\n-    let new_ret_local = Local::new(body.local_decls.len());\n-    body.local_decls.push(new_ret);\n-    body.local_decls.swap(RETURN_PLACE, new_ret_local);\n+    let new_ret_local = Local::new(body_cache.local_decls.len());\n+    body_cache.local_decls.push(new_ret);\n+    body_cache.local_decls.swap(RETURN_PLACE, new_ret_local);\n \n     RenameLocalVisitor {\n         from: RETURN_PLACE,\n         to: new_ret_local,\n         tcx,\n-    }.visit_body(body);\n+    }.visit_body(body_cache);\n \n     new_ret_local\n }\n@@ -481,12 +481,13 @@ struct LivenessInfo {\n \n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> LivenessInfo {\n-    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n     let def_id = source.def_id();\n+    let body = body_cache.body();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n@@ -498,8 +499,8 @@ fn locals_live_across_suspend_points(\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(BitSet::new_filled(body.local_decls.len()));\n-    ignored.visit_body(body);\n+    let mut ignored = StorageIgnored(BitSet::new_filled(body_cache.local_decls.len()));\n+    ignored.visit_body(body_cache);\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n@@ -511,16 +512,16 @@ fn locals_live_across_suspend_points(\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n+    let requires_storage_analysis = RequiresStorage::new(body_cache, &borrowed_locals_results);\n     let requires_storage_results =\n         do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n     let mut requires_storage_cursor = DataflowResultsCursor::new(&requires_storage_results, body);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n+    let mut live_locals = liveness::LiveVarSet::new_empty(body_cache.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n-        body,\n+        body_cache,\n     );\n     liveness::dump_mir(\n         tcx,\n@@ -533,7 +534,7 @@ fn locals_live_across_suspend_points(\n     let mut storage_liveness_map = FxHashMap::default();\n     let mut live_locals_at_suspension_points = Vec::new();\n \n-    for (block, data) in body.basic_blocks().iter_enumerated() {\n+    for (block, data) in body_cache.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n             let loc = Location {\n                 block: block,\n@@ -749,7 +750,7 @@ fn compute_layout<'tcx>(\n     upvars: &Vec<Ty<'tcx>>,\n     interior: Ty<'tcx>,\n     movable: bool,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n@@ -758,7 +759,7 @@ fn compute_layout<'tcx>(\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n         live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n-    } = locals_live_across_suspend_points(tcx, body, source, movable);\n+    } = locals_live_across_suspend_points(tcx, body_cache.read_only(), source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -768,7 +769,7 @@ fn compute_layout<'tcx>(\n         _ => bug!(),\n     };\n \n-    for (local, decl) in body.local_decls.iter_enumerated() {\n+    for (local, decl) in body_cache.local_decls.iter_enumerated() {\n         // Ignore locals which are internal or not live\n         if !live_locals.contains(local) || decl.internal {\n             continue;\n@@ -777,7 +778,7 @@ fn compute_layout<'tcx>(\n         // Sanity check that typeck knows about the type of locals which are\n         // live across a suspension point\n         if !allowed.contains(&decl.ty) && !allowed_upvars.contains(&decl.ty) {\n-            span_bug!(body.span,\n+            span_bug!(body_cache.span,\n                       \"Broken MIR: generator contains type {} in MIR, \\\n                        but typeck only knows about {}\",\n                       decl.ty,\n@@ -790,7 +791,7 @@ fn compute_layout<'tcx>(\n     let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n     for (idx, local) in live_locals.iter().enumerate() {\n         locals.push(local);\n-        tys.push(body.local_decls[local].ty);\n+        tys.push(body_cache.local_decls[local].ty);\n         debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n     }\n \n@@ -828,22 +829,22 @@ fn compute_layout<'tcx>(\n }\n \n fn insert_switch<'tcx>(\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     cases: Vec<(usize, BasicBlock)>,\n     transform: &TransformVisitor<'tcx>,\n     default: TerminatorKind<'tcx>,\n ) {\n-    let default_block = insert_term_block(body, default);\n-    let (assign, discr) = transform.get_discr(body);\n+    let default_block = insert_term_block(body_cache, default);\n+    let (assign, discr) = transform.get_discr(body_cache);\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Move(discr),\n         switch_ty: transform.discr_ty,\n         values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n         targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n     };\n \n-    let source_info = source_info(body);\n-    body.basic_blocks_mut().raw.insert(0, BasicBlockData {\n+    let source_info = source_info(body_cache);\n+    body_cache.basic_blocks_mut().raw.insert(0, BasicBlockData {\n         statements: vec![assign],\n         terminator: Some(Terminator {\n             source_info,\n@@ -852,14 +853,14 @@ fn insert_switch<'tcx>(\n         is_cleanup: false,\n     });\n \n-    let blocks = body.basic_blocks_mut().iter_mut();\n+    let blocks = body_cache.basic_blocks_mut().iter_mut();\n \n     for target in blocks.flat_map(|b| b.terminator_mut().successors_mut()) {\n         *target = BasicBlock::new(target.index() + 1);\n     }\n }\n \n-fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n+fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body_cache: &mut BodyCache<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -872,13 +873,13 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n     let gen = self_arg();\n \n     let mut elaborator = DropShimElaborator {\n-        body: body,\n-        patch: MirPatch::new(body),\n+        body: body_cache,\n+        patch: MirPatch::new(body_cache),\n         tcx,\n         param_env\n     };\n \n-    for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+    for (block, block_data) in body_cache.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n             Terminator {\n                 source_info,\n@@ -915,7 +916,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n             block,\n         );\n     }\n-    elaborator.patch.apply(body);\n+    elaborator.patch.apply(body_cache);\n }\n \n fn create_generator_drop_shim<'tcx>(\n@@ -924,31 +925,31 @@ fn create_generator_drop_shim<'tcx>(\n     def_id: DefId,\n     source: MirSource<'tcx>,\n     gen_ty: Ty<'tcx>,\n-    body: &Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     drop_clean: BasicBlock,\n-) -> Body<'tcx> {\n-    let mut body = body.clone();\n+) -> BodyCache<'tcx> {\n+    let mut body_cache = body_cache.clone();\n \n-    let source_info = source_info(&body);\n+    let source_info = source_info(body_cache.body());\n \n-    let mut cases = create_cases(&mut body, transform, |point| point.drop);\n+    let mut cases = create_cases(&mut body_cache, transform, |point| point.drop);\n \n     cases.insert(0, (UNRESUMED, drop_clean));\n \n     // The returned state and the poisoned state fall through to the default\n     // case which is just to return\n \n-    insert_switch(&mut body, cases, &transform, TerminatorKind::Return);\n+    insert_switch(&mut body_cache, cases, &transform, TerminatorKind::Return);\n \n-    for block in body.basic_blocks_mut() {\n+    for block in body_cache.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n         if let TerminatorKind::GeneratorDrop = *kind {\n             *kind = TerminatorKind::Return;\n         }\n     }\n \n     // Replace the return variable\n-    body.local_decls[RETURN_PLACE] = LocalDecl {\n+    body_cache.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_unit(),\n         user_ty: UserTypeProjections::none(),\n@@ -958,10 +959,10 @@ fn create_generator_drop_shim<'tcx>(\n         local_info: LocalInfo::Other\n     };\n \n-    make_generator_state_argument_indirect(tcx, def_id, &mut body);\n+    make_generator_state_argument_indirect(tcx, def_id, &mut body_cache);\n \n     // Change the generator argument from &mut to *mut\n-    body.local_decls[self_arg()] = LocalDecl {\n+    body_cache.local_decls[self_arg()] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n@@ -975,27 +976,27 @@ fn create_generator_drop_shim<'tcx>(\n     };\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type\n-        body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+        body_cache.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n             source_info,\n             kind: StatementKind::Retag(RetagKind::Raw, box Place::from(self_arg())),\n         })\n     }\n \n-    no_landing_pads(tcx, &mut body);\n+    no_landing_pads(tcx, &mut body_cache);\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function\n-    simplify::remove_dead_blocks(&mut body);\n+    simplify::remove_dead_blocks(&mut body_cache);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut body, |_, _| Ok(()) );\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut body_cache, |_, _| Ok(()) );\n \n-    body\n+    body_cache\n }\n \n-fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-    let term_block = BasicBlock::new(body.basic_blocks().len());\n-    let source_info = source_info(body);\n-    body.basic_blocks_mut().push(BasicBlockData {\n+fn insert_term_block<'tcx>(body_cache: &mut BodyCache<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+    let term_block = BasicBlock::new(body_cache.basic_blocks().len());\n+    let source_info = source_info(body_cache);\n+    body_cache.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -1008,13 +1009,13 @@ fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n \n fn insert_panic_block<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     message: AssertMessage<'tcx>,\n ) -> BasicBlock {\n-    let assert_block = BasicBlock::new(body.basic_blocks().len());\n+    let assert_block = BasicBlock::new(body_cache.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n-            span: body.span,\n+            span: body_cache.span,\n             user_ty: None,\n             literal: ty::Const::from_bool(tcx, false),\n         }),\n@@ -1024,8 +1025,8 @@ fn insert_panic_block<'tcx>(\n         cleanup: None,\n     };\n \n-    let source_info = source_info(body);\n-    body.basic_blocks_mut().push(BasicBlockData {\n+    let source_info = source_info(body_cache);\n+    body_cache.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -1042,18 +1043,18 @@ fn create_generator_resume_function<'tcx>(\n     transform: TransformVisitor<'tcx>,\n     def_id: DefId,\n     source: MirSource<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n ) {\n     // Poison the generator when it unwinds\n-    for block in body.basic_blocks_mut() {\n+    for block in body_cache.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n         if let &TerminatorKind::Resume = &block.terminator().kind {\n             block.statements.push(\n                 transform.set_discr(VariantIdx::new(POISONED), source_info));\n         }\n     }\n \n-    let mut cases = create_cases(body, &transform, |point| Some(point.resume));\n+    let mut cases = create_cases(body_cache, &transform, |point| Some(point.resume));\n \n     use rustc::mir::interpret::PanicInfo::{\n         ResumedAfterPanic,\n@@ -1067,25 +1068,25 @@ fn create_generator_resume_function<'tcx>(\n     let generator_kind = body.generator_kind.unwrap();\n     cases.insert(1, (RETURNED, insert_panic_block(\n         tcx,\n-        body,\n+        body_cache,\n         ResumedAfterReturn(generator_kind))));\n     cases.insert(2, (POISONED, insert_panic_block(\n         tcx,\n-        body,\n+        body_cache,\n         ResumedAfterPanic(generator_kind))));\n \n-    insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n+    insert_switch(body_cache, cases, &transform, TerminatorKind::Unreachable);\n \n-    make_generator_state_argument_indirect(tcx, def_id, body);\n-    make_generator_state_argument_pinned(tcx, body);\n+    make_generator_state_argument_indirect(tcx, def_id, body_cache);\n+    make_generator_state_argument_pinned(tcx, body_cache);\n \n-    no_landing_pads(tcx, body);\n+    no_landing_pads(tcx, body_cache);\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the drop part of the function\n-    simplify::remove_dead_blocks(body);\n+    simplify::remove_dead_blocks(body_cache);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, body, |_, _| Ok(()) );\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, body_cache, |_, _| Ok(()) );\n }\n \n fn source_info(body: &Body<'_>) -> SourceInfo {\n@@ -1095,18 +1096,18 @@ fn source_info(body: &Body<'_>) -> SourceInfo {\n     }\n }\n \n-fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n-    let return_block = insert_term_block(body, TerminatorKind::Return);\n+fn insert_clean_drop(body_cache: &mut BodyCache<'_>) -> BasicBlock {\n+    let return_block = insert_term_block(body_cache, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n-    let drop_clean = BasicBlock::new(body.basic_blocks().len());\n+    let drop_clean = BasicBlock::new(body_cache.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n         location: Place::from(self_arg()),\n         target: return_block,\n         unwind: None,\n     };\n-    let source_info = source_info(body);\n-    body.basic_blocks_mut().push(BasicBlockData {\n+    let source_info = source_info(body_cache);\n+    body_cache.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -1119,23 +1120,23 @@ fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n }\n \n fn create_cases<'tcx, F>(\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n     target: F,\n ) -> Vec<(usize, BasicBlock)>\n where\n     F: Fn(&SuspensionPoint) -> Option<BasicBlock>,\n {\n-    let source_info = source_info(body);\n+    let source_info = source_info(body_cache);\n \n     transform.suspension_points.iter().filter_map(|point| {\n         // Find the target for this suspension point, if applicable\n         target(point).map(|target| {\n-            let block = BasicBlock::new(body.basic_blocks().len());\n+            let block = BasicBlock::new(body_cache.basic_blocks().len());\n             let mut statements = Vec::new();\n \n             // Create StorageLive instructions for locals with live storage\n-            for i in 0..(body.local_decls.len()) {\n+            for i in 0..(body_cache.local_decls.len()) {\n                 let l = Local::new(i);\n                 if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n                     statements.push(Statement {\n@@ -1146,7 +1147,7 @@ where\n             }\n \n             // Then jump to the real target\n-            body.basic_blocks_mut().push(BasicBlockData {\n+            body_cache.basic_blocks_mut().push(BasicBlockData {\n                 statements,\n                 terminator: Some(Terminator {\n                     source_info,\n@@ -1163,20 +1164,20 @@ where\n }\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let yield_ty = if let Some(yield_ty) = body.yield_ty {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        let yield_ty = if let Some(yield_ty) = body_cache.yield_ty {\n             yield_ty\n         } else {\n             // This only applies to generators\n             return\n         };\n \n-        assert!(body.generator_drop.is_none());\n+        assert!(body_cache.generator_drop.is_none());\n \n         let def_id = source.def_id();\n \n         // The first argument is the generator type passed by value\n-        let gen_ty = body.local_decls.raw[1].ty;\n+        let gen_ty = body_cache.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n         let (upvars, interior, discr_ty, movable) = match gen_ty.kind {\n@@ -1195,13 +1196,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.intern_substs(&[\n             yield_ty.into(),\n-            body.return_ty().into(),\n+            body_cache.return_ty().into(),\n         ]);\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n-        let new_ret_local = replace_result_variable(ret_ty, body, tcx);\n+        let new_ret_local = replace_result_variable(ret_ty, body_cache, tcx);\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n@@ -1212,7 +1213,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             &upvars,\n             interior,\n             movable,\n-            body);\n+            body_cache);\n \n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n@@ -1228,40 +1229,40 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             new_ret_local,\n             discr_ty,\n         };\n-        transform.visit_body(body);\n+        transform.visit_body(body_cache);\n \n         // Update our MIR struct to reflect the changed we've made\n-        body.yield_ty = None;\n-        body.arg_count = 1;\n-        body.spread_arg = None;\n-        body.generator_layout = Some(layout);\n+        body_cache.yield_ty = None;\n+        body_cache.arg_count = 1;\n+        body_cache.spread_arg = None;\n+        body_cache.generator_layout = Some(layout);\n \n         // Insert `drop(generator_struct)` which is used to drop upvars for generators in\n         // the unresumed state.\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n-        let drop_clean = insert_clean_drop(body);\n+        let drop_clean = insert_clean_drop(body_cache);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, body, |_, _| Ok(()) );\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, body_cache, |_, _| Ok(()) );\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n-        elaborate_generator_drops(tcx, def_id, body);\n+        elaborate_generator_drops(tcx, def_id, body_cache);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, body, |_, _| Ok(()) );\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, body_cache, |_, _| Ok(()) );\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,\n-            &transform,\n-            def_id,\n-            source,\n-            gen_ty,\n-            &body,\n-            drop_clean);\n+                                                   &transform,\n+                                                   def_id,\n+                                                   source,\n+                                                   gen_ty,\n+                                                   body_cache,\n+                                                   drop_clean);\n \n-        body.generator_drop = Some(box drop_shim);\n+        body_cache.generator_drop = Some(box drop_shim);\n \n         // Create the Generator::resume function\n-        create_generator_resume_function(tcx, transform, def_id, source, body);\n+        create_generator_resume_function(tcx, transform, def_id, source, body_cache);\n     }\n }"}, {"sha": "c1c3d39bdc086bc5577b930f18d55e825c45af29", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -38,9 +38,9 @@ struct CallSite<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for Inline {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            Inliner { tcx, source }.run_pass(body);\n+            Inliner { tcx, source }.run_pass(body_cache);\n         }\n     }\n }\n@@ -51,7 +51,7 @@ struct Inliner<'tcx> {\n }\n \n impl Inliner<'tcx> {\n-    fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n+    fn run_pass(&self, caller_body_cache: &mut BodyCache<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n         // allow us to try and fetch the fully optimized MIR of a\n@@ -73,11 +73,11 @@ impl Inliner<'tcx> {\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure()\n             && self.source.promoted.is_none()\n         {\n-            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n+            for (bb, bb_data) in caller_body_cache.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) = self.get_valid_function_call(bb,\n-                                                                    bb_data,\n-                                                                    caller_body,\n-                                                                    param_env) {\n+                                                                     bb_data,\n+                                                                     caller_body_cache,\n+                                                                     param_env) {\n                     callsites.push_back(callsite);\n                 }\n             }\n@@ -127,19 +127,19 @@ impl Inliner<'tcx> {\n                     continue;\n                 };\n \n-                let start = caller_body.basic_blocks().len();\n+                let start = caller_body_cache.basic_blocks().len();\n                 debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-                if !self.inline_call(callsite, caller_body, callee_body) {\n+                if !self.inline_call(callsite, caller_body_cache, callee_body) {\n                     debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n                     continue;\n                 }\n                 debug!(\"attempting to inline callsite {:?} - success\", callsite);\n \n                 // Add callsites from inlined function\n-                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n+                for (bb, bb_data) in caller_body_cache.basic_blocks().iter_enumerated().skip(start) {\n                     if let Some(new_callsite) = self.get_valid_function_call(bb,\n                                                                              bb_data,\n-                                                                             caller_body,\n+                                                                             caller_body_cache,\n                                                                              param_env) {\n                         // Don't inline the same function multiple times.\n                         if callsite.callee != new_callsite.callee {\n@@ -160,8 +160,8 @@ impl Inliner<'tcx> {\n         // Simplify if we inlined anything.\n         if changed {\n             debug!(\"running simplify cfg on {:?}\", self.source);\n-            CfgSimplifier::new(caller_body).simplify();\n-            remove_dead_blocks(caller_body);\n+            CfgSimplifier::new(caller_body_cache).simplify();\n+            remove_dead_blocks(caller_body_cache);\n         }\n     }\n \n@@ -377,23 +377,23 @@ impl Inliner<'tcx> {\n \n     fn inline_call(&self,\n                    callsite: CallSite<'tcx>,\n-                   caller_body: &mut Body<'tcx>,\n-                   mut callee_body: Body<'tcx>) -> bool {\n+                   caller_body: &mut BodyCache<'tcx>,\n+                   mut callee_body_cache: BodyCache<'tcx>) -> bool {\n         let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n-                let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());\n+                let mut local_map = IndexVec::with_capacity(callee_body_cache.local_decls.len());\n+                let mut scope_map = IndexVec::with_capacity(callee_body_cache.source_scopes.len());\n \n-                for mut scope in callee_body.source_scopes.iter().cloned() {\n+                for mut scope in callee_body_cache.source_scopes.iter().cloned() {\n                     if scope.parent_scope.is_none() {\n                         scope.parent_scope = Some(callsite.location.scope);\n                         // FIXME(eddyb) is this really needed?\n                         // (also note that it's always overwritten below)\n-                        scope.span = callee_body.span;\n+                        scope.span = callee_body_cache.span;\n                     }\n \n                     // FIXME(eddyb) this doesn't seem right at all.\n@@ -405,8 +405,8 @@ impl Inliner<'tcx> {\n                     scope_map.push(idx);\n                 }\n \n-                for loc in callee_body.vars_and_temps_iter() {\n-                    let mut local = callee_body.local_decls[loc].clone();\n+                for loc in callee_body_cache.vars_and_temps_iter() {\n+                    let mut local = callee_body_cache.local_decls[loc].clone();\n \n                     local.source_info.scope =\n                         scope_map[local.source_info.scope];\n@@ -445,7 +445,7 @@ impl Inliner<'tcx> {\n                         BorrowKind::Mut { allow_two_phase_borrow: false },\n                         destination.0);\n \n-                    let ty = dest.ty(caller_body, self.tcx);\n+                    let ty = dest.ty(caller_body.body(), self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n@@ -486,7 +486,7 @@ impl Inliner<'tcx> {\n                     caller_body.var_debug_info.push(var_debug_info);\n                 }\n \n-                for (bb, mut block) in callee_body.basic_blocks_mut().drain_enumerated(..) {\n+                for (bb, mut block) in callee_body_cache.basic_blocks_mut().drain_enumerated(..) {\n                     integrator.visit_basic_block_data(bb, &mut block);\n                     caller_body.basic_blocks_mut().push(block);\n                 }"}, {"sha": "e466b0cb77b720fd3745732ad78851ac9feb8cb7", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -1,7 +1,8 @@\n //! Performs various peephole optimizations.\n \n use rustc::mir::{\n-    Constant, Location, Place, PlaceBase, PlaceRef, Body, Operand, ProjectionElem, Rvalue, Local\n+    Constant, Location, Place, PlaceBase, PlaceRef, Body, BodyCache, Operand, ProjectionElem,\n+    Rvalue, Local\n };\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{self, TyCtxt};\n@@ -13,7 +14,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -23,13 +24,13 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n-            let mut optimization_finder = OptimizationFinder::new(body, tcx);\n-            optimization_finder.visit_body(body);\n+            let mut optimization_finder = OptimizationFinder::new(body_cache, tcx);\n+            optimization_finder.visit_body(body_cache.read_only());\n             optimization_finder.optimizations\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n+        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body_cache);\n     }\n }\n "}, {"sha": "97c4efc08a375b666dede592552fe2f269a1eb69", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -1,7 +1,7 @@\n use crate::{build, shim};\n use rustc_index::vec::IndexVec;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::{Body, MirPhase, Promoted, ConstQualifs};\n+use rustc::mir::{BodyCache, MirPhase, Promoted, ConstQualifs};\n use rustc::ty::{TyCtxt, InstanceDef, TypeFoldable};\n use rustc::ty::query::Providers;\n use rustc::ty::steal::Steal;\n@@ -97,7 +97,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n+fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyCache<'_>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n@@ -144,12 +144,12 @@ pub trait MirPass<'tcx> {\n         default_name::<Self>()\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     instance: InstanceDef<'tcx>,\n     promoted: Option<Promoted>,\n     mir_phase: MirPhase,\n@@ -220,47 +220,47 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n     validator.qualifs_in_return_place().into()\n }\n \n-fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n+fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyCache<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n-    let mut body = tcx.mir_built(def_id).steal();\n-    run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Const, &[\n+    let mut body_cache = tcx.mir_built(def_id).steal();\n+    run_passes(tcx, &mut body_cache, InstanceDef::Item(def_id), None, MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n-    tcx.alloc_steal_mir(body)\n+    tcx.alloc_steal_mir(body_cache)\n }\n \n fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n+) -> (&'tcx Steal<BodyCache<'tcx>>, &'tcx Steal<IndexVec<Promoted, BodyCache<'tcx>>>) {\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n     let _ = tcx.mir_const_qualif(def_id);\n \n-    let mut body = tcx.mir_const(def_id).steal();\n+    let mut body_cache = tcx.mir_const(def_id).steal();\n     let promote_pass = promote_consts::PromoteTemps::default();\n-    run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n+    run_passes(tcx, &mut body_cache, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n         &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n \n     let promoted = promote_pass.promoted_fragments.into_inner();\n-    (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n+    (tcx.alloc_steal_mir(body_cache), tcx.alloc_steal_promoted(promoted))\n }\n \n fn run_optimization_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     def_id: DefId,\n     promoted: Option<Promoted>,\n ) {\n-    run_passes(tcx, body, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n+    run_passes(tcx, body_cache, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads::new(tcx),\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n@@ -318,7 +318,7 @@ fn run_optimization_passes<'tcx>(\n     ]);\n }\n \n-fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n+fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &BodyCache<'_> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const\n@@ -332,12 +332,12 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n     tcx.ensure().mir_borrowck(def_id);\n \n     let (body, _) = tcx.mir_validated(def_id);\n-    let mut body = body.steal();\n-    run_optimization_passes(tcx, &mut body, def_id, None);\n-    tcx.arena.alloc(body)\n+    let mut body_cache = body.steal();\n+    run_optimization_passes(tcx, &mut body_cache, def_id, None);\n+    tcx.arena.alloc(body_cache)\n }\n \n-fn promoted_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n+fn promoted_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx IndexVec<Promoted, BodyCache<'tcx>> {\n     if tcx.is_constructor(def_id) {\n         return tcx.intern_promoted(IndexVec::new());\n     }\n@@ -346,8 +346,8 @@ fn promoted_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx IndexVec<Promot\n     let (_, promoted) = tcx.mir_validated(def_id);\n     let mut promoted = promoted.steal();\n \n-    for (p, mut body) in promoted.iter_enumerated_mut() {\n-        run_optimization_passes(tcx, &mut body, def_id, Some(p));\n+    for (p, mut body_cache) in promoted.iter_enumerated_mut() {\n+        run_optimization_passes(tcx, &mut body_cache, def_id, Some(p));\n     }\n \n     tcx.intern_promoted(promoted)"}, {"sha": "07dd4120528ad4cc1f4fa2e09642a1625fda9b7a", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -17,14 +17,14 @@ impl<'tcx> NoLandingPads<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n-        NoLandingPads::new(tcx).visit_body(body);\n+        NoLandingPads::new(tcx).visit_body(body_cache);\n     }\n }\n "}, {"sha": "e409bb0842903df40d7fababc8970295928cd181", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -770,8 +770,8 @@ pub fn validate_candidates(\n \n struct Promoter<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    source: &'a mut Body<'tcx>,\n-    promoted: Body<'tcx>,\n+    source_cache: &'a mut BodyCache<'tcx>,\n+    promoted_cache: BodyCache<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n \n     /// If true, all nested temps are also kept in the\n@@ -781,8 +781,8 @@ struct Promoter<'a, 'tcx> {\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn new_block(&mut self) -> BasicBlock {\n-        let span = self.promoted.span;\n-        self.promoted.basic_blocks_mut().push(BasicBlockData {\n+        let span = self.promoted_cache.span;\n+        self.promoted_cache.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n                 source_info: SourceInfo {\n@@ -796,8 +796,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted.basic_blocks().last().unwrap();\n-        let data = &mut self.promoted[last];\n+        let last = self.promoted_cache.basic_blocks().last().unwrap();\n+        let data = &mut self.promoted_cache[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span,\n@@ -808,7 +808,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn is_temp_kind(&self, local: Local) -> bool {\n-        self.source.local_kind(local) == LocalKind::Temp\n+        self.source_cache.local_kind(local) == LocalKind::Temp\n     }\n \n     /// Copies the initialization of this temp to the\n@@ -823,18 +823,18 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 location\n             }\n             state =>  {\n-                span_bug!(self.promoted.span, \"{:?} not promotable: {:?}\",\n+                span_bug!(self.promoted_cache.span, \"{:?} not promotable: {:?}\",\n                           temp, state);\n             }\n         };\n         if !self.keep_original {\n             self.temps[temp] = TempState::PromotedOut;\n         }\n \n-        let num_stmts = self.source[loc.block].statements.len();\n-        let new_temp = self.promoted.local_decls.push(\n-            LocalDecl::new_temp(self.source.local_decls[temp].ty,\n-                                self.source.local_decls[temp].source_info.span));\n+        let num_stmts = self.source_cacje[loc.block].statements.len();\n+        let new_temp = self.promoted_cache.local_decls.push(\n+            LocalDecl::new_temp(self.source_cache.local_decls[temp].ty,\n+                                self.source_cache.local_decls[temp].source_info.span));\n \n         debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n                temp, loc, num_stmts, self.keep_original);\n@@ -843,7 +843,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // or duplicate it, depending on keep_original.\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n-                let statement = &mut self.source[loc.block].statements[loc.statement_index];\n+                let statement = &mut self.source_cache[loc.block].statements[loc.statement_index];\n                 let rhs = match statement.kind {\n                     StatementKind::Assign(box(_, ref mut rhs)) => rhs,\n                     _ => {\n@@ -864,9 +864,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.assign(new_temp, rvalue, source_info.span);\n         } else {\n             let terminator = if self.keep_original {\n-                self.source[loc.block].terminator().clone()\n+                self.source_cache[loc.block].terminator().clone()\n             } else {\n-                let terminator = self.source[loc.block].terminator_mut();\n+                let terminator = self.source_cache[loc.block].terminator_mut();\n                 let target = match terminator.kind {\n                     TerminatorKind::Call { destination: Some((_, target)), .. } => target,\n                     ref kind => {\n@@ -888,10 +888,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         self.visit_operand(arg, loc);\n                     }\n \n-                    let last = self.promoted.basic_blocks().last().unwrap();\n+                    let last = self.promoted_cache.basic_blocks().last().unwrap();\n                     let new_target = self.new_block();\n \n-                    *self.promoted[last].terminator_mut() = Terminator {\n+                    *self.promoted_cache[last].terminator_mut() = Terminator {\n                         kind: TerminatorKind::Call {\n                             func,\n                             args,\n@@ -919,9 +919,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         def_id: DefId,\n         candidate: Candidate,\n         next_promoted_id: usize,\n-    ) -> Option<Body<'tcx>> {\n+    ) -> Option<BodyCache<'tcx>> {\n         let mut operand = {\n-            let promoted = &mut self.promoted;\n+            let promoted = &mut self.promoted_cache;\n             let promoted_id = Promoted::new(next_promoted_id);\n             let tcx = self.tcx;\n             let mut promoted_place = |ty, span| {\n@@ -940,7 +940,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     projection: List::empty(),\n                 }\n             };\n-            let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n+            let (blocks, local_decls) = self.source_cache.basic_blocks_and_local_decls_mut();\n             match candidate {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n@@ -1004,9 +1004,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             statement_index: usize::MAX\n         });\n \n-        let span = self.promoted.span;\n+        let span = self.promoted_cache.span;\n         self.assign(RETURN_PLACE, Rvalue::Use(operand), span);\n-        Some(self.promoted)\n+        Some(self.promoted_cache)\n     }\n }\n \n@@ -1040,11 +1040,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n \n pub fn promote_candidates<'tcx>(\n     def_id: DefId,\n-    body: &mut Body<'tcx>,\n+    body_cache: &mut BodyCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n-) -> IndexVec<Promoted, Body<'tcx>> {\n+) -> IndexVec<Promoted, BodyCache<'tcx>> {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n \n@@ -1054,7 +1054,7 @@ pub fn promote_candidates<'tcx>(\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n-                match &body[block].statements[statement_index].kind {\n+                match &body_cache[block].statements[statement_index].kind {\n                     StatementKind::Assign(box(place, _)) => {\n                         if let Some(local) = place.as_local() {\n                             if temps[local] == TempState::PromotedOut {\n@@ -1072,25 +1072,26 @@ pub fn promote_candidates<'tcx>(\n \n         // Declare return place local so that `mir::Body::new` doesn't complain.\n         let initial_locals = iter::once(\n-            LocalDecl::new_return_place(tcx.types.never, body.span)\n+            LocalDecl::new_return_place(tcx.types.never, body_cache.span)\n         ).collect();\n \n         let promoter = Promoter {\n-            promoted: Body::new(\n+            promoted_cache: BodyCache::new(Body::new(\n                 IndexVec::new(),\n                 // FIXME: maybe try to filter this to avoid blowing up\n                 // memory usage?\n-                body.source_scopes.clone(),\n+                body_cache.source_scopes.clone(),\n+                body_cache.source_scope_local_data.clone(),\n                 initial_locals,\n                 IndexVec::new(),\n                 0,\n                 vec![],\n-                body.span,\n+                body_cache.span,\n                 vec![],\n-                body.generator_kind,\n-            ),\n+                body_cache.generator_kind,\n+            )),\n             tcx,\n-            source: body,\n+            source_cache: body_cache,\n             temps: &mut temps,\n             keep_original: false\n         };\n@@ -1103,7 +1104,7 @@ pub fn promote_candidates<'tcx>(\n \n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n-    for block in body.basic_blocks_mut() {\n+    for block in body_cache.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match &statement.kind {\n                 StatementKind::Assign(box(place, _)) => {"}, {"sha": "3a7d7d17f0693549575bdab537a4b8e770c5dfc8", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -9,18 +9,18 @@ use crate::util::patch::MirPatch;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n-    debug!(\"remove_noop_landing_pads({:?})\", body);\n+    debug!(\"remove_noop_landing_pads({:?})\", body_cache.body());\n \n-    RemoveNoopLandingPads.remove_nop_landing_pads(body)\n+    RemoveNoopLandingPads.remove_nop_landing_pads(body_cache)\n }\n \n impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        remove_noop_landing_pads(tcx, body);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        remove_noop_landing_pads(tcx, body_cache);\n     }\n }\n \n@@ -84,34 +84,34 @@ impl RemoveNoopLandingPads {\n         }\n     }\n \n-    fn remove_nop_landing_pads(&self, body: &mut Body<'_>) {\n+    fn remove_nop_landing_pads(&self, body_cache: &mut BodyCache<'_>) {\n         // make sure there's a single resume block\n         let resume_block = {\n-            let patch = MirPatch::new(body);\n+            let patch = MirPatch::new(body_cache);\n             let resume_block = patch.resume_block();\n-            patch.apply(body);\n+            patch.apply(body_cache);\n             resume_block\n         };\n         debug!(\"remove_noop_landing_pads: resume block is {:?}\", resume_block);\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitSet::new_empty(body.basic_blocks().len());\n+        let mut nop_landing_pads = BitSet::new_empty(body_cache.basic_blocks().len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B.\n-        let postorder: Vec<_> = traversal::postorder(body).map(|(bb, _)| bb).collect();\n+        let postorder: Vec<_> = traversal::postorder(body_cache).map(|(bb, _)| bb).collect();\n         for bb in postorder {\n             debug!(\"  processing {:?}\", bb);\n-            for target in body[bb].terminator_mut().successors_mut() {\n+            for target in body_cache[bb].terminator_mut().successors_mut() {\n                 if *target != resume_block && nop_landing_pads.contains(*target) {\n                     debug!(\"    folding noop jump to {:?} to resume block\", target);\n                     *target = resume_block;\n                     jumps_folded += 1;\n                 }\n             }\n \n-            match body[bb].terminator_mut().unwind_mut() {\n+            match body_cache[bb].terminator_mut().unwind_mut() {\n                 Some(unwind) => {\n                     if *unwind == Some(resume_block) {\n                         debug!(\"    removing noop landing pad\");\n@@ -123,7 +123,7 @@ impl RemoveNoopLandingPads {\n                 _ => {}\n             }\n \n-            let is_nop_landing_pad = self.is_nop_landing_pad(bb, body, &nop_landing_pads);\n+            let is_nop_landing_pad = self.is_nop_landing_pad(bb, body_cache, &nop_landing_pads);\n             if is_nop_landing_pad {\n                 nop_landing_pads.insert(bb);\n             }"}, {"sha": "87fcef69238d8e9d1735c7b9aa76609ee81ab5c7", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -5,7 +5,7 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{self, Body, Location, Local};\n+use rustc::mir::{self, Body, BodyCache, Location, Local};\n use rustc_index::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n \n@@ -26,7 +26,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl<'tcx> MirPass<'tcx> for SanityCheck {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -37,37 +37,37 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(body, tcx).unwrap();\n+        let move_data = MoveData::gather_moves(body_cache, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n+        let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n         let flow_inits =\n-            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n-                        MaybeInitializedPlaces::new(tcx, body, &mdpe),\n+            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n+                        MaybeInitializedPlaces::new(tcx, body_cache, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_uninits =\n-            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n-                        MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n+            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n+                        MaybeUninitializedPlaces::new(tcx, body_cache, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_def_inits =\n-            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n-                        DefinitelyInitializedPlaces::new(tcx, body, &mdpe),\n+            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n+                        DefinitelyInitializedPlaces::new(tcx, body_cache, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_indirectly_mut =\n-            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n-                        IndirectlyMutableLocals::new(tcx, body, param_env),\n+            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n+                        IndirectlyMutableLocals::new(tcx, body_cache, param_env),\n                         |_, i| DebugFormatted::new(&i));\n \n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n+            sanity_check_via_rustc_peek(tcx, body_cache.body(), def_id, &attributes, &flow_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n+            sanity_check_via_rustc_peek(tcx, body_cache.body(), def_id, &attributes, &flow_uninits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n+            sanity_check_via_rustc_peek(tcx, body_cache.body(), def_id, &attributes, &flow_def_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_indirectly_mut);\n+            sanity_check_via_rustc_peek(tcx, body_cache.body(), def_id, &attributes, &flow_indirectly_mut);\n         }\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");"}, {"sha": "75016cf1746c9f67290053ab9fdd889dc8e67090", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -43,22 +43,22 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(body: &mut Body<'_>) {\n-    CfgSimplifier::new(body).simplify();\n-    remove_dead_blocks(body);\n+pub fn simplify_cfg(body_cache: &mut BodyCache<'_>) {\n+    CfgSimplifier::new(body_cache).simplify();\n+    remove_dead_blocks(body_cache);\n \n     // FIXME: Should probably be moved into some kind of pass manager\n-    body.basic_blocks_mut().raw.shrink_to_fit();\n+    body_cache.basic_blocks_mut().raw.shrink_to_fit();\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n     fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n-        simplify_cfg(body);\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body_cache.body());\n+        simplify_cfg(body_cache);\n     }\n }\n \n@@ -68,22 +68,22 @@ pub struct CfgSimplifier<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n-    pub fn new(body: &'a mut Body<'tcx>) -> Self {\n-        let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n+    pub fn new(body_cache: &'a mut BodyCache<'tcx>) -> Self {\n+        let mut pred_count = IndexVec::from_elem(0u32, body_cache.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n         // dead blocks, which we don't want to.\n         pred_count[START_BLOCK] = 1;\n \n-        for (_, data) in traversal::preorder(body) {\n+        for (_, data) in traversal::preorder(body_cache) {\n             if let Some(ref term) = data.terminator {\n                 for &tgt in term.successors() {\n                     pred_count[tgt] += 1;\n                 }\n             }\n         }\n \n-        let basic_blocks = body.basic_blocks_mut();\n+        let basic_blocks = body_cache.basic_blocks_mut();\n \n         CfgSimplifier {\n             basic_blocks,\n@@ -260,13 +260,13 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(body: &mut Body<'_>) {\n-    let mut seen = BitSet::new_empty(body.basic_blocks().len());\n-    for (bb, _) in traversal::preorder(body) {\n+pub fn remove_dead_blocks(body_cache: &mut BodyCache<'_>) {\n+    let mut seen = BitSet::new_empty(body_cache.basic_blocks().len());\n+    for (bb, _) in traversal::preorder(body_cache.body()) {\n         seen.insert(bb.index());\n     }\n \n-    let basic_blocks = body.basic_blocks_mut();\n+    let basic_blocks = body_cache.basic_blocks_mut();\n \n     let num_blocks = basic_blocks.len();\n     let mut replacements : Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n@@ -293,27 +293,27 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         trace!(\"running SimplifyLocals on {:?}\", source);\n         let locals = {\n             let mut marker = DeclMarker {\n-                locals: BitSet::new_empty(body.local_decls.len()),\n-                body,\n+                locals: BitSet::new_empty(body_cache.local_decls.len()),\n+                body: body_cache,\n             };\n-            marker.visit_body(body);\n+            marker.visit_body(body_cache.read_only());\n             // Return pointer and arguments are always live\n             marker.locals.insert(RETURN_PLACE);\n-            for arg in body.args_iter() {\n+            for arg in body_cache.args_iter() {\n                 marker.locals.insert(arg);\n             }\n \n             marker.locals\n         };\n \n-        let map = make_local_map(&mut body.local_decls, locals);\n+        let map = make_local_map(&mut body_cache.local_decls, locals);\n         // Update references to all vars and tmps now\n-        LocalUpdater { map, tcx }.visit_body(body);\n-        body.local_decls.shrink_to_fit();\n+        LocalUpdater { map, tcx }.visit_body(body_cache);\n+        body_cache.local_decls.shrink_to_fit();\n     }\n }\n "}, {"sha": "df5d40484bf289ade3b45ae0d5bc521c0913924c", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -19,9 +19,9 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n         let param_env = tcx.param_env(src.def_id());\n-        for block in body.basic_blocks_mut() {\n+        for block in body_cache.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::SwitchInt {"}, {"sha": "d3fbfaf384a9150aa36d2d410ec79074124d7af1", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -37,14 +37,14 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl<'tcx> MirPass<'tcx> for UniformArrayMoveOut {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let mut patch = MirPatch::new(body);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        let mut patch = MirPatch::new(body_cache);\n         let param_env = tcx.param_env(src.def_id());\n         {\n-            let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx, param_env};\n-            visitor.visit_body(body);\n+            let mut visitor = UniformArrayMoveOutVisitor{ body: body_cache, patch: &mut patch, tcx, param_env};\n+            visitor.visit_body(body_cache.read_only());\n         }\n-        patch.apply(body);\n+        patch.apply(body_cache);\n     }\n }\n \n@@ -184,26 +184,26 @@ pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let mut patch = MirPatch::new(body);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+        let mut patch = MirPatch::new(body_cache);\n         let param_env = tcx.param_env(src.def_id());\n         {\n             let mut visitor = RestoreDataCollector {\n-                locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n+                locals_use: IndexVec::from_elem(LocalUse::new(), &body_cache.local_decls),\n                 candidates: vec![],\n             };\n-            visitor.visit_body(body);\n+            visitor.visit_body(body_cache.read_only());\n \n             for candidate in &visitor.candidates {\n-                let statement = &body[candidate.block].statements[candidate.statement_index];\n+                let statement = &body_cache[candidate.block].statements[candidate.statement_index];\n                 if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n                             if let Operand::Move(place) = item {\n                                 if let Some(local) = place.as_local() {\n                                     let local_use = &visitor.locals_use[local];\n                                     let opt_index_and_place =\n-                                        Self::try_get_item_source(local_use, body);\n+                                        Self::try_get_item_source(local_use, body_cache);\n                                     // each local should be used twice:\n                                     //  in assign and in aggregate statements\n                                     if local_use.use_count == 2 && opt_index_and_place.is_some() {\n@@ -218,7 +218,7 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n                             let src_ty =\n-                                Place::ty_from(src_place.base, src_place.projection, body, tcx).ty;\n+                                Place::ty_from(src_place.base, src_place.projection, body_cache.body(), tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.kind {\n                                 size_o.try_eval_usize(tcx, param_env)\n                             } else {\n@@ -232,7 +232,7 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n                 }\n             }\n         }\n-        patch.apply(body);\n+        patch.apply(body_cache);\n     }\n }\n "}, {"sha": "f94bea2002461d70422903bc00d436c4bf234426", "filename": "src/librustc_mir/util/collect_writes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -12,7 +12,7 @@ crate trait FindAssignments {\n impl<'a, 'tcx> FindAssignments for ReadOnlyBodyCache<'a, 'tcx>{\n     fn find_assignments(&self, local: Local) -> Vec<Location>{\n             let mut visitor = FindLocalAssignmentVisitor{ needle: local, locations: vec![]};\n-            visitor.visit_body(self);\n+            visitor.visit_body(*self);\n             visitor.locations\n     }\n }"}, {"sha": "256ba94af44d28520365d4e90f1ea2444a635047", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -30,7 +30,7 @@ impl DefUseAnalysis {\n         }\n     }\n \n-    pub fn analyze(&mut self, body_cache: &ReadOnlyBodyCache<'_, '_>) {\n+    pub fn analyze(&mut self, body_cache: ReadOnlyBodyCache<'_, '_>) {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n@@ -55,7 +55,7 @@ impl DefUseAnalysis {\n     fn mutate_defs_and_uses(\n         &self,\n         local: Local,\n-        body_cache: &mut BodyCache<&mut Body<'tcx>>,\n+        body_cache: &mut BodyCache<'tcx>,\n         new_local: Local,\n         tcx: TyCtxt<'tcx>,\n     ) {\n@@ -73,7 +73,7 @@ impl DefUseAnalysis {\n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          body_cache: &mut BodyCache<&mut Body<'tcx>>,\n+                                          body_cache: &mut BodyCache<'tcx>,\n                                           new_local: Local,\n                                           tcx: TyCtxt<'tcx>) {\n         self.mutate_defs_and_uses(local, body_cache, new_local, tcx)"}, {"sha": "37611561d58ef952590a95127a00f4ec29eecf85", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -57,7 +57,7 @@ pub struct LivenessResult {\n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n pub fn liveness_of_locals(\n-    body_cache: &ReadOnlyBodyCache<'_, '_>,\n+    body_cache: ReadOnlyBodyCache<'_, '_>,\n ) -> LivenessResult {\n     let num_live_vars = body_cache.local_decls.len();\n \n@@ -84,7 +84,7 @@ pub fn liveness_of_locals(\n     // order when cycles are present, but the overhead of computing the reverse CFG may outweigh\n     // any benefits. Benchmark this and find out.\n     let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body_cache.basic_blocks().len());\n-    for (bb, _) in traversal::postorder(body_cache) {\n+    for (bb, _) in traversal::postorder(body_cache.body()) {\n         dirty_queue.insert(bb);\n     }\n "}, {"sha": "6e110b1177f14898b3dc29d13ad3b40a002cd4d5", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b58d0a809b4994cd1a633ccb04e89234ff0b8/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=fc6b58d0a809b4994cd1a633ccb04e89234ff0b8", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.make_nop.push(loc);\n     }\n \n-    pub fn apply(self, body_cache: &mut BodyCache<&'_ mut Body<'tcx>>) {\n+    pub fn apply(self, body_cache: &mut BodyCache<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {\n             body_cache.make_statement_nop(loc);"}]}