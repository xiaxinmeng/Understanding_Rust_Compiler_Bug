{"sha": "a226f566002b58d618787f1121388b3df65be9c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMjZmNTY2MDAyYjU4ZDYxODc4N2YxMTIxMzg4YjNkZjY1YmU5YzI=", "commit": {"author": {"name": "Geoffroy Couprie", "email": "geo.couprie@gmail.com", "date": "2014-01-16T15:56:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-17T02:45:48Z"}, "message": "Implement Unix domain sockets in libnative", "tree": {"sha": "ae01e5bd7c2f749b34b8e4ed6740a271f00a7787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae01e5bd7c2f749b34b8e4ed6740a271f00a7787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a226f566002b58d618787f1121388b3df65be9c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a226f566002b58d618787f1121388b3df65be9c2", "html_url": "https://github.com/rust-lang/rust/commit/a226f566002b58d618787f1121388b3df65be9c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a226f566002b58d618787f1121388b3df65be9c2/comments", "author": {"login": "Geal", "id": 119296, "node_id": "MDQ6VXNlcjExOTI5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/119296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Geal", "html_url": "https://github.com/Geal", "followers_url": "https://api.github.com/users/Geal/followers", "following_url": "https://api.github.com/users/Geal/following{/other_user}", "gists_url": "https://api.github.com/users/Geal/gists{/gist_id}", "starred_url": "https://api.github.com/users/Geal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Geal/subscriptions", "organizations_url": "https://api.github.com/users/Geal/orgs", "repos_url": "https://api.github.com/users/Geal/repos", "events_url": "https://api.github.com/users/Geal/events{/privacy}", "received_events_url": "https://api.github.com/users/Geal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8489069b43191c5298f17430933b3b88fb79c3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8489069b43191c5298f17430933b3b88fb79c3c", "html_url": "https://github.com/rust-lang/rust/commit/c8489069b43191c5298f17430933b3b88fb79c3c"}], "stats": {"total": 389, "additions": 387, "deletions": 2}, "files": [{"sha": "dc134aa95feed9f1f5114ad2786f7fdf112c2f93", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=a226f566002b58d618787f1121388b3df65be9c2", "patch": "@@ -197,10 +197,10 @@ impl rtio::IoFactory for IoFactory {\n         net::UdpSocket::bind(addr).map(|u| ~u as ~RtioUdpSocket)\n     }\n     fn unix_bind(&mut self, _path: &CString) -> IoResult<~RtioUnixListener> {\n-        Err(unimpl())\n+        net::UnixListener::bind(_path).map(|s| ~s as ~RtioUnixListener)\n     }\n     fn unix_connect(&mut self, _path: &CString) -> IoResult<~RtioPipe> {\n-        Err(unimpl())\n+        net::UnixStream::connect(_path, libc::SOCK_STREAM).map(|s| ~s as ~RtioPipe)\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {"}, {"sha": "62753b66af05c0eb7f03c73be11c7bfd4b1864ec", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=a226f566002b58d618787f1121388b3df65be9c2", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::c_str::CString;\n use std::cast;\n use std::io::net::ip;\n use std::io;\n use std::libc;\n use std::mem;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n+use std::unstable::intrinsics;\n \n use super::{IoResult, retry};\n use super::file::keep_going;\n@@ -88,6 +90,30 @@ fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     }\n }\n \n+fn addr_to_sockaddr_un(addr: &CString) -> IoResult<(libc::sockaddr_storage, uint)> {\n+    // the sun_path length is limited to SUN_LEN (with null)\n+    if addr.len() > libc::sun_len -1 {\n+        return Err(io::IoError {\n+            kind: io::OtherIoError,\n+            desc: \"path must be smaller than SUN_LEN\",\n+            detail: None,\n+        })\n+    }\n+    unsafe {\n+        let storage: libc::sockaddr_storage = intrinsics::init();\n+        let s: *mut libc::sockaddr_un = cast::transmute(&storage);\n+        (*s).sun_family = libc::AF_UNIX as libc::sa_family_t;\n+        let mut i = 0;\n+        for c in addr.iter() {\n+          (*s).sun_path[i] = c;\n+          i += 1;\n+        }\n+\n+        let len = mem::size_of::<libc::sa_family_t>() + i + 1; //count the null terminator\n+        return Ok((storage, len));\n+    }\n+}\n+\n fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n@@ -101,6 +127,15 @@ fn socket(addr: ip::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     }\n }\n \n+fn unix_socket(ty: libc::c_int) -> IoResult<sock_t> {\n+    unsafe {\n+        match libc::socket(libc::AF_UNIX, ty, 0) {\n+            -1 => Err(super::last_error()),\n+            fd => Ok(fd)\n+        }\n+    }\n+}\n+\n fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                  payload: T) -> IoResult<()> {\n     unsafe {\n@@ -193,6 +228,24 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n+fn sockaddr_to_unix(storage: &libc::sockaddr_storage,\n+                    len: uint) -> IoResult<CString> {\n+    match storage.ss_family as libc::c_int {\n+        libc::AF_UNIX => {\n+            assert!(len as uint <= mem::size_of::<libc::sockaddr_un>());\n+            let storage: &libc::sockaddr_un = unsafe {\n+                cast::transmute(storage)\n+            };\n+            unsafe {\n+                Ok(CString::new(storage.sun_path.to_owned().as_ptr(), false))\n+            }\n+        }\n+        _ => {\n+            Err(io::standard_error(io::OtherIoError))\n+        }\n+    }\n+}\n+\n #[cfg(unix)]\n pub fn init() {}\n \n@@ -632,3 +685,306 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         ~UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket\n     }\n }\n+\n+\n+#[cfg(not(windows))]\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix\n+////////////////////////////////////////////////////////////////////////////////\n+\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixStream {\n+    priv fd: sock_t,\n+}\n+\n+impl UnixStream {\n+    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixStream> {\n+        unsafe {\n+            unix_socket(ty).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixStream{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match retry(|| {\n+                          libc::connect(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t)\n+                        }) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+}\n+\n+impl rtio::RtioPipe for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = retry(|| {\n+            unsafe {\n+                libc::recv(self.fd,\n+                           buf.as_ptr() as *mut libc::c_void,\n+                           buf.len() as wrlen,\n+                           0) as libc::c_int\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::send(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for UnixStream {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix Datagram\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixDatagram {\n+    priv fd: sock_t,\n+}\n+\n+impl UnixDatagram {\n+    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixDatagram> {\n+        unsafe {\n+            unix_socket(ty).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixDatagram{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match retry(|| {\n+                          libc::connect(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t)\n+                        }) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn bind(addr: &CString) -> IoResult<UnixDatagram> {\n+        unsafe {\n+            unix_socket(libc::SOCK_DGRAM).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixDatagram{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match libc::bind(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+}\n+\n+impl rtio::RtioPipe for UnixDatagram {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = retry(|| {\n+            unsafe {\n+                libc::recv(self.fd,\n+                           buf.as_ptr() as *mut libc::c_void,\n+                           buf.len() as wrlen,\n+                           0) as libc::c_int\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::send(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl rtio::RtioDatagramPipe for UnixDatagram {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, CString)> {\n+        unsafe {\n+            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let storagep = &mut storage as *mut libc::sockaddr_storage;\n+            let mut addrlen: libc::socklen_t =\n+                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+            let ret = retry(|| {\n+                libc::recvfrom(self.fd,\n+                               buf.as_ptr() as *mut libc::c_void,\n+                               buf.len() as msglen_t,\n+                               0,\n+                               storagep as *mut libc::sockaddr,\n+                               &mut addrlen) as libc::c_int\n+            });\n+            if ret < 0 { return Err(super::last_error()) }\n+            sockaddr_to_unix(&storage, addrlen as uint).and_then(|addr| {\n+                Ok((ret as uint, addr))\n+            })\n+        }\n+    }\n+\n+    fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> {\n+        match addr_to_sockaddr_un(dst) {\n+            Err(e)         => Err(e),\n+            Ok((dst, len)) => {\n+                let dstp = &dst as *libc::sockaddr_storage;\n+                unsafe {\n+                    let ret = retry(|| {\n+                        libc::sendto(self.fd,\n+                                     buf.as_ptr() as *libc::c_void,\n+                                     buf.len() as msglen_t,\n+                                     0,\n+                                     dstp as *libc::sockaddr,\n+                                     len as libc::socklen_t) as libc::c_int\n+                    });\n+                    match ret {\n+                        -1 => Err(super::last_error()),\n+                        n if n as uint != buf.len() => {\n+                            Err(io::IoError {\n+                                kind: io::OtherIoError,\n+                                desc: \"couldn't send entire packet at once\",\n+                                detail: None,\n+                            })\n+                        }\n+                        _ => Ok(())\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for UnixDatagram {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix Listener\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixListener {\n+    priv fd: sock_t,\n+}\n+\n+impl UnixListener {\n+    pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n+        unsafe {\n+            unix_socket(libc::SOCK_STREAM).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixListener{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match libc::bind(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n+        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n+            -1 => Err(super::last_error()),\n+            _ => Ok(UnixAcceptor { listener: self })\n+        }\n+    }\n+}\n+\n+impl rtio::RtioUnixListener for UnixListener {\n+    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor> {\n+        self.native_listen(128).map(|a| ~a as ~rtio::RtioUnixAcceptor)\n+    }\n+}\n+\n+impl Drop for UnixListener {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+\n+pub struct UnixAcceptor {\n+    priv listener: UnixListener,\n+}\n+\n+impl UnixAcceptor {\n+    pub fn fd(&self) -> sock_t { self.listener.fd }\n+\n+    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+        unsafe {\n+            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let storagep = &mut storage as *mut libc::sockaddr_storage;\n+            let size = mem::size_of::<libc::sockaddr_storage>();\n+            let mut size = size as libc::socklen_t;\n+            match retry(|| {\n+                libc::accept(self.fd(),\n+                             storagep as *mut libc::sockaddr,\n+                             &mut size as *mut libc::socklen_t) as libc::c_int\n+            }) as sock_t {\n+                -1 => Err(super::last_error()),\n+                fd => Ok(UnixStream { fd: fd })\n+            }\n+        }\n+    }\n+}\n+\n+impl rtio::RtioUnixAcceptor for UnixAcceptor {\n+    fn accept(&mut self) -> IoResult<~rtio::RtioPipe> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioPipe)\n+    }\n+}\n+\n+"}, {"sha": "c42a8896053120a2fcb5636befe4ea35547299ea", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=a226f566002b58d618787f1121388b3df65be9c2", "patch": "@@ -269,6 +269,7 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n \n+                pub static sun_len:uint = 108;\n                 pub type socklen_t = u32;\n                 pub type sa_family_t = u16;\n                 pub type in_port_t = u16;\n@@ -319,6 +320,10 @@ pub mod types {\n                     ai_canonname: *c_char,\n                     ai_next: *addrinfo\n                 }\n+                pub struct sockaddr_un {\n+                    sun_family: sa_family_t,\n+                    sun_path: [c_char, ..108]\n+                }\n             }\n         }\n \n@@ -636,6 +641,7 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n \n+                pub static sun_len:uint = 104;\n                 pub type socklen_t = u32;\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n@@ -691,6 +697,11 @@ pub mod types {\n                     ai_addr: *sockaddr,\n                     ai_next: *addrinfo\n                 }\n+                pub struct sockaddr_un {\n+                    sun_len: u8,\n+                    sun_family: sa_family_t,\n+                    sun_path: [c_char, ..104]\n+                }\n             }\n         }\n \n@@ -833,6 +844,7 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n \n+                pub static sun_len:uint = 108;\n                 pub type SOCKET = c_uint;\n                 pub type socklen_t = c_int;\n                 pub type sa_family_t = u16;\n@@ -884,6 +896,10 @@ pub mod types {\n                     ai_addr: *sockaddr,\n                     ai_next: *addrinfo\n                 }\n+                pub struct sockaddr_un {\n+                    sun_family: sa_family_t,\n+                    sun_path: [c_char, ..108]\n+                }\n             }\n         }\n \n@@ -1197,6 +1213,7 @@ pub mod types {\n             pub mod bsd44 {\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint};\n \n+                pub static sun_len:uint = 104;\n                 pub type socklen_t = c_int;\n                 pub type sa_family_t = u8;\n                 pub type in_port_t = u16;\n@@ -1252,6 +1269,11 @@ pub mod types {\n                     ai_addr: *sockaddr,\n                     ai_next: *addrinfo\n                 }\n+                pub struct sockaddr_un {\n+                    sun_len: u8,\n+                    sun_family: sa_family_t,\n+                    sun_path: [c_char, ..104]\n+                }\n             }\n         }\n \n@@ -2310,6 +2332,7 @@ pub mod consts {\n             pub static MADV_UNMERGEABLE : c_int = 13;\n             pub static MADV_HWPOISON : c_int = 100;\n \n+            pub static AF_UNIX: c_int = 1;\n             pub static AF_INET: c_int = 2;\n             pub static AF_INET6: c_int = 10;\n             pub static SOCK_STREAM: c_int = 1;\n@@ -3137,6 +3160,7 @@ pub mod consts {\n             pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n             pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n \n+            pub static AF_UNIX: c_int = 1;\n             pub static AF_INET: c_int = 2;\n             pub static AF_INET6: c_int = 30;\n             pub static SOCK_STREAM: c_int = 1;"}, {"sha": "578ace2ba86a0379d244aef9771cdd9981807021", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a226f566002b58d618787f1121388b3df65be9c2/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=a226f566002b58d618787f1121388b3df65be9c2", "patch": "@@ -260,6 +260,11 @@ pub trait RtioPipe {\n     fn clone(&self) -> ~RtioPipe;\n }\n \n+pub trait RtioDatagramPipe : RtioPipe {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, CString), IoError>;\n+    fn sendto(&mut self, buf: &[u8], dst: &CString) -> Result<(), IoError>;\n+}\n+\n pub trait RtioUnixListener {\n     fn listen(~self) -> Result<~RtioUnixAcceptor, IoError>;\n }"}]}