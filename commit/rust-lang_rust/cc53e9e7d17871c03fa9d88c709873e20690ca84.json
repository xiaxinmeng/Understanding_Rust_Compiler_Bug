{"sha": "cc53e9e7d17871c03fa9d88c709873e20690ca84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNTNlOWU3ZDE3ODcxYzAzZmE5ZDg4YzcwOTg3M2UyMDY5MGNhODQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-05T17:03:55Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-05T17:03:55Z"}, "message": "Merge #437\n\n437: refactor goto defenition r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "9021f6b236ce24d19a7a419c9f8c9c08c9ff08f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9021f6b236ce24d19a7a419c9f8c9c08c9ff08f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc53e9e7d17871c03fa9d88c709873e20690ca84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc53e9e7d17871c03fa9d88c709873e20690ca84", "html_url": "https://github.com/rust-lang/rust/commit/cc53e9e7d17871c03fa9d88c709873e20690ca84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc53e9e7d17871c03fa9d88c709873e20690ca84/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2a19d699eb594c4929215a24df333f87fd41881a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a19d699eb594c4929215a24df333f87fd41881a", "html_url": "https://github.com/rust-lang/rust/commit/2a19d699eb594c4929215a24df333f87fd41881a"}, {"sha": "ee461a211195b093269ead477f01fcf63f20cf34", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee461a211195b093269ead477f01fcf63f20cf34", "html_url": "https://github.com/rust-lang/rust/commit/ee461a211195b093269ead477f01fcf63f20cf34"}], "stats": {"total": 350, "additions": 138, "deletions": 212}, "files": [{"sha": "e37421f8dc7ee257caf493239c6ce596f9fdb9d1", "filename": "crates/ra_analysis/src/goto_defenition.rs", "status": "modified", "additions": 121, "deletions": 56, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs?ref=cc53e9e7d17871c03fa9d88c709873e20690ca84", "patch": "@@ -1,73 +1,138 @@\n-use ra_db::FileId;\n-use ra_syntax::ast;\n+use ra_db::{FileId, Cancelable, SyntaxDatabase};\n+use ra_syntax::{TextRange, AstNode, ast, SyntaxKind::{NAME, MODULE}};\n \n-use crate::db::RootDatabase;\n+use ra_editor::find_node_at_offset;\n \n-pub fn goto_defenition(db: &RootDatabase, position: FilePosition,\n+use crate::{FilePosition, NavigationTarget, db::RootDatabase};\n+\n+pub(crate) fn goto_defenition(\n+    db: &RootDatabase,\n+    position: FilePosition,\n ) -> Cancelable<Option<Vec<NavigationTarget>>> {\n     let file = db.source_file(position.file_id);\n     let syntax = file.syntax();\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        return Ok(Some(reference_defenition(db, position.file_id, name_ref)));\n+        return Ok(Some(reference_defenition(db, position.file_id, name_ref)?));\n     }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset)  {\n-        return Ok(Some(name_defenition(db, position.file_idname)));\n+    if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n+        return name_defenition(db, position.file_id, name);\n     }\n     Ok(None)\n }\n \n-fn reference_defenition(db: &RootDatabase, file_id: FileId, name_ref: ast::NameRef) -> Cancelable<Vec<Nav>> {\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        let mut rr = ReferenceResolution::new(name_ref.syntax().range());\n-        if let Some(fn_descr) =\n-            source_binder::function_from_child_node(self, position.file_id, name_ref.syntax())?\n-        {\n-            let scope = fn_descr.scopes(self);\n-            // First try to resolve the symbol locally\n-            if let Some(entry) = scope.resolve_local_name(name_ref) {\n-                rr.resolves_to.push(NavigationTarget {\n-                    file_id: position.file_id,\n-                    name: entry.name().to_string().into(),\n-                    range: entry.ptr().range(),\n-                    kind: NAME,\n-                    ptr: None,\n-                });\n-                return Ok(Some(rr));\n+pub(crate) fn reference_defenition(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name_ref: ast::NameRef,\n+) -> Cancelable<Vec<NavigationTarget>> {\n+    if let Some(fn_descr) =\n+        hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())?\n+    {\n+        let scope = fn_descr.scopes(db);\n+        // First try to resolve the symbol locally\n+        if let Some(entry) = scope.resolve_local_name(name_ref) {\n+            let nav = NavigationTarget {\n+                file_id,\n+                name: entry.name().to_string().into(),\n+                range: entry.ptr().range(),\n+                kind: NAME,\n+                ptr: None,\n             };\n-        }\n-        // If that fails try the index based approach.\n-        rr.resolves_to.extend(\n-            self.index_resolve(name_ref)?\n-                .into_iter()\n-                .map(NavigationTarget::from_symbol),\n-        );\n-        return Ok(Some(rr));\n+            return Ok(vec![nav]);\n+        };\n     }\n-        if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-            let mut rr = ReferenceResolution::new(name.syntax().range());\n-            if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n-                if module.has_semi() {\n-                    if let Some(child_module) =\n-                        source_binder::module_from_declaration(self, position.file_id, module)?\n-                    {\n-                        let file_id = child_module.file_id();\n-                        let name = match child_module.name() {\n-                            Some(name) => name.to_string().into(),\n-                            None => \"\".into(),\n-                        };\n-                        let symbol = NavigationTarget {\n-                            file_id,\n-                            name,\n-                            range: TextRange::offset_len(0.into(), 0.into()),\n-                            kind: MODULE,\n-                            ptr: None,\n-                        };\n-                        rr.resolves_to.push(symbol);\n-                        return Ok(Some(rr));\n-                    }\n-                }\n+    // If that fails try the index based approach.\n+    let navs = db\n+        .index_resolve(name_ref)?\n+        .into_iter()\n+        .map(NavigationTarget::from_symbol)\n+        .collect();\n+    Ok(navs)\n+}\n+\n+fn name_defenition(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name: ast::Name,\n+) -> Cancelable<Option<Vec<NavigationTarget>>> {\n+    if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n+        if module.has_semi() {\n+            if let Some(child_module) =\n+                hir::source_binder::module_from_declaration(db, file_id, module)?\n+            {\n+                let file_id = child_module.file_id();\n+                let name = match child_module.name() {\n+                    Some(name) => name.to_string().into(),\n+                    None => \"\".into(),\n+                };\n+                let nav = NavigationTarget {\n+                    file_id,\n+                    name,\n+                    range: TextRange::offset_len(0.into(), 0.into()),\n+                    kind: MODULE,\n+                    ptr: None,\n+                };\n+                return Ok(Some(vec![nav]));\n             }\n         }\n-        Ok(None)\n+    }\n+    Ok(None)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::assert_eq_dbg;\n+    use crate::mock_analysis::analysis_and_position;\n \n+    #[test]\n+    fn goto_defenition_works_in_items() {\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            struct Foo;\n+            enum E { X(Foo<|>) }\n+            \",\n+        );\n+\n+        let symbols = analysis.goto_defenition(pos).unwrap().unwrap();\n+        assert_eq_dbg(\n+            r#\"[NavigationTarget { file_id: FileId(1), name: \"Foo\",\n+                                   kind: STRUCT_DEF, range: [0; 11),\n+                                   ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\"#,\n+            &symbols,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_defenition_works_for_module_declaration() {\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod <|>foo;\n+            //- /foo.rs\n+            // empty\n+        \",\n+        );\n+\n+        let symbols = analysis.goto_defenition(pos).unwrap().unwrap();\n+        assert_eq_dbg(\n+            r#\"[NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\"#,\n+            &symbols,\n+        );\n+\n+        let (analysis, pos) = analysis_and_position(\n+            \"\n+            //- /lib.rs\n+            mod <|>foo;\n+            //- /foo/mod.rs\n+            // empty\n+        \",\n+        );\n+\n+        let symbols = analysis.goto_defenition(pos).unwrap().unwrap();\n+        assert_eq_dbg(\n+            r#\"[NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\"#,\n+            &symbols,\n+        );\n+    }\n }"}, {"sha": "758de376e30bad891e050f4775bb05ed0607bfcc", "filename": "crates/ra_analysis/src/hover.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=cc53e9e7d17871c03fa9d88c709873e20690ca84", "patch": "@@ -1,4 +1,5 @@\n use ra_db::{Cancelable, SyntaxDatabase};\n+use ra_editor::find_node_at_offset;\n use ra_syntax::{\n     AstNode, SyntaxNode,\n     ast::{self, NameOwner},\n@@ -11,18 +12,18 @@ pub(crate) fn hover(\n     db: &RootDatabase,\n     position: FilePosition,\n ) -> Cancelable<Option<RangeInfo<String>>> {\n+    let file = db.source_file(position.file_id);\n     let mut res = Vec::new();\n-    let range = if let Some(rr) = db.approximately_resolve_symbol(position)? {\n-        for nav in rr.resolves_to {\n+    let range = if let Some(name_ref) =\n+        find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset)\n+    {\n+        let navs = crate::goto_defenition::reference_defenition(db, position.file_id, name_ref)?;\n+        for nav in navs {\n             res.extend(doc_text_for(db, nav)?)\n         }\n-        rr.reference_range\n+        name_ref.syntax().range()\n     } else {\n-        let file = db.source_file(position.file_id);\n-        let expr: ast::Expr = ctry!(ra_editor::find_node_at_offset(\n-            file.syntax(),\n-            position.offset\n-        ));\n+        let expr: ast::Expr = ctry!(find_node_at_offset(file.syntax(), position.offset));\n         let frange = FileRange {\n             file_id: position.file_id,\n             range: expr.syntax().range(),"}, {"sha": "6ab3c5476b8d598759ac9ea4f51bdd8a62f65a35", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=cc53e9e7d17871c03fa9d88c709873e20690ca84", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     AnalysisChange,\n     Cancelable, NavigationTarget,\n     CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n-    Query, ReferenceResolution, RootChange, SourceChange, SourceFileEdit,\n+    Query, RootChange, SourceChange, SourceFileEdit,\n     symbol_index::{LibrarySymbolsQuery, FileSymbol},\n };\n \n@@ -139,66 +139,6 @@ impl db::RootDatabase {\n     pub(crate) fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.crate_graph().crate_root(crate_id)\n     }\n-    pub(crate) fn approximately_resolve_symbol(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<ReferenceResolution>> {\n-        let file = self.source_file(position.file_id);\n-        let syntax = file.syntax();\n-        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-            let mut rr = ReferenceResolution::new(name_ref.syntax().range());\n-            if let Some(fn_descr) =\n-                source_binder::function_from_child_node(self, position.file_id, name_ref.syntax())?\n-            {\n-                let scope = fn_descr.scopes(self);\n-                // First try to resolve the symbol locally\n-                if let Some(entry) = scope.resolve_local_name(name_ref) {\n-                    rr.resolves_to.push(NavigationTarget {\n-                        file_id: position.file_id,\n-                        name: entry.name().to_string().into(),\n-                        range: entry.ptr().range(),\n-                        kind: NAME,\n-                        ptr: None,\n-                    });\n-                    return Ok(Some(rr));\n-                };\n-            }\n-            // If that fails try the index based approach.\n-            rr.resolves_to.extend(\n-                self.index_resolve(name_ref)?\n-                    .into_iter()\n-                    .map(NavigationTarget::from_symbol),\n-            );\n-            return Ok(Some(rr));\n-        }\n-        if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-            let mut rr = ReferenceResolution::new(name.syntax().range());\n-            if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n-                if module.has_semi() {\n-                    if let Some(child_module) =\n-                        source_binder::module_from_declaration(self, position.file_id, module)?\n-                    {\n-                        let file_id = child_module.file_id();\n-                        let name = match child_module.name() {\n-                            Some(name) => name.to_string().into(),\n-                            None => \"\".into(),\n-                        };\n-                        let symbol = NavigationTarget {\n-                            file_id,\n-                            name,\n-                            range: TextRange::offset_len(0.into(), 0.into()),\n-                            kind: MODULE,\n-                            ptr: None,\n-                        };\n-                        rr.resolves_to.push(symbol);\n-                        return Ok(Some(rr));\n-                    }\n-                }\n-            }\n-        }\n-        Ok(None)\n-    }\n-\n     pub(crate) fn find_all_refs(\n         &self,\n         position: FilePosition,\n@@ -416,7 +356,7 @@ impl db::RootDatabase {\n             .collect::<Vec<_>>();\n         Ok(res)\n     }\n-    fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<FileSymbol>> {\n+    pub(crate) fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<FileSymbol>> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n         query.exact();"}, {"sha": "4d895b004454abf2d12bdba0b0d944f526e36d41", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=cc53e9e7d17871c03fa9d88c709873e20690ca84", "patch": "@@ -15,6 +15,7 @@ macro_rules! ctry {\n mod db;\n mod imp;\n mod completion;\n+mod goto_defenition;\n mod symbol_index;\n pub mod mock_analysis;\n mod runnables;\n@@ -273,26 +274,6 @@ impl<T> RangeInfo<T> {\n     }\n }\n \n-/// Result of \"goto def\" query.\n-#[derive(Debug)]\n-pub struct ReferenceResolution {\n-    /// The range of the reference itself. Client does not know what constitutes\n-    /// a reference, it handles us only the offset. It's helpful to tell the\n-    /// client where the reference was.\n-    pub reference_range: TextRange,\n-    /// What this reference resolves to.\n-    pub resolves_to: Vec<NavigationTarget>,\n-}\n-\n-impl ReferenceResolution {\n-    fn new(reference_range: TextRange) -> ReferenceResolution {\n-        ReferenceResolution {\n-            reference_range,\n-            resolves_to: Vec::new(),\n-        }\n-    }\n-}\n-\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug, Default)]\n pub struct AnalysisHost {\n@@ -392,12 +373,11 @@ impl Analysis {\n             .collect();\n         Ok(res)\n     }\n-    /// Resolves reference to definition, but does not gurantee correctness.\n-    pub fn approximately_resolve_symbol(\n+    pub fn goto_defenition(\n         &self,\n         position: FilePosition,\n-    ) -> Cancelable<Option<ReferenceResolution>> {\n-        self.db.approximately_resolve_symbol(position)\n+    ) -> Cancelable<Option<Vec<NavigationTarget>>> {\n+        goto_defenition::goto_defenition(&*self.db, position)\n     }\n     /// Finds all usages of the reference at point.\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {"}, {"sha": "e15035304bac4ecdf117d2e77912fecd65cd8b7c", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=cc53e9e7d17871c03fa9d88c709873e20690ca84", "patch": "@@ -14,65 +14,6 @@ fn get_signature(text: &str) -> (FnSignatureInfo, Option<usize>) {\n     analysis.resolve_callable(position).unwrap().unwrap()\n }\n \n-#[test]\n-fn approximate_resolve_works_in_items() {\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        struct Foo;\n-        enum E { X(Foo<|>) }\n-    \",\n-    );\n-\n-    let symbols = analysis.approximately_resolve_symbol(pos).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"ReferenceResolution {\n-            reference_range: [23; 26),\n-            resolves_to: [NavigationTarget { file_id: FileId(1), name: \"Foo\", kind: STRUCT_DEF, range: [0; 11), ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\n-        }\"#,\n-        &symbols,\n-    );\n-}\n-\n-#[test]\n-fn test_resolve_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod <|>foo;\n-        //- /foo.rs\n-        // empty\n-    \",\n-    );\n-\n-    let symbols = analysis.approximately_resolve_symbol(pos).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"ReferenceResolution {\n-            reference_range: [4; 7),\n-            resolves_to: [NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\n-        }\"#,\n-        &symbols,\n-    );\n-\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod <|>foo;\n-        //- /foo/mod.rs\n-        // empty\n-    \",\n-    );\n-\n-    let symbols = analysis.approximately_resolve_symbol(pos).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"ReferenceResolution {\n-            reference_range: [4; 7),\n-            resolves_to: [NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\n-        }\"#,\n-        &symbols,\n-    );\n-}\n-\n #[test]\n fn test_unresolved_module_diagnostic() {\n     let (analysis, file_id) = single_file(\"mod foo;\");"}, {"sha": "1baed73ade86fb7c7780b46a19c008ce9fff3000", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc53e9e7d17871c03fa9d88c709873e20690ca84/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=cc53e9e7d17871c03fa9d88c709873e20690ca84", "patch": "@@ -207,12 +207,11 @@ pub fn handle_goto_definition(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n     let position = params.try_conv_with(&world)?;\n-    let rr = match world.analysis().approximately_resolve_symbol(position)? {\n+    let navs = match world.analysis().goto_defenition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = rr\n-        .resolves_to\n+    let res = navs\n         .into_iter()\n         .map(|nav| nav.try_conv_with(&world))\n         .collect::<Result<Vec<_>>>()?;"}]}