{"sha": "aeef8cee2904cc52e00fc34bcd370c38e8615fa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZWY4Y2VlMjkwNGNjNTJlMDBmYzM0YmNkMzcwYzM4ZTg2MTVmYTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-03T21:03:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-03T21:03:07Z"}, "message": "Add load_non_structural and use it.", "tree": {"sha": "626ac38edc1754eb5a87ffe04a6ed6a08d9a746b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/626ac38edc1754eb5a87ffe04a6ed6a08d9a746b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeef8cee2904cc52e00fc34bcd370c38e8615fa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeef8cee2904cc52e00fc34bcd370c38e8615fa8", "html_url": "https://github.com/rust-lang/rust/commit/aeef8cee2904cc52e00fc34bcd370c38e8615fa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeef8cee2904cc52e00fc34bcd370c38e8615fa8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5347cac92d0d44b5f1ca2f3b742a3786b62335d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5347cac92d0d44b5f1ca2f3b742a3786b62335d7", "html_url": "https://github.com/rust-lang/rust/commit/5347cac92d0d44b5f1ca2f3b742a3786b62335d7"}], "stats": {"total": 36, "additions": 27, "deletions": 9}, "files": [{"sha": "2b4bec0c7ab26066a57ab5440216efb31a98838e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aeef8cee2904cc52e00fc34bcd370c38e8615fa8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeef8cee2904cc52e00fc34bcd370c38e8615fa8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=aeef8cee2904cc52e00fc34bcd370c38e8615fa8", "patch": "@@ -553,15 +553,19 @@ fn iter_structural_ty(@block_ctxt cx,\n             let int i = 0;\n             for (@typeck.ty arg in args) {\n                 auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n-                r = f(r.bcx, elt, arg);\n+                r = f(r.bcx,\n+                      load_non_structural(r.bcx, elt, arg),\n+                      arg);\n                 i += 1;\n             }\n         }\n         case (typeck.ty_rec(?fields)) {\n             let int i = 0;\n             for (typeck.field fld in fields) {\n                 auto llfld = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n-                r = f(r.bcx, llfld, fld.ty);\n+                r = f(r.bcx,\n+                      load_non_structural(r.bcx, llfld, fld.ty),\n+                      fld.ty);\n                 i += 1;\n             }\n         }\n@@ -608,15 +612,18 @@ fn iter_structural_ty(@block_ctxt cx,\n                                                      C_int(i as int));\n                         auto llvar = variant_cx.build.GEP(v, vals);\n \n-                        auto fn_ty = typeck.ann_to_type(variants.(i).ann); \n+                        auto fn_ty = typeck.ann_to_type(variants.(i).ann);\n                         alt (fn_ty.struct) {\n                             case (typeck.ty_fn(?args, _)) {\n                                 auto j = 0u;\n                                 for (typeck.arg a in args) {\n                                     auto idx = vec(C_int(0), C_int(j as int));\n                                     auto llfp = variant_cx.build.GEP(llvar,\n                                                                      idx);\n-                                    auto llfld = variant_cx.build.Load(llfp);\n+                                    auto llfld =\n+                                        load_non_structural(variant_cx,\n+                                                            llfp, a.ty);\n+\n                                     auto res = f(variant_cx, llfld, a.ty);\n                                     variant_cx = res.bcx;\n                                     j += 1u;\n@@ -1483,17 +1490,28 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         case (_) {\n             auto t = typeck.expr_ty(e);\n             auto sub = trans_lval(cx, e);\n-            if (sub._1 && ! typeck.type_is_structural(t)) {\n-                ret res(sub._0.bcx, cx.build.Load(sub._0.val));\n-            } else {\n-                ret sub._0;\n-            }\n+            ret res(sub._0.bcx,\n+                    load_non_structural(sub._0.bcx, sub._0.val, t));\n         }\n     }\n     cx.fcx.ccx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;\n }\n \n+// We pass structural values around the compiler \"by pointer\" and\n+// non-structural values \"by value\". This function selects whether\n+// to load a pointer or pass it.\n+\n+fn load_non_structural(@block_ctxt cx,\n+                       ValueRef v,\n+                       @typeck.ty t) -> ValueRef {\n+    if (typeck.type_is_structural(t)) {\n+        ret v;\n+    } else {\n+        ret cx.build.Load(v);\n+    }\n+}\n+\n impure fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, _)) {"}]}