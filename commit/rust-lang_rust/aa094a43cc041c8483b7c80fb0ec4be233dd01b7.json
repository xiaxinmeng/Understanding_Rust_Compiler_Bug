{"sha": "aa094a43cc041c8483b7c80fb0ec4be233dd01b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDk0YTQzY2MwNDFjODQ4M2I3YzgwZmIwZWM0YmUyMzNkZDAxYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-01T18:25:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-01T18:25:19Z"}, "message": "Auto merge of #51163 - Amanieu:hashmap_layout, r=SimonSapin\n\nSimplify HashMap layout calculation by using Layout\n\n`RawTable` uses a single allocation to hold both the array of hashes and the array of key/value pairs. This PR changes `RawTable` to use `Layout` when calculating the amount of memory to allocate instead of performing the calculation manually.\n\nr? @SimonSapin", "tree": {"sha": "dcf48d2463372afcb0b04b99bce3c365ad8dbb8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcf48d2463372afcb0b04b99bce3c365ad8dbb8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa094a43cc041c8483b7c80fb0ec4be233dd01b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa094a43cc041c8483b7c80fb0ec4be233dd01b7", "html_url": "https://github.com/rust-lang/rust/commit/aa094a43cc041c8483b7c80fb0ec4be233dd01b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa094a43cc041c8483b7c80fb0ec4be233dd01b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "747e655010dd200b4faef1db0910f6097920b58e", "url": "https://api.github.com/repos/rust-lang/rust/commits/747e655010dd200b4faef1db0910f6097920b58e", "html_url": "https://github.com/rust-lang/rust/commit/747e655010dd200b4faef1db0910f6097920b58e"}, {"sha": "c6bebf4554692c07ff96c8395f8aeddb09443708", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bebf4554692c07ff96c8395f8aeddb09443708", "html_url": "https://github.com/rust-lang/rust/commit/c6bebf4554692c07ff96c8395f8aeddb09443708"}], "stats": {"total": 128, "additions": 21, "deletions": 107}, "files": [{"sha": "6172a98bca6116dc1a42b1cab46d89c9df7fc837", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa094a43cc041c8483b7c80fb0ec4be233dd01b7/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa094a43cc041c8483b7c80fb0ec4be233dd01b7/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=aa094a43cc041c8483b7c80fb0ec4be233dd01b7", "patch": "@@ -392,6 +392,14 @@ impl From<AllocErr> for CollectionAllocErr {\n     }\n }\n \n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+impl From<LayoutErr> for CollectionAllocErr {\n+    #[inline]\n+    fn from(_: LayoutErr) -> Self {\n+        CollectionAllocErr::CapacityOverflow\n+    }\n+}\n+\n /// A memory allocator that can be registered to be the one backing `std::alloc::Global`\n /// though the `#[global_allocator]` attributes.\n pub unsafe trait GlobalAlloc {"}, {"sha": "c62a409ac02c9a635faa827fb5899fd8ba87f5bf", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 13, "deletions": 107, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/aa094a43cc041c8483b7c80fb0ec4be233dd01b7/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa094a43cc041c8483b7c80fb0ec4be233dd01b7/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=aa094a43cc041c8483b7c80fb0ec4be233dd01b7", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::{Global, Alloc, Layout, CollectionAllocErr, oom};\n-use cmp;\n+use alloc::{Global, Alloc, Layout, LayoutErr, CollectionAllocErr, oom};\n use hash::{BuildHasher, Hash, Hasher};\n use marker;\n-use mem::{align_of, size_of, needs_drop};\n+use mem::{size_of, needs_drop};\n use mem;\n use ops::{Deref, DerefMut};\n use ptr::{self, Unique, NonNull};\n@@ -651,64 +650,12 @@ impl<K, V, M> GapThenFull<K, V, M>\n     }\n }\n \n-\n-/// Rounds up to a multiple of a power of two. Returns the closest multiple\n-/// of `target_alignment` that is higher or equal to `unrounded`.\n-///\n-/// # Panics\n-///\n-/// Panics if `target_alignment` is not a power of two.\n-#[inline]\n-fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n-    assert!(target_alignment.is_power_of_two());\n-    (unrounded + target_alignment - 1) & !(target_alignment - 1)\n-}\n-\n-#[test]\n-fn test_rounding() {\n-    assert_eq!(round_up_to_next(0, 4), 0);\n-    assert_eq!(round_up_to_next(1, 4), 4);\n-    assert_eq!(round_up_to_next(2, 4), 4);\n-    assert_eq!(round_up_to_next(3, 4), 4);\n-    assert_eq!(round_up_to_next(4, 4), 4);\n-    assert_eq!(round_up_to_next(5, 4), 8);\n-}\n-\n-// Returns a tuple of (pairs_offset, end_of_pairs_offset),\n-// from the start of a mallocated array.\n-#[inline]\n-fn calculate_offsets(hashes_size: usize,\n-                     pairs_size: usize,\n-                     pairs_align: usize)\n-                     -> (usize, usize, bool) {\n-    let pairs_offset = round_up_to_next(hashes_size, pairs_align);\n-    let (end_of_pairs, oflo) = pairs_offset.overflowing_add(pairs_size);\n-\n-    (pairs_offset, end_of_pairs, oflo)\n-}\n-\n-// Returns a tuple of (minimum required malloc alignment,\n-// array_size), from the start of a mallocated array.\n-fn calculate_allocation(hash_size: usize,\n-                        hash_align: usize,\n-                        pairs_size: usize,\n-                        pairs_align: usize)\n-                        -> (usize, usize, bool) {\n-    let (_, end_of_pairs, oflo) = calculate_offsets(hash_size, pairs_size, pairs_align);\n-\n-    let align = cmp::max(hash_align, pairs_align);\n-\n-    (align, end_of_pairs, oflo)\n-}\n-\n-#[test]\n-fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 144, false));\n-    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 5, false));\n-    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 20, false));\n-    assert_eq!(calculate_offsets(128, 15, 4), (128, 143, false));\n-    assert_eq!(calculate_offsets(3, 2, 4), (4, 6, false));\n-    assert_eq!(calculate_offsets(6, 12, 4), (8, 20, false));\n+// Returns a Layout which describes the allocation required for a hash table,\n+// and the offset of the array of (key, value) pairs in the allocation.\n+fn calculate_layout<K, V>(capacity: usize) -> Result<(Layout, usize), LayoutErr> {\n+    let hashes = Layout::array::<HashUint>(capacity)?;\n+    let pairs = Layout::array::<(K, V)>(capacity)?;\n+    hashes.extend(pairs)\n }\n \n pub(crate) enum Fallibility {\n@@ -735,37 +682,11 @@ impl<K, V> RawTable<K, V> {\n             });\n         }\n \n-        // No need for `checked_mul` before a more restrictive check performed\n-        // later in this method.\n-        let hashes_size = capacity.wrapping_mul(size_of::<HashUint>());\n-        let pairs_size = capacity.wrapping_mul(size_of::<(K, V)>());\n-\n         // Allocating hashmaps is a little tricky. We need to allocate two\n         // arrays, but since we know their sizes and alignments up front,\n         // we just allocate a single array, and then have the subarrays\n         // point into it.\n-        //\n-        // This is great in theory, but in practice getting the alignment\n-        // right is a little subtle. Therefore, calculating offsets has been\n-        // factored out into a different function.\n-        let (alignment, size, oflo) = calculate_allocation(hashes_size,\n-                                                           align_of::<HashUint>(),\n-                                                           pairs_size,\n-                                                           align_of::<(K, V)>());\n-        if oflo {\n-            return Err(CollectionAllocErr::CapacityOverflow);\n-        }\n-\n-        // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<HashUint>().checked_add(size_of::<(K, V)>())\n-            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n-        let capacity_mul_size_of_bucket = capacity.checked_mul(size_of_bucket);\n-        if capacity_mul_size_of_bucket.is_none() || size < capacity_mul_size_of_bucket.unwrap() {\n-            return Err(CollectionAllocErr::CapacityOverflow);\n-        }\n-\n-        let layout = Layout::from_size_align(size, alignment)\n-            .map_err(|_| CollectionAllocErr::CapacityOverflow)?;\n+        let (layout, _) = calculate_layout::<K, V>(capacity)?;\n         let buffer = Global.alloc(layout).map_err(|e| match fallibility {\n             Infallible => oom(layout),\n             Fallible => e,\n@@ -790,18 +711,12 @@ impl<K, V> RawTable<K, V> {\n     }\n \n     fn raw_bucket_at(&self, index: usize) -> RawBucket<K, V> {\n-        let hashes_size = self.capacity() * size_of::<HashUint>();\n-        let pairs_size = self.capacity() * size_of::<(K, V)>();\n-\n-        let (pairs_offset, _, oflo) =\n-            calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n-        debug_assert!(!oflo, \"capacity overflow\");\n-\n+        let (_, pairs_offset) = calculate_layout::<K, V>(self.capacity()).unwrap();\n         let buffer = self.hashes.ptr() as *mut u8;\n         unsafe {\n             RawBucket {\n                 hash_start: buffer as *mut HashUint,\n-                pair_start: buffer.offset(pairs_offset as isize) as *const (K, V),\n+                pair_start: buffer.add(pairs_offset) as *const (K, V),\n                 idx: index,\n                 _marker: marker::PhantomData,\n             }\n@@ -1194,18 +1109,9 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n             }\n         }\n \n-        let hashes_size = self.capacity() * size_of::<HashUint>();\n-        let pairs_size = self.capacity() * size_of::<(K, V)>();\n-        let (align, size, oflo) = calculate_allocation(hashes_size,\n-                                                       align_of::<HashUint>(),\n-                                                       pairs_size,\n-                                                       align_of::<(K, V)>());\n-\n-        debug_assert!(!oflo, \"should be impossible\");\n-\n+        let (layout, _) = calculate_layout::<K, V>(self.capacity()).unwrap();\n         unsafe {\n-            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_opaque(),\n-                           Layout::from_size_align(size, align).unwrap());\n+            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_opaque(), layout);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}]}