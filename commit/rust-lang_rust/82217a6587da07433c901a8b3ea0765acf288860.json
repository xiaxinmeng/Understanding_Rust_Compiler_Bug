{"sha": "82217a6587da07433c901a8b3ea0765acf288860", "node_id": "C_kwDOAAsO6NoAKDgyMjE3YTY1ODdkYTA3NDMzYzkwMWE4YjNlYTA3NjVhY2YyODg4NjA", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-08T11:09:24Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-08T13:45:14Z"}, "message": "create leafs for slices", "tree": {"sha": "78f5b61edba7994d7c7775d57971878d7d328290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78f5b61edba7994d7c7775d57971878d7d328290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82217a6587da07433c901a8b3ea0765acf288860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82217a6587da07433c901a8b3ea0765acf288860", "html_url": "https://github.com/rust-lang/rust/commit/82217a6587da07433c901a8b3ea0765acf288860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82217a6587da07433c901a8b3ea0765acf288860/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc4d8ce98ef61586fccfb7efae7563788453b73", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc4d8ce98ef61586fccfb7efae7563788453b73", "html_url": "https://github.com/rust-lang/rust/commit/fcc4d8ce98ef61586fccfb7efae7563788453b73"}], "stats": {"total": 209, "additions": 64, "deletions": 145}, "files": [{"sha": "e28e7d766161badbb43383b4b7bbae5b46913203", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=82217a6587da07433c901a8b3ea0765acf288860", "patch": "@@ -188,6 +188,7 @@ pub(super) fn op_to_const<'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: ConstAlloc<'tcx>,\n@@ -206,6 +207,7 @@ fn turn_into_const_value<'tcx>(\n         !is_static || cid.promoted.is_some(),\n         \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n     );\n+\n     // Turn this into a proper constant.\n     op_to_const(&ecx, &mplace.into())\n }"}, {"sha": "9b42910f99cea2f6dc5e722ebc85be3d7e04f5e8", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 57, "deletions": 71, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=82217a6587da07433c901a8b3ea0765acf288860", "patch": "@@ -6,14 +6,14 @@ use rustc_hir::Mutability;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_middle::{\n     mir::{self, interpret::ConstAlloc},\n-    ty::{ScalarInt, Ty},\n+    ty::ScalarInt,\n };\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MPlaceTy,\n-    MemPlaceMeta, Scalar,\n+    intern_const_alloc_recursive, ConstValue, Immediate, InternKind, InterpCx, InterpResult,\n+    MPlaceTy, MemPlaceMeta, Scalar,\n };\n \n mod error;\n@@ -80,19 +80,28 @@ fn branches<'tcx>(\n     Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n }\n \n+fn slice_branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+    n: u64,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let elems = (0..n).map(|i| {\n+        let place_elem = ecx.mplace_index(place, i).unwrap();\n+        const_to_valtree_inner(ecx, &place_elem)\n+    });\n+\n+    // Need `len` for the ValTree -> ConstValue conversion\n+    let len = Some(Some(ty::ValTree::Leaf(ScalarInt::from(n))));\n+    let branches = len.into_iter().chain(elems);\n+\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n #[instrument(skip(ecx), level = \"debug\")]\n fn const_to_valtree_inner<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n ) -> Option<ty::ValTree<'tcx>> {\n-    // We only want to use raw bytes in ValTrees for string slices or &[<integer_ty>]\n-    let use_bytes_for_ref = |ty: Ty<'tcx>| -> bool {\n-        match ty.kind() {\n-            ty::Str | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Bool => true,\n-            _ => false,\n-        }\n-    };\n-\n     match place.layout.ty.kind() {\n         ty::FnDef(..) => Some(ty::ValTree::zst()),\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n@@ -107,75 +116,52 @@ fn const_to_valtree_inner<'tcx>(\n         // agree with runtime equality tests.\n         ty::FnPtr(_) | ty::RawPtr(_) => None,\n \n-        ty::Ref(_, ref_ty, _) if place.layout.ty.is_slice() => {\n-            match ecx.try_read_immediate_from_mplace(&place) {\n-                Ok(Some(imm)) => {\n-                    // `imm` is a ScalarPair. We try to get the underlying bytes behind that\n-                    // fat pointer for string slices and slices of integer types. For any other\n-                    // slice types we use `branches` to recursively construct the Valtree.\n-\n-                    if use_bytes_for_ref(*ref_ty) {\n-                        let (alloc, range) = ecx.get_alloc_from_imm_scalar_pair(imm);\n-                        let alloc_bytes = match alloc.get_bytes(&ecx.tcx, range) {\n-                            Ok(bytes) => bytes,\n-                            Err(_e) => return None,\n-                        };\n-                        debug!(?alloc_bytes);\n-\n-                        let bytes = ecx.tcx.arena.alloc_slice(alloc_bytes);\n-                        let len = bytes.len();\n-                        debug!(?bytes, ?len);\n-\n-                        let slice = ty::ValSlice { bytes};\n-\n-                        Some(ty::ValTree::SliceOrStr(slice))\n-                    } else {\n-                        let derefd = ecx.deref_operand(&imm.into()).expect(&format!(\"couldnt deref {:?}\", imm));\n-                        debug!(\"derefd: {:?}\", derefd);\n-\n-                        let derefd_imm = match ecx.try_read_immediate_from_mplace(&derefd) {\n-                            Ok(Some(imm)) => imm,\n-                            _ => return None,\n-                        };\n-                        debug!(?derefd_imm);\n-\n-                        let tcx = ecx.tcx.tcx;\n-                        let scalar_len= derefd.meta.unwrap_meta();\n-                        let len = match scalar_len {\n-                            Scalar::Int(int) => {\n-                                int.try_to_machine_usize(tcx).expect(&format!(\"Expected a valid ScalarInt in {:?}\", scalar_len))\n-                            }\n-                            _ => bug!(\"expected a ScalarInt in meta data for {:?}\", place),\n-                        };\n-                        debug!(?len);\n-\n-                        let valtree = branches(ecx, place, len.try_into().expect(\"BLA\"), None);\n-                        debug!(?valtree);\n-\n-                        valtree\n+        ty::Ref(_, inner_ty, _)  => {\n+            match inner_ty.kind() {\n+                ty::Slice(_) | ty::Str => {\n+                    match ecx.try_read_immediate_from_mplace(&place) {\n+                        Ok(Some(imm)) => {\n+                            let mplace_ref = ecx.ref_to_mplace(&imm).unwrap();\n+                            let derefd = ecx.deref_operand(&place.into()).expect(&format!(\"couldnt deref {:?}\", imm));\n+                            debug!(?mplace_ref, ?derefd);\n+\n+                            let len = match imm.imm {\n+                                Immediate::ScalarPair(_, b) => {\n+                                    let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                                    len\n+                                }\n+                                _ => bug!(\"expected ScalarPair for &[T] or &str\"),\n+                            };\n+                            debug!(?len);\n+\n+                            let valtree = slice_branches(ecx, &derefd, len);\n+                            debug!(?valtree);\n+\n+                            valtree\n+                        }\n+                        _ => {\n+                            None\n+                        }\n                     }\n                 }\n                 _ => {\n-                    None\n-                }\n-            }\n-        }\n+                    let imm = ecx.try_read_immediate_from_mplace(&place).unwrap_or_else(|e| bug!(\"couldnt read immediate from {:?}, error: {:?}\", place, e));\n \n-        ty::Ref(_, inner_ty, _) => {\n-            debug!(\"Ref with inner_ty: {:?}\", inner_ty);\n-            let imm = ecx.try_read_immediate_from_mplace(&place).unwrap_or_else(|e| bug!(\"couldnt read immediate from {:?}, error: {:?}\", place, e));\n-            match imm {\n-                Some(imm) => {\n-                    debug!(?imm);\n+                    match imm {\n+                        Some(imm) => {\n+                            debug!(?imm);\n \n-                    let derefd_place = ecx.deref_mplace(place).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n-                    debug!(?derefd_place);\n+                            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n+                            debug!(?derefd_place);\n \n-                    const_to_valtree_inner(ecx, &derefd_place)\n+                            const_to_valtree_inner(ecx, &derefd_place)\n+                        }\n+                        None => bug!(\"couldn't read immediate from {:?}\", place),\n+                    }\n                 }\n-                None => None,\n             }\n         }\n+\n         ty::Str => {\n             bug!(\"ty::Str should have been handled in ty::Ref branch that uses raw bytes\");\n         }"}, {"sha": "3b9fab9db438ebfeda5cc207274904a65a308018", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=82217a6587da07433c901a8b3ea0765acf288860", "patch": "@@ -14,9 +14,9 @@ use rustc_target::abi::{Abi, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, AllocRange, Allocation,\n-    ConstValue, GlobalId, InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy,\n-    Pointer, Provenance, Scalar, ScalarMaybeUninit,\n+    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, GlobalId,\n+    InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Provenance,\n+    Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -98,7 +98,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n-    imm: Immediate<Tag>,\n+    pub(crate) imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -777,32 +777,3 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n }\n-\n-impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx, PointerTag = AllocId>> InterpCx<'mir, 'tcx, M> {\n-    pub fn get_alloc_from_imm_scalar_pair(\n-        &self,\n-        imm: ImmTy<'tcx, M::PointerTag>,\n-    ) -> (&Allocation, AllocRange) {\n-        match imm.imm {\n-            Immediate::ScalarPair(a, b) => {\n-                // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-                let (data, start) = match self.scalar_to_ptr(a.check_init().unwrap()).into_parts() {\n-                    (Some(alloc_id), offset) => {\n-                        (self.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n-                    }\n-                    (None, _offset) => (\n-                        self.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n-                            b\"\" as &[u8],\n-                        )),\n-                        0,\n-                    ),\n-                };\n-                let len = b.to_machine_usize(self).unwrap();\n-                let size = Size::from_bytes(len);\n-                let start = Size::from_bytes(start);\n-                (data.inner(), AllocRange { start, size })\n-            }\n-            _ => bug!(\"{:?} not a ScalarPair\", imm),\n-        }\n-    }\n-}"}, {"sha": "b1784b12c6520045ae44cf6281882d0881e361c2", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=82217a6587da07433c901a8b3ea0765acf288860", "patch": "@@ -305,18 +305,6 @@ where\n         Ok(mplace)\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn deref_mplace(\n-        &self,\n-        src: &MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let val = self.try_read_immediate_from_mplace(src)?;\n-        let mplace = self.ref_to_mplace(&val.unwrap())?;\n-        self.check_mplace_access(mplace, CheckInAllocMsg::DerefTest)?;\n-\n-        Ok(mplace)\n-    }\n-\n     #[inline]\n     pub(super) fn get_alloc(\n         &self,"}, {"sha": "195760c059081bf607e54c26a33dfec44e4dbb77", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=82217a6587da07433c901a8b3ea0765acf288860", "patch": "@@ -1,7 +1,5 @@\n use super::ScalarInt;\n-use crate::ty::codec::TyDecoder;\n use rustc_macros::{HashStable, TyDecodable, TyEncodable};\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n \n #[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n #[derive(HashStable)]\n@@ -22,7 +20,6 @@ pub enum ValTree<'tcx> {\n     /// See the `ScalarInt` documentation for how `ScalarInt` guarantees that equal values\n     /// of these types have the same representation.\n     Leaf(ScalarInt),\n-    SliceOrStr(ValSlice<'tcx>),\n     /// The fields of any kind of aggregate. Structs, tuples and arrays are represented by\n     /// listing their fields' values in order.\n     /// Enums are represented by storing their discriminant as a field, followed by all\n@@ -35,28 +32,3 @@ impl<'tcx> ValTree<'tcx> {\n         Self::Branch(&[])\n     }\n }\n-\n-#[derive(Copy, Clone, Debug, HashStable, Hash, Eq, PartialEq, PartialOrd, Ord)]\n-pub struct ValSlice<'tcx> {\n-    pub bytes: &'tcx [u8],\n-}\n-\n-impl<'tcx, S: Encoder> Encodable<S> for ValSlice<'tcx> {\n-    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_usize(self.bytes.len())?;\n-        s.emit_raw_bytes(self.bytes)?;\n-\n-        Ok(())\n-    }\n-}\n-\n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ValSlice<'tcx> {\n-    fn decode(d: &mut D) -> Self {\n-        let tcx = d.tcx();\n-        let len = d.read_usize();\n-        let bytes_raw = d.read_raw_bytes(len);\n-        let bytes = tcx.arena.alloc_slice(&bytes_raw[..]);\n-\n-        ValSlice { bytes }\n-    }\n-}"}, {"sha": "31db66dc242f1c1f8373ab681c16f1a786ae031c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82217a6587da07433c901a8b3ea0765acf288860/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=82217a6587da07433c901a8b3ea0765acf288860", "patch": "@@ -62,7 +62,7 @@ pub use self::closure::{\n     CAPTURE_STRUCT_LOCAL,\n };\n pub use self::consts::{\n-    Const, ConstInt, ConstKind, ConstS, InferConst, ScalarInt, Unevaluated, ValSlice, ValTree,\n+    Const, ConstInt, ConstKind, ConstS, InferConst, ScalarInt, Unevaluated, ValTree,\n };\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,"}]}