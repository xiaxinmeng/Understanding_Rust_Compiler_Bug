{"sha": "51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZmY5ZmRhZjY4NGM4OWMxMmFjNWJmNDE5ODBhNTNlZWQ0NGVlMmQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-17T13:48:34Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-18T09:05:55Z"}, "message": "deallocate all locals on function exit and transitively freeze constants through pointers", "tree": {"sha": "9f27fc3d61ac07acd73529f28824ab0d0e0c94b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f27fc3d61ac07acd73529f28824ab0d0e0c94b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYLsRzAAoJEFbW7qD8Z6xG/kkP/iDbbVdHyEgTFEa2WkIgoTh0\nfik8oija2/2a7sdaSkxQAkarmFRJdxoWLHP8Yk6xrjkmIEO81CZOClga8g3pHZP2\nFFPlhkz+RJKOW7t/TjnuofwY+4jBJci5oYaib+mlQCp4oAs/dFBrCmzrfjDR/Epq\nx52X4hu6RjLHgAXu+k7R+eMrrNUHp6NOPN151lbj+cvcwwR5e0PdY5GC5PmPgqBh\nx36q3lESCWYkpQZslW31jegAia5QKKFNLXS19eTu0w/Ivyqcd8OJBqDAMziQesaM\nhS8K6s9OXnypokgTFKI1tAkuzhz3pNhedlWeU+9JTklVoOUE5/YZxFEEeP/JiddY\nfHU/KaKRGHMy6ktItJwIc8TF6KDjfs49NTDSTTXAlGBrDG3zLnzHO9kPN4MBmlYr\nPN0PwSECbYNl0g+Yw5y907/j35VF1608I995uVytSq7UD8KGfX5lvkEZygMVsM77\nePHL1bKJUx/EoSPuloAHQu2PCOZSqGr6cXda9AYlg5Ns6rslt/vBG91SQvePSh2Y\nUfgpZARBUO67iKs9vU/IFGK0ALXIJlbSOXjpM/Rp4M7at+HK6RRk71YEEta2dpmg\nsX6E2+d4zLiar7qpr+s+wqZENughguyxz3AdKRZ4YuMsVb8zfNO23IigYaXNsTz6\nh9QhH/hY9GlT/6H8DH3a\n=hy3h\n-----END PGP SIGNATURE-----", "payload": "tree 9f27fc3d61ac07acd73529f28824ab0d0e0c94b0\nparent f7cb9a09e4f05260f19c9e626457e3a7f2835c81\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479390514 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479459955 +0100\n\ndeallocate all locals on function exit and transitively freeze constants through pointers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "html_url": "https://github.com/rust-lang/rust/commit/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7cb9a09e4f05260f19c9e626457e3a7f2835c81", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7cb9a09e4f05260f19c9e626457e3a7f2835c81", "html_url": "https://github.com/rust-lang/rust/commit/f7cb9a09e4f05260f19c9e626457e3a7f2835c81"}], "stats": {"total": 110, "additions": 101, "deletions": 9}, "files": [{"sha": "0fd35ff65652677f79f0f92f6668d8e7cbbee69a", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -7,7 +7,7 @@ use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n     NoMirFor(String),\n@@ -48,6 +48,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n+    ReallocatedFrozenMemory,\n+    DeallocatedFrozenMemory,\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -110,6 +112,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"cannot evaluate inline assembly\",\n             EvalError::TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n+            EvalError::ReallocatedFrozenMemory =>\n+                \"tried to reallocate frozen memory\",\n+            EvalError::DeallocatedFrozenMemory =>\n+                \"tried to deallocate frozen memory\",\n         }\n     }\n "}, {"sha": "dbc6d7bfb8344265720a455bd30fa83f68ec91f3", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -364,6 +364,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let global_value = self.globals\n                                        .get_mut(&id)\n                                        .expect(\"global should have been cached (freeze)\");\n+                match global_value.data.expect(\"global should have been initialized\") {\n+                    Value::ByRef(ptr) => self.memory.freeze(ptr.alloc_id)?,\n+                    Value::ByVal(val) => if let Some(alloc_id) = val.relocation {\n+                        self.memory.freeze(alloc_id)?;\n+                    },\n+                    Value::ByValPair(a, b) => {\n+                        if let Some(alloc_id) = a.relocation {\n+                            self.memory.freeze(alloc_id)?;\n+                        }\n+                        if let Some(alloc_id) = b.relocation {\n+                            self.memory.freeze(alloc_id)?;\n+                        }\n+                    },\n+                }\n                 if let Value::ByRef(ptr) = global_value.data.expect(\"global should have been initialized\") {\n                     self.memory.freeze(ptr.alloc_id)?;\n                 }\n@@ -375,7 +389,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n         }\n-        // TODO(solson): Deallocate local variables.\n+        // check that all locals have been deallocated through StorageDead\n+        for (i, local) in frame.locals.into_iter().enumerate() {\n+            if let Some(Value::ByRef(ptr)) = local {\n+                trace!(\"deallocating local {}: {:?}\", i + 1, ptr);\n+                self.memory.dump(ptr.alloc_id);\n+                match self.memory.deallocate(ptr) {\n+                    Ok(()) | Err(EvalError::DeallocatedFrozenMemory) => {},\n+                    other => return other,\n+                }\n+            }\n+        }\n         Ok(())\n     }\n \n@@ -729,6 +753,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // Skip the initial 0 intended for LLVM GEP.\n         for field_index in path {\n             let field_offset = self.get_field_offset(ty, field_index)?;\n+            trace!(\"field_path_offset_and_ty: {}, {}, {:?}, {:?}\", field_index, ty, field_offset, offset);\n             ty = self.get_field_ty(ty, field_index)?;\n             offset = offset.checked_add(field_offset, &self.tcx.data_layout).unwrap();\n         }\n@@ -1595,8 +1620,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         let val = self.stack[frame].get_local(local);\n         let val = f(self, val)?;\n-        // can't use `set_local` here, because that's only meant for going to an initialized value\n-        self.stack[frame].locals[local.index() - 1] = val;\n+        if let Some(val) = val {\n+            self.stack[frame].set_local(local, val);\n+        } else {\n+            self.deallocate_local(frame, local)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn deallocate_local(&mut self, frame: usize, local: mir::Local) -> EvalResult<'tcx, ()> {\n+        if let Some(Value::ByRef(ptr)) = self.stack[frame].get_local(local) {\n+            self.memory.deallocate(ptr)?;\n+        }\n+        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n+        self.stack[frame].locals[local.index() - 1] = None;\n         Ok(())\n     }\n }"}, {"sha": "90564cd2fcc91e0aa14fa541c99386fbfaf5a19b", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -81,8 +81,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Assign(ref lvalue, ref rvalue) => self.eval_rvalue_into_lvalue(rvalue, lvalue)?,\n             SetDiscriminant { .. } => unimplemented!(),\n \n-            // Miri can safely ignore these. Only translation needs them.\n-            StorageLive(_) | StorageDead(_) => {}\n+            // Miri can safely ignore these. Only translation needs it.\n+            StorageLive(_) |\n+            StorageDead(_) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly."}, {"sha": "b0c24fc344f2a05b27fdb9f0956d044977fb0bf4", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n+    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>) -> EvalResult<'tcx, ()> {\n         let span = self.frame().span;\n         // add them to the stack in reverse order, because the impl that needs to run the last\n         // is the one that needs to be at the bottom of the stack\n@@ -249,6 +249,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty);\n+        trace!(\"read_discriminant_value {:?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, signed: false, .. } => {\n@@ -263,12 +264,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             RawNullablePointer { nndiscr, value } => {\n                 let discr_size = value.size(&self.tcx.data_layout).bytes() as usize;\n+                trace!(\"rawnullablepointer with size {}\", discr_size);\n                 self.read_nonnull_discriminant_value(adt_ptr, nndiscr, discr_size)?\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n                 let nonnull = adt_ptr.offset(offset.bytes() as isize);\n+                trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n                 self.read_nonnull_discriminant_value(nonnull, nndiscr, discr_size)?\n@@ -515,7 +518,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     /// push DefIds of drop impls and their argument on the given vector\n-    fn drop(\n+    pub fn drop(\n         &mut self,\n         lval: Lvalue<'tcx>,\n         ty: Ty<'tcx>,"}, {"sha": "4421fe23ebab8623e9bac233ae1474878895b258", "filename": "src/memory.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -212,6 +212,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return self.allocate(new_size, align);\n         }\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+            return Err(EvalError::ReallocatedFrozenMemory);\n+        }\n \n         let size = self.get(ptr.alloc_id)?.bytes.len();\n \n@@ -242,6 +245,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+            return Err(EvalError::DeallocatedFrozenMemory);\n+        }\n \n         if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n             self.memory_usage -= alloc.bytes.len();\n@@ -446,9 +452,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n+        // FIXME: the comment is wrong and do we really still need this check?\n         // It's not possible to freeze the zero-sized allocation, because it doesn't exist.\n         if alloc_id != ZST_ALLOC_ID {\n-            self.get_mut(alloc_id)?.immutable = true;\n+            // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n+            // sub-element or have circular pointers (e.g. `Rc`-cycles)\n+            let allocs: Vec<_> = match self.alloc_map.get_mut(&alloc_id) {\n+                Some(ref mut alloc) if !alloc.immutable => {\n+                    alloc.immutable = true;\n+                    alloc.relocations.values().cloned().collect()\n+                },\n+                None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => Vec::new(),\n+                None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n+                _ => Vec::new(),\n+            };\n+            // recurse into inner allocations\n+            for alloc in allocs {\n+                self.freeze(alloc)?;\n+            }\n         }\n         Ok(())\n     }"}, {"sha": "5a8fd189aae7de18435b00723393429bb5bc17dc", "filename": "tests/compile-fail/modifying_constants.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is frozen, not the pointee\n+    let y = unsafe { &mut *(x as *const i32 as *mut i32) };\n+    *y = 42; //~ ERROR tried to modify constant memory\n+    assert_eq!(*x, 42);\n+}"}, {"sha": "2e6320eb8025725ac802390ccbe674e9068d6791", "filename": "tests/run-pass/move-arg-3-unique.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/tests%2Frun-pass%2Fmove-arg-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d/tests%2Frun-pass%2Fmove-arg-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-3-unique.rs?ref=51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_features, unused_variables)]\n+#![feature(box_syntax)]\n+\n+pub fn main() {\n+    let x = box 10;\n+    let y = x;\n+    assert_eq!(*y, 10);\n+}"}]}