{"sha": "116201eefebcf45074ae232377e7145f5fbb704b", "node_id": "C_kwDOAAsO6NoAKDExNjIwMWVlZmViY2Y0NTA3NGFlMjMyMzc3ZTcxNDVmNWZiYjcwNGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-28T16:49:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-28T16:49:52Z"}, "message": "Auto merge of #97461 - eddyb:proc-macro-less-payload, r=bjorn3\n\nproc_macro: don't pass a client-side function pointer through the server.\n\nBefore this PR, `proc_macro::bridge::Client<F>` contained both:\n* the C ABI entry-point `run`, that the server can call to start the client\n* some \"payload\" `f: F` passed to that entry-point\n  * in practice, this was always a (client-side Rust ABI) `fn` pointer to the actual function the proc macro author wrote, i.e. `#[proc_macro] fn foo(input: TokenStream) -> TokenStream`\n\nIn other words, the client was passing one of its (Rust) `fn` pointers to the server, which was passing it back to the client, for the client to call (see later below for why that was ever needed).\n\nI was inspired by `@nnethercote's` attempt to remove the `get_handle_counters` field from `Client` (see https://github.com/rust-lang/rust/pull/97004#issuecomment-1139273301), which combined with removing the `f` (\"payload\") field, could theoretically allow for a `#[repr(transparent)]` `Client` that mostly just newtypes the C ABI entry-point `fn` pointer <sub>(and in the context of e.g. wasm isolation, that's *all* you want, since you can reason about it from outside the wasm VM, as just a 32-bit \"function table index\", that you can pass to the wasm VM to call that function)</sub>.\n\n<hr/>\n\nSo this PR removes that \"payload\". But it's not a simple refactor: the reason the field existed in the first place is because monomorphizing over a function type doesn't let you call the function without having a value of that type, because function types don't implement anything like `Default`, i.e.:\n```rust\nextern \"C\" fn ffi_wrapper<A, R, F: Fn(A) -> R>(arg: A) -> R {\n    let f: F = ???; // no way to get a value of `F`\n    f(arg)\n}\n```\nThat could be solved with something like this, if it was allowed:\n```rust\nextern \"C\" fn ffi_wrapper<\n    A, R,\n    F: Fn(A) -> R,\n    const f: F // not allowed because the type is a generic param\n>(arg: A) -> R {\n    f(arg)\n}\n```\n\nInstead, this PR contains a workaround in `proc_macro::bridge::selfless_reify` (see its module-level comment for more details) that can provide something similar to the `ffi_wrapper` example above, but limited to `F` being `Copy` and ZST (and requiring an `F` value to prove the caller actually can create values of `F` and it's not uninhabited or some other unsound situation).\n\n<hr/>\n\nHopefully this time we don't have a performance regression, and this has a chance to land.\n\ncc `@mystor` `@bjorn3`", "tree": {"sha": "a5981e4e7c67e1ab311782da7926c135f5b9645a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5981e4e7c67e1ab311782da7926c135f5b9645a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/116201eefebcf45074ae232377e7145f5fbb704b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/116201eefebcf45074ae232377e7145f5fbb704b", "html_url": "https://github.com/rust-lang/rust/commit/116201eefebcf45074ae232377e7145f5fbb704b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/116201eefebcf45074ae232377e7145f5fbb704b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f39fb1f34d4bd25d9ce96afe7b2d109f073e286", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f39fb1f34d4bd25d9ce96afe7b2d109f073e286", "html_url": "https://github.com/rust-lang/rust/commit/4f39fb1f34d4bd25d9ce96afe7b2d109f073e286"}, {"sha": "78a83b0d5fb90d3fa9418592282b55e9f2e496be", "url": "https://api.github.com/repos/rust-lang/rust/commits/78a83b0d5fb90d3fa9418592282b55e9f2e496be", "html_url": "https://github.com/rust-lang/rust/commit/78a83b0d5fb90d3fa9418592282b55e9f2e496be"}], "stats": {"total": 351, "additions": 217, "deletions": 134}, "files": [{"sha": "03159d43950661a357c226ba371173caca05354b", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -294,50 +294,57 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n     // that we generate expressions. The position of each NodeId\n     // in the 'proc_macros' Vec corresponds to its position\n     // in the static array that will be generated\n-    let decls = {\n-        let local_path = |cx: &ExtCtxt<'_>, sp: Span, name| {\n-            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![name]))\n-        };\n-        let proc_macro_ty_method_path = |cx: &ExtCtxt<'_>, method| {\n-            cx.expr_path(cx.path(span, vec![proc_macro, bridge, client, proc_macro_ty, method]))\n-        };\n-        let attr_or_bang = |cx: &mut ExtCtxt<'_>, ca: &ProcMacroDef, ident| {\n-            cx.resolver.declare_proc_macro(ca.id);\n-            cx.expr_call(\n-                span,\n-                proc_macro_ty_method_path(cx, ident),\n-                vec![\n-                    cx.expr_str(ca.span, ca.function_name.name),\n-                    local_path(cx, ca.span, ca.function_name),\n-                ],\n-            )\n-        };\n-        macros\n-            .iter()\n-            .map(|m| match m {\n+    let decls = macros\n+        .iter()\n+        .map(|m| {\n+            let harness_span = span;\n+            let span = match m {\n+                ProcMacro::Derive(m) => m.span,\n+                ProcMacro::Attr(m) | ProcMacro::Bang(m) => m.span,\n+            };\n+            let local_path = |cx: &ExtCtxt<'_>, name| cx.expr_path(cx.path(span, vec![name]));\n+            let proc_macro_ty_method_path = |cx: &ExtCtxt<'_>, method| {\n+                cx.expr_path(cx.path(\n+                    span.with_ctxt(harness_span.ctxt()),\n+                    vec![proc_macro, bridge, client, proc_macro_ty, method],\n+                ))\n+            };\n+            match m {\n                 ProcMacro::Derive(cd) => {\n                     cx.resolver.declare_proc_macro(cd.id);\n                     cx.expr_call(\n                         span,\n                         proc_macro_ty_method_path(cx, custom_derive),\n                         vec![\n-                            cx.expr_str(cd.span, cd.trait_name),\n+                            cx.expr_str(span, cd.trait_name),\n                             cx.expr_vec_slice(\n                                 span,\n-                                cd.attrs\n-                                    .iter()\n-                                    .map(|&s| cx.expr_str(cd.span, s))\n-                                    .collect::<Vec<_>>(),\n+                                cd.attrs.iter().map(|&s| cx.expr_str(span, s)).collect::<Vec<_>>(),\n                             ),\n-                            local_path(cx, cd.span, cd.function_name),\n+                            local_path(cx, cd.function_name),\n                         ],\n                     )\n                 }\n-                ProcMacro::Attr(ca) => attr_or_bang(cx, &ca, attr),\n-                ProcMacro::Bang(ca) => attr_or_bang(cx, &ca, bang),\n-            })\n-            .collect()\n-    };\n+                ProcMacro::Attr(ca) | ProcMacro::Bang(ca) => {\n+                    cx.resolver.declare_proc_macro(ca.id);\n+                    let ident = match m {\n+                        ProcMacro::Attr(_) => attr,\n+                        ProcMacro::Bang(_) => bang,\n+                        ProcMacro::Derive(_) => unreachable!(),\n+                    };\n+\n+                    cx.expr_call(\n+                        span,\n+                        proc_macro_ty_method_path(cx, ident),\n+                        vec![\n+                            cx.expr_str(span, ca.function_name.name),\n+                            local_path(cx, ca.function_name),\n+                        ],\n+                    )\n+                }\n+            }\n+        })\n+        .collect();\n \n     let decls_static = cx\n         .item_static("}, {"sha": "9e1cd299fd60fc8bc851d70cacab18d6b7938b67", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -14,7 +14,7 @@ use rustc_span::{Span, DUMMY_SP};\n const EXEC_STRATEGY: pm::bridge::server::SameThread = pm::bridge::server::SameThread;\n \n pub struct BangProcMacro {\n-    pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n+    pub client: pm::bridge::client::Client<pm::TokenStream, pm::TokenStream>,\n }\n \n impl base::BangProcMacro for BangProcMacro {\n@@ -42,7 +42,7 @@ impl base::BangProcMacro for BangProcMacro {\n }\n \n pub struct AttrProcMacro {\n-    pub client: pm::bridge::client::Client<fn(pm::TokenStream, pm::TokenStream) -> pm::TokenStream>,\n+    pub client: pm::bridge::client::Client<(pm::TokenStream, pm::TokenStream), pm::TokenStream>,\n }\n \n impl base::AttrProcMacro for AttrProcMacro {\n@@ -73,7 +73,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n }\n \n pub struct DeriveProcMacro {\n-    pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n+    pub client: pm::bridge::client::Client<pm::TokenStream, pm::TokenStream>,\n }\n \n impl MultiItemModifier for DeriveProcMacro {"}, {"sha": "c38457ac6712d2dc79598e490f46368ca9d89dcb", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -357,22 +357,33 @@ impl Bridge<'_> {\n     }\n }\n \n-/// A client-side \"global object\" (usually a function pointer),\n-/// which may be using a different `proc_macro` from the one\n-/// used by the server, but can be interacted with compatibly.\n+/// A client-side RPC entry-point, which may be using a different `proc_macro`\n+/// from the one used by the server, but can be invoked compatibly.\n ///\n-/// N.B., `F` must have FFI-friendly memory layout (e.g., a pointer).\n-/// The call ABI of function pointers used for `F` doesn't\n-/// need to match between server and client, since it's only\n-/// passed between them and (eventually) called by the client.\n+/// Note that the (phantom) `I` (\"input\") and `O` (\"output\") type parameters\n+/// decorate the `Client<I, O>` with the RPC \"interface\" of the entry-point, but\n+/// do not themselves participate in ABI, at all, only facilitate type-checking.\n+///\n+/// E.g. `Client<TokenStream, TokenStream>` is the common proc macro interface,\n+/// used for `#[proc_macro] fn foo(input: TokenStream) -> TokenStream`,\n+/// indicating that the RPC input and output will be serialized token streams,\n+/// and forcing the use of APIs that take/return `S::TokenStream`, server-side.\n #[repr(C)]\n-#[derive(Copy, Clone)]\n-pub struct Client<F> {\n+pub struct Client<I, O> {\n     // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n     // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer,\n-    pub(super) f: F,\n+\n+    pub(super) run: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+\n+    pub(super) _marker: PhantomData<fn(I) -> O>,\n+}\n+\n+impl<I, O> Copy for Client<I, O> {}\n+impl<I, O> Clone for Client<I, O> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n }\n \n /// Client-side helper for handling client panics, entering the bridge,\n@@ -419,31 +430,31 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     buf\n }\n \n-impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n-    pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n-        extern \"C\" fn run(\n-            bridge: Bridge<'_>,\n-            f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n-        ) -> Buffer {\n-            run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+impl Client<crate::TokenStream, crate::TokenStream> {\n+    pub const fn expand1(f: impl Fn(crate::TokenStream) -> crate::TokenStream + Copy) -> Self {\n+        Client {\n+            get_handle_counters: HandleCounters::get,\n+            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n+                run_client(bridge, |input| f(crate::TokenStream(input)).0)\n+            }),\n+            _marker: PhantomData,\n         }\n-        Client { get_handle_counters: HandleCounters::get, run, f }\n     }\n }\n \n-impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+impl Client<(crate::TokenStream, crate::TokenStream), crate::TokenStream> {\n     pub const fn expand2(\n-        f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        f: impl Fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream + Copy,\n     ) -> Self {\n-        extern \"C\" fn run(\n-            bridge: Bridge<'_>,\n-            f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n-        ) -> Buffer {\n-            run_client(bridge, |(input, input2)| {\n-                f(crate::TokenStream(input), crate::TokenStream(input2)).0\n-            })\n+        Client {\n+            get_handle_counters: HandleCounters::get,\n+            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n+                run_client(bridge, |(input, input2)| {\n+                    f(crate::TokenStream(input), crate::TokenStream(input2)).0\n+                })\n+            }),\n+            _marker: PhantomData,\n         }\n-        Client { get_handle_counters: HandleCounters::get, run, f }\n     }\n }\n \n@@ -453,17 +464,17 @@ pub enum ProcMacro {\n     CustomDerive {\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<crate::TokenStream, crate::TokenStream>,\n     },\n \n     Attr {\n         name: &'static str,\n-        client: Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<(crate::TokenStream, crate::TokenStream), crate::TokenStream>,\n     },\n \n     Bang {\n         name: &'static str,\n-        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n+        client: Client<crate::TokenStream, crate::TokenStream>,\n     },\n }\n \n@@ -479,21 +490,21 @@ impl ProcMacro {\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        expand: fn(crate::TokenStream) -> crate::TokenStream,\n+        expand: impl Fn(crate::TokenStream) -> crate::TokenStream + Copy,\n     ) -> Self {\n         ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n     }\n \n     pub const fn attr(\n         name: &'static str,\n-        expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n+        expand: impl Fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream + Copy,\n     ) -> Self {\n         ProcMacro::Attr { name, client: Client::expand2(expand) }\n     }\n \n     pub const fn bang(\n         name: &'static str,\n-        expand: fn(crate::TokenStream) -> crate::TokenStream,\n+        expand: impl Fn(crate::TokenStream) -> crate::TokenStream + Copy,\n     ) -> Self {\n         ProcMacro::Bang { name, client: Client::expand1(expand) }\n     }"}, {"sha": "4d3e89ba09356b96d3be903621ceeaebaedb1596", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -208,6 +208,8 @@ mod handle;\n mod rpc;\n #[allow(unsafe_code)]\n mod scoped_cell;\n+#[allow(unsafe_code)]\n+mod selfless_reify;\n #[forbid(unsafe_code)]\n pub mod server;\n "}, {"sha": "4ee4bb87c2bbdd348c552a0aa95703c4f0a8b3f1", "filename": "library/proc_macro/src/bridge/selfless_reify.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -0,0 +1,83 @@\n+//! Abstraction for creating `fn` pointers from any callable that *effectively*\n+//! has the equivalent of implementing `Default`, even if the compiler neither\n+//! provides `Default` nor allows reifying closures (i.e. creating `fn` pointers)\n+//! other than those with absolutely no captures.\n+//!\n+//! More specifically, for a closure-like type to be \"effectively `Default`\":\n+//! * it must be a ZST (zero-sized type): no information contained within, so\n+//!   that `Default`'s return value (if it were implemented) is unambiguous\n+//! * it must be `Copy`: no captured \"unique ZST tokens\" or any other similar\n+//!   types that would make duplicating values at will unsound\n+//!   * combined with the ZST requirement, this confers a kind of \"telecopy\"\n+//!     ability: similar to `Copy`, but without keeping the value around, and\n+//!     instead \"reconstructing\" it (a noop given it's a ZST) when needed\n+//! * it must be *provably* inhabited: no captured uninhabited types or any\n+//!   other types that cannot be constructed by the user of this abstraction\n+//!   * the proof is a value of the closure-like type itself, in a sense the\n+//!     \"seed\" for the \"telecopy\" process made possible by ZST + `Copy`\n+//!   * this requirement is the only reason an abstraction limited to a specific\n+//!     usecase is required: ZST + `Copy` can be checked with *at worst* a panic\n+//!     at the \"attempted `::default()` call\" time, but that doesn't guarantee\n+//!     that the value can be soundly created, and attempting to use the typical\n+//!     \"proof ZST token\" approach leads yet again to having a ZST + `Copy` type\n+//!     that is not proof of anything without a value (i.e. isomorphic to a\n+//!     newtype of the type it's trying to prove the inhabitation of)\n+//!\n+//! A more flexible (and safer) solution to the general problem could exist once\n+//! `const`-generic parameters can have type parameters in their types:\n+//!\n+//! ```rust,ignore (needs future const-generics)\n+//! extern \"C\" fn ffi_wrapper<\n+//!     A, R,\n+//!     F: Fn(A) -> R,\n+//!     const f: F, // <-- this `const`-generic is not yet allowed\n+//! >(arg: A) -> R {\n+//!     f(arg)\n+//! }\n+//! ```\n+\n+use std::mem;\n+\n+// FIXME(eddyb) this could be `trait` impls except for the `const fn` requirement.\n+macro_rules! define_reify_functions {\n+    ($(\n+        fn $name:ident $(<$($param:ident),*>)?\n+            for $(extern $abi:tt)? fn($($arg:ident: $arg_ty:ty),*) -> $ret_ty:ty;\n+    )+) => {\n+        $(pub const fn $name<\n+            $($($param,)*)?\n+            F: Fn($($arg_ty),*) -> $ret_ty + Copy\n+        >(f: F) -> $(extern $abi)? fn($($arg_ty),*) -> $ret_ty {\n+            // FIXME(eddyb) describe the `F` type (e.g. via `type_name::<F>`) once panic\n+            // formatting becomes possible in `const fn`.\n+            assert!(mem::size_of::<F>() == 0, \"selfless_reify: closure must be zero-sized\");\n+\n+            $(extern $abi)? fn wrapper<\n+                $($($param,)*)?\n+                F: Fn($($arg_ty),*) -> $ret_ty + Copy\n+            >($($arg: $arg_ty),*) -> $ret_ty {\n+                let f = unsafe {\n+                    // SAFETY: `F` satisfies all criteria for \"out of thin air\"\n+                    // reconstructability (see module-level doc comment).\n+                    mem::MaybeUninit::<F>::uninit().assume_init()\n+                };\n+                f($($arg),*)\n+            }\n+            let _f_proof = f;\n+            wrapper::<\n+                $($($param,)*)?\n+                F\n+            >\n+        })+\n+    }\n+}\n+\n+define_reify_functions! {\n+    fn _reify_to_extern_c_fn_unary<A, R> for extern \"C\" fn(arg: A) -> R;\n+\n+    // HACK(eddyb) this abstraction is used with `for<'a> fn(Bridge<'a>) -> T`\n+    // but that doesn't work with just `reify_to_extern_c_fn_unary` because of\n+    // the `fn` pointer type being \"higher-ranked\" (i.e. the `for<'a>` binder).\n+    // FIXME(eddyb) try to remove the lifetime from `Bridge`, that'd help.\n+    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::Bridge<'_>) -> R;\n+}"}, {"sha": "cbddf39da44d245c60d0b51f7d998e2f728f2f3f", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 32, "deletions": 55, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -118,38 +118,33 @@ macro_rules! define_dispatcher_impl {\n with_api!(Self, self_, define_dispatcher_impl);\n \n pub trait ExecutionStrategy {\n-    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+    fn run_bridge_and_client(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n-        client_data: D,\n+        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer;\n }\n \n pub struct SameThread;\n \n impl ExecutionStrategy for SameThread {\n-    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+    fn run_bridge_and_client(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n-        client_data: D,\n+        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         let mut dispatch = |buf| dispatcher.dispatch(buf);\n \n-        run_client(\n-            Bridge {\n-                cached_buffer: input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            },\n-            client_data,\n-        )\n+        run_client(Bridge {\n+            cached_buffer: input,\n+            dispatch: (&mut dispatch).into(),\n+            force_show_panics,\n+            _marker: marker::PhantomData,\n+        })\n     }\n }\n \n@@ -159,12 +154,11 @@ impl ExecutionStrategy for SameThread {\n pub struct CrossThread1;\n \n impl ExecutionStrategy for CrossThread1 {\n-    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+    fn run_bridge_and_client(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n-        client_data: D,\n+        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         use std::sync::mpsc::channel;\n@@ -178,15 +172,12 @@ impl ExecutionStrategy for CrossThread1 {\n                 res_rx.recv().unwrap()\n             };\n \n-            run_client(\n-                Bridge {\n-                    cached_buffer: input,\n-                    dispatch: (&mut dispatch).into(),\n-                    force_show_panics,\n-                    _marker: marker::PhantomData,\n-                },\n-                client_data,\n-            )\n+            run_client(Bridge {\n+                cached_buffer: input,\n+                dispatch: (&mut dispatch).into(),\n+                force_show_panics,\n+                _marker: marker::PhantomData,\n+            })\n         });\n \n         for b in req_rx {\n@@ -200,12 +191,11 @@ impl ExecutionStrategy for CrossThread1 {\n pub struct CrossThread2;\n \n impl ExecutionStrategy for CrossThread2 {\n-    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+    fn run_bridge_and_client(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n-        client_data: D,\n+        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         use std::sync::{Arc, Mutex};\n@@ -231,15 +221,12 @@ impl ExecutionStrategy for CrossThread2 {\n                 }\n             };\n \n-            let r = run_client(\n-                Bridge {\n-                    cached_buffer: input,\n-                    dispatch: (&mut dispatch).into(),\n-                    force_show_panics,\n-                    _marker: marker::PhantomData,\n-                },\n-                client_data,\n-            );\n+            let r = run_client(Bridge {\n+                cached_buffer: input,\n+                dispatch: (&mut dispatch).into(),\n+                force_show_panics,\n+                _marker: marker::PhantomData,\n+            });\n \n             // Wake up the server so it can exit the dispatch loop.\n             drop(state2);\n@@ -268,14 +255,12 @@ fn run_server<\n     S: Server,\n     I: Encode<HandleStore<MarkedTypes<S>>>,\n     O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n-    D: Copy + Send + 'static,\n >(\n     strategy: &impl ExecutionStrategy,\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n-    client_data: D,\n+    run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n     force_show_panics: bool,\n ) -> Result<O, PanicMessage> {\n     let mut dispatcher =\n@@ -284,40 +269,33 @@ fn run_server<\n     let mut buf = Buffer::new();\n     input.encode(&mut buf, &mut dispatcher.handle_store);\n \n-    buf = strategy.run_bridge_and_client(\n-        &mut dispatcher,\n-        buf,\n-        run_client,\n-        client_data,\n-        force_show_panics,\n-    );\n+    buf = strategy.run_bridge_and_client(&mut dispatcher, buf, run_client, force_show_panics);\n \n     Result::decode(&mut &buf[..], &mut dispatcher.handle_store)\n }\n \n-impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+impl client::Client<crate::TokenStream, crate::TokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n         server: S,\n         input: S::TokenStream,\n         force_show_panics: bool,\n     ) -> Result<S::TokenStream, PanicMessage> {\n-        let client::Client { get_handle_counters, run, f } = *self;\n+        let client::Client { get_handle_counters, run, _marker } = *self;\n         run_server(\n             strategy,\n             get_handle_counters(),\n             server,\n             <MarkedTypes<S> as Types>::TokenStream::mark(input),\n             run,\n-            f,\n             force_show_panics,\n         )\n         .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n     }\n }\n \n-impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+impl client::Client<(crate::TokenStream, crate::TokenStream), crate::TokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n@@ -326,7 +304,7 @@ impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenSt\n         input2: S::TokenStream,\n         force_show_panics: bool,\n     ) -> Result<S::TokenStream, PanicMessage> {\n-        let client::Client { get_handle_counters, run, f } = *self;\n+        let client::Client { get_handle_counters, run, _marker } = *self;\n         run_server(\n             strategy,\n             get_handle_counters(),\n@@ -336,7 +314,6 @@ impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenSt\n                 <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n             ),\n             run,\n-            f,\n             force_show_panics,\n         )\n         .map(<MarkedTypes<S> as Types>::TokenStream::unmark)"}, {"sha": "2302238253e82e172cf2a6ab068a2b5bdbdb3643", "filename": "src/test/ui/proc-macro/signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.rs?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -8,6 +8,6 @@ extern crate proc_macro;\n \n #[proc_macro_derive(A)]\n pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n-    //~^ ERROR: mismatched types\n+    //~^ ERROR: expected a `Fn<(proc_macro::TokenStream,)>` closure, found `unsafe extern \"C\" fn\n     loop {}\n }"}, {"sha": "78b0beff0da39d6aae0af07deafac0e05ce2b58f", "filename": "src/test/ui/proc-macro/signature.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/116201eefebcf45074ae232377e7145f5fbb704b/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/116201eefebcf45074ae232377e7145f5fbb704b/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr?ref=116201eefebcf45074ae232377e7145f5fbb704b", "patch": "@@ -1,20 +1,23 @@\n-error[E0308]: mismatched types\n+error[E0277]: expected a `Fn<(proc_macro::TokenStream,)>` closure, found `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n   --> $DIR/signature.rs:10:1\n    |\n LL | / pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n LL | |\n LL | |     loop {}\n LL | | }\n-   | |_^ expected normal fn, found unsafe fn\n+   | | ^\n+   | | |\n+   | |_call the function in a closure: `|| unsafe { /* code */ }`\n+   |   required by a bound introduced by this call\n    |\n-   = note: expected fn pointer `fn(proc_macro::TokenStream) -> proc_macro::TokenStream`\n-                 found fn item `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n-note: associated function defined here\n+   = help: the trait `Fn<(proc_macro::TokenStream,)>` is not implemented for `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n+   = note: unsafe function cannot be called generically without an unsafe block\n+note: required by a bound in `ProcMacro::custom_derive`\n   --> $SRC_DIR/proc_macro/src/bridge/client.rs:LL:COL\n    |\n-LL |     pub const fn custom_derive(\n-   |                  ^^^^^^^^^^^^^\n+LL |         expand: impl Fn(crate::TokenStream) -> crate::TokenStream + Copy,\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `ProcMacro::custom_derive`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0277`."}]}