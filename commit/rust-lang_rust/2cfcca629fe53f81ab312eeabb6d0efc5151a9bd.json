{"sha": "2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "node_id": "C_kwDOAAsO6NoAKDJjZmNjYTYyOWZlNTNmODFhYjMxMmVlYWJiNmQwZWZjNTE1MWE5YmQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-24T06:13:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-24T06:13:06Z"}, "message": "Rollup merge of #109550 - Nathan-Fenner:nathanf/fixme-adjust-funcs, r=compiler-errors\n\nMake helper functions private in fn_ctxt/adjust_fulfillment_errors\n\nTwo helper functions in `rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs` were previously made `pub` impl members, because they were also used in `rustc_hir_typeck/src/fn_ctxt/check.rs` (see #107746).\n\nHowever, that's no longer the case, so the FIXME suggesting they be made private can now be implemented.", "tree": {"sha": "df8f56ba15d8be04f1ed1a37e30b8848b8b39b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df8f56ba15d8be04f1ed1a37e30b8848b8b39b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkHT9yCRBK7hj4Ov3rIwAA6WsIALJ64lMn1jWpjXEGXI4sBZzQ\nqtChn5kCVLN4ZwjmgMZ2uT58bsfpWvWv46Wa1aMBN9x6ClB2kWAPADj71W41hZlG\nh7nE3f4k1So3i5BuAClzXrWdnV3tvrXY2EazJz9E2jlLURG8C9v6Zj2FKUvui9Hp\n4RdtGe4vip2kh5RoSCrUlijFoc/dhnCnJHgAU8ZQH/wxv1pMhNvdux8yKk0WyRV0\nQVRpWN6NS3qoZVcmwABYCgNJ4fI2cbxXujruVDDXJ4IScxW9xv2nyRHNm9e5fqjI\nQX6Lnh37Tkwv4by/iYayWFXFF79QoHUDDfD5A1Vssc5pxcS7/ujeY91UqlcyUs0=\n=Qvte\n-----END PGP SIGNATURE-----\n", "payload": "tree df8f56ba15d8be04f1ed1a37e30b8848b8b39b8f\nparent 4378369b6ad92ec89f45906bc7240e3837ffdde1\nparent d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679638386 +0100\ncommitter GitHub <noreply@github.com> 1679638386 +0100\n\nRollup merge of #109550 - Nathan-Fenner:nathanf/fixme-adjust-funcs, r=compiler-errors\n\nMake helper functions private in fn_ctxt/adjust_fulfillment_errors\n\nTwo helper functions in `rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs` were previously made `pub` impl members, because they were also used in `rustc_hir_typeck/src/fn_ctxt/check.rs` (see #107746).\n\nHowever, that's no longer the case, so the FIXME suggesting they be made private can now be implemented.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "html_url": "https://github.com/rust-lang/rust/commit/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4378369b6ad92ec89f45906bc7240e3837ffdde1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4378369b6ad92ec89f45906bc7240e3837ffdde1", "html_url": "https://github.com/rust-lang/rust/commit/4378369b6ad92ec89f45906bc7240e3837ffdde1"}, {"sha": "d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e", "html_url": "https://github.com/rust-lang/rust/commit/d4d1cc4db6e0fb1f5427fcbece7b04bfb7952d9e"}], "stats": {"total": 62, "additions": 30, "deletions": 32}, "files": [{"sha": "7534e432f1198aa411cd581da42afe9813a64eba", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cfcca629fe53f81ab312eeabb6d0efc5151a9bd/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=2cfcca629fe53f81ab312eeabb6d0efc5151a9bd", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+                find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -356,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .filter(|(_, ty)| find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n@@ -579,8 +579,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find out which of `in_ty_elements` refer to `param`.\n             // FIXME: It may be better to take the first if there are multiple,\n             // just so that the error points to a smaller expression.\n-            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n-                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            let Some((drill_expr, drill_ty)) = is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                find_param_in_ty((*in_ty_elem).into(), param)\n             })) else {\n                 // The param is not mentioned, or it is mentioned in multiple indexes.\n                 return Err(expr);\n@@ -628,10 +628,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -751,10 +751,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -793,14 +793,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //     outer contextual information.\n \n             // (1) Find the (unique) field index which mentions the type in our constraint:\n-            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+            let Some((field_index, field_type)) = is_iterator_singleton(\n                 in_ty_adt\n                     .variant_with_id(variant_def_id)\n                     .fields\n                     .iter()\n                     .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n                     .enumerate()\n-                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+                    .filter(|(_index, field_type)| find_param_in_ty((*field_type).into(), param))\n             ) else {\n                 return Err(expr);\n             };\n@@ -833,20 +833,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         Err(expr)\n     }\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n-    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n-    pub fn find_param_in_ty(\n-        ty: ty::GenericArg<'tcx>,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-    ) -> bool {\n-        let mut walk = ty.walk();\n-        while let Some(arg) = walk.next() {\n-            if arg == param_to_point_at {\n-                return true;\n-            }\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+/// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+/// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+fn find_param_in_ty<'tcx>(\n+    ty: ty::GenericArg<'tcx>,\n+    param_to_point_at: ty::GenericArg<'tcx>,\n+) -> bool {\n+    let mut walk = ty.walk();\n+    while let Some(arg) = walk.next() {\n+        if arg == param_to_point_at {\n+            return true;\n+        }\n+        if let ty::GenericArgKind::Type(ty) = arg.unpack()\n                 && let ty::Alias(ty::Projection, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n@@ -857,16 +857,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // in some UI tests.\n                 walk.skip_current_subtree();\n             }\n-        }\n-        false\n     }\n+    false\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n-    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n-        match (iterator.next(), iterator.next()) {\n-            (_, Some(_)) => None,\n-            (first, _) => first,\n-        }\n+/// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+    match (iterator.next(), iterator.next()) {\n+        (_, Some(_)) => None,\n+        (first, _) => first,\n     }\n }"}]}