{"sha": "0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYTQ5ZGNmMTM1MmJjMDM4YmIzMmMxYTdiYzFhYzFiZTUwZDU0MWM=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-09T14:20:13Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-12T15:02:44Z"}, "message": "Deprecate Bounded trait", "tree": {"sha": "9a8685c01cde12db04355e00b312b0cfab7f2eff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a8685c01cde12db04355e00b312b0cfab7f2eff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "html_url": "https://github.com/rust-lang/rust/commit/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e51cc089da7f5a067d348ee48f494c5bca662f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/e51cc089da7f5a067d348ee48f494c5bca662f95", "html_url": "https://github.com/rust-lang/rust/commit/e51cc089da7f5a067d348ee48f494c5bca662f95"}], "stats": {"total": 157, "additions": 91, "deletions": 66}, "files": [{"sha": "70c3b03a0a26e6c0b29e60ad3e349ab9ca476ee6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "patch": "@@ -177,9 +177,15 @@ impl Float for f32 {\n     #[inline]\n     fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n+    #[inline]\n+    fn min_value() -> f32 { MIN_VALUE }\n+\n     #[inline]\n     fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n \n+    #[inline]\n+    fn max_value() -> f32 { MAX_VALUE }\n+\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe { mem::transmute(self) };"}, {"sha": "538885f0d296707eb8d20db0058eda472bdd8a6b", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "patch": "@@ -183,9 +183,15 @@ impl Float for f64 {\n     #[inline]\n     fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n \n+    #[inline]\n+    fn min_value() -> f64 { MIN_VALUE }\n+\n     #[inline]\n     fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n \n+    #[inline]\n+    fn max_value() -> f64 { MAX_VALUE }\n+\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe { mem::transmute(self) };"}, {"sha": "d686d53704a72d2f3eb3b0b2d6089f9bc91dda53", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 74, "deletions": 57, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "patch": "@@ -296,65 +296,35 @@ pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n     }\n }\n \n-/// Numbers which have upper and lower bounds\n-pub trait Bounded {\n-    // FIXME (#5527): These should be associated constants\n-    /// returns the smallest finite number this type can represent\n-    fn min_value() -> Self;\n-    /// returns the largest finite number this type can represent\n-    fn max_value() -> Self;\n-}\n-\n-macro_rules! bounded_impl(\n-    ($t:ty, $min:expr, $max:expr) => {\n-        impl Bounded for $t {\n-            #[inline]\n-            fn min_value() -> $t { $min }\n-\n-            #[inline]\n-            fn max_value() -> $t { $max }\n-        }\n-    }\n-)\n-\n-bounded_impl!(uint, uint::MIN, uint::MAX)\n-bounded_impl!(u8, u8::MIN, u8::MAX)\n-bounded_impl!(u16, u16::MIN, u16::MAX)\n-bounded_impl!(u32, u32::MIN, u32::MAX)\n-bounded_impl!(u64, u64::MIN, u64::MAX)\n-\n-bounded_impl!(int, int::MIN, int::MAX)\n-bounded_impl!(i8, i8::MIN, i8::MAX)\n-bounded_impl!(i16, i16::MIN, i16::MAX)\n-bounded_impl!(i32, i32::MIN, i32::MAX)\n-bounded_impl!(i64, i64::MIN, i64::MAX)\n-\n-bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n-bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)\n-\n /// Specifies the available operations common to all of Rust's core numeric primitives.\n /// These may not always make sense from a purely mathematical point of view, but\n /// may be useful for systems programming.\n pub trait Primitive: Copy\n                    + Clone\n                    + Num\n                    + NumCast\n-                   + PartialOrd\n-                   + Bounded {}\n+                   + PartialOrd {}\n \n trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n \n /// A primitive signed or unsigned integer equipped with various bitwise\n /// operators, bit counting methods, and endian conversion functions.\n pub trait Int: Primitive\n              + Ord\n-             + Bounded\n              + Not<Self>\n              + BitAnd<Self,Self>\n              + BitOr<Self,Self>\n              + BitXor<Self,Self>\n              + Shl<uint,Self>\n              + Shr<uint,Self> {\n+    /// Returns the smallest value that can be represented by this integer.\n+    // FIXME (#5527): Should be and associated constant\n+    fn min_value() -> Self;\n+\n+    /// Returns the largest value that can be represented by this integer.\n+    // FIXME (#5527): Should be and associated constant\n+    fn max_value() -> Self;\n+\n     /// Returns the number of ones in the binary representation of the integer.\n     ///\n     /// # Example\n@@ -582,8 +552,8 @@ pub trait Int: Primitive\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n             Some(x)                       => x,\n-            None if other >= Zero::zero() => Bounded::max_value(),\n-            None                          => Bounded::min_value(),\n+            None if other >= Zero::zero() => Int::max_value(),\n+            None                          => Int::min_value(),\n         }\n     }\n \n@@ -593,8 +563,8 @@ pub trait Int: Primitive\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n             Some(x)                       => x,\n-            None if other >= Zero::zero() => Bounded::min_value(),\n-            None                          => Bounded::max_value(),\n+            None if other >= Zero::zero() => Int::min_value(),\n+            None                          => Int::max_value(),\n         }\n     }\n }\n@@ -616,6 +586,12 @@ macro_rules! uint_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         impl Int for $T {\n+            #[inline]\n+            fn min_value() -> $T { 0 }\n+\n+            #[inline]\n+            fn max_value() -> $T { -1 }\n+\n             #[inline]\n             fn count_ones(self) -> uint { unsafe { $ctpop(self as $ActualT) as uint } }\n \n@@ -729,11 +705,17 @@ uint_impl!(uint = u64, 64,\n     intrinsics::u64_mul_with_overflow)\n \n macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty,\n+    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         impl Int for $T {\n+            #[inline]\n+            fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n+\n+            #[inline]\n+            fn max_value() -> $T { let min: $T = Int::min_value(); !min }\n+\n             #[inline]\n             fn count_ones(self) -> uint { (self as $UnsignedT).count_ones() }\n \n@@ -771,7 +753,7 @@ macro_rules! int_impl {\n             fn checked_div(self, v: $T) -> Option<$T> {\n                 match v {\n                     0   => None,\n-                   -1 if self == Bounded::min_value()\n+                   -1 if self == Int::min_value()\n                         => None,\n                     v   => Some(self / v),\n                 }\n@@ -780,34 +762,34 @@ macro_rules! int_impl {\n     }\n }\n \n-int_impl!(i8 = i8, u8,\n+int_impl!(i8 = i8, u8, 8,\n     intrinsics::i8_add_with_overflow,\n     intrinsics::i8_sub_with_overflow,\n     intrinsics::i8_mul_with_overflow)\n \n-int_impl!(i16 = i16, u16,\n+int_impl!(i16 = i16, u16, 16,\n     intrinsics::i16_add_with_overflow,\n     intrinsics::i16_sub_with_overflow,\n     intrinsics::i16_mul_with_overflow)\n \n-int_impl!(i32 = i32, u32,\n+int_impl!(i32 = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n     intrinsics::i32_mul_with_overflow)\n \n-int_impl!(i64 = i64, u64,\n+int_impl!(i64 = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow)\n \n #[cfg(target_word_size = \"32\")]\n-int_impl!(int = i32, u32,\n+int_impl!(int = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n     intrinsics::i32_mul_with_overflow)\n \n #[cfg(target_word_size = \"64\")]\n-int_impl!(int = i64, u64,\n+int_impl!(int = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow)\n@@ -930,8 +912,8 @@ macro_rules! impl_to_primitive_int_to_int(\n                 Some($slf as $DstT)\n             } else {\n                 let n = $slf as i64;\n-                let min_value: $DstT = Bounded::min_value();\n-                let max_value: $DstT = Bounded::max_value();\n+                let min_value: $DstT = Int::min_value();\n+                let max_value: $DstT = Int::max_value();\n                 if min_value as i64 <= n && n <= max_value as i64 {\n                     Some($slf as $DstT)\n                 } else {\n@@ -946,7 +928,7 @@ macro_rules! impl_to_primitive_int_to_uint(\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             let zero: $SrcT = Zero::zero();\n-            let max_value: $DstT = Bounded::max_value();\n+            let max_value: $DstT = Int::max_value();\n             if zero <= $slf && $slf as u64 <= max_value as u64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -998,7 +980,7 @@ impl_to_primitive_int!(i64)\n macro_rules! impl_to_primitive_uint_to_int(\n     ($DstT:ty, $slf:expr) => (\n         {\n-            let max_value: $DstT = Bounded::max_value();\n+            let max_value: $DstT = Int::max_value();\n             if $slf as u64 <= max_value as u64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -1015,7 +997,7 @@ macro_rules! impl_to_primitive_uint_to_uint(\n                 Some($slf as $DstT)\n             } else {\n                 let zero: $SrcT = Zero::zero();\n-                let max_value: $DstT = Bounded::max_value();\n+                let max_value: $DstT = Int::max_value();\n                 if zero <= $slf && $slf as u64 <= max_value as u64 {\n                     Some($slf as $DstT)\n                 } else {\n@@ -1071,7 +1053,7 @@ macro_rules! impl_to_primitive_float_to_float(\n             Some($slf as $DstT)\n         } else {\n             let n = $slf as f64;\n-            let max_value: $SrcT = Bounded::max_value();\n+            let max_value: $SrcT = Float::max_value();\n             if -max_value as f64 <= n && n <= max_value as f64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -1400,8 +1382,12 @@ pub trait Float: Signed + Primitive {\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the smallest finite value that this type can represent.\n+    fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n+    /// Returns the largest finite value that this type can represent.\n+    fn max_value() -> Self;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n@@ -1515,3 +1501,34 @@ pub fn is_power_of_two<T: UnsignedInt>(n: T) -> bool {\n pub fn checked_next_power_of_two<T: UnsignedInt>(n: T) -> Option<T> {\n     n.checked_next_power_of_two()\n }\n+\n+#[deprecated = \"Generalised bounded values are no longer supported\"]\n+pub trait Bounded {\n+    #[deprecated = \"Use `Int::min_value` or `Float::min_value`\"]\n+    fn min_value() -> Self;\n+    #[deprecated = \"Use `Int::max_value` or `Float::max_value`\"]\n+    fn max_value() -> Self;\n+}\n+macro_rules! bounded_impl {\n+    ($T:ty, $min:expr, $max:expr) => {\n+        impl Bounded for $T {\n+            #[inline]\n+            fn min_value() -> $T { $min }\n+\n+            #[inline]\n+            fn max_value() -> $T { $max }\n+        }\n+    };\n+}\n+bounded_impl!(uint, uint::MIN, uint::MAX)\n+bounded_impl!(u8, u8::MIN, u8::MAX)\n+bounded_impl!(u16, u16::MIN, u16::MAX)\n+bounded_impl!(u32, u32::MIN, u32::MAX)\n+bounded_impl!(u64, u64::MIN, u64::MAX)\n+bounded_impl!(int, int::MIN, int::MAX)\n+bounded_impl!(i8, i8::MIN, i8::MAX)\n+bounded_impl!(i16, i16::MIN, i16::MAX)\n+bounded_impl!(i32, i32::MIN, i32::MAX)\n+bounded_impl!(i64, i64::MIN, i64::MAX)\n+bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n+bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)"}, {"sha": "e2762759e5ee9d36bde07b57aee591aa11b902c0", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "patch": "@@ -13,7 +13,6 @@\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::*;\n-use core::num::Bounded;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -98,7 +97,7 @@ macro_rules! integer_impl {\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n                 let range = high as $unsigned - low as $unsigned;\n-                let unsigned_max: $unsigned = Bounded::max_value();\n+                let unsigned_max: $unsigned = Int::max_value();\n \n                 // this is the largest number that fits into $unsigned\n                 // that `range` divides evenly, so, if we've sampled\n@@ -166,7 +165,6 @@ mod tests {\n     use std::prelude::*;\n     use distributions::{Sample, IndependentSample};\n     use super::Range;\n-    use std::num::Bounded;\n \n     #[should_fail]\n     #[test]\n@@ -187,7 +185,7 @@ mod tests {\n                 $(\n                    let v: &[($ty, $ty)] = [(0, 10),\n                                            (10, 127),\n-                                           (Bounded::min_value(), Bounded::max_value())];\n+                                           (Int::min_value(), Int::max_value())];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in range(0u, 1000) {"}, {"sha": "2c6a56038d64e3543261f8e027d715f78a14953b", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "patch": "@@ -528,7 +528,6 @@ mod tests {\n     extern crate rand;\n \n     use super::{Digest, Sha256, FixedBuffer};\n-    use std::num::Bounded;\n     use self::rand::isaac::IsaacRng;\n     use self::rand::Rng;\n     use serialize::hex::FromHex;\n@@ -543,7 +542,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+        super::add_bytes_to_bits::<u64>(Int::max_value(), 1);\n     }\n \n     struct Test {"}, {"sha": "65d48dd94f3087ae15c1107684bfc83f8f457077", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da49dcf1352bc038bb32c1a7bc1ac1be50d541c/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=0da49dcf1352bc038bb32c1a7bc1ac1be50d541c", "patch": "@@ -17,8 +17,7 @@ use char::Char;\n use from_str::from_str;\n use iter::Iterator;\n use num;\n-use num::{Int, Bounded};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n use str::StrPrelude;\n@@ -581,7 +580,7 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n \n     let _0: T = num::zero();\n     let _1: T = num::one();\n-    let is_signed = _0 > Bounded::min_value();\n+    let is_signed = _0 > Int::min_value();\n \n     let (is_positive, src) =  match src.slice_shift_char() {\n         (Some('-'), src) if is_signed => (false, src),"}]}