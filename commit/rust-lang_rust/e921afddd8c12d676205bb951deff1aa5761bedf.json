{"sha": "e921afddd8c12d676205bb951deff1aa5761bedf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MjFhZmRkZDhjMTJkNjc2MjA1YmI5NTFkZWZmMWFhNTc2MWJlZGY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-04T23:42:51Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-05T22:01:05Z"}, "message": "Stabilize core::ops\n\nThis commit marks as stable those parts of `core::ops` that are in their\nfinal planned form: `Drop`, all of the mathematical operators (`Add`,\n`Sub`, etc), `Deref`/`DerefMut`. It leaves the `Index*`, `Slice*` and\n`Fn*` traits unstable, as they are still undergoing active changes.", "tree": {"sha": "f9467aa25e5834b1626b9d8e065045f3d84fe181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9467aa25e5834b1626b9d8e065045f3d84fe181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e921afddd8c12d676205bb951deff1aa5761bedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e921afddd8c12d676205bb951deff1aa5761bedf", "html_url": "https://github.com/rust-lang/rust/commit/e921afddd8c12d676205bb951deff1aa5761bedf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e921afddd8c12d676205bb951deff1aa5761bedf/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ec47c9d2a75c8150d153450e7e7b7db60208dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/64ec47c9d2a75c8150d153450e7e7b7db60208dc", "html_url": "https://github.com/rust-lang/rust/commit/64ec47c9d2a75c8150d153450e7e7b7db60208dc"}], "stats": {"total": 70, "additions": 70, "deletions": 0}, "files": [{"sha": "da2e95832e71aa00a99c33693084707e0c53343c", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e921afddd8c12d676205bb951deff1aa5761bedf/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e921afddd8c12d676205bb951deff1aa5761bedf/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=e921afddd8c12d676205bb951deff1aa5761bedf", "patch": "@@ -59,6 +59,8 @@\n //! See the documentation for each trait for a minimum implementation that prints\n //! something to the screen.\n \n+#![stable]\n+\n use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use kinds::Sized;\n@@ -86,8 +88,10 @@ use option::Option::{self, Some, None};\n /// }\n /// ```\n #[lang=\"drop\"]\n+#[stable]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n+    #[stable]\n     fn drop(&mut self);\n }\n \n@@ -120,15 +124,19 @@ pub trait Drop {\n /// }\n /// ```\n #[lang=\"add\"]\n+#[stable]\n pub trait Add<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `+` operator\n+    #[stable]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Add for $t {\n             type Output = $t;\n \n@@ -169,15 +177,19 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n+#[stable]\n pub trait Sub<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `-` operator\n+    #[stable]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Sub for $t {\n             type Output = $t;\n \n@@ -218,15 +230,19 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n+#[stable]\n pub trait Mul<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `*` operator\n+    #[stable]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Mul for $t {\n             type Output = $t;\n \n@@ -267,15 +283,19 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n+#[stable]\n pub trait Div<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `/` operator\n+    #[stable]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Div for $t {\n             type Output = $t;\n \n@@ -316,15 +336,19 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n+#[stable]\n pub trait Rem<RHS=Self> {\n+    #[stable]\n     type Output = Self;\n \n     /// The method for the `%` operator\n+    #[stable]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -336,6 +360,7 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n+        #[stable]\n         impl Rem for $t {\n             type Output = $t;\n \n@@ -382,26 +407,33 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n+#[stable]\n pub trait Neg {\n+    #[stable]\n     type Output;\n \n     /// The method for the unary `-` operator\n+    #[stable]\n     fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Neg for $t {\n+            #[stable]\n             type Output = $t;\n \n             #[inline]\n+            #[stable]\n             fn neg(self) -> $t { -self }\n         }\n     )*)\n }\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n+        #[stable]\n         impl Neg for $t {\n             type Output = $t;\n \n@@ -450,15 +482,19 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n+#[stable]\n pub trait Not {\n+    #[stable]\n     type Output;\n \n     /// The method for the unary `!` operator\n+    #[stable]\n     fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Not for $t {\n             type Output = $t;\n \n@@ -499,15 +535,19 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n+#[stable]\n pub trait BitAnd<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `&` operator\n+    #[stable]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitAnd for $t {\n             type Output = $t;\n \n@@ -548,15 +588,19 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n+#[stable]\n pub trait BitOr<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `|` operator\n+    #[stable]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitOr for $t {\n             type Output = $t;\n \n@@ -597,15 +641,19 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n+#[stable]\n pub trait BitXor<RHS=Self> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `^` operator\n+    #[stable]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl BitXor for $t {\n             type Output = $t;\n \n@@ -646,15 +694,19 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n+#[stable]\n pub trait Shl<RHS> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `<<` operator\n+    #[stable]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n+        #[stable]\n         impl Shl<uint> for $t {\n             type Output = $t;\n \n@@ -697,10 +749,13 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shr\"]\n+#[stable]\n pub trait Shr<RHS> {\n+    #[stable]\n     type Output;\n \n     /// The method for the `>>` operator\n+    #[stable]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n@@ -913,11 +968,13 @@ pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n /// An unbounded range.\n #[derive(Copy)]\n #[lang=\"full_range\"]\n+#[unstable = \"API still in development\"]\n pub struct FullRange;\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy)]\n #[lang=\"range\"]\n+#[unstable = \"API still in development\"]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n@@ -968,6 +1025,7 @@ impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n /// A range which is only bounded below.\n #[derive(Copy)]\n #[lang=\"range_from\"]\n+#[unstable = \"API still in development\"]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n@@ -988,6 +1046,7 @@ impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy)]\n #[lang=\"range_to\"]\n+#[unstable = \"API still in development\"]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n@@ -1025,19 +1084,24 @@ pub struct RangeTo<Idx> {\n /// }\n /// ```\n #[lang=\"deref\"]\n+#[stable]\n pub trait Deref for Sized? {\n+    #[stable]\n     type Sized? Target;\n \n     /// The method called to dereference a value\n+    #[stable]\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n+#[stable]\n impl<'a, Sized? T> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n+#[stable]\n impl<'a, Sized? T> Deref for &'a mut T {\n     type Target = T;\n \n@@ -1082,31 +1146,37 @@ impl<'a, Sized? T> Deref for &'a mut T {\n /// }\n /// ```\n #[lang=\"deref_mut\"]\n+#[stable]\n pub trait DerefMut for Sized? : Deref {\n     /// The method called to mutably dereference a value\n+    #[stable]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n }\n \n+#[stable]\n impl<'a, Sized? T> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait Fn<Args,Result> for Sized? {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait FnMut<Args,Result> for Sized? {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Result;\n }\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n+#[unstable = \"uncertain about variadic generics, input versus associated types\"]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;"}]}