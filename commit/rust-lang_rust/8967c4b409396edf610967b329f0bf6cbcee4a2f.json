{"sha": "8967c4b409396edf610967b329f0bf6cbcee4a2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NjdjNGI0MDkzOTZlZGY2MTA5NjdiMzI5ZjBiZjZjYmNlZTRhMmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-11T16:14:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-12T00:21:53Z"}, "message": "simplify demand module", "tree": {"sha": "60232d8d3871815ea95e5e250cc9fcfb470ecc36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60232d8d3871815ea95e5e250cc9fcfb470ecc36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8967c4b409396edf610967b329f0bf6cbcee4a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8967c4b409396edf610967b329f0bf6cbcee4a2f", "html_url": "https://github.com/rust-lang/rust/commit/8967c4b409396edf610967b329f0bf6cbcee4a2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8967c4b409396edf610967b329f0bf6cbcee4a2f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "html_url": "https://github.com/rust-lang/rust/commit/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb"}], "stats": {"total": 87, "additions": 23, "deletions": 64}, "files": [{"sha": "add63e357e2288aa09d7b36599c725f8dcfbc9aa", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 23, "deletions": 64, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8967c4b409396edf610967b329f0bf6cbcee4a2f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8967c4b409396edf610967b329f0bf6cbcee4a2f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=8967c4b409396edf610967b329f0bf6cbcee4a2f", "patch": "@@ -1402,59 +1402,13 @@ fn require_same_types(\n }\n \n mod demand {\n-    fn simple(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) ->\n-       ty::t {\n-        full(fcx, sp, unify::unify, expected, actual, []).ty\n-    }\n-\n-    // n.b.: order of arguments is reversed.\n-    fn subty(fcx: @fn_ctxt, sp: span, actual: ty::t, expected: ty::t) {\n-        full(fcx, sp, unify::unify, expected, actual, []);\n-    }\n-\n-    fn with_substs(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t,\n-                   ty_param_substs_0: [ty::t]) -> ty_param_substs_and_ty {\n-        full(fcx, sp, unify::unify, expected, actual, ty_param_substs_0)\n-    }\n-\n     // Requires that the two types unify, and prints an error message if they\n-    // don't. Returns the unified type and the type parameter substitutions.\n-    fn full(fcx: @fn_ctxt,\n-            sp: span,\n-            unifier: fn@(@fn_ctxt, ty::t, ty::t)\n-                -> result<(), ty::type_err>,\n-            expected: ty::t,\n-            actual: ty::t,\n-            ty_param_substs_0: [ty::t]) ->\n-       ty_param_substs_and_ty {\n-\n-        let mut ty_param_substs: [mut ty::t] = [mut];\n-        let mut ty_param_subst_var_ids: [ty_vid] = [];\n-        for ty_param_substs_0.each {|ty_param_subst|\n-            // Generate a type variable and unify it with the type parameter\n-            // substitution. We will then pull out these type variables.\n-            let t_0 = next_ty_var(fcx);\n-            ty_param_substs += [mut t_0];\n-            ty_param_subst_var_ids += [ty::ty_var_id(t_0)];\n-            simple(fcx, sp, ty_param_subst, t_0);\n-        }\n-\n-        fn mk_result(fcx: @fn_ctxt, result_ty: ty::t,\n-                     ty_param_subst_var_ids: [ty_vid]) ->\n-           ty_param_substs_and_ty {\n-            let mut result_ty_param_substs: [ty::t] = [];\n-            for ty_param_subst_var_ids.each {|var_id|\n-                let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n-                result_ty_param_substs += [tp_subst];\n-            }\n-            ret {substs: result_ty_param_substs, ty: result_ty};\n-        }\n+    // don't.\n+    fn simple(fcx: @fn_ctxt, sp: span,\n+              expected: ty::t, actual: ty::t) {\n \n-\n-        alt unifier(fcx, expected, actual) {\n-          result::ok(()) {\n-            ret mk_result(fcx, expected, ty_param_subst_var_ids);\n-          }\n+        alt infer::mk_subty(fcx.infcx, actual, expected) {\n+          result::ok(()) { /* ok */ }\n           result::err(err) {\n             fcx.ccx.tcx.sess.span_err(sp,\n                                       \"mismatched types: expected `\" +\n@@ -1465,7 +1419,6 @@ mod demand {\n                                       ty::type_err_to_str(\n                                           fcx.ccx.tcx, err) +\n                                       \")\");\n-            ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n         }\n     }\n@@ -1938,20 +1891,27 @@ fn universally_quantify_before_call(\n \n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                      subpats: [@ast::pat], expected: ty::t) {\n+\n     // Typecheck the path.\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n+\n+    // Lookup the enum and variant def ids:\n     let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n     let v_def_ids = ast_util::variant_def_ids(v_def);\n-    let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n-    instantiate_path(pcx.fcx, path, ctor_tpt, pat.span, pat.id);\n+\n+    // Assign the pattern the type of the *enum*, not the variant.\n+    let enum_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n+    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n \n     // Take the enum type params out of `expected`.\n     alt structure_of(pcx.fcx, pat.span, expected) {\n       ty::ty_enum(_, expected_tps) {\n-        let ctor_ty = fcx.node_ty(pat.id);\n-        demand::with_substs(pcx.fcx, pat.span, expected, ctor_ty,\n-                            expected_tps);\n+        // check that the type of the value being matched is a subtype\n+        // of the type of the pattern:\n+        let pat_ty = fcx.node_ty(pat.id);\n+        demand::simple(fcx, pat.span, pat_ty, expected);\n+\n         // Get the number of arguments in this enum variant.\n         let arg_types = variant_arg_types(pcx.fcx.ccx, pat.span,\n                                           v_def_ids.var, expected_tps);\n@@ -2029,12 +1989,12 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       if !pat_util::pat_is_variant(tcx.def_map, pat) {\n         let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n-        typ = demand::simple(pcx.fcx, pat.span, expected, typ);\n+        demand::simple(pcx.fcx, pat.span, expected, typ);\n         let canon_id = pcx.map.get(path_to_ident(name));\n         if canon_id != pat.id {\n             let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n             let ct = ty::mk_var(tcx, tv_id);\n-            typ = demand::simple(pcx.fcx, pat.span, ct, typ);\n+            demand::simple(pcx.fcx, pat.span, ct, typ);\n         }\n         fcx.write_ty(pat.id, typ);\n         alt sub {\n@@ -2203,12 +2163,11 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n     }\n }\n \n-type unifier = fn@(@fn_ctxt, span, ty::t, ty::t) -> ty::t;\n+type unifier = fn@(@fn_ctxt, span, ty::t, ty::t);\n \n fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n-    fn dummy_unify(_fcx: @fn_ctxt, _sp: span, _expected: ty::t, actual: ty::t)\n-       -> ty::t {\n-        actual\n+    fn dummy_unify(_fcx: @fn_ctxt, _sp: span,\n+                   _expected: ty::t, _actual: ty::t) {\n     }\n     ret check_expr_with_unifier(fcx, expr, dummy_unify,\n                                 ty::mk_nil(fcx.ccx.tcx));\n@@ -3139,7 +3098,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n             if !check_block(fcx, arm.body) { arm_non_bot = true; }\n             let bty = fcx.node_ty(arm.body.node.id);\n-            result_ty = demand::simple(fcx, arm.body.span, result_ty, bty);\n+            demand::simple(fcx, arm.body.span, result_ty, bty);\n         }\n         bot |= !arm_non_bot;\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }"}]}