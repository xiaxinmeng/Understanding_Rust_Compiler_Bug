{"sha": "66e0c9f840bc60fa132b285312136293301cc2c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTBjOWY4NDBiYzYwZmExMzJiMjg1MzEyMTM2MjkzMzAxY2MyYzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-21T11:15:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-21T11:15:56Z"}, "message": "Remove expect crate", "tree": {"sha": "f2204e7ed797079dcdbf3007a5505fbf9d379181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2204e7ed797079dcdbf3007a5505fbf9d379181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e0c9f840bc60fa132b285312136293301cc2c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e0c9f840bc60fa132b285312136293301cc2c0", "html_url": "https://github.com/rust-lang/rust/commit/66e0c9f840bc60fa132b285312136293301cc2c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e0c9f840bc60fa132b285312136293301cc2c0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "844e1aa725cbc26ec8a4221bd5412bd28238544c", "url": "https://api.github.com/repos/rust-lang/rust/commits/844e1aa725cbc26ec8a4221bd5412bd28238544c", "html_url": "https://github.com/rust-lang/rust/commit/844e1aa725cbc26ec8a4221bd5412bd28238544c"}], "stats": {"total": 371, "additions": 0, "deletions": 371}, "files": [{"sha": "b54d3a60e300e48e208623126cea2b80a74d95be", "filename": "crates/expect/Cargo.toml", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/844e1aa725cbc26ec8a4221bd5412bd28238544c/crates%2Fexpect%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/844e1aa725cbc26ec8a4221bd5412bd28238544c/crates%2Fexpect%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2FCargo.toml?ref=844e1aa725cbc26ec8a4221bd5412bd28238544c", "patch": "@@ -1,15 +0,0 @@\n-[package]\n-name = \"expect\"\n-version = \"0.0.0\"\n-license = \"MIT OR Apache-2.0\"\n-authors = [\"rust-analyzer developers\"]\n-edition = \"2018\"\n-\n-[lib]\n-doctest = false\n-\n-[dependencies]\n-once_cell = \"1\"\n-difference = \"2\"\n-\n-stdx = { path = \"../stdx\" }"}, {"sha": "bd83895f78251f2ecac9cba72a3fd64e46ce31dd", "filename": "crates/expect/src/lib.rs", "status": "removed", "additions": 0, "deletions": 356, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/844e1aa725cbc26ec8a4221bd5412bd28238544c/crates%2Fexpect%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/844e1aa725cbc26ec8a4221bd5412bd28238544c/crates%2Fexpect%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2Fsrc%2Flib.rs?ref=844e1aa725cbc26ec8a4221bd5412bd28238544c", "patch": "@@ -1,356 +0,0 @@\n-//! Snapshot testing library, see\n-//! https://github.com/rust-analyzer/rust-analyzer/pull/5101\n-use std::{\n-    collections::HashMap,\n-    env, fmt, fs, mem,\n-    ops::Range,\n-    panic,\n-    path::{Path, PathBuf},\n-    sync::Mutex,\n-};\n-\n-use difference::Changeset;\n-use once_cell::sync::Lazy;\n-use stdx::{lines_with_ends, trim_indent};\n-\n-const HELP: &str = \"\n-You can update all `expect![[]]` tests by running:\n-\n-    env UPDATE_EXPECT=1 cargo test\n-\n-To update a single test, place the cursor on `expect` token and use `run` feature of rust-analyzer.\n-\";\n-\n-fn update_expect() -> bool {\n-    env::var(\"UPDATE_EXPECT\").is_ok()\n-}\n-\n-/// expect![[r#\"inline snapshot\"#]]\n-#[macro_export]\n-macro_rules! expect {\n-    [[$data:literal]] => {$crate::Expect {\n-        position: $crate::Position {\n-            file: file!(),\n-            line: line!(),\n-            column: column!(),\n-        },\n-        data: $data,\n-    }};\n-    [[]] => { $crate::expect![[\"\"]] };\n-}\n-\n-/// expect_file![\"/crates/foo/test_data/bar.html\"]\n-#[macro_export]\n-macro_rules! expect_file {\n-    [$path:expr] => {$crate::ExpectFile {\n-        path: std::path::PathBuf::from($path)\n-    }};\n-}\n-\n-#[derive(Debug)]\n-pub struct Expect {\n-    pub position: Position,\n-    pub data: &'static str,\n-}\n-\n-#[derive(Debug)]\n-pub struct ExpectFile {\n-    pub path: PathBuf,\n-}\n-\n-#[derive(Debug)]\n-pub struct Position {\n-    pub file: &'static str,\n-    pub line: u32,\n-    pub column: u32,\n-}\n-\n-impl fmt::Display for Position {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}:{}:{}\", self.file, self.line, self.column)\n-    }\n-}\n-\n-impl Expect {\n-    pub fn assert_eq(&self, actual: &str) {\n-        let trimmed = self.trimmed();\n-        if trimmed == actual {\n-            return;\n-        }\n-        Runtime::fail_expect(self, &trimmed, actual);\n-    }\n-    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n-        let actual = format!(\"{:#?}\\n\", actual);\n-        self.assert_eq(&actual)\n-    }\n-\n-    fn trimmed(&self) -> String {\n-        if !self.data.contains('\\n') {\n-            return self.data.to_string();\n-        }\n-        trim_indent(self.data)\n-    }\n-\n-    fn locate(&self, file: &str) -> Location {\n-        let mut target_line = None;\n-        let mut line_start = 0;\n-        for (i, line) in lines_with_ends(file).enumerate() {\n-            if i == self.position.line as usize - 1 {\n-                let pat = \"expect![[\";\n-                let offset = line.find(pat).unwrap();\n-                let literal_start = line_start + offset + pat.len();\n-                let indent = line.chars().take_while(|&it| it == ' ').count();\n-                target_line = Some((literal_start, indent));\n-                break;\n-            }\n-            line_start += line.len();\n-        }\n-        let (literal_start, line_indent) = target_line.unwrap();\n-        let literal_length =\n-            file[literal_start..].find(\"]]\").expect(\"Couldn't find matching `]]` for `expect![[`.\");\n-        let literal_range = literal_start..literal_start + literal_length;\n-        Location { line_indent, literal_range }\n-    }\n-}\n-\n-impl ExpectFile {\n-    pub fn assert_eq(&self, actual: &str) {\n-        let expected = self.read();\n-        if actual == expected {\n-            return;\n-        }\n-        Runtime::fail_file(self, &expected, actual);\n-    }\n-    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n-        let actual = format!(\"{:#?}\\n\", actual);\n-        self.assert_eq(&actual)\n-    }\n-    fn read(&self) -> String {\n-        fs::read_to_string(self.abs_path()).unwrap_or_default().replace(\"\\r\\n\", \"\\n\")\n-    }\n-    fn write(&self, contents: &str) {\n-        fs::write(self.abs_path(), contents).unwrap()\n-    }\n-    fn abs_path(&self) -> PathBuf {\n-        WORKSPACE_ROOT.join(&self.path)\n-    }\n-}\n-\n-#[derive(Default)]\n-struct Runtime {\n-    help_printed: bool,\n-    per_file: HashMap<&'static str, FileRuntime>,\n-}\n-static RT: Lazy<Mutex<Runtime>> = Lazy::new(Default::default);\n-\n-impl Runtime {\n-    fn fail_expect(expect: &Expect, expected: &str, actual: &str) {\n-        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n-        if update_expect() {\n-            println!(\"\\x1b[1m\\x1b[92mupdating\\x1b[0m: {}\", expect.position);\n-            rt.per_file\n-                .entry(expect.position.file)\n-                .or_insert_with(|| FileRuntime::new(expect))\n-                .update(expect, actual);\n-            return;\n-        }\n-        rt.panic(expect.position.to_string(), expected, actual);\n-    }\n-\n-    fn fail_file(expect: &ExpectFile, expected: &str, actual: &str) {\n-        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n-        if update_expect() {\n-            println!(\"\\x1b[1m\\x1b[92mupdating\\x1b[0m: {}\", expect.path.display());\n-            expect.write(actual);\n-            return;\n-        }\n-        rt.panic(expect.path.display().to_string(), expected, actual);\n-    }\n-\n-    fn panic(&mut self, position: String, expected: &str, actual: &str) {\n-        let print_help = !mem::replace(&mut self.help_printed, true);\n-        let help = if print_help { HELP } else { \"\" };\n-\n-        let diff = Changeset::new(actual, expected, \"\\n\");\n-\n-        println!(\n-            \"\\n\n-\\x1b[1m\\x1b[91merror\\x1b[97m: expect test failed\\x1b[0m\n-   \\x1b[1m\\x1b[34m-->\\x1b[0m {}\n-{}\n-\\x1b[1mExpect\\x1b[0m:\n-----\n-{}\n-----\n-\n-\\x1b[1mActual\\x1b[0m:\n-----\n-{}\n-----\n-\n-\\x1b[1mDiff\\x1b[0m:\n-----\n-{}\n-----\n-\",\n-            position, help, expected, actual, diff\n-        );\n-        // Use resume_unwind instead of panic!() to prevent a backtrace, which is unnecessary noise.\n-        panic::resume_unwind(Box::new(()));\n-    }\n-}\n-\n-struct FileRuntime {\n-    path: PathBuf,\n-    original_text: String,\n-    patchwork: Patchwork,\n-}\n-\n-impl FileRuntime {\n-    fn new(expect: &Expect) -> FileRuntime {\n-        let path = WORKSPACE_ROOT.join(expect.position.file);\n-        let original_text = fs::read_to_string(&path).unwrap();\n-        let patchwork = Patchwork::new(original_text.clone());\n-        FileRuntime { path, original_text, patchwork }\n-    }\n-    fn update(&mut self, expect: &Expect, actual: &str) {\n-        let loc = expect.locate(&self.original_text);\n-        let patch = format_patch(loc.line_indent.clone(), actual);\n-        self.patchwork.patch(loc.literal_range, &patch);\n-        fs::write(&self.path, &self.patchwork.text).unwrap()\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct Location {\n-    line_indent: usize,\n-    literal_range: Range<usize>,\n-}\n-\n-#[derive(Debug)]\n-struct Patchwork {\n-    text: String,\n-    indels: Vec<(Range<usize>, usize)>,\n-}\n-\n-impl Patchwork {\n-    fn new(text: String) -> Patchwork {\n-        Patchwork { text, indels: Vec::new() }\n-    }\n-    fn patch(&mut self, mut range: Range<usize>, patch: &str) {\n-        self.indels.push((range.clone(), patch.len()));\n-        self.indels.sort_by_key(|(delete, _insert)| delete.start);\n-\n-        let (delete, insert) = self\n-            .indels\n-            .iter()\n-            .take_while(|(delete, _)| delete.start < range.start)\n-            .map(|(delete, insert)| (delete.end - delete.start, insert))\n-            .fold((0usize, 0usize), |(x1, y1), (x2, y2)| (x1 + x2, y1 + y2));\n-\n-        for pos in &mut [&mut range.start, &mut range.end] {\n-            **pos -= delete;\n-            **pos += insert;\n-        }\n-\n-        self.text.replace_range(range, &patch);\n-    }\n-}\n-\n-fn format_patch(line_indent: usize, patch: &str) -> String {\n-    let mut max_hashes = 0;\n-    let mut cur_hashes = 0;\n-    for byte in patch.bytes() {\n-        if byte != b'#' {\n-            cur_hashes = 0;\n-            continue;\n-        }\n-        cur_hashes += 1;\n-        max_hashes = max_hashes.max(cur_hashes);\n-    }\n-    let hashes = &\"#\".repeat(max_hashes + 1);\n-    let indent = &\" \".repeat(line_indent);\n-    let is_multiline = patch.contains('\\n');\n-\n-    let mut buf = String::new();\n-    buf.push('r');\n-    buf.push_str(hashes);\n-    buf.push('\"');\n-    if is_multiline {\n-        buf.push('\\n');\n-    }\n-    let mut final_newline = false;\n-    for line in lines_with_ends(patch) {\n-        if is_multiline && !line.trim().is_empty() {\n-            buf.push_str(indent);\n-            buf.push_str(\"    \");\n-        }\n-        buf.push_str(line);\n-        final_newline = line.ends_with('\\n');\n-    }\n-    if final_newline {\n-        buf.push_str(indent);\n-    }\n-    buf.push('\"');\n-    buf.push_str(hashes);\n-    buf\n-}\n-\n-static WORKSPACE_ROOT: Lazy<PathBuf> = Lazy::new(|| {\n-    let my_manifest =\n-        env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned());\n-    // Heuristic, see https://github.com/rust-lang/cargo/issues/3946\n-    Path::new(&my_manifest)\n-        .ancestors()\n-        .filter(|it| it.join(\"Cargo.toml\").exists())\n-        .last()\n-        .unwrap()\n-        .to_path_buf()\n-});\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_format_patch() {\n-        let patch = format_patch(0, \"hello\\nworld\\n\");\n-        expect![[r##\"\n-            r#\"\n-                hello\n-                world\n-            \"#\"##]]\n-        .assert_eq(&patch);\n-\n-        let patch = format_patch(4, \"single line\");\n-        expect![[r##\"r#\"single line\"#\"##]].assert_eq(&patch);\n-    }\n-\n-    #[test]\n-    fn test_patchwork() {\n-        let mut patchwork = Patchwork::new(\"one two three\".to_string());\n-        patchwork.patch(4..7, \"zwei\");\n-        patchwork.patch(0..3, \"\u043e\u0434\u0438\u043d\");\n-        patchwork.patch(8..13, \"3\");\n-        expect![[r#\"\n-            Patchwork {\n-                text: \"\u043e\u0434\u0438\u043d zwei 3\",\n-                indels: [\n-                    (\n-                        0..3,\n-                        8,\n-                    ),\n-                    (\n-                        4..7,\n-                        4,\n-                    ),\n-                    (\n-                        8..13,\n-                        1,\n-                    ),\n-                ],\n-            }\n-        \"#]]\n-        .assert_debug_eq(&patchwork);\n-    }\n-}"}]}