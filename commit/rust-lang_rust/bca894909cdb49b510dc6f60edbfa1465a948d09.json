{"sha": "bca894909cdb49b510dc6f60edbfa1465a948d09", "node_id": "C_kwDOAAsO6NoAKGJjYTg5NDkwOWNkYjQ5YjUxMGRjNmY2MGVkYmZhMTQ2NWE5NDhkMDk", "commit": {"author": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2022-06-17T09:15:24Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2022-07-05T18:18:19Z"}, "message": "Split TypeVisitable from TypeFoldable", "tree": {"sha": "8e16455915baf3c9257c060be48a0a16ae11831f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e16455915baf3c9257c060be48a0a16ae11831f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca894909cdb49b510dc6f60edbfa1465a948d09", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEm/Nz5g9hEBdpmKVOB8rDzKfgZD8FAmLEgGsACgkQB8rDzKfg\nZD+0Rw//W20lDIByxt298oV9QGPv232BwBla+Cd5nhQuIIuB9qN1+CRJHFuKc2We\nSTv2g4sKB0q+LG1ouiG0jTGR0tweZeADU6moDd3xdkvzVT0n4+wx8YiReuJoW+dt\nGgGF9f+P3NotB47ZNMDXVZfKjyulxqYrcFgiF7WY+4UpDgIpbD4SWU+Q2iCi2/Oa\nCN8+51AtBJkynhUtrLXmIgaATMGdi2e9xU7xVcZoHOBgNH5mx18lUCPMszixANP4\nUDpWZpJtpKOmkIMLAihiqg4sHS5NwGTC58l9aQvMZRiMGvCq7QV6A7llHSOIROWm\nJovBIUnD/nNRJAW1bg30/FIBZr+8R0KQxlLd+n7C7T+1/xSvKC6I79k69d9d486W\nF7uA4orcLyyJFkC4TL/X0EZek07TSxsvBC/6beenhFjRR+ZYdS5Ukncp2XEgFYBd\nC/F/28j2qpCacq+pTvBliyw+sY3DOxFhmJkKRPtlUnoEbfq0cNbiFmtWNvQ4bCQz\nLVjXpiDgh24VoqwbmwZiDbe6DcgRQoKm7mm/zp9y6glk8O5wayRjYxn0Y/ShsIKH\nOdnqI9Hls5S0jI+/hqmUkUNdGUsxwkwo3fR0sJFO1pAAha52XS4v72WPqbMOz9p6\nLNQBMlCGTZDoNtDQ4dUZuqWQDYAmaA8s64t+KE3olXOBnuqCnpk=\n=soMr\n-----END PGP SIGNATURE-----", "payload": "tree 8e16455915baf3c9257c060be48a0a16ae11831f\nparent efb171e2350de2bec6dd1f035b99bc00535c1c15\nauthor Alan Egerton <eggyal@gmail.com> 1655457324 +0100\ncommitter Alan Egerton <eggyal@gmail.com> 1657045099 +0100\n\nSplit TypeVisitable from TypeFoldable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca894909cdb49b510dc6f60edbfa1465a948d09", "html_url": "https://github.com/rust-lang/rust/commit/bca894909cdb49b510dc6f60edbfa1465a948d09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca894909cdb49b510dc6f60edbfa1465a948d09/comments", "author": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efb171e2350de2bec6dd1f035b99bc00535c1c15", "url": "https://api.github.com/repos/rust-lang/rust/commits/efb171e2350de2bec6dd1f035b99bc00535c1c15", "html_url": "https://github.com/rust-lang/rust/commit/efb171e2350de2bec6dd1f035b99bc00535c1c15"}], "stats": {"total": 1519, "additions": 783, "deletions": 736}, "files": [{"sha": "f8893ae29f58ee8eb0f7ae8f9e1d93fece10a516", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 35, "deletions": 733, "changes": 768, "blob_url": "https://github.com/rust-lang/rust/blob/bca894909cdb49b510dc6f60edbfa1465a948d09/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca894909cdb49b510dc6f60edbfa1465a948d09/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=bca894909cdb49b510dc6f60edbfa1465a948d09", "patch": "@@ -1,76 +1,60 @@\n-//! A generalized traversal mechanism for complex data structures that contain\n-//! type information.\n+//! A folding traversal mechanism for complex data structures that contain type\n+//! information.\n //!\n-//! There are two types of traversal.\n-//! - Folding. This is a modifying traversal. It consumes the data structure,\n-//!   producing a (possibly) modified version of it. Both fallible and\n-//!   infallible versions are available. The name is potentially\n-//!   confusing, because this traversal is more like `Iterator::map` than\n-//!   `Iterator::fold`.\n-//! - Visiting. This is a read-only traversal of the data structure.\n+//! This is a modifying traversal. It consumes the data structure, producing a\n+//! (possibly) modified version of it. Both fallible and infallible versions are\n+//! available. The name is potentially confusing, because this traversal is more\n+//! like `Iterator::map` than `Iterator::fold`.\n //!\n-//! These traversals have limited flexibility. Only a small number of \"types of\n+//! This traversal has limited flexibility. Only a small number of \"types of\n //! interest\" within the complex data structures can receive custom\n-//! modification (when folding) or custom visitation (when visiting). These are\n-//! the ones containing the most important type-related information, such as\n-//! `Ty`, `Predicate`, `Region`, and `Const`.\n+//! modification. These are the ones containing the most important type-related\n+//! information, such as `Ty`, `Predicate`, `Region`, and `Const`.\n //!\n-//! There are three traits involved in each traversal type.\n-//! - `TypeFoldable`. This is implemented once for many types. This includes\n-//!   both:\n+//! There are three groups of traits involved in each traversal.\n+//! - `TypeFoldable`. This is implemented once for many types, including:\n //!   - Types of interest, for which the the methods delegate to the\n-//!     folder/visitor.\n+//!     folder.\n //!   - All other types, including generic containers like `Vec` and `Option`.\n-//!     It defines a \"skeleton\" of how they should be traversed, for both\n-//!     folding and visiting.\n+//!     It defines a \"skeleton\" of how they should be folded.\n //! - `TypeSuperFoldable`. This is implemented only for each type of interest,\n-//!   and defines the traversal \"skeleton\" for these types.\n-//! - `TypeFolder`/`FallibleTypeFolder` (for infallible/fallible folding\n-//!   traversals) or `TypeVisitor` (for visiting traversals). One of these is\n-//!   implemented for each folder/visitor. This defines how types of interest\n-//!   are folded/visited.\n+//!   and defines the folding \"skeleton\" for these types.\n+//! - `TypeFolder`/`FallibleTypeFolder. One of these is implemented for each\n+//!   folder. This defines how types of interest are folded.\n //!\n-//! This means each traversal is a mixture of (a) generic traversal operations,\n-//! and (b) custom fold/visit operations that are specific to the\n-//! folder/visitor.\n+//! This means each fold is a mixture of (a) generic folding operations, and (b)\n+//! custom fold operations that are specific to the folder.\n //! - The `TypeFoldable` impls handle most of the traversal, and call into\n-//!   `TypeFolder`/`FallibleTypeFolder`/`TypeVisitor` when they encounter a\n-//!   type of interest.\n-//! - A `TypeFolder`/`FallibleTypeFolder`/`TypeVisitor` may call into another\n-//!   `TypeFoldable` impl, because some of the types of interest are recursive\n-//!   and can contain other types of interest.\n-//! - A `TypeFolder`/`FallibleTypeFolder`/`TypeVisitor` may also call into\n-//!   a `TypeSuperFoldable` impl, because each folder/visitor might provide\n-//!   custom handling only for some types of interest, or only for some\n-//!   variants of each type of interest, and then use default traversal for the\n-//!   remaining cases.\n+//!   `TypeFolder`/`FallibleTypeFolder` when they encounter a type of interest.\n+//! - A `TypeFolder`/`FallibleTypeFolder` may call into another `TypeFoldable`\n+//!   impl, because some of the types of interest are recursive and can contain\n+//!   other types of interest.\n+//! - A `TypeFolder`/`FallibleTypeFolder` may also call into a `TypeSuperFoldable`\n+//!   impl, because each folder might provide custom handling only for some types\n+//!   of interest, or only for some variants of each type of interest, and then\n+//!   use default traversal for the remaining cases.\n //!\n //! For example, if you have `struct S(Ty, U)` where `S: TypeFoldable` and `U:\n-//! TypeFoldable`, and an instance `s = S(ty, u)`, it would be visited like so:\n+//! TypeFoldable`, and an instance `s = S(ty, u)`, it would be folded like so:\n //! ```text\n-//! s.visit_with(visitor) calls\n-//! - ty.visit_with(visitor) calls\n-//!   - visitor.visit_ty(ty) may call\n-//!     - ty.super_visit_with(visitor)\n-//! - u.visit_with(visitor)\n+//! s.fold_with(folder) calls\n+//! - ty.fold_with(folder) calls\n+//!   - folder.fold_ty(ty) may call\n+//!     - ty.super_fold_with(folder)\n+//! - u.fold_with(folder)\n //! ```\n use crate::mir;\n-use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n-use rustc_errors::ErrorGuaranteed;\n+use crate::ty::{self, Binder, Ty, TyCtxt, TypeVisitable};\n use rustc_hir::def_id::DefId;\n \n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::sso::SsoHashSet;\n use std::collections::BTreeMap;\n-use std::fmt;\n-use std::ops::ControlFlow;\n \n-/// This trait is implemented for every type that can be folded/visited,\n+/// This trait is implemented for every type that can be folded,\n /// providing the skeleton of the traversal.\n ///\n /// To implement this conveniently, use the derive macro located in\n /// `rustc_macros`.\n-pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n+pub trait TypeFoldable<'tcx>: TypeVisitable<'tcx> {\n     /// The entry point for folding. To fold a value `t` with a folder `f`\n     /// call: `t.try_fold_with(f)`.\n     ///\n@@ -89,115 +73,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         self.try_fold_with(folder).into_ok()\n     }\n-\n-    /// The entry point for visiting. To visit a value `t` with a visitor `v`\n-    /// call: `t.visit_with(v)`.\n-    ///\n-    /// For most types, this just traverses the value, calling `visit_with` on\n-    /// each field/element.\n-    ///\n-    /// For types of interest (such as `Ty`), the implementation of this method\n-    /// that calls a visitor method specifically for that type (such as\n-    /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n-    /// `TypeVisitor`.\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n-\n-    /// Returns `true` if `self` has any late-bound regions that are either\n-    /// bound by `binder` or bound by some binder outside of `binder`.\n-    /// If `binder` is `ty::INNERMOST`, this indicates whether\n-    /// there are any late-bound regions that appear free.\n-    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n-    }\n-\n-    /// Returns `true` if this `self` has any regions that escape `binder` (and\n-    /// hence are not bound by it).\n-    fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.has_vars_bound_at_or_above(binder.shifted_in(1))\n-    }\n-\n-    fn has_escaping_bound_vars(&self) -> bool {\n-        self.has_vars_bound_at_or_above(ty::INNERMOST)\n-    }\n-\n-    #[instrument(level = \"trace\")]\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n-    }\n-    fn has_projections(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_PROJECTION)\n-    }\n-    fn has_opaque_types(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n-    }\n-    fn references_error(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_ERROR)\n-    }\n-    fn error_reported(&self) -> Option<ErrorGuaranteed> {\n-        if self.references_error() {\n-            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            None\n-        }\n-    }\n-    fn has_param_types_or_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_CT_PARAM)\n-    }\n-    fn has_infer_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_INFER)\n-    }\n-    fn has_infer_types(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_INFER)\n-    }\n-    fn has_infer_types_or_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n-    }\n-    fn needs_infer(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_INFER)\n-    }\n-    fn has_placeholders(&self) -> bool {\n-        self.has_type_flags(\n-            TypeFlags::HAS_RE_PLACEHOLDER\n-                | TypeFlags::HAS_TY_PLACEHOLDER\n-                | TypeFlags::HAS_CT_PLACEHOLDER,\n-        )\n-    }\n-    fn needs_subst(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n-    }\n-    /// \"Free\" regions in this context means that it has any region\n-    /// that is not (a) erased or (b) late-bound.\n-    fn has_free_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n-    }\n-\n-    fn has_erased_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n-    }\n-\n-    /// True if there are any un-erased free regions.\n-    fn has_erasable_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n-    }\n-\n-    /// Indicates whether this value references only 'global'\n-    /// generic parameters that are the same regardless of what fn we are\n-    /// in. This is used for caching.\n-    fn is_global(&self) -> bool {\n-        !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n-    }\n-\n-    /// True if there are any late-bound regions\n-    fn has_late_bound_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n-    }\n-\n-    /// Indicates whether this value still has parameters/placeholders/inference variables\n-    /// which could be replaced later, in a way that would change the results of `impl`\n-    /// specialization.\n-    fn still_further_specializable(&self) -> bool {\n-        self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n-    }\n }\n \n // This trait is implemented for types of interest.\n@@ -219,14 +94,6 @@ pub trait TypeSuperFoldable<'tcx>: TypeFoldable<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         self.try_super_fold_with(folder).into_ok()\n     }\n-\n-    /// Provides a default visit for a type of interest. This should only be\n-    /// called within `TypeVisitor` methods, when a non-custom traversal is\n-    /// desired for the value of the type of interest passed to that method.\n-    /// For example, in `MyVisitor::visit_ty(ty)`, it is valid to call\n-    /// `ty.super_visit_with(self)`, but any other visiting should be done\n-    /// with `xyz.visit_with(self)`.\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n }\n \n /// This trait is implemented for every infallible folding traversal. There is\n@@ -376,44 +243,6 @@ where\n     }\n }\n \n-/// This trait is implemented for every visiting traversal. There is a visit\n-/// method defined for every type of interest. Each such method has a default\n-/// that recurses into the type's fields in a non-custom fashion.\n-pub trait TypeVisitor<'tcx>: Sized {\n-    type BreakTy = !;\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        r.super_visit_with(self)\n-    }\n-\n-    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        c.super_visit_with(self)\n-    }\n-\n-    fn visit_unevaluated(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        uv.super_visit_with(self)\n-    }\n-\n-    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        p.super_visit_with(self)\n-    }\n-\n-    fn visit_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        c.super_visit_with(self)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n@@ -472,99 +301,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         value.fold_with(&mut RegionFolder::new(self, &mut f))\n     }\n-\n-    /// Invoke `callback` on every region appearing free in `value`.\n-    pub fn for_each_free_region(\n-        self,\n-        value: &impl TypeFoldable<'tcx>,\n-        mut callback: impl FnMut(ty::Region<'tcx>),\n-    ) {\n-        self.any_free_region_meets(value, |r| {\n-            callback(r);\n-            false\n-        });\n-    }\n-\n-    /// Returns `true` if `callback` returns true for every region appearing free in `value`.\n-    pub fn all_free_regions_meet(\n-        self,\n-        value: &impl TypeFoldable<'tcx>,\n-        mut callback: impl FnMut(ty::Region<'tcx>) -> bool,\n-    ) -> bool {\n-        !self.any_free_region_meets(value, |r| !callback(r))\n-    }\n-\n-    /// Returns `true` if `callback` returns true for some region appearing free in `value`.\n-    pub fn any_free_region_meets(\n-        self,\n-        value: &impl TypeFoldable<'tcx>,\n-        callback: impl FnMut(ty::Region<'tcx>) -> bool,\n-    ) -> bool {\n-        struct RegionVisitor<F> {\n-            /// The index of a binder *just outside* the things we have\n-            /// traversed. If we encounter a bound region bound by this\n-            /// binder or one outer to it, it appears free. Example:\n-            ///\n-            /// ```ignore (illustrative)\n-            ///       for<'a> fn(for<'b> fn(), T)\n-            /// // ^          ^          ^     ^\n-            /// // |          |          |     | here, would be shifted in 1\n-            /// // |          |          | here, would be shifted in 2\n-            /// // |          | here, would be `INNERMOST` shifted in by 1\n-            /// // | here, initially, binder would be `INNERMOST`\n-            /// ```\n-            ///\n-            /// You see that, initially, *any* bound value is free,\n-            /// because we've not traversed any binders. As we pass\n-            /// through a binder, we shift the `outer_index` by 1 to\n-            /// account for the new binder that encloses us.\n-            outer_index: ty::DebruijnIndex,\n-            callback: F,\n-        }\n-\n-        impl<'tcx, F> TypeVisitor<'tcx> for RegionVisitor<F>\n-        where\n-            F: FnMut(ty::Region<'tcx>) -> bool,\n-        {\n-            type BreakTy = ();\n-\n-            fn visit_binder<T: TypeFoldable<'tcx>>(\n-                &mut self,\n-                t: &Binder<'tcx, T>,\n-            ) -> ControlFlow<Self::BreakTy> {\n-                self.outer_index.shift_in(1);\n-                let result = t.super_visit_with(self);\n-                self.outer_index.shift_out(1);\n-                result\n-            }\n-\n-            fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                match *r {\n-                    ty::ReLateBound(debruijn, _) if debruijn < self.outer_index => {\n-                        ControlFlow::CONTINUE\n-                    }\n-                    _ => {\n-                        if (self.callback)(r) {\n-                            ControlFlow::BREAK\n-                        } else {\n-                            ControlFlow::CONTINUE\n-                        }\n-                    }\n-                }\n-            }\n-\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                // We're only interested in types involving regions\n-                if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n-                    ty.super_visit_with(self)\n-                } else {\n-                    ControlFlow::CONTINUE\n-                }\n-            }\n-        }\n-\n-        value.visit_with(&mut RegionVisitor { outer_index: ty::INNERMOST, callback }).is_break()\n-    }\n }\n \n /// Folds over the substructure of a type, visiting its component\n@@ -861,45 +597,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    /// Returns a set of all late-bound regions that are constrained\n-    /// by `value`, meaning that if we instantiate those LBR with\n-    /// variables and equate `value` with something else, those\n-    /// variables will also be equated.\n-    pub fn collect_constrained_late_bound_regions<T>(\n-        self,\n-        value: &Binder<'tcx, T>,\n-    ) -> FxHashSet<ty::BoundRegionKind>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.collect_late_bound_regions(value, true)\n-    }\n-\n-    /// Returns a set of all late-bound regions that appear in `value` anywhere.\n-    pub fn collect_referenced_late_bound_regions<T>(\n-        self,\n-        value: &Binder<'tcx, T>,\n-    ) -> FxHashSet<ty::BoundRegionKind>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.collect_late_bound_regions(value, false)\n-    }\n-\n-    fn collect_late_bound_regions<T>(\n-        self,\n-        value: &Binder<'tcx, T>,\n-        just_constraint: bool,\n-    ) -> FxHashSet<ty::BoundRegionKind>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut collector = LateBoundRegionsCollector::new(just_constraint);\n-        let result = value.as_ref().skip_binder().visit_with(&mut collector);\n-        assert!(result.is_continue()); // should never have stopped early\n-        collector.regions\n-    }\n-\n     /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n     pub fn erase_late_bound_regions<T>(self, value: Binder<'tcx, T>) -> T\n@@ -940,103 +637,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-pub struct ValidateBoundVars<'tcx> {\n-    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n-    binder_index: ty::DebruijnIndex,\n-    // We may encounter the same variable at different levels of binding, so\n-    // this can't just be `Ty`\n-    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n-}\n-\n-impl<'tcx> ValidateBoundVars<'tcx> {\n-    pub fn new(bound_vars: &'tcx ty::List<ty::BoundVariableKind>) -> Self {\n-        ValidateBoundVars {\n-            bound_vars,\n-            binder_index: ty::INNERMOST,\n-            visited: SsoHashSet::default(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n-    type BreakTy = ();\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        self.binder_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.binder_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if t.outer_exclusive_binder() < self.binder_index\n-            || !self.visited.insert((self.binder_index, t))\n-        {\n-            return ControlFlow::BREAK;\n-        }\n-        match *t.kind() {\n-            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n-                if self.bound_vars.len() <= bound_ty.var.as_usize() {\n-                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", t, self.bound_vars);\n-                }\n-                let list_var = self.bound_vars[bound_ty.var.as_usize()];\n-                match list_var {\n-                    ty::BoundVariableKind::Ty(kind) => {\n-                        if kind != bound_ty.kind {\n-                            bug!(\n-                                \"Mismatched type kinds: {:?} doesn't var in list {:?}\",\n-                                bound_ty.kind,\n-                                list_var\n-                            );\n-                        }\n-                    }\n-                    _ => {\n-                        bug!(\"Mismatched bound variable kinds! Expected type, found {:?}\", list_var)\n-                    }\n-                }\n-            }\n-\n-            _ => (),\n-        };\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match *r {\n-            ty::ReLateBound(index, br) if index == self.binder_index => {\n-                if self.bound_vars.len() <= br.var.as_usize() {\n-                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", br, self.bound_vars);\n-                }\n-                let list_var = self.bound_vars[br.var.as_usize()];\n-                match list_var {\n-                    ty::BoundVariableKind::Region(kind) => {\n-                        if kind != br.kind {\n-                            bug!(\n-                                \"Mismatched region kinds: {:?} doesn't match var ({:?}) in list ({:?})\",\n-                                br.kind,\n-                                list_var,\n-                                self.bound_vars\n-                            );\n-                        }\n-                    }\n-                    _ => bug!(\n-                        \"Mismatched bound variable kinds! Expected region, found {:?}\",\n-                        list_var\n-                    ),\n-                }\n-            }\n-\n-            _ => (),\n-        };\n-\n-        r.super_visit_with(self)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Shifter\n //\n@@ -1141,301 +741,3 @@ where\n \n     value.fold_with(&mut Shifter::new(tcx, amount))\n }\n-\n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-struct FoundEscapingVars;\n-\n-/// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a\n-/// bound region or a bound type.\n-///\n-/// So, for example, consider a type like the following, which has two binders:\n-///\n-///    for<'a> fn(x: for<'b> fn(&'a isize, &'b isize))\n-///    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n-///                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n-///\n-/// This type has *bound regions* (`'a`, `'b`), but it does not have escaping regions, because the\n-/// binders of both `'a` and `'b` are part of the type itself. However, if we consider the *inner\n-/// fn type*, that type has an escaping region: `'a`.\n-///\n-/// Note that what I'm calling an \"escaping var\" is often just called a \"free var\". However,\n-/// we already use the term \"free var\". It refers to the regions or types that we use to represent\n-/// bound regions or type params on a fn definition while we are type checking its body.\n-///\n-/// To clarify, conceptually there is no particular difference between\n-/// an \"escaping\" var and a \"free\" var. However, there is a big\n-/// difference in practice. Basically, when \"entering\" a binding\n-/// level, one is generally required to do some sort of processing to\n-/// a bound var, such as replacing it with a fresh/placeholder\n-/// var, or making an entry in the environment to represent the\n-/// scope to which it is attached, etc. An escaping var represents\n-/// a bound var for which this processing has not yet been done.\n-struct HasEscapingVarsVisitor {\n-    /// Anything bound by `outer_index` or \"above\" is escaping.\n-    outer_index: ty::DebruijnIndex,\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n-    type BreakTy = FoundEscapingVars;\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        self.outer_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.outer_index.shift_out(1);\n-        result\n-    }\n-\n-    #[inline]\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // If the outer-exclusive-binder is *strictly greater* than\n-        // `outer_index`, that means that `t` contains some content\n-        // bound at `outer_index` or above (because\n-        // `outer_exclusive_binder` is always 1 higher than the\n-        // content in `t`). Therefore, `t` has some escaping vars.\n-        if t.outer_exclusive_binder() > self.outer_index {\n-            ControlFlow::Break(FoundEscapingVars)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n-    #[inline]\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // If the region is bound by `outer_index` or anything outside\n-        // of outer index, then it escapes the binders we have\n-        // visited.\n-        if r.bound_at_or_above_binder(self.outer_index) {\n-            ControlFlow::Break(FoundEscapingVars)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n-    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // we don't have a `visit_infer_const` callback, so we have to\n-        // hook in here to catch this case (annoying...), but\n-        // otherwise we do want to remember to visit the rest of the\n-        // const, as it has types/regions embedded in a lot of other\n-        // places.\n-        match ct.kind() {\n-            ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => {\n-                ControlFlow::Break(FoundEscapingVars)\n-            }\n-            _ => ct.super_visit_with(self),\n-        }\n-    }\n-\n-    #[inline]\n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if predicate.outer_exclusive_binder() > self.outer_index {\n-            ControlFlow::Break(FoundEscapingVars)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-struct FoundFlags;\n-\n-// FIXME: Optimize for checking for infer flags\n-struct HasTypeFlagsVisitor {\n-    flags: ty::TypeFlags,\n-}\n-\n-impl std::fmt::Debug for HasTypeFlagsVisitor {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        self.flags.fmt(fmt)\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n-    type BreakTy = FoundFlags;\n-\n-    #[inline]\n-    #[instrument(skip(self), level = \"trace\")]\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let flags = t.flags();\n-        trace!(t.flags=?t.flags());\n-        if flags.intersects(self.flags) {\n-            ControlFlow::Break(FoundFlags)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n-    #[inline]\n-    #[instrument(skip(self), level = \"trace\")]\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let flags = r.type_flags();\n-        trace!(r.flags=?flags);\n-        if flags.intersects(self.flags) {\n-            ControlFlow::Break(FoundFlags)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n-    #[inline]\n-    #[instrument(level = \"trace\")]\n-    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let flags = FlagComputation::for_const(c);\n-        trace!(r.flags=?flags);\n-        if flags.intersects(self.flags) {\n-            ControlFlow::Break(FoundFlags)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n-    #[inline]\n-    #[instrument(level = \"trace\")]\n-    fn visit_unevaluated(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        let flags = FlagComputation::for_unevaluated_const(uv);\n-        trace!(r.flags=?flags);\n-        if flags.intersects(self.flags) {\n-            ControlFlow::Break(FoundFlags)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n-    #[inline]\n-    #[instrument(level = \"trace\")]\n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n-            predicate,\n-            predicate.flags(),\n-            self.flags\n-        );\n-        if predicate.flags().intersects(self.flags) {\n-            ControlFlow::Break(FoundFlags)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-}\n-\n-/// Collects all the late-bound regions at the innermost binding level\n-/// into a hash set.\n-struct LateBoundRegionsCollector {\n-    current_index: ty::DebruijnIndex,\n-    regions: FxHashSet<ty::BoundRegionKind>,\n-\n-    /// `true` if we only want regions that are known to be\n-    /// \"constrained\" when you equate this type with another type. In\n-    /// particular, if you have e.g., `&'a u32` and `&'b u32`, equating\n-    /// them constraints `'a == 'b`. But if you have `<&'a u32 as\n-    /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n-    /// types may mean that `'a` and `'b` don't appear in the results,\n-    /// so they are not considered *constrained*.\n-    just_constrained: bool,\n-}\n-\n-impl LateBoundRegionsCollector {\n-    fn new(just_constrained: bool) -> Self {\n-        LateBoundRegionsCollector {\n-            current_index: ty::INNERMOST,\n-            regions: Default::default(),\n-            just_constrained,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        self.current_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.current_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // if we are only looking for \"constrained\" region, we have to\n-        // ignore the inputs to a projection, as they may not appear\n-        // in the normalized form\n-        if self.just_constrained {\n-            if let ty::Projection(..) = t.kind() {\n-                return ControlFlow::CONTINUE;\n-            }\n-        }\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // if we are only looking for \"constrained\" region, we have to\n-        // ignore the inputs of an unevaluated const, as they may not appear\n-        // in the normalized form\n-        if self.just_constrained {\n-            if let ty::ConstKind::Unevaluated(..) = c.kind() {\n-                return ControlFlow::CONTINUE;\n-            }\n-        }\n-\n-        c.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if let ty::ReLateBound(debruijn, br) = *r {\n-            if debruijn == self.current_index {\n-                self.regions.insert(br.kind);\n-            }\n-        }\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n-/// Finds the max universe present\n-pub struct MaxUniverse {\n-    max_universe: ty::UniverseIndex,\n-}\n-\n-impl MaxUniverse {\n-    pub fn new() -> Self {\n-        MaxUniverse { max_universe: ty::UniverseIndex::ROOT }\n-    }\n-\n-    pub fn max_universe(self) -> ty::UniverseIndex {\n-        self.max_universe\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for MaxUniverse {\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if let ty::Placeholder(placeholder) = t.kind() {\n-            self.max_universe = ty::UniverseIndex::from_u32(\n-                self.max_universe.as_u32().max(placeholder.universe.as_u32()),\n-            );\n-        }\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_const(&mut self, c: ty::consts::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if let ty::ConstKind::Placeholder(placeholder) = c.kind() {\n-            self.max_universe = ty::UniverseIndex::from_u32(\n-                self.max_universe.as_u32().max(placeholder.universe.as_u32()),\n-            );\n-        }\n-\n-        c.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if let ty::RePlaceholder(placeholder) = *r {\n-            self.max_universe = ty::UniverseIndex::from_u32(\n-                self.max_universe.as_u32().max(placeholder.universe.as_u32()),\n-            );\n-        }\n-\n-        ControlFlow::CONTINUE\n-    }\n-}"}, {"sha": "e546920a08468bb1239ead4084d95e769552a3aa", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca894909cdb49b510dc6f60edbfa1465a948d09/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca894909cdb49b510dc6f60edbfa1465a948d09/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=bca894909cdb49b510dc6f60edbfa1465a948d09", "patch": "@@ -9,9 +9,8 @@\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n-pub use self::fold::{\n-    FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitor,\n-};\n+pub use self::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeSuperFoldable};\n+pub use self::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n@@ -110,6 +109,7 @@ pub mod relate;\n pub mod subst;\n pub mod trait_def;\n pub mod util;\n+pub mod visit;\n pub mod vtable;\n pub mod walk;\n "}, {"sha": "5365067209af98042864cd0a8410a0a20170e722", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/bca894909cdb49b510dc6f60edbfa1465a948d09/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca894909cdb49b510dc6f60edbfa1465a948d09/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=bca894909cdb49b510dc6f60edbfa1465a948d09", "patch": "@@ -0,0 +1,745 @@\n+//! A visiting traversal mechanism for complex data structures that contain type\n+//! information.\n+//!\n+//! This is a read-only traversal of the data structure.\n+//!\n+//! This traversal has limited flexibility. Only a small number of \"types of\n+//! interest\" within the complex data structures can receive custom\n+//! visitation. These are the ones containing the most important type-related\n+//! information, such as `Ty`, `Predicate`, `Region`, and `Const`.\n+//!\n+//! There are three groups of traits involved in each traversal.\n+//! - `TypeVisitable`. This is implemented once for many types, including:\n+//!   - Types of interest, for which the the methods delegate to the\n+//!     visitor.\n+//!   - All other types, including generic containers like `Vec` and `Option`.\n+//!     It defines a \"skeleton\" of how they should be visited.\n+//! - `TypeSuperVisitable`. This is implemented only for each type of interest,\n+//!   and defines the visiting \"skeleton\" for these types.\n+//! - `TypeVisitor`. This is implemented for each visitor. This defines how\n+//!   types of interest are visited.\n+//!\n+//! This means each visit is a mixture of (a) generic visiting operations, and (b)\n+//! custom visit operations that are specific to the visitor.\n+//! - The `TypeVisitable` impls handle most of the traversal, and call into\n+//!   `TypeVisitor` when they encounter a type of interest.\n+//! - A `TypeVisitor` may call into another `TypeVisitable` impl, because some of\n+//!   the types of interest are recursive and can contain other types of interest.\n+//! - A `TypeVisitor` may also call into a `TypeSuperVisitable` impl, because each\n+//!   visitor might provide custom handling only for some types of interest, or\n+//!   only for some variants of each type of interest, and then use default\n+//!   traversal for the remaining cases.\n+//!\n+//! For example, if you have `struct S(Ty, U)` where `S: TypeVisitable` and `U:\n+//! TypeVisitable`, and an instance `s = S(ty, u)`, it would be visited like so:\n+//! ```text\n+//! s.visit_with(visitor) calls\n+//! - ty.visit_with(visitor) calls\n+//!   - visitor.visit_ty(ty) may call\n+//!     - ty.super_visit_with(visitor)\n+//! - u.visit_with(visitor)\n+//! ```\n+use crate::mir;\n+use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n+use rustc_errors::ErrorGuaranteed;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sso::SsoHashSet;\n+use std::fmt;\n+use std::ops::ControlFlow;\n+\n+/// This trait is implemented for every type that can be visited,\n+/// providing the skeleton of the traversal.\n+///\n+/// To implement this conveniently, use the derive macro located in\n+/// `rustc_macros`.\n+pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n+    /// The entry point for visiting. To visit a value `t` with a visitor `v`\n+    /// call: `t.visit_with(v)`.\n+    ///\n+    /// For most types, this just traverses the value, calling `visit_with` on\n+    /// each field/element.\n+    ///\n+    /// For types of interest (such as `Ty`), the implementation of this method\n+    /// that calls a visitor method specifically for that type (such as\n+    /// `V::visit_ty`). This is where control transfers from `TypeFoldable` to\n+    /// `TypeVisitor`.\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+\n+    /// Returns `true` if `self` has any late-bound regions that are either\n+    /// bound by `binder` or bound by some binder outside of `binder`.\n+    /// If `binder` is `ty::INNERMOST`, this indicates whether\n+    /// there are any late-bound regions that appear free.\n+    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n+    }\n+\n+    /// Returns `true` if this `self` has any regions that escape `binder` (and\n+    /// hence are not bound by it).\n+    fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.has_vars_bound_at_or_above(binder.shifted_in(1))\n+    }\n+\n+    fn has_escaping_bound_vars(&self) -> bool {\n+        self.has_vars_bound_at_or_above(ty::INNERMOST)\n+    }\n+\n+    #[instrument(level = \"trace\")]\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n+    }\n+    fn has_projections(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_PROJECTION)\n+    }\n+    fn has_opaque_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n+    }\n+    fn references_error(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_ERROR)\n+    }\n+    fn error_reported(&self) -> Option<ErrorGuaranteed> {\n+        if self.references_error() {\n+            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+        } else {\n+            None\n+        }\n+    }\n+    fn has_param_types_or_consts(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_CT_PARAM)\n+    }\n+    fn has_infer_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_INFER)\n+    }\n+    fn has_infer_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INFER)\n+    }\n+    fn has_infer_types_or_consts(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n+    }\n+    fn needs_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_INFER)\n+    }\n+    fn has_placeholders(&self) -> bool {\n+        self.has_type_flags(\n+            TypeFlags::HAS_RE_PLACEHOLDER\n+                | TypeFlags::HAS_TY_PLACEHOLDER\n+                | TypeFlags::HAS_CT_PLACEHOLDER,\n+        )\n+    }\n+    fn needs_subst(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n+    }\n+    /// \"Free\" regions in this context means that it has any region\n+    /// that is not (a) erased or (b) late-bound.\n+    fn has_free_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    }\n+\n+    fn has_erased_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n+    }\n+\n+    /// True if there are any un-erased free regions.\n+    fn has_erasable_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    }\n+\n+    /// Indicates whether this value references only 'global'\n+    /// generic parameters that are the same regardless of what fn we are\n+    /// in. This is used for caching.\n+    fn is_global(&self) -> bool {\n+        !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n+    }\n+\n+    /// True if there are any late-bound regions\n+    fn has_late_bound_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n+    }\n+\n+    /// Indicates whether this value still has parameters/placeholders/inference variables\n+    /// which could be replaced later, in a way that would change the results of `impl`\n+    /// specialization.\n+    fn still_further_specializable(&self) -> bool {\n+        self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n+    }\n+}\n+\n+pub trait TypeSuperVisitable<'tcx>: TypeVisitable<'tcx> {\n+    /// Provides a default visit for a type of interest. This should only be\n+    /// called within `TypeVisitor` methods, when a non-custom traversal is\n+    /// desired for the value of the type of interest passed to that method.\n+    /// For example, in `MyVisitor::visit_ty(ty)`, it is valid to call\n+    /// `ty.super_visit_with(self)`, but any other visiting should be done\n+    /// with `xyz.visit_with(self)`.\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n+}\n+\n+/// This trait is implemented for every visiting traversal. There is a visit\n+/// method defined for every type of interest. Each such method has a default\n+/// that recurses into the type's fields in a non-custom fashion.\n+pub trait TypeVisitor<'tcx>: Sized {\n+    type BreakTy = !;\n+\n+    fn visit_binder<T: TypeVisitable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        r.super_visit_with(self)\n+    }\n+\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        c.super_visit_with(self)\n+    }\n+\n+    fn visit_unevaluated(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        uv.super_visit_with(self)\n+    }\n+\n+    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        p.super_visit_with(self)\n+    }\n+\n+    fn visit_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        c.super_visit_with(self)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region folder\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Invoke `callback` on every region appearing free in `value`.\n+    pub fn for_each_free_region(\n+        self,\n+        value: &impl TypeVisitable<'tcx>,\n+        mut callback: impl FnMut(ty::Region<'tcx>),\n+    ) {\n+        self.any_free_region_meets(value, |r| {\n+            callback(r);\n+            false\n+        });\n+    }\n+\n+    /// Returns `true` if `callback` returns true for every region appearing free in `value`.\n+    pub fn all_free_regions_meet(\n+        self,\n+        value: &impl TypeVisitable<'tcx>,\n+        mut callback: impl FnMut(ty::Region<'tcx>) -> bool,\n+    ) -> bool {\n+        !self.any_free_region_meets(value, |r| !callback(r))\n+    }\n+\n+    /// Returns `true` if `callback` returns true for some region appearing free in `value`.\n+    pub fn any_free_region_meets(\n+        self,\n+        value: &impl TypeVisitable<'tcx>,\n+        callback: impl FnMut(ty::Region<'tcx>) -> bool,\n+    ) -> bool {\n+        struct RegionVisitor<F> {\n+            /// The index of a binder *just outside* the things we have\n+            /// traversed. If we encounter a bound region bound by this\n+            /// binder or one outer to it, it appears free. Example:\n+            ///\n+            /// ```ignore (illustrative)\n+            ///       for<'a> fn(for<'b> fn(), T)\n+            /// // ^          ^          ^     ^\n+            /// // |          |          |     | here, would be shifted in 1\n+            /// // |          |          | here, would be shifted in 2\n+            /// // |          | here, would be `INNERMOST` shifted in by 1\n+            /// // | here, initially, binder would be `INNERMOST`\n+            /// ```\n+            ///\n+            /// You see that, initially, *any* bound value is free,\n+            /// because we've not traversed any binders. As we pass\n+            /// through a binder, we shift the `outer_index` by 1 to\n+            /// account for the new binder that encloses us.\n+            outer_index: ty::DebruijnIndex,\n+            callback: F,\n+        }\n+\n+        impl<'tcx, F> TypeVisitor<'tcx> for RegionVisitor<F>\n+        where\n+            F: FnMut(ty::Region<'tcx>) -> bool,\n+        {\n+            type BreakTy = ();\n+\n+            fn visit_binder<T: TypeVisitable<'tcx>>(\n+                &mut self,\n+                t: &Binder<'tcx, T>,\n+            ) -> ControlFlow<Self::BreakTy> {\n+                self.outer_index.shift_in(1);\n+                let result = t.super_visit_with(self);\n+                self.outer_index.shift_out(1);\n+                result\n+            }\n+\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                match *r {\n+                    ty::ReLateBound(debruijn, _) if debruijn < self.outer_index => {\n+                        ControlFlow::CONTINUE\n+                    }\n+                    _ => {\n+                        if (self.callback)(r) {\n+                            ControlFlow::BREAK\n+                        } else {\n+                            ControlFlow::CONTINUE\n+                        }\n+                    }\n+                }\n+            }\n+\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                // We're only interested in types involving regions\n+                if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n+                    ty.super_visit_with(self)\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            }\n+        }\n+\n+        value.visit_with(&mut RegionVisitor { outer_index: ty::INNERMOST, callback }).is_break()\n+    }\n+\n+    /// Returns a set of all late-bound regions that are constrained\n+    /// by `value`, meaning that if we instantiate those LBR with\n+    /// variables and equate `value` with something else, those\n+    /// variables will also be equated.\n+    pub fn collect_constrained_late_bound_regions<T>(\n+        self,\n+        value: &Binder<'tcx, T>,\n+    ) -> FxHashSet<ty::BoundRegionKind>\n+    where\n+        T: TypeVisitable<'tcx>,\n+    {\n+        self.collect_late_bound_regions(value, true)\n+    }\n+\n+    /// Returns a set of all late-bound regions that appear in `value` anywhere.\n+    pub fn collect_referenced_late_bound_regions<T>(\n+        self,\n+        value: &Binder<'tcx, T>,\n+    ) -> FxHashSet<ty::BoundRegionKind>\n+    where\n+        T: TypeVisitable<'tcx>,\n+    {\n+        self.collect_late_bound_regions(value, false)\n+    }\n+\n+    fn collect_late_bound_regions<T>(\n+        self,\n+        value: &Binder<'tcx, T>,\n+        just_constraint: bool,\n+    ) -> FxHashSet<ty::BoundRegionKind>\n+    where\n+        T: TypeVisitable<'tcx>,\n+    {\n+        let mut collector = LateBoundRegionsCollector::new(just_constraint);\n+        let result = value.as_ref().skip_binder().visit_with(&mut collector);\n+        assert!(result.is_continue()); // should never have stopped early\n+        collector.regions\n+    }\n+}\n+\n+pub struct ValidateBoundVars<'tcx> {\n+    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+    binder_index: ty::DebruijnIndex,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> ValidateBoundVars<'tcx> {\n+    pub fn new(bound_vars: &'tcx ty::List<ty::BoundVariableKind>) -> Self {\n+        ValidateBoundVars {\n+            bound_vars,\n+            binder_index: ty::INNERMOST,\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeVisitable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder() < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::BREAK;\n+        }\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                if self.bound_vars.len() <= bound_ty.var.as_usize() {\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", t, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[bound_ty.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Ty(kind) => {\n+                        if kind != bound_ty.kind {\n+                            bug!(\n+                                \"Mismatched type kinds: {:?} doesn't var in list {:?}\",\n+                                bound_ty.kind,\n+                                list_var\n+                            );\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\"Mismatched bound variable kinds! Expected type, found {:?}\", list_var)\n+                    }\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match *r {\n+            ty::ReLateBound(index, br) if index == self.binder_index => {\n+                if self.bound_vars.len() <= br.var.as_usize() {\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", br, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[br.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Region(kind) => {\n+                        if kind != br.kind {\n+                            bug!(\n+                                \"Mismatched region kinds: {:?} doesn't match var ({:?}) in list ({:?})\",\n+                                br.kind,\n+                                list_var,\n+                                self.bound_vars\n+                            );\n+                        }\n+                    }\n+                    _ => bug!(\n+                        \"Mismatched bound variable kinds! Expected region, found {:?}\",\n+                        list_var\n+                    ),\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+struct FoundEscapingVars;\n+\n+/// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a\n+/// bound region or a bound type.\n+///\n+/// So, for example, consider a type like the following, which has two binders:\n+///\n+///    for<'a> fn(x: for<'b> fn(&'a isize, &'b isize))\n+///    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n+///                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n+///\n+/// This type has *bound regions* (`'a`, `'b`), but it does not have escaping regions, because the\n+/// binders of both `'a` and `'b` are part of the type itself. However, if we consider the *inner\n+/// fn type*, that type has an escaping region: `'a`.\n+///\n+/// Note that what I'm calling an \"escaping var\" is often just called a \"free var\". However,\n+/// we already use the term \"free var\". It refers to the regions or types that we use to represent\n+/// bound regions or type params on a fn definition while we are type checking its body.\n+///\n+/// To clarify, conceptually there is no particular difference between\n+/// an \"escaping\" var and a \"free\" var. However, there is a big\n+/// difference in practice. Basically, when \"entering\" a binding\n+/// level, one is generally required to do some sort of processing to\n+/// a bound var, such as replacing it with a fresh/placeholder\n+/// var, or making an entry in the environment to represent the\n+/// scope to which it is attached, etc. An escaping var represents\n+/// a bound var for which this processing has not yet been done.\n+struct HasEscapingVarsVisitor {\n+    /// Anything bound by `outer_index` or \"above\" is escaping.\n+    outer_index: ty::DebruijnIndex,\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n+    type BreakTy = FoundEscapingVars;\n+\n+    fn visit_binder<T: TypeVisitable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.outer_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.outer_index.shift_out(1);\n+        result\n+    }\n+\n+    #[inline]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // If the outer-exclusive-binder is *strictly greater* than\n+        // `outer_index`, that means that `t` contains some content\n+        // bound at `outer_index` or above (because\n+        // `outer_exclusive_binder` is always 1 higher than the\n+        // content in `t`). Therefore, `t` has some escaping vars.\n+        if t.outer_exclusive_binder() > self.outer_index {\n+            ControlFlow::Break(FoundEscapingVars)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // If the region is bound by `outer_index` or anything outside\n+        // of outer index, then it escapes the binders we have\n+        // visited.\n+        if r.bound_at_or_above_binder(self.outer_index) {\n+            ControlFlow::Break(FoundEscapingVars)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // we don't have a `visit_infer_const` callback, so we have to\n+        // hook in here to catch this case (annoying...), but\n+        // otherwise we do want to remember to visit the rest of the\n+        // const, as it has types/regions embedded in a lot of other\n+        // places.\n+        match ct.kind() {\n+            ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => {\n+                ControlFlow::Break(FoundEscapingVars)\n+            }\n+            _ => ct.super_visit_with(self),\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if predicate.outer_exclusive_binder() > self.outer_index {\n+            ControlFlow::Break(FoundEscapingVars)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+struct FoundFlags;\n+\n+// FIXME: Optimize for checking for infer flags\n+struct HasTypeFlagsVisitor {\n+    flags: ty::TypeFlags,\n+}\n+\n+impl std::fmt::Debug for HasTypeFlagsVisitor {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        self.flags.fmt(fmt)\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n+    type BreakTy = FoundFlags;\n+\n+    #[inline]\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = t.flags();\n+        trace!(t.flags=?t.flags());\n+        if flags.intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = r.type_flags();\n+        trace!(r.flags=?flags);\n+        if flags.intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    #[instrument(level = \"trace\")]\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = FlagComputation::for_const(c);\n+        trace!(r.flags=?flags);\n+        if flags.intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    #[instrument(level = \"trace\")]\n+    fn visit_unevaluated(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = FlagComputation::for_unevaluated_const(uv);\n+        trace!(r.flags=?flags);\n+        if flags.intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    #[instrument(level = \"trace\")]\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        debug!(\n+            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n+            predicate,\n+            predicate.flags(),\n+            self.flags\n+        );\n+        if predicate.flags().intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}\n+\n+/// Collects all the late-bound regions at the innermost binding level\n+/// into a hash set.\n+struct LateBoundRegionsCollector {\n+    current_index: ty::DebruijnIndex,\n+    regions: FxHashSet<ty::BoundRegionKind>,\n+\n+    /// `true` if we only want regions that are known to be\n+    /// \"constrained\" when you equate this type with another type. In\n+    /// particular, if you have e.g., `&'a u32` and `&'b u32`, equating\n+    /// them constraints `'a == 'b`. But if you have `<&'a u32 as\n+    /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n+    /// types may mean that `'a` and `'b` don't appear in the results,\n+    /// so they are not considered *constrained*.\n+    just_constrained: bool,\n+}\n+\n+impl LateBoundRegionsCollector {\n+    fn new(just_constrained: bool) -> Self {\n+        LateBoundRegionsCollector {\n+            current_index: ty::INNERMOST,\n+            regions: Default::default(),\n+            just_constrained,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n+    fn visit_binder<T: TypeVisitable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.current_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.current_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // if we are only looking for \"constrained\" region, we have to\n+        // ignore the inputs to a projection, as they may not appear\n+        // in the normalized form\n+        if self.just_constrained {\n+            if let ty::Projection(..) = t.kind() {\n+                return ControlFlow::CONTINUE;\n+            }\n+        }\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // if we are only looking for \"constrained\" region, we have to\n+        // ignore the inputs of an unevaluated const, as they may not appear\n+        // in the normalized form\n+        if self.just_constrained {\n+            if let ty::ConstKind::Unevaluated(..) = c.kind() {\n+                return ControlFlow::CONTINUE;\n+            }\n+        }\n+\n+        c.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if let ty::ReLateBound(debruijn, br) = *r {\n+            if debruijn == self.current_index {\n+                self.regions.insert(br.kind);\n+            }\n+        }\n+        ControlFlow::CONTINUE\n+    }\n+}\n+\n+/// Finds the max universe present\n+pub struct MaxUniverse {\n+    max_universe: ty::UniverseIndex,\n+}\n+\n+impl MaxUniverse {\n+    pub fn new() -> Self {\n+        MaxUniverse { max_universe: ty::UniverseIndex::ROOT }\n+    }\n+\n+    pub fn max_universe(self) -> ty::UniverseIndex {\n+        self.max_universe\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for MaxUniverse {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if let ty::Placeholder(placeholder) = t.kind() {\n+            self.max_universe = ty::UniverseIndex::from_u32(\n+                self.max_universe.as_u32().max(placeholder.universe.as_u32()),\n+            );\n+        }\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_const(&mut self, c: ty::consts::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if let ty::ConstKind::Placeholder(placeholder) = c.kind() {\n+            self.max_universe = ty::UniverseIndex::from_u32(\n+                self.max_universe.as_u32().max(placeholder.universe.as_u32()),\n+            );\n+        }\n+\n+        c.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if let ty::RePlaceholder(placeholder) = *r {\n+            self.max_universe = ty::UniverseIndex::from_u32(\n+                self.max_universe.as_u32().max(placeholder.universe.as_u32()),\n+            );\n+        }\n+\n+        ControlFlow::CONTINUE\n+    }\n+}"}]}