{"sha": "5807e261c27e4964fc6a8d2b8cf02e548292b940", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MDdlMjYxYzI3ZTQ5NjRmYzZhOGQyYjhjZjAyZTU0ODI5MmI5NDA=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-18T16:36:12Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-25T22:16:52Z"}, "message": "Support custom `CoerceUnsized`\nSplit out tests about coercion", "tree": {"sha": "b6bfef565281c2fec4b584a4e2759ff1c5b417e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6bfef565281c2fec4b584a4e2759ff1c5b417e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5807e261c27e4964fc6a8d2b8cf02e548292b940", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2L51cACgkQztOS3gxI\nPQBjRRAAm00+fNpq3oCZq2xgSXsDHmv0cjXHlOwJqi5XK0meYZdgKHjBVwm8DEEp\nvkoygatgN8SocQrFchFH2fa9gdFUqgAgY+/HIZMekJFTbZTyJniFf8uPcNN5ngYf\n9gnuO+dPSMunddKQys8PSLkeLfAuRZSWcpjR5JRmGd5BuYg6czY8+WIQKMfstbpK\nOzAxCrNycumeizeNAIyKI17tZBOPOw/0VnkOlCDf4EN0Ba4giC/GrWBr2hDwoGRz\nKST8kd0Emu9O072/UiAkMuOsQN//X/Di5IDqVE0FR6UWcSvDClaBndf4bJDv6odo\nN3r+H3pJqxzlYoQncYNtt976VFMKpDpPxr7YfFP/t/ReRsTFap5tNj2jbAo8aZlN\nUKnxT49CZDtgocY4icTxsgBH/HPJ7P5pZPngQDnynJrCQyQtqYdvilYMdpd2wuwi\ntp1G2GUyvpeEYTI9LfV+9iLG0zCXX24Or/Zwi2YnVjzE85eoI3BHulDO7OKMiMY3\n8wjnMMbY6P4riv6BAs03+CUhG0WL6MaY4BuGFqFCZnyfXAK/muFpdw2Y+wOxaxkc\nNJI4QJJWBZWxOV3u2yiCNMz/L0W+fCWde0Lc2oYs6o5T2o0+CbzyrCQKB2DpRC79\nbv1Fv3INPDvzyr8NBLS8jru36VBr2F5M34lzbNEMAAmG3rZrFmc=\n=uEHF\n-----END PGP SIGNATURE-----", "payload": "tree b6bfef565281c2fec4b584a4e2759ff1c5b417e5\nparent bf161fa3e58d57d9b15bd965405036d834f18595\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1568824572 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1569449812 +0800\n\nSupport custom `CoerceUnsized`\nSplit out tests about coercion\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5807e261c27e4964fc6a8d2b8cf02e548292b940", "html_url": "https://github.com/rust-lang/rust/commit/5807e261c27e4964fc6a8d2b8cf02e548292b940", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5807e261c27e4964fc6a8d2b8cf02e548292b940/comments", "author": null, "committer": null, "parents": [{"sha": "bf161fa3e58d57d9b15bd965405036d834f18595", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf161fa3e58d57d9b15bd965405036d834f18595", "html_url": "https://github.com/rust-lang/rust/commit/bf161fa3e58d57d9b15bd965405036d834f18595"}], "stats": {"total": 723, "additions": 476, "deletions": 247}, "files": [{"sha": "ba63050a937854552175e456f76e99970a06a74e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 181, "deletions": 26, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=5807e261c27e4964fc6a8d2b8cf02e548292b940", "patch": "@@ -42,6 +42,7 @@ use crate::{\n         RecordFieldPat, Statement, UnaryOp,\n     },\n     generics::{GenericParams, HasGenericParams},\n+    lang_item::LangItemTarget,\n     name,\n     nameres::Namespace,\n     path::{known, GenericArg, GenericArgs},\n@@ -188,6 +189,12 @@ struct InferenceContext<'a, D: HirDatabase> {\n     result: InferenceResult,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n+\n+    /// Impls of `CoerceUnsized` used in coercion.\n+    /// (from_ty_ctor, to_ty_ctor) => coerce_generic_index\n+    // FIXME: Use trait solver for this.\n+    // Chalk seems unable to work well with builtin impl of `Unsize` now.\n+    coerce_unsized_map: FxHashMap<(TypeCtor, TypeCtor), usize>,\n }\n \n macro_rules! ty_app {\n@@ -207,12 +214,52 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: lower::trait_env(db, &resolver),\n+            coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             body,\n             resolver,\n         }\n     }\n \n+    fn init_coerce_unsized_map(\n+        db: &'a D,\n+        resolver: &Resolver,\n+    ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n+        let krate = resolver.krate().unwrap();\n+        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate, trait_),\n+            _ => return FxHashMap::default(),\n+        };\n+\n+        impls\n+            .iter()\n+            .filter_map(|impl_block| {\n+                // `CoerseUnsized` has one generic parameter for the target type.\n+                let trait_ref = impl_block.target_trait_ref(db)?;\n+                let cur_from_ty = trait_ref.substs.0.get(0)?;\n+                let cur_to_ty = trait_ref.substs.0.get(1)?;\n+\n+                match (&cur_from_ty, cur_to_ty) {\n+                    (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n+                        // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n+                        // This works for smart-pointer-like coercion, which covers all impls from std.\n+                        st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n+                            match (ty1, ty2) {\n+                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n+                                    if p1 != p2 =>\n+                                {\n+                                    Some(((*ctor1, *ctor2), i))\n+                                }\n+                                _ => None,\n+                            }\n+                        })\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = mem::replace(&mut self.result, InferenceResult::default());\n@@ -919,16 +966,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             _ => {}\n         }\n \n-        // FIXME: Solve `FromTy: CoerceUnsized<ToTy>` instead of listing common impls here.\n-        match (&from_ty, &to_ty) {\n-            // Mutilibity is checked above\n-            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2))\n-            | (ty_app!(TypeCtor::RawPtr(_), st1), ty_app!(TypeCtor::RawPtr(_), st2)) => {\n-                if self.try_coerce_unsized(&st1[0], &st2[0], 0) {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n+            return ret;\n         }\n \n         // Auto Deref if cannot coerce\n@@ -943,40 +982,157 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    /// Coerce a type to a DST if `FromTy: Unsize<ToTy>`\n+    /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n     ///\n-    /// See: `https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html`\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> bool {\n+    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n+        let (ctor1, st1, ctor2, st2) = match (from_ty, to_ty) {\n+            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => (ctor1, st1, ctor2, st2),\n+            _ => return None,\n+        };\n+\n+        let coerce_generic_index = *self.coerce_unsized_map.get(&(*ctor1, *ctor2))?;\n+\n+        // Check `Unsize` first\n+        match self.check_unsize_and_coerce(\n+            st1.0.get(coerce_generic_index)?,\n+            st2.0.get(coerce_generic_index)?,\n+            0,\n+        ) {\n+            Some(true) => {}\n+            ret => return ret,\n+        }\n+\n+        let ret = st1\n+            .iter()\n+            .zip(st2.iter())\n+            .enumerate()\n+            .filter(|&(idx, _)| idx != coerce_generic_index)\n+            .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+\n+        Some(ret)\n+    }\n+\n+    /// Check if `from_ty: Unsize<to_ty>`, and coerce to `to_ty` if it holds.\n+    ///\n+    /// It should not be directly called. It is only used by `try_coerce_unsized`.\n+    ///\n+    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\n+    fn check_unsize_and_coerce(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n         if depth > 1000 {\n             panic!(\"Infinite recursion in coercion\");\n         }\n \n         match (&from_ty, &to_ty) {\n             // `[T; N]` -> `[T]`\n             (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n-                self.unify(&st1[0], &st2[0])\n+                Some(self.unify(&st1[0], &st2[0]))\n             }\n \n             // `T` -> `dyn Trait` when `T: Trait`\n             (_, Ty::Dyn(_)) => {\n                 // FIXME: Check predicates\n-                true\n+                Some(true)\n             }\n \n+            // `(..., T)` -> `(..., U)` when `T: Unsize<U>`\n+            (\n+                ty_app!(TypeCtor::Tuple { cardinality: len1 }, st1),\n+                ty_app!(TypeCtor::Tuple { cardinality: len2 }, st2),\n+            ) => {\n+                if len1 != len2 || *len1 == 0 {\n+                    return None;\n+                }\n+\n+                match self.check_unsize_and_coerce(\n+                    st1.last().unwrap(),\n+                    st2.last().unwrap(),\n+                    depth + 1,\n+                ) {\n+                    Some(true) => {}\n+                    ret => return ret,\n+                }\n+\n+                let ret = st1[..st1.len() - 1]\n+                    .iter()\n+                    .zip(&st2[..st2.len() - 1])\n+                    .all(|(ty1, ty2)| self.unify(ty1, ty2));\n+\n+                Some(ret)\n+            }\n+\n+            // Foo<..., T, ...> is Unsize<Foo<..., U, ...>> if:\n+            // - T: Unsize<U>\n+            // - Foo is a struct\n+            // - Only the last field of Foo has a type involving T\n+            // - T is not part of the type of any other fields\n+            // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n             (\n                 ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n                 ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n             ) if struct1 == struct2 => {\n-                // FIXME: Check preconditions here\n-                for (ty1, ty2) in st1.iter().zip(st2.iter()) {\n-                    if !self.try_coerce_unsized(ty1, ty2, depth + 1) {\n-                        return false;\n+                let fields = struct1.fields(self.db);\n+                let (last_field, prev_fields) = fields.split_last()?;\n+\n+                // Get the generic parameter involved in the last field.\n+                let unsize_generic_index = {\n+                    let mut index = None;\n+                    let mut multiple_param = false;\n+                    last_field.ty(self.db).walk(&mut |ty| match ty {\n+                        &Ty::Param { idx, .. } => {\n+                            if index.is_none() {\n+                                index = Some(idx);\n+                            } else if Some(idx) != index {\n+                                multiple_param = true;\n+                            }\n+                        }\n+                        _ => {}\n+                    });\n+\n+                    if multiple_param {\n+                        return None;\n                     }\n+                    index?\n+                };\n+\n+                // Check other fields do not involve it.\n+                let mut multiple_used = false;\n+                prev_fields.iter().for_each(|field| {\n+                    field.ty(self.db).walk(&mut |ty| match ty {\n+                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n+                            multiple_used = true\n+                        }\n+                        _ => {}\n+                    })\n+                });\n+                if multiple_used {\n+                    return None;\n                 }\n-                true\n+\n+                let unsize_generic_index = unsize_generic_index as usize;\n+\n+                // Check `Unsize` first\n+                match self.check_unsize_and_coerce(\n+                    st1.get(unsize_generic_index)?,\n+                    st2.get(unsize_generic_index)?,\n+                    depth + 1,\n+                ) {\n+                    Some(true) => {}\n+                    ret => return ret,\n+                }\n+\n+                // Then unify other parameters\n+                let ret = st1\n+                    .iter()\n+                    .zip(st2.iter())\n+                    .enumerate()\n+                    .filter(|&(idx, _)| idx != unsize_generic_index)\n+                    .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+\n+                Some(ret)\n             }\n \n-            _ => false,\n+            _ => None,\n         }\n     }\n \n@@ -1433,12 +1589,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     let decl_ty =\n                         type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n                     let decl_ty = self.insert_type_vars(decl_ty);\n-                    let ty = if let Some(expr) = initializer {\n-                        self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty))\n-                    } else {\n-                        decl_ty\n-                    };\n+                    if let Some(expr) = initializer {\n+                        self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n+                    }\n \n+                    let ty = self.resolve_ty_as_possible(&mut vec![], decl_ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {"}, {"sha": "cd5a05092b3fd7bd9297cf2147ba5321f43d122e", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 5, "deletions": 197, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=5807e261c27e4964fc6a8d2b8cf02e548292b940", "patch": "@@ -21,6 +21,7 @@ use crate::{\n // update the snapshots.\n \n mod never_type;\n+mod coercion;\n \n #[test]\n fn infer_await() {\n@@ -925,196 +926,6 @@ fn test(a: A<i32>) {\n     );\n }\n \n-#[test]\n-fn infer_if_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test() {\n-    let x = if true {\n-        foo(&[1])\n-    } else {\n-        &[1]\n-    };\n-}\n-\"#),\n-        @r###\"\n-    [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n-    [30; 37) 'loop {}': !\n-    [35; 37) '{}': ()\n-    [50; 126) '{     ...  }; }': ()\n-    [60; 61) 'x': &[i32]\n-    [64; 123) 'if tru...     }': &[i32]\n-    [67; 71) 'true': bool\n-    [72; 97) '{     ...     }': &[i32]\n-    [82; 85) 'foo': fn foo<i32>(&[T]) -> &[T]\n-    [82; 91) 'foo(&[1])': &[i32]\n-    [86; 90) '&[1]': &[i32;_]\n-    [87; 90) '[1]': [i32;_]\n-    [88; 89) '1': i32\n-    [103; 123) '{     ...     }': &[i32;_]\n-    [113; 117) '&[1]': &[i32;_]\n-    [114; 117) '[1]': [i32;_]\n-    [115; 116) '1': i32\n-\"###\n-    );\n-}\n-\n-#[test]\n-fn infer_if_else_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test() {\n-    let x = if true {\n-        &[1]\n-    } else {\n-        foo(&[1])\n-    };\n-}\n-\"#),\n-        @r###\"\n-    [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n-    [30; 37) 'loop {}': !\n-    [35; 37) '{}': ()\n-    [50; 126) '{     ...  }; }': ()\n-    [60; 61) 'x': &[i32]\n-    [64; 123) 'if tru...     }': &[i32]\n-    [67; 71) 'true': bool\n-    [72; 92) '{     ...     }': &[i32;_]\n-    [82; 86) '&[1]': &[i32;_]\n-    [83; 86) '[1]': [i32;_]\n-    [84; 85) '1': i32\n-    [98; 123) '{     ...     }': &[i32]\n-    [108; 111) 'foo': fn foo<i32>(&[T]) -> &[T]\n-    [108; 117) 'foo(&[1])': &[i32]\n-    [112; 116) '&[1]': &[i32;_]\n-    [113; 116) '[1]': [i32;_]\n-    [114; 115) '1': i32\n-\"###\n-    );\n-}\n-\n-#[test]\n-fn infer_match_first_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test(i: i32) {\n-    let x = match i {\n-        2 => foo(&[2]),\n-        1 => &[1],\n-        _ => &[3],\n-    };\n-}\n-\"#),\n-        @r###\"\n-    [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n-    [30; 37) 'loop {}': !\n-    [35; 37) '{}': ()\n-    [48; 49) 'i': i32\n-    [56; 150) '{     ...  }; }': ()\n-    [66; 67) 'x': &[i32]\n-    [70; 147) 'match ...     }': &[i32]\n-    [76; 77) 'i': i32\n-    [88; 89) '2': i32\n-    [93; 96) 'foo': fn foo<i32>(&[T]) -> &[T]\n-    [93; 102) 'foo(&[2])': &[i32]\n-    [97; 101) '&[2]': &[i32;_]\n-    [98; 101) '[2]': [i32;_]\n-    [99; 100) '2': i32\n-    [112; 113) '1': i32\n-    [117; 121) '&[1]': &[i32;_]\n-    [118; 121) '[1]': [i32;_]\n-    [119; 120) '1': i32\n-    [131; 132) '_': i32\n-    [136; 140) '&[3]': &[i32;_]\n-    [137; 140) '[3]': [i32;_]\n-    [138; 139) '3': i32\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn infer_match_second_coerce() {\n-    assert_snapshot!(\n-        infer(r#\"\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n-fn test(i: i32) {\n-    let x = match i {\n-        1 => &[1],\n-        2 => foo(&[2]),\n-        _ => &[3],\n-    };\n-}\n-\"#),\n-        @r###\"\n-    [11; 12) 'x': &[T]\n-    [28; 39) '{ loop {} }': !\n-    [30; 37) 'loop {}': !\n-    [35; 37) '{}': ()\n-    [48; 49) 'i': i32\n-    [56; 150) '{     ...  }; }': ()\n-    [66; 67) 'x': &[i32]\n-    [70; 147) 'match ...     }': &[i32]\n-    [76; 77) 'i': i32\n-    [88; 89) '1': i32\n-    [93; 97) '&[1]': &[i32;_]\n-    [94; 97) '[1]': [i32;_]\n-    [95; 96) '1': i32\n-    [107; 108) '2': i32\n-    [112; 115) 'foo': fn foo<i32>(&[T]) -> &[T]\n-    [112; 121) 'foo(&[2])': &[i32]\n-    [116; 120) '&[2]': &[i32;_]\n-    [117; 120) '[2]': [i32;_]\n-    [118; 119) '2': i32\n-    [131; 132) '_': i32\n-    [136; 140) '&[3]': &[i32;_]\n-    [137; 140) '[3]': [i32;_]\n-    [138; 139) '3': i32\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn coerce_merge_one_by_one1() {\n-    covers!(coerce_merge_fail_fallback);\n-\n-    assert_snapshot!(\n-        infer(r#\"\n-fn test() {\n-    let t = &mut 1;\n-    let x = match 1 {\n-        1 => t as *mut i32,\n-        2 => t as &i32,\n-        _ => t as *const i32,\n-    };\n-}\n-\"#),\n-        @r###\"\n-    [11; 145) '{     ...  }; }': ()\n-    [21; 22) 't': &mut i32\n-    [25; 31) '&mut 1': &mut i32\n-    [30; 31) '1': i32\n-    [41; 42) 'x': *const i32\n-    [45; 142) 'match ...     }': *const i32\n-    [51; 52) '1': i32\n-    [63; 64) '1': i32\n-    [68; 69) 't': &mut i32\n-    [68; 81) 't as *mut i32': *mut i32\n-    [91; 92) '2': i32\n-    [96; 97) 't': &mut i32\n-    [96; 105) 't as &i32': &i32\n-    [115; 116) '_': i32\n-    [120; 121) 't': &mut i32\n-    [120; 135) 't as *const i32': *const i32\n-    \"###\n-    );\n-}\n-\n #[test]\n fn bug_484() {\n     assert_snapshot!(\n@@ -1302,7 +1113,6 @@ fn test(x: &str, y: isize) {\n }\n \"#),\n         @r###\"\n-\n     [9; 10) 'x': &str\n     [18; 19) 'y': isize\n     [28; 324) '{     ... 3]; }': ()\n@@ -1355,7 +1165,7 @@ fn test(x: &str, y: isize) {\n     [260; 263) '\"b\"': &str\n     [275; 276) 'x': [u8;_]\n     [288; 290) '[]': [u8;_]\n-    [300; 301) 'z': &[u8;_]\n+    [300; 301) 'z': &[u8]\n     [311; 321) '&[1, 2, 3]': &[u8;_]\n     [312; 321) '[1, 2, 3]': [u8;_]\n     [313; 314) '1': u8\n@@ -2288,10 +2098,9 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n     [11; 48) '{     ...&y]; }': ()\n     [21; 22) 'y': &{unknown}\n-    [25; 32) 'unknown': &{unknown}\n+    [25; 32) 'unknown': &&{unknown}\n     [38; 45) '[y, &y]': [&&{unknown};_]\n     [39; 40) 'y': &{unknown}\n     [42; 44) '&y': &&{unknown}\n@@ -2313,12 +2122,11 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n     [11; 80) '{     ...x)]; }': ()\n     [21; 22) 'x': &&{unknown}\n-    [25; 32) 'unknown': &&{unknown}\n+    [25; 32) 'unknown': &&&{unknown}\n     [42; 43) 'y': &&{unknown}\n-    [46; 53) 'unknown': &&{unknown}\n+    [46; 53) 'unknown': &&&{unknown}\n     [59; 77) '[(x, y..., &x)]': [(&&{unknown}, &&{unknown});_]\n     [60; 66) '(x, y)': (&&{unknown}, &&{unknown})\n     [61; 62) 'x': &&{unknown}"}, {"sha": "d80d3fb6f4158a6f49093337c851d1c17fea2dfa", "filename": "crates/ra_hir/src/ty/tests/coercion.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs?ref=5807e261c27e4964fc6a8d2b8cf02e548292b940", "patch": "@@ -0,0 +1,278 @@\n+use insta::assert_snapshot;\n+use test_utils::covers;\n+\n+// Infer with some common definitions and impls.\n+fn infer(source: &str) -> String {\n+    let defs = r#\"\n+        #[lang = \"sized\"]\n+        pub trait Sized {}\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T: ?Sized> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n+\n+        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+    \"#;\n+\n+    // Append to the end to keep positions unchanged.\n+    super::infer(&format!(\"{}{}\", source, defs))\n+}\n+\n+#[test]\n+fn infer_let_stmt_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let x: &[i32] = &[1];\n+}\n+\"#),\n+        @r###\"\n+    [11; 40) '{     ...[1]; }': ()\n+    [21; 22) 'x': &[i32]\n+    [33; 37) '&[1]': &[i32;_]\n+    [34; 37) '[1]': [i32;_]\n+    [35; 36) '1': i32\n+    \"###);\n+}\n+\n+#[test]\n+fn infer_custom_coerce_unsized() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T: ?Sized>(*const T);\n+struct B<T: ?Sized>(*const T);\n+struct C<T: ?Sized> { inner: *const T }\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n+\n+fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n+fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n+fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n+\n+fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n+    let d = foo1(a);\n+    let e = foo2(b);\n+    let f = foo3(c);\n+}\n+\"#),\n+        @r###\"\n+    [258; 259) 'x': A<[T]>\n+    [279; 284) '{ x }': A<[T]>\n+    [281; 282) 'x': A<[T]>\n+    [296; 297) 'x': B<[T]>\n+    [317; 322) '{ x }': B<[T]>\n+    [319; 320) 'x': B<[T]>\n+    [334; 335) 'x': C<[T]>\n+    [355; 360) '{ x }': C<[T]>\n+    [357; 358) 'x': C<[T]>\n+    [370; 371) 'a': A<[u8;_]>\n+    [385; 386) 'b': B<[u8;_]>\n+    [400; 401) 'c': C<[u8;_]>\n+    [415; 481) '{     ...(c); }': ()\n+    [425; 426) 'd': A<[{unknown}]>\n+    [429; 433) 'foo1': fn foo1<{unknown}>(A<[T]>) -> A<[T]>\n+    [429; 436) 'foo1(a)': A<[{unknown}]>\n+    [434; 435) 'a': A<[u8;_]>\n+    [446; 447) 'e': B<[u8]>\n+    [450; 454) 'foo2': fn foo2<u8>(B<[T]>) -> B<[T]>\n+    [450; 457) 'foo2(b)': B<[u8]>\n+    [455; 456) 'b': B<[u8;_]>\n+    [467; 468) 'f': C<[u8]>\n+    [471; 475) 'foo3': fn foo3<u8>(C<[T]>) -> C<[T]>\n+    [471; 478) 'foo3(c)': C<[u8]>\n+    [476; 477) 'c': C<[u8;_]>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_if_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        foo(&[1])\n+    } else {\n+        &[1]\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [50; 126) '{     ...  }; }': ()\n+    [60; 61) 'x': &[i32]\n+    [64; 123) 'if tru...     }': &[i32]\n+    [67; 71) 'true': bool\n+    [72; 97) '{     ...     }': &[i32]\n+    [82; 85) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [82; 91) 'foo(&[1])': &[i32]\n+    [86; 90) '&[1]': &[i32;_]\n+    [87; 90) '[1]': [i32;_]\n+    [88; 89) '1': i32\n+    [103; 123) '{     ...     }': &[i32;_]\n+    [113; 117) '&[1]': &[i32;_]\n+    [114; 117) '[1]': [i32;_]\n+    [115; 116) '1': i32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_if_else_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        &[1]\n+    } else {\n+        foo(&[1])\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [50; 126) '{     ...  }; }': ()\n+    [60; 61) 'x': &[i32]\n+    [64; 123) 'if tru...     }': &[i32]\n+    [67; 71) 'true': bool\n+    [72; 92) '{     ...     }': &[i32;_]\n+    [82; 86) '&[1]': &[i32;_]\n+    [83; 86) '[1]': [i32;_]\n+    [84; 85) '1': i32\n+    [98; 123) '{     ...     }': &[i32]\n+    [108; 111) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [108; 117) 'foo(&[1])': &[i32]\n+    [112; 116) '&[1]': &[i32;_]\n+    [113; 116) '[1]': [i32;_]\n+    [114; 115) '1': i32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_match_first_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        2 => foo(&[2]),\n+        1 => &[1],\n+        _ => &[3],\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [48; 49) 'i': i32\n+    [56; 150) '{     ...  }; }': ()\n+    [66; 67) 'x': &[i32]\n+    [70; 147) 'match ...     }': &[i32]\n+    [76; 77) 'i': i32\n+    [88; 89) '2': i32\n+    [93; 96) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [93; 102) 'foo(&[2])': &[i32]\n+    [97; 101) '&[2]': &[i32;_]\n+    [98; 101) '[2]': [i32;_]\n+    [99; 100) '2': i32\n+    [112; 113) '1': i32\n+    [117; 121) '&[1]': &[i32;_]\n+    [118; 121) '[1]': [i32;_]\n+    [119; 120) '1': i32\n+    [131; 132) '_': i32\n+    [136; 140) '&[3]': &[i32;_]\n+    [137; 140) '[3]': [i32;_]\n+    [138; 139) '3': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_match_second_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        1 => &[1],\n+        2 => foo(&[2]),\n+        _ => &[3],\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [48; 49) 'i': i32\n+    [56; 150) '{     ...  }; }': ()\n+    [66; 67) 'x': &[i32]\n+    [70; 147) 'match ...     }': &[i32]\n+    [76; 77) 'i': i32\n+    [88; 89) '1': i32\n+    [93; 97) '&[1]': &[i32;_]\n+    [94; 97) '[1]': [i32;_]\n+    [95; 96) '1': i32\n+    [107; 108) '2': i32\n+    [112; 115) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [112; 121) 'foo(&[2])': &[i32]\n+    [116; 120) '&[2]': &[i32;_]\n+    [117; 120) '[2]': [i32;_]\n+    [118; 119) '2': i32\n+    [131; 132) '_': i32\n+    [136; 140) '&[3]': &[i32;_]\n+    [137; 140) '[3]': [i32;_]\n+    [138; 139) '3': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_merge_one_by_one1() {\n+    covers!(coerce_merge_fail_fallback);\n+\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let t = &mut 1;\n+    let x = match 1 {\n+        1 => t as *mut i32,\n+        2 => t as &i32,\n+        _ => t as *const i32,\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 145) '{     ...  }; }': ()\n+    [21; 22) 't': &mut i32\n+    [25; 31) '&mut 1': &mut i32\n+    [30; 31) '1': i32\n+    [41; 42) 'x': *const i32\n+    [45; 142) 'match ...     }': *const i32\n+    [51; 52) '1': i32\n+    [63; 64) '1': i32\n+    [68; 69) 't': &mut i32\n+    [68; 81) 't as *mut i32': *mut i32\n+    [91; 92) '2': i32\n+    [96; 97) 't': &mut i32\n+    [96; 105) 't as &i32': &i32\n+    [115; 116) '_': i32\n+    [120; 121) 't': &mut i32\n+    [120; 135) 't as *const i32': *const i32\n+    \"###\n+    );\n+}"}, {"sha": "c202f545a3799852f93f47dbc1be8872a08b796c", "filename": "crates/ra_hir/src/ty/tests/never_type.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5807e261c27e4964fc6a8d2b8cf02e548292b940/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs?ref=5807e261c27e4964fc6a8d2b8cf02e548292b940", "patch": "@@ -19,12 +19,10 @@ fn infer_never2() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n-trait Foo { fn gen() -> Self; }\n-impl Foo for ! { fn gen() -> Self { loop {} } }\n-impl Foo for () { fn gen() -> Self { loop {} } }\n+fn gen<T>() -> T { loop {} }\n \n fn test() {\n-    let a = Foo::gen();\n+    let a = gen();\n     if false { a } else { loop {} };\n     a<|>;\n }\n@@ -38,12 +36,10 @@ fn infer_never3() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n-trait Foo { fn gen() -> Self; }\n-impl Foo for ! { fn gen() -> Self { loop {} } }\n-impl Foo for () { fn gen() -> Self { loop {} } }\n+fn gen<T>() -> T { loop {} }\n \n fn test() {\n-    let a = Foo::gen();\n+    let a = gen();\n     if false { loop {} } else { a };\n     a<|>;\n }\n@@ -73,12 +69,10 @@ fn never_type_can_be_reinferred1() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n-trait Foo { fn gen() -> Self; }\n-impl Foo for ! { fn gen() -> Self { loop {} } }\n-impl Foo for () { fn gen() -> Self { loop {} } }\n+fn gen<T>() -> T { loop {} }\n \n fn test() {\n-    let a = Foo::gen();\n+    let a = gen();\n     if false { loop {} } else { a };\n     a<|>;\n     if false { a };\n@@ -154,8 +148,7 @@ fn test() {\n     } else {\n         3.0\n     };\n-    i<|>\n-    ()\n+    i<|>;\n }\n \"#,\n     );\n@@ -173,8 +166,7 @@ fn test(input: bool) {\n     } else {\n         return\n     };\n-    i<|>\n-    ()\n+    i<|>;\n }\n \"#,\n     );\n@@ -193,8 +185,7 @@ fn test(a: i32) {\n         3 => loop {},\n         _ => 3.0,\n     };\n-    i<|>\n-    ()\n+    i<|>;\n }\n \"#,\n     );\n@@ -213,8 +204,7 @@ fn test(a: i32) {\n         3 => 3.0,\n         _ => return,\n     };\n-    i<|>\n-    ()\n+    i<|>;\n }\n \"#,\n     );\n@@ -231,8 +221,7 @@ fn test(a: i32) {\n         2 => return,\n         _ => loop {},\n     };\n-    i<|>\n-    ()\n+    i<|>;\n }\n \"#,\n     );\n@@ -249,8 +238,7 @@ fn test(a: i32) {\n         2 => 2.0,\n         _ => 3.0,\n     };\n-    i<|>\n-    ()\n+    i<|>;\n }\n \"#,\n     );"}]}