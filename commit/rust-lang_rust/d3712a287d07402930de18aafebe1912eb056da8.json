{"sha": "d3712a287d07402930de18aafebe1912eb056da8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNzEyYTI4N2QwNzQwMjkzMGRlMThhYWZlYmUxOTEyZWIwNTZkYTg=", "commit": {"author": {"name": "Jyun-Yan You", "email": "jyyou@cs.nctu.edu.tw", "date": "2012-03-20T18:44:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-20T18:59:24Z"}, "message": "make native and crust functions conform to x86-64 ABI", "tree": {"sha": "d0eac77e2de6dd11bef04d955bc7ff9f45c8b93b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0eac77e2de6dd11bef04d955bc7ff9f45c8b93b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3712a287d07402930de18aafebe1912eb056da8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3712a287d07402930de18aafebe1912eb056da8", "html_url": "https://github.com/rust-lang/rust/commit/d3712a287d07402930de18aafebe1912eb056da8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3712a287d07402930de18aafebe1912eb056da8/comments", "author": {"login": "crabtw", "id": 36015, "node_id": "MDQ6VXNlcjM2MDE1", "avatar_url": "https://avatars.githubusercontent.com/u/36015?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crabtw", "html_url": "https://github.com/crabtw", "followers_url": "https://api.github.com/users/crabtw/followers", "following_url": "https://api.github.com/users/crabtw/following{/other_user}", "gists_url": "https://api.github.com/users/crabtw/gists{/gist_id}", "starred_url": "https://api.github.com/users/crabtw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crabtw/subscriptions", "organizations_url": "https://api.github.com/users/crabtw/orgs", "repos_url": "https://api.github.com/users/crabtw/repos", "events_url": "https://api.github.com/users/crabtw/events{/privacy}", "received_events_url": "https://api.github.com/users/crabtw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "716dc29ffc20165a43a6cdec2d530459f5368b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/716dc29ffc20165a43a6cdec2d530459f5368b56", "html_url": "https://github.com/rust-lang/rust/commit/716dc29ffc20165a43a6cdec2d530459f5368b56"}], "stats": {"total": 599, "additions": 564, "deletions": 35}, "files": [{"sha": "0ddfa2a4cecb926b6c34a0d24ebe9e9a1ff480ce", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 564, "deletions": 35, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/d3712a287d07402930de18aafebe1912eb056da8/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3712a287d07402930de18aafebe1912eb056da8/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=d3712a287d07402930de18aafebe1912eb056da8", "patch": "@@ -1,8 +1,11 @@\n-import driver::session::session;\n+import driver::session::{session, arch_x86_64};\n import syntax::codemap::span;\n import libc::c_uint;\n import front::attr;\n-import lib::llvm::{ llvm, TypeRef, ValueRef };\n+import lib::llvm::{ llvm, TypeRef, ValueRef,\n+                    ModuleRef, CallConv, Attribute,\n+                    StructRetAttribute, ByValAttribute\n+                  };\n import syntax::ast;\n import back::link;\n import common::*;\n@@ -14,6 +17,381 @@ import std::map::hashmap;\n export link_name, trans_native_mod, register_crust_fn, trans_crust_fn,\n        decl_native_fn;\n \n+enum x86_64_reg_class {\n+    no_class,\n+    integer_class,\n+    sse_fs_class,\n+    sse_fv_class,\n+    sse_ds_class,\n+    sse_dv_class,\n+    sse_int_class,\n+    sseup_class,\n+    x87_class,\n+    x87up_class,\n+    complex_x87_class,\n+    memory_class\n+}\n+\n+fn is_sse(c: x86_64_reg_class) -> bool {\n+    ret alt c {\n+        sse_fs_class | sse_fv_class |\n+        sse_ds_class | sse_dv_class { true }\n+        _ { false }\n+    };\n+}\n+\n+fn is_ymm(cls: [x86_64_reg_class]) -> bool {\n+    let len = vec::len(cls);\n+    ret (len > 2u &&\n+         is_sse(cls[0]) &&\n+         cls[1] == sseup_class &&\n+         cls[2] == sseup_class) ||\n+        (len > 3u &&\n+         is_sse(cls[1]) &&\n+         cls[2] == sseup_class &&\n+         cls[3] == sseup_class);\n+}\n+\n+fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n+    fn align(off: uint, ty: TypeRef) -> uint {\n+        let a = ty_align(ty);\n+        ret (off + a - 1u) / a * a;\n+    }\n+\n+    fn struct_tys(ty: TypeRef) -> [TypeRef] {\n+        let n = llvm::LLVMCountStructElementTypes(ty);\n+        let elts = vec::from_elem(n as uint, ptr::null());\n+        vec::as_buf(elts) {|buf|\n+            llvm::LLVMGetStructElementTypes(ty, buf);\n+        }\n+        ret elts;\n+    }\n+\n+    fn ty_align(ty: TypeRef) -> uint {\n+        ret alt llvm::LLVMGetTypeKind(ty) as int {\n+            8 /* integer */ {\n+                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7u) / 8u\n+            }\n+            12 /* pointer */ { 8u }\n+            2 /* float */ { 4u }\n+            3 /* double */ { 8u }\n+            10 /* struct */ {\n+                vec::foldl(0u, struct_tys(ty)) {|a, t|\n+                    uint::max(a, ty_align(t))\n+                }\n+            }\n+            _ {\n+                fail \"ty_size: unhandled type\"\n+            }\n+        };\n+    }\n+\n+    fn ty_size(ty: TypeRef) -> uint {\n+        ret alt llvm::LLVMGetTypeKind(ty) as int {\n+            8 /* integer */ {\n+                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7u) / 8u\n+            }\n+            12 /* pointer */ { 8u }\n+            2 /* float */ { 4u }\n+            3 /* double */ { 8u }\n+            10 /* struct */ {\n+                vec::foldl(0u, struct_tys(ty)) {|s, t|\n+                    s + ty_size(t)\n+                }\n+            }\n+            _ {\n+                fail \"ty_size: unhandled type\"\n+            }\n+        };\n+    }\n+\n+    fn all_mem(cls: [mut x86_64_reg_class]) {\n+        vec::iteri(cls) {|i, _c|\n+            cls[i] = memory_class;\n+        }\n+    }\n+\n+    fn unify(cls: [mut x86_64_reg_class], i: uint,\n+             new: x86_64_reg_class) {\n+        if cls[i] == new {\n+            ret;\n+        } else if cls[i] == no_class {\n+            cls[i] = new;\n+        } else if new == no_class {\n+            ret;\n+        } else if cls[i] == memory_class || new == memory_class {\n+            cls[i] = memory_class;\n+        } else if cls[i] == integer_class || new == integer_class {\n+            cls[i] = integer_class;\n+        } else if cls[i] == x87_class ||\n+                  cls[i] == x87up_class ||\n+                  cls[i] == complex_x87_class ||\n+                  new == x87_class ||\n+                  new == x87up_class ||\n+                  new == complex_x87_class {\n+            cls[i] = memory_class;\n+        } else {\n+            cls[i] = new;\n+        }\n+    }\n+\n+    fn classify_struct(tys: [TypeRef],\n+                       cls: [mut x86_64_reg_class], i: uint,\n+                       off: uint) {\n+        if vec::is_empty(tys) {\n+            classify(T_i64(), cls, i, off);\n+        } else {\n+            let field_off = off;\n+            for ty in tys {\n+                field_off = align(field_off, ty);\n+                classify(ty, cls, i, field_off);\n+                field_off += ty_size(ty);\n+            }\n+        }\n+    }\n+\n+    fn classify(ty: TypeRef,\n+                cls: [mut x86_64_reg_class], i: uint,\n+                off: uint) {\n+        let t_align = ty_align(ty);\n+        let t_size = ty_size(ty);\n+\n+        let misalign = off % t_align;\n+        if misalign != 0u {\n+            let i = off / 8u;\n+            let e = (off + t_size + 7u) / 8u;\n+            while i < e {\n+                unify(cls, i, memory_class);\n+                i += 1u;\n+            }\n+            ret;\n+        }\n+\n+        alt llvm::LLVMGetTypeKind(ty) as int {\n+            8 /* integer */ |\n+            12 /* pointer */ {\n+                unify(cls, off / 8u, integer_class);\n+            }\n+            2 /* float */ {\n+                if off % 8u == 4u {\n+                    unify(cls, off / 8u, sse_fv_class);\n+                } else {\n+                    unify(cls, off / 8u, sse_fs_class);\n+                }\n+            }\n+            3 /* double */ {\n+                unify(cls, off / 8u, sse_ds_class);\n+            }\n+            10 /* struct */ {\n+                classify_struct(struct_tys(ty), cls, i, off);\n+            }\n+            _ {\n+                fail \"classify: unhandled type\";\n+            }\n+        }\n+    }\n+\n+    fn fixup(ty: TypeRef, cls: [mut x86_64_reg_class]) {\n+        let i = 0u;\n+        let e = vec::len(cls);\n+        if vec::len(cls) > 2u &&\n+           llvm::LLVMGetTypeKind(ty) as int == 10 /* struct */ {\n+            if is_sse(cls[i]) {\n+                i += 1u;\n+                while i < e {\n+                    if cls[i] != sseup_class {\n+                        all_mem(cls);\n+                        ret;\n+                    }\n+                    i += 1u;\n+                }\n+            } else {\n+                all_mem(cls);\n+                ret\n+            }\n+        } else {\n+            while i < e {\n+                if cls[i] == memory_class {\n+                    all_mem(cls);\n+                    ret;\n+                }\n+                if cls[i] == x87up_class {\n+                    // for darwin\n+                    // cls[i] = sse_ds_class;\n+                    all_mem(cls);\n+                    ret;\n+                }\n+                if cls[i] == sseup_class {\n+                    cls[i] = sse_int_class;\n+                } else if is_sse(cls[i]) {\n+                    i += 1u;\n+                    while cls[i] == sseup_class { i += 1u; }\n+                } else if cls[i] == x87_class {\n+                    i += 1u;\n+                    while cls[i] == x87up_class { i += 1u; }\n+                } else {\n+                    i += 1u;\n+                }\n+            }\n+        }\n+    }\n+\n+    let words = (ty_size(ty) + 7u) / 8u;\n+    let cls = vec::to_mut(vec::from_elem(words, no_class));\n+    if words > 4u {\n+        all_mem(cls);\n+        ret vec::from_mut(cls);\n+    }\n+    classify(ty, cls, 0u, 0u);\n+    fixup(ty, cls);\n+    ret vec::from_mut(cls);\n+}\n+\n+fn llreg_ty(cls: [x86_64_reg_class]) -> TypeRef {\n+    fn llvec_len(cls: [x86_64_reg_class]) -> uint {\n+        let len = 1u;\n+        for c in cls {\n+            if c != sseup_class {\n+                break;\n+            }\n+            len += 1u;\n+        }\n+        ret len;\n+    }\n+\n+    let tys = [];\n+    let i = 0u;\n+    let e = vec::len(cls);\n+    while i < e {\n+        alt cls[i] {\n+            integer_class {\n+                tys += [T_i64()];\n+            }\n+            sse_fv_class {\n+                let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                let vec_ty = llvm::LLVMVectorType(T_f32(),\n+                                                  vec_len as c_uint);\n+                tys += [vec_ty];\n+                i += vec_len;\n+                cont;\n+            }\n+            sse_fs_class {\n+                tys += [T_f32()];\n+            }\n+            sse_ds_class {\n+                tys += [T_f64()];\n+            }\n+            _ {\n+                fail \"llregtype: unhandled class\";\n+            }\n+        }\n+        i += 1u;\n+    }\n+    ret T_struct(tys);\n+}\n+\n+type x86_64_llty = {\n+    cast: bool,\n+    ty: TypeRef\n+};\n+\n+type x86_64_tys = {\n+    arg_tys: [x86_64_llty],\n+    ret_ty: x86_64_llty,\n+    attrs: [option<Attribute>],\n+    sret: bool\n+};\n+\n+fn x86_64_tys(atys: [TypeRef],\n+              rty: TypeRef,\n+              ret_def: bool) -> x86_64_tys {\n+    fn is_reg_ty(ty: TypeRef) -> bool {\n+        ret alt llvm::LLVMGetTypeKind(ty) as int {\n+            8 /* integer */ |\n+            12 /* pointer */ |\n+            2 /* float */ |\n+            3 /* double */ { true }\n+            _ { false }\n+        };\n+    }\n+\n+    fn is_pass_byval(cls: [x86_64_reg_class]) -> bool {\n+        ret cls[0] == memory_class ||\n+            cls[0] == x87_class ||\n+            cls[0] == complex_x87_class;\n+    }\n+\n+    fn is_ret_bysret(cls: [x86_64_reg_class]) -> bool {\n+        ret cls[0] == memory_class;\n+    }\n+\n+    fn x86_64_ty(ty: TypeRef,\n+                 is_mem_cls: fn(cls: [x86_64_reg_class]) -> bool,\n+                 attr: Attribute) -> (x86_64_llty, option<Attribute>) {\n+        let cast = false;\n+        let ty_attr = option::none;\n+        let llty = ty;\n+        if !is_reg_ty(ty) {\n+            let cls = classify_ty(ty);\n+            if is_mem_cls(cls) {\n+                llty = T_ptr(ty);\n+                ty_attr = option::some(attr);\n+            } else {\n+                cast = true;\n+                llty = llreg_ty(cls);\n+            }\n+        }\n+        ret ({ cast: cast, ty: llty }, ty_attr);\n+    }\n+\n+    let arg_tys = [];\n+    let attrs = [];\n+    for t in atys {\n+        let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n+        arg_tys += [ty];\n+        attrs += [attr];\n+    }\n+    let (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n+                                            StructRetAttribute);\n+    let sret = option::is_some(ret_attr);\n+    if sret {\n+        arg_tys = [ret_ty] + arg_tys;\n+        ret_ty = { cast:  false,\n+                   ty: T_void()\n+                 };\n+        attrs = [ret_attr] + attrs;\n+    } else if !ret_def {\n+        ret_ty = { cast: false,\n+                   ty: T_void()\n+                 };\n+    }\n+    ret {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n+}\n+\n+fn decl_x86_64_fn(tys: x86_64_tys,\n+                  decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+    let atys = vec::map(tys.arg_tys) {|t| t.ty };\n+    let rty = tys.ret_ty.ty;\n+    let fnty = T_fn(atys, rty);\n+    let llfn = decl(fnty);\n+\n+    vec::iteri(tys.attrs) {|i, a|\n+        alt a {\n+            option::some(attr) {\n+                let llarg = llvm::LLVMGetParam(llfn, i as c_uint);\n+                llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+            }\n+            _ {}\n+        }\n+    }\n+    ret llfn;\n+}\n+\n fn link_name(i: @ast::native_item) -> str {\n     alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n       none { ret i.ident; }\n@@ -26,7 +404,8 @@ type c_stack_tys = {\n     ret_ty: TypeRef,\n     ret_def: bool,\n     bundle_ty: TypeRef,\n-    shim_fn_ty: TypeRef\n+    shim_fn_ty: TypeRef,\n+    x86_64_tys: option<x86_64_tys>\n };\n \n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n@@ -45,12 +424,19 @@ fn c_stack_tys(ccx: @crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n     let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n+    let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n+    let x86_64 = if ccx.sess.targ_cfg.arch == arch_x86_64 {\n+        option::some(x86_64_tys(llargtys, llretty, ret_def))\n+    } else {\n+        option::none\n+    };\n     ret @{\n         arg_tys: llargtys,\n         ret_ty: llretty,\n-        ret_def: !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty),\n+        ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n+        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void()),\n+        x86_64_tys: x86_64\n     };\n }\n \n@@ -173,31 +559,101 @@ fn trans_native_mod(ccx: @crate_ctxt,\n             let llargvals = [];\n             let i = 0u;\n             let n = vec::len(tys.arg_tys);\n-            while i < n {\n-                let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n-                llargvals += [llargval];\n-                i += 1u;\n+\n+            alt tys.x86_64_tys {\n+                some(x86_64) {\n+                    let atys = x86_64.arg_tys;\n+                    let attrs = x86_64.attrs;\n+                    if x86_64.sret {\n+                        let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                        let llretloc = Load(bcx, llretptr);\n+                        llargvals = [llretloc];\n+                        atys = vec::tail(atys);\n+                        attrs = vec::tail(attrs);\n+                    }\n+                    while i < n {\n+                        let llargval = if atys[i].cast {\n+                            let arg_ptr = GEPi(bcx, llargbundle,\n+                                                    [0, i as int]);\n+                            arg_ptr = BitCast(bcx, arg_ptr,\n+                                                   T_ptr(atys[i].ty));\n+                            Load(bcx, arg_ptr)\n+                        } else if option::is_some(attrs[i]) {\n+                            GEPi(bcx, llargbundle, [0, i as int])\n+                        } else {\n+                            load_inbounds(bcx, llargbundle, [0, i as int])\n+                        };\n+                        llargvals += [llargval];\n+                        i += 1u;\n+                    }\n+                }\n+                _ {\n+                    while i < n {\n+                        let llargval = load_inbounds(bcx, llargbundle,\n+                                                          [0, i as int]);\n+                        llargvals += [llargval];\n+                        i += 1u;\n+                    }\n+                }\n             }\n             ret llargvals;\n         }\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n-            if tys.ret_def {\n-                let n = vec::len(tys.arg_tys);\n-                // R** llretptr = &args->r;\n-                let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n-                // R* llretloc = *llretptr; /* (args->r) */\n-                let llretloc = Load(bcx, llretptr);\n-                // *args->r = r;\n-                Store(bcx, llretval, llretloc);\n+            alt tys.x86_64_tys {\n+                some(x86_64) {\n+                    vec::iteri(x86_64.attrs) {|i, a|\n+                        alt a {\n+                            some(attr) {\n+                                llvm::LLVMAddInstrAttribute(\n+                                    llretval, (i + 1u) as c_uint,\n+                                              attr as c_uint);\n+                            }\n+                            _ {}\n+                        }\n+                    }\n+                    if x86_64.sret || !tys.ret_def {\n+                        ret;\n+                    }\n+                    let n = vec::len(tys.arg_tys);\n+                    let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                    let llretloc = Load(bcx, llretptr);\n+                    if x86_64.ret_ty.cast {\n+                        let tmp_ptr = BitCast(bcx, llretloc,\n+                                                   T_ptr(x86_64.ret_ty.ty));\n+                        Store(bcx, llretval, tmp_ptr);\n+                    } else {\n+                        Store(bcx, llretval, llretloc);\n+                    };\n+                }\n+                _ {\n+                    if tys.ret_def {\n+                        let n = vec::len(tys.arg_tys);\n+                        // R** llretptr = &args->r;\n+                        let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                        // R* llretloc = *llretptr; /* (args->r) */\n+                        let llretloc = Load(bcx, llretptr);\n+                        // *args->r = r;\n+                        Store(bcx, llretval, llretloc);\n+                    }\n+                }\n             }\n         }\n \n         let lname = link_name(native_item);\n         // Declare the \"prototype\" for the base function F:\n-        let llbasefnty = T_fn(tys.arg_tys, tys.ret_ty);\n-        let llbasefn = decl_fn(ccx.llmod, lname, cc, llbasefnty);\n+        let llbasefn = alt tys.x86_64_tys {\n+            some(x86_64) {\n+                decl_x86_64_fn(x86_64) {|fnty|\n+                    decl_fn(ccx.llmod, lname, cc, fnty)\n+                }\n+            }\n+            _ {\n+                let llbasefnty = T_fn(tys.arg_tys, tys.ret_ty);\n+                decl_fn(ccx.llmod, lname, cc, llbasefnty)\n+            }\n+        };\n         // Name the shim function\n         let shim_name = lname + \"__c_stack_shim\";\n         ret build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n@@ -311,23 +767,87 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-            let llretptr = alloca(bcx, tys.ret_ty);\n-            let i = 0u, n = vec::len(tys.arg_tys);\n-            while i < n {\n-                let llargval = llvm::LLVMGetParam(\n-                    llwrapfn, i as c_uint);\n-                store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n-                i += 1u;\n+            alt tys.x86_64_tys {\n+                option::some(x86_64) {\n+                    let atys = x86_64.arg_tys;\n+                    let attrs = x86_64.attrs;\n+                    let j = 0u;\n+                    let llretptr = if x86_64.sret {\n+                        atys = vec::tail(atys);\n+                        attrs = vec::tail(attrs);\n+                        j = 1u;\n+                        llvm::LLVMGetParam(llwrapfn, 0 as c_uint)\n+                    } else if x86_64.ret_ty.cast {\n+                        let retptr = alloca(bcx, x86_64.ret_ty.ty);\n+                        BitCast(bcx, retptr, T_ptr(tys.ret_ty))\n+                    } else {\n+                        alloca(bcx, tys.ret_ty)\n+                    };\n+\n+                    let i = 0u, n = vec::len(atys);\n+                    while i < n {\n+                        let argval = llvm::LLVMGetParam(llwrapfn,\n+                                                        (i + j) as c_uint);\n+                        if option::is_some(attrs[i]) {\n+                            argval = Load(bcx, argval);\n+                            store_inbounds(bcx, argval, llargbundle,\n+                                                        [0, i as int]);\n+                        } else if atys[i].cast {\n+                            let argptr = GEPi(bcx, llargbundle,\n+                                                   [0, i as int]);\n+                            argptr = BitCast(bcx, argptr, T_ptr(atys[i].ty));\n+                            Store(bcx, argval, argptr);\n+                        } else {\n+                            store_inbounds(bcx, argval, llargbundle,\n+                                                        [0, i as int]);\n+                        }\n+                        i += 1u;\n+                    }\n+                    store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+                }\n+                _ {\n+                    let llretptr = alloca(bcx, tys.ret_ty);\n+                    let i = 0u, n = vec::len(tys.arg_tys);\n+                    while i < n {\n+                        let llargval = llvm::LLVMGetParam(llwrapfn,\n+                                                          i as c_uint);\n+                        store_inbounds(bcx, llargval, llargbundle,\n+                                                      [0, i as int]);\n+                        i += 1u;\n+                    }\n+                    store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+                }\n             }\n-            store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n         }\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n-            let n = vec::len(tys.arg_tys);\n-            let llretval = load_inbounds(bcx, llargbundle, [0, n as int]);\n-            let llretval = Load(bcx, llretval);\n-            Ret(bcx, llretval);\n+            alt tys.x86_64_tys {\n+                option::some(x86_64) {\n+                    if x86_64.sret || !tys.ret_def {\n+                        RetVoid(bcx);\n+                        ret;\n+                    }\n+                    let n = vec::len(tys.arg_tys);\n+                    let llretval = load_inbounds(bcx, llargbundle,\n+                                                      [0, n as int]);\n+                    let llretval = if x86_64.ret_ty.cast {\n+                        let retptr = BitCast(bcx, llretval,\n+                                                  T_ptr(x86_64.ret_ty.ty));\n+                        Load(bcx, retptr)\n+                    } else {\n+                        Load(bcx, llretval)\n+                    };\n+                    Ret(bcx, llretval);\n+                }\n+                _ {\n+                    let n = vec::len(tys.arg_tys);\n+                    let llretval = load_inbounds(bcx, llargbundle,\n+                                                      [0, n as int]);\n+                    let llretval = Load(bcx, llretval);\n+                    Ret(bcx, llretval);\n+                }\n+            }\n         }\n \n         build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n@@ -348,10 +868,19 @@ fn register_crust_fn(ccx: @crate_ctxt, sp: span,\n                      path: ast_map::path, node_id: ast::node_id)\n     -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    let (llargtys, llretty, _) = c_arg_and_ret_lltys(ccx, node_id);\n-    let llfty = T_fn(llargtys, llretty);\n-    register_fn_fuller(ccx, sp, path, \"crust fn\", node_id,\n-                       t, lib::llvm::CCallConv, llfty)\n+    let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n+    ret if ccx.sess.targ_cfg.arch == arch_x86_64 {\n+        let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n+        let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n+        decl_x86_64_fn(x86_64) {|fnty|\n+            register_fn_fuller(ccx, sp, path, \"crust fn\", node_id,\n+                               t, lib::llvm::CCallConv, fnty)\n+        }\n+    } else {\n+        let llfty = T_fn(llargtys, llretty);\n+        register_fn_fuller(ccx, sp, path, \"crust fn\", node_id,\n+                           t, lib::llvm::CCallConv, llfty)\n+    }\n }\n \n fn abi_of_native_fn(ccx: @crate_ctxt, i: @ast::native_item)"}]}