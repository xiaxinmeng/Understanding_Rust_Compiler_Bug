{"sha": "fec59c5f737d044df31284090dcab2a7b678982d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYzU5YzVmNzM3ZDA0NGRmMzEyODQwOTBkY2FiMmE3YjY3ODk4MmQ=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-11T23:28:10Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:01:41Z"}, "message": "Replace lpad().and_then(..) with None", "tree": {"sha": "15a3a4058217fe3d22fcec7b1be2294f1e4211ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15a3a4058217fe3d22fcec7b1be2294f1e4211ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fec59c5f737d044df31284090dcab2a7b678982d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fec59c5f737d044df31284090dcab2a7b678982d", "html_url": "https://github.com/rust-lang/rust/commit/fec59c5f737d044df31284090dcab2a7b678982d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fec59c5f737d044df31284090dcab2a7b678982d/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad0a901d3739660bce7cb464da2ab5bcf519fbf8", "html_url": "https://github.com/rust-lang/rust/commit/ad0a901d3739660bce7cb464da2ab5bcf519fbf8"}], "stats": {"total": 134, "additions": 63, "deletions": 71}, "files": [{"sha": "84d7b6bc7c9bd53fda6815e65978679336b6508c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=fec59c5f737d044df31284090dcab2a7b678982d", "patch": "@@ -205,7 +205,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     // Allocate space:\n     let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n     let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[])).reify(bcx.ccx());\n-    bcx.pointercast(bcx.call(r, &[size, align], bcx.lpad().and_then(|b| b.bundle())), llty_ptr)\n+    bcx.pointercast(bcx.call(r, &[size, align], None), llty_ptr)\n }\n \n \n@@ -451,38 +451,6 @@ fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n     }\n }\n \n-pub fn invoke<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n-                          llfn: ValueRef,\n-                          llargs: &[ValueRef])\n-                          -> (ValueRef, BlockAndBuilder<'blk, 'tcx>) {\n-    let _icx = push_ctxt(\"invoke_\");\n-    if need_invoke(&bcx) {\n-        debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb());\n-        for &llarg in llargs {\n-            debug!(\"arg: {:?}\", Value(llarg));\n-        }\n-        let normal_bcx = bcx.fcx().new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx().get_landing_pad();\n-\n-        let llresult = bcx.invoke(\n-            llfn,\n-            &llargs[..],\n-            normal_bcx.llbb,\n-            landing_pad,\n-            bcx.lpad().and_then(|b| b.bundle())\n-        );\n-        return (llresult, normal_bcx.build());\n-    } else {\n-        debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb());\n-        for &llarg in llargs {\n-            debug!(\"arg: {:?}\", Value(llarg));\n-        }\n-\n-        let llresult = bcx.call(llfn, &llargs[..], bcx.lpad().and_then(|b| b.bundle()));\n-        return (llresult, bcx);\n-    }\n-}\n-\n /// Returns whether this session's target will use SEH-based unwinding.\n ///\n /// This is only true for MSVC targets, and even then the 64-bit MSVC target\n@@ -492,14 +460,6 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-fn need_invoke(bcx: &BlockAndBuilder) -> bool {\n-    if bcx.sess().no_landing_pads() || bcx.lpad().is_some() {\n-        false\n-    } else {\n-        bcx.fcx().needs_invoke()\n-    }\n-}\n-\n pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n     let assume_intrinsic = b.ccx.get_intrinsic(\"llvm.assume\");\n     b.call(assume_intrinsic, &[val], None);"}, {"sha": "331945a5a44a5dd682802f16f02f07b057806cf3", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=fec59c5f737d044df31284090dcab2a7b678982d", "patch": "@@ -209,9 +209,10 @@ impl<'tcx> Callee<'tcx> {\n     /// function.\n     pub fn call<'a, 'blk>(self, bcx: BlockAndBuilder<'blk, 'tcx>,\n                           args: &[ValueRef],\n-                          dest: Option<ValueRef>)\n+                          dest: Option<ValueRef>,\n+                          lpad: Option<&'blk llvm::OperandBundleDef>)\n                           -> (BlockAndBuilder<'blk, 'tcx>, ValueRef) {\n-        trans_call_inner(bcx, self, args, dest)\n+        trans_call_inner(bcx, self, args, dest, lpad)\n     }\n \n     /// Turn the callee into a function pointer.\n@@ -411,7 +412,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let self_scope = fcx.push_custom_cleanup_scope();\n     fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n \n-    let bcx = callee.call(bcx, &llargs[self_idx..], dest).0;\n+    let bcx = callee.call(bcx, &llargs[self_idx..], dest, None).0;\n \n     let bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n \n@@ -540,7 +541,7 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n         data: Fn(llfnpointer),\n         ty: bare_fn_ty\n     };\n-    let bcx = callee.call(bcx, &llargs[(self_idx + 1)..], dest).0;\n+    let bcx = callee.call(bcx, &llargs[(self_idx + 1)..], dest, None).0;\n     fcx.finish(&bcx);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n@@ -653,7 +654,8 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n                                     callee: Callee<'tcx>,\n                                     args: &[ValueRef],\n-                                    opt_llretslot: Option<ValueRef>)\n+                                    opt_llretslot: Option<ValueRef>,\n+                                    lpad: Option<&'blk llvm::OperandBundleDef>)\n                                     -> (BlockAndBuilder<'blk, 'tcx>, ValueRef) {\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n@@ -707,7 +709,40 @@ fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n     };\n \n-    let (llret, bcx) = base::invoke(bcx, llfn, &llargs);\n+    fn need_invoke(bcx: &BlockAndBuilder, had_lpad: bool) -> bool {\n+        if bcx.sess().no_landing_pads() || had_lpad {\n+            false\n+        } else {\n+            bcx.fcx().needs_invoke()\n+        }\n+    }\n+\n+    let _icx = push_ctxt(\"invoke_\");\n+    let (llret, bcx) = if need_invoke(&bcx, lpad.is_some()) {\n+        debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb());\n+        for &llarg in &llargs {\n+            debug!(\"arg: {:?}\", Value(llarg));\n+        }\n+        let normal_bcx = bcx.fcx().new_block(\"normal-return\");\n+        let landing_pad = bcx.fcx().get_landing_pad();\n+\n+        let llresult = bcx.invoke(\n+            llfn,\n+            &llargs[..],\n+            normal_bcx.llbb,\n+            landing_pad,\n+            lpad,\n+        );\n+        (llresult, normal_bcx.build())\n+    } else {\n+        debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb());\n+        for &llarg in &llargs {\n+            debug!(\"arg: {:?}\", Value(llarg));\n+        }\n+\n+        let llresult = bcx.call(llfn, &llargs[..], lpad);\n+        (llresult, bcx)\n+    };\n     fn_ty.apply_attrs_callsite(llret);\n \n     // If the function we just called does not use an outpointer,"}, {"sha": "e6db048cf86a7a29a95a8d3cc75ad89896e49add", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=fec59c5f737d044df31284090dcab2a7b678982d", "patch": "@@ -46,7 +46,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [bcx.pointercast(v, Type::i8p(bcx.ccx())), size, align];\n     Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]))\n-        .call(bcx, &args, None).0\n+        .call(bcx, &args, None, None).0\n }\n \n pub fn trans_exchange_free<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n@@ -288,8 +288,7 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n     let dtor_did = def.destructor().unwrap();\n-    bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n-        .call(bcx, args, None).0;\n+    bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs).call(bcx, args, None, None).0;\n \n     bcx.fcx().pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n@@ -456,9 +455,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n             let data_ptr = get_dataptr(&bcx, v0);\n             let vtable_ptr = bcx.load(get_meta(&bcx, v0));\n             let dtor = bcx.load(vtable_ptr);\n-            bcx.call(dtor,\n-                &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx()))],\n-                bcx.lpad().and_then(|b| b.bundle()));\n+            bcx.call(dtor, &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx()))], None);\n             bcx\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {"}, {"sha": "303f0f273625af0a353b9f39d17800d9c28ad061", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=fec59c5f737d044df31284090dcab2a7b678982d", "patch": "@@ -119,7 +119,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     // These are the only intrinsic functions that diverge.\n     if name == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        bcx.call(llfn, &[], bcx.lpad().and_then(|b| b.bundle()));\n+        bcx.call(llfn, &[], None);\n         return;\n     } else if name == \"unreachable\" {\n         // FIXME: do nothing?\n@@ -131,23 +131,23 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match (simple, name) {\n         (Some(llfn), _) => {\n-            bcx.call(llfn, &llargs, bcx.lpad().and_then(|b| b.bundle()))\n+            bcx.call(llfn, &llargs, None)\n         }\n         (_, \"likely\") => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[llargs[0], C_bool(ccx, true)], bcx.lpad().and_then(|b| b.bundle()))\n+            bcx.call(expect, &[llargs[0], C_bool(ccx, true)], None)\n         }\n         (_, \"unlikely\") => {\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[llargs[0], C_bool(ccx, false)], bcx.lpad().and_then(|b| b.bundle()))\n+            bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n         }\n         (_, \"try\") => {\n             try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult);\n             C_nil(ccx)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            bcx.call(llfn, &[], bcx.lpad().and_then(|b| b.bundle()))\n+            bcx.call(llfn, &[], None)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = substs.type_at(0);\n@@ -318,13 +318,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                         \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n                                                         llargs[0]),\n                         \"ctpop\" => bcx.call(ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n-                                        &llargs, bcx.lpad().and_then(|b| b.bundle())),\n+                                        &llargs, None),\n                         \"bswap\" => {\n                             if width == 8 {\n                                 llargs[0] // byte swap a u8/i8 is just a no-op\n                             } else {\n                                 bcx.call(ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n-                                        &llargs, bcx.lpad().and_then(|b| b.bundle()))\n+                                        &llargs, None)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n@@ -654,7 +654,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                     let f = declare::declare_cfn(ccx,\n                                                  name,\n                                                  Type::func(&inputs, &outputs));\n-                    bcx.call(f, &llargs, bcx.lpad().and_then(|b| b.bundle()))\n+                    bcx.call(f, &llargs, None)\n                 }\n             };\n \n@@ -720,7 +720,7 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         bcx.mul(size, count),\n         align,\n         C_bool(ccx, volatile)],\n-        bcx.lpad().and_then(|b| b.bundle()))\n+        None)\n }\n \n fn memset_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n@@ -748,7 +748,7 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         bcx.mul(size, count),\n         align,\n         C_bool(ccx, volatile)],\n-        bcx.lpad().and_then(|b| b.bundle()))\n+        None)\n }\n \n fn count_zeros_intrinsic(bcx: &BlockAndBuilder,\n@@ -757,7 +757,7 @@ fn count_zeros_intrinsic(bcx: &BlockAndBuilder,\n                          -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    bcx.call(llfn, &[val, y], bcx.lpad().and_then(|b| b.bundle()))\n+    bcx.call(llfn, &[val, y], None)\n }\n \n fn with_overflow_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n@@ -769,7 +769,7 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = bcx.call(llfn, &[a, b], bcx.lpad().and_then(|b| b.bundle()));\n+    let val = bcx.call(llfn, &[a, b], None);\n     let result = bcx.extract_value(val, 0);\n     let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx()));\n     bcx.store(result, bcx.struct_gep(out, 0));\n@@ -786,7 +786,7 @@ fn try_intrinsic<'blk, 'tcx>(\n     dest: ValueRef,\n ) {\n     if bcx.sess().no_landing_pads() {\n-        bcx.call(func, &[data], bcx.lpad().and_then(|b| b.bundle()));\n+        bcx.call(func, &[data], None);\n         bcx.store(C_null(Type::i8p(&bcx.ccx())), dest);\n     } else if wants_msvc_seh(bcx.sess()) {\n         trans_msvc_try(bcx, func, data, local_ptr, dest);\n@@ -863,7 +863,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         let i64p = Type::i64(ccx).ptr_to();\n         let slot = bcx.fcx().alloca(i64p, \"slot\");\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n-            bcx.lpad().and_then(|b| b.bundle()));\n+            None);\n \n         normal.ret(C_i32(ccx, 0));\n \n@@ -890,7 +890,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bcx.call(llfn, &[func, data, local_ptr], bcx.lpad().and_then(|b| b.bundle()));\n+    let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n     bcx.store(ret, dest);\n }\n \n@@ -936,7 +936,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         let func = llvm::get_param(bcx.fcx().llfn, 0);\n         let data = llvm::get_param(bcx.fcx().llfn, 1);\n         let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n-        bcx.invoke(func, &[data], then.llbb(), catch.llbb(), bcx.lpad().and_then(|b| b.bundle()));\n+        bcx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(C_i32(ccx, 0));\n \n         // Type indicator for the exception being thrown.\n@@ -956,7 +956,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bcx.call(llfn, &[func, data, local_ptr], bcx.lpad().and_then(|b| b.bundle()));\n+    let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n     bcx.store(ret, dest);\n }\n "}, {"sha": "e23c545753fe955467c449b827652373eebd9468", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec59c5f737d044df31284090dcab2a7b678982d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=fec59c5f737d044df31284090dcab2a7b678982d", "patch": "@@ -91,7 +91,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     let dest = fcx.llretslotptr.get();\n     let llargs = get_params(fcx.llfn);\n-    bcx = callee.call(bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], dest).0;\n+    bcx = callee.call(bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], dest, None).0;\n \n     fcx.finish(&bcx);\n "}]}