{"sha": "5192956952dbf8b4b3ec073fc31d5d3caea7158a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOTI5NTY5NTJkYmY4YjRiM2VjMDczZmMzMWQ1ZDNjYWVhNzE1OGE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-30T00:28:53Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-30T00:28:53Z"}, "message": "Merge pull request #599 from mcarton/lt\n\nFix false positive with NEEDLESS_LIFETIMES and some cleanup", "tree": {"sha": "931bafc2fbb32f58b60a037a1d8f6f7e38d18a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/931bafc2fbb32f58b60a037a1d8f6f7e38d18a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5192956952dbf8b4b3ec073fc31d5d3caea7158a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5192956952dbf8b4b3ec073fc31d5d3caea7158a", "html_url": "https://github.com/rust-lang/rust/commit/5192956952dbf8b4b3ec073fc31d5d3caea7158a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5192956952dbf8b4b3ec073fc31d5d3caea7158a/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6c99bd089e6f8f4d6118f2a00669f61f3002905", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c99bd089e6f8f4d6118f2a00669f61f3002905", "html_url": "https://github.com/rust-lang/rust/commit/e6c99bd089e6f8f4d6118f2a00669f61f3002905"}, {"sha": "f7bab322f65c3cbc5a312ea02fb6f4781c167e1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7bab322f65c3cbc5a312ea02fb6f4781c167e1e", "html_url": "https://github.com/rust-lang/rust/commit/f7bab322f65c3cbc5a312ea02fb6f4781c167e1e"}], "stats": {"total": 132, "additions": 95, "deletions": 37}, "files": [{"sha": "dd89b22a40f953c3a2cb6fbe9fea47f77d8f055b", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -19,7 +19,7 @@ use syntax::codemap::Spanned;\n use utils::{in_macro, snippet, snippet_block, span_lint_and_then};\n \n /// **What it does:** This lint checks for nested `if`-statements which can be collapsed by\n-/// `&&`-combining their conditions and for `else { if .. } expressions that can be collapsed to\n+/// `&&`-combining their conditions and for `else { if .. }` expressions that can be collapsed to\n /// `else if ..`. It is `Warn` by default.\n ///\n /// **Why is this bad?** Each `if`-statement adds one level of nesting, which makes code look more complex than it really is."}, {"sha": "ca7649f75b3de7f884cdf9462ede11871320ecb2", "filename": "src/derive.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -29,6 +29,7 @@ use rustc::middle::ty::TypeVariants;\n /// impl PartialEq for Foo {\n ///     ..\n /// }\n+/// ```\n declare_lint! {\n     pub DERIVE_HASH_NOT_EQ,\n     Warn,\n@@ -52,6 +53,7 @@ declare_lint! {\n /// impl Clone for Foo {\n ///     ..\n /// }\n+/// ```\n declare_lint! {\n     pub EXPL_IMPL_CLONE_ON_COPY,\n     Warn,"}, {"sha": "64d6fa7be38b0f014bace0473b924a502cd66233", "filename": "src/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -93,19 +93,19 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n         ], {\n             let help = if sole_expr {\n                 format!(\"{}.entry({}).or_insert({})\",\n-                        snippet(cx, map.span, \"..\"),\n+                        snippet(cx, map.span, \"map\"),\n                         snippet(cx, params[1].span, \"..\"),\n                         snippet(cx, params[2].span, \"..\"))\n             }\n             else {\n                 format!(\"{}.entry({})\",\n-                        snippet(cx, map.span, \"..\"),\n+                        snippet(cx, map.span, \"map\"),\n                         snippet(cx, params[1].span, \"..\"))\n             };\n \n             span_lint_and_then(cx, MAP_ENTRY, span,\n                                &format!(\"usage of `contains_key` followed by `insert` on `{}`\", kind), |db| {\n-                db.span_suggestion(span, \"Consider using\", help.clone());\n+                db.span_suggestion(span, \"Consider using\", help);\n             });\n         }\n     }"}, {"sha": "8eb3364b2bd09866a0d81131682f8d68d1f9f466", "filename": "src/items_after_statements.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems_after_statements.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -5,9 +5,12 @@ use syntax::attr::*;\n use syntax::ast::*;\n use utils::in_macro;\n \n-/// **What it does:** It `Warn`s on blocks where there are items that are declared in the middle of or after the statements\n+/// **What it does:** It `Warn`s on blocks where there are items that are declared in the middle of\n+/// or after the statements\n ///\n-/// **Why is this bad?** Items live for the entire scope they are declared in. But statements are processed in order. This might cause confusion as it's hard to figure out which item is meant in a statement.\n+/// **Why is this bad?** Items live for the entire scope they are declared in. But statements are\n+/// processed in order. This might cause confusion as it's hard to figure out which item is meant\n+/// in a statement.\n ///\n /// **Known problems:** None\n ///\n@@ -23,6 +26,7 @@ use utils::in_macro;\n ///     }\n ///     foo(); // prints \"foo\"\n /// }\n+/// ```\n declare_lint! { pub ITEMS_AFTER_STATEMENTS, Warn, \"finds blocks where an item comes after a statement\" }\n \n pub struct ItemsAfterStatemets;"}, {"sha": "1441015eb0e3ec1a0a445130338b5b2c49118717", "filename": "src/lifetimes.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -65,13 +65,30 @@ enum RefLt {\n     Static,\n     Named(Name),\n }\n-use self::RefLt::*;\n+\n+fn bound_lifetimes(bound: &TyParamBound) -> Option<HirVec<&Lifetime>> {\n+    if let TraitTyParamBound(ref trait_ref, _) = *bound {\n+        let lt = trait_ref.trait_ref.path.segments\n+            .last().expect(\"a path must have at least one segment\")\n+            .parameters.lifetimes();\n+\n+        Some(lt)\n+    } else {\n+        None\n+    }\n+}\n \n fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, generics: &Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n-    if could_use_elision(cx, decl, slf, &generics.lifetimes) {\n+\n+    let bounds_lts =\n+        generics.ty_params\n+            .iter()\n+            .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n+\n+    if could_use_elision(cx, decl, slf, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n                   NEEDLESS_LIFETIMES,\n                   span,\n@@ -80,7 +97,10 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, g\n     report_extra_lifetimes(cx, decl, &generics, slf);\n }\n \n-fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>, named_lts: &[LifetimeDef]) -> bool {\n+fn could_use_elision<'a, T: Iterator<Item=&'a Lifetime>>(\n+    cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n+    named_lts: &[LifetimeDef], bounds_lts: T\n+) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -112,7 +132,7 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n         output_visitor.visit_ty(ty);\n     }\n \n-    let input_lts = input_visitor.into_vec();\n+    let input_lts = lts_from_bounds(input_visitor.into_vec(), bounds_lts);\n     let output_lts = output_visitor.into_vec();\n \n     // check for lifetimes from higher scopes\n@@ -129,7 +149,7 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n         // no output lifetimes, check distinctness of input lifetimes\n \n         // only unnamed and static, ok\n-        if input_lts.iter().all(|lt| *lt == Unnamed || *lt == Static) {\n+        if input_lts.iter().all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static) {\n             return false;\n         }\n         // we have no output reference, so we only need all distinct lifetimes\n@@ -142,8 +162,8 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n         }\n         if input_lts.len() == 1 {\n             match (&input_lts[0], &output_lts[0]) {\n-                (&Named(n1), &Named(n2)) if n1 == n2 => true,\n-                (&Named(_), &Unnamed) => true,\n+                (&RefLt::Named(n1), &RefLt::Named(n2)) if n1 == n2 => true,\n+                (&RefLt::Named(_), &RefLt::Unnamed) => true,\n                 _ => false, // already elided, different named lifetimes\n                 // or something static going on\n             }\n@@ -157,22 +177,32 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n     let mut allowed_lts = HashSet::new();\n     for lt in named_lts {\n         if lt.bounds.is_empty() {\n-            allowed_lts.insert(Named(lt.lifetime.name));\n+            allowed_lts.insert(RefLt::Named(lt.lifetime.name));\n         }\n     }\n-    allowed_lts.insert(Unnamed);\n-    allowed_lts.insert(Static);\n+    allowed_lts.insert(RefLt::Unnamed);\n+    allowed_lts.insert(RefLt::Static);\n     allowed_lts\n }\n \n+fn lts_from_bounds<'a, T: Iterator<Item=&'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n+    for lt in bounds_lts {\n+        if lt.name.as_str() != \"'static\" {\n+            vec.push(RefLt::Named(lt.name));\n+        }\n+    }\n+\n+    vec\n+}\n+\n /// Number of unique lifetimes in the given vector.\n fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<HashSet<_>>().len()\n }\n \n-/// A visitor usable for rustc_front::visit::walk_ty().\n+/// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+    cx: &'v LateContext<'v, 't>,\n     lts: Vec<RefLt>,\n }\n \n@@ -187,12 +217,12 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n             if lt.name.as_str() == \"'static\" {\n-                self.lts.push(Static);\n+                self.lts.push(RefLt::Static);\n             } else {\n-                self.lts.push(Named(lt.name));\n+                self.lts.push(RefLt::Named(lt.name));\n             }\n         } else {\n-            self.lts.push(Unnamed);\n+            self.lts.push(RefLt::Unnamed);\n         }\n     }\n "}, {"sha": "0c18d35fa128333198085ccba044559ebe721cd4", "filename": "src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -223,8 +223,8 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                            expr.span,\n                            \"you seem to be trying to match on a boolean expression. Consider using \\\n                            an if..else block:\", move |db| {\n-            if let Some(ref sugg) = sugg {\n-                db.span_suggestion(expr.span, \"try this\", sugg.clone());\n+            if let Some(sugg) = sugg {\n+                db.span_suggestion(expr.span, \"try this\", sugg);\n             }\n         });\n     }"}, {"sha": "b5355919496ef3bfd2be7e80b04c93dd758b7cb8", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -649,7 +649,7 @@ fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n     }\n }\n \n-/// Return the pre-expansion span is this comes from a expansion of the macro `name`.\n+/// Return the pre-expansion span if is this comes from an expansion of the macro `name`.\n pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n     loop {\n         let span_name_span = cx.tcx.sess.codemap().with_expn_info(span.expn_id, |expn| {"}, {"sha": "41a477c34ff0c6cd2ec7e4a9dc5f9298b895f90d", "filename": "src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -14,7 +14,7 @@ use utils::{is_expn_of, match_path, snippet, span_lint_and_then};\n /// **Known problems:** None.\n ///\n /// **Example:**\n-/// ```rust, ignore\n+/// ```rust,ignore\n /// foo(&vec![1, 2])\n /// ```\n declare_lint! {"}, {"sha": "408b6762df69002047e484cc824e83e0a98d5ab9", "filename": "tests/compile-fail/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/tests%2Fcompile-fail%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/tests%2Fcompile-fail%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flifetimes.rs?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -3,6 +3,7 @@\n \n #![deny(needless_lifetimes, unused_lifetimes)]\n #![allow(dead_code)]\n+\n fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) { }\n //~^ERROR explicit lifetimes given\n \n@@ -97,6 +98,7 @@ fn struct_with_lt3<'a>(_foo: &Foo<'a> ) -> &'a str { unimplemented!() }\n fn struct_with_lt4<'a, 'b>(_foo: &'a Foo<'b> ) -> &'a str { unimplemented!() }\n \n trait WithLifetime<'a> {}\n+\n type WithLifetimeAlias<'a> = WithLifetime<'a>;\n \n // should not warn because it won't build without the lifetime\n@@ -123,5 +125,8 @@ fn named_input_elided_output<'a>(_arg: &'a str) -> &str { unimplemented!() } //~\n \n fn elided_input_named_output<'a>(_arg: &str) -> &'a str { unimplemented!() }\n \n+fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) { unimplemented!() } //~ERROR explicit lifetimes given\n+fn trait_bound<'a, T: WithLifetime<'a>>(_: &'a u8, _: T) { unimplemented!() }\n+\n fn main() {\n }"}, {"sha": "9f105a2699cc95d86f71333a182a14c19f8e8541", "filename": "util/update_lints.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -1,7 +1,8 @@\n #!/usr/bin/env python\n # Generate a Markdown table of all lints, and put it in README.md.\n # With -n option, only print the new table to stdout.\n-# With -c option, print a warning and set exit status to 1 if a file would be changed.\n+# With -c option, print a warning and set exit status to 1 if a file would be\n+# changed.\n \n import os\n import re\n@@ -18,6 +19,7 @@\n \n wiki_link = 'https://github.com/Manishearth/rust-clippy/wiki'\n \n+\n def collect(lints, fn):\n     \"\"\"Collect all lints from a file.\n "}, {"sha": "842f0ed6d8e4c69e8611e8d6415362d0c989a406", "filename": "util/update_wiki.py", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5192956952dbf8b4b3ec073fc31d5d3caea7158a/util%2Fupdate_wiki.py", "raw_url": "https://github.com/rust-lang/rust/raw/5192956952dbf8b4b3ec073fc31d5d3caea7158a/util%2Fupdate_wiki.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_wiki.py?ref=5192956952dbf8b4b3ec073fc31d5d3caea7158a", "patch": "@@ -1,8 +1,12 @@\n #!/usr/bin/env python\n # Generate the wiki Home.md page from the contained doc comments\n # requires the checked out wiki in ../rust-clippy.wiki/\n-# with -c option, print a warning and set exit status 1 if the file would be changed.\n-import os, re, sys\n+# with -c option, print a warning and set exit status 1 if the file would be\n+# changed.\n+import os\n+import re\n+import sys\n+\n \n def parse_path(p=\"src\"):\n     d = {}\n@@ -14,10 +18,10 @@ def parse_path(p=\"src\"):\n START = 0\n LINT = 1\n \n+\n def parse_file(d, f):\n     last_comment = []\n     comment = True\n-    lint = None\n \n     with open(f) as rs:\n         for line in rs:\n@@ -35,27 +39,33 @@ def parse_file(d, f):\n                 l = line.strip()\n                 m = re.search(r\"pub\\s+([A-Z_]+)\", l)\n                 if m:\n-                    print \"found %s in %s\" % (m.group(1).lower(), f)\n+                    print(\"found %s in %s\" % (m.group(1).lower(), f))\n                     d[m.group(1).lower()] = last_comment\n                     last_comment = []\n                     comment = True\n                 if \"}\" in l:\n-                    print \"Warning: Missing Lint-Name in\", f\n+                    print(\"Warning: Missing Lint-Name in\", f)\n                     comment = True\n \n PREFIX = \"\"\"Welcome to the rust-clippy wiki!\n \n-Here we aim to collect further explanations on the lints clippy provides. So without further ado:\n+Here we aim to collect further explanations on the lints clippy provides. So \\\n+without further ado:\n \n \"\"\"\n \n WARNING = \"\"\"\n # A word of warning\n \n-Clippy works as a *plugin* to the compiler, which means using an unstable internal API. We have gotten quite good at keeping pace with the API evolution, but the consequence is that clippy absolutely needs to be compiled with the version of `rustc` it will run on, otherwise you will get strange errors of missing symbols.\"\"\"\n+Clippy works as a *plugin* to the compiler, which means using an unstable \\\n+internal API. We have gotten quite good at keeping pace with the API \\\n+evolution, but the consequence is that clippy absolutely needs to be compiled \\\n+with the version of `rustc` it will run on, otherwise you will get strange \\\n+errors of missing symbols.\"\"\"\n+\n \n def write_wiki_page(d, f):\n-    keys = d.keys()\n+    keys = list(d.keys())\n     keys.sort()\n     with open(f, \"w\") as w:\n         w.write(PREFIX)\n@@ -65,6 +75,7 @@ def write_wiki_page(d, f):\n         for k in keys:\n             w.write(\"\\n# `%s`\\n\\n%s\" % (k, \"\".join(d[k])))\n \n+\n def check_wiki_page(d, f):\n     errors = []\n     with open(f) as w:\n@@ -74,17 +85,21 @@ def check_wiki_page(d, f):\n                 v = d.pop(m.group(1), \"()\")\n                 if v == \"()\":\n                     errors.append(\"Missing wiki entry: \" + m.group(1))\n-    keys = d.keys()\n+    keys = list(d.keys())\n     keys.sort()\n     for k in keys:\n         errors.append(\"Spurious wiki entry: \" + k)\n     if errors:\n-        print \"\\n\".join(errors)\n+        print(\"\\n\".join(errors))\n         sys.exit(1)\n \n-if __name__ == \"__main__\":\n+\n+def main():\n     d = parse_path()\n     if \"-c\" in sys.argv:\n         check_wiki_page(d, \"../rust-clippy.wiki/Home.md\")\n     else:\n         write_wiki_page(d, \"../rust-clippy.wiki/Home.md\")\n+\n+if __name__ == \"__main__\":\n+    main()"}]}