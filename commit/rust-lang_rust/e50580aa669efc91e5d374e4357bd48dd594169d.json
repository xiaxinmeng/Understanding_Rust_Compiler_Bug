{"sha": "e50580aa669efc91e5d374e4357bd48dd594169d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MDU4MGFhNjY5ZWZjOTFlNWQzNzRlNDM1N2JkNDhkZDU5NDE2OWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-27T22:56:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-27T23:03:09Z"}, "message": "Revert \"Use DPS for assignment and local initialization\"\n\nThis reverts commit b1b202d302d1e84886360f9c8f146b9562db5f23.", "tree": {"sha": "b9d6353b2374dfebc7e83f9ec5164caa981dc0f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9d6353b2374dfebc7e83f9ec5164caa981dc0f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e50580aa669efc91e5d374e4357bd48dd594169d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e50580aa669efc91e5d374e4357bd48dd594169d", "html_url": "https://github.com/rust-lang/rust/commit/e50580aa669efc91e5d374e4357bd48dd594169d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e50580aa669efc91e5d374e4357bd48dd594169d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1097463d96fb549464ba37a3d2dbaa6a837d18eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1097463d96fb549464ba37a3d2dbaa6a837d18eb", "html_url": "https://github.com/rust-lang/rust/commit/1097463d96fb549464ba37a3d2dbaa6a837d18eb"}], "stats": {"total": 107, "additions": 51, "deletions": 56}, "files": [{"sha": "6c8d9d6bb0d421f465e15f729125c4b1e2c7f2d7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e50580aa669efc91e5d374e4357bd48dd594169d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50580aa669efc91e5d374e4357bd48dd594169d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e50580aa669efc91e5d374e4357bd48dd594169d", "patch": "@@ -2208,7 +2208,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n             let llety = T_ptr(type_of(ccx, e_sp, e_ty));\n             body = PointerCast(bcx, body, llety);\n         }\n-        bcx = trans_expr_save_in(bcx, e, body, INIT);\n+        bcx = trans_expr_save_in(bcx, e, body);\n         revoke_clean(bcx, box);\n         ret store_in_dest(bcx, box, dest);\n       }\n@@ -4033,15 +4033,15 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n       }\n       save_in(pos) { (pos, none) }\n       overwrite(pos, _) {\n-        let scratch = alloca(bcx, llvm::LLVMGetElementType(val_ty(pos)));\n+        let scratch = alloca(bcx, val_ty(pos));\n         (scratch, some(pos))\n       }\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n         let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n         let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n-        bcx = trans_expr_save_in(dst.bcx, e, dst.val, INIT);\n+        bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n         add_clean_temp_mem(bcx, dst.val, e_ty);\n         temp_cleanups += [dst.val];\n         i += 1;\n@@ -4072,7 +4072,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n       // The expressions that populate the fields might still use the old\n       // record, so we build the new on in a scratch area\n       overwrite(pos, _) {\n-        let scratch = alloca(bcx, llvm::LLVMGetElementType(val_ty(pos)));\n+        let scratch = alloca(bcx, val_ty(pos));\n         (scratch, some(pos))\n       }\n     };\n@@ -4096,7 +4096,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n         fn test(n: str, f: ast::field) -> bool { str::eq(f.node.ident, n) }\n         alt vec::find(bind test(tf.ident, _), fields) {\n           some(f) {\n-            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val, INIT);\n+            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val);\n           }\n           none. {\n             let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n@@ -4198,17 +4198,20 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     }\n }\n \n-fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef,\n-                      kind: copy_action) -> @block_ctxt {\n+// FIXME add support for INIT/DROP_EXISTING\n+fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n+    -> @block_ctxt {\n     let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n-    let dst = if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n-        ignore\n-    } else if kind == INIT {\n-        save_in(dest)\n+    if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n+        ret trans_expr_dps(bcx, e, ignore);\n+    } else if type_is_immediate(bcx_ccx(bcx), t) {\n+        let cell = empty_dest_cell();\n+        bcx = trans_expr_dps(bcx, e, by_val(cell));\n+        Store(bcx, *cell, dest);\n+        ret bcx;\n     } else {\n-        overwrite(dest, t)\n-    };\n-    ret trans_expr_dps(bcx, e, dst);\n+        ret trans_expr_dps(bcx, e, save_in(dest));\n+    }\n }\n \n fn trans_expr_by_ref(bcx: @block_ctxt, e: @ast::expr) -> result {\n@@ -4335,9 +4338,13 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       }\n       ast::expr_assign(dst, src) {\n         assert dest == ignore;\n-        let {bcx, val: lhs_addr, is_mem} = trans_lval(bcx, dst);\n-        assert is_mem;\n-        ret trans_expr_save_in(bcx, src, lhs_addr, DROP_EXISTING);\n+        let lhs_res = trans_lval(bcx, dst);\n+        assert (lhs_res.is_mem);\n+        let rhs = trans_lval(lhs_res.bcx, src);\n+        let t = ty::expr_ty(bcx_tcx(bcx), src);\n+        // FIXME: calculate copy init-ness in typestate.\n+        ret move_val_if_temp(rhs.bcx, DROP_EXISTING, lhs_res.val,\n+                             rhs, t);\n       }\n       ast::expr_swap(dst, src) {\n         assert dest == ignore;\n@@ -4643,7 +4650,7 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n             Store(cx, val, bcx.fcx.llretptr);\n             bcx = cx;\n         } else {\n-            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr, INIT);\n+            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr);\n         }\n       }\n       _ {}\n@@ -4687,9 +4694,13 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       some(init) {\n         alt init.op {\n           ast::init_assign. {\n-            bcx = trans_expr_save_in(bcx, init.expr, llptr, INIT);\n+            // Use the type of the RHS because if it's _|_, the LHS\n+            // type might be something else, but we don't want to copy\n+            // the value.\n+            ty = node_id_type(bcx_ccx(bcx), init.expr.id);\n+            let sub = trans_lval(bcx, init.expr);\n+            bcx = move_val_if_temp(sub.bcx, INIT, llptr, sub, ty);\n           }\n-          // FIXME[DPS] do a save_in when expr isn't lval\n           ast::init_move. {\n             let sub = trans_lval(bcx, init.expr);\n             bcx = move_val(sub.bcx, INIT, llptr, sub, ty);"}, {"sha": "52865564c0481e8ba64c1f9604983c8a50cbb678", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e50580aa669efc91e5d374e4357bd48dd594169d/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50580aa669efc91e5d374e4357bd48dd594169d/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=e50580aa669efc91e5d374e4357bd48dd594169d", "patch": "@@ -30,7 +30,7 @@ fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n     check type_is_unique_box(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n-    bcx = trans::trans_expr_save_in(bcx, contents, llptr, INIT);\n+    bcx = trans::trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n     ret trans::store_in_dest(bcx, llptr, dest);\n }"}, {"sha": "cda37664ec18b96a5afb86e6b14051998d5c9f5b", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 19, "deletions": 35, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e50580aa669efc91e5d374e4357bd48dd594169d/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50580aa669efc91e5d374e4357bd48dd594169d/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=e50580aa669efc91e5d374e4357bd48dd594169d", "patch": "@@ -20,11 +20,7 @@ fn get_alloc(bcx: @block_ctxt, vptrptr: ValueRef) -> ValueRef {\n }\n fn get_dataptr(bcx: @block_ctxt, vptrptr: ValueRef, unit_ty: TypeRef) ->\n    ValueRef {\n-    ret get_dataptr_simple(bcx, Load(bcx, vptrptr), unit_ty);\n-}\n-fn get_dataptr_simple(bcx: @block_ctxt, vptr: ValueRef, unit_ty: TypeRef)\n-    -> ValueRef {\n-    let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems as int]);\n+    let ptr = GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_elems as int]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n@@ -53,7 +49,8 @@ type alloc_result =\n      llunitsz: ValueRef,\n      llunitty: TypeRef};\n \n-fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n+fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint, dest: dest)\n+    -> alloc_result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let llvecty = T_vec(llunitty);\n@@ -64,8 +61,11 @@ fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n     let {bcx: bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n \n+    let vptrptr = alt dest { trans::save_in(a) { a } };\n+    Store(bcx, vptr, vptrptr);\n+//    add_clean_temp(bcx, vptrptr, vec_ty);\n     ret {bcx: bcx,\n-         val: vptr,\n+         val: vptrptr,\n          unit_ty: unit_ty,\n          llunitsz: unit_sz,\n          llunitty: llunitty};\n@@ -110,15 +110,16 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n     }\n     let vec_ty = node_id_type(bcx_ccx(bcx), id);\n     let {bcx: bcx,\n-         val: vptr,\n+         val: vptrptr,\n          llunitsz: llunitsz,\n          unit_ty: unit_ty,\n          llunitty: llunitty} =\n-        alloc(bcx, vec_ty, vec::len(args));\n+        alloc(bcx, vec_ty, vec::len(args), dest);\n \n+    let vptr = Load(bcx, vptrptr);\n     add_clean_free(bcx, vptr, true);\n     // Store the individual elements.\n-    let dataptr = get_dataptr_simple(bcx, vptr, llunitty);\n+    let dataptr = get_dataptr(bcx, vptrptr, llunitty);\n     let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n         let lv = trans_lval(bcx, e);\n@@ -132,28 +133,17 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         i += 1u;\n     }\n     for clean in temp_cleanups { revoke_clean(bcx, clean); }\n-    let vptrptr = alt dest {\n-      trans::save_in(a) { a }\n-      trans::overwrite(a, t) { bcx = trans::drop_ty(bcx, a, t); a }\n-    };\n-    Store(bcx, vptr, vptrptr);\n     ret bcx;\n }\n-\n fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n     let veclen = std::str::byte_len(s) + 1u; // +1 for \\0\n-    let {bcx: bcx, val: sptr, _} =\n-        alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n+    let {bcx: bcx, val: sptrptr, _} =\n+        alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen, dest);\n \n     let llcstr = C_cstr(bcx_ccx(bcx), s);\n     let bcx =\n-        call_memmove(bcx, get_dataptr_simple(bcx, sptr, T_i8()), llcstr,\n+        call_memmove(bcx, get_dataptr(bcx, sptrptr, T_i8()), llcstr,\n                      C_uint(veclen)).bcx;\n-    let sptrptr = alt dest {\n-      trans::save_in(a) { a }\n-      trans::overwrite(a, t) { bcx = trans::drop_ty(bcx, a, t); a }\n-    };\n-    Store(bcx, sptr, sptrptr);\n     ret bcx;\n }\n \n@@ -247,9 +237,11 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n     new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(llunitty)));\n+    let new_vec_ptr_ptr = alt dest { trans::save_in(a) { a } };\n+    Store(bcx, new_vec_ptr, new_vec_ptr_ptr);\n \n-    let write_ptr_ptr = do_spill_noroot\n-        (bcx, get_dataptr_simple(bcx, new_vec_ptr, llunitty));\n+    let write_ptr_ptr =\n+        do_spill_noroot(bcx, get_dataptr(bcx, new_vec_ptr_ptr, llunitty));\n     let copy_fn =\n         bind fn (bcx: @block_ctxt, addr: ValueRef, _ty: ty::t,\n                  write_ptr_ptr: ValueRef, unit_ty: ty::t, llunitsz: ValueRef)\n@@ -267,15 +259,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n              }(_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n     let bcx = iter_vec_raw(bcx, lhsptr, vec_ty, lhs_fill, copy_fn);\n-    bcx = iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n-    alt dest {\n-      trans::save_in(a) { Store(bcx, new_vec_ptr, a); }\n-      trans::overwrite(a, t) {\n-        bcx = trans::drop_ty(bcx, a, t);\n-        Store(bcx, new_vec_ptr, a);\n-      }\n-    }\n-    ret bcx;\n+    ret iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n }\n \n type val_and_ty_fn = fn(@block_ctxt, ValueRef, ty::t) -> result;"}]}