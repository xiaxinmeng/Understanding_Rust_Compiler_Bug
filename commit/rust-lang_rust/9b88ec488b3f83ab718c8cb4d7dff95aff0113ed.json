{"sha": "9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliODhlYzQ4OGIzZjgzYWI3MThjOGNiNGQ3ZGZmOTVhZmYwMTEzZWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-07T17:34:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-07T17:34:16Z"}, "message": "split completion mod", "tree": {"sha": "fcdb2d0922b1492df59e779b5cbcb6086c19c402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcdb2d0922b1492df59e779b5cbcb6086c19c402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "html_url": "https://github.com/rust-lang/rust/commit/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af17fc969742a36cee5199860789ed0b14123240", "url": "https://api.github.com/repos/rust-lang/rust/commits/af17fc969742a36cee5199860789ed0b14123240", "html_url": "https://github.com/rust-lang/rust/commit/af17fc969742a36cee5199860789ed0b14123240"}], "stats": {"total": 611, "additions": 339, "deletions": 272}, "files": [{"sha": "763533012578f5b8f051664be447d002b1c98d65", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "renamed", "additions": 8, "deletions": 272, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "patch": "@@ -1,20 +1,17 @@\n+mod reference_completion;\n+\n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    algo::visit::{visitor, visitor_ctx, Visitor, VisitorCtx},\n-    ast::{self, AstChildren, LoopBodyOwner, ModuleItemOwner},\n-    AstNode, AtomEdit, SourceFileNode,\n-    SyntaxKind::*,\n+    algo::visit::{visitor_ctx, VisitorCtx},\n+    ast,\n+    AstNode, AtomEdit,\n     SyntaxNodeRef,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::{FxHashMap};\n \n use crate::{\n     db::{self, SyntaxDatabase},\n-    descriptors::function::FnScopes,\n-    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n-    descriptors::DescriptorDatabase,\n-    input::FilesDatabase,\n-    Cancelable, FilePosition, FileId,\n+    Cancelable, FilePosition\n };\n \n #[derive(Debug)]\n@@ -43,27 +40,11 @@ pub(crate) fn completions(\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n-        // completion from lexical scope\n-        complete_name_ref(&file, name_ref, &mut res);\n+        reference_completion::completions(&mut res, db, position.file_id, &file, name_ref)?;\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n         if is_node::<ast::Param>(name_ref.syntax()) {\n             param_completions(name_ref.syntax(), &mut res);\n         }\n-        // snippet completions\n-        {\n-            let name_range = name_ref.syntax().range();\n-            let top_node = name_ref\n-                .syntax()\n-                .ancestors()\n-                .take_while(|it| it.range() == name_range)\n-                .last()\n-                .unwrap();\n-            match top_node.parent().map(|it| it.kind()) {\n-                Some(SOURCE_FILE) | Some(ITEM_LIST) => complete_mod_item_snippets(&mut res),\n-                _ => (),\n-            }\n-        }\n-        complete_path(db, position.file_id, name_ref, &mut res)?;\n     }\n \n     // Otherwise, if this is a declaration, use heuristics to suggest a name.\n@@ -77,117 +58,6 @@ pub(crate) fn completions(\n     Ok(res)\n }\n \n-fn complete_path(\n-    db: &db::RootDatabase,\n-    file_id: FileId,\n-    name_ref: ast::NameRef,\n-    acc: &mut Vec<CompletionItem>,\n-) -> Cancelable<()> {\n-    let source_root_id = db.file_source_root(file_id);\n-    let module_tree = db.module_tree(source_root_id)?;\n-    let module_id = match module_tree.any_module_for_source(ModuleSource::SourceFile(file_id)) {\n-        None => return Ok(()),\n-        Some(it) => it,\n-    };\n-    let target_module_id = match find_target_module(&module_tree, module_id, name_ref) {\n-        None => return Ok(()),\n-        Some(it) => it,\n-    };\n-    let module_scope = db.module_scope(source_root_id, target_module_id)?;\n-    let completions = module_scope.entries().iter().map(|entry| CompletionItem {\n-        label: entry.name().to_string(),\n-        lookup: None,\n-        snippet: None,\n-    });\n-    acc.extend(completions);\n-    Ok(())\n-}\n-\n-fn find_target_module(\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n-    name_ref: ast::NameRef,\n-) -> Option<ModuleId> {\n-    let mut crate_path = crate_path(name_ref)?;\n-\n-    crate_path.pop();\n-    let mut target_module = module_id.root(&module_tree);\n-    for name in crate_path {\n-        target_module = target_module.child(module_tree, name.text().as_str())?;\n-    }\n-    Some(target_module)\n-}\n-\n-fn crate_path(name_ref: ast::NameRef) -> Option<Vec<ast::NameRef>> {\n-    let mut path = name_ref\n-        .syntax()\n-        .parent()\n-        .and_then(ast::PathSegment::cast)?\n-        .parent_path();\n-    let mut res = Vec::new();\n-    loop {\n-        let segment = path.segment()?;\n-        match segment.kind()? {\n-            ast::PathSegmentKind::Name(name) => res.push(name),\n-            ast::PathSegmentKind::CrateKw => break,\n-            ast::PathSegmentKind::SelfKw | ast::PathSegmentKind::SuperKw => return None,\n-        }\n-        path = path.qualifier()?;\n-    }\n-    res.reverse();\n-    Some(res)\n-}\n-\n-fn complete_module_items(\n-    file: &SourceFileNode,\n-    items: AstChildren<ast::ModuleItem>,\n-    this_item: Option<ast::NameRef>,\n-    acc: &mut Vec<CompletionItem>,\n-) {\n-    let scope = ModuleScope::new(items); // FIXME\n-    acc.extend(\n-        scope\n-            .entries()\n-            .iter()\n-            .filter(|entry| {\n-                let syntax = entry.ptr().resolve(file);\n-                Some(syntax.borrowed()) != this_item.map(|it| it.syntax())\n-            })\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n-}\n-\n-fn complete_name_ref(file: &SourceFileNode, name_ref: ast::NameRef, acc: &mut Vec<CompletionItem>) {\n-    if !is_node::<ast::Path>(name_ref.syntax()) {\n-        return;\n-    }\n-    let mut visited_fn = false;\n-    for node in name_ref.syntax().ancestors() {\n-        if let Some(items) = visitor()\n-            .visit::<ast::SourceFile, _>(|it| Some(it.items()))\n-            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n-            .accept(node)\n-        {\n-            if let Some(items) = items {\n-                complete_module_items(file, items, Some(name_ref), acc);\n-            }\n-            break;\n-        } else if !visited_fn {\n-            if let Some(fn_def) = ast::FnDef::cast(node) {\n-                visited_fn = true;\n-                complete_expr_keywords(&file, fn_def, name_ref, acc);\n-                complete_expr_snippets(acc);\n-                let scopes = FnScopes::new(fn_def);\n-                complete_fn(name_ref, &scopes, acc);\n-            }\n-        }\n-    }\n-}\n-\n fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n     let mut params = FxHashMap::default();\n     for node in ctx.ancestors() {\n@@ -235,140 +105,6 @@ fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n     }\n }\n \n-fn complete_expr_keywords(\n-    file: &SourceFileNode,\n-    fn_def: ast::FnDef,\n-    name_ref: ast::NameRef,\n-    acc: &mut Vec<CompletionItem>,\n-) {\n-    acc.push(keyword(\"if\", \"if $0 {}\"));\n-    acc.push(keyword(\"match\", \"match $0 {}\"));\n-    acc.push(keyword(\"while\", \"while $0 {}\"));\n-    acc.push(keyword(\"loop\", \"loop {$0}\"));\n-\n-    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n-            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                acc.push(keyword(\"else\", \"else {$0}\"));\n-                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n-            }\n-        }\n-    }\n-    if is_in_loop_body(name_ref) {\n-        acc.push(keyword(\"continue\", \"continue\"));\n-        acc.push(keyword(\"break\", \"break\"));\n-    }\n-    acc.extend(complete_return(fn_def, name_ref));\n-}\n-\n-fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n-    for node in name_ref.syntax().ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n-        if let Some(Some(body)) = loop_body {\n-            if name_ref\n-                .syntax()\n-                .range()\n-                .is_subrange(&body.syntax().range())\n-            {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n-    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n-    //     .next()\n-    //     .and_then(|it| it.syntax().parent())\n-    //     .and_then(ast::Block::cast)\n-    //     .is_some();\n-\n-    // if is_last_in_block {\n-    //     return None;\n-    // }\n-\n-    let is_stmt = match name_ref\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::ExprStmt::cast)\n-        .next()\n-    {\n-        None => false,\n-        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n-    };\n-    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n-        (true, true) => \"return $0;\",\n-        (true, false) => \"return;\",\n-        (false, true) => \"return $0\",\n-        (false, false) => \"return\",\n-    };\n-    Some(keyword(\"return\", snip))\n-}\n-\n-fn keyword(kw: &str, snip: &str) -> CompletionItem {\n-    CompletionItem {\n-        label: kw.to_string(),\n-        lookup: None,\n-        snippet: Some(snip.to_string()),\n-    }\n-}\n-\n-fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"pd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"ppd\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n-    });\n-}\n-\n-fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n-    acc.push(CompletionItem {\n-        label: \"tfn\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n-    });\n-    acc.push(CompletionItem {\n-        label: \"pub(crate)\".to_string(),\n-        lookup: None,\n-        snippet: Some(\"pub(crate) $0\".to_string()),\n-    })\n-}\n-\n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n-    let mut shadowed = FxHashSet::default();\n-    acc.extend(\n-        scopes\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .map(|entry| CompletionItem {\n-                label: entry.name().to_string(),\n-                lookup: None,\n-                snippet: None,\n-            }),\n-    );\n-    if scopes.self_param.is_some() {\n-        acc.push(CompletionItem {\n-            label: \"self\".to_string(),\n-            lookup: None,\n-            snippet: None,\n-        })\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::assert_eq_dbg;", "previous_filename": "crates/ra_analysis/src/completion.rs"}, {"sha": "b081749689aeb22d1be2b7b61e078a5a24cdcd90", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "patch": "@@ -0,0 +1,331 @@\n+use rustc_hash::{FxHashSet};\n+use ra_editor::find_node_at_offset;\n+use ra_syntax::{\n+    algo::visit::{visitor, Visitor},\n+    SourceFileNode, AstNode,\n+    ast::{self, AstChildren, ModuleItemOwner, LoopBodyOwner},\n+    SyntaxKind::*,\n+};\n+\n+use crate::{\n+    db::RootDatabase,\n+    input::FilesDatabase,\n+    completion::CompletionItem,\n+    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n+    descriptors::function::FnScopes,\n+    descriptors::DescriptorDatabase,\n+    FileId, Cancelable\n+};\n+\n+pub(super) fn completions(\n+    acc: &mut Vec<CompletionItem>,\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    file: &SourceFileNode,\n+    name_ref: ast::NameRef,\n+) -> Cancelable<()> {\n+    let kind = match classify_name_ref(name_ref) {\n+        Some(it) => it,\n+        None => return Ok(()),\n+    };\n+    match kind {\n+        NameRefKind::LocalRef => {\n+            if let Some(fn_def) = complete_local_name(acc, &file, name_ref) {\n+                complete_expr_keywords(&file, fn_def, name_ref, acc);\n+                complete_expr_snippets(acc);\n+            }\n+        }\n+        NameRefKind::CratePath(path) => complete_path(acc, db, file_id, path)?,\n+        NameRefKind::BareIdentInMod => {\n+            let name_range = name_ref.syntax().range();\n+            let top_node = name_ref\n+                .syntax()\n+                .ancestors()\n+                .take_while(|it| it.range() == name_range)\n+                .last()\n+                .unwrap();\n+            match top_node.parent().map(|it| it.kind()) {\n+                Some(SOURCE_FILE) | Some(ITEM_LIST) => complete_mod_item_snippets(acc),\n+                _ => (),\n+            }\n+        }\n+    }\n+    Ok(())\n+}\n+\n+enum NameRefKind<'a> {\n+    /// NameRef is a part of single-segment path, for example, a refernece to a\n+    /// local variable.\n+    LocalRef,\n+    /// NameRef is the last segment in crate:: path\n+    CratePath(Vec<ast::NameRef<'a>>),\n+    /// NameRef is bare identifier at the module's root.\n+    /// Used for keyword completion\n+    BareIdentInMod,\n+}\n+\n+fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n+    let name_range = name_ref.syntax().range();\n+    let top_node = name_ref\n+        .syntax()\n+        .ancestors()\n+        .take_while(|it| it.range() == name_range)\n+        .last()\n+        .unwrap();\n+    match top_node.parent().map(|it| it.kind()) {\n+        Some(SOURCE_FILE) | Some(ITEM_LIST) => return Some(NameRefKind::BareIdentInMod),\n+        _ => (),\n+    }\n+\n+    let parent = name_ref.syntax().parent()?;\n+    if let Some(segment) = ast::PathSegment::cast(parent) {\n+        let path = segment.parent_path();\n+        if path.qualifier().is_none() {\n+            return Some(NameRefKind::LocalRef);\n+        }\n+        if let Some(crate_path) = crate_path(path) {\n+            return Some(NameRefKind::CratePath(crate_path));\n+        }\n+    }\n+    None\n+}\n+\n+fn crate_path(mut path: ast::Path) -> Option<Vec<ast::NameRef>> {\n+    let mut res = Vec::new();\n+    loop {\n+        let segment = path.segment()?;\n+        match segment.kind()? {\n+            ast::PathSegmentKind::Name(name) => res.push(name),\n+            ast::PathSegmentKind::CrateKw => break,\n+            ast::PathSegmentKind::SelfKw | ast::PathSegmentKind::SuperKw => return None,\n+        }\n+        path = path.qualifier()?;\n+    }\n+    res.reverse();\n+    Some(res)\n+}\n+\n+fn complete_local_name<'a>(\n+    acc: &mut Vec<CompletionItem>,\n+    file: &SourceFileNode,\n+    name_ref: ast::NameRef<'a>,\n+) -> Option<ast::FnDef<'a>> {\n+    let mut enclosing_fn = None;\n+    for node in name_ref.syntax().ancestors() {\n+        if let Some(items) = visitor()\n+            .visit::<ast::SourceFile, _>(|it| Some(it.items()))\n+            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n+            .accept(node)\n+        {\n+            if let Some(items) = items {\n+                complete_module_items(file, items, Some(name_ref), acc);\n+            }\n+            break;\n+        } else if enclosing_fn.is_none() {\n+            if let Some(fn_def) = ast::FnDef::cast(node) {\n+                enclosing_fn = Some(fn_def);\n+                let scopes = FnScopes::new(fn_def);\n+                complete_fn(name_ref, &scopes, acc);\n+            }\n+        }\n+    }\n+    enclosing_fn\n+}\n+\n+fn complete_module_items(\n+    file: &SourceFileNode,\n+    items: AstChildren<ast::ModuleItem>,\n+    this_item: Option<ast::NameRef>,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    let scope = ModuleScope::new(items); // FIXME\n+    acc.extend(\n+        scope\n+            .entries()\n+            .iter()\n+            .filter(|entry| {\n+                let syntax = entry.ptr().resolve(file);\n+                Some(syntax.borrowed()) != this_item.map(|it| it.syntax())\n+            })\n+            .map(|entry| CompletionItem {\n+                label: entry.name().to_string(),\n+                lookup: None,\n+                snippet: None,\n+            }),\n+    );\n+}\n+\n+fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n+    let mut shadowed = FxHashSet::default();\n+    acc.extend(\n+        scopes\n+            .scope_chain(name_ref.syntax())\n+            .flat_map(|scope| scopes.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .map(|entry| CompletionItem {\n+                label: entry.name().to_string(),\n+                lookup: None,\n+                snippet: None,\n+            }),\n+    );\n+    if scopes.self_param.is_some() {\n+        acc.push(CompletionItem {\n+            label: \"self\".to_string(),\n+            lookup: None,\n+            snippet: None,\n+        })\n+    }\n+}\n+\n+fn complete_path(\n+    acc: &mut Vec<CompletionItem>,\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    crate_path: Vec<ast::NameRef>,\n+) -> Cancelable<()> {\n+    let source_root_id = db.file_source_root(file_id);\n+    let module_tree = db.module_tree(source_root_id)?;\n+    let module_id = match module_tree.any_module_for_source(ModuleSource::SourceFile(file_id)) {\n+        None => return Ok(()),\n+        Some(it) => it,\n+    };\n+    let target_module_id = match find_target_module(&module_tree, module_id, crate_path) {\n+        None => return Ok(()),\n+        Some(it) => it,\n+    };\n+    let module_scope = db.module_scope(source_root_id, target_module_id)?;\n+    let completions = module_scope.entries().iter().map(|entry| CompletionItem {\n+        label: entry.name().to_string(),\n+        lookup: None,\n+        snippet: None,\n+    });\n+    acc.extend(completions);\n+    Ok(())\n+}\n+\n+fn find_target_module(\n+    module_tree: &ModuleTree,\n+    module_id: ModuleId,\n+    mut crate_path: Vec<ast::NameRef>,\n+) -> Option<ModuleId> {\n+    crate_path.pop();\n+    let mut target_module = module_id.root(&module_tree);\n+    for name in crate_path {\n+        target_module = target_module.child(module_tree, name.text().as_str())?;\n+    }\n+    Some(target_module)\n+}\n+\n+fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n+    acc.push(CompletionItem {\n+        label: \"tfn\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n+    });\n+    acc.push(CompletionItem {\n+        label: \"pub(crate)\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"pub(crate) $0\".to_string()),\n+    })\n+}\n+\n+fn complete_expr_keywords(\n+    file: &SourceFileNode,\n+    fn_def: ast::FnDef,\n+    name_ref: ast::NameRef,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    acc.push(keyword(\"if\", \"if $0 {}\"));\n+    acc.push(keyword(\"match\", \"match $0 {}\"));\n+    acc.push(keyword(\"while\", \"while $0 {}\"));\n+    acc.push(keyword(\"loop\", \"loop {$0}\"));\n+\n+    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n+        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n+                acc.push(keyword(\"else\", \"else {$0}\"));\n+                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n+            }\n+        }\n+    }\n+    if is_in_loop_body(name_ref) {\n+        acc.push(keyword(\"continue\", \"continue\"));\n+        acc.push(keyword(\"break\", \"break\"));\n+    }\n+    acc.extend(complete_return(fn_def, name_ref));\n+}\n+\n+fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n+    for node in name_ref.syntax().ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = visitor()\n+            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n+            .accept(node);\n+        if let Some(Some(body)) = loop_body {\n+            if name_ref\n+                .syntax()\n+                .range()\n+                .is_subrange(&body.syntax().range())\n+            {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n+    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n+    //     .next()\n+    //     .and_then(|it| it.syntax().parent())\n+    //     .and_then(ast::Block::cast)\n+    //     .is_some();\n+\n+    // if is_last_in_block {\n+    //     return None;\n+    // }\n+\n+    let is_stmt = match name_ref\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::ExprStmt::cast)\n+        .next()\n+    {\n+        None => false,\n+        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n+    };\n+    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n+        (true, true) => \"return $0;\",\n+        (true, false) => \"return;\",\n+        (false, true) => \"return $0\",\n+        (false, false) => \"return\",\n+    };\n+    Some(keyword(\"return\", snip))\n+}\n+\n+fn keyword(kw: &str, snip: &str) -> CompletionItem {\n+    CompletionItem {\n+        label: kw.to_string(),\n+        lookup: None,\n+        snippet: Some(snip.to_string()),\n+    }\n+}\n+\n+fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n+    acc.push(CompletionItem {\n+        label: \"pd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n+    });\n+    acc.push(CompletionItem {\n+        label: \"ppd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n+    });\n+}\n+\n+"}]}