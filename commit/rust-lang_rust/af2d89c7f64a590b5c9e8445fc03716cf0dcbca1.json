{"sha": "af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMmQ4OWM3ZjY0YTU5MGI1YzllODQ0NWZjMDM3MTZjZjBkY2JjYTE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-25T06:07:21Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-29T00:18:34Z"}, "message": "Refactor path resoloution.", "tree": {"sha": "afd46a63dba33aa05afc924ab4e6993dc0d0591c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afd46a63dba33aa05afc924ab4e6993dc0d0591c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "html_url": "https://github.com/rust-lang/rust/commit/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb9f14e987732fa1406911633d9bf4e7eee45978", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9f14e987732fa1406911633d9bf4e7eee45978", "html_url": "https://github.com/rust-lang/rust/commit/cb9f14e987732fa1406911633d9bf4e7eee45978"}], "stats": {"total": 833, "additions": 287, "deletions": 546}, "files": [{"sha": "d113f6b5e4e76283b5c5e46f72cb7ff9db12f889", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "patch": "@@ -77,7 +77,7 @@ pub struct LoweringContext<'a> {\n \n pub trait Resolver {\n     // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool);\n+    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n@@ -2091,7 +2091,7 @@ impl<'a> LoweringContext<'a> {\n             segments: segments.into(),\n         };\n \n-        self.resolver.resolve_generated_global_path(&mut path, is_value);\n+        self.resolver.resolve_hir_path(&mut path, is_value);\n         path\n     }\n "}, {"sha": "19764f2e68200b1ac59de4c743274ffb329023b0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 268, "deletions": 525, "changes": 793, "blob_url": "https://github.com/rust-lang/rust/blob/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "patch": "@@ -39,8 +39,6 @@ use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n use self::RibKind::*;\n-use self::UseLexicalScopeFlag::*;\n-use self::ModulePrefixResult::*;\n \n use rustc::hir::map::{Definitions, DefCollector};\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n@@ -57,6 +55,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::Determinacy::{Determined, Undetermined};\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -191,10 +190,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                                         span: syntax_pos::Span,\n                                         resolution_error: ResolutionError<'c>)\n                                         -> DiagnosticBuilder<'a> {\n-    if !resolver.emit_errors {\n-        return resolver.session.diagnostic().struct_dummy();\n-    }\n-\n     match resolution_error {\n         ResolutionError::TypeParametersFromOuterFunction => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -584,8 +579,9 @@ impl<'a> Visitor for Resolver<'a> {\n         self.resolve_type(ty);\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n-        let def =\n-            self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0, None);\n+        let ast::Path { ref segments, span, global } = tref.trait_ref.path;\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+        let def = self.resolve_trait_reference(&path, global, None, span);\n         self.record_def(tref.trait_ref.ref_id, def);\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n@@ -737,17 +733,6 @@ enum RibKind<'a> {\n     MacroDefinition(Mark),\n }\n \n-#[derive(Copy, Clone)]\n-enum UseLexicalScopeFlag {\n-    DontUseLexicalScope,\n-    UseLexicalScope,\n-}\n-\n-enum ModulePrefixResult<'a> {\n-    NoPrefixFound,\n-    PrefixFound(Module<'a>, usize),\n-}\n-\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n@@ -765,33 +750,18 @@ impl<'a> Rib<'a> {\n }\n \n /// A definition along with the index of the rib it was found on\n+#[derive(Copy, Clone)]\n struct LocalDef {\n     ribs: Option<(Namespace, usize)>,\n     def: Def,\n }\n \n-impl LocalDef {\n-    fn from_def(def: Def) -> Self {\n-        LocalDef {\n-            ribs: None,\n-            def: def,\n-        }\n-    }\n-}\n-\n enum LexicalScopeBinding<'a> {\n     Item(&'a NameBinding<'a>),\n-    LocalDef(LocalDef),\n+    Def(Def),\n }\n \n impl<'a> LexicalScopeBinding<'a> {\n-    fn local_def(self) -> LocalDef {\n-        match self {\n-            LexicalScopeBinding::LocalDef(local_def) => local_def,\n-            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def()),\n-        }\n-    }\n-\n     fn item(self) -> Option<&'a NameBinding<'a>> {\n         match self {\n             LexicalScopeBinding::Item(binding) => Some(binding),\n@@ -800,6 +770,21 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+enum PathScope {\n+    Global,\n+    Lexical,\n+    Import,\n+}\n+\n+#[derive(Clone)]\n+enum PathResult<'a> {\n+    Module(Module<'a>),\n+    NonModule(PathResolution),\n+    Indeterminate,\n+    Failed(String, bool /* is the error from the last segment? */),\n+}\n+\n enum ModuleKind {\n     Block(NodeId),\n     Def(Def, Name),\n@@ -1107,11 +1092,6 @@ pub struct Resolver<'a> {\n     module_map: NodeMap<Module<'a>>,\n     extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n \n-    // Whether or not to print error messages. Can be set to true\n-    // when getting additional info for error message suggestions,\n-    // so as to avoid printing duplicate errors\n-    emit_errors: bool,\n-\n     pub make_glob_map: bool,\n     // Maps imports to the names of items actually imported (this actually maps\n     // all imports, but only glob imports are actually interesting).\n@@ -1197,22 +1177,23 @@ impl<'a> ty::NodeIdTree for Resolver<'a> {\n }\n \n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool) {\n+    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n-        match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n-            Ok(binding) => path.def = binding.def(),\n-            None => {\n-                let path_name = &format!(\"{}\", path);\n-                let error =\n-                    ResolutionError::UnresolvedName {\n-                        path: path_name,\n-                        message: \"\",\n-                        context: UnresolvedNameContext::Other,\n-                        is_static_method: false,\n-                        is_field: false,\n-                        def: Def::Err,\n-                    };\n-                resolve_error(self, path.span, error);\n+        let hir::Path { ref segments, span, global, ref mut def } = *path;\n+        let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n+        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+        match self.resolve_path(&path, scope, Some(namespace), Some(span)) {\n+            PathResult::Module(module) => *def = module.def().unwrap(),\n+            PathResult::NonModule(path_res) if path_res.depth == 0 => *def = path_res.base_def,\n+            PathResult::NonModule(..) => match self.resolve_path(&path, scope, None, Some(span)) {\n+                PathResult::Failed(msg, _) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                }\n+                _ => {}\n+            },\n+            PathResult::Indeterminate => unreachable!(),\n+            PathResult::Failed(msg, _) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n             }\n         }\n     }\n@@ -1230,22 +1211,6 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n }\n \n-trait Named {\n-    fn ident(&self) -> Ident;\n-}\n-\n-impl Named for ast::PathSegment {\n-    fn ident(&self) -> Ident {\n-        self.identifier\n-    }\n-}\n-\n-impl Named for hir::PathSegment {\n-    fn ident(&self) -> Ident {\n-        Ident::with_empty_ctxt(self.name)\n-    }\n-}\n-\n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n                krate: &Crate,\n@@ -1307,7 +1272,6 @@ impl<'a> Resolver<'a> {\n             module_map: module_map,\n             extern_crate_roots: FxHashMap(),\n \n-            emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n@@ -1413,163 +1377,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn expect_module(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Option<Span>)\n-                     -> ResolveResult<Module<'a>> {\n-        match binding.module() {\n-            Ok(module) => Success(module),\n-            Err(true) => Failed(None),\n-            Err(false) => {\n-                let msg = format!(\"Not a module `{}`\", name);\n-                Failed(span.map(|span| (span, msg)))\n-            }\n-        }\n-    }\n-\n-    /// Resolves the given module path from the given root `search_module`.\n-    fn resolve_module_path_from_root(&mut self,\n-                                     mut search_module: Module<'a>,\n-                                     module_path: &[Ident],\n-                                     index: usize,\n-                                     span: Option<Span>)\n-                                     -> ResolveResult<Module<'a>> {\n-        fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n-                                       -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n-                Success(binding) if binding.is_extern_crate() => Some(module),\n-                _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n-                    search_parent_externals(this, needle, parent)\n-                } else {\n-                    None\n-                },\n-            }\n-        }\n-\n-        let mut index = index;\n-        let module_path_len = module_path.len();\n-\n-        // Resolve the module part of the path. This does not involve looking\n-        // upward though scope chains; we simply resolve names directly in\n-        // modules as we go.\n-        while index < module_path_len {\n-            let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n-                Failed(_) => {\n-                    let module_name = module_to_string(search_module);\n-                    let msg = if \"???\" == &module_name {\n-                        let current_module = self.current_module;\n-                        match search_parent_externals(self, name, current_module) {\n-                            Some(module) => {\n-                                let path_str = names_to_string(module_path);\n-                                let target_mod_str = module_to_string(&module);\n-                                let current_mod_str = module_to_string(current_module);\n-\n-                                let prefix = if target_mod_str == current_mod_str {\n-                                    \"self::\".to_string()\n-                                } else {\n-                                    format!(\"{}::\", target_mod_str)\n-                                };\n-\n-                                format!(\"Did you mean `{}{}`?\", prefix, path_str)\n-                            }\n-                            None => format!(\"Maybe a missing `extern crate {};`?\", name),\n-                        }\n-                    } else {\n-                        format!(\"Could not find `{}` in `{}`\", name, module_name)\n-                    };\n-\n-                    return Failed(span.map(|span| (span, msg)));\n-                }\n-                Indeterminate => {\n-                    debug!(\"(resolving module path for import) module resolution is \\\n-                            indeterminate: {}\",\n-                           name);\n-                    return Indeterminate;\n-                }\n-                Success(binding) => {\n-                    // Check to see whether there are type bindings, and, if\n-                    // so, whether there is a module within.\n-                    match self.expect_module(name, binding, span) {\n-                        Success(module) => search_module = module,\n-                        result @ _ => return result,\n-                    }\n-                }\n-            }\n-\n-            index += 1;\n-        }\n-\n-        return Success(search_module);\n-    }\n-\n-    /// Attempts to resolve the module part of an import directive or path\n-    /// rooted at the given module.\n-    fn resolve_module_path(&mut self,\n-                           module_path: &[Ident],\n-                           use_lexical_scope: UseLexicalScopeFlag,\n-                           span: Option<Span>)\n-                           -> ResolveResult<Module<'a>> {\n-        if module_path.len() == 0 {\n-            return Success(self.graph_root) // Use the crate root\n-        }\n-\n-        debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n-               names_to_string(module_path),\n-               module_to_string(self.current_module));\n-\n-        // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_path, span);\n-\n-        let search_module;\n-        let start_index;\n-        match module_prefix_result {\n-            Failed(err) => return Failed(err),\n-            Indeterminate => {\n-                debug!(\"(resolving module path for import) indeterminate; bailing\");\n-                return Indeterminate;\n-            }\n-            Success(NoPrefixFound) => {\n-                // There was no prefix, so we're considering the first element\n-                // of the path. How we handle this depends on whether we were\n-                // instructed to use lexical scope or not.\n-                match use_lexical_scope {\n-                    DontUseLexicalScope => {\n-                        // This is a crate-relative path. We will start the\n-                        // resolution process at index zero.\n-                        search_module = self.graph_root;\n-                        start_index = 0;\n-                    }\n-                    UseLexicalScope => {\n-                        // This is not a crate-relative path. We resolve the\n-                        // first component of the path in the current lexical\n-                        // scope and then proceed to resolve below that.\n-                        let ident = module_path[0];\n-                        let lexical_binding =\n-                            self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n-                        if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n-                            match self.expect_module(ident.name, binding, span) {\n-                                Success(containing_module) => {\n-                                    search_module = containing_module;\n-                                    start_index = 1;\n-                                }\n-                                result @ _ => return result,\n-                            }\n-                        } else {\n-                            let msg =\n-                                format!(\"Use of undeclared type or module `{}`\", ident.name);\n-                            return Failed(span.map(|span| (span, msg)));\n-                        }\n-                    }\n-                }\n-            }\n-            Success(PrefixFound(ref containing_module, index)) => {\n-                search_module = containing_module;\n-                start_index = index;\n-            }\n-        }\n-\n-        self.resolve_module_path_from_root(search_module, module_path, start_index, span)\n-    }\n-\n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n     /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n     /// `ident` in the first scope that defines it (or None if no scopes define it).\n@@ -1600,9 +1407,10 @@ impl<'a> Resolver<'a> {\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::LocalDef(LocalDef {\n-                    ribs: Some((ns, i)),\n-                    def: def,\n+                return Some(LexicalScopeBinding::Def(if let Some(span) = record_used {\n+                    self.adjust_local_def(LocalDef { ribs: Some((ns, i)), def: def }, span)\n+                } else {\n+                    def\n                 }));\n             }\n \n@@ -1637,45 +1445,6 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n-    /// (b) some chain of `super::`.\n-    /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n-                             -> ResolveResult<ModulePrefixResult<'a>> {\n-        if module_path[0].name == \"$crate\" {\n-            return Success(PrefixFound(self.resolve_crate_var(module_path[0].ctxt), 1));\n-        }\n-\n-        // Start at the current module if we see `self` or `super`, or at the\n-        // top of the crate otherwise.\n-        let mut i = match &*module_path[0].name.as_str() {\n-            \"self\" => 1,\n-            \"super\" => 0,\n-            _ => return Success(NoPrefixFound),\n-        };\n-\n-        let mut containing_module =\n-            self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n-\n-        // Now loop through all the `super`s we find.\n-        while i < module_path.len() && module_path[i].name == \"super\" {\n-            debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   module_to_string(&containing_module));\n-            if let Some(parent) = containing_module.parent {\n-                containing_module = self.module_map[&parent.normal_ancestor_id.unwrap()];\n-                i += 1;\n-            } else {\n-                let msg = \"There are too many initial `super`s.\".into();\n-                return Failed(span.map(|span| (span, msg)));\n-            }\n-        }\n-\n-        debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               module_to_string(&containing_module));\n-\n-        return Success(PrefixFound(containing_module, i));\n-    }\n-\n     fn resolve_crate_var(&mut self, mut crate_var_ctxt: SyntaxContext) -> Module<'a> {\n         while crate_var_ctxt.source().0 != SyntaxContext::empty() {\n             crate_var_ctxt = crate_var_ctxt.source().0;\n@@ -1834,23 +1603,32 @@ impl<'a> Resolver<'a> {\n             ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n                     ast::ViewPathList(ref prefix, ref items) => {\n+                        let path: Vec<_> =\n+                            prefix.segments.iter().map(|seg| seg.identifier).collect();\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n-                            match self.resolve_crate_relative_path(prefix.span,\n-                                                                   &prefix.segments,\n-                                                                   TypeNS) {\n-                                Some(binding) => {\n-                                    let def = binding.def();\n-                                    self.record_def(item.id, PathResolution::new(def));\n-                                }\n-                                None => {\n-                                    resolve_error(self,\n-                                                  prefix.span,\n-                                                  ResolutionError::FailedToResolve(\n-                                                      &path_names_to_string(prefix, 0)));\n-                                    self.record_def(item.id, err_path_resolution());\n+                            let (scope, span) = (PathScope::Import, prefix.span);\n+                            // FIXME(#38012) This should be a module path, not anything in TypeNS.\n+                            let result =\n+                                self.resolve_path(&path, scope, Some(TypeNS), Some(span));\n+                            let (def, msg) = match result {\n+                                PathResult::Module(module) => (module.def().unwrap(), None),\n+                                PathResult::NonModule(res) if res.depth == 0 =>\n+                                    (res.base_def, None),\n+                                PathResult::NonModule(_) => {\n+                                    // Resolve a module path for better errors\n+                                    match self.resolve_path(&path, scope, None, Some(span)) {\n+                                        PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n+                                        _ => unreachable!(),\n+                                    }\n                                 }\n+                                PathResult::Indeterminate => unreachable!(),\n+                                PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n+                            };\n+                            if let Some(msg) = msg {\n+                                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                             }\n+                            self.record_def(item.id, PathResolution::new(def));\n                         }\n                     }\n                     _ => {}\n@@ -1925,60 +1703,51 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_trait_reference(&mut self,\n-                               id: NodeId,\n-                               trait_path: &Path,\n-                               path_depth: usize,\n-                               generics: Option<&Generics>)\n+                               path: &[Ident],\n+                               global: bool,\n+                               generics: Option<&Generics>,\n+                               span: Span)\n                                -> PathResolution {\n-        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS) {\n-            match path_res.base_def {\n-                Def::Trait(_) => {\n-                    debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n-                    return path_res;\n-                }\n-                Def::Err => return err_path_resolution(),\n-                _ => {}\n+        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+        let def = match self.resolve_path(path, scope, None, Some(span)) {\n+            PathResult::Module(module) => Some(module.def().unwrap()),\n+            PathResult::NonModule(..) => return err_path_resolution(),\n+            PathResult::Failed(msg, false) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                return err_path_resolution();\n+            }\n+            _ => match self.resolve_path(path, scope, Some(TypeNS), None) {\n+                PathResult::NonModule(path_resolution) => Some(path_resolution.base_def),\n+                _ => None,\n+            },\n+        };\n+\n+        if let Some(def) = def {\n+            if let Def::Trait(_) = def {\n+                return PathResolution::new(def);\n             }\n \n-            let mut err = resolve_struct_error(self, trait_path.span, {\n-                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth),\n-                                             path_res.base_def.kind_name())\n+            let mut err = resolve_struct_error(self, span, {\n+                ResolutionError::IsNotATrait(&names_to_string(path), def.kind_name())\n             });\n             if let Some(generics) = generics {\n-                if let Some(span) = generics.span_for_name(\n-                    &path_names_to_string(trait_path, path_depth)) {\n-\n+                if let Some(span) = generics.span_for_name(&names_to_string(path)) {\n                     err.span_label(span, &\"type parameter defined here\");\n                 }\n             }\n \n             // If it's a typedef, give a note\n-            if let Def::TyAlias(..) = path_res.base_def {\n+            if let Def::TyAlias(..) = def {\n                 err.note(&format!(\"type aliases cannot be used for traits\"));\n             }\n             err.emit();\n         } else {\n             // find possible candidates\n-            let trait_name = trait_path.segments.last().unwrap().identifier.name;\n-            let candidates =\n-                self.lookup_candidates(\n-                    trait_name,\n-                    TypeNS,\n-                    |def| match def {\n-                        Def::Trait(_) => true,\n-                        _             => false,\n-                    },\n-                );\n-\n-            // create error object\n-            let name = &path_names_to_string(trait_path, path_depth);\n-            let error =\n-                ResolutionError::UndeclaredTraitName(\n-                    name,\n-                    candidates,\n-                );\n+            let is_trait = |def| match def { Def::Trait(_) => true, _ => false };\n+            let candidates = self.lookup_candidates(path.last().unwrap().name, TypeNS, is_trait);\n \n-            resolve_error(self, trait_path.span, error);\n+            let path = names_to_string(path);\n+            resolve_error(self, span, ResolutionError::UndeclaredTraitName(&path, candidates));\n         }\n         err_path_resolution()\n     }\n@@ -2003,8 +1772,9 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let path_res =\n-                self.resolve_trait_reference(trait_ref.ref_id, &trait_ref.path, 0, generics);\n+            let ast::Path { ref segments, span, global } = trait_ref.path;\n+            let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+            let path_res = self.resolve_trait_reference(&path, global, generics, span);\n             assert!(path_res.depth == 0);\n             self.record_def(trait_ref.ref_id, path_res);\n             if path_res.base_def != Def::Err {\n@@ -2265,8 +2035,7 @@ impl<'a> Resolver<'a> {\n                     self.record_def(ty.id, err_path_resolution());\n \n                     // Keep reporting some errors even if they're ignored above.\n-                    let result = self.resolve_path(ty.id, path, 0, TypeNS);\n-                    if result.map(|resolution| resolution.base_def) != Some(Def::Err) {\n+                    {\n                         let kind = if maybe_qself.is_some() {\n                             \"associated type\"\n                         } else {\n@@ -2408,13 +2177,8 @@ impl<'a> Resolver<'a> {\n                 resolution\n             }\n         } else {\n-            if self.resolve_path(pat_id, path, 0, namespace).is_none() {\n-                resolve_error(\n-                    self,\n-                    path.span,\n-                    ResolutionError::PatPathUnresolved(expected_what, path)\n-                );\n-            }\n+            let error = ResolutionError::PatPathUnresolved(expected_what, path);\n+            resolve_error(self, path.span, error);\n             err_path_resolution()\n         };\n \n@@ -2526,81 +2290,32 @@ impl<'a> Resolver<'a> {\n                                    id: NodeId,\n                                    maybe_qself: Option<&QSelf>,\n                                    path: &Path,\n-                                   namespace: Namespace)\n+                                   ns: Namespace)\n                                    -> Option<PathResolution> {\n-        let max_assoc_types;\n-\n-        match maybe_qself {\n-            Some(qself) => {\n-                if qself.position == 0 {\n-                    // FIXME: Create some fake resolution that can't possibly be a type.\n-                    return Some(PathResolution {\n-                        base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len(),\n-                    });\n-                }\n-                max_assoc_types = path.segments.len() - qself.position;\n-                // Make sure the trait is valid.\n-                self.resolve_trait_reference(id, path, max_assoc_types, None);\n-            }\n-            None => {\n-                max_assoc_types = path.segments.len();\n-            }\n-        }\n-\n-        let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace)\n-        });\n-        if resolution.map(|res| res.base_def) == Some(Def::Err) { resolution = None; }\n-        for depth in 1..max_assoc_types {\n-            if resolution.is_some() {\n-                break;\n+        let ast::Path { ref segments, global, span } = *path;\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+\n+        if let Some(qself) = maybe_qself {\n+            if qself.position == 0 {\n+                // FIXME: Create some fake resolution that can't possibly be a type.\n+                return Some(PathResolution {\n+                    base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n+                    depth: path.len(),\n+                });\n             }\n-            self.with_no_errors(|this| {\n-                let partial_resolution = this.resolve_path(id, path, depth, TypeNS);\n-                if let Some(Def::Mod(..)) = partial_resolution.map(|r| r.base_def) {\n-                    // Modules cannot have associated items\n-                } else {\n-                    resolution = partial_resolution;\n-                    if resolution.map(|res| res.base_def) == Some(Def::Err) { resolution = None; }\n-                }\n-            });\n+            // Make sure the trait is valid.\n+            self.resolve_trait_reference(&path[..qself.position], global, None, span);\n         }\n-        resolution\n-    }\n-\n-    /// Skips `path_depth` trailing segments, which is also reflected in the\n-    /// returned value. See `hir::def::PathResolution` for more info.\n-    fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n-                    -> Option<PathResolution> {\n-        debug!(\"resolve_path(id={:?} path={:?}, path_depth={:?})\", id, path, path_depth);\n \n-        let span = path.span;\n-        let segments = &path.segments[..path.segments.len() - path_depth];\n-\n-        let mk_res = |def| PathResolution { base_def: def, depth: path_depth };\n-\n-        if path.global {\n-            let binding = self.resolve_crate_relative_path(span, segments, namespace);\n-            return binding.map(|binding| mk_res(binding.def()));\n-        }\n-\n-        // Try to find a path to an item in a module.\n-        let last_ident = segments.last().unwrap().identifier;\n-        // Resolve a single identifier with fallback to primitive types\n-        let resolve_identifier_with_fallback = |this: &mut Self, record_used| {\n-            let def = this.resolve_identifier(last_ident, namespace, record_used);\n-            match def {\n-                None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n-                    this.primitive_type_table\n-                        .primitive_types\n-                        .get(&last_ident.name)\n-                        .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n-                _ => def\n+        let result = match self.resolve_path(&path, scope, Some(ns), Some(span)) {\n+            PathResult::NonModule(path_res) => match path_res.base_def {\n+                Def::Trait(..) if maybe_qself.is_some() => return None,\n+                _ => path_res,\n+            },\n+            PathResult::Module(module) if !module.is_normal() => {\n+                PathResolution::new(module.def().unwrap())\n             }\n-        };\n-\n-        if segments.len() == 1 {\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n             // don't report an error right away, but try to fallback to a primitive type.\n             // So, we are still able to successfully resolve something like\n@@ -2613,39 +2328,140 @@ impl<'a> Resolver<'a> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let def = resolve_identifier_with_fallback(self, Some(span));\n-            return def.map(|def| mk_res(self.adjust_local_def(def, span)));\n+            _ if self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n+                PathResolution {\n+                    base_def: Def::PrimTy(self.primitive_type_table.primitive_types[&path[0].name]),\n+                    depth: segments.len() - 1,\n+                }\n+            }\n+            PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n+            PathResult::Failed(msg, false) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                err_path_resolution()\n+            }\n+            _ => return None,\n+        };\n+\n+        if path.len() == 1 || result.base_def == Def::Err {\n+            return Some(result);\n         }\n \n-        let unqualified_def = resolve_identifier_with_fallback(self, None);\n-        let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n-        match (qualified_binding, unqualified_def) {\n-            (Some(binding), Some(ref ud)) if binding.def() == ud.def &&\n-                                             segments[0].identifier.name != \"$crate\" => {\n-                self.session\n-                    .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n-                              id,\n-                              span,\n-                              \"unnecessary qualification\".to_string());\n+        let unqualified_result = {\n+            match self.resolve_path(&[*path.last().unwrap()], PathScope::Lexical, Some(ns), None) {\n+                PathResult::NonModule(path_res) => path_res.base_def,\n+                PathResult::Module(module) => module.def().unwrap(),\n+                _ => return Some(result),\n             }\n-            _ => {}\n+        };\n+        if result.base_def == unqualified_result && path[0].name != \"$crate\" {\n+            let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n+            self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n         }\n \n-        qualified_binding.map(|binding| mk_res(binding.def()))\n+        Some(result)\n     }\n \n-    // Resolve a single identifier\n-    fn resolve_identifier(&mut self,\n-                          identifier: Ident,\n-                          namespace: Namespace,\n-                          record_used: Option<Span>)\n-                          -> Option<LocalDef> {\n-        if identifier.name == keywords::Invalid.name() {\n-            return None;\n+    fn resolve_path(&mut self,\n+                    path: &[Ident],\n+                    scope: PathScope,\n+                    opt_ns: Option<Namespace>, // `None` indicates a module path\n+                    record_used: Option<Span>)\n+                    -> PathResult<'a> {\n+        let (mut module, allow_self) = match scope {\n+            PathScope::Lexical => (None, true),\n+            PathScope::Import => (Some(self.graph_root), true),\n+            PathScope::Global => (Some(self.graph_root), false),\n+        };\n+        let mut allow_super = allow_self;\n+\n+        for (i, &ident) in path.iter().enumerate() {\n+            let is_last = i == path.len() - 1;\n+            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+\n+            if i == 0 && allow_self && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n+                module = Some(self.module_map[&self.current_module.normal_ancestor_id.unwrap()]);\n+                continue\n+            } else if i == 0 && allow_self && ns == TypeNS && ident.name == \"$crate\" {\n+                module = Some(self.resolve_crate_var(ident.ctxt));\n+                continue\n+            } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n+                let current_module = if i == 0 { self.current_module } else { module.unwrap() };\n+                let self_module = self.module_map[&current_module.normal_ancestor_id.unwrap()];\n+                if let Some(parent) = self_module.parent {\n+                    module = Some(self.module_map[&parent.normal_ancestor_id.unwrap()]);\n+                    continue\n+                } else {\n+                    let msg = \"There are too many initial `super`s.\".to_string();\n+                    return PathResult::Failed(msg, false);\n+                }\n+            }\n+            allow_super = false;\n+\n+            let binding = if let Some(module) = module {\n+                match self.resolve_name_in_module(module, ident.name, ns, false, record_used) {\n+                    Success(binding) => Ok(binding),\n+                    Indeterminate => Err(Undetermined),\n+                    Failed(_) => Err(Determined),\n+                }\n+            } else {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n+                    Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                    Some(LexicalScopeBinding::Def(def)) if opt_ns.is_some() => {\n+                        return PathResult::NonModule(PathResolution {\n+                            base_def: def,\n+                            depth: path.len() - 1,\n+                        });\n+                    }\n+                    _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n+                }\n+            };\n+\n+            match binding {\n+                Ok(binding) => {\n+                    if let Ok(next_module) = binding.module() {\n+                        module = Some(next_module);\n+                    } else if binding.def() == Def::Err {\n+                        return PathResult::NonModule(err_path_resolution());\n+                    } else if opt_ns.is_some() {\n+                        return PathResult::NonModule(PathResolution {\n+                            base_def: binding.def(),\n+                            depth: path.len() - i - 1,\n+                        });\n+                    } else {\n+                        return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n+                    }\n+                }\n+                Err(Undetermined) => return PathResult::Indeterminate,\n+                Err(Determined) => {\n+                    if let Some(module) = module {\n+                        if opt_ns.is_some() && !module.is_normal() {\n+                            return PathResult::NonModule(PathResolution {\n+                                base_def: module.def().unwrap(),\n+                                depth: path.len() - i,\n+                            });\n+                        }\n+                    }\n+                    let msg = if module.and_then(ModuleS::def) == self.graph_root.def() {\n+                        let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n+                        let mut candidates =\n+                            self.lookup_candidates(ident.name, TypeNS, is_mod).candidates;\n+                        candidates.sort_by_key(|path| (path.segments.len(), path.to_string()));\n+                        if let Some(candidate) = candidates.get(0) {\n+                            format!(\"Did you mean `{}`?\", candidate)\n+                        } else {\n+                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n+                        }\n+                    } else if i == 0 {\n+                        format!(\"Use of undeclared type or module `{}`\", ident)\n+                    } else {\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n+                    };\n+                    return PathResult::Failed(msg, is_last);\n+                }\n+            }\n         }\n \n-        self.resolve_ident_in_lexical_scope(identifier, namespace, record_used)\n-            .map(LexicalScopeBinding::local_def)\n+        PathResult::Module(module.unwrap())\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -2736,65 +2552,6 @@ impl<'a> Resolver<'a> {\n         return def;\n     }\n \n-    // resolve a \"module-relative\" path, e.g. a::b::c\n-    fn resolve_module_relative_path(&mut self,\n-                                    span: Span,\n-                                    segments: &[ast::PathSegment],\n-                                    namespace: Namespace)\n-                                    -> Option<&'a NameBinding<'a>> {\n-        let module_path =\n-            segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n-\n-        let module = match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n-            Failed(err) => {\n-                if let Some((span, msg)) = err {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                return Some(self.dummy_binding);\n-            }\n-            Indeterminate => return None,\n-            Success(module) => module,\n-        };\n-\n-        let name = segments.last().unwrap().identifier.name;\n-        self.resolve_name_in_module(module, name, namespace, false, Some(span)).success()\n-    }\n-\n-    /// Invariant: This must be called only during main resolution, not during\n-    /// import resolution.\n-    fn resolve_crate_relative_path<T>(&mut self, span: Span, segments: &[T], namespace: Namespace)\n-                                      -> Option<&'a NameBinding<'a>>\n-        where T: Named,\n-    {\n-        let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n-        let root = self.graph_root;\n-\n-        let module = match self.resolve_module_path_from_root(root, &module_path, 0, Some(span)) {\n-            Failed(err) => {\n-                if let Some((span, msg)) = err {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                return Some(self.dummy_binding);\n-            }\n-\n-            Indeterminate => return None,\n-\n-            Success(module) => module,\n-        };\n-\n-        let name = segments.last().unwrap().ident().name;\n-        self.resolve_name_in_module(module, name, namespace, false, Some(span)).success()\n-    }\n-\n-    fn with_no_errors<T, F>(&mut self, f: F) -> T\n-        where F: FnOnce(&mut Resolver) -> T\n-    {\n-        self.emit_errors = false;\n-        let rs = f(self);\n-        self.emit_errors = true;\n-        rs\n-    }\n-\n     // Calls `f` with a `Resolver` whose current lexical scope is `module`'s lexical scope,\n     // i.e. the module's items and the prelude (unless the module is `#[no_implicit_prelude]`).\n     // FIXME #34673: This needs testing.\n@@ -2918,11 +2675,7 @@ impl<'a> Resolver<'a> {\n \n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n-                        if self.emit_errors {\n-                            err.help(&msg);\n-                        } else {\n-                            err.span_help(expr.span, &msg);\n-                        }\n+                        err.help(&msg);\n                         err.emit();\n                         self.record_def(expr.id, err_path_resolution());\n                     } else {\n@@ -2943,9 +2696,13 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     // Be helpful if the name refers to a struct\n                     let path_name = path_names_to_string(path, 0);\n-                    let type_res = self.with_no_errors(|this| {\n-                        this.resolve_path(expr.id, path, 0, TypeNS)\n-                    });\n+                    let ast::Path { ref segments, global, .. } = *path;\n+                    let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+                    let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+                    let type_res = match self.resolve_path(&path, scope, Some(TypeNS), None) {\n+                        PathResult::NonModule(type_res) => Some(type_res),\n+                        _ => None,\n+                    };\n \n                     self.record_def(expr.id, err_path_resolution());\n \n@@ -2957,16 +2714,11 @@ impl<'a> Resolver<'a> {\n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n \n-                        if self.emit_errors {\n-                            err.help(&msg);\n-                        } else {\n-                            err.span_help(expr.span, &msg);\n-                        }\n+                        err.help(&msg);\n                         err.emit();\n                     } else {\n                         // Keep reporting some errors even if they're ignored above.\n-                        let result = self.resolve_path(expr.id, path, 0, ValueNS);\n-                        if result.map(|resolution| resolution.base_def) != Some(Def::Err) {\n+                        {\n                             let mut method_scope = false;\n                             let mut is_static = false;\n                             self.ribs[ValueNS].iter().rev().all(|rib| {\n@@ -2986,7 +2738,7 @@ impl<'a> Resolver<'a> {\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);\n                             } else {\n-                                let last_name = path.segments.last().unwrap().identifier.name;\n+                                let last_name = path.last().unwrap().name;\n                                 let (mut msg, is_field) =\n                                     match self.find_fallback_in_self_type(last_name) {\n                                     NoSuggestion => {\n@@ -3018,16 +2770,9 @@ impl<'a> Resolver<'a> {\n                                     msg = format!(\"did you mean {}?\", msg);\n                                 } else {\n                                     // we display a help message if this is a module\n-                                    let name_path: Vec<_> =\n-                                        path.segments.iter().map(|seg| seg.identifier).collect();\n-\n-                                    match self.resolve_module_path(&name_path[..],\n-                                                                   UseLexicalScope,\n-                                                                   Some(expr.span)) {\n-                                        Success(e) => {\n-                                            if let Some(def_type) = e.def() {\n-                                                def = def_type;\n-                                            }\n+                                    match self.resolve_path(&path, scope, None, None) {\n+                                        PathResult::Module(module) => {\n+                                            def = module.def().unwrap();\n                                             context = UnresolvedNameContext::PathIsMod(parent);\n                                         },\n                                         _ => {},\n@@ -3270,7 +3015,7 @@ impl<'a> Resolver<'a> {\n                         segms.push(segment);\n                         let path = Path {\n                             span: span,\n-                            global: true,\n+                            global: false,\n                             segments: segms,\n                         };\n                         // the entity is accessible in the following cases:\n@@ -3320,34 +3065,32 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        let (path, id) = match *vis {\n+        let (segments, span, id) = match *vis {\n             ast::Visibility::Public => return ty::Visibility::Public,\n             ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n-            ast::Visibility::Restricted { ref path, id } => (path, id),\n+            ast::Visibility::Restricted { ref path, id } => (&path.segments, path.span, id),\n             ast::Visibility::Inherited => {\n                 return ty::Visibility::Restricted(self.current_module.normal_ancestor_id.unwrap());\n             }\n         };\n \n-        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let mut path_resolution = err_path_resolution();\n-        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n-            Success(module) => {\n+        let vis = match self.resolve_path(&path, PathScope::Import, None, Some(span)) {\n+            PathResult::Module(module) => {\n                 path_resolution = PathResolution::new(module.def().unwrap());\n                 ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n             }\n-            Indeterminate => unreachable!(),\n-            Failed(err) => {\n-                if let Some((span, msg)) = err {\n-                    self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n-                }\n+            PathResult::Failed(msg, _) => {\n+                self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n                 ty::Visibility::Public\n             }\n+            _ => ty::Visibility::Public,\n         };\n         self.def_map.insert(id, path_resolution);\n         if !self.is_accessible(vis) {\n             let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n-            self.session.span_err(path.span, &msg);\n+            self.session.span_err(span, &msg);\n         }\n         vis\n     }"}, {"sha": "c30154b9bba6478ec1f3a8049f8ed9c6a29b9d5d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "patch": "@@ -12,11 +12,10 @@ use self::ImportDirectiveSubclass::*;\n \n use {Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n+use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n-use UseLexicalScopeFlag::DontUseLexicalScope;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n@@ -27,6 +26,7 @@ use rustc::hir::def::*;\n use syntax::ast::{Ident, NodeId, Name};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n+use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n@@ -482,14 +482,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::PrivateExternal);\n-            let result =\n-                self.resolve_module_path(&directive.module_path, DontUseLexicalScope, None);\n+            let result = self.resolve_path(&directive.module_path, PathScope::Import, None, None);\n             directive.vis.set(vis);\n \n             match result {\n-                Success(module) => module,\n-                Indeterminate => return Indeterminate,\n-                Failed(err) => return Failed(err),\n+                PathResult::Module(module) => module,\n+                PathResult::Indeterminate => return Indeterminate,\n+                _ => return Failed(None),\n             }\n         };\n \n@@ -551,21 +550,20 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_module_path(&module_path, DontUseLexicalScope, Some(span));\n+        let module_result = self.resolve_path(&module_path, PathScope::Import, None, Some(span));\n         let module = match module_result {\n-            Success(module) => module,\n-            Indeterminate => return Indeterminate,\n-            Failed(err) => {\n-                let self_module = self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n-\n-                let resolve_from_self_result = self.resolve_module_path_from_root(\n-                    &self_module, &module_path, 0, Some(span));\n-\n-                return if let Success(_) = resolve_from_self_result {\n+            PathResult::Module(module) => module,\n+            PathResult::NonModule(..) => return Success(()),\n+            PathResult::Indeterminate => return Indeterminate,\n+            PathResult::Failed(msg, _) => {\n+                let mut path = vec![keywords::SelfValue.ident()];\n+                path.extend(module_path);\n+                let result = self.resolve_path(&path, PathScope::Import, None, None);\n+                return if let PathResult::Module(..) = result {\n                     let msg = format!(\"Did you mean `self::{}`?\", &names_to_string(module_path));\n                     Failed(Some((span, msg)))\n                 } else {\n-                    Failed(err)\n+                    Failed(Some((span, msg)))\n                 };\n             },\n         };"}, {"sha": "bee05cd53133af19aea1d9816c2e1df2e6d0d3d7", "filename": "src/test/compile-fail/issue-28388-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs?ref=af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "patch": "@@ -10,6 +10,6 @@\n \n // Prefix in imports with empty braces should be resolved and checked privacy, stability, etc.\n \n-use foo::{}; //~ ERROR failed to resolve. foo\n+use foo::{}; //~ ERROR failed to resolve. Maybe a missing `extern crate foo;`?\n \n fn main() {}"}]}