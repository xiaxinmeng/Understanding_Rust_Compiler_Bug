{"sha": "a47fa9b32f664beb4a50527e547c81cf6d6629bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0N2ZhOWIzMmY2NjRiZWI0YTUwNTI3ZTU0N2M4MWNmNmQ2NjI5YmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T01:57:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T06:14:08Z"}, "message": "librustc: De-export some of trans. rs=deexporting", "tree": {"sha": "9181c5300e043d7607705e35003b62947cc19a10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9181c5300e043d7607705e35003b62947cc19a10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a47fa9b32f664beb4a50527e547c81cf6d6629bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a47fa9b32f664beb4a50527e547c81cf6d6629bf", "html_url": "https://github.com/rust-lang/rust/commit/a47fa9b32f664beb4a50527e547c81cf6d6629bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a47fa9b32f664beb4a50527e547c81cf6d6629bf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b8dfad5cd33ee74acaaae79077346c0f2a25277", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8dfad5cd33ee74acaaae79077346c0f2a25277", "html_url": "https://github.com/rust-lang/rust/commit/4b8dfad5cd33ee74acaaae79077346c0f2a25277"}], "stats": {"total": 433, "additions": 218, "deletions": 215}, "files": [{"sha": "af45dd7064e547c8e231dafeb027c7cf371960f3", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 68, "deletions": 72, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -39,29 +39,29 @@ use syntax::visit;\n // Represents a (possibly monomorphized) top-level fn item or method\n // item.  Note that this is just the fn-ptr and is not a Rust closure\n // value (which is a pair).\n-struct FnData {\n+pub struct FnData {\n     llfn: ValueRef,\n }\n \n-struct MethodData {\n+pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n     self_ty: ty::t,\n     self_mode: ast::rmode\n }\n \n-enum CalleeData {\n+pub enum CalleeData {\n     Closure(Datum),\n     Fn(FnData),\n     Method(MethodData)\n }\n \n-struct Callee {\n+pub struct Callee {\n     bcx: block,\n     data: CalleeData\n }\n \n-fn trans(bcx: block, expr: @ast::expr) -> Callee {\n+pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n     let _icx = bcx.insn_ctxt(\"trans_callee\");\n \n     // pick out special kinds of expressions that can be called:\n@@ -133,17 +133,16 @@ fn trans(bcx: block, expr: @ast::expr) -> Callee {\n     }\n }\n \n-fn trans_fn_ref_to_callee(bcx: block,\n-                          def_id: ast::def_id,\n-                          ref_id: ast::node_id) -> Callee\n-{\n+pub fn trans_fn_ref_to_callee(bcx: block,\n+                              def_id: ast::def_id,\n+                              ref_id: ast::node_id) -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n-fn trans_fn_ref(bcx: block,\n-                def_id: ast::def_id,\n-                ref_id: ast::node_id) -> FnData {\n+pub fn trans_fn_ref(bcx: block,\n+                    def_id: ast::def_id,\n+                    ref_id: ast::node_id) -> FnData {\n     /*!\n      *\n      * Translates a reference (with id `ref_id`) to the fn/method\n@@ -158,26 +157,25 @@ fn trans_fn_ref(bcx: block,\n     trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n }\n \n-fn trans_fn_ref_with_vtables_to_callee(bcx: block,\n-                                       def_id: ast::def_id,\n-                                       ref_id: ast::node_id,\n-                                       +type_params: ~[ty::t],\n-                                       vtables: Option<typeck::vtable_res>)\n-    -> Callee\n-{\n+pub fn trans_fn_ref_with_vtables_to_callee(\n+        bcx: block,\n+        def_id: ast::def_id,\n+        ref_id: ast::node_id,\n+        +type_params: ~[ty::t],\n+        vtables: Option<typeck::vtable_res>)\n+     -> Callee {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id,\n                                                type_params, vtables))}\n }\n \n-fn trans_fn_ref_with_vtables(\n-    bcx: block,            //\n-    def_id: ast::def_id,   // def id of fn\n-    ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n-    +type_params: ~[ty::t], // values for fn's ty params\n-    vtables: Option<typeck::vtable_res>)\n-    -> FnData\n-{\n+pub fn trans_fn_ref_with_vtables(\n+        bcx: block,            //\n+        def_id: ast::def_id,   // def id of fn\n+        ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n+        +type_params: ~[ty::t], // values for fn's ty params\n+        vtables: Option<typeck::vtable_res>)\n+     -> FnData {\n     //!\n     //\n     // Translates a reference to a fn/method item, monomorphizing and\n@@ -289,26 +287,25 @@ fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-fn trans_call(in_cx: block,\n-              call_ex: @ast::expr,\n-              f: @ast::expr,\n-              args: CallArgs,\n-              id: ast::node_id,\n-              dest: expr::Dest)\n-    -> block\n-{\n+pub fn trans_call(in_cx: block,\n+                  call_ex: @ast::expr,\n+                  f: @ast::expr,\n+                  args: CallArgs,\n+                  id: ast::node_id,\n+                  dest: expr::Dest)\n+               -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_call\");\n     trans_call_inner(\n         in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n         |cx| trans(cx, f), args, dest, DontAutorefArg)\n }\n \n-fn trans_method_call(in_cx: block,\n-                     call_ex: @ast::expr,\n-                     rcvr: @ast::expr,\n-                     args: CallArgs,\n-                     dest: expr::Dest)\n-                  -> block {\n+pub fn trans_method_call(in_cx: block,\n+                         call_ex: @ast::expr,\n+                         rcvr: @ast::expr,\n+                         args: CallArgs,\n+                         dest: expr::Dest)\n+                      -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n     trans_call_inner(\n         in_cx,\n@@ -335,8 +332,11 @@ fn trans_method_call(in_cx: block,\n         DontAutorefArg)\n }\n \n-fn trans_rtcall_or_lang_call(bcx: block, did: ast::def_id, args: ~[ValueRef],\n-                             dest: expr::Dest) -> block {\n+pub fn trans_rtcall_or_lang_call(bcx: block,\n+                                 did: ast::def_id,\n+                                 args: ~[ValueRef],\n+                                 dest: expr::Dest)\n+                              -> block {\n     let fty = if did.crate == ast::local_crate {\n         ty::node_id_to_type(bcx.ccx().tcx, did.node)\n     } else {\n@@ -349,11 +349,12 @@ fn trans_rtcall_or_lang_call(bcx: block, did: ast::def_id, args: ~[ValueRef],\n         ArgVals(args), dest, DontAutorefArg);\n }\n \n-fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n-                                              did: ast::def_id,\n-                                              args: ~[ValueRef],\n-                                              type_params: ~[ty::t],\n-                                              dest: expr::Dest) -> block {\n+pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n+                                                  did: ast::def_id,\n+                                                  args: ~[ValueRef],\n+                                                  type_params: ~[ty::t],\n+                                                  dest: expr::Dest)\n+                                               -> block {\n     let fty;\n     if did.crate == ast::local_crate {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n@@ -389,7 +390,7 @@ fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n         ArgVals(args), dest, DontAutorefArg);\n }\n \n-fn body_contains_ret(body: ast::blk) -> bool {\n+pub fn body_contains_ret(body: ast::blk) -> bool {\n     let cx = {mut found: false};\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_item: |_i, _cx, _v| { },\n@@ -407,16 +408,15 @@ fn body_contains_ret(body: ast::blk) -> bool {\n }\n \n // See [Note-arg-mode]\n-fn trans_call_inner(\n+pub fn trans_call_inner(\n     ++in_cx: block,\n     call_info: Option<node_info>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n     get_callee: fn(block) -> Callee,\n     args: CallArgs,\n     dest: expr::Dest,\n-    autoref_arg: AutorefArg) -> block\n-{\n+    autoref_arg: AutorefArg) -> block {\n     do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n         let ret_in_loop = match /*bad*/copy args {\n           ArgExprs(args) => {\n@@ -520,21 +520,19 @@ fn trans_call_inner(\n     }\n }\n \n-\n-enum CallArgs {\n+pub enum CallArgs {\n     ArgExprs(~[@ast::expr]),\n     ArgVals(~[ValueRef])\n }\n \n-fn trans_args(cx: block,\n-              llenv: ValueRef,\n-              +args: CallArgs,\n-              fn_ty: ty::t,\n-              dest: expr::Dest,\n-              ret_flag: Option<ValueRef>,\n-              +autoref_arg: AutorefArg)\n-    -> {bcx: block, args: ~[ValueRef], retslot: ValueRef}\n-{\n+pub fn trans_args(cx: block,\n+                  llenv: ValueRef,\n+                  +args: CallArgs,\n+                  fn_ty: ty::t,\n+                  dest: expr::Dest,\n+                  ret_flag: Option<ValueRef>,\n+                  +autoref_arg: AutorefArg)\n+               -> {bcx: block, args: ~[ValueRef], retslot: ValueRef} {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n@@ -594,21 +592,19 @@ fn trans_args(cx: block,\n     return {bcx: bcx, args: llargs, retslot: llretslot};\n }\n \n-enum AutorefArg {\n+pub enum AutorefArg {\n     DontAutorefArg,\n     DoAutorefArg\n }\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n-fn trans_arg_expr(bcx: block,\n-                  formal_ty: ty::arg,\n-                  arg_expr: @ast::expr,\n-                  temp_cleanups: &mut ~[ValueRef],\n-                  ret_flag: Option<ValueRef>,\n-                  +autoref_arg: AutorefArg)\n-    -> Result\n-{\n+pub fn trans_arg_expr(bcx: block,\n+                      formal_ty: ty::arg,\n+                      arg_expr: @ast::expr,\n+                      temp_cleanups: &mut ~[ValueRef],\n+                      ret_flag: Option<ValueRef>,\n+                      +autoref_arg: AutorefArg) -> Result {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n "}, {"sha": "92ea60d1946cda8fff34aa5d4f3811db83a7c3a6", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -18,9 +18,12 @@ use middle::trans::datum::*;\n \n use core::str;\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+pub fn macros() {\n+    // FIXME(#3114): Macro import/export.\n+    include!(\"macros.rs\");\n+}\n \n-fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n+pub fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| {\n@@ -42,13 +45,12 @@ fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n     return bcx;\n }\n \n-fn trans_if(bcx: block,\n+pub fn trans_if(bcx: block,\n             cond: @ast::expr,\n             thn: ast::blk,\n             els: Option<@ast::expr>,\n             dest: expr::Dest)\n-    -> block\n-{\n+         -> block {\n     debug!(\"trans_if(bcx=%s, cond=%s, thn=%?, dest=%s)\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.node.id,\n            dest.to_str(bcx.ccx()));\n@@ -95,7 +97,7 @@ fn trans_if(bcx: block,\n \n }\n \n-fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n+pub fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n     let out = sub_block(parent_bcx, ~\"join\");\n     let mut reachable = false;\n     for vec::each(in_cxs) |bcx| {\n@@ -110,8 +112,7 @@ fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n     return out;\n }\n \n-fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk)\n-    -> block {\n+pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, ~\"while next\");\n \n@@ -149,7 +150,10 @@ fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk)\n     return next_bcx;\n }\n \n-fn trans_loop(bcx:block, body: ast::blk, opt_label: Option<ident>) -> block {\n+pub fn trans_loop(bcx:block,\n+                  body: ast::blk,\n+                  opt_label: Option<ident>)\n+               -> block {\n     let _icx = bcx.insn_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, ~\"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, ~\"`loop`\",\n@@ -160,11 +164,10 @@ fn trans_loop(bcx:block, body: ast::blk, opt_label: Option<ident>) -> block {\n     return next_bcx;\n }\n \n-fn trans_log(log_ex: @ast::expr,\n-             lvl: @ast::expr,\n-             bcx: block,\n-             e: @ast::expr) -> block\n-{\n+pub fn trans_log(log_ex: @ast::expr,\n+                 lvl: @ast::expr,\n+                 bcx: block,\n+                 e: @ast::expr) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n@@ -223,8 +226,10 @@ fn trans_log(log_ex: @ast::expr,\n     }\n }\n \n-fn trans_break_cont(bcx: block, opt_label: Option<ident>, to_end: bool)\n-    -> block {\n+pub fn trans_break_cont(bcx: block,\n+                        opt_label: Option<ident>,\n+                        to_end: bool)\n+                     -> block {\n     let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n@@ -270,15 +275,15 @@ fn trans_break_cont(bcx: block, opt_label: Option<ident>, to_end: bool)\n     return bcx;\n }\n \n-fn trans_break(bcx: block, label_opt: Option<ident>) -> block {\n+pub fn trans_break(bcx: block, label_opt: Option<ident>) -> block {\n     return trans_break_cont(bcx, label_opt, true);\n }\n \n-fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n+pub fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n     return trans_break_cont(bcx, label_opt, false);\n }\n \n-fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n+pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let retptr = match copy bcx.fcx.loop_ret {\n@@ -306,8 +311,12 @@ fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     Unreachable(bcx);\n     return bcx;\n }\n-fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n-                    pred_expr: @ast::expr, s: ~str) -> block {\n+\n+pub fn trans_check_expr(bcx: block,\n+                        chk_expr: @ast::expr,\n+                        pred_expr: @ast::expr,\n+                        s: ~str)\n+                     -> block {\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n     let expr_str = s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n         + ~\" failed\";\n@@ -321,9 +330,10 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n     }\n }\n \n-fn trans_fail_expr(bcx: block,\n-                   sp_opt: Option<span>,\n-                   fail_expr: Option<@ast::expr>) -> block {\n+pub fn trans_fail_expr(bcx: block,\n+                       sp_opt: Option<span>,\n+                       fail_expr: Option<@ast::expr>)\n+                    -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n@@ -347,17 +357,19 @@ fn trans_fail_expr(bcx: block,\n     }\n }\n \n-fn trans_fail(bcx: block, sp_opt: Option<span>, +fail_str: ~str)\n-    -> block\n-{\n+pub fn trans_fail(bcx: block,\n+                  sp_opt: Option<span>,\n+                  +fail_str: ~str)\n+               -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: block, sp_opt: Option<span>, V_fail_str: ValueRef)\n-    -> block\n-{\n+fn trans_fail_value(bcx: block,\n+                    sp_opt: Option<span>,\n+                    V_fail_str: ValueRef)\n+                 -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let {V_filename, V_line} = match sp_opt {\n@@ -381,8 +393,8 @@ fn trans_fail_value(bcx: block, sp_opt: Option<span>, V_fail_str: ValueRef)\n     return bcx;\n }\n \n-fn trans_fail_bounds_check(bcx: block, sp: span,\n-                           index: ValueRef, len: ValueRef) -> block {\n+pub fn trans_fail_bounds_check(bcx: block, sp: span,\n+                               index: ValueRef, len: ValueRef) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_bounds_check\");\n     let ccx = bcx.ccx();\n "}, {"sha": "b4dd59cd624b075439d4a36eda704dd0301cf947", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -114,12 +114,12 @@ use core::uint;\n use core::vec;\n use syntax::parse::token::special_idents;\n \n-enum CopyAction {\n+pub enum CopyAction {\n     INIT,\n     DROP_EXISTING\n }\n \n-struct Datum {\n+pub struct Datum {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `mode` below.\n     val: ValueRef,\n@@ -137,20 +137,20 @@ struct Datum {\n     source: DatumSource\n }\n \n-struct DatumBlock {\n+pub struct DatumBlock {\n     bcx: block,\n     datum: Datum,\n }\n \n-enum DatumMode {\n+pub enum DatumMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,\n \n     /// `val` is the actual value (*only used for immediates* like ints, ptrs)\n     ByValue,\n }\n \n-impl DatumMode {\n+pub impl DatumMode {\n     fn is_by_ref() -> bool {\n         match self { ByRef => true, ByValue => false }\n     }\n@@ -160,27 +160,27 @@ impl DatumMode {\n     }\n }\n \n-impl DatumMode: cmp::Eq {\n+pub impl DatumMode: cmp::Eq {\n     pure fn eq(&self, other: &DatumMode) -> bool {\n         (*self) as uint == (*other as uint)\n     }\n     pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n-impl DatumMode: to_bytes::IterBytes {\n+pub impl DatumMode: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n /// See `Datum Sources` section at the head of this module.\n-enum DatumSource {\n+pub enum DatumSource {\n     FromRvalue,\n     FromLvalue,\n     FromLastUseLvalue,\n }\n \n-impl DatumSource {\n+pub impl DatumSource {\n     fn is_rvalue() -> bool {\n         match self {\n             FromRvalue => true,\n@@ -196,16 +196,19 @@ impl DatumSource {\n     }\n }\n \n-fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n+pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n     return Datum {val: val, ty: ty,\n                   mode: ByValue, source: FromRvalue};\n }\n \n-fn immediate_rvalue_bcx(bcx: block, val: ValueRef, ty: ty::t) -> DatumBlock {\n+pub fn immediate_rvalue_bcx(bcx: block,\n+                            val: ValueRef,\n+                            ty: ty::t)\n+                         -> DatumBlock {\n     return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n }\n \n-fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n     /*!\n      *\n      * Allocates temporary space on the stack using alloca() and\n@@ -221,7 +224,7 @@ fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n     Datum { val: scratch, ty: ty, mode: ByRef, source: FromRvalue }\n }\n \n-fn appropriate_mode(ty: ty::t) -> DatumMode {\n+pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n     /*!\n     *\n     * Indicates the \"appropriate\" mode for this value,\n@@ -237,7 +240,7 @@ fn appropriate_mode(ty: ty::t) -> DatumMode {\n     }\n }\n \n-impl Datum {\n+pub impl Datum {\n     fn store_will_move() -> bool {\n         match self.source {\n             FromRvalue | FromLastUseLvalue => true,\n@@ -348,7 +351,7 @@ impl Datum {\n                 Store(bcx, self.val, dst);\n             }\n             ByRef => {\n-                memcpy_ty(bcx, dst, self.val, self.ty);\n+                base::memcpy_ty(bcx, dst, self.val, self.ty);\n             }\n         }\n \n@@ -375,7 +378,7 @@ impl Datum {\n \n         match self.mode {\n             ByRef => {\n-                glue::memcpy_ty(bcx, dst, self.val, self.ty);\n+                base::memcpy_ty(bcx, dst, self.val, self.ty);\n             }\n             ByValue => {\n                 Store(bcx, self.val, dst);\n@@ -823,7 +826,7 @@ impl Datum {\n     }\n }\n \n-impl DatumBlock {\n+pub impl DatumBlock {\n     fn unpack(bcx: &mut block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n@@ -871,7 +874,7 @@ impl DatumBlock {\n     }\n }\n \n-impl CopyAction : cmp::Eq {\n+pub impl CopyAction : cmp::Eq {\n     pure fn eq(&self, other: &CopyAction) -> bool {\n         match ((*self), (*other)) {\n             (INIT, INIT) => true,"}, {"sha": "ab1e386cc7cb33e94315299adeb21ddc8e93c436", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -137,28 +137,14 @@ use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n use syntax::ast::spanned;\n \n-// The primary two functions for translating expressions:\n-export trans_to_datum, trans_into;\n-\n-// More specific variants than trans_to_datum/trans_into that are useful\n-// in some scenarios:\n-export trans_local_var;\n-\n-// Other helpers, types, and so forth:\n-export with_field_tys;\n-export Dest, SaveIn, Ignore;\n-export cast_type_kind;\n-export cast_kind, cast_pointer, cast_integral, cast_float;\n-export cast_enum, cast_other;\n-\n // Destinations\n \n // These are passed around by the code generating functions to track the\n // destination of a computation's value.\n \n fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n-enum Dest {\n+pub enum Dest {\n     SaveIn(ValueRef),\n     Ignore,\n }\n@@ -190,7 +176,7 @@ fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n     return bcx;\n }\n \n-fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n+pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n     return match bcx.tcx().adjustments.find(expr.id) {\n         None => {\n@@ -271,7 +257,7 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n+pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n     return match bcx.tcx().adjustments.find(expr.id) {\n         None => trans_into_unadjusted(bcx, expr, dest),\n         Some(_) => {\n@@ -830,10 +816,10 @@ fn trans_def_lvalue(bcx: block,\n     }\n }\n \n-fn trans_local_var(bcx: block,\n-                   def: ast::def,\n-                   expr_id_opt: Option<ast::node_id>)\n-                -> Datum {\n+pub fn trans_local_var(bcx: block,\n+                       def: ast::def,\n+                       expr_id_opt: Option<ast::node_id>)\n+                    -> Datum {\n     let _icx = bcx.insn_ctxt(\"trans_local_var\");\n \n     return match def {\n@@ -949,10 +935,10 @@ fn fn_data_to_datum(bcx: block,\n // The optional node ID here is the node ID of the path identifying the enum\n // variant in use. If none, this cannot possibly an enum variant (so, if it\n // is and `node_id_opt` is none, this function fails).\n-fn with_field_tys<R>(tcx: ty::ctxt,\n-                     ty: ty::t,\n-                     node_id_opt: Option<ast::node_id>,\n-                     op: fn(bool, (&[ty::field])) -> R) -> R {\n+pub fn with_field_tys<R>(tcx: ty::ctxt,\n+                         ty: ty::t,\n+                         node_id_opt: Option<ast::node_id>,\n+                         op: fn(bool, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_rec(ref fields) => {\n             op(false, *fields)\n@@ -1521,7 +1507,7 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     } else { llsrc };\n }\n \n-enum cast_kind {\n+pub enum cast_kind {\n     cast_pointer,\n     cast_integral,\n     cast_float,\n@@ -1547,7 +1533,7 @@ impl cast_kind : cmp::Eq {\n     pure fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n }\n \n-fn cast_type_kind(t: ty::t) -> cast_kind {\n+pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_float(*)   => cast_float,\n         ty::ty_ptr(*)     => cast_pointer,"}, {"sha": "090de8508b6b58f63d065dc10a202e3c5280df16", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -28,7 +28,7 @@ use middle::trans::uniq;\n use core::io;\n use core::str;\n \n-fn trans_free(cx: block, v: ValueRef) -> block {\n+pub fn trans_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_free\");\n     callee::trans_rtcall_or_lang_call(\n         cx,\n@@ -37,7 +37,7 @@ fn trans_free(cx: block, v: ValueRef) -> block {\n         expr::Ignore)\n }\n \n-fn trans_unique_free(cx: block, v: ValueRef) -> block {\n+pub fn trans_unique_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_unique_free\");\n     callee::trans_rtcall_or_lang_call(\n         cx,\n@@ -46,7 +46,7 @@ fn trans_unique_free(cx: block, v: ValueRef) -> block {\n         expr::Ignore)\n }\n \n-fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = cx.insn_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -55,7 +55,7 @@ fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = cx.insn_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -64,7 +64,11 @@ fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n+pub fn drop_ty_root(bcx: block,\n+                    v: ValueRef,\n+                    rooted: bool,\n+                    t: ty::t)\n+                 -> block {\n     if rooted {\n         // NB: v is a raw ptr to an addrspace'd ptr to the value.\n         let v = PointerCast(bcx, Load(bcx, v), T_ptr(type_of(bcx.ccx(), t)));\n@@ -74,7 +78,7 @@ fn drop_ty_root(bcx: block, v: ValueRef, rooted: bool, t: ty::t) -> block {\n     }\n }\n \n-fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n@@ -91,7 +95,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n+pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n     let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -111,7 +115,7 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n     }\n }\n \n-fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = cx.insn_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -120,7 +124,7 @@ fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     return cx;\n }\n \n-fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n@@ -138,16 +142,15 @@ fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n-                               static_ti: @tydesc_info) {\n+pub fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n+                                   static_ti: @tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n }\n \n-fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n-\n+pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     if (field == abi::tydesc_field_take_glue ||\n         field == abi::tydesc_field_drop_glue ||\n         field == abi::tydesc_field_free_glue) &&\n@@ -200,16 +203,17 @@ fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pure fn cast_glue(ccx: @crate_ctxt, ti: @tydesc_info, v: ValueRef)\n-    -> ValueRef {\n+pub pure fn cast_glue(ccx: @crate_ctxt, ti: @tydesc_info, v: ValueRef)\n+                   -> ValueRef {\n     unsafe {\n         let llfnty = type_of_glue_fn(ccx, ti.ty);\n         llvm::LLVMConstPointerCast(v, T_ptr(llfnty))\n     }\n }\n \n-fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt, field: uint,\n-                                      ti: @tydesc_info) -> bool {\n+pub fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt,\n+                                          field: uint,\n+                                          ti: @tydesc_info) -> bool {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n@@ -234,8 +238,9 @@ fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt, field: uint,\n }\n \n \n-fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n-                           ti: @tydesc_info) {\n+pub fn lazily_emit_tydesc_glue(ccx: @crate_ctxt,\n+                               field: uint,\n+                               ti: @tydesc_info) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx, ti.ty);\n \n@@ -299,8 +304,8 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n }\n \n // See [Note-arg-mode]\n-fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n-                         field: uint, static_ti: Option<@tydesc_info>) {\n+pub fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n+                             field: uint, static_ti: Option<@tydesc_info>) {\n     let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n@@ -363,15 +368,15 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n }\n \n // See [Note-arg-mode]\n-fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n+pub fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n-fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n@@ -382,7 +387,7 @@ fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(\"make_free_glue\");\n     let ccx = bcx.ccx();\n@@ -437,12 +442,13 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn trans_struct_drop(bcx: block,\n-                    v0: ValueRef,\n-                    dtor_did: ast::def_id,\n-                    class_did: ast::def_id,\n-                    substs: &ty::substs,\n-                    take_ref: bool) -> block {\n+pub fn trans_struct_drop(bcx: block,\n+                         v0: ValueRef,\n+                         dtor_did: ast::def_id,\n+                         class_did: ast::def_id,\n+                         substs: &ty::substs,\n+                         take_ref: bool)\n+                      -> block {\n     let drop_flag = GEPi(bcx, v0, struct_dtor());\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n         let mut bcx = cx;\n@@ -491,7 +497,7 @@ fn trans_struct_drop(bcx: block,\n }\n \n \n-fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n+pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n@@ -549,7 +555,10 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n+pub fn decr_refcnt_maybe_free(bcx: block,\n+                              box_ptr: ValueRef,\n+                              t: ty::t)\n+                           -> block {\n     let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n@@ -563,7 +572,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n }\n \n \n-fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     let bcx = match ty::get(t).sty {\n@@ -612,7 +621,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n+pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n     let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n@@ -623,7 +632,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n \n \n // Chooses the addrspace for newly declared types.\n-fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n+pub fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n     if !ty::type_needs_drop(ccx.tcx, t) {\n         return default_addrspace;\n     } else if ty::type_is_immediate(t) {\n@@ -637,7 +646,7 @@ fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+pub fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n@@ -682,10 +691,10 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     return inf;\n }\n \n-type glue_helper = fn@(block, ValueRef, ty::t);\n+pub type glue_helper = fn@(block, ValueRef, ty::t);\n \n-fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n-                        +name: ~str) -> ValueRef {\n+pub fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n+                            +name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let mut fn_nm;\n@@ -703,8 +712,11 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     return llfn;\n }\n \n-fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n-                           llfn: ValueRef, helper: glue_helper) -> ValueRef {\n+pub fn make_generic_glue_inner(ccx: @crate_ctxt,\n+                               t: ty::t,\n+                               llfn: ValueRef,\n+                               helper: glue_helper)\n+                            -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -725,9 +737,9 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     return llfn;\n }\n \n-fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n-                     helper: glue_helper, name: ~str)\n-    -> ValueRef {\n+pub fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n+                         helper: glue_helper, name: ~str)\n+                      -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n         return make_generic_glue_inner(ccx, t, llfn, helper);\n@@ -741,7 +753,7 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n     return llval;\n }\n \n-fn emit_tydescs(ccx: @crate_ctxt) {\n+pub fn emit_tydescs(ccx: @crate_ctxt) {\n     let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;"}, {"sha": "f5d232363347c32fe28661ee9057b82615db5a8e", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -27,8 +27,8 @@ use syntax::ast_util::local_def;\n // `translate` will be true if this function is allowed to translate the\n // item and false otherwise. Currently, this parameter is set to false when\n // translating default methods.\n-fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n-                            translate: bool)\n+pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n+                                translate: bool)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(fn_id) {"}, {"sha": "9924e5d97cc027bc8d5c4d11cf26dc04a059507f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -36,13 +36,13 @@ use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util::local_def;\n use syntax::parse::token::special_idents;\n \n-fn monomorphic_fn(ccx: @crate_ctxt,\n-                  fn_id: ast::def_id,\n-                  real_substs: ~[ty::t],\n-                  vtables: Option<typeck::vtable_res>,\n-                  impl_did_opt: Option<ast::def_id>,\n-                  ref_id: Option<ast::node_id>) ->\n-                  {val: ValueRef, must_cast: bool} {\n+pub fn monomorphic_fn(ccx: @crate_ctxt,\n+                      fn_id: ast::def_id,\n+                      real_substs: ~[ty::t],\n+                      vtables: Option<typeck::vtable_res>,\n+                      impl_did_opt: Option<ast::def_id>,\n+                      ref_id: Option<ast::node_id>) ->\n+                      {val: ValueRef, must_cast: bool} {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n@@ -268,7 +268,8 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     {val: lldecl, must_cast: must_cast}\n }\n \n-fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n+pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n+                                      ty: ty::t) -> Option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n     match ty::get(ty).sty {\n         ty::ty_box(*) => {\n@@ -305,10 +306,10 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> Option<ty::t> {\n     }\n }\n \n-fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n-                vtables: Option<typeck::vtable_res>,\n-                impl_did_opt: Option<ast::def_id>,\n-                param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n+pub fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n+                    vtables: Option<typeck::vtable_res>,\n+                    impl_did_opt: Option<ast::def_id>,\n+                    param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;"}, {"sha": "15b250a302de898c6bcb913207b371a65df90164", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa9b32f664beb4a50527e547c81cf6d6629bf/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=a47fa9b32f664beb4a50527e547c81cf6d6629bf", "patch": "@@ -50,19 +50,12 @@ use back_ = back;\n \n pub mod middle {\n     pub mod trans {\n-        #[legacy_exports]\n         pub mod inline;\n-        #[legacy_exports]\n         pub mod monomorphize;\n-        #[legacy_exports]\n         pub mod controlflow;\n-        #[legacy_exports]\n         pub mod glue;\n-        #[legacy_exports]\n         pub mod datum;\n-        #[legacy_exports]\n         pub mod callee;\n-        #[legacy_exports]\n         pub mod expr;\n         #[legacy_exports]\n         pub mod common;"}]}