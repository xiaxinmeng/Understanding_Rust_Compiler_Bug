{"sha": "2118ff401f64789b6a9e64134d6d2797efee4be9", "node_id": "C_kwDOAAsO6NoAKDIxMThmZjQwMWY2NDc4OWI2YTllNjQxMzRkNmQyNzk3ZWZlZTRiZTk", "commit": {"author": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-09-10T21:45:38Z"}, "committer": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-12-28T11:53:47Z"}, "message": "Migrate placeholder_error.rs", "tree": {"sha": "9d22958dead53788fe0235782fb4b12be116e38d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d22958dead53788fe0235782fb4b12be116e38d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2118ff401f64789b6a9e64134d6d2797efee4be9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEAWou4Gq79HasRseDspeR1Nh440UFAmOsLksACgkQspeR1Nh4\n40VKeA/+P1oOJhmt5obdjeJeeAcarB5PxZvxLSvY3DGctysDvPcJpyhekJpc6nz6\nVZjlAgfuar6IExEL8I9AI65k/4LLj0tKHD/qugMO75AJ5cjVlpoBJvxYDe5xDJed\nxDHAJ8JRdeGgmgiBGgz+/osGhsWWEtqr87Vcb3nsxr8NIgoQfOCMm85x/wGOZKiz\nHf9dk9Pn/NTc7RZRNILIqO7L+XT5wEP884SFf9V+KV1ittX8m4Novb1ENKl2sBoh\nS2RgDjjGpp+/gNWpVDpZ5xU8McRwvJgrkkl1pdTdoXOrIKcfjAEh2VXBpcNn0EfS\ncPgRMDMijXGJY7L1i8xoeMNtn4on7y5933BNTlci5ig8Xk5XjyMzXHpvQOzvPj31\nWXMP55jPlIPxRgyNXJMekEfyUvP2DNXFtmHrkZ+b18xi+c7xERTyyu7B4jawPkBU\nCwJCvcPzyTeNJuAaH3HhqpsORxJe4gLO5t+/iz9QVHJmseibdGoy2gQp7Ze7GmuB\nR3clqK4/53jVQ+PIEQscUADGNlPjwwIqOUGMgJaH6bUBd6Q4olm8vRqGXbj6uyYP\nucV2QbJyDW6VekOpSpIG7ct1yDkNCv+XlcwGRZaQuYs/Nw8kMnYL5IabbJK0acXl\nHPoyorCr9VEShVf9flk/6qPRwj53ZSxfTJLbyrQjOTbVBX6BHAU=\n=MvMx\n-----END PGP SIGNATURE-----", "payload": "tree 9d22958dead53788fe0235782fb4b12be116e38d\nparent 8360a40a8a2ff2098eed561dd89c577349dbbb76\nauthor Nikita Tomashevich <quant3234@gmail.com> 1662846338 +0300\ncommitter Nikita Tomashevich <quant3234@gmail.com> 1672228427 +0300\n\nMigrate placeholder_error.rs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2118ff401f64789b6a9e64134d6d2797efee4be9", "html_url": "https://github.com/rust-lang/rust/commit/2118ff401f64789b6a9e64134d6d2797efee4be9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2118ff401f64789b6a9e64134d6d2797efee4be9/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8360a40a8a2ff2098eed561dd89c577349dbbb76", "url": "https://api.github.com/repos/rust-lang/rust/commits/8360a40a8a2ff2098eed561dd89c577349dbbb76", "html_url": "https://github.com/rust-lang/rust/commit/8360a40a8a2ff2098eed561dd89c577349dbbb76"}], "stats": {"total": 312, "additions": 186, "deletions": 126}, "files": [{"sha": "a52ac1339468c8b284a55d4af69e6b66c901b55b", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2118ff401f64789b6a9e64134d6d2797efee4be9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2118ff401f64789b6a9e64134d6d2797efee4be9/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=2118ff401f64789b6a9e64134d6d2797efee4be9", "patch": "@@ -183,3 +183,31 @@ infer_explicit_lifetime_required_sugg = add explicit lifetime `{$named}` to {$id\n     [ident] the type of `{$simple_ident}`\n     *[param_type] type\n }\n+\n+infer_actual_impl_expl_1 = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}{$kind ->\n+    [signature] closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n+    [passive] `{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n+    *[other] `{$ty_or_sig}` must implement `{$trait_path}`\n+}{$lt_kind ->\n+    [two] , for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+    [any] , for any lifetime `'{$lifetime_1}`...\n+    [some] , for some specific lifetime `'{lifetime_1}`...\n+    *[nothing] {\"\"}\n+}\n+\n+infer_actual_impl_expl_2 = {$kind_2 ->\n+    [implements_trait] ...but it actually implements `{$trait_path_2}`\n+    [implemented_for_ty] ...but `{$trait_path_2}` is actually implemented for the type `{$ty}`\n+    *[ty_implements] ...but `{$ty}` actually implements `{$trait_path_2}`\n+}{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+\n+infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n+    .label_satisfy = doesn't satisfy where-clause\n+    .label_where = due to a where-clause on `{$def_id}`...\n+    .label_dup = implementation of `{$trait_def_id}` is not general enough"}, {"sha": "f694c5ca40978fe7bc349efe05a7ca354912346c", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2118ff401f64789b6a9e64134d6d2797efee4be9/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2118ff401f64789b6a9e64134d6d2797efee4be9/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=2118ff401f64789b6a9e64134d6d2797efee4be9", "patch": "@@ -540,3 +540,44 @@ pub struct ExplicitLifetimeRequired<'a> {\n     #[skip_arg]\n     pub new_ty: Ty<'a>,\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum ActualImplExplNotes {\n+    // Field names have to be different across all variants\n+    #[note(infer::actual_impl_expl_1)]\n+    NoteOne {\n+        leading_ellipsis: bool,\n+        kind: &'static str,\n+        ty_or_sig: String,\n+        trait_path: String,\n+        lt_kind: &'static str,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer::actual_impl_expl_2)]\n+    NoteTwo {\n+        kind_2: &'static str,\n+        trait_path_2: String,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::trait_placeholder_mismatch)]\n+pub struct TraitPlaceholderMismatch {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(infer::label_satisfy)]\n+    pub satisfy_span: Option<Span>,\n+    #[label(infer::label_where)]\n+    pub where_span: Option<Span>,\n+    #[label(infer::label_dup)]\n+    pub dup_span: Option<Span>,\n+    pub def_id: String,\n+    pub trait_def_id: String,\n+\n+    #[subdiagnostic]\n+    pub actual_impl_expl_notes: Vec<ActualImplExplNotes>,\n+}"}, {"sha": "d9fc2ec243f11c955caa1993615a46fba045cd60", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 117, "deletions": 126, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/2118ff401f64789b6a9e64134d6d2797efee4be9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2118ff401f64789b6a9e64134d6d2797efee4be9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=2118ff401f64789b6a9e64134d6d2797efee4be9", "patch": "@@ -1,18 +1,19 @@\n+use crate::errors::{ActualImplExplNotes, TraitPlaceholderMismatch};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, RePlaceholder, ReVar, Region, TyCtxt};\n \n-use std::fmt::{self, Write};\n+use std::fmt;\n \n impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -205,26 +206,21 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_substs: SubstsRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let span = cause.span();\n-        let msg = format!(\n-            \"implementation of `{}` is not general enough\",\n-            self.tcx().def_path_str(trait_def_id),\n-        );\n-        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n \n-        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id)\n-        | ObligationCauseCode::ExprItemObligation(def_id, ..) =\n-            *cause.code()\n-        {\n-            err.span_label(span, \"doesn't satisfy where-clause\");\n-            err.span_label(\n-                self.tcx().def_span(def_id),\n-                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n-            );\n-            true\n-        } else {\n-            err.span_label(span, &msg);\n-            false\n-        };\n+        let (leading_ellipsis, satisfy_span, where_span, dup_span, def_id) =\n+            if let ObligationCauseCode::ItemObligation(def_id)\n+            | ObligationCauseCode::ExprItemObligation(def_id, ..) = *cause.code()\n+            {\n+                (\n+                    true,\n+                    Some(span),\n+                    Some(self.tcx().def_span(def_id)),\n+                    None,\n+                    self.tcx().def_path_str(def_id),\n+                )\n+            } else {\n+                (false, None, None, Some(span), String::new())\n+            };\n \n         let expected_trait_ref = self\n             .cx\n@@ -284,8 +280,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             ?expected_self_ty_has_vid,\n         );\n \n-        self.explain_actual_impl_that_was_found(\n-            &mut err,\n+        let actual_impl_expl_notes = self.explain_actual_impl_that_was_found(\n             sub_placeholder,\n             sup_placeholder,\n             has_sub,\n@@ -299,7 +294,17 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             leading_ellipsis,\n         );\n \n-        err\n+        let diag = TraitPlaceholderMismatch {\n+            span,\n+            satisfy_span,\n+            where_span,\n+            dup_span,\n+            def_id,\n+            trait_def_id: self.tcx().def_path_str(trait_def_id),\n+            actual_impl_expl_notes,\n+        };\n+\n+        self.tcx().sess.create_err(diag)\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases\n@@ -309,7 +314,6 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// due to the number of combinations we have to deal with.\n     fn explain_actual_impl_that_was_found(\n         &self,\n-        err: &mut Diagnostic,\n         sub_placeholder: Option<Region<'tcx>>,\n         sup_placeholder: Option<Region<'tcx>>,\n         has_sub: Option<usize>,\n@@ -321,7 +325,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n         leading_ellipsis: bool,\n-    ) {\n+    ) -> Vec<ActualImplExplNotes> {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n         struct Highlighted<'tcx, T> {\n@@ -380,120 +384,107 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n         expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n         expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n-        err.note(&{\n-            let passive_voice = match (has_sub, has_sup) {\n-                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n-                (None, None) => {\n-                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n-                    match expected_has_vid {\n-                        Some(_) => true,\n-                        None => any_self_ty_has_vid,\n-                    }\n-                }\n-            };\n \n-            let mut note = if same_self_type {\n-                let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n-                self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-\n-                if self_ty.value.is_closure()\n-                    && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n-                {\n-                    let closure_sig = self_ty.map(|closure| {\n-                        if let ty::Closure(_, substs) = closure.kind() {\n-                            self.tcx().signature_unclosure(\n-                                substs.as_closure().sig(),\n-                                rustc_hir::Unsafety::Normal,\n-                            )\n-                        } else {\n-                            bug!(\"type is not longer closure\");\n-                        }\n-                    });\n-\n-                    format!(\n-                        \"{}closure with signature `{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        closure_sig,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n-                } else {\n-                    format!(\n-                        \"{}`{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        self_ty,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n+        let passive_voice = match (has_sub, has_sup) {\n+            (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+            (None, None) => {\n+                expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                match expected_has_vid {\n+                    Some(_) => true,\n+                    None => any_self_ty_has_vid,\n                 }\n-            } else if passive_voice {\n-                format!(\n-                    \"{}`{}` would have to be implemented for the type `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n+            }\n+        };\n+\n+        let (kind, ty_or_sig, trait_path) = if same_self_type {\n+            let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n+            self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+\n+            if self_ty.value.is_closure()\n+                && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n+            {\n+                let closure_sig = self_ty.map(|closure| {\n+                    if let ty::Closure(_, substs) = closure.kind() {\n+                        self.tcx().signature_unclosure(\n+                            substs.as_closure().sig(),\n+                            rustc_hir::Unsafety::Normal,\n+                        )\n+                    } else {\n+                        bug!(\"type is not longer closure\");\n+                    }\n+                });\n+                (\n+                    \"signature\",\n+                    closure_sig.to_string(),\n+                    expected_trait_ref.map(|tr| tr.print_only_trait_path()).to_string(),\n                 )\n             } else {\n-                format!(\n-                    \"{}`{}` must implement `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n-                    expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                (\n+                    \"other\",\n+                    self_ty.to_string(),\n+                    expected_trait_ref.map(|tr| tr.print_only_trait_path()).to_string(),\n                 )\n-            };\n+            }\n+        } else if passive_voice {\n+            (\n+                \"passive\",\n+                expected_trait_ref.map(|tr| tr.self_ty()).to_string(),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()).to_string(),\n+            )\n+        } else {\n+            (\n+                \"other\",\n+                expected_trait_ref.map(|tr| tr.self_ty()).to_string(),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()).to_string(),\n+            )\n+        };\n \n-            match (has_sub, has_sup) {\n-                (Some(n1), Some(n2)) => {\n-                    let _ = write!(\n-                        note,\n-                        \", for any two lifetimes `'{}` and `'{}`...\",\n-                        std::cmp::min(n1, n2),\n-                        std::cmp::max(n1, n2),\n-                    );\n-                }\n-                (Some(n), _) | (_, Some(n)) => {\n-                    let _ = write!(note, \", for any lifetime `'{}`...\", n,);\n-                }\n-                (None, None) => {\n-                    if let Some(n) = expected_has_vid {\n-                        let _ = write!(note, \", for some specific lifetime `'{}`...\", n,);\n-                    }\n+        let (lt_kind, lifetime_1, lifetime_2) = match (has_sub, has_sup) {\n+            (Some(n1), Some(n2)) => (\"two\", std::cmp::min(n1, n2), std::cmp::max(n1, n2)),\n+            (Some(n), _) | (_, Some(n)) => (\"any\", n, 0),\n+            (None, None) => {\n+                if let Some(n) = expected_has_vid {\n+                    (\"some\", n, 0)\n+                } else {\n+                    (\"nothing\", 0, 0)\n                 }\n             }\n+        };\n \n-            note\n-        });\n+        let note_1 = ActualImplExplNotes::NoteOne {\n+            leading_ellipsis,\n+            kind,\n+            ty_or_sig,\n+            trait_path,\n+            lt_kind,\n+            lifetime_1,\n+            lifetime_2,\n+        };\n \n         let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n         actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-        err.note(&{\n-            let passive_voice = match actual_has_vid {\n-                Some(_) => any_self_ty_has_vid,\n-                None => true,\n-            };\n \n-            let mut note = if same_self_type {\n-                format!(\n-                    \"...but it actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            } else if passive_voice {\n-                format!(\n-                    \"...but `{}` is actually implemented for the type `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                )\n-            } else {\n-                format!(\n-                    \"...but `{}` actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            };\n+        let passive_voice = match actual_has_vid {\n+            Some(_) => any_self_ty_has_vid,\n+            None => true,\n+        };\n \n-            if let Some(n) = actual_has_vid {\n-                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n-            }\n+        let trait_path_2 = actual_trait_ref.map(|tr| tr.print_only_trait_path()).to_string();\n+        let ty = actual_trait_ref.map(|tr| tr.self_ty()).to_string();\n+        let kind_2 = if same_self_type {\n+            \"implements_trait\"\n+        } else if passive_voice {\n+            \"implemented_for_ty\"\n+        } else {\n+            \"ty_implements\"\n+        };\n \n-            note\n-        });\n+        let has_lifetime = actual_has_vid.is_some();\n+        let lifetime = actual_has_vid.unwrap_or_default();\n+\n+        let note_2 =\n+            ActualImplExplNotes::NoteTwo { kind_2, trait_path_2, ty, has_lifetime, lifetime };\n+\n+        vec![note_1, note_2]\n     }\n }"}]}