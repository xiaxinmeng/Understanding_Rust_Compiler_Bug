{"sha": "eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMGNmM2E3MTVjYWQ3ZDBhZDZkMjQwNzQ5OTM1NmFlOWRmZmFhN2Q=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-05T00:22:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-05T00:27:03Z"}, "message": "std: Remove struct ctors", "tree": {"sha": "9e10313302bbba7e39886fb3710944ffc0ec0cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e10313302bbba7e39886fb3710944ffc0ec0cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "html_url": "https://github.com/rust-lang/rust/commit/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268850f67b8e535dca2a8f29c717eafb4bd54e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/268850f67b8e535dca2a8f29c717eafb4bd54e13", "html_url": "https://github.com/rust-lang/rust/commit/268850f67b8e535dca2a8f29c717eafb4bd54e13"}], "stats": {"total": 74, "additions": 64, "deletions": 10}, "files": [{"sha": "d8c32a264341d7c52c0599568ec82c5f946bd9c6", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "patch": "@@ -223,13 +223,18 @@ fn check_poison(is_mutex: bool, failed: bool) {\n #[doc(hidden)]\n struct PoisonOnFail {\n     failed: &mut bool;\n-    new(failed: &mut bool) { self.failed = failed; }\n     drop {\n         /* assert !*self.failed; -- might be false in case of cond.wait() */\n         if task::failing() { *self.failed = true; }\n     }\n }\n \n+fn PoisonOnFail(failed: &r/mut bool) -> PoisonOnFail/&r {\n+    PoisonOnFail {\n+        failed: failed\n+    }\n+}\n+\n /****************************************************************************\n  * R/W lock protected ARC\n  ****************************************************************************/"}, {"sha": "002029acd9424b309550bd4307487aa812637082", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "patch": "@@ -44,7 +44,6 @@ enum CVec<T> {\n \n struct DtorRes {\n   let dtor: Option<fn@()>;\n-  new(dtor: Option<fn@()>) { self.dtor = dtor; }\n   drop {\n     match self.dtor {\n       option::None => (),\n@@ -53,6 +52,12 @@ struct DtorRes {\n   }\n }\n \n+fn DtorRes(dtor: Option<fn@()>) -> DtorRes {\n+    DtorRes {\n+        dtor: dtor\n+    }\n+}\n+\n /*\n  Section: Introduction forms\n  */"}, {"sha": "e1751b1762f61940c2efb3e199ee03f0d264b260", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "patch": "@@ -40,14 +40,19 @@ extern mod rustrt {\n  */\n struct TcpSocket {\n   let socket_data: @TcpSocketData;\n-  new(socket_data: @TcpSocketData) { self.socket_data = socket_data; }\n   drop {\n     unsafe {\n         tear_down_socket_data(self.socket_data)\n     }\n   }\n }\n \n+fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n+    TcpSocket {\n+        socket_data: socket_data\n+    }\n+}\n+\n /**\n  * A buffered wrapper for `net::tcp::tcp_socket`\n  *\n@@ -56,7 +61,12 @@ struct TcpSocket {\n  */\n struct TcpSocketBuf {\n   let data: @TcpBufferedSocketData;\n-  new(data: @TcpBufferedSocketData) { self.data = data; }\n+}\n+\n+fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n+    TcpSocketBuf {\n+        data: data\n+    }\n }\n \n /// Contains raw, string-based, error information returned from libuv"}, {"sha": "2149d179b97201cdb2fe386bb3716dba92bda694", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=eb0cf3a715cad7d0ad6d2407499356ae9dffaa7d", "patch": "@@ -154,16 +154,28 @@ impl &Sem<~[mut Waitqueue]> {\n #[doc(hidden)]\n struct SemRelease {\n     sem: &Sem<()>;\n-    new(sem: &Sem<()>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n+\n+fn SemRelease(sem: &r/Sem<()>) -> SemRelease/&r {\n+    SemRelease {\n+        sem: sem\n+    }\n+}\n+\n #[doc(hidden)]\n struct SemAndSignalRelease {\n     sem: &Sem<~[mut Waitqueue]>;\n-    new(sem: &Sem<~[mut Waitqueue]>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n \n+fn SemAndSignalRelease(sem: &r/Sem<~[mut Waitqueue]>)\n+    -> SemAndSignalRelease/&r {\n+    SemAndSignalRelease {\n+        sem: sem\n+    }\n+}\n+\n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n struct Condvar { priv sem: &Sem<~[mut Waitqueue]>; drop { } }\n \n@@ -234,14 +246,21 @@ impl &Condvar {\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct SemAndSignalReacquire {\n             sem: &Sem<~[mut Waitqueue]>;\n-            new(sem: &Sem<~[mut Waitqueue]>) { self.sem = sem; }\n             drop unsafe {\n                 // Needs to succeed, instead of itself dying.\n                 do task::unkillable {\n                     self.sem.acquire();\n                 }\n             }\n         }\n+\n+        fn SemAndSignalReacquire(sem: &r/Sem<~[mut Waitqueue]>)\n+            -> SemAndSignalReacquire/&r {\n+            SemAndSignalReacquire {\n+                sem: sem\n+            }\n+        }\n+        \n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n@@ -567,7 +586,6 @@ impl &RWlock {\n #[doc(hidden)]\n struct RWlockReleaseRead {\n     lock: &RWlock;\n-    new(lock: &RWlock) { self.lock = lock; }\n     drop unsafe {\n         do task::unkillable {\n             let mut last_reader = false;\n@@ -587,11 +605,16 @@ struct RWlockReleaseRead {\n     }\n }\n \n+fn RWlockReleaseRead(lock: &r/RWlock) -> RWlockReleaseRead/&r {\n+    RWlockReleaseRead {\n+        lock: lock\n+    }\n+}\n+\n // FIXME(#3136) should go inside of downgrade()\n #[doc(hidden)]\n struct RWlockReleaseDowngrade {\n     lock: &RWlock;\n-    new(lock: &RWlock) { self.lock = lock; }\n     drop unsafe {\n         do task::unkillable {\n             let mut writer_or_last_reader = false;\n@@ -618,6 +641,12 @@ struct RWlockReleaseDowngrade {\n     }\n }\n \n+fn RWlockReleaseDowngrade(lock: &r/RWlock) -> RWlockReleaseDowngrade/&r {\n+    RWlockReleaseDowngrade {\n+        lock: lock\n+    }\n+}\n+\n /// The \"write permission\" token used for rwlock.write_downgrade().\n struct RWlockWriteMode { /* priv */ lock: &RWlock; drop { } }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n@@ -929,9 +958,14 @@ mod tests {\n         }\n         struct SendOnFailure {\n             c: pipes::Chan<()>;\n-            new(+c: pipes::Chan<()>) { self.c = c; }\n             drop { self.c.send(()); }\n         }\n+\n+        fn SendOnFailure(+c: pipes::Chan<()>) -> SendOnFailure {\n+            SendOnFailure {\n+                c: c\n+            }\n+        }\n     }\n     #[test]\n     fn test_mutex_cond_signal_on_0() {"}]}