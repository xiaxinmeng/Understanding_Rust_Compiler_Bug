{"sha": "8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZThiYzI4MDhiZDNiNWUxMjViNzJhNDRiZmRjZDI0MzUzZTUyMTE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-05T22:06:02Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-05T22:50:47Z"}, "message": "Fix various issues with making items reachable through macros\n\n* Allow items to be accessible through private modules and fields when a\n  macro can access them.\n* Don't mark type-private items as reachable.\n* Never make items exported/public via macros", "tree": {"sha": "a2802c3ef12c0fb81e3a018e251ab768048d8fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2802c3ef12c0fb81e3a018e251ab768048d8fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "html_url": "https://github.com/rust-lang/rust/commit/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7270712cb446aad0817040bbca73a8d024f67b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7270712cb446aad0817040bbca73a8d024f67b0", "html_url": "https://github.com/rust-lang/rust/commit/d7270712cb446aad0817040bbca73a8d024f67b0"}], "stats": {"total": 307, "additions": 276, "deletions": 31}, "files": [{"sha": "330370e3803dd5407672776c0d86d83bfe85330f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 159, "deletions": 31, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -229,6 +229,13 @@ fn def_id_visibility<'tcx>(\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                Node::MacroDef(macro_def) => {\n+                    if attr::contains_name(&macro_def.attrs, sym::macro_export) {\n+                        return (ty::Visibility::Public, macro_def.span, \"public\");\n+                    } else {\n+                        &macro_def.vis\n+                    }\n+                },\n                 Node::TraitItem(..) | Node::Variant(..) => {\n                     return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id));\n                 }\n@@ -433,11 +440,24 @@ impl VisibilityLike for Option<AccessLevel> {\n struct EmbargoVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    // Accessibility levels for reachable nodes.\n+    /// Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n-    // Previous accessibility level; `None` means unreachable.\n+    /// A set of pairs corresponding to modules, where the first module is\n+    /// reachable via a macro that's defined in the second module. This cannot\n+    /// be represented as reachable because it can't handle the following case:\n+    ///\n+    /// pub mod n {                         // Should be `Public`\n+    ///     pub(crate) mod p {              // Should *not* be accessible\n+    ///         pub fn f() -> i32 { 12 }    // Must be `Reachable`\n+    ///     }\n+    /// }\n+    /// pub macro m() {\n+    ///     n::p::f()\n+    /// }\n+    macro_reachable: FxHashSet<(hir::HirId, DefId)>,\n+    /// Previous accessibility level; `None` means unreachable.\n     prev_level: Option<AccessLevel>,\n-    // Has something changed in the level map?\n+    /// Has something changed in the level map?\n     changed: bool,\n }\n \n@@ -452,7 +472,7 @@ impl EmbargoVisitor<'tcx> {\n         self.access_levels.map.get(&id).cloned()\n     }\n \n-    // Updates node level and returns the updated level.\n+    /// Updates node level and returns the updated level.\n     fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n         // Accessibility levels can only grow.\n@@ -477,6 +497,127 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n+    /// Updates the item as being reachable through a macro defined in the given\n+    /// module. Returns `true` if the level has changed.\n+    fn update_macro_reachable(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) -> bool {\n+        if self.macro_reachable.insert((reachable_mod, defining_mod)) {\n+            self.update_macro_reachable_mod(reachable_mod, defining_mod);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn update_macro_reachable_mod(\n+        &mut self,\n+        reachable_mod: hir::HirId,\n+        defining_mod: DefId,\n+    ) {\n+        let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n+        let module = self.tcx.hir().get_module(module_def_id).0;\n+        for item_id in &module.item_ids {\n+            let hir_id = item_id.id;\n+            let item_def_id = self.tcx.hir().local_def_id(hir_id);\n+            if let Some(def_kind) = self.tcx.def_kind(item_def_id) {\n+                let item = self.tcx.hir().expect_item(hir_id);\n+                let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n+                self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n+            }\n+        }\n+\n+        if let Some(exports) = self.tcx.module_exports(module_def_id) {\n+            for export in exports {\n+                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n+                    if let Res::Def(def_kind, def_id) = export.res {\n+                        let vis = def_id_visibility(self.tcx, def_id).0;\n+                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            self.update_macro_reachable_def(\n+                                hir_id,\n+                                def_kind,\n+                                vis,\n+                                defining_mod,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn update_macro_reachable_def(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        def_kind: DefKind,\n+        vis: ty::Visibility,\n+        module: DefId,\n+    ) {\n+        let level = Some(AccessLevel::Reachable);\n+        if let ty::Visibility::Public = vis {\n+            self.update(hir_id, level);\n+        }\n+        match def_kind {\n+            // No type privacy, so can be directly marked as reachable.\n+            DefKind::Const\n+            | DefKind::Macro(_)\n+            | DefKind::Static\n+            | DefKind::TraitAlias\n+            | DefKind::TyAlias => {\n+                if vis.is_accessible_from(module, self.tcx) {\n+                    self.update(hir_id, level);\n+                }\n+            },\n+\n+            // We can't use a module name as the final segment of a path, except\n+            // in use statements. Since re-export checking doesn't consider\n+            // hygiene these don't need to be marked reachable. The contents of\n+            // the module, however may be reachable.\n+            DefKind::Mod => {\n+                if vis.is_accessible_from(module, self.tcx) {\n+                    self.update_macro_reachable(hir_id, module);\n+                }\n+            }\n+\n+            DefKind::Struct | DefKind::Union => {\n+                // While structs and unions have type privacy, their fields do\n+                // not.\n+                if let ty::Visibility::Public = vis {\n+                    let item = self.tcx.hir().expect_item(hir_id);\n+                    if let hir::ItemKind::Struct(ref struct_def, _)\n+                        | hir::ItemKind::Union(ref struct_def, _) = item.node\n+                    {\n+                        for field in struct_def.fields() {\n+                            let field_vis = ty::Visibility::from_hir(\n+                                &field.vis,\n+                                field.hir_id,\n+                                self.tcx,\n+                            );\n+                            if field_vis.is_accessible_from(module, self.tcx) {\n+                                self.reach(field.hir_id, level).ty();\n+                            }\n+                        }\n+                    } else {\n+                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n+                    }\n+                }\n+            }\n+\n+            // These have type privacy, so are not reachable unless they're\n+            // public\n+            DefKind::AssocConst\n+            | DefKind::AssocTy\n+            | DefKind::AssocOpaqueTy\n+            | DefKind::ConstParam\n+            | DefKind::Ctor(_, _)\n+            | DefKind::Enum\n+            | DefKind::ForeignTy\n+            | DefKind::Fn\n+            | DefKind::OpaqueTy\n+            | DefKind::Method\n+            | DefKind::Trait\n+            | DefKind::TyParam\n+            | DefKind::Variant => (),\n+        }\n+    }\n \n     /// Given the path segments of a `ItemKind::Use`, then we need\n     /// to update the visibility of the intermediate use so that it isn't linted\n@@ -746,40 +887,21 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             return\n         }\n \n-        let module_did = ty::DefIdTree::parent(\n+        let macro_module_def_id = ty::DefIdTree::parent(\n             self.tcx,\n             self.tcx.hir().local_def_id(md.hir_id)\n         ).unwrap();\n-        let mut module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n+        let mut module_id = self.tcx.hir().as_local_hir_id(macro_module_def_id).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let level = self.update(md.hir_id, level);\n-        if level.is_none() {\n+        let new_level = self.update(md.hir_id, level);\n+        if new_level.is_none() {\n             return\n         }\n \n         loop {\n-            let module = if module_id == hir::CRATE_HIR_ID {\n-                &self.tcx.hir().krate().module\n-            } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item(module_id).node {\n-                module\n-            } else {\n-                unreachable!()\n-            };\n-            for id in &module.item_ids {\n-                self.update(id.id, level);\n-            }\n-            let def_id = self.tcx.hir().local_def_id(module_id);\n-            if let Some(exports) = self.tcx.module_exports(def_id) {\n-                for export in exports.iter() {\n-                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.res.def_id()) {\n-                        self.update(hir_id, level);\n-                    }\n-                }\n-            }\n-\n-            if module_id == hir::CRATE_HIR_ID {\n-                break\n+            let changed_reachability = self.update_macro_reachable(module_id, macro_module_def_id);\n+            if changed_reachability || module_id == hir::CRATE_HIR_ID {\n+                break;\n             }\n             module_id = self.tcx.hir().get_parent_node(module_id);\n         }\n@@ -826,7 +948,12 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n-            self.ev.update(hir_id, self.access_level);\n+            if let ((ty::Visibility::Public, ..), _)\n+                | (_, Some(AccessLevel::ReachableFromImplTrait))\n+                = (def_id_visibility(self.tcx(), def_id), self.access_level)\n+            {\n+                self.ev.update(hir_id, self.access_level);\n+            }\n         }\n         false\n     }\n@@ -1860,6 +1987,7 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, krate: CrateNum) -> &AccessLevels {\n     let mut visitor = EmbargoVisitor {\n         tcx,\n         access_levels: Default::default(),\n+        macro_reachable: Default::default(),\n         prev_level: Some(AccessLevel::Public),\n         changed: false,\n     };"}, {"sha": "30ba70bdfeb66bc3699c0d74edbe73003adb1f05", "filename": "src/test/ui/definition-reachable/auxiliary/field-method-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,23 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub struct B(pub(crate) p::C);\n+    impl B {\n+        pub fn new() -> Self {\n+            B(p::C)\n+        }\n+    }\n+    mod p {\n+        pub struct C;\n+\n+        impl C {\n+            pub fn foo(&self) -> i32 {\n+                33\n+            }\n+        }\n+    }\n+}\n+\n+pub macro m() {\n+    n::B::new().0.foo()\n+}"}, {"sha": "a39e8c986c3911df50ec764a1c49a886f7d38b61", "filename": "src/test/ui/definition-reachable/auxiliary/nested-fn-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub(crate) mod p {\n+        pub fn f() -> i32 { 12 }\n+    }\n+}\n+\n+pub macro m() {\n+    n::p::f()\n+}"}, {"sha": "4f283d9c19c04f55b7533321c0aff385afa04fb4", "filename": "src/test/ui/definition-reachable/auxiliary/private-use-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub static S: i32 = 57;\n+}\n+\n+use n::S;\n+\n+pub macro m() {\n+    S\n+}"}, {"sha": "60e895a2f9a0742db232c47f95de091562c1a320", "filename": "src/test/ui/definition-reachable/field-method.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,11 @@\n+// Check that functions accessible through a field visible to a macro are\n+// considered reachable\n+\n+// aux-build:nested-fn-macro.rs\n+// run-pass\n+\n+extern crate nested_fn_macro;\n+\n+fn main() {\n+    assert_eq!(nested_fn_macro::m!(), 12);\n+}"}, {"sha": "b596ba8936a4391142680f3aceccd3970f9819ee", "filename": "src/test/ui/definition-reachable/nested-fn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,11 @@\n+// Check that functions visible to macros through paths with >2 segements are\n+// considered reachable\n+\n+// aux-build:field-method-macro.rs\n+// run-pass\n+\n+extern crate field_method_macro;\n+\n+fn main() {\n+    assert_eq!(field_method_macro::m!(), 33);\n+}"}, {"sha": "a601dabcb0b3fdfe9643ea4b358ff68aa791340e", "filename": "src/test/ui/definition-reachable/private-non-types.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,21 @@\n+// Check that we don't require stability annotations for private modules,\n+// imports and fields that are accessible to opaque macros.\n+\n+// check-pass\n+\n+#![feature(decl_macro, staged_api)]\n+#![stable(feature = \"test\", since = \"1.0.0\")]\n+\n+extern crate std as local_std;\n+use local_std::marker::Copy as LocalCopy;\n+mod private_mod {\n+    #[stable(feature = \"test\", since = \"1.0.0\")]\n+    pub struct A {\n+        pub(crate) f: i32,\n+    }\n+}\n+\n+#[stable(feature = \"test\", since = \"1.0.0\")]\n+pub macro m() {}\n+\n+fn main() {}"}, {"sha": "02c1224f4e142e63ce23836a49e6c3eb382eb8de", "filename": "src/test/ui/definition-reachable/private-types.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,19 @@\n+// Check that type privacy is taken into account when considering reachability\n+\n+// check-pass\n+\n+#![feature(decl_macro, staged_api)]\n+#![stable(feature = \"test\", since = \"1.0.0\")]\n+\n+// Type privacy should prevent use of these in other crates, so we shouldn't\n+// need a stability annotation.\n+fn private_function() {}\n+struct PrivateStruct { f: () }\n+enum PrivateEnum { V }\n+union PrivateUnion { g: () }\n+trait PrivateTrait {}\n+\n+#[stable(feature = \"test\", since = \"1.0.0\")]\n+pub macro m() {}\n+\n+fn main() {}"}, {"sha": "02cff0475e586447cd657de642cc20db47a1abbd", "filename": "src/test/ui/definition-reachable/private-use.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae8bc2808bd3b5e125b72a44bfdcd24353e5211/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs?ref=8ae8bc2808bd3b5e125b72a44bfdcd24353e5211", "patch": "@@ -0,0 +1,10 @@\n+// Check that private use statements can be used by\n+\n+// run-pass\n+// aux-build:private-use-macro.rs\n+\n+extern crate private_use_macro;\n+\n+fn main() {\n+    assert_eq!(private_use_macro::m!(), 57);\n+}"}]}