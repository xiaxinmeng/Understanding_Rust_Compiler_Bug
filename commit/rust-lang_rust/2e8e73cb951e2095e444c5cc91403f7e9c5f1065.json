{"sha": "2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOGU3M2NiOTUxZTIwOTVlNDQ0YzVjYzkxNDAzZjdlOWM1ZjEwNjU=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-13T09:44:29Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-14T11:57:46Z"}, "message": "Add in styled_buffer.rs and remove some unused code", "tree": {"sha": "697b3ee295258fa7c096b64e53021d6f1d157577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/697b3ee295258fa7c096b64e53021d6f1d157577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "html_url": "https://github.com/rust-lang/rust/commit/2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/comments", "author": null, "committer": null, "parents": [{"sha": "012ff15c94ff44f45c07641bdd0957da6a625591", "url": "https://api.github.com/repos/rust-lang/rust/commits/012ff15c94ff44f45c07641bdd0957da6a625591", "html_url": "https://github.com/rust-lang/rust/commit/012ff15c94ff44f45c07641bdd0957da6a625591"}], "stats": {"total": 214, "additions": 158, "deletions": 56}, "files": [{"sha": "96ecad629f543f24d7a7e586a351e7163375b4c1", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "patch": "@@ -94,7 +94,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{self, Pos, Span};\n-use errors::{DiagnosticBuilder, check_old_skool};\n+use errors::{DiagnosticBuilder, check_old_school};\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -485,7 +485,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        \"{}\",\n                                        trace.origin);\n \n-        if !is_simple_error || check_old_skool() {\n+        if !is_simple_error || check_old_school() {\n             err.note_expected_found(&\"type\", &expected, &found);\n         }\n "}, {"sha": "161f2f7bb1c306249b4919ef81fe6363da4c2fee", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 21, "deletions": 52, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "patch": "@@ -13,7 +13,7 @@ use self::Destination::*;\n use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo, CharPos};\n use registry;\n \n-use check_old_skool;\n+use check_old_school;\n use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n use snippet::{StyledString, Style, FormatMode, Annotation, Line};\n@@ -36,7 +36,7 @@ impl Emitter for EmitterWriter {\n         let old_school = match self.format_mode {\n             FormatMode::NewErrorFormat => false,\n             FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n+            FormatMode::EnvironmentSelected => check_old_school()\n         };\n \n         if old_school {\n@@ -243,59 +243,32 @@ impl EmitterWriter {\n         // For this reason, we group the lines into \"highlight lines\"\n         // and \"annotations lines\", where the highlight lines have the `~`.\n \n-        // let mut highlight_line = Self::whitespace(&source_string);\n-        let old_school = check_old_skool();\n-\n         // Sort the annotations by (start, end col)\n         let mut annotations = line.annotations.clone();\n         annotations.sort();\n \n         // Next, create the highlight line.\n         for annotation in &annotations {\n-            if old_school {\n-                for p in annotation.start_col..annotation.end_col {\n-                    if p == annotation.start_col {\n-                        buffer.putc(line_offset + 1,\n-                                    width_offset + p,\n-                                    '^',\n-                                    if annotation.is_primary {\n-                                        Style::UnderlinePrimary\n-                                    } else {\n-                                        Style::OldSchoolNote\n-                                    });\n-                    } else {\n-                        buffer.putc(line_offset + 1,\n-                                    width_offset + p,\n-                                    '~',\n-                                    if annotation.is_primary {\n-                                        Style::UnderlinePrimary\n-                                    } else {\n-                                        Style::OldSchoolNote\n-                                    });\n+            for p in annotation.start_col..annotation.end_col {\n+                if annotation.is_primary {\n+                    buffer.putc(line_offset + 1,\n+                                width_offset + p,\n+                                '^',\n+                                Style::UnderlinePrimary);\n+                    if !annotation.is_minimized {\n+                        buffer.set_style(line_offset,\n+                                            width_offset + p,\n+                                            Style::UnderlinePrimary);\n                     }\n-                }\n-            } else {\n-                for p in annotation.start_col..annotation.end_col {\n-                    if annotation.is_primary {\n-                        buffer.putc(line_offset + 1,\n-                                    width_offset + p,\n-                                    '^',\n-                                    Style::UnderlinePrimary);\n-                        if !annotation.is_minimized {\n-                            buffer.set_style(line_offset,\n-                                                width_offset + p,\n-                                                Style::UnderlinePrimary);\n-                        }\n-                    } else {\n-                        buffer.putc(line_offset + 1,\n-                                    width_offset + p,\n-                                    '-',\n-                                    Style::UnderlineSecondary);\n-                        if !annotation.is_minimized {\n-                            buffer.set_style(line_offset,\n-                                                width_offset + p,\n-                                                Style::UnderlineSecondary);\n-                        }\n+                } else {\n+                    buffer.putc(line_offset + 1,\n+                                width_offset + p,\n+                                '-',\n+                                Style::UnderlineSecondary);\n+                    if !annotation.is_minimized {\n+                        buffer.set_style(line_offset,\n+                                            width_offset + p,\n+                                            Style::UnderlineSecondary);\n                     }\n                 }\n             }\n@@ -311,10 +284,6 @@ impl EmitterWriter {\n         if labeled_annotations.is_empty() {\n             return;\n         }\n-        if old_school {\n-            return;\n-        }\n-\n         // Now add the text labels. We try, when possible, to stick the rightmost\n         // annotation at the end of the highlight line:\n         //"}, {"sha": "6a48f65714cc50d95e6463d337ec64af32233dd1", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "patch": "@@ -756,13 +756,13 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n ///\n /// FIXME(#33240)\n #[cfg(not(test))]\n-pub fn check_old_skool() -> bool {\n+pub fn check_old_school() -> bool {\n     use std::env;\n     env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n }\n \n /// For unit tests, use the new format.\n #[cfg(test)]\n-pub fn check_old_skool() -> bool {\n+pub fn check_old_school() -> bool {\n     false\n }"}, {"sha": "238caf93b83f0e5ffac1c12ebdfb9379163ac009", "filename": "src/librustc_errors/styled_buffer.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc_errors%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8e73cb951e2095e444c5cc91403f7e9c5f1065/src%2Flibrustc_errors%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fstyled_buffer.rs?ref=2e8e73cb951e2095e444c5cc91403f7e9c5f1065", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for creating styled buffers\n+\n+use snippet::{Style, StyledString};\n+\n+#[derive(Debug)]\n+pub struct StyledBuffer {\n+    text: Vec<Vec<char>>,\n+    styles: Vec<Vec<Style>>,\n+}\n+\n+impl StyledBuffer {\n+    pub fn new() -> StyledBuffer {\n+        StyledBuffer {\n+            text: vec![],\n+            styles: vec![],\n+        }\n+    }\n+\n+    pub fn render(&self) -> Vec<Vec<StyledString>> {\n+        let mut output: Vec<Vec<StyledString>> = vec![];\n+        let mut styled_vec: Vec<StyledString> = vec![];\n+\n+        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+            let mut current_style = Style::NoStyle;\n+            let mut current_text = String::new();\n+\n+            for (&c, &s) in row.iter().zip(row_style) {\n+                if s != current_style {\n+                    if !current_text.is_empty() {\n+                        styled_vec.push(StyledString {\n+                            text: current_text,\n+                            style: current_style,\n+                        });\n+                    }\n+                    current_style = s;\n+                    current_text = String::new();\n+                }\n+                current_text.push(c);\n+            }\n+            if !current_text.is_empty() {\n+                styled_vec.push(StyledString {\n+                    text: current_text,\n+                    style: current_style,\n+                });\n+            }\n+\n+            // We're done with the row, push and keep going\n+            output.push(styled_vec);\n+\n+            styled_vec = vec![];\n+        }\n+\n+        output\n+    }\n+\n+    fn ensure_lines(&mut self, line: usize) {\n+        while line >= self.text.len() {\n+            self.text.push(vec![]);\n+            self.styles.push(vec![]);\n+        }\n+    }\n+\n+    pub fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n+        self.ensure_lines(line);\n+        if col < self.text[line].len() {\n+            self.text[line][col] = chr;\n+            self.styles[line][col] = style;\n+        } else {\n+            let mut i = self.text[line].len();\n+            while i < col {\n+                let s = match self.text[0].get(i) {\n+                    Some(&'\\t') => '\\t',\n+                    _ => ' ',\n+                };\n+                self.text[line].push(s);\n+                self.styles[line].push(Style::NoStyle);\n+                i += 1;\n+            }\n+            self.text[line].push(chr);\n+            self.styles[line].push(style);\n+        }\n+    }\n+\n+    pub fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n+        let mut n = col;\n+        for c in string.chars() {\n+            self.putc(line, n, c, style);\n+            n += 1;\n+        }\n+    }\n+\n+    pub fn set_style(&mut self, line: usize, col: usize, style: Style) {\n+        if self.styles.len() > line && self.styles[line].len() > col {\n+            self.styles[line][col] = style;\n+        }\n+    }\n+\n+    pub fn prepend(&mut self, line: usize, string: &str, style: Style) {\n+        self.ensure_lines(line);\n+        let string_len = string.len();\n+\n+        // Push the old content over to make room for new content\n+        for _ in 0..string_len {\n+            self.styles[line].insert(0, Style::NoStyle);\n+            self.text[line].insert(0, ' ');\n+        }\n+\n+        self.puts(line, 0, string, style);\n+    }\n+\n+    pub fn append(&mut self, line: usize, string: &str, style: Style) {\n+        if line >= self.text.len() {\n+            self.puts(line, 0, string, style);\n+        } else {\n+            let col = self.text[line].len();\n+            self.puts(line, col, string, style);\n+        }\n+    }\n+\n+    pub fn num_lines(&self) -> usize {\n+        self.text.len()\n+    }\n+}"}]}