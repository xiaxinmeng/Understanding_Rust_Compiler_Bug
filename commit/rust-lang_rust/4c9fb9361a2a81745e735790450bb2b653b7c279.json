{"sha": "4c9fb9361a2a81745e735790450bb2b653b7c279", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOWZiOTM2MWEyYTgxNzQ1ZTczNTc5MDQ1MGJiMmI2NTNiN2MyNzk=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2018-12-06T13:02:21Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2019-04-03T16:22:18Z"}, "message": "Uplift match_def_path from Clippy", "tree": {"sha": "ca1af2df65bbe80d8dffa00292706b10d0ab12e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca1af2df65bbe80d8dffa00292706b10d0ab12e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9fb9361a2a81745e735790450bb2b653b7c279", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAlyk3boACgkQaTCGhp1Q\nZjdLJBAAmwjX9gp45vUSZTIxEYUT5Dx/F80/GFaeRKH2qsGot9Gl9OP0fdLKpp30\nuLOAnRvA4wlR8dyPpSmpFrRX7PHXQY5oIIc1ugTYzG+eP6l96GNgUOl1fUi/o4ED\n0M04qNbJRLaZ/CdMLrpdnT/usA6ojX+RUCWf6pAaLp7EParuq1sbbq/TDarc6zhk\nKw3AeqtUIxn0SqdIzqfatieG/qHOVs3ct03BxErH+DISbHZMGC4XU1TLt0ipZKqj\nklN4BRaSGexlyAIO/3fQZG5Woi0mdFYdcRet9Xx08xiYhLUK4sHO1X1dVVzNdYFW\nkfapegXgKkxqcnjrRLKdC7SCMWh5kPmcKIqwna0+T0/DjSp+FyVdDbUC1xbnytf3\nsnY//TY+hfR5tLQAiEmDGzXeIJFcNXXRWZtEijanuM6+ZdIXOtdIfUdBkGauB+EZ\nz/u+ejFWGYEXofR/IImNJdTaLKWFKrJVMfGKu9Fot/4rlYoFf48LRXmnfWM++GhT\nS5ThO/kXVMwK+KP93DCyfIKNqTDII+HstlHU5qwlDbqwXvgVE2E5KNkgskKAFdKM\n/pga4KvMkMMi9u/lWYmo32rlQJgizLzcMa+U5CCzXybMWAX3PYhgOVZ7+0NmZnRu\nbAKN/2bmdeuw9vb6GbyS7y3OOyg4IhL/l58Ryq5ClLsJzfO6cNo=\n=rPgV\n-----END PGP SIGNATURE-----", "payload": "tree ca1af2df65bbe80d8dffa00292706b10d0ab12e2\nparent 5c0656789dfde752ea7af001e3d04a2a916685cf\nauthor flip1995 <hello@philkrones.com> 1544101341 +0100\ncommitter flip1995 <hello@philkrones.com> 1554308538 +0200\n\nUplift match_def_path from Clippy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9fb9361a2a81745e735790450bb2b653b7c279", "html_url": "https://github.com/rust-lang/rust/commit/4c9fb9361a2a81745e735790450bb2b653b7c279", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9fb9361a2a81745e735790450bb2b653b7c279/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c0656789dfde752ea7af001e3d04a2a916685cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0656789dfde752ea7af001e3d04a2a916685cf", "html_url": "https://github.com/rust-lang/rust/commit/5c0656789dfde752ea7af001e3d04a2a916685cf"}], "stats": {"total": 107, "additions": 104, "deletions": 3}, "files": [{"sha": "abfa96841d9f6ce1fe16eb03001a06cc6f2336ee", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 104, "deletions": 3, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4c9fb9361a2a81745e735790450bb2b653b7c279/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9fb9361a2a81745e735790450bb2b653b7c279/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=4c9fb9361a2a81745e735790450bb2b653b7c279", "patch": "@@ -1,10 +1,10 @@\n-use crate::ty;\n-use crate::ty::TyCtxt;\n-use crate::hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n+use crate::ty::{self, print::Printer, subst::Kind, Ty, TyCtxt};\n+use crate::hir::map::definitions::{DisambiguatedDefPathData, FIRST_FREE_HIGH_DEF_INDEX};\n use rustc_data_structures::indexed_vec::Idx;\n use serialize;\n use std::fmt;\n use std::u32;\n+use syntax::symbol::{LocalInternedString, Symbol};\n \n newtype_index! {\n     pub struct CrateId {\n@@ -252,6 +252,107 @@ impl DefId {\n             format!(\"module `{}`\", tcx.def_path_str(*self))\n         }\n     }\n+\n+    /// Check if a `DefId`'s path matches the given absolute type path usage.\n+    // Uplifted from rust-lang/rust-clippy\n+    pub fn match_path<'a, 'tcx>(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &[&str]) -> bool {\n+        pub struct AbsolutePathPrinter<'a, 'tcx> {\n+            pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        }\n+\n+        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+            type Error = !;\n+\n+            type Path = Vec<LocalInternedString>;\n+            type Region = ();\n+            type Type = ();\n+            type DynExistential = ();\n+\n+            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+                self.tcx\n+            }\n+\n+            fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_dyn_existential(\n+                self,\n+                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+                ) -> Result<Self::DynExistential, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n+                Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n+            }\n+\n+            fn path_qualified(\n+                self,\n+                self_ty: Ty<'tcx>,\n+                trait_ref: Option<ty::TraitRef<'tcx>>,\n+                ) -> Result<Self::Path, Self::Error> {\n+                if trait_ref.is_none() {\n+                    if let ty::Adt(def, substs) = self_ty.sty {\n+                        return self.print_def_path(def.did, substs);\n+                    }\n+                }\n+\n+                // This shouldn't ever be needed, but just in case:\n+                Ok(vec![match trait_ref {\n+                    Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n+                    None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n+                }])\n+            }\n+\n+            fn path_append_impl(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _disambiguated_data: &DisambiguatedDefPathData,\n+                self_ty: Ty<'tcx>,\n+                trait_ref: Option<ty::TraitRef<'tcx>>,\n+                ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+\n+                // This shouldn't ever be needed, but just in case:\n+                path.push(match trait_ref {\n+                    Some(trait_ref) => {\n+                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str()\n+                    },\n+                    None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n+                });\n+\n+                Ok(path)\n+            }\n+\n+            fn path_append(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                disambiguated_data: &DisambiguatedDefPathData,\n+                ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+                path.push(disambiguated_data.data.as_interned_str().as_str());\n+                Ok(path)\n+            }\n+\n+            fn path_generic_args(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _args: &[Kind<'tcx>],\n+                ) -> Result<Self::Path, Self::Error> {\n+                print_prefix(self)\n+            }\n+        }\n+\n+        let names = AbsolutePathPrinter { tcx }.print_def_path(self, &[]).unwrap();\n+\n+        names.len() == path.len()\n+            && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n+    }\n }\n \n impl serialize::UseSpecializedEncodable for DefId {}"}]}