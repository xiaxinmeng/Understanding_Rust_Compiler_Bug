{"sha": "00c8cab20b057ebd75166936fffd649d29a9fd29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYzhjYWIyMGIwNTdlYmQ3NTE2NjkzNmZmZmQ2NDlkMjlhOWZkMjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-03T15:32:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-03T15:32:51Z"}, "message": "Merge #9765\n\n9765: internal: Introduce TypeInfo r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "dc847559d97c1900ab98a011f9eb9c99be6f1fc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc847559d97c1900ab98a011f9eb9c99be6f1fc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00c8cab20b057ebd75166936fffd649d29a9fd29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhCWGjCRBK7hj4Ov3rIwAAXyYIAErQXgtxdRhp/wkGbfVoy1hH\nf0r565jfbChoW4PkNR0EPLIwdHd0S80QG5TvI9cTOwwq7b7lvRW5imYUDw/Anahz\ncC8p15uLwnfR7qGI8jQRVfz8wfzaBWfk0kVVc3xsDt1sZx4ygpdkESEEH/w5N5G4\nbmXgEaWvwq3jntKVNV/SrEDWIdH6f46OM++ZmmdfTx/TaflhDJnTFUTFRAA9LdS2\ntmK6PrJE23gCBrQjkX33oNCp8hvc9MWSZmatES8g1V1WlzmCkpAFWjuxaHunw7Xh\n/M2lEuu7j5idhBR6qTPGBbE4BclU1JOy6NDdJeh/QP0cDvSLkY5xxYsxHqXbcjw=\n=+b3b\n-----END PGP SIGNATURE-----\n", "payload": "tree dc847559d97c1900ab98a011f9eb9c99be6f1fc5\nparent 4b0c97668c8b5feddcb3532677c567b838c5613c\nparent b96f1adf5cbfaaa0e0538bae63b20caa09484635\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628004771 +0000\ncommitter GitHub <noreply@github.com> 1628004771 +0000\n\nMerge #9765\n\n9765: internal: Introduce TypeInfo r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00c8cab20b057ebd75166936fffd649d29a9fd29", "html_url": "https://github.com/rust-lang/rust/commit/00c8cab20b057ebd75166936fffd649d29a9fd29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00c8cab20b057ebd75166936fffd649d29a9fd29/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b0c97668c8b5feddcb3532677c567b838c5613c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0c97668c8b5feddcb3532677c567b838c5613c", "html_url": "https://github.com/rust-lang/rust/commit/4b0c97668c8b5feddcb3532677c567b838c5613c"}, {"sha": "b96f1adf5cbfaaa0e0538bae63b20caa09484635", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96f1adf5cbfaaa0e0538bae63b20caa09484635", "html_url": "https://github.com/rust-lang/rust/commit/b96f1adf5cbfaaa0e0538bae63b20caa09484635"}], "stats": {"total": 276, "additions": 141, "deletions": 135}, "files": [{"sha": "c47988fc4c2620eca90911dacb465f1fd6ca73fc", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -89,7 +89,7 @@ pub use crate::{\n         UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n-    semantics::{PathResolution, Semantics, SemanticsScope},\n+    semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo},\n };\n \n // Be careful with these re-exports."}, {"sha": "c41654fc2e741a8198465584b27c945284473a79", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -87,6 +87,29 @@ impl PathResolution {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct TypeInfo {\n+    /// The original type of the expression or pattern.\n+    pub original: Type,\n+    /// The adjusted type, if an adjustment happened.\n+    pub adjusted: Option<Type>,\n+}\n+\n+impl TypeInfo {\n+    pub fn original(self) -> Type {\n+        self.original\n+    }\n+\n+    pub fn has_adjustment(&self) -> bool {\n+        self.adjusted.is_some()\n+    }\n+\n+    /// The adjusted type, or the original in case no adjustments occurred.\n+    pub fn adjusted(self) -> Type {\n+        self.adjusted.unwrap_or(self.original)\n+    }\n+}\n+\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n@@ -212,23 +235,14 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_type(ty)\n     }\n \n-    pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n+    pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n         self.imp.type_of_expr(expr)\n     }\n \n-    /// Returns true in case a coercion happened.\n-    pub fn type_of_expr_with_coercion(&self, expr: &ast::Expr) -> Option<(Type, bool)> {\n-        self.imp.type_of_expr_with_coercion(expr)\n-    }\n-\n-    pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n+    pub fn type_of_pat(&self, pat: &ast::Pat) -> Option<TypeInfo> {\n         self.imp.type_of_pat(pat)\n     }\n \n-    pub fn type_of_pat_with_coercion(&self, expr: &ast::Pat) -> Option<(Type, bool)> {\n-        self.imp.type_of_pat_with_coercion(expr)\n-    }\n-\n     pub fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n         self.imp.type_of_self(param)\n     }\n@@ -565,20 +579,16 @@ impl<'db> SemanticsImpl<'db> {\n         Type::new_with_resolver(self.db, &scope.resolver, ty)\n     }\n \n-    fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n-        self.analyze(expr.syntax()).type_of_expr(self.db, expr)\n-    }\n-\n-    fn type_of_expr_with_coercion(&self, expr: &ast::Expr) -> Option<(Type, bool)> {\n-        self.analyze(expr.syntax()).type_of_expr_with_coercion(self.db, expr)\n-    }\n-\n-    fn type_of_pat(&self, pat: &ast::Pat) -> Option<Type> {\n-        self.analyze(pat.syntax()).type_of_pat(self.db, pat)\n+    fn type_of_expr(&self, expr: &ast::Expr) -> Option<TypeInfo> {\n+        self.analyze(expr.syntax())\n+            .type_of_expr(self.db, expr)\n+            .map(|(ty, coerced)| TypeInfo { original: ty, adjusted: coerced })\n     }\n \n-    fn type_of_pat_with_coercion(&self, pat: &ast::Pat) -> Option<(Type, bool)> {\n-        self.analyze(pat.syntax()).type_of_pat_with_coercion(self.db, pat)\n+    fn type_of_pat(&self, pat: &ast::Pat) -> Option<TypeInfo> {\n+        self.analyze(pat.syntax())\n+            .type_of_pat(self.db, pat)\n+            .map(|(ty, coerced)| TypeInfo { original: ty, adjusted: coerced })\n     }\n \n     fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n@@ -757,7 +767,7 @@ impl<'db> SemanticsImpl<'db> {\n                     ast::Expr::FieldExpr(field_expr) => field_expr,\n                     _ => return None,\n                 };\n-                let ty = self.type_of_expr(&field_expr.expr()?)?;\n+                let ty = self.type_of_expr(&field_expr.expr()?)?.original;\n                 if !ty.is_packed(self.db) {\n                     return None;\n                 }\n@@ -784,7 +794,7 @@ impl<'db> SemanticsImpl<'db> {\n                 self.type_of_expr(&expr)\n             })\n             // Binding a reference to a packed type is possibly unsafe.\n-            .map(|ty| ty.is_packed(self.db))\n+            .map(|ty| ty.original.is_packed(self.db))\n             .unwrap_or(false)\n \n         // FIXME This needs layout computation to be correct. It will highlight\n@@ -830,7 +840,7 @@ impl<'db> SemanticsImpl<'db> {\n                 }\n             })\n             // Binding a reference to a packed type is possibly unsafe.\n-            .map(|ty| ty.is_packed(self.db))\n+            .map(|ty| ty.original.is_packed(self.db))\n             .unwrap_or(false)\n     }\n }"}, {"sha": "cb6fd69bc600b9cd2e86a8a2758c276d31a96286", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -116,46 +116,36 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub(crate) fn type_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<Type> {\n-        let expr_id = self.expr_id(db, expr)?;\n-        let ty = self.infer.as_ref()?[expr_id].clone();\n-        Type::new_with_resolver(db, &self.resolver, ty)\n-    }\n-\n-    pub(crate) fn type_of_expr_with_coercion(\n+    pub(crate) fn type_of_expr(\n         &self,\n         db: &dyn HirDatabase,\n         expr: &ast::Expr,\n-    ) -> Option<(Type, bool)> {\n+    ) -> Option<(Type, Option<Type>)> {\n         let expr_id = self.expr_id(db, expr)?;\n         let infer = self.infer.as_ref()?;\n-        let (ty, coerced) = infer\n+        let coerced = infer\n             .expr_adjustments\n             .get(&expr_id)\n-            .and_then(|adjusts| adjusts.last().map(|adjust| (&adjust.target, true)))\n-            .unwrap_or_else(|| (&infer[expr_id], false));\n-        Type::new_with_resolver(db, &self.resolver, ty.clone()).zip(Some(coerced))\n-    }\n-\n-    pub(crate) fn type_of_pat(&self, db: &dyn HirDatabase, pat: &ast::Pat) -> Option<Type> {\n-        let pat_id = self.pat_id(pat)?;\n-        let ty = self.infer.as_ref()?[pat_id].clone();\n-        Type::new_with_resolver(db, &self.resolver, ty)\n+            .and_then(|adjusts| adjusts.last().map(|adjust| adjust.target.clone()));\n+        let ty = infer[expr_id].clone();\n+        let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n+        mk_ty(ty.clone()).zip(Some(coerced.and_then(mk_ty)))\n     }\n \n-    pub(crate) fn type_of_pat_with_coercion(\n+    pub(crate) fn type_of_pat(\n         &self,\n         db: &dyn HirDatabase,\n         pat: &ast::Pat,\n-    ) -> Option<(Type, bool)> {\n+    ) -> Option<(Type, Option<Type>)> {\n         let pat_id = self.pat_id(pat)?;\n         let infer = self.infer.as_ref()?;\n-        let (ty, coerced) = infer\n+        let coerced = infer\n             .pat_adjustments\n             .get(&pat_id)\n-            .and_then(|adjusts| adjusts.last().map(|adjust| (&adjust.target, true)))\n-            .unwrap_or_else(|| (&infer[pat_id], false));\n-        Type::new_with_resolver(db, &self.resolver, ty.clone()).zip(Some(coerced))\n+            .and_then(|adjusts| adjusts.last().map(|adjust| adjust.target.clone()));\n+        let ty = infer[pat_id].clone();\n+        let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n+        mk_ty(ty.clone()).zip(Some(coerced.and_then(mk_ty)))\n     }\n \n     pub(crate) fn type_of_self("}, {"sha": "f725247ccb47df33e35d94f66e8b0e6a32fa95f2", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -86,7 +86,7 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             let name_ref = call_node.name_ref()?;\n             let func_target = match call_node {\n                 FnCallNode::CallExpr(expr) => {\n-                    let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(db)?;\n+                    let callable = sema.type_of_expr(&expr.expr()?)?.original.as_callable(db)?;\n                     match callable.kind() {\n                         hir::CallableKind::Function(it) => it.try_to_nav(db),\n                         _ => None,"}, {"sha": "f8105790f4c035b827db016f04ea0b89a7001160", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -32,8 +32,8 @@ pub(crate) fn goto_type_definition(\n     let (ty, node) = sema.token_ancestors_with_macros(token).find_map(|node| {\n         let ty = match_ast! {\n             match node {\n-                ast::Expr(it) => sema.type_of_expr(&it)?,\n-                ast::Pat(it) => sema.type_of_pat(&it)?,\n+                ast::Expr(it) => sema.type_of_expr(&it)?.original,\n+                ast::Pat(it) => sema.type_of_pat(&it)?.original,\n                 ast::SelfParam(it) => sema.type_of_self(&it)?,\n                 ast::Type(it) => sema.resolve_type(&it)?,\n                 ast::RecordField(it) => sema.to_def(&it).map(|d| d.ty(db.upcast()))?,"}, {"sha": "b4715b10a065194a1464bbce258101beb4b4eba8", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -123,7 +123,7 @@ fn highlight_exit_points(\n                 }\n             }\n             ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n-                if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n+                if sema.type_of_expr(&expr).map_or(false, |ty| ty.original.is_never()) {\n                     highlights\n                         .push(HighlightedRange { access: None, range: expr.syntax().text_range() });\n                 }"}, {"sha": "6789abfb0a7d828c7a24134ae5247cedcb816857", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n+use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n     base_db::{FileRange, SourceDatabase},\n     defs::{Definition, NameClass, NameRefClass},\n@@ -225,33 +225,29 @@ fn hover_type_info(\n     config: &HoverConfig,\n     expr_or_pat: &Either<ast::Expr, ast::Pat>,\n ) -> Option<HoverResult> {\n-    let (ty, coerced) = match expr_or_pat {\n-        Either::Left(expr) => sema.type_of_expr_with_coercion(expr)?,\n-        Either::Right(pat) => sema.type_of_pat_with_coercion(pat)?,\n+    let TypeInfo { original, adjusted } = match expr_or_pat {\n+        Either::Left(expr) => sema.type_of_expr(expr)?,\n+        Either::Right(pat) => sema.type_of_pat(pat)?,\n     };\n \n     let mut res = HoverResult::default();\n-    res.markup = if coerced {\n-        let uncoerced_ty = match expr_or_pat {\n-            Either::Left(expr) => sema.type_of_expr(expr)?,\n-            Either::Right(pat) => sema.type_of_pat(pat)?,\n-        };\n-        let uncoerced = uncoerced_ty.display(sema.db).to_string();\n-        let coerced = ty.display(sema.db).to_string();\n+    res.markup = if let Some(adjusted_ty) = adjusted {\n+        let original = original.display(sema.db).to_string();\n+        let adjusted = adjusted_ty.display(sema.db).to_string();\n         format!(\n-            \"```text\\nType: {:>upad$}\\nCoerced to: {:>cpad$}\\n```\\n\",\n-            uncoerced = uncoerced,\n-            coerced = coerced,\n+            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n+            uncoerced = original,\n+            coerced = adjusted,\n             // 6 base padding for static text prefix of each line\n-            upad = 6 + coerced.len().max(uncoerced.len()),\n-            cpad = uncoerced.len(),\n+            apad = 6 + adjusted.len().max(original.len()),\n+            opad = original.len(),\n         )\n         .into()\n     } else {\n         if config.markdown() {\n-            Markup::fenced_block(&ty.display(sema.db))\n+            Markup::fenced_block(&original.display(sema.db))\n         } else {\n-            ty.display(sema.db).to_string().into()\n+            original.display(sema.db).to_string().into()\n         }\n     };\n     Some(res)"}, {"sha": "3dc1bbf7dca47ef4d216951af087af51f144ac16", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{known, Callable, HasVisibility, HirDisplay, Semantics};\n+use hir::{known, Callable, HasVisibility, HirDisplay, Semantics, TypeInfo};\n use ide_db::helpers::FamousDefs;\n use ide_db::RootDatabase;\n use stdx::to_lower_snake_case;\n@@ -117,7 +117,7 @@ fn get_chaining_hints(\n             next_next = tokens.next()?.kind();\n         }\n         if next_next == T![.] {\n-            let ty = sema.type_of_expr(&expr)?;\n+            let ty = sema.type_of_expr(&expr)?.original;\n             if ty.is_unknown() {\n                 return None;\n             }\n@@ -189,7 +189,7 @@ fn get_bind_pat_hints(\n     let krate = sema.scope(pat.syntax()).module().map(|it| it.krate());\n     let famous_defs = FamousDefs(sema, krate);\n \n-    let ty = sema.type_of_pat(&pat.clone().into())?;\n+    let ty = sema.type_of_pat(&pat.clone().into())?.original;\n \n     if should_not_display_type_hint(sema, &pat, &ty) {\n         return None;\n@@ -308,6 +308,7 @@ fn should_not_display_type_hint(\n                     return it.in_token().is_none() ||\n                         it.iterable()\n                             .and_then(|iterable_expr| sema.type_of_expr(&iterable_expr))\n+                            .map(TypeInfo::original)\n                             .map_or(true, |iterable_ty| iterable_ty.is_unknown() || iterable_ty.is_unit())\n                 },\n                 _ => (),\n@@ -393,7 +394,7 @@ fn is_enum_name_similar_to_param_name(\n     argument: &ast::Expr,\n     param_name: &str,\n ) -> bool {\n-    match sema.type_of_expr(argument).and_then(|t| t.as_adt()) {\n+    match sema.type_of_expr(argument).and_then(|t| t.original.as_adt()) {\n         Some(hir::Adt::Enum(e)) => to_lower_snake_case(&e.name(sema.db).to_string()) == param_name,\n         _ => false,\n     }\n@@ -430,7 +431,7 @@ fn get_callable(\n ) -> Option<(hir::Callable, ast::ArgList)> {\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n-            sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db).zip(expr.arg_list())\n+            sema.type_of_expr(&expr.expr()?)?.original.as_callable(sema.db).zip(expr.arg_list())\n         }\n         ast::Expr::MethodCallExpr(expr) => {\n             sema.resolve_method_call_as_callable(expr).zip(expr.arg_list())"}, {"sha": "3f61a856ddf864e1d12cfd353f0c4493c84bde5d", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -123,7 +123,7 @@ pub(super) fn element(\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n-                let ty = sema.type_of_expr(&expr)?;\n+                let ty = sema.type_of_expr(&expr)?.original;\n                 if ty.is_raw_ptr() {\n                     HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n                 } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n@@ -555,7 +555,7 @@ fn highlight_method_call(\n                 if let Some(receiver_ty) =\n                     method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n                 {\n-                    if !receiver_ty.is_copy(sema.db) {\n+                    if !receiver_ty.adjusted().is_copy(sema.db) {\n                         h |= HlMod::Consuming\n                     }\n                 }"}, {"sha": "a48729b45f04bfbe5c41f477951456d00d92e304", "filename": "crates/ide_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -54,9 +54,10 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     }\n \n     let ty = match (pat, expr) {\n-        (ast::Pat::IdentPat(_), Some(expr)) => ctx.sema.type_of_expr_with_coercion(&expr)?.0,\n+        (ast::Pat::IdentPat(_), Some(expr)) => ctx.sema.type_of_expr(&expr)?,\n         (pat, _) => ctx.sema.type_of_pat(&pat)?,\n-    };\n+    }\n+    .adjusted();\n \n     // Unresolved or unnameable types can't be annotated\n     if ty.contains_unknown() || ty.is_closure() {"}, {"sha": "a7344572baefc806b012ccd4eaa2ed66888a966a", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -86,7 +86,7 @@ fn validate_method_call_expr(\n     let receiver = expr.receiver()?;\n     let expr = ast::Expr::MethodCallExpr(expr);\n \n-    let it_type = sema.type_of_expr(&receiver)?;\n+    let it_type = sema.type_of_expr(&receiver)?.adjusted();\n     let module = sema.scope(receiver.syntax()).module()?;\n     let krate = module.krate();\n "}, {"sha": "25a66029cb9ae6f0105778e78605271500bbdc47", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -2,7 +2,7 @@ use std::{hash::BuildHasherDefault, iter};\n \n use ast::make;\n use either::Either;\n-use hir::{HirDisplay, Local, Semantics};\n+use hir::{HirDisplay, Local, Semantics, TypeInfo};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     search::{FileReference, ReferenceAccess, SearchScope},\n@@ -344,7 +344,9 @@ impl FlowKind {\n         match self {\n             FlowKind::Return(Some(expr))\n             | FlowKind::Break(Some(expr))\n-            | FlowKind::TryReturn { expr, .. } => ctx.sema.type_of_expr(expr),\n+            | FlowKind::TryReturn { expr, .. } => {\n+                ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted)\n+            }\n             FlowKind::Try { .. } => {\n                 stdx::never!(\"try does not have defined expr_ty\");\n                 None\n@@ -850,10 +852,7 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n \n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n     match body.tail_expr() {\n-        Some(expr) => {\n-            let ty = ctx.sema.type_of_expr(&expr)?;\n-            Some(RetType::Expr(ty))\n-        }\n+        Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),\n         None => Some(RetType::Stmt),\n     }\n }\n@@ -950,7 +949,7 @@ fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n     let text = func_name.syntax().text();\n \n     if text == \"Err\" {\n-        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr)? })\n+        Some(TryKind::Result { ty: ctx.sema.type_of_expr(expr).map(TypeInfo::original)? })\n     } else if text == \"None\" {\n         Some(TryKind::Option)\n     } else {"}, {"sha": "c72ed324237bbe8b7b709760db2c05db8959dbbc", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -39,8 +39,8 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n         .ancestors()\n         .take_while(|it| it.text_range().contains_range(ctx.frange.range))\n         .find_map(valid_target_expr)?;\n-    if let Some(ty) = ctx.sema.type_of_expr(&to_extract) {\n-        if ty.is_unit() {\n+    if let Some(ty_info) = ctx.sema.type_of_expr(&to_extract) {\n+        if ty_info.adjusted().is_unit() {\n             return None;\n         }\n     }"}, {"sha": "f71b9e3a3cbfea1af5427eaa0017f532350c0e9e", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -223,7 +223,7 @@ impl ExtendedEnum {\n }\n \n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ExtendedEnum> {\n-    sema.type_of_expr(expr)?.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n+    sema.type_of_expr(expr)?.adjusted().autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n         Some(Adt::Enum(e)) => Some(ExtendedEnum::Enum(e)),\n         _ => ty.is_bool().then(|| ExtendedEnum::Bool),\n     })\n@@ -234,6 +234,7 @@ fn resolve_tuple_of_enum_def(\n     expr: &ast::Expr,\n ) -> Option<Vec<ExtendedEnum>> {\n     sema.type_of_expr(expr)?\n+        .adjusted()\n         .tuple_fields(sema.db)\n         .iter()\n         .map(|ty| {"}, {"sha": "255f9ae4ec21cee805e1b7c4a2fd165bb6d01794", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -1,4 +1,4 @@\n-use hir::HirDisplay;\n+use hir::{HirDisplay, TypeInfo};\n use ide_db::{base_db::FileId, helpers::SnippetCap};\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::to_lower_snake_case;\n@@ -153,7 +153,8 @@ impl FunctionBuilder {\n         // type, but that the current state of their code doesn't allow that return type\n         // to be accurately inferred.\n         let (ret_ty, should_render_snippet) = {\n-            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())) {\n+            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())).map(TypeInfo::original)\n+            {\n                 Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n                 Some(ty) => {\n                     let rendered = ty.display_source_code(ctx.db(), target_module.into());\n@@ -331,7 +332,7 @@ fn fn_arg_type(\n     target_module: hir::Module,\n     fn_arg: &ast::Expr,\n ) -> Option<String> {\n-    let ty = ctx.sema.type_of_expr(fn_arg)?;\n+    let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n     if ty.is_unknown() {\n         return None;\n     }"}, {"sha": "778ad21b08a9a3969a6a7c1edd9175777358ce2a", "filename": "crates/ide_assists/src/handlers/infer_function_return_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finfer_function_return_type.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -18,7 +18,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn infer_function_return_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let (fn_type, tail_expr, builder_edit_pos) = extract_tail(ctx)?;\n     let module = ctx.sema.scope(tail_expr.syntax()).module()?;\n-    let ty = ctx.sema.type_of_expr(&tail_expr)?;\n+    let ty = ctx.sema.type_of_expr(&tail_expr)?.adjusted();\n     if ty.is_unit() {\n         return None;\n     }"}, {"sha": "c60dd81eb06d52bd0d9401c13434d3b372bc9053", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -1,5 +1,5 @@\n use ast::make;\n-use hir::{HasSource, PathResolution};\n+use hir::{HasSource, PathResolution, TypeInfo};\n use ide_db::{defs::Definition, search::FileReference};\n use itertools::izip;\n use syntax::{\n@@ -189,10 +189,9 @@ pub(crate) fn inline_(\n                     _ => {\n                         let ty = ctx\n                             .sema\n-                            .type_of_expr_with_coercion(&expr)\n-                            .map_or(false, |(_, coerced)| coerced)\n-                            .then(|| param_ty)\n-                            .flatten();\n+                            .type_of_expr(&expr)\n+                            .filter(TypeInfo::has_adjustment)\n+                            .and_then(|_| param_ty);\n                         body.push_front(\n                             make::let_stmt(pat, ty, Some(expr)).clone_for_update().into(),\n                         )"}, {"sha": "371223e79dccfe592bf36dc823a64d8714a5d888", "filename": "crates/ide_assists/src/handlers/replace_for_loop_with_for_each.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -80,13 +80,13 @@ fn is_ref_and_impls_iter_method(\n     };\n     let wanted_method = if ref_expr.mut_token().is_some() { known::iter_mut } else { known::iter };\n     let expr_behind_ref = ref_expr.expr()?;\n-    let typ = sema.type_of_expr(&expr_behind_ref)?;\n+    let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n     let scope = sema.scope(iterable.syntax());\n     let krate = scope.module()?.krate();\n     let traits_in_scope = scope.traits_in_scope();\n     let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n \n-    let has_wanted_method = typ\n+    let has_wanted_method = ty\n         .iterate_method_candidates(\n             sema.db,\n             krate,\n@@ -110,7 +110,7 @@ fn is_ref_and_impls_iter_method(\n /// Whether iterable implements core::Iterator\n fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n     let it_typ = match sema.type_of_expr(iterable) {\n-        Some(it) => it,\n+        Some(it) => it.adjusted(),\n         None => return false,\n     };\n "}, {"sha": "323f58acbbe7757b24a4a8ecf1f0ad303944e466", "filename": "crates/ide_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -127,7 +127,7 @@ fn make_else_arm(\n         let pattern = if let [(Either::Left(pat), _)] = conditionals {\n             ctx.sema\n                 .type_of_pat(&pat)\n-                .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.adjusted()))\n                 .zip(Some(pat))\n         } else {\n             None\n@@ -268,7 +268,7 @@ fn binds_name(pat: &ast::Pat) -> bool {\n \n fn is_sad_pat(sema: &hir::Semantics<RootDatabase>, pat: &ast::Pat) -> bool {\n     sema.type_of_pat(pat)\n-        .and_then(|ty| TryEnum::from_ty(sema, &ty))\n+        .and_then(|ty| TryEnum::from_ty(sema, &ty.adjusted()))\n         .map_or(false, |it| does_pat_match_variant(pat, &it.sad_pattern()))\n }\n "}, {"sha": "19abb129efce5c99a0b0951bba6dd39a77004b3e", "filename": "crates/ide_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -49,8 +49,9 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n         target,\n         |edit| {\n             let ty = ctx.sema.type_of_expr(&init);\n-            let happy_variant =\n-                ty.and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty)).map(|it| it.happy_case());\n+            let happy_variant = ty\n+                .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.adjusted()))\n+                .map(|it| it.happy_case());\n             let pat = match happy_variant {\n                 None => original_pat,\n                 Some(var_name) => {"}, {"sha": "0bd89b51f8f365811928c5e7aeb83e075ff24cf4", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -270,8 +270,8 @@ fn invert_special_case(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Opti\n \n fn bin_impls_ord(sema: &Semantics<RootDatabase>, bin: &ast::BinExpr) -> bool {\n     match (\n-        bin.lhs().and_then(|lhs| sema.type_of_expr(&lhs)),\n-        bin.rhs().and_then(|rhs| sema.type_of_expr(&rhs)),\n+        bin.lhs().and_then(|lhs| sema.type_of_expr(&lhs)).map(hir::TypeInfo::adjusted),\n+        bin.rhs().and_then(|rhs| sema.type_of_expr(&rhs)).map(hir::TypeInfo::adjusted),\n     ) {\n         (Some(lhs_ty), Some(rhs_ty)) if lhs_ty == rhs_ty => {\n             let krate = sema.scope(bin.syntax()).module().map(|it| it.krate());"}, {"sha": "c1513f97dade2eda105266bdb9b5f1f00932a278", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -197,7 +197,7 @@ fn from_param(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<St\n         match args_parent {\n             ast::CallExpr(call) => {\n                 let func = call.expr()?;\n-                let func_ty = sema.type_of_expr(&func)?;\n+                let func_ty = sema.type_of_expr(&func)?.adjusted();\n                 func_ty.as_callable(sema.db)?\n             },\n             ast::MethodCallExpr(method) => sema.resolve_method_call_as_callable(&method)?,\n@@ -225,7 +225,7 @@ fn var_name_from_pat(pat: &ast::Pat) -> Option<ast::Name> {\n }\n \n fn from_type(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n-    let ty = sema.type_of_expr(expr)?;\n+    let ty = sema.type_of_expr(expr)?.adjusted();\n     let ty = ty.remove_ref().unwrap_or(ty);\n \n     name_of_type(&ty, sema.db)"}, {"sha": "fdd6e59ffe9c50030fb16faf043b4e9ddc2178b0", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -14,7 +14,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     };\n \n     let receiver_ty = match ctx.sema.type_of_expr(dot_receiver) {\n-        Some(ty) => ty,\n+        Some(ty) => ty.original,\n         _ => return,\n     };\n "}, {"sha": "2a5aa7e91fb8c3ea6a01fb2473f302ccb9246db3", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -180,7 +180,7 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n     if let Some(dot_receiver) = ctx.dot_receiver() {\n         ImportAssets::for_fuzzy_method_call(\n             current_module,\n-            ctx.sema.type_of_expr(dot_receiver)?,\n+            ctx.sema.type_of_expr(dot_receiver)?.original,\n             fuzzy_name,\n             dot_receiver.syntax().clone(),\n         )"}, {"sha": "b9eaccaf55c1cd7a8e3e9a89a8c9190358626588", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     let receiver_text = get_receiver_text(dot_receiver, receiver_is_ambiguous_float_literal);\n \n     let receiver_ty = match ctx.sema.type_of_expr(dot_receiver) {\n-        Some(it) => it,\n+        Some(it) => it.original,\n         None => return,\n     };\n "}, {"sha": "8ede825a622775149d22c7cce4c03765b1d3c651", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -12,9 +12,9 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n         Some(ImmediateLocation::RecordExpr(record_expr)) => {\n             let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n             let default_trait = FamousDefs(&ctx.sema, ctx.krate).core_default_Default();\n-            let impl_default_trait = default_trait\n-                .zip(ty)\n-                .map_or(false, |(default_trait, ty)| ty.impls_trait(ctx.db, default_trait, &[]));\n+            let impl_default_trait = default_trait.zip(ty).map_or(false, |(default_trait, ty)| {\n+                ty.original.impls_trait(ctx.db, default_trait, &[])\n+            });\n \n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n             if impl_default_trait && !missing_fields.is_empty() {"}, {"sha": "ac5cd1ce8e325cab3f6384106cb39e199bd385aa", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -1,7 +1,7 @@\n //! See `CompletionContext` structure.\n \n use base_db::SourceDatabaseExt;\n-use hir::{Local, Name, ScopeDef, Semantics, SemanticsScope, Type};\n+use hir::{Local, Name, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo};\n use ide_db::{\n     base_db::{FilePosition, SourceDatabase},\n     call_info::ActiveParameter,\n@@ -453,7 +453,8 @@ impl<'a> CompletionContext<'a> {\n                         cov_mark::hit!(expected_type_let_without_leading_char);\n                         let ty = it.pat()\n                             .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)));\n+                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)))\n+                            .map(TypeInfo::original);\n                         let name = if let Some(ast::Pat::IdentPat(ident)) = it.pat() {\n                             ident.name().map(NameOrNameRef::Name)\n                         } else {\n@@ -496,27 +497,27 @@ impl<'a> CompletionContext<'a> {\n                     ast::RecordExprField(it) => {\n                         cov_mark::hit!(expected_type_struct_field_with_leading_char);\n                         (\n-                            it.expr().as_ref().and_then(|e| self.sema.type_of_expr(e)),\n+                            it.expr().as_ref().and_then(|e| self.sema.type_of_expr(e)).map(TypeInfo::original),\n                             it.field_name().map(NameOrNameRef::NameRef),\n                         )\n                     },\n                     ast::MatchExpr(it) => {\n                         cov_mark::hit!(expected_type_match_arm_without_leading_char);\n-                        let ty = it.expr()\n-                            .and_then(|e| self.sema.type_of_expr(&e));\n+                        let ty = it.expr().and_then(|e| self.sema.type_of_expr(&e)).map(TypeInfo::original);\n                         (ty, None)\n                     },\n                     ast::IfExpr(it) => {\n                         cov_mark::hit!(expected_type_if_let_without_leading_char);\n                         let ty = it.condition()\n                             .and_then(|cond| cond.expr())\n-                            .and_then(|e| self.sema.type_of_expr(&e));\n+                            .and_then(|e| self.sema.type_of_expr(&e))\n+                            .map(TypeInfo::original);\n                         (ty, None)\n                     },\n                     ast::IdentPat(it) => {\n                         cov_mark::hit!(expected_type_if_let_with_leading_char);\n                         cov_mark::hit!(expected_type_match_arm_with_leading_char);\n-                        let ty = self.sema.type_of_pat(&ast::Pat::from(it));\n+                        let ty = self.sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n                         (ty, None)\n                     },\n                     ast::Fn(it) => {\n@@ -527,7 +528,7 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::ClosureExpr(it) => {\n                         let ty = self.sema.type_of_expr(&it.into());\n-                        ty.and_then(|ty| ty.as_callable(self.db))\n+                        ty.and_then(|ty| ty.original.as_callable(self.db))\n                             .map(|c| (Some(c.return_type()), None))\n                             .unwrap_or((None, None))\n                     },"}, {"sha": "016b00143967e95690108bff81cb84365d905cdc", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -118,7 +118,9 @@ fn call_info_impl(\n     let calling_node = FnCallNode::with_node(&token.parent()?)?;\n \n     let callable = match &calling_node {\n-        FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.as_callable(sema.db)?,\n+        FnCallNode::CallExpr(call) => {\n+            sema.type_of_expr(&call.expr()?)?.adjusted().as_callable(sema.db)?\n+        }\n         FnCallNode::MethodCallExpr(call) => sema.resolve_method_call_as_callable(call)?,\n     };\n     let active_param = if let Some(arg_list) = calling_node.arg_list() {"}, {"sha": "3433398ebab4b34e72a2cd41d5505c9ba600b10c", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -543,7 +543,7 @@ impl ImportCandidate {\n         match sema.resolve_method_call(method_call) {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n-                receiver_ty: sema.type_of_expr(&method_call.receiver()?)?,\n+                receiver_ty: sema.type_of_expr(&method_call.receiver()?)?.adjusted(),\n                 assoc_item_name: NameToImport::Exact(method_call.name_ref()?.to_string()),\n             })),\n         }"}, {"sha": "2e9bd2d3ddd3016ba33646ae49665500a33bd97d", "filename": "crates/ide_diagnostics/src/handlers/missing_ok_or_some_in_tail_expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -1,4 +1,4 @@\n-use hir::db::AstDatabase;\n+use hir::{db::AstDatabase, TypeInfo};\n use ide_db::{assists::Assist, helpers::for_each_tail_expr, source_change::SourceChange};\n use syntax::AstNode;\n use text_edit::TextEdit;\n@@ -35,7 +35,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingOkOrSomeInTailExpr) -> Op\n     let tail_expr_range = tail_expr.syntax().text_range();\n     let mut builder = TextEdit::builder();\n     for_each_tail_expr(&tail_expr, &mut |expr| {\n-        if ctx.sema.type_of_expr(expr).as_ref() != Some(&d.expected) {\n+        if ctx.sema.type_of_expr(expr).map(TypeInfo::original).as_ref() != Some(&d.expected) {\n             builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", d.required));\n             builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n         }"}, {"sha": "667a550d1f9c29953c446c83f3d8d09fe80c827d", "filename": "crates/ide_diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -62,7 +62,7 @@ fn missing_record_expr_field_fixes(\n     };\n     let def_file_id = def_file_id.original_file(sema.db);\n \n-    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?.adjusted();\n     if new_field_type.is_unknown() {\n         return None;\n     }"}, {"sha": "55147674d25b9cc340f652c675d65d9e6ce3d0f9", "filename": "crates/ide_ssr/src/matching.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c8cab20b057ebd75166936fffd649d29a9fd29/crates%2Fide_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fmatching.rs?ref=00c8cab20b057ebd75166936fffd649d29a9fd29", "patch": "@@ -609,9 +609,13 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         expr: &ast::Expr,\n     ) -> Result<usize, MatchFailed> {\n         use hir::HirDisplay;\n-        let code_type = self.sema.type_of_expr(expr).ok_or_else(|| {\n-            match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n-        })?;\n+        let code_type = self\n+            .sema\n+            .type_of_expr(expr)\n+            .ok_or_else(|| {\n+                match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n+            })?\n+            .original;\n         // Temporary needed to make the borrow checker happy.\n         let res = code_type\n             .autoderef(self.sema.db)"}]}