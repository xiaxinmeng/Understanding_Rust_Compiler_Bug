{"sha": "d2e9912aea87f9b1812a0f44e093c0405848f7ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZTk5MTJhZWE4N2Y5YjE4MTJhMGY0NGUwOTNjMDQwNTg0OGY3Y2U=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-21T12:29:53Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-23T06:05:20Z"}, "message": "vec: remove BaseIter implementation\n\nI removed the `static-method-test.rs` test because it was heavily based\non `BaseIter` and there are plenty of other more complex uses of static\nmethods anyway.", "tree": {"sha": "a872d8f5ab40841274cbb777c642d3b6c9036a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a872d8f5ab40841274cbb777c642d3b6c9036a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2e9912aea87f9b1812a0f44e093c0405848f7ce", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e9912aea87f9b1812a0f44e093c0405848f7ce", "html_url": "https://github.com/rust-lang/rust/commit/d2e9912aea87f9b1812a0f44e093c0405848f7ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2e9912aea87f9b1812a0f44e093c0405848f7ce/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9342663df3e705f6fe380f3d4f46c4a7be8035e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9342663df3e705f6fe380f3d4f46c4a7be8035e", "html_url": "https://github.com/rust-lang/rust/commit/c9342663df3e705f6fe380f3d4f46c4a7be8035e"}], "stats": {"total": 1672, "additions": 796, "deletions": 876}, "files": [{"sha": "4c963c5ab7b67c6e44b5441ecda8a3cc1bc289a2", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -882,11 +882,11 @@ the function name.\n \n ~~~~ {.xfail-test}\n fn iter<T>(seq: &[T], f: &fn(T)) {\n-    for seq.each |elt| { f(elt); }\n+    for seq.iter().advance |elt| { f(elt); }\n }\n fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for seq.each |elt| { acc.push(f(elt)); }\n+    for seq.iter().advance |elt| { acc.push(f(elt)); }\n     acc\n }\n ~~~~\n@@ -2327,7 +2327,7 @@ An example of a for loop over the contents of a vector:\n \n let v: &[foo] = &[a, b, c];\n \n-for v.each |e| {\n+for v.iter().advance |e| {\n     bar(*e);\n }\n ~~~~"}, {"sha": "9c61a04930ace169f799cf002a2bab69eb10d583", "filename": "doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1396,7 +1396,7 @@ assert!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n // (`for` is explained in the next section)\n-for crayons.each |crayon| {\n+for crayons.iter().advance |crayon| {\n     let delicious_crayon_wax = unwrap_crayon(*crayon);\n     eat_crayon_wax(delicious_crayon_wax);\n }\n@@ -2119,7 +2119,7 @@ generic types.\n ~~~~\n # trait Printable { fn print(&self); }\n fn print_all<T: Printable>(printable_things: ~[T]) {\n-    for printable_things.each |thing| {\n+    for printable_things.iter().advance |thing| {\n         thing.print();\n     }\n }\n@@ -2165,7 +2165,7 @@ However, consider this function:\n trait Drawable { fn draw(&self); }\n \n fn draw_all<T: Drawable>(shapes: ~[T]) {\n-    for shapes.each |shape| { shape.draw(); }\n+    for shapes.iter().advance |shape| { shape.draw(); }\n }\n # let c: Circle = new_circle();\n # draw_all(~[c]);\n@@ -2180,7 +2180,7 @@ an _object_.\n ~~~~\n # trait Drawable { fn draw(&self); }\n fn draw_all(shapes: &[@Drawable]) {\n-    for shapes.each |shape| { shape.draw(); }\n+    for shapes.iter().advance |shape| { shape.draw(); }\n }\n ~~~~\n "}, {"sha": "e8876c4851bc71512d5bd7b73422fa8646fc413d", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -208,7 +208,8 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n-    for os::list_dir_path(&config.src_base).each |file| {\n+    let dirs = os::list_dir_path(&config.src_base);\n+    for dirs.iter().advance |file| {\n         let file = copy *file;\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n@@ -230,11 +231,11 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n \n     let mut valid = false;\n \n-    for valid_extensions.each |ext| {\n+    for valid_extensions.iter().advance |ext| {\n         if name.ends_with(*ext) { valid = true; }\n     }\n \n-    for invalid_prefixes.each |pre| {\n+    for invalid_prefixes.iter().advance |pre| {\n         if name.starts_with(*pre) { valid = false; }\n     }\n "}, {"sha": "fd56031ccf9423908ffe4e402ca399a90930841d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -327,7 +327,7 @@ fn check_error_patterns(props: &TestProps,\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);\n     } else {\n-        for missing_patterns.each |pattern| {\n+        for missing_patterns.iter().advance |pattern| {\n             error(fmt!(\"error pattern '%s' not found!\", *pattern));\n         }\n         fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n@@ -757,7 +757,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs.push(fmt!(\"%s\", config.adb_test_dir));\n     runargs.push(fmt!(\"%s\", prog_short));\n \n-    for args.args.each |tv| {\n+    for args.args.iter().advance |tv| {\n         runargs.push(tv.to_owned());\n     }\n \n@@ -822,7 +822,8 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tstr = aux_output_dir_name(config, testfile).to_str();\n \n-    for os::list_dir_path(&Path(tstr)).each |file| {\n+    let dirs = os::list_dir_path(&Path(tstr));\n+    for dirs.iter().advance |file| {\n \n         if (file.filetype() == Some(~\".so\")) {\n "}, {"sha": "32114f4037ecc0d9b95d2d4eb09f034af15ba348", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -517,6 +517,7 @@ mod tests {\n \n     use arc::*;\n \n+    use core::vec;\n     use core::cell::Cell;\n     use core::comm;\n     use core::task;\n@@ -725,7 +726,7 @@ mod tests {\n         }\n \n         // Wait for children to pass their asserts\n-        for children.each |r| {\n+        for children.iter().advance |r| {\n             r.recv();\n         }\n \n@@ -790,7 +791,7 @@ mod tests {\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n                 // send to other readers\n-                for reader_convos.each |x| {\n+                for vec::each(reader_convos) |x| {\n                     match *x {\n                         (ref rc, _) => rc.send(()),\n                     }\n@@ -799,7 +800,7 @@ mod tests {\n             let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n-                for reader_convos.each |x| {\n+                for vec::each(reader_convos) |x| {\n                     match *x {\n                         (_, ref rp) => rp.recv(),\n                     }"}, {"sha": "7a1e925a15dca71ca221244fb3234d3b96c393ae", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -421,7 +421,7 @@ mod test {\n     fn make_file(path : &Path, contents: &[~str]) {\n         let file = io::file_writer(path, [io::Create, io::Truncate]).get();\n \n-        for contents.each |&str| {\n+        for contents.iter().advance |&str| {\n             file.write_str(str);\n             file.write_char('\\n');\n         }"}, {"sha": "d97804722f2595bd61f178435309188ea95f123b", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -295,7 +295,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 }\n             }\n             let mut name_pos = 0;\n-            for names.each() |nm| {\n+            for names.iter().advance() |nm| {\n                 name_pos += 1;\n                 let optid = match find_opt(opts, copy *nm) {\n                   Some(id) => id,\n@@ -373,7 +373,7 @@ pub fn opt_count(mm: &Matches, nm: &str) -> uint {\n \n /// Returns true if any of several options were matched\n pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n-    for names.each |nm| {\n+    for names.iter().advance |nm| {\n         match find_opt(mm.opts, mkname(*nm)) {\n             Some(id) if !mm.vals[id].is_empty() => return true,\n             _ => (),\n@@ -400,7 +400,7 @@ pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n  * option took an argument\n  */\n pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n-    for names.each |nm| {\n+    for names.iter().advance |nm| {\n         match opt_val(mm, *nm) {\n           Val(ref s) => return copy *s,\n           _ => ()"}, {"sha": "24c4c5b27c49fe65d16c2c74eb821190e6d27ca5", "filename": "src/libextra/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1385,7 +1385,7 @@ mod tests {\n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~HashMap::new();\n \n-        for items.each |item| {\n+        for items.iter().advance |item| {\n             match *item {\n                 (ref key, ref value) => { d.insert(copy *key, copy *value); },\n             }"}, {"sha": "1d0b9829242d50f959b76679056673192a834d73", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -426,7 +426,7 @@ mod test {\n         let results = result::unwrap(ga_result);\n         debug!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, results.len());\n-        for results.each |r| {\n+        for results.iter().advance |r| {\n             let ipv_prefix = match *r {\n               Ipv4(_) => ~\"IPv4\",\n               Ipv6(_) => ~\"IPv6\""}, {"sha": "dda4b85df4bf75abd792f9ac550ca0de42c0f003", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -210,7 +210,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     for m.each |key, values| {\n         let key = encode_plus(*key);\n \n-        for values.each |value| {\n+        for values.iter().advance |value| {\n             if first {\n                 first = false;\n             } else {\n@@ -342,7 +342,7 @@ fn query_from_str(rawquery: &str) -> Query {\n \n pub fn query_to_str(query: &Query) -> ~str {\n     let mut strvec = ~[];\n-    for query.each |kv| {\n+    for query.iter().advance |kv| {\n         match kv {\n             &(ref k, ref v) => {\n                 strvec.push(fmt!(\"%s=%s\","}, {"sha": "4b080e0153ccc9c1a9d2cee9d307035e294f836d", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1349,7 +1349,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_add() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1362,7 +1362,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1413,7 +1413,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1423,7 +1423,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1437,7 +1437,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_div_rem() {\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1451,7 +1451,7 @@ mod biguint_tests {\n             }\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1567,9 +1567,10 @@ mod biguint_tests {\n \n     #[test]\n     fn test_to_str_radix() {\n-        for to_str_pairs().each |num_pair| {\n+        let r = to_str_pairs();\n+        for r.iter().advance |num_pair| {\n             let &(n, rs) = num_pair;\n-            for rs.each |str_pair| {\n+            for rs.iter().advance |str_pair| {\n                 let &(radix, str) = str_pair;\n                 assert_eq!(n.to_str_radix(radix), str);\n             }\n@@ -1578,9 +1579,10 @@ mod biguint_tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        for to_str_pairs().each |num_pair| {\n+        let r = to_str_pairs();\n+        for r.iter().advance |num_pair| {\n             let &(n, rs) = num_pair;\n-            for rs.each |str_pair| {\n+            for rs.iter().advance |str_pair| {\n                 let &(radix, str) = str_pair;\n                 assert_eq!(&n, &FromStrRadix::from_str_radix(str, radix).get());\n             }\n@@ -1756,7 +1758,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_add() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1775,7 +1777,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_sub() {\n-        for sum_triples.each |elm| {\n+        for sum_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1832,7 +1834,7 @@ mod bigint_tests {\n \n     #[test]\n     fn test_mul() {\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1845,7 +1847,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1884,7 +1886,7 @@ mod bigint_tests {\n             }\n         }\n \n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1894,7 +1896,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1927,7 +1929,7 @@ mod bigint_tests {\n             check_sub(&a.neg(), b, &q.neg(), &r.neg());\n             check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n-        for mul_triples.each |elm| {\n+        for mul_triples.iter().advance |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1937,7 +1939,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for div_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.iter().advance |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);"}, {"sha": "3a63549cf3ac8d2800657c37e9a2e9adfd203e69", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -238,14 +238,14 @@ mod test {\n     fn test_scale_unscale() {\n         assert_eq!(_05_05i.scale(2f), _1_1i);\n         assert_eq!(_1_1i.unscale(2f), _05_05i);\n-        for all_consts.each |&c| {\n+        for all_consts.iter().advance |&c| {\n             assert_eq!(c.scale(2f).unscale(2f), c);\n         }\n     }\n \n     #[test]\n     fn test_conj() {\n-        for all_consts.each |&c| {\n+        for all_consts.iter().advance |&c| {\n             assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n             assert_eq!(c.conj().conj(), c);\n         }\n@@ -282,7 +282,7 @@ mod test {\n             let (r, theta) = c.to_polar();\n             assert!((c - Cmplx::from_polar(&r, &theta)).norm() < 1e-6);\n         }\n-        for all_consts.each |&c| { test(c); }\n+        for all_consts.iter().advance |&c| { test(c); }\n     }\n \n     mod arith {\n@@ -295,7 +295,7 @@ mod test {\n             assert_eq!(_0_1i + _1_0i, _1_1i);\n             assert_eq!(_1_0i + _neg1_1i, _0_1i);\n \n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(_0_0i + c, c);\n                 assert_eq!(c + _0_0i, c);\n             }\n@@ -307,7 +307,7 @@ mod test {\n             assert_eq!(_0_1i - _1_0i, _neg1_1i);\n             assert_eq!(_0_1i - _neg1_1i, _1_0i);\n \n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(c - _0_0i, c);\n                 assert_eq!(c - c, _0_0i);\n             }\n@@ -322,15 +322,15 @@ mod test {\n             assert_eq!(_0_1i * _0_1i, -_1_0i);\n             assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n \n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(c * _1_0i, c);\n                 assert_eq!(_1_0i * c, c);\n             }\n         }\n         #[test]\n         fn test_div() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 if c != Zero::zero() {\n                     assert_eq!(c / c, _1_0i);\n                 }\n@@ -340,7 +340,7 @@ mod test {\n         fn test_neg() {\n             assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n             assert_eq!((-_0_1i) * _0_1i, _1_0i);\n-            for all_consts.each |&c| {\n+            for all_consts.iter().advance |&c| {\n                 assert_eq!(-(-c), c);\n             }\n         }"}, {"sha": "339d35e25936a7d8353ae39500e3c10dea47e04e", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -482,7 +482,8 @@ mod test {\n             assert_eq!(FromStr::from_str::<Rational>(s), None);\n         }\n \n-        for [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"].each |&s| {\n+        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n+        for xs.iter().advance |&s| {\n             test(s);\n         }\n     }\n@@ -521,7 +522,8 @@ mod test {\n             assert_eq!(FromStrRadix::from_str_radix::<Rational>(s, 3), None);\n         }\n \n-        for [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"].each |&s| {\n+        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];\n+        for xs.iter().advance |&s| {\n             test(s);\n         }\n     }"}, {"sha": "31c9acbbd54d42c364a60dc7da75de94cc712ef1", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -28,9 +28,9 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n-    fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.each(f) }\n+    fn each(&self, f: &fn(&T) -> bool) -> bool { self.data.iter().advance(f) }\n \n-    fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n+    fn size_hint(&self) -> Option<uint> { Some(self.data.len()) }\n }\n \n impl<T:Ord> Container for PriorityQueue<T> {"}, {"sha": "84b48c87890b2efeeaf84ec944c1002d050c5ec7", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -250,7 +250,7 @@ pub fn sha1() -> @Sha1 {\n         fn result_str(&mut self) -> ~str {\n             let rr = mk_result(self);\n             let mut s = ~\"\";\n-            for rr.each |b| {\n+            for rr.iter().advance |b| {\n                 let hex = uint::to_str_radix(*b as uint, 16u);\n                 if hex.len() == 1 {\n                     s += \"0\";\n@@ -375,7 +375,7 @@ mod tests {\n         // Test that it works when accepting the message all at once\n \n         let mut sh = sha1::sha1();\n-        for tests.each |t| {\n+        for tests.iter().advance |t| {\n             sh.input_str(t.input);\n             let out = sh.result();\n             check_vec_eq(copy t.output, out);\n@@ -389,7 +389,7 @@ mod tests {\n \n \n         // Test that it works when accepting the message in pieces\n-        for tests.each |t| {\n+        for tests.iter().advance |t| {\n             let len = t.input.len();\n             let mut left = len;\n             while left > 0u {"}, {"sha": "ae2a5c01993de55562e25f0832279668d6763305", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -846,7 +846,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n-        for pairs.each |p| {\n+        for pairs.iter().advance |p| {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n             assert_eq!(a, b);"}, {"sha": "69f75037c7e446fc1315e30217d4586735490822", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -72,7 +72,7 @@ impl<'self> Stats for &'self [f64] {\n         } else {\n             let mean = self.mean();\n             let mut v = 0.0;\n-            for self.each |s| {\n+            for self.iter().advance |s| {\n                 let x = *s - mean;\n                 v += x*x;\n             }"}, {"sha": "6990d35f061324b59ba870c3b7d05aa0f8c11378", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -994,13 +994,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -1085,7 +1085,7 @@ mod tests {\n                     }\n                 }\n             }\n-            for sibling_convos.each |p| {\n+            for sibling_convos.iter().advance |p| {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n@@ -1361,13 +1361,13 @@ mod tests {\n         }\n \n         // wait until all children get in the mutex\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n         // wait until all children wake up\n-        for ports.each |port| { let _ = port.recv(); }\n+        for ports.iter().advance |port| { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "643081d4a7ad03302032e0796de8a556bfae9c3e", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -36,7 +36,7 @@ pub struct TaskPool<T> {\n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n     fn finalize(&self) {\n-        for self.channels.each |channel| {\n+        for self.channels.iter().advance |channel| {\n             channel.send(Quit);\n         }\n     }"}, {"sha": "da12a1c4203f13593f0341c1288742dcf503d2db", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -55,7 +55,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n     };\n \n     // Look for the terminal in all of the search directories\n-    for dirs_to_search.each |p| {\n+    for dirs_to_search.iter().advance |p| {\n         let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);"}, {"sha": "e058a098fa49edff200dfbf93de0db0565e81a08", "filename": "src/libextra/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -369,7 +369,7 @@ fn print_failures(st: &ConsoleTestState) {\n         failures.push(name.to_str());\n     }\n     sort::tim_sort(failures);\n-    for failures.each |name| {\n+    for failures.iter().advance |name| {\n         st.out.write_line(fmt!(\"    %s\", name.to_str()));\n     }\n }\n@@ -947,7 +947,7 @@ mod tests {\n         {\n             fn testfn() { }\n             let mut tests = ~[];\n-            for names.each |name| {\n+            for names.iter().advance |name| {\n                 let test = TestDescAndFn {\n                     desc: TestDesc {\n                         name: DynTestName(copy *name),\n@@ -973,7 +973,7 @@ mod tests {\n \n         let pairs = vec::zip(expected, filtered);\n \n-        for pairs.each |p| {\n+        for pairs.iter().advance |p| {\n             match *p {\n                 (ref a, ref b) => {\n                     assert!(*a == b.desc.name.to_str());"}, {"sha": "ef156ccfb45fdad52b60b74d5534d0a39d0c3016", "filename": "src/libextra/time.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1033,31 +1033,33 @@ mod tests {\n             }\n         }\n \n-        for [\n+        let days = [\n             ~\"Sunday\",\n             ~\"Monday\",\n             ~\"Tuesday\",\n             ~\"Wednesday\",\n             ~\"Thursday\",\n             ~\"Friday\",\n             ~\"Saturday\"\n-        ].each |day| {\n+        ];\n+        for days.iter().advance |day| {\n             assert!(test(*day, \"%A\"));\n         }\n \n-        for [\n+        let days = [\n             ~\"Sun\",\n             ~\"Mon\",\n             ~\"Tue\",\n             ~\"Wed\",\n             ~\"Thu\",\n             ~\"Fri\",\n             ~\"Sat\"\n-        ].each |day| {\n+        ];\n+        for days.iter().advance |day| {\n             assert!(test(*day, \"%a\"));\n         }\n \n-        for [\n+        let months = [\n             ~\"January\",\n             ~\"February\",\n             ~\"March\",\n@@ -1070,11 +1072,12 @@ mod tests {\n             ~\"October\",\n             ~\"November\",\n             ~\"December\"\n-        ].each |day| {\n+        ];\n+        for months.iter().advance |day| {\n             assert!(test(*day, \"%B\"));\n         }\n \n-        for [\n+        let months = [\n             ~\"Jan\",\n             ~\"Feb\",\n             ~\"Mar\",\n@@ -1087,7 +1090,8 @@ mod tests {\n             ~\"Oct\",\n             ~\"Nov\",\n             ~\"Dec\"\n-        ].each |day| {\n+        ];\n+        for months.iter().advance |day| {\n             assert!(test(*day, \"%b\"));\n         }\n "}, {"sha": "71d8a5d81e7e4241be708eb74a82618c351b8419", "filename": "src/libextra/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftimer.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -217,7 +217,7 @@ mod test {\n \n         for repeat.times {\n             let ch = ch.clone();\n-            for spec.each |spec| {\n+            for spec.iter().advance |spec| {\n                 let (times, maxms) = *spec;\n                 let ch = ch.clone();\n                 let hl_loop_clone = hl_loop.clone();"}, {"sha": "87932c25cda180d7a5de34c4eaa26fe17d334246", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -781,13 +781,13 @@ mod test_treemap {\n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n-        for ctrl.each |x| {\n+        for ctrl.iter().advance |x| {\n             let &(k, v) = x;\n             assert!(map.find(&k).unwrap() == &v)\n         }\n         for map.each |map_k, map_v| {\n             let mut found = false;\n-            for ctrl.each |x| {\n+            for ctrl.iter().advance |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n                 if *map_k == ctrl_k {\n                     assert!(*map_v == ctrl_v);\n@@ -1135,8 +1135,8 @@ mod test_set {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n \n-        for a.each |x| { assert!(set_a.insert(*x)) }\n-        for b.each |y| { assert!(set_b.insert(*y)) }\n+        for a.iter().advance |x| { assert!(set_a.insert(*x)) }\n+        for b.iter().advance |y| { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n         for f(&set_a, &set_b) |x| {"}, {"sha": "63c89ebf5865273d562d97837d094b9e09725801", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -157,7 +157,7 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &mut D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = WorkMap::new();\n-        for v.each |&(k, v)| {\n+        for v.iter().advance |&(k, v)| {\n             w.insert(copy k, copy v);\n         }\n         w"}, {"sha": "68427745ff592d78bc2ea9daffab98ad9e2c1d36", "filename": "src/librust/rust.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -222,7 +222,7 @@ fn usage() {\n         \\n\"\n     );\n \n-    for commands.each |command| {\n+    for commands.iter().advance |command| {\n         let padding = \" \".repeat(indent - command.cmd.len());\n         io::println(fmt!(\"    %s%s%s\",\n                          command.cmd, padding, command.usage_line));"}, {"sha": "01ad3507b83ead18687bf37ee290012789528abb", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -124,7 +124,8 @@ pub mod jit {\n             // incase the user wants to use an older extra library.\n \n             let cstore = sess.cstore;\n-            for cstore::get_used_crate_files(cstore).each |cratepath| {\n+            let r = cstore::get_used_crate_files(cstore);\n+            for r.iter().advance |cratepath| {\n                 let path = cratepath.to_str();\n \n                 debug!(\"linking: %s\", path);\n@@ -470,7 +471,7 @@ pub fn build_link_meta(sess: Session,\n         let mut cmh_items = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n-        for linkage_metas.each |meta| {\n+        for linkage_metas.iter().advance |meta| {\n             match attr::get_meta_item_value_str(*meta) {\n                 Some(value) => {\n                     let item_name : &str = attr::get_meta_item_name(*meta);\n@@ -518,19 +519,19 @@ pub fn build_link_meta(sess: Session,\n               }\n               ast::meta_list(name, ref mis) => {\n                 write_string(symbol_hasher, len_and_str(name));\n-                for mis.each |m_| {\n+                for mis.iter().advance |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n               }\n             }\n         }\n \n         symbol_hasher.reset();\n-        for cmh_items.each |m| {\n+        for cmh_items.iter().advance |m| {\n             hash(symbol_hasher, m);\n         }\n \n-        for dep_hashes.each |dh| {\n+        for dep_hashes.iter().advance |dh| {\n             write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n@@ -682,7 +683,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n-    for ss.each |s| {\n+    for ss.iter().advance |s| {\n         match *s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(sess.str_of(s));\n           n += fmt!(\"%u%s\", sani.len(), sani);\n@@ -872,7 +873,8 @@ pub fn link_args(sess: Session,\n     // # Crate linking\n \n     let cstore = sess.cstore;\n-    for cstore::get_used_crate_files(cstore).each |cratepath| {\n+    let r = cstore::get_used_crate_files(cstore);\n+    for r.iter().advance |cratepath| {\n         if cratepath.filetype() == Some(~\".rlib\") {\n             args.push(cratepath.to_str());\n             loop;\n@@ -884,7 +886,7 @@ pub fn link_args(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { args.push(arg.to_owned()); }\n+    for ula.iter().advance |arg| { args.push(arg.to_owned()); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n@@ -902,13 +904,13 @@ pub fn link_args(sess: Session,\n     // to be found at compile time so it is still entirely up to outside\n     // forces to make sure that library can be found at runtime.\n \n-    for sess.opts.addl_lib_search_paths.each |path| {\n+    for sess.opts.addl_lib_search_paths.iter().advance |path| {\n         args.push(~\"-L\" + path.to_str());\n     }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each |l| { args.push(~\"-l\" + *l); }\n+    for used_libs.iter().advance |l| { args.push(~\"-l\" + *l); }\n \n     if *sess.building_library {\n         args.push(lib_cmd);"}, {"sha": "2c994fbc3fc123dfb43e02cf5e5736f01a7e136d", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -147,7 +147,7 @@ pub fn create_standard_passes(level:OptLevel) -> ~[~str] {\n }\n \n pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n-    for pass_list.each |&nm| {\n+    for pass_list.iter().advance |&nm| {\n         match create_pass(nm) {\n             Some(p) => pm.add_pass(p),\n             None    => sess.warn(fmt!(\"Unknown pass %s\", nm))\n@@ -172,15 +172,15 @@ pub fn list_passes() {\n     io::println(\"\\nAvailable Passes:\");\n \n     io::println(\"\\nAnalysis Passes:\");\n-    for analysis_passes.each |&(name, desc)| {\n+    for analysis_passes.iter().advance |&(name, desc)| {\n         io::println(fmt!(\"    %-30s -- %s\", name, desc));\n     }\n     io::println(\"\\nTransformation Passes:\");\n-    for transform_passes.each |&(name, desc)| {\n+    for transform_passes.iter().advance |&(name, desc)| {\n         io::println(fmt!(\"    %-30s -- %s\", name, desc));\n     }\n     io::println(\"\\nUtility Passes:\");\n-    for utility_passes.each |&(name, desc)| {\n+    for utility_passes.iter().advance |&(name, desc)| {\n         io::println(fmt!(\"    %-30s -- %s\", name, desc));\n     }\n }\n@@ -298,23 +298,23 @@ static utility_passes : &'static [(&'static str, &'static str)] = &'static [\n fn passes_exist() {\n     let mut failed = ~[];\n     unsafe { llvm::LLVMInitializePasses(); }\n-    for analysis_passes.each() |&(name,_)| {\n+    for analysis_passes.iter().advance |&(name,_)| {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    for transform_passes.each() |&(name,_)| {\n+    for transform_passes.iter().advance |&(name,_)| {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n             unsafe { llvm::LLVMDestroyPass(pass.get()) }\n         }\n     }\n-    for utility_passes.each() |&(name,_)| {\n+    for utility_passes.iter().advance |&(name,_)| {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n@@ -325,7 +325,7 @@ fn passes_exist() {\n \n     if failed.len() > 0 {\n         io::println(\"Some passes don't exist:\");\n-        for failed.each |&n| {\n+        for failed.iter().advance |&n| {\n             io::println(fmt!(\"    %s\", n));\n         }\n         fail!();"}, {"sha": "4657c069c21e3ef3d95838afa573d4192abea096", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -64,7 +64,7 @@ fn get_rpaths(os: session::os,\n     debug!(\"sysroot: %s\", sysroot.to_str());\n     debug!(\"output: %s\", output.to_str());\n     debug!(\"libs:\");\n-    for libs.each |libpath| {\n+    for libs.iter().advance |libpath| {\n         debug!(\"    %s\", libpath.to_str());\n     }\n     debug!(\"target_triple: %s\", target_triple);\n@@ -83,7 +83,7 @@ fn get_rpaths(os: session::os,\n \n     fn log_rpaths(desc: &str, rpaths: &[Path]) {\n         debug!(\"%s rpaths:\", desc);\n-        for rpaths.each |rpath| {\n+        for rpaths.iter().advance |rpath| {\n             debug!(\"    %s\", rpath.to_str());\n         }\n     }\n@@ -185,7 +185,7 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut set = HashSet::new();\n     let mut minimized = ~[];\n-    for rpaths.each |rpath| {\n+    for rpaths.iter().advance |rpath| {\n         if set.insert(rpath.to_str()) {\n             minimized.push(copy *rpath);\n         }"}, {"sha": "1a7041c08840ec51d41ad08eb36f806486066fe6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -453,7 +453,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    for os_names.each |&(name, os)| {\n+    for os_names.iter().advance |&(name, os)| {\n         if triple.contains(name) { return Some(os) }\n     }\n     None\n@@ -467,7 +467,7 @@ static os_names : &'static [(&'static str, session::os)] = &'static [\n     (\"freebsd\", session::os_freebsd)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    for architecture_abis.each |&(arch, abi)| {\n+    for architecture_abis.iter().advance |&(arch, abi)| {\n         if triple.contains(arch) { return Some(abi) }\n     }\n     None\n@@ -556,7 +556,7 @@ pub fn build_session_options(binary: @str,\n                        lint::deny, lint::forbid];\n     let mut lint_opts = ~[];\n     let lint_dict = lint::get_lint_dict();\n-    for lint_levels.each |level| {\n+    for lint_levels.iter().advance |level| {\n         let level_name = lint::level_to_str(*level);\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n@@ -565,7 +565,7 @@ pub fn build_session_options(binary: @str,\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n-        for flags.each |lint_name| {\n+        for flags.iter().advance |lint_name| {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n@@ -582,9 +582,9 @@ pub fn build_session_options(binary: @str,\n     let mut debugging_opts = 0u;\n     let debug_flags = getopts::opt_strs(matches, \"Z\");\n     let debug_map = session::debugging_opts_map();\n-    for debug_flags.each |debug_flag| {\n+    for debug_flags.iter().advance |debug_flag| {\n         let mut this_bit = 0u;\n-        for debug_map.each |tuple| {\n+        for debug_map.iter().advance |tuple| {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n             if name == debug_flag { this_bit = bit; break; }\n         }"}, {"sha": "71375966a28b79365c8ea126bd186bfdc83d4a24", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -143,7 +143,7 @@ fn fold_block(\n     let filtered_view_items =\n         filtered_view_items.map(|x| fld.fold_view_item(*x));\n     let mut resulting_stmts = ~[];\n-    for filtered_stmts.each |stmt| {\n+    for filtered_stmts.iter().advance |stmt| {\n         match fld.fold_stmt(*stmt) {\n             None => {}\n             Some(stmt) => resulting_stmts.push(stmt),"}, {"sha": "c9eb97b44cd705e98dec880f8fd764322ed46c93", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -386,7 +386,7 @@ fn is_std(cx: &TestCtxt) -> bool {\n fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    for cx.testfns.each |test| {\n+    for cx.testfns.iter().advance |test| {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n "}, {"sha": "2743cd1ddc1e77dd2b4e09eeed3123fe3158f78e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -66,7 +66,7 @@ struct cache_entry {\n \n fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n     debug!(\"resolved crates:\");\n-    for crate_cache.each |entry| {\n+    for crate_cache.iter().advance |entry| {\n         debug!(\"cnum: %?\", entry.cnum);\n         debug!(\"span: %?\", entry.span);\n         debug!(\"hash: %?\", entry.hash);\n@@ -101,7 +101,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n         if matches.len() != 1u {\n             diag.handler().warn(\n                 fmt!(\"using multiple versions of crate `%s`\", name));\n-            for matches.each |match_| {\n+            for matches.iter().advance |match_| {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n@@ -130,7 +130,7 @@ fn visit_crate(e: @mut Env, c: &ast::crate) {\n     let cstore = e.cstore;\n     let link_args = attr::find_attrs_by_name(c.node.attrs, \"link_args\");\n \n-    for link_args.each |a| {\n+    for link_args.iter().advance |a| {\n         match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n           Some(ref linkarg) => {\n             cstore::add_used_link_args(cstore, *linkarg);\n@@ -191,7 +191,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n             ast::anonymous => { /* do nothing */ }\n         }\n \n-        for link_args.each |a| {\n+        for link_args.iter().advance |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n                 Some(linkarg) => {\n                     cstore::add_used_link_args(cstore, linkarg);\n@@ -221,7 +221,7 @@ fn metas_with_ident(ident: @str, metas: ~[@ast::meta_item])\n \n fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @str)\n                -> Option<int> {\n-    for e.crate_cache.each |c| {\n+    for e.crate_cache.iter().advance |c| {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || c.hash == hash) {\n             return Some(c.cnum);\n@@ -303,7 +303,8 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let mut cnum_map = HashMap::new();\n-    for decoder::get_crate_deps(cdata).each |dep| {\n+    let r = decoder::get_crate_deps(cdata);\n+    for r.iter().advance |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);"}, {"sha": "c6c1ac720e8e0518db33d98ab79935783923d60c", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -160,7 +160,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n     };\n \n     debug!(\"sorted:\");\n-    for sorted.each |x| {\n+    for sorted.iter().advance |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n "}, {"sha": "9ace8677dab76342ebc900ad21efc657b7deac6f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -598,7 +598,7 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let mut infos: ~[ty::VariantInfo] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for variant_ids.each |did| {\n+    for variant_ids.iter().advance |did| {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::def_id { crate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n@@ -818,7 +818,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     let mut static_impl_methods = ~[];\n-    for impl_method_ids.each |impl_method_id| {\n+    for impl_method_ids.iter().advance |impl_method_id| {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n         let family = item_family(impl_method_doc);\n         match family {\n@@ -1008,7 +1008,8 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n fn list_meta_items(intr: @ident_interner,\n                    meta_items: ebml::Doc,\n                    out: @io::Writer) {\n-    for get_meta_items(meta_items).each |mi| {\n+    let r = get_meta_items(meta_items);\n+    for r.iter().advance |mi| {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n@@ -1017,7 +1018,8 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n                          out: @io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n-    for get_attributes(md).each |attr| {\n+    let r = get_attributes(md);\n+    for r.iter().advance |attr| {\n         out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n     }\n \n@@ -1057,7 +1059,8 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n-    for get_crate_deps(data).each |dep| {\n+    let r = get_crate_deps(data);\n+    for r.iter().advance |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n                  dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));"}, {"sha": "826b64b9a64b8e28ac5267ea40bf98947d9a5db6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -187,7 +187,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n         tcx: ecx.tcx,\n         reachable: |a| r.contains(&a),\n         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n-    for params.each |param| {\n+    for params.iter().advance |param| {\n         ebml_w.start_tag(tag);\n         tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n         ebml_w.end_tag();\n@@ -325,7 +325,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: local_crate, node: id });\n-    for variants.each |variant| {\n+    for variants.iter().advance |variant| {\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n@@ -373,7 +373,7 @@ fn encode_path(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_path);\n     ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n-    for path.each |pe| {\n+    for path.iter().advance |pe| {\n         encode_path_elt(ecx, ebml_w, *pe);\n     }\n     encode_path_elt(ecx, ebml_w, name);\n@@ -403,8 +403,8 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          -> bool {\n     match ecx.tcx.base_impls.find(&exp.def_id) {\n         Some(implementations) => {\n-            for implementations.each |&base_impl| {\n-                for base_impl.methods.each |&m| {\n+            for implementations.iter().advance |&base_impl| {\n+                for base_impl.methods.iter().advance |&m| {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n                                                         m.did, m.ident);\n@@ -424,7 +424,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.find(&exp.def_id) {\n         Some(methods) => {\n-            for methods.each |&m| {\n+            for methods.iter().advance |&m| {\n                 if m.explicit_self == ast::sty_static {\n                     encode_reexported_static_method(ecx, ebml_w, exp,\n                                                     m.def_id, m.ident);\n@@ -486,7 +486,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     debug!(\"(encoding info for module) encoding info for module ID %d\", id);\n \n     // Encode info about all the module children.\n-    for md.items.each |item| {\n+    for md.items.iter().advance |item| {\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n@@ -511,7 +511,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.each |exp| {\n+            for exports.iter().advance |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n                        exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -617,7 +617,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for fields.each |field| {\n+    for fields.iter().advance |field| {\n         let (nm, vis) = match field.node.kind {\n             named_field(nm, vis) => (nm, vis),\n             unnamed_field => (special_idents::unnamed_field, inherited)\n@@ -862,7 +862,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        for (*enum_definition).variants.each |v| {\n+        for (*enum_definition).variants.iter().advance |v| {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n@@ -921,7 +921,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        for struct_def.fields.each |f| {\n+        for struct_def.fields.iter().advance |f| {\n             match f.node.kind {\n                 named_field(ident, vis) => {\n                    ebml_w.start_tag(tag_item_field);\n@@ -960,7 +960,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for methods.each |m| {\n+        for methods.iter().advance |m| {\n             ebml_w.start_tag(tag_item_impl_method);\n             let method_def_id = local_def(m.id);\n             let s = def_to_str(method_def_id);\n@@ -978,7 +978,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let mut impl_path = vec::append(~[], path);\n         impl_path += [ast_map::path_name(item.ident)];\n \n-        for methods.each |m| {\n+        for methods.iter().advance |m| {\n             index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n                                    ebml_w,\n@@ -1001,13 +1001,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).each |&method_def_id| {\n+        for ty::trait_method_def_ids(tcx, local_def(item.id)).iter().advance |&method_def_id| {\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        for super_traits.each |ast_trait_ref| {\n+        for super_traits.iter().advance |ast_trait_ref| {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n@@ -1183,13 +1183,13 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n    ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n-    for index.each |elt| {\n+    for index.iter().advance |elt| {\n         let h = elt.val.hash() as uint;\n         buckets[h % 256].push(copy *elt);\n     }\n \n     let mut buckets_frozen = ~[];\n-    for buckets.each |bucket| {\n+    for buckets.iter().advance |bucket| {\n         buckets_frozen.push(@/*bad*/copy **bucket);\n     }\n     return buckets_frozen;\n@@ -1202,10 +1202,10 @@ fn encode_index<T>(ebml_w: &mut writer::Encoder,\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n-    for buckets.each |bucket| {\n+    for buckets.iter().advance |bucket| {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for (**bucket).each |elt| {\n+        for (**bucket).iter().advance |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n@@ -1216,7 +1216,7 @@ fn encode_index<T>(ebml_w: &mut writer::Encoder,\n     }\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n-    for bucket_locs.each |pos| {\n+    for bucket_locs.iter().advance |pos| {\n         assert!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n@@ -1262,7 +1262,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n         ebml_w.start_tag(tag_meta_item_name);\n         ebml_w.writer.write(name.as_bytes());\n         ebml_w.end_tag();\n-        for items.each |inner_item| {\n+        for items.iter().advance |inner_item| {\n             encode_meta_item(ebml_w, *inner_item);\n         }\n         ebml_w.end_tag();\n@@ -1272,7 +1272,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @meta_item) {\n \n fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n-    for attrs.each |attr| {\n+    for attrs.iter().advance |attr| {\n         ebml_w.start_tag(tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n         ebml_w.end_tag();\n@@ -1314,7 +1314,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n \n     let mut attrs: ~[attribute] = ~[];\n     let mut found_link_attr = false;\n-    for crate.node.attrs.each |attr| {\n+    for crate.node.attrs.iter().advance |attr| {\n         attrs.push(\n             if \"link\" != attr::get_attr_name(attr)  {\n                 copy *attr\n@@ -1356,7 +1356,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n-        for deps.each |n| {\n+        for deps.iter().advance |n| {\n             assert_eq!(n.cnum, expected_cnum);\n             expected_cnum += 1;\n         }\n@@ -1370,7 +1370,8 @@ fn encode_crate_deps(ecx: &EncodeContext,\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    for get_ordered_deps(ecx, cstore).each |dep| {\n+    let r = get_ordered_deps(ecx, cstore);\n+    for r.iter().advance |dep| {\n         encode_crate_dep(ecx, ebml_w, *dep);\n     }\n     ebml_w.end_tag();\n@@ -1404,7 +1405,7 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n-    for link_args.each |link_arg| {\n+    for link_args.iter().advance |link_arg| {\n         ebml_w.start_tag(tag_link_args_arg);\n         ebml_w.writer.write_str(link_arg.to_str());\n         ebml_w.end_tag();\n@@ -1515,7 +1516,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-        for wr.bytes.each |e| {\n+        for wr.bytes.iter().advance |e| {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }"}, {"sha": "6268932ba9958a3f06265091ba7ca85b8d4e4775", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -48,7 +48,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n             // a little weird\n-            self.addl_lib_search_paths.each(f);\n+            self.addl_lib_search_paths.iter().advance(f);\n \n             debug!(\"filesearch: searching target lib path\");\n             if !f(&make_target_lib_path(self.sysroot,\n@@ -89,7 +89,8 @@ pub fn search<T:Copy>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());\n-        for os::list_dir_path(lib_search_path).each |path| {\n+        let r = os::list_dir_path(lib_search_path);\n+        for r.iter().advance |path| {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(*path);\n             if maybe_picked.is_some() {"}, {"sha": "f6ad676546dd90715b32932ed9a4725f1668a54f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -130,7 +130,7 @@ fn find_library_crate_aux(\n         cx.diag.span_err(\n             cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n         cx.diag.handler().note(\"candidates:\");\n-        for matches.each |&(ident, data)| {\n+        for matches.iter().advance |&(ident, data)| {\n             cx.diag.handler().note(fmt!(\"path: %s\", ident));\n             let attrs = decoder::get_crate_attributes(data);\n             note_linkage_attrs(cx.intr, cx.diag, attrs);\n@@ -158,9 +158,9 @@ pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @str {\n pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n                           attrs: ~[ast::attribute]) {\n-    for attr::find_linkage_metas(attrs).each |mi| {\n-        diag.handler().note(fmt!(\"meta: %s\",\n-              pprust::meta_item_to_str(*mi,intr)));\n+    let r = attr::find_linkage_metas(attrs);\n+    for r.iter().advance |mi| {\n+        diag.handler().note(fmt!(\"meta: %s\", pprust::meta_item_to_str(*mi,intr)));\n     }\n }\n \n@@ -182,7 +182,7 @@ pub fn metadata_matches(extern_metas: &[@ast::meta_item],\n     debug!(\"matching %u metadata requirements against %u items\",\n            local_metas.len(), extern_metas.len());\n \n-    for local_metas.each |needed| {\n+    for local_metas.iter().advance |needed| {\n         if !attr::contains(extern_metas, *needed) {\n             return false;\n         }"}, {"sha": "5f854b1f24e0d8c69172148ea5e15af7d15c264f", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -125,7 +125,7 @@ fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n-    for substs.tps.each |t| { enc_ty(w, cx, *t); }\n+    for substs.tps.iter().advance |t| { enc_ty(w, cx, *t); }\n     w.write_char(']');\n }\n \n@@ -272,7 +272,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_tup(ts) => {\n         w.write_str(&\"T[\");\n-        for ts.each |t| { enc_ty(w, cx, *t); }\n+        for ts.iter().advance |t| { enc_ty(w, cx, *t); }\n         w.write_char(']');\n       }\n       ty::ty_box(mt) => { w.write_char('@'); enc_mt(w, cx, mt); }\n@@ -389,7 +389,7 @@ fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n \n fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    for fsig.inputs.each |ty| {\n+    for fsig.inputs.iter().advance |ty| {\n         enc_ty(w, cx, *ty);\n     }\n     w.write_char(']');\n@@ -407,7 +407,7 @@ fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n         }\n     }\n \n-    for bs.trait_bounds.each |&tp| {\n+    for bs.trait_bounds.iter().advance |&tp| {\n         w.write_char('I');\n         enc_trait_ref(w, cx, tp);\n     }"}, {"sha": "5730eb0d9bd8b00ace1210d49857843279e619f1", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -118,7 +118,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! given `loan_path`\n \n         for self.each_in_scope_loan(scope_id) |loan| {\n-            for loan.restrictions.each |restr| {\n+            for loan.restrictions.iter().advance |restr| {\n                 if restr.loan_path == loan_path {\n                     if !op(loan, restr) {\n                         return false;\n@@ -152,7 +152,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         debug!(\"new_loan_indices = %?\", new_loan_indices);\n \n         for self.each_issued_loan(scope_id) |issued_loan| {\n-            for new_loan_indices.each |&new_loan_index| {\n+            for new_loan_indices.iter().advance |&new_loan_index| {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n@@ -210,7 +210,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         };\n         debug!(\"illegal_if=%?\", illegal_if);\n \n-        for loan1.restrictions.each |restr| {\n+        for loan1.restrictions.iter().advance |restr| {\n             if !restr.set.intersects(illegal_if) { loop; }\n             if restr.loan_path != loan2.loan_path { loop; }\n \n@@ -634,7 +634,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                                 closure_id: ast::node_id,\n                                 span: span) {\n         let cap_vars = this.bccx.capture_map.get(&closure_id);\n-        for cap_vars.each |cap_var| {\n+        for cap_vars.iter().advance |cap_var| {\n             match cap_var.mode {\n                 moves::CapRef | moves::CapCopy => {\n                     let var_id = ast_util::def_id_of_def(cap_var.def).node;"}, {"sha": "c7bad60e90e8d0dbbb4fe644f47476ceade81217", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -71,7 +71,7 @@ pub fn gather_captures(bccx: @BorrowckCtxt,\n                        move_data: &mut MoveData,\n                        closure_expr: @ast::expr) {\n     let captured_vars = bccx.capture_map.get(&closure_expr.id);\n-    for captured_vars.each |captured_var| {\n+    for captured_vars.iter().advance |captured_var| {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let fvar_id = ast_util::def_id_of_def(captured_var.def).node;"}, {"sha": "9d8fdb06278266d3fb39297de5c6edf059ceb022", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -229,8 +229,8 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n-        for arms.each |arm| {\n-            for arm.pats.each |pat| {\n+        for arms.iter().advance |arm| {\n+            for arm.pats.iter().advance |pat| {\n                 this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n         }"}, {"sha": "bedb465c5c14c6dd29794c75e688bdb6efe5b52b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -140,7 +140,7 @@ impl RestrictionsContext {\n                 // static errors. For example, if there is code like\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n-                //    for v.each |e| {\n+                //    for v.iter().advance |e| {\n                 //        v.push(e + 1);\n                 //    }\n                 //\n@@ -152,7 +152,7 @@ impl RestrictionsContext {\n                 //\n                 //    let v = @mut ~[1, 2, 3];\n                 //    let w = v;\n-                //    for v.each |e| {\n+                //    for v.iter().advance |e| {\n                 //        w.push(e + 1);\n                 //    }\n                 //\n@@ -165,7 +165,7 @@ impl RestrictionsContext {\n                 //    }\n                 //    ...\n                 //    let v: &V = ...;\n-                //    for v.get_list().each |e| {\n+                //    for v.get_list().iter().advance |e| {\n                 //        v.get_list().push(e + 1);\n                 //    }\n                 match opt_loan_path(cmt_base) {"}, {"sha": "0b94eeecba87112ff97900823d407b413f730744", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -357,13 +357,13 @@ impl MoveData {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        for self.path_assignments.each |assignment| {\n+        for self.path_assignments.iter().advance |assignment| {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n-        for self.paths.each |path| {\n+        for self.paths.iter().advance |path| {\n             match *path.loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);"}, {"sha": "126d2db6879dd5f9380f618e63a69177ef1f8a9f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -48,7 +48,7 @@ pub fn check_item(sess: Session,\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n-        for (*enum_definition).variants.each |var| {\n+        for (*enum_definition).variants.iter().advance |var| {\n             for var.node.disr_expr.iter().advance |ex| {\n                 (v.visit_expr)(*ex, (true, v));\n             }"}, {"sha": "a253240587077de561d7eaf62b93ec7ff9475729", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -64,7 +64,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n         let is_non_moving_lvalue = expr_is_non_moving_lvalue(cx, ex);\n-        for arms.each |arm| {\n+        for arms.iter().advance |arm| {\n             check_legality_of_move_bindings(cx,\n                                             is_non_moving_lvalue,\n                                             arm.guard.is_some(),\n@@ -110,8 +110,8 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n // Check for unreachable patterns\n pub fn check_arms(cx: @MatchCheckCtxt, arms: &[arm]) {\n     let mut seen = ~[];\n-    for arms.each |arm| {\n-        for arm.pats.each |pat| {\n+    for arms.iter().advance |arm| {\n+        for arm.pats.iter().advance |pat| {\n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n               not_useful => {\n@@ -232,7 +232,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n-                for (*ty::enum_variants(cx.tcx, eid)).each |va| {\n+                for (*ty::enum_variants(cx.tcx, eid)).iter().advance |va| {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n@@ -354,14 +354,14 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n       ty::ty_struct(*) => {\n-        for m.each |r| {\n+        for m.iter().advance |r| {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n-        for m.each |r| {\n+        for m.iter().advance |r| {\n             let r = pat_ctor_id(cx, r[0]);\n             for r.iter().advance |id| {\n                 if !vec::contains(found, id) {\n@@ -371,7 +371,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n         }\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n-            for (*variants).each |v| {\n+            for (*variants).iter().advance |v| {\n                 if !found.iter().any_(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n@@ -383,7 +383,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       ty::ty_bool => {\n         let mut true_found = false;\n         let mut false_found = false;\n-        for m.each |r| {\n+        for m.iter().advance |r| {\n             match pat_ctor_id(cx, r[0]) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n@@ -423,7 +423,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n         let mut found_slice = false;\n         let mut next = 0;\n         let mut missing = None;\n-        for sorted_vec_lens.each |&(length, slice)| {\n+        for sorted_vec_lens.iter().advance |&(length, slice)| {\n             if length != next {\n                 missing = Some(next);\n                 break;\n@@ -775,7 +775,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n                 (s, v): ((),\n                          visit::vt<()>)) {\n     visit::visit_fn(kind, decl, body, sp, id, (s, v));\n-    for decl.inputs.each |input| {\n+    for decl.inputs.iter().advance |input| {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n                                  \"refutable pattern in function argument\");\n@@ -829,7 +829,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     let def_map = tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n-    for pats.each |pat| {\n+    for pats.iter().advance |pat| {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n                 bind_by_ref(_) => {\n@@ -871,7 +871,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     };\n \n     if !any_by_move { return; } // pointless micro-optimization\n-    for pats.each |pat| {\n+    for pats.iter().advance |pat| {\n         for walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {"}, {"sha": "acd47eca7265c486f2f95c913ef03aa42931a91c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -389,7 +389,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n         self.merge_with_entry_set(blk.node.id, in_out);\n \n-        for blk.node.stmts.each |&stmt| {\n+        for blk.node.stmts.iter().advance |&stmt| {\n             self.walk_stmt(stmt, in_out, loop_scopes);\n         }\n \n@@ -510,7 +510,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                         loop_kind: ForLoop,\n                         break_bits: reslice(in_out).to_owned()\n                     });\n-                    for decl.inputs.each |input| {\n+                    for decl.inputs.iter().advance |input| {\n                         self.walk_pat(input.pat, func_bits, loop_scopes);\n                     }\n                     self.walk_block(body, func_bits, loop_scopes);\n@@ -627,7 +627,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 // together the bits from each arm:\n                 self.reset(in_out);\n \n-                for arms.each |arm| {\n+                for arms.iter().advance |arm| {\n                     // in_out reflects the discr and all guards to date\n                     self.walk_opt_expr(arm.guard, guards, loop_scopes);\n \n@@ -702,7 +702,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_struct(_, ref fields, with_expr) => {\n-                for fields.each |field| {\n+                for fields.iter().advance |field| {\n                     self.walk_expr(field.node.expr, in_out, loop_scopes);\n                 }\n                 self.walk_opt_expr(with_expr, in_out, loop_scopes);\n@@ -764,10 +764,10 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_inline_asm(ref inline_asm) => {\n-                for inline_asm.inputs.each |&(_, expr)| {\n+                for inline_asm.inputs.iter().advance |&(_, expr)| {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n-                for inline_asm.outputs.each |&(_, expr)| {\n+                for inline_asm.outputs.iter().advance |&(_, expr)| {\n                     self.walk_expr(expr, in_out, loop_scopes);\n                 }\n             }\n@@ -835,7 +835,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   exprs: &[@ast::expr],\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        for exprs.each |&expr| {\n+        for exprs.iter().advance |&expr| {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }\n@@ -897,7 +897,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n         let initial_state = reslice(in_out).to_owned();\n-        for pats.each |&pat| {\n+        for pats.iter().advance |&pat| {\n             let mut temp = copy initial_state;\n             self.walk_pat(pat, temp, loop_scopes);\n             join_bits(&self.dfcx.oper, temp, in_out);\n@@ -993,7 +993,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n \n     // Note: this is a little endian printout of bytes.\n \n-    for words.each |&word| {\n+    for words.iter().advance |&word| {\n         let mut v = word;\n         for uint::range(0, uint::bytes) |_| {\n             result.push_char(sep);"}, {"sha": "06feb9e7ba958e4405a93e54125640aeaae37280", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -138,7 +138,7 @@ fn configure_main(ctxt: @mut EntryContext) {\n                                    but you have one or more functions named 'main' that are not \\\n                                    defined at the crate level. Either move the definition or \\\n                                    attach the `#[main]` attribute to override this behavior.\");\n-                for this.non_main_fns.each |&(_, span)| {\n+                for this.non_main_fns.iter().advance |&(_, span)| {\n                     this.session.span_note(span, \"here is a function named 'main'\");\n                 }\n             }"}, {"sha": "3a8d369469b175dfc35ccfbb0e548a82c6148ec1", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -391,7 +391,7 @@ impl LanguageItemCollector {\n         let this: *mut LanguageItemCollector = &mut *self;\n         visit_crate(self.crate, ((), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n-                for item.attrs.each |attribute| {\n+                for item.attrs.iter().advance |attribute| {\n                     unsafe {\n                         (*this).match_and_collect_meta_item(\n                             local_def(item.id),"}, {"sha": "d29c027f3c28104bd13f0f628992b713f7aa901c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -288,7 +288,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n  */\n pub fn get_lint_dict() -> LintDict {\n     let mut map = HashMap::new();\n-    for lint_table.each|&(k, v)| {\n+    for lint_table.iter().advance |&(k, v)| {\n         map.insert(k, v);\n     }\n     return map;\n@@ -435,7 +435,8 @@ impl Context {\n \n         // detect doc(hidden)\n         let mut doc_hidden = false;\n-        for attr::find_attrs_by_name(attrs, \"doc\").each |attr| {\n+        let r = attr::find_attrs_by_name(attrs, \"doc\");\n+        for r.iter().advance |attr| {\n             match attr::get_meta_item_list(attr.node.value) {\n                 Some(s) => {\n                     if attr::find_meta_items_by_name(s, \"hidden\").len() > 0 {\n@@ -472,12 +473,12 @@ impl Context {\n         // pair instead of just one visitor.\n         match n {\n             Item(it) => {\n-                for self.visitors.each |&(orig, stopping)| {\n+                for self.visitors.iter().advance |&(orig, stopping)| {\n                     (orig.visit_item)(it, (self, stopping));\n                 }\n             }\n             Crate(c) => {\n-                for self.visitors.each |&(_, stopping)| {\n+                for self.visitors.iter().advance |&(_, stopping)| {\n                     visit::visit_crate(c, (self, stopping));\n                 }\n             }\n@@ -486,7 +487,7 @@ impl Context {\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n                 let fk = visit::fk_method(copy m.ident, &m.generics, m);\n-                for self.visitors.each |&(orig, stopping)| {\n+                for self.visitors.iter().advance |&(orig, stopping)| {\n                     (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n                                     (self, stopping));\n                 }\n@@ -497,12 +498,12 @@ impl Context {\n \n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::attribute],\n-                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool\n-{\n-    for [allow, warn, deny, forbid].each |&level| {\n+                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool {\n+    let xs = [allow, warn, deny, forbid];\n+    for xs.iter().advance |&level| {\n         let level_name = level_to_str(level);\n         let attrs = attr::find_attrs_by_name(attrs, level_name);\n-        for attrs.each |attr| {\n+        for attrs.iter().advance |attr| {\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::meta_list(_, ref metas) => metas,\n@@ -511,7 +512,7 @@ pub fn each_lint(sess: session::Session,\n                     loop;\n                 }\n             };\n-            for metas.each |meta| {\n+            for metas.iter().advance |meta| {\n                 match meta.node {\n                     ast::meta_word(lintname) => {\n                         if !f(*meta, level, lintname) {\n@@ -525,7 +526,7 @@ pub fn each_lint(sess: session::Session,\n             }\n         }\n     }\n-    return true;\n+    true\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -693,7 +694,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n fn check_item_default_methods(cx: &Context, item: @ast::item) {\n     match item.node {\n         ast::item_trait(_, _, ref methods) => {\n-            for methods.each |method| {\n+            for methods.iter().advance |method| {\n                 match *method {\n                     ast::required(*) => {}\n                     ast::provided(*) => {\n@@ -735,7 +736,7 @@ fn check_item_ctypes(cx: &Context, it: @ast::item) {\n \n     match it.node {\n       ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n-        for nmod.items.each |ni| {\n+        for nmod.items.iter().advance |ni| {\n             match ni.node {\n               ast::foreign_item_fn(ref decl, _, _) => {\n                 check_foreign_fn(cx, decl);\n@@ -777,7 +778,8 @@ fn check_type_for_lint(cx: &Context, lint: lint, span: span, ty: ty::t) {\n }\n \n fn check_type(cx: &Context, span: span, ty: ty::t) {\n-    for [managed_heap_memory, owned_heap_memory, heap_memory].each |lint| {\n+    let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n+    for xs.iter().advance |lint| {\n         check_type_for_lint(cx, *lint, span, ty);\n     }\n }\n@@ -796,7 +798,7 @@ fn check_item_heap(cx: &Context, it: @ast::item) {\n     // If it's a struct, we also have to check the fields' types\n     match it.node {\n         ast::item_struct(struct_def, _) => {\n-            for struct_def.fields.each |struct_field| {\n+            for struct_def.fields.iter().advance |struct_field| {\n                 check_type(cx, struct_field.span,\n                            ty::node_id_to_type(cx.tcx,\n                                                struct_field.node.id));\n@@ -860,7 +862,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n         }\n         ast::item_enum(ref enum_definition, _) => {\n             check_case(cx, it.ident, it.span);\n-            for enum_definition.variants.each |variant| {\n+            for enum_definition.variants.iter().advance |variant| {\n                 check_case(cx, variant.node.name, variant.span);\n             }\n         }\n@@ -905,7 +907,7 @@ fn lint_unused_mut() -> visit::vt<@mut Context> {\n     }\n \n     fn visit_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n-        for fd.inputs.each |arg| {\n+        for fd.inputs.iter().advance |arg| {\n             if arg.is_mutbl {\n                 check_pat(cx, arg.pat);\n             }\n@@ -1052,7 +1054,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n                 ast::item_struct(sdef, _) if it.vis == ast::public => {\n                     check_attrs(cx, it.attrs, it.span,\n                                 \"missing documentation for a struct\");\n-                    for sdef.fields.each |field| {\n+                    for sdef.fields.iter().advance |field| {\n                         match field.node.kind {\n                             ast::named_field(_, vis) if vis != ast::private => {\n                                 check_attrs(cx, field.node.attrs, field.span,\n@@ -1100,7 +1102,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n \n     // Install command-line options, overriding defaults.\n-    for tcx.sess.opts.lint_opts.each |&(lint, level)| {\n+    for tcx.sess.opts.lint_opts.iter().advance |&(lint, level)| {\n         cx.set_level(lint, level, CommandLine);\n     }\n \n@@ -1158,7 +1160,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n     for tcx.sess.lints.each |_, v| {\n-        for v.each |t| {\n+        for v.iter().advance |t| {\n             match *t {\n                 (lint, span, ref msg) =>\n                     tcx.sess.span_bug(span, fmt!(\"unprocessed lint %?: %s\","}, {"sha": "d8308c516b05638f0e9cc55729c8eede2db1ef88", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -355,7 +355,7 @@ fn visit_fn(fk: &visit::fn_kind,\n         debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n     }\n \n-    for decl.inputs.each |arg| {\n+    for decl.inputs.iter().advance |arg| {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n@@ -431,7 +431,7 @@ fn visit_local(local: @local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n \n fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n     let def_map = this.tcx.def_map;\n-    for arm.pats.each |pat| {\n+    for arm.pats.iter().advance |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n             debug!(\"adding local variable %d from match with bm %?\",\n                    p_id, bm);\n@@ -470,7 +470,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         // construction site.\n         let cvs = this.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n-        for cvs.each |cv| {\n+        for cvs.iter().advance |cv| {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n@@ -1075,7 +1075,7 @@ impl Liveness {\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n-            for arms.each |arm| {\n+            for arms.iter().advance |arm| {\n                 let body_succ =\n                     self.propagate_through_block(&arm.body, succ);\n                 let guard_succ =\n@@ -1453,12 +1453,12 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       }\n \n       expr_inline_asm(ref ia) => {\n-        for ia.inputs.each |&(_, in)| {\n+        for ia.inputs.iter().advance |&(_, in)| {\n           (vt.visit_expr)(in, (this, vt));\n         }\n \n         // Output operands must be lvalues\n-        for ia.outputs.each |&(_, out)| {\n+        for ia.outputs.iter().advance |&(_, out)| {\n           match out.node {\n             expr_addr_of(_, inner) => {\n               this.check_lvalue(inner, vt);\n@@ -1594,7 +1594,7 @@ impl Liveness {\n     }\n \n     pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n-        for decl.inputs.each |arg| {\n+        for decl.inputs.iter().advance |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n                 let var = self.variable(p_id, sp);"}, {"sha": "2ced57dc885b666824e23f3493fe5d8a63c7eb51", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -895,7 +895,7 @@ impl mem_categorization_ctxt {\n                     }\n                 }\n                 Some(&ast::def_const(*)) => {\n-                    for subpats.each |&subpat| {\n+                    for subpats.iter().advance |&subpat| {\n                         self.cat_pattern(cmt, subpat, op);\n                     }\n                 }\n@@ -917,7 +917,7 @@ impl mem_categorization_ctxt {\n \n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            for field_pats.each |fp| {\n+            for field_pats.iter().advance |fp| {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n@@ -945,15 +945,15 @@ impl mem_categorization_ctxt {\n \n           ast::pat_vec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n-              for before.each |&before_pat| {\n+              for before.iter().advance |&before_pat| {\n                   self.cat_pattern(elt_cmt, before_pat, op);\n               }\n               for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue(pat, slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, op);\n               }\n-              for after.each |&after_pat| {\n+              for after.iter().advance |&after_pat| {\n                   self.cat_pattern(elt_cmt, after_pat, op);\n               }\n           }\n@@ -1041,7 +1041,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n     // Need to refactor so that struct/enum fields can be treated uniformly.\n     match ty::get(base_ty).sty {\n       ty::ty_struct(did, _) => {\n-        for ty::lookup_struct_fields(tcx, did).each |fld| {\n+        let r = ty::lookup_struct_fields(tcx, did);\n+        for r.iter().advance |fld| {\n             if fld.ident == f_name {\n                 return Some(ast::m_imm);\n             }\n@@ -1050,7 +1051,8 @@ pub fn field_mutbl(tcx: ty::ctxt,\n       ty::ty_enum(*) => {\n         match tcx.def_map.get_copy(&node_id) {\n           ast::def_variant(_, variant_id) => {\n-            for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n+            let r = ty::lookup_struct_fields(tcx, variant_id);\n+            for r.iter().advance |fld| {\n                 if fld.ident == f_name {\n                     return Some(ast::m_imm);\n                 }"}, {"sha": "0050239e0663023406d9bcd509f5160ee1469768", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -232,7 +232,7 @@ fn compute_modes_for_expr(expr: @expr,\n \n impl VisitContext {\n     pub fn consume_exprs(&self, exprs: &[@expr], visitor: vt<VisitContext>) {\n-        for exprs.each |expr| {\n+        for exprs.iter().advance |expr| {\n             self.consume_expr(*expr, visitor);\n         }\n     }\n@@ -263,7 +263,7 @@ impl VisitContext {\n \n         debug!(\"consume_block(blk.id=%?)\", blk.node.id);\n \n-        for blk.node.stmts.each |stmt| {\n+        for blk.node.stmts.iter().advance |stmt| {\n             (visitor.visit_stmt)(*stmt, (*self, visitor));\n         }\n \n@@ -347,7 +347,7 @@ impl VisitContext {\n             }\n \n             expr_struct(_, ref fields, opt_with) => {\n-                for fields.each |field| {\n+                for fields.iter().advance |field| {\n                     self.consume_expr(field.node.expr, visitor);\n                 }\n \n@@ -398,7 +398,7 @@ impl VisitContext {\n             expr_match(discr, ref arms) => {\n                 // We must do this first so that `arms_have_by_move_bindings`\n                 // below knows which bindings are moves.\n-                for arms.each |arm| {\n+                for arms.iter().advance |arm| {\n                     self.consume_arm(arm, visitor);\n                 }\n \n@@ -534,7 +534,7 @@ impl VisitContext {\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n-        for arg_exprs.each |arg_expr| {\n+        for arg_exprs.iter().advance |arg_expr| {\n             self.use_expr(*arg_expr, Read, visitor);\n         }\n \n@@ -591,7 +591,7 @@ impl VisitContext {\n                        arg_exprs: &[@expr],\n                        visitor: vt<VisitContext>) {\n         //! Uses the argument expressions.\n-        for arg_exprs.each |arg_expr| {\n+        for arg_exprs.iter().advance |arg_expr| {\n             self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n@@ -605,8 +605,8 @@ impl VisitContext {\n                                       moves_map: MovesMap,\n                                       arms: &[arm])\n                                       -> Option<@pat> {\n-        for arms.each |arm| {\n-            for arm.pats.each |&pat| {\n+        for arms.iter().advance |arm| {\n+            for arm.pats.iter().advance |&pat| {\n                 for ast_util::walk_pat(pat) |p| {\n                     if moves_map.contains(&p.id) {\n                         return Some(p);"}, {"sha": "94771b4ed0b311ad15a7eb448a3701505684529e", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -52,15 +52,15 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 *count += 1;\n             }\n             item_impl(_, _, _, ref methods) => {\n-                for methods.each |method| {\n+                for methods.iter().advance |method| {\n                     privileged_items.push(method.id);\n                     *count += 1;\n                 }\n                 privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_foreign_mod(ref foreign_mod) => {\n-                for foreign_mod.items.each |foreign_item| {\n+                for foreign_mod.items.iter().advance |foreign_item| {\n                     privileged_items.push(foreign_item.id);\n                     *count += 1;\n                 }\n@@ -72,7 +72,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     // Adds items that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n         let mut count = 0;\n-        for items.each |&item| {\n+        for items.iter().advance |&item| {\n             add_privileged_item(item, &mut count);\n         }\n         count\n@@ -231,7 +231,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n             |span, id, ident| {\n         let fields = ty::lookup_struct_fields(tcx, id);\n-        for fields.each |field| {\n+        for fields.iter().advance |field| {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n@@ -377,7 +377,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         visit_block: |block, (method_map, visitor)| {\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n-            for block.node.stmts.each |stmt| {\n+            for block.node.stmts.iter().advance |stmt| {\n                 match stmt.node {\n                     stmt_decl(decl, _) => {\n                         match decl.node {\n@@ -450,7 +450,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.iter().any_(|x| x == &(id.node)) {\n-                                for (*fields).each |field| {\n+                                for (*fields).iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n                                     check_field(expr.span, id,\n@@ -463,7 +463,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n-                                        for (*fields).each |field| {\n+                                        for (*fields).iter().advance |field| {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n@@ -516,7 +516,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.iter().any_(|x| x == &(id.node)) {\n-                                for fields.each |field| {\n+                                for fields.iter().advance |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n                                     check_field(pattern.span, id,\n@@ -529,7 +529,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     !privileged_items.iter().any_(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n-                                        for fields.each |field| {\n+                                        for fields.iter().advance |field| {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");"}, {"sha": "4b6cedd114c31f16170535ae67c105127963d734", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -197,7 +197,7 @@ impl RegionMaps {\n         while i < queue.len() {\n             match self.free_region_map.find(&queue[i]) {\n                 Some(parents) => {\n-                    for parents.each |parent| {\n+                    for parents.iter().advance |parent| {\n                         if *parent == sup {\n                             return true;\n                         }\n@@ -732,7 +732,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                                           visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n-            for decl.inputs.each |a| {\n+            for decl.inputs.iter().advance |a| {\n                 (visitor.visit_ty)(a.ty, (cx, visitor));\n             }\n         }\n@@ -843,7 +843,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n       ast::ty_path(path, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n-            for path.types.each |tp| {\n+            for path.types.iter().advance |tp| {\n                 (visitor.visit_ty)(*tp, (cx, visitor));\n             }\n         }\n@@ -856,7 +856,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                for decl.inputs.each |a| {\n+                for decl.inputs.iter().advance |a| {\n                     (visitor.visit_ty)(a.ty, (cx, visitor));\n                 }\n             }\n@@ -936,7 +936,7 @@ pub fn determine_rp_in_crate(sess: Session,\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n-                for deps.each |dep| {\n+                for deps.iter().advance |dep| {\n                     let v = add_variance(dep.ambient_variance, c_variance);\n                     cx.add_rp(dep.id, v);\n                 }"}, {"sha": "8a08b3419e2e9a93a433fe23efdb7df4ac0a3232", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1057,7 +1057,7 @@ impl Resolver {\n         }\n \n         // Check each statement.\n-        for block.node.stmts.each |statement| {\n+        for block.node.stmts.iter().advance |statement| {\n             match statement.node {\n                 stmt_decl(declaration, _) => {\n                     match declaration.node {\n@@ -1178,7 +1178,7 @@ impl Resolver {\n                 name_bindings.define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n-                for (*enum_definition).variants.each |variant| {\n+                for (*enum_definition).variants.iter().advance |variant| {\n                     self.build_reduced_graph_for_variant(\n                         variant,\n                         local_def(item.id),\n@@ -1227,7 +1227,7 @@ impl Resolver {\n                 // Bail out early if there are no static methods.\n                 let mut methods_seen = HashMap::new();\n                 let mut has_static_methods = false;\n-                for methods.each |method| {\n+                for methods.iter().advance |method| {\n                     match method.explicit_self.node {\n                         sty_static => has_static_methods = true,\n                         _ => {\n@@ -1282,7 +1282,7 @@ impl Resolver {\n                         };\n \n                         // For each static method...\n-                        for methods.each |method| {\n+                        for methods.iter().advance |method| {\n                             match method.explicit_self.node {\n                                 sty_static => {\n                                     // Add the static method to the\n@@ -1319,7 +1319,7 @@ impl Resolver {\n                 // We only need to create the module if the trait has static\n                 // methods, so check that first.\n                 let mut has_static_methods = false;\n-                for (*methods).each |method| {\n+                for (*methods).iter().advance |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n                     match ty_m.explicit_self.node {\n                         sty_static => {\n@@ -1347,7 +1347,7 @@ impl Resolver {\n \n                 // Add the names of all the methods to the trait info.\n                 let mut method_names = HashMap::new();\n-                for methods.each |method| {\n+                for methods.iter().advance |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n@@ -1452,7 +1452,7 @@ impl Resolver {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n-                for view_paths.each |view_path| {\n+                for view_paths.iter().advance |view_path| {\n                     // Extract and intern the module part of the path. For\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n@@ -1472,7 +1472,7 @@ impl Resolver {\n \n                         view_path_glob(module_ident_path, _) |\n                         view_path_list(module_ident_path, _, _) => {\n-                            for module_ident_path.idents.each |ident| {\n+                            for module_ident_path.idents.iter().advance |ident| {\n                                 module_path.push(*ident);\n                             }\n                         }\n@@ -1493,7 +1493,7 @@ impl Resolver {\n                                                         id);\n                         }\n                         view_path_list(_, ref source_idents, _) => {\n-                            for source_idents.each |source_ident| {\n+                            for source_idents.iter().advance |source_ident| {\n                                 let name = source_ident.node.name;\n                                 let subclass = @SingleImport(name, name);\n                                 self.build_import_directive(privacy,\n@@ -1686,7 +1686,7 @@ impl Resolver {\n               let method_def_ids =\n                 get_trait_method_def_ids(self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n-              for method_def_ids.each |&method_def_id| {\n+              for method_def_ids.iter().advance |&method_def_id| {\n                   let (method_name, explicit_self) =\n                       get_method_name_and_explicit_self(self.session.cstore,\n                                                         method_def_id);\n@@ -1767,7 +1767,7 @@ impl Resolver {\n             // need to.\n \n             let mut current_module = root;\n-            for pieces.each |ident_str| {\n+            for pieces.iter().advance |ident_str| {\n                 let ident = self.session.ident_of(*ident_str);\n                 // Create or reuse a graph node for the child.\n                 let (child_name_bindings, new_parent) =\n@@ -1887,8 +1887,7 @@ impl Resolver {\n                                     // Add each static method to the module.\n                                     let new_parent = ModuleReducedGraphParent(\n                                         type_module);\n-                                    for static_methods.each\n-                                            |static_method_info| {\n+                                    for static_methods.iter().advance |static_method_info| {\n                                         let ident = static_method_info.ident;\n                                         debug!(\"(building reduced graph for \\\n                                                  external crate) creating \\\n@@ -2074,7 +2073,7 @@ impl Resolver {\n     pub fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n-        for idents.each |ident| {\n+        for idents.iter().advance |ident| {\n             if first { first = false; } else { result += \"::\" };\n             result += self.session.str_of(*ident);\n         };\n@@ -3270,7 +3269,8 @@ impl Resolver {\n                        self.session.str_of(*ident));\n                 loop;\n             }\n-            for [ TypeNS, ValueNS ].each |ns| {\n+            let xs = [TypeNS, ValueNS];\n+            for xs.iter().advance |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n@@ -3517,7 +3517,7 @@ impl Resolver {\n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n             item_enum(ref enum_def, ref generics) => {\n-                for (*enum_def).variants.each() |variant| {\n+                for (*enum_def).variants.iter().advance |variant| {\n                     for variant.node.disr_expr.iter().advance |dis_expr| {\n                         // resolve the discriminator expr\n                         // as a constant\n@@ -3575,7 +3575,7 @@ impl Resolver {\n                                                  visitor);\n \n                     // Resolve derived traits.\n-                    for traits.each |trt| {\n+                    for traits.iter().advance |trt| {\n                         match self.resolve_path(trt.path, TypeNS, true,\n                                                 visitor) {\n                             None =>\n@@ -3595,7 +3595,7 @@ impl Resolver {\n                         }\n                     }\n \n-                    for (*methods).each |method| {\n+                    for (*methods).iter().advance |method| {\n                         // Create a new rib for the method-specific type\n                         // parameters.\n                         //\n@@ -3615,7 +3615,7 @@ impl Resolver {\n                                     &ty_m.generics.ty_params,\n                                     visitor);\n \n-                                for ty_m.decl.inputs.each |argument| {\n+                                for ty_m.decl.inputs.iter().advance |argument| {\n                                     self.resolve_type(argument.ty, visitor);\n                                 }\n \n@@ -3652,7 +3652,7 @@ impl Resolver {\n \n             item_foreign_mod(ref foreign_module) => {\n                 do self.with_scope(Some(item.ident)) {\n-                    for foreign_module.items.each |foreign_item| {\n+                    for foreign_module.items.iter().advance |foreign_item| {\n                         match foreign_item.node {\n                             foreign_item_fn(_, _, ref generics) => {\n                                 self.with_type_parameter_rib(\n@@ -3799,7 +3799,7 @@ impl Resolver {\n                     // Nothing to do.\n                 }\n                 Some(declaration) => {\n-                    for declaration.inputs.each |argument| {\n+                    for declaration.inputs.iter().advance |argument| {\n                         let binding_mode = ArgumentIrrefutableMode;\n                         let mutability =\n                             if argument.is_mutbl {Mutable} else {Immutable};\n@@ -3878,7 +3878,7 @@ impl Resolver {\n             self.resolve_type_parameters(&generics.ty_params, visitor);\n \n             // Resolve fields.\n-            for fields.each |field| {\n+            for fields.iter().advance |field| {\n                 self.resolve_type(field.node.ty, visitor);\n             }\n         }\n@@ -3953,7 +3953,7 @@ impl Resolver {\n             // Resolve the self type.\n             self.resolve_type(self_type, visitor);\n \n-            for methods.each |method| {\n+            for methods.iter().advance |method| {\n                 // We also need a new scope for the method-specific\n                 // type parameters.\n                 self.resolve_method(MethodRibKind(\n@@ -4073,7 +4073,7 @@ impl Resolver {\n         self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n-        for arm.pats.each |pattern| {\n+        for arm.pats.iter().advance |pattern| {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n         }\n@@ -4326,7 +4326,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for path.types.each |ty| {\n+                    for path.types.iter().advance |ty| {\n                         self.resolve_type(*ty, visitor);\n                     }\n                 }\n@@ -4359,7 +4359,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for path.types.each |ty| {\n+                    for path.types.iter().advance |ty| {\n                         self.resolve_type(*ty, visitor);\n                     }\n                 }\n@@ -4388,7 +4388,7 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for path.types.each |ty| {\n+                    for path.types.iter().advance |ty| {\n                         self.resolve_type(*ty, visitor);\n                     }\n                 }\n@@ -4483,7 +4483,7 @@ impl Resolver {\n                         visitor: ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n-        for path.types.each |ty| {\n+        for path.types.iter().advance |ty| {\n             self.resolve_type(*ty, visitor);\n         }\n \n@@ -4872,11 +4872,11 @@ impl Resolver {\n           i -= 1;\n           match this.type_ribs[i].kind {\n             MethodRibKind(node_id, _) =>\n-              for this.crate.node.module.items.each |item| {\n+              for this.crate.node.module.items.iter().advance |item| {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n-                      for class_def.fields.each |field| {\n+                      for class_def.fields.iter().advance |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _) => {\n@@ -5130,7 +5130,7 @@ impl Resolver {\n                 // Look for the current trait.\n                 match /*bad*/copy self.current_trait_refs {\n                     Some(trait_def_ids) => {\n-                        for trait_def_ids.each |trait_def_id| {\n+                        for trait_def_ids.iter().advance |trait_def_id| {\n                             if candidate_traits.contains(trait_def_id) {\n                                 self.add_trait_info(\n                                     &mut found_traits,\n@@ -5281,7 +5281,7 @@ impl Resolver {\n         match vi.node {\n             view_item_extern_mod(*) => {} // ignore\n             view_item_use(ref path) => {\n-                for path.each |p| {\n+                for path.iter().advance |p| {\n                     match p.node {\n                         view_path_simple(_, _, id) | view_path_glob(_, id) => {\n                             if !self.used_imports.contains(&id) {\n@@ -5292,7 +5292,7 @@ impl Resolver {\n                         }\n \n                         view_path_list(_, ref list, _) => {\n-                            for list.each |i| {\n+                            for list.iter().advance |i| {\n                                 if !self.used_imports.contains(&i.node.id) {\n                                     self.session.add_lint(unused_imports,\n                                                           i.node.id, i.span,"}, {"sha": "ab2f0c84d02e481efc86f7c97a72d303a17fa4e7", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -298,7 +298,7 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n-            for (*variants).each |v| {\n+            for (*variants).iter().advance |v| {\n                 if var_id == v.id {\n                     return var(v.disr_val,\n                                adt::represent_node(bcx, pat_id))\n@@ -363,7 +363,7 @@ pub fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n }\n \n pub fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n           _ => ()\n@@ -432,7 +432,7 @@ pub fn enter_match<'r>(bcx: block,\n     let _indenter = indenter();\n \n     let mut result = ~[];\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         match e(br.pats[col]) {\n             Some(sub) => {\n                 let pats =\n@@ -579,8 +579,8 @@ pub fn enter_opt<'r>(bcx: block,\n                     // specified in the struct definition. Also fill in\n                     // unspecified fields with dummy.\n                     let mut reordered_patterns = ~[];\n-                    for ty::lookup_struct_fields(tcx, struct_id).each\n-                        |field| {\n+                    let r = ty::lookup_struct_fields(tcx, struct_id);\n+                    for r.iter().advance |field| {\n                             match field_pats.iter().find_(|p| p.ident == field.ident) {\n                                 None => reordered_patterns.push(dummy),\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n@@ -640,7 +640,7 @@ pub fn enter_rec_or_struct<'r>(bcx: block,\n         match p.node {\n             ast::pat_struct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n-                for fields.each |fname| {\n+                for fields.iter().advance |fname| {\n                     match fpats.iter().find_(|p| p.ident == *fname) {\n                         None => pats.push(dummy),\n                         Some(pat) => pats.push(pat.pat)\n@@ -802,7 +802,7 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     }\n \n     let mut found = ~[];\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         let cur = br.pats[col];\n         match cur.node {\n             ast::pat_lit(l) => {\n@@ -948,7 +948,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n                                        col: uint)\n                                     -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n@@ -962,7 +962,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     return fields;\n \n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n-        for field_pats.each |field_pat| {\n+        for field_pats.iter().advance |field_pat| {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any_(|x| *x == field_ident) {\n                 idents.push(field_ident);\n@@ -987,7 +987,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n                               col: uint,\n                               val: ValueRef)\n                            -> block {\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n             let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n@@ -1056,14 +1056,14 @@ pub fn pick_col(m: &[@Match]) -> uint {\n         }\n     }\n     let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         let mut i = 0u;\n-        for br.pats.each |p| { scores[i] += score(*p); i += 1u; }\n+        for br.pats.iter().advance |p| { scores[i] += score(*p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    for scores.each |score| {\n+    for scores.iter().advance |score| {\n         let score = *score;\n \n         // Irrefutable columns always go first, they'd only be duplicated in\n@@ -1236,7 +1236,7 @@ pub fn compile_guard(bcx: block,\n     let val = bool_to_i1(bcx, val);\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n-    for temp_cleanups.each |llval| {\n+    for temp_cleanups.iter().advance |llval| {\n         revoke_clean(bcx, *llval);\n     }\n \n@@ -1314,7 +1314,7 @@ pub fn compile_submatch(bcx: block,\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();\n-    for m.each |br| {\n+    for m.iter().advance |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n@@ -1442,7 +1442,7 @@ pub fn compile_submatch(bcx: block,\n             }\n         }\n     }\n-    for opts.each |o| {\n+    for opts.iter().advance |o| {\n         match *o {\n             range(_, _) => { kind = compare; break }\n             _ => ()\n@@ -1464,7 +1464,7 @@ pub fn compile_submatch(bcx: block,\n     let mut i = 0u;\n \n     // Compile subtrees for each option\n-    for opts.each |opt| {\n+    for opts.iter().advance |opt| {\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -1680,7 +1680,7 @@ pub fn trans_match_inner(scope_cx: block,\n                                  arm: arm,\n                                  bindings_map: bindings_map};\n         arm_datas.push(arm_data);\n-        for arm.pats.each |p| {\n+        for arm.pats.iter().advance |p| {\n             matches.push(@Match {pats: ~[*p], data: arm_data});\n         }\n     }\n@@ -1701,7 +1701,7 @@ pub fn trans_match_inner(scope_cx: block,\n     compile_submatch(bcx, matches, [lldiscr], chk);\n \n     let mut arm_cxs = ~[];\n-    for arm_datas.each |arm_data| {\n+    for arm_datas.iter().advance |arm_data| {\n         let mut bcx = arm_data.bodycx;\n \n         // If this arm has a guard, then the various by-value bindings have\n@@ -1844,7 +1844,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-                for fields.each |f| {\n+                for fields.iter().advance |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                 discr, ix);"}, {"sha": "624c6607859e9af24e5f23a9e9855deab4ea86a0", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -248,7 +248,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             let mut most_aligned = None;\n             let mut largest_align = 0;\n             let mut largest_size = 0;\n-            for sts.each |st| {\n+            for sts.iter().advance |st| {\n                 if largest_size < st.size {\n                     largest_size = st.size;\n                 }"}, {"sha": "3c263b1c01eb6bb16478b0894b6ad8634997fba6", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -64,7 +64,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     };\n \n-    for cleanups.each |c| {\n+    for cleanups.iter().advance |c| {\n         revoke_clean(bcx, *c);\n     }\n     cleanups.clear();\n@@ -85,7 +85,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     };\n \n-    for cleanups.each |c| {\n+    for cleanups.iter().advance |c| {\n         revoke_clean(bcx, *c);\n     }\n "}, {"sha": "ec77fe359b5991887437a4a1061fbba8050d37bd", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -670,7 +670,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                         n_variants);\n                   let next_cx = sub_block(cx, \"enum-iter-next\");\n \n-                  for (*variants).each |variant| {\n+                  for (*variants).iter().advance |variant| {\n                       let variant_cx =\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n                                     int::to_str(variant.disr_val));\n@@ -804,7 +804,7 @@ pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n             debug!(\"invoking %x at %x\",\n                    ::core::cast::transmute(llfn),\n                    ::core::cast::transmute(bcx.llbb));\n-            for llargs.each |&llarg| {\n+            for llargs.iter().advance |&llarg| {\n                 debug!(\"arg: %x\", ::core::cast::transmute(llarg));\n             }\n         }\n@@ -820,7 +820,7 @@ pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n             debug!(\"calling %x at %x\",\n                    ::core::cast::transmute(llfn),\n                    ::core::cast::transmute(bcx.llbb));\n-            for llargs.each |&llarg| {\n+            for llargs.iter().advance |&llarg| {\n                 debug!(\"arg: %x\", ::core::cast::transmute(llarg));\n             }\n         }\n@@ -849,7 +849,7 @@ pub fn need_invoke(bcx: block) -> bool {\n         match cur.kind {\n             block_scope(inf) => {\n                 let inf = &mut *inf; // FIXME(#5074) workaround old borrowck\n-                for inf.cleanups.each |cleanup| {\n+                for inf.cleanups.iter().advance |cleanup| {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n@@ -1366,7 +1366,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n }\n \n pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n-    for b.node.stmts.each |s| {\n+    for b.node.stmts.iter().advance |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n@@ -2046,7 +2046,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::node_id, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n-    for enum_definition.variants.each |variant| {\n+    for enum_definition.variants.iter().advance |variant| {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n@@ -2097,7 +2097,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n                      None,\n                      item.attrs);\n         } else {\n-            for body.node.stmts.each |stmt| {\n+            for body.node.stmts.iter().advance |stmt| {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n@@ -2126,7 +2126,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           consts::trans_const(ccx, expr, item.id);\n           // Do static_assert checking. It can't really be done much earlier because we need to get\n           // the value of the bool out of LLVM\n-          for item.attrs.each |attr| {\n+          for item.attrs.iter().advance |attr| {\n               match attr.node.value.node {\n                   ast::meta_word(x) => {\n                       if x.slice(0, x.len()) == \"static_assert\" {\n@@ -2175,7 +2175,7 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // and control visibility.\n pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n-    for m.items.each |item| {\n+    for m.items.iter().advance |item| {\n         trans_item(ccx, *item);\n     }\n }\n@@ -2549,7 +2549,7 @@ pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n                                                  node: it.id });\n         let mut i = 0;\n         let path = item_path(ccx, it);\n-        for (*enum_definition).variants.each |variant| {\n+        for (*enum_definition).variants.iter().advance |variant| {\n             let p = vec::append(/*bad*/copy path, [\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n@@ -2729,7 +2729,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n         keys.push(k.to_managed());\n     }\n \n-    for keys.each |key| {\n+    for keys.iter().advance |key| {\n         let val = *ccx.module_data.find_equiv(key).get();\n         let s_const = C_cstr(ccx, *key);\n         let s_ptr = p2i(ccx, s_const);"}, {"sha": "ac51c7efc6f0c022b14432289375ef3935e23214", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -133,7 +133,7 @@ impl ABIInfo for ARM_ABIInfo {\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = ~[];\n         let mut attrs = ~[];\n-        for atys.each |&aty| {\n+        for atys.iter().advance |&aty| {\n             let (ty, attr) = classify_arg_ty(aty);\n             arg_tys.push(ty);\n             attrs.push(attr);"}, {"sha": "8604ae37f774857e9887b3221e31fd4f5d989a56", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -189,7 +189,7 @@ impl ABIInfo for MIPS_ABIInfo {\n         let mut attrs = ~[];\n         let mut offset = if sret { 4 } else { 0 };\n \n-        for atys.each() |aty| {\n+        for atys.iter().advance |aty| {\n             let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n             arg_tys.push(ty);\n             attrs.push(attr);"}, {"sha": "14ab17f5030d6a34ac2dcd4675d0701b143bb428", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -176,7 +176,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                        cls: &mut [RegClass], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n-        for tys.each |ty| {\n+        for tys.iter().advance |ty| {\n             field_off = align(field_off, *ty);\n             classify(*ty, cls, i, field_off);\n             field_off += ty_size(*ty);\n@@ -294,7 +294,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n fn llreg_ty(cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n-        for cls.each |c| {\n+        for cls.iter().advance |c| {\n             if *c != SSEUp {\n                 break;\n             }\n@@ -355,7 +355,7 @@ fn x86_64_tys(atys: &[Type],\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n-    for atys.each |t| {\n+    for atys.iter().advance |t| {\n         let (ty, attr) = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n         attrs.push(attr);"}, {"sha": "6120e1e65810d9c7128b02bfa2c9d18d4c0685ab", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -575,7 +575,7 @@ pub fn trans_call_inner(in_cx: block,\n         // Uncomment this to debug calls.\n         /*\n         io::println(fmt!(\"calling: %s\", bcx.val_to_str(llfn)));\n-        for llargs.each |llarg| {\n+        for llargs.iter().advance |llarg| {\n             io::println(fmt!(\"arg: %s\", bcx.val_to_str(*llarg)));\n         }\n         io::println(\"---\");"}, {"sha": "6cff996d0d45f1b2ddacc2906ff42648f75f21cd", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -266,7 +266,7 @@ pub fn build_closure(bcx0: block,\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n-    for cap_vars.each |cap_var| {\n+    for cap_vars.iter().advance |cap_var| {\n         debug!(\"Building closure: captured variable %?\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n@@ -346,7 +346,7 @@ pub fn load_environment(fcx: fn_ctxt,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    for cap_vars.each |cap_var| {\n+    for cap_vars.iter().advance |cap_var| {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n         match sigil {\n             ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }"}, {"sha": "7baa3ec068b8d269e035b1e8054c4ef50955e1b9", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -143,7 +143,7 @@ pub struct param_substs {\n \n impl param_substs {\n     pub fn validate(&self) {\n-        for self.tys.each |t| { assert!(!ty::type_needs_infer(*t)); }\n+        for self.tys.iter().advance |t| { assert!(!ty::type_needs_infer(*t)); }\n         for self.self_ty.iter().advance |t| { assert!(!ty::type_needs_infer(*t)); }\n     }\n }\n@@ -982,7 +982,7 @@ pub fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     let mut r = ~\"\";\n     let mut first = true;\n-    for p.each |e| {\n+    for p.iter().advance |e| {\n         match *e {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first { first = false; }"}, {"sha": "f101a8657322e4386b06ff1735f104f0cf73530e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -40,7 +40,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     do block_locals(b) |local| {\n         bcx = alloc_local(bcx, local);\n     };\n-    for b.node.stmts.each |s| {\n+    for b.node.stmts.iter().advance |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -113,7 +113,7 @@ pub fn trans_if(bcx: block,\n pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n-    for in_cxs.each |bcx| {\n+    for in_cxs.iter().advance |bcx| {\n         if !bcx.unreachable {\n             Br(*bcx, out.llbb);\n             reachable = true;"}, {"sha": "2eadad7d8d1bae9dead432a0cef270d8329c871d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -335,7 +335,7 @@ fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: sp\n     let file_md = create_file(cx, loc.file.name);\n \n     let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, t), file_md, loc.line);\n-    for fields.each |field| {\n+    for fields.iter().advance |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n@@ -362,7 +362,7 @@ fn create_tuple(cx: @mut CrateContext, _t: ty::t, elements: &[ty::t], span: span\n \n     let name = (cx.sess.str_of((dbg_cx(cx).names)(\"tuple\"))).to_owned();\n     let mut scx = StructContext::new(cx, name, file_md, loc.line);\n-    for elements.each |element| {\n+    for elements.iter().advance |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n         scx.add_member(\"\", loc.line, size, align, ty_md);"}, {"sha": "58f04ab3b2ec422f81664f27b62e096db566fa17", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1221,7 +1221,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for fields.each |&(_i, e)| {\n+            for fields.iter().advance |&(_i, e)| {\n                 bcx = trans_into(bcx, e, Ignore);\n             }\n             for optbase.iter().advance |sbi| {\n@@ -1233,7 +1233,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n     };\n     let mut temp_cleanups = ~[];\n     adt::trans_start_init(bcx, repr, addr, discr);\n-    for fields.each |&(i, e)| {\n+    for fields.iter().advance |&(i, e)| {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_into(bcx, e, SaveIn(dest));\n@@ -1253,7 +1253,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n         }\n     }\n \n-    for temp_cleanups.each |cleanup| {\n+    for temp_cleanups.iter().advance |cleanup| {\n         revoke_clean(bcx, *cleanup);\n     }\n     return bcx;"}, {"sha": "10e63e6af77786cbb4fb1490c7d6e0800caf92b5", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -289,7 +289,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         Some(abi) => abi,\n     };\n \n-    for foreign_mod.items.each |&foreign_item| {\n+    for foreign_mod.items.iter().advance |&foreign_item| {\n         match foreign_item.node {\n             ast::foreign_item_fn(*) => {\n                 let id = foreign_item.id;"}, {"sha": "f55523b2841882064c4a61f94585974b84761aed", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -130,7 +130,7 @@ pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n             // Compute max(variant sizes).\n             let mut max_size = 0;\n             let variants = ty::enum_variants(cx.tcx, tid);\n-            for variants.each |variant| {\n+            for variants.iter().advance |variant| {\n                 if variant.args.len() == 0 {\n                     loop;\n                 }"}, {"sha": "0b68ae5ee1718bf81283f6bd73f07060cfc17aca", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -59,7 +59,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n \n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    for methods.each |method| {\n+    for methods.iter().advance |method| {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(/*bad*/copy sub_path,\n@@ -175,7 +175,7 @@ pub fn trans_self_arg(bcx: block,\n \n     // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n     // should be revoked only after all arguments have been passed.\n-    for temp_cleanups.each |c| {\n+    for temp_cleanups.iter().advance |c| {\n         revoke_clean(bcx, *c)\n     }\n \n@@ -406,7 +406,7 @@ pub fn method_with_name_or_default(ccx: @mut CrateContext,\n         let pmm = ccx.tcx.provided_methods;\n         match pmm.find(&impl_id) {\n             Some(pmis) => {\n-                for pmis.each |pmi| {\n+                for pmis.iter().advance |pmi| {\n                     if pmi.method_info.ident == name {\n                         debug!(\"pmi.method_info.did = %?\",\n                                pmi.method_info.did);\n@@ -773,7 +773,7 @@ pub fn make_vtable(ccx: @mut CrateContext,\n         let _icx = push_ctxt(\"impl::make_vtable\");\n \n         let mut components = ~[ tydesc.tydesc ];\n-        for ptrs.each |&ptr| {\n+        for ptrs.iter().advance |&ptr| {\n             components.push(ptr)\n         }\n "}, {"sha": "fd382a869dfa67922b618ff7242db93c1472efbf", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -69,8 +69,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         }\n     });\n \n-    for real_substs.tps.each() |s| { assert!(!ty::type_has_params(*s)); }\n-    for substs.each() |s| { assert!(!ty::type_has_params(*s)); }\n+    for real_substs.tps.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n+    for substs.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n                                Some(param_uses));\n@@ -340,7 +340,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n         let mut i = 0;\n         vec::map_zip(*item_ty.generics.type_param_defs, substs, |type_param_def, subst| {\n             let mut v = ~[];\n-            for type_param_def.bounds.trait_bounds.each |_bound| {\n+            for type_param_def.bounds.trait_bounds.iter().advance |_bound| {\n                 v.push(meth::vtable_id(ccx, &vts[i]));\n                 i += 1;\n             }"}, {"sha": "5cb52d2a057979d6034ae705d48d40f580e11d29", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -59,7 +59,7 @@ fn traverse_exports(cx: @mut ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n     match cx.exp_map2.find(&mod_id) {\n       Some(ref exp2s) => {\n-        for (*exp2s).each |e2| {\n+        for (*exp2s).iter().advance |e2| {\n             found_export = true;\n             traverse_def_id(cx, e2.def_id)\n         };\n@@ -90,7 +90,7 @@ fn traverse_def_id(cx: @mut ctx, did: def_id) {\n fn traverse_public_mod(cx: @mut ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n-        for m.items.each |item| {\n+        for m.items.iter().advance |item| {\n             traverse_public_item(cx, *item);\n         }\n     }\n@@ -109,7 +109,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n       item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n-              for nm.items.each |item| {\n+              for nm.items.iter().advance |item| {\n                   let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n                   cx.rmap.insert(item.id);\n               }\n@@ -122,7 +122,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n         }\n       }\n       item_impl(ref generics, _, _, ref ms) => {\n-        for ms.each |m| {\n+        for ms.iter().advance |m| {\n             if generics.ty_params.len() > 0u ||\n                 m.generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n@@ -168,7 +168,7 @@ fn traverse_ty<'a>(ty: @Ty, (cx, v): (@mut ctx<'a>, visit::vt<@mut ctx<'a>>)) {\n           Some(&d) => traverse_def_id(cx, def_id_of_def(d)),\n           None    => { /* do nothing -- but should we fail here? */ }\n         }\n-        for p.types.each |t| {\n+        for p.types.iter().advance |t| {\n             (v.visit_ty)(*t, (cx, v));\n         }\n       }"}, {"sha": "df8de7b7cd5aa2bca6e191432e34447f1b41b40f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -376,7 +376,7 @@ pub fn write_content(bcx: block,\n         ast::expr_vec(ref elements, _) => {\n             match dest {\n                 Ignore => {\n-                    for elements.each |element| {\n+                    for elements.iter().advance |element| {\n                         bcx = expr::trans_into(bcx, *element, Ignore);\n                     }\n                 }\n@@ -392,7 +392,7 @@ pub fn write_content(bcx: block,\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n                         temp_cleanups.push(lleltptr);\n                     }\n-                    for temp_cleanups.each |cleanup| {\n+                    for temp_cleanups.iter().advance |cleanup| {\n                         revoke_clean(bcx, *cleanup);\n                     }\n                 }"}, {"sha": "49cb3bd51ddb3f2a5c42814206c49d5ba89dddd9", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -78,7 +78,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-            for sig.inputs.each |arg| {\n+            for sig.inputs.iter().advance |arg| {\n                 type_needs(cx, use_repr, *arg);\n             }\n         }\n@@ -214,7 +214,7 @@ pub fn type_needs_inner(cx: Context,\n                 if list::find(enums_seen, |id| *id == did).is_none() {\n                     let seen = @Cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n-                        for v.args.each |aty| {\n+                        for v.args.iter().advance |aty| {\n                             let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }\n@@ -314,7 +314,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n           match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n               ast::OwnedSigil => {}\n               ast::BorrowedSigil | ast::ManagedSigil => {\n-                  for freevars::get_freevars(cx.ccx.tcx, e.id).each |fv| {\n+                  for freevars::get_freevars(cx.ccx.tcx, e.id).iter().advance |fv| {\n                       let node_id = ast_util::def_id_of_def(fv.def).node;\n                       node_type_needs(cx, use_repr, node_id);\n                   }\n@@ -344,25 +344,27 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {\n-          for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)).each |a| {\n+          let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id));\n+          for r.iter().advance |a| {\n               type_needs(cx, use_repr, *a);\n           }\n       }\n       expr_method_call(callee_id, rcvr, _, _, _, _) => {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, rcvr.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n-        for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, callee_id)).each |a| {\n+        let r = ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, callee_id));\n+        for r.iter().advance |a| {\n             type_needs(cx, use_repr, *a);\n         }\n         mark_for_method_call(cx, e.id, callee_id);\n       }\n \n       expr_inline_asm(ref ia) => {\n-        for ia.inputs.each |&(_, in)| {\n+        for ia.inputs.iter().advance |&(_, in)| {\n           node_type_needs(cx, use_repr, in.id);\n         }\n-        for ia.outputs.each |&(_, out)| {\n+        for ia.outputs.iter().advance |&(_, out)| {\n           node_type_needs(cx, use_repr, out.id);\n         }\n       }"}, {"sha": "a367cf4c430a7b6e1ac7c04ea7f7bb64e8ec6ecd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1018,7 +1018,7 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     }\n     fn sflags(substs: &substs) -> uint {\n         let mut f = 0u;\n-        for substs.tps.each |tt| { f |= get(*tt).flags; }\n+        for substs.tps.iter().advance |tt| { f |= get(*tt).flags; }\n         for substs.self_r.iter().advance |r| { f |= rflags(*r) }\n         return f;\n     }\n@@ -1057,16 +1057,16 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n         flags |= rflags(r);\n         flags |= get(m.ty).flags;\n       }\n-      &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n+      &ty_tup(ref ts) => for ts.iter().advance |tt| { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n-        for f.sig.inputs.each |a| { flags |= get(*a).flags; }\n+        for f.sig.inputs.iter().advance |a| { flags |= get(*a).flags; }\n          flags |= get(f.sig.output).flags;\n          // T -> _|_ is *not* _|_ !\n          flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n         flags |= rflags(f.region);\n-        for f.sig.inputs.each |a| { flags |= get(*a).flags; }\n+        for f.sig.inputs.iter().advance |a| { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n         flags &= !(has_ty_bot as uint);\n@@ -1320,15 +1320,15 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _, _) => {\n-        for (*substs).tps.each |subty| { maybe_walk_ty(*subty, f); }\n+        for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, f); }\n       }\n-      ty_tup(ref ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n+      ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, f); } }\n       ty_bare_fn(ref ft) => {\n-        for ft.sig.inputs.each |a| { maybe_walk_ty(*a, f); }\n+        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n       ty_closure(ref ft) => {\n-        for ft.sig.inputs.each |a| { maybe_walk_ty(*a, f); }\n+        for ft.sig.inputs.iter().advance |a| { maybe_walk_ty(*a, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n     }\n@@ -1772,8 +1772,8 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, ref substs) => {\n-            for (*enum_variants(cx, did)).each |v| {\n-                for v.args.each |aty| {\n+            for (*enum_variants(cx, did)).iter().advance |v| {\n+                for v.args.iter().advance |aty| {\n                     let t = subst(cx, substs, *aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n@@ -2407,24 +2407,25 @@ pub fn type_structurally_contains(cx: ctxt,\n     if test(sty) { return true; }\n     match *sty {\n       ty_enum(did, ref substs) => {\n-        for (*enum_variants(cx, did)).each |variant| {\n-            for variant.args.each |aty| {\n+        for (*enum_variants(cx, did)).iter().advance |variant| {\n+            for variant.args.iter().advance |aty| {\n                 let sty = subst(cx, substs, *aty);\n                 if type_structurally_contains(cx, sty, test) { return true; }\n             }\n         }\n         return false;\n       }\n       ty_struct(did, ref substs) => {\n-        for lookup_struct_fields(cx, did).each |field| {\n+        let r = lookup_struct_fields(cx, did);\n+        for r.iter().advance |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n             if type_structurally_contains(cx, ft, test) { return true; }\n         }\n         return false;\n       }\n \n       ty_tup(ref ts) => {\n-        for ts.each |tt| {\n+        for ts.iter().advance |tt| {\n             if type_structurally_contains(cx, *tt, test) { return true; }\n         }\n         return false;\n@@ -2503,7 +2504,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-        for (*variants).each |variant| {\n+        for (*variants).iter().advance |variant| {\n             let tup_ty = mk_tup(cx, /*bad*/copy variant.args);\n \n             // Perform any type parameter substitutions.\n@@ -2512,7 +2513,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         }\n       }\n       ty_tup(ref elts) => {\n-        for elts.each |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n+        for elts.iter().advance |elt| { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n       ty_estr(vstore_fixed(_)) => result = true,\n       ty_evec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n@@ -3357,14 +3358,14 @@ pub fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n \n pub fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n-    for fields.each |f| { if f.ident == id { return Some(i); } i += 1u; }\n+    for fields.iter().advance |f| { if f.ident == id { return Some(i); } i += 1u; }\n     return None;\n }\n \n pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n-    for fields.each |f| { if f.ident == id { return i; } i += 1u; }\n+    for fields.iter().advance |f| { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n         tcx.sess.str_of(id),\n@@ -4383,7 +4384,7 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &ParamBounds,\n                                         f: &fn(@TraitRef) -> bool) -> bool {\n-    for bounds.trait_bounds.each |&bound_trait_ref| {\n+    for bounds.trait_bounds.iter().advance |&bound_trait_ref| {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];\n         let mut i = 0;\n@@ -4403,7 +4404,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n \n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n-            for supertrait_refs.each |&supertrait_ref| {\n+            for supertrait_refs.iter().advance |&supertrait_ref| {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n                        supertrait_ref.repr(tcx));\n \n@@ -4424,7 +4425,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n-    for type_param_defs.each |type_param_def| {\n+    for type_param_defs.iter().advance |type_param_def| {\n         for each_bound_trait_and_supertraits(tcx, type_param_def.bounds) |_| {\n             total += 1;\n         }"}, {"sha": "de6b792032b1bd1eabf775ae60f726e12ebb5159", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -35,22 +35,22 @@ pub fn check_match(fcx: @mut FnCtxt,\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n-    for arms.each |arm| {\n+    for arms.iter().advance |arm| {\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n             match_region: ty::re_scope(expr.id),\n             block_region: ty::re_scope(arm.body.node.id)\n         };\n \n-        for arm.pats.each |p| { check_pat(&pcx, *p, pattern_ty);}\n+        for arm.pats.iter().advance |p| { check_pat(&pcx, *p, pattern_ty);}\n     }\n \n     // Now typecheck the blocks.\n     let mut result_ty = fcx.infcx().next_ty_var();\n     let mut arm_non_bot = false;\n     let mut saw_err = false;\n-    for arms.each |arm| {\n+    for arms.iter().advance |arm| {\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n@@ -248,7 +248,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n \n     if error_happened {\n         for subpats.iter().advance |pats| {\n-            for pats.each |pat| {\n+            for pats.iter().advance |pat| {\n                 check_pat(pcx, *pat, ty::mk_err());\n             }\n         }\n@@ -280,7 +280,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Typecheck each field.\n     let mut found_fields = HashSet::new();\n-    for fields.each |field| {\n+    for fields.iter().advance |field| {\n         match field_map.find(&field.ident) {\n             Some(&index) => {\n                 let class_field = class_fields[index];\n@@ -516,7 +516,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 fcx.write_ty(pat.id, expected);\n             }\n             _ => {\n-                for elts.each |elt| {\n+                for elts.iter().advance |elt| {\n                     check_pat(pcx, *elt, ty::mk_err());\n                 }\n                 // use terr_tuple_size if both types are tuples\n@@ -565,13 +565,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             (mt, default_region_var)\n           },\n           _ => {\n-              for before.each |&elt| {\n+              for before.iter().advance |&elt| {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n               for slice.iter().advance |&elt| {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n-              for after.each |&elt| {\n+              for after.iter().advance |&elt| {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n               fcx.infcx().type_error_message_str_with_expected(\n@@ -587,7 +587,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               return;\n           }\n         };\n-        for before.each |elt| {\n+        for before.iter().advance |elt| {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n         match slice {\n@@ -600,7 +600,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             }\n             None => ()\n         }\n-        for after.each |elt| {\n+        for after.iter().advance |elt| {\n             check_pat(pcx, *elt, elt_type.ty);\n         }\n         fcx.write_ty(pat.id, expected);"}, {"sha": "33d1377d000d0c7ff19735c9ae2a31a441aae9ee", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -333,14 +333,14 @@ impl<'self> LookupContext<'self> {\n         let trait_map: &mut resolve::TraitMap = &mut self.fcx.ccx.trait_map;\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n         for opt_applicable_traits.iter().advance |applicable_traits| {\n-            for applicable_traits.each |trait_did| {\n+            for applicable_traits.iter().advance |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n \n                 // Look for explicit implementations.\n                 let opt_impl_infos =\n                     coherence_info.extension_methods.find(trait_did);\n                 for opt_impl_infos.iter().advance |impl_infos| {\n-                    for impl_infos.each |impl_info| {\n+                    for impl_infos.iter().advance |impl_info| {\n                         self.push_candidates_from_impl(\n                             self.extension_candidates, *impl_info);\n \n@@ -486,7 +486,7 @@ impl<'self> LookupContext<'self> {\n         }\n         // No method found yet? Check each supertrait\n         if method_info.is_none() {\n-            for ty::trait_supertraits(tcx, did).each() |trait_ref| {\n+            for ty::trait_supertraits(tcx, did).iter().advance |trait_ref| {\n                 let supertrait_methods =\n                     ty::trait_methods(tcx, trait_ref.def_id);\n                 match supertrait_methods.iter().position_(|m| m.ident == self.m_name) {\n@@ -527,7 +527,7 @@ impl<'self> LookupContext<'self> {\n         let opt_impl_infos =\n             self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n         for opt_impl_infos.iter().advance |impl_infos| {\n-            for impl_infos.each |impl_info| {\n+            for impl_infos.iter().advance |impl_info| {\n                 self.push_candidates_from_impl(\n                     self.inherent_candidates, *impl_info);\n             }\n@@ -767,7 +767,7 @@ impl<'self> LookupContext<'self> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region = self.infcx().next_region_var_nb(self.expr.span);\n-        for mutbls.each |mutbl| {\n+        for mutbls.iter().advance |mutbl| {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n                 None => {}"}, {"sha": "fa7959c7872b464a23a3fc9255ec8d6bae40808d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -550,7 +550,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::ident, span)]) {\n     let mut field_names = HashMap::new();\n \n-    for fields.each |p| {\n+    for fields.iter().advance |p| {\n         let (id, sp) = *p;\n         let orig_sp = field_names.find(&id).map_consume(|x| *x);\n         match orig_sp {\n@@ -599,12 +599,12 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n-        for ms.each |m| {\n+        for ms.iter().advance |m| {\n             check_method(ccx, *m);\n         }\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n-        for (*trait_methods).each |trait_method| {\n+        for (*trait_methods).iter().advance |trait_method| {\n             match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n@@ -625,11 +625,11 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_foreign_mod(ref m) => {\n         if m.abis.is_intrinsic() {\n-            for m.items.each |item| {\n+            for m.items.iter().advance |item| {\n                 check_intrinsic_type(ccx, *item);\n             }\n         } else {\n-            for m.items.each |item| {\n+            for m.items.iter().advance |item| {\n                 let tpt = ty::lookup_item_type(ccx.tcx, local_def(item.id));\n                 if tpt.generics.has_type_params() {\n                     ccx.tcx.sess.span_err(\n@@ -1225,7 +1225,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // functions. This is so that we have more information about the types\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n-        for [false, true].each |check_blocks| {\n+        let xs = [false, true];\n+        for xs.iter().advance |check_blocks| {\n             let check_blocks = *check_blocks;\n             debug!(\"check_blocks=%b\", check_blocks);\n \n@@ -1803,14 +1804,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let mut class_field_map = HashMap::new();\n         let mut fields_found = 0;\n-        for field_types.each |field| {\n+        for field_types.iter().advance |field| {\n             class_field_map.insert(field.ident, (field.id, false));\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n-        for ast_fields.each |field| {\n+        for ast_fields.iter().advance |field| {\n             let mut expected_field_type = ty::mk_err();\n \n             let pair = class_field_map.find(&field.node.ident).\n@@ -1856,7 +1857,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n-                for field_types.each |class_field| {\n+                for field_types.iter().advance |class_field| {\n                     let name = class_field.ident;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n@@ -2175,7 +2176,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 _ => mutability = mutbl\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            for args.each |e| {\n+            for args.iter().advance |e| {\n                 check_expr_has_type(fcx, *e, t);\n                 let arg_t = fcx.expr_ty(*e);\n                 if ty::type_is_error(arg_t) {\n@@ -2377,10 +2378,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n       }\n       ast::expr_inline_asm(ref ia) => {\n-          for ia.inputs.each |&(_, in)| {\n+          for ia.inputs.iter().advance |&(_, in)| {\n               check_expr(fcx, in);\n           }\n-          for ia.outputs.each |&(_, out)| {\n+          for ia.outputs.iter().advance |&(_, out)| {\n               check_expr(fcx, out);\n           }\n           fcx.write_nil(id);\n@@ -2506,7 +2507,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             // We know there's at least one because we already checked\n             // for n=0 as well as all arms being _|_ in the previous\n             // `if`.\n-            for arm_tys.each() |arm_ty| {\n+            for arm_tys.iter().advance |arm_ty| {\n                 if !ty::type_is_bot(*arm_ty) {\n                     fcx.write_ty(id, *arm_ty);\n                     break;\n@@ -2687,7 +2688,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let t: ty::t = fcx.infcx().next_ty_var();\n         let mut arg_is_bot = false;\n         let mut arg_is_err = false;\n-        for args.each |e| {\n+        for args.iter().advance |e| {\n             check_expr_has_type(fcx, *e, t);\n             let arg_t = fcx.expr_ty(*e);\n             arg_is_bot |= ty::type_is_bot(arg_t);\n@@ -2948,7 +2949,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n         let mut last_was_bot = false;\n         let mut any_bot = false;\n         let mut any_err = false;\n-        for blk.node.stmts.each |s| {\n+        for blk.node.stmts.iter().advance |s| {\n             check_stmt(fcx, *s);\n             let s_id = ast_util::stmt_id(*s);\n             let s_ty = fcx.node_ty(s_id);\n@@ -3085,7 +3086,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 disr_val: &mut int,\n                 variants: &mut ~[ty::VariantInfo]) {\n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        for vs.each |v| {\n+        for vs.iter().advance |v| {\n             for v.node.disr_expr.iter().advance |e_ref| {\n                 let e = *e_ref;\n                 debug!(\"disr expr, checking %s\","}, {"sha": "ac89c48a29b2c679fc80a1164cd2b32990ff939e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -184,7 +184,7 @@ fn visit_block(b: &ast::blk, (rcx, v): (@mut Rcx, rvt)) {\n \n fn visit_arm(arm: &ast::arm, (rcx, v): (@mut Rcx, rvt)) {\n     // see above\n-    for arm.pats.each |&p| {\n+    for arm.pats.iter().advance |&p| {\n         constrain_bindings_in_pat(p, rcx);\n     }\n \n@@ -267,7 +267,7 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n         }\n         ast::expr_match(_, ref arms) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n-            for arms.each |arm| {\n+            for arms.iter().advance |arm| {\n                 for arm.guard.iter().advance |guard| {\n                     tcx.region_maps.record_cleanup_scope(guard.id);\n                 }\n@@ -476,7 +476,7 @@ fn constrain_call(rcx: @mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::re_scope(callee_scope);\n \n-    for arg_exprs.each |&arg_expr| {\n+    for arg_exprs.iter().advance |&arg_expr| {\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n@@ -614,7 +614,7 @@ fn constrain_free_variables(rcx: @mut Rcx,\n     let tcx = rcx.fcx.ccx.tcx;\n     debug!(\"constrain_free_variables(%s, %s)\",\n            region.repr(tcx), expr.repr(tcx));\n-    for get_freevars(tcx, expr.id).each |freevar| {\n+    for get_freevars(tcx, expr.id).iter().advance |freevar| {\n         debug!(\"freevar def is %?\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n@@ -824,8 +824,8 @@ pub mod guarantor {\n         debug!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n         debug!(\"discr_guarantor=%s\", discr_guarantor.repr(rcx.tcx()));\n-        for arms.each |arm| {\n-            for arm.pats.each |pat| {\n+        for arms.iter().advance |arm| {\n+            for arm.pats.iter().advance |pat| {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n             }\n         }\n@@ -1217,7 +1217,7 @@ pub mod guarantor {\n                 link_ref_bindings_in_pats(rcx, pats, guarantor);\n             }\n             ast::pat_struct(_, ref fpats, _) => {\n-                for fpats.each |fpat| {\n+                for fpats.iter().advance |fpat| {\n                     link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n                 }\n             }\n@@ -1258,7 +1258,7 @@ pub mod guarantor {\n     fn link_ref_bindings_in_pats(rcx: @mut Rcx,\n                                  pats: &~[@ast::pat],\n                                  guarantor: Option<ty::Region>) {\n-        for pats.each |pat| {\n+        for pats.iter().advance |pat| {\n             link_ref_bindings_in_pat(rcx, *pat, guarantor);\n         }\n     }"}, {"sha": "160737142c8ca75e47c44333d6a3ba32c7a15490", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -231,7 +231,7 @@ pub fn relate_nested_regions(\n               r_sub: ty::Region,\n               relate_op: &fn(ty::Region, ty::Region))\n     {\n-        for the_stack.each |&r| {\n+        for the_stack.iter().advance |&r| {\n             if !r.is_bound() && !r_sub.is_bound() {\n                 relate_op(r, r_sub);\n             }\n@@ -259,14 +259,14 @@ pub fn relate_free_regions(\n     debug!(\"relate_free_regions >>\");\n \n     let mut all_tys = ~[];\n-    for fn_sig.inputs.each |arg| {\n+    for fn_sig.inputs.iter().advance |arg| {\n         all_tys.push(*arg);\n     }\n     for self_ty.iter().advance |&t| {\n         all_tys.push(t);\n     }\n \n-    for all_tys.each |&t| {\n+    for all_tys.iter().advance |&t| {\n         debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {"}, {"sha": "5ce95e23e2c7a4907166b610aed5dba068b04f52", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -88,7 +88,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n     let mut result = ~[];\n     let mut i = 0u;\n-    for substs.tps.each |ty| {\n+    for substs.tps.iter().advance |ty| {\n         // ty is the value supplied for the type parameter A...\n \n         for ty::each_bound_trait_and_supertraits("}, {"sha": "dd9d68beb1fd54d36c717cb35128266bc10f9b3c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -175,7 +175,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n         write_ty_to_tcx(tcx, id, t);\n         for fcx.opt_node_ty_substs(id) |substs| {\n           let mut new_tps = ~[];\n-          for substs.tps.each |subst| {\n+          for substs.tps.iter().advance |subst| {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),\n                 None => { wbcx.success = false; return None; }\n@@ -240,7 +240,7 @@ fn visit_expr(e: @ast::expr, (wbcx, v): (@mut WbCtxt, wb_vt)) {\n \n     match e.node {\n         ast::expr_fn_block(ref decl, _) => {\n-            for decl.inputs.each |input| {\n+            for decl.inputs.iter().advance |input| {\n                 let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n         }\n@@ -341,7 +341,7 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                    self_info.span,\n                                    self_info.self_id);\n     }\n-    for decl.inputs.each |arg| {\n+    for decl.inputs.iter().advance |arg| {\n         do pat_util::pat_bindings(fcx.tcx().def_map, arg.pat)\n                 |_bm, pat_id, span, _path| {\n             resolve_type_vars_for_node(wbcx, span, pat_id);"}, {"sha": "bf935d92c75c3b90b1f5fe9818f1d1761b67dd92", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -270,7 +270,7 @@ impl CoherenceChecker {\n         // We only want to generate one Impl structure. When we generate one,\n         // we store it here so that we don't recreate it.\n         let mut implementation_opt = None;\n-        for associated_traits.each |&associated_trait| {\n+        for associated_traits.iter().advance |&associated_trait| {\n             let trait_ref =\n                 ty::node_id_to_trait_ref(\n                     self.crate_context.tcx,\n@@ -536,11 +536,12 @@ impl CoherenceChecker {\n         // XXX: This is horrible.\n         let mut provided_method_idents = HashSet::new();\n         let tcx = self.crate_context.tcx;\n-        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+        let r = ty::provided_trait_methods(tcx, trait_did);\n+        for r.iter().advance |ident| {\n             provided_method_idents.insert(*ident);\n         }\n \n-        for ty::trait_methods(tcx, trait_did).each |&method| {\n+        for ty::trait_methods(tcx, trait_did).iter().advance |&method| {\n             if provided_method_idents.contains(&method.ident) {\n                 if !f(method) {\n                     return false;\n@@ -611,7 +612,8 @@ impl CoherenceChecker {\n             if result.is_ok() {\n                 // Check to ensure that each parameter binding respected its\n                 // kind bounds.\n-                for [ a, b ].each |result| {\n+                let xs = [a, b];\n+                for xs.iter().advance |result| {\n                     for result.type_variables.iter()\n                         .zip(result.type_param_defs.iter())\n                         .advance |(ty_var, type_param_def)|\n@@ -728,12 +730,14 @@ impl CoherenceChecker {\n             provided_names.insert(all_methods[i].ident);\n         }\n         // Default methods\n-        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+        let r = ty::provided_trait_methods(tcx, trait_did);\n+        for r.iter().advance |ident| {\n             debug!(\"inserting provided method %s\", ident.repr(tcx));\n             provided_names.insert(*ident);\n         }\n \n-        for (*ty::trait_methods(tcx, trait_did)).each |method| {\n+        let r = ty::trait_methods(tcx, trait_did);\n+        for r.iter().advance |method| {\n             debug!(\"checking for %s\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident) { loop; }\n \n@@ -802,7 +806,7 @@ impl CoherenceChecker {\n                     debug!(\"(creating impl) trait with node_id `%d` \\\n                             has provided methods\", trait_did.node);\n                     // Add all provided methods.\n-                    for all_provided_methods.each |provided_method| {\n+                    for all_provided_methods.iter().advance |provided_method| {\n                         debug!(\n                             \"(creating impl) adding provided method \\\n                              `%s` to impl\",\n@@ -821,7 +825,7 @@ impl CoherenceChecker {\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n-                for ast_methods.each |ast_method| {\n+                for ast_methods.iter().advance |ast_method| {\n                     methods.push(method_to_MethodInfo(*ast_method));\n                 }\n \n@@ -882,7 +886,7 @@ impl CoherenceChecker {\n         let implementations = get_impls_for_mod(crate_store,\n                                                 module_def_id,\n                                                 None);\n-        for implementations.each |implementation| {\n+        for implementations.iter().advance |implementation| {\n             debug!(\"coherence: adding impl from external crate: %s\",\n                    ty::item_path_str(self.crate_context.tcx,\n                                      implementation.did));\n@@ -1009,7 +1013,7 @@ impl CoherenceChecker {\n             Some(found_impls) => impls = found_impls\n         }\n \n-        for impls.each |impl_info| {\n+        for impls.iter().advance |impl_info| {\n             if impl_info.methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 loop;"}, {"sha": "7f820d11ac6142e69dfbbf8a78cbbff7b25d151e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -66,13 +66,13 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n     // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n     // There ought to be a better approach. Attributes?\n \n-    for crate.node.module.items.each |crate_item| {\n+    for crate.node.module.items.iter().advance |crate_item| {\n         if crate_item.ident\n             == ::syntax::parse::token::special_idents::intrinsic {\n \n             match crate_item.node {\n               ast::item_mod(ref m) => {\n-                for m.items.each |intrinsic_item| {\n+                for m.items.iter().advance |intrinsic_item| {\n                     let def_id = ast::def_id { crate: ast::local_crate,\n                                                node: intrinsic_item.id };\n                     let substs = substs {\n@@ -168,7 +168,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n-    for variants.each |variant| {\n+    for variants.iter().advance |variant| {\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n \n@@ -233,7 +233,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.methods` table:\n-            for ms.each |m| {\n+            for ms.iter().advance |m| {\n                 let ty_method = @match m {\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n@@ -416,7 +416,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n-    for ast_trait_refs.each |&ast_trait_ref| {\n+    for ast_trait_refs.iter().advance |&ast_trait_ref| {\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n \n@@ -686,7 +686,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // Trait methods we don't implement must be default methods, but if not\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n-    for impl_ms.each |impl_m| {\n+    for impl_ms.iter().advance |impl_m| {\n         match trait_ms.iter().find_(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n@@ -921,7 +921,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members\n-    for struct_def.fields.each |f| {\n+    for struct_def.fields.iter().advance |f| {\n        convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);\n     }\n     let (_, substs) = mk_item_substs(ccx, generics, rp, None);"}, {"sha": "a1e16cfbe8388bb312984fe898821ce0cc7aee34", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -223,7 +223,7 @@ impl Combine for Glb {\n             let mut a_r = None;\n             let mut b_r = None;\n             let mut only_new_vars = true;\n-            for tainted.each |r| {\n+            for tainted.iter().advance |r| {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n                         return fresh_bound_variable(this);"}, {"sha": "d9add22479ccec64efb13d05200ee03697b33285", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -1572,8 +1572,8 @@ impl RegionVarBindings {\n             return;\n         }\n \n-        for lower_bounds.each |lower_bound| {\n-            for upper_bounds.each |upper_bound| {\n+        for lower_bounds.iter().advance |lower_bound| {\n+            for upper_bounds.iter().advance |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n \n@@ -1629,8 +1629,8 @@ impl RegionVarBindings {\n             return;\n         }\n \n-        for upper_bounds.each |upper_bound_1| {\n-            for upper_bounds.each |upper_bound_2| {\n+        for upper_bounds.iter().advance |upper_bound_1| {\n+            for upper_bounds.iter().advance |upper_bound_2| {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}"}, {"sha": "4462d43015cfc487273e433fdf97e597f5f65299", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -198,7 +198,7 @@ impl Combine for Sub {\n         for list::each(skol_isr) |pair| {\n             let (skol_br, skol) = *pair;\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n-            for tainted.each |tainted_region| {\n+            for tainted.iter().advance |tainted_region| {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {"}, {"sha": "a3d11bedbdc78a29e45c42745fa2fbd8927ec1f6", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -79,7 +79,7 @@ fn setup_env(test_name: &str, source_string: &str) -> Env {\n \n impl Env {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n-        for rh.sub.each |child_rh| {\n+        for rh.sub.iter().advance |child_rh| {\n             self.create_region_hierarchy(child_rh);\n             self.tcx.region_map.insert(child_rh.id, rh.id);\n         }\n@@ -109,7 +109,7 @@ impl Env {\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n             assert!(idx < names.len());\n-            for m.items.each |item| {\n+            for m.items.iter().advance |item| {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n                     return search(self, *item, idx+1, names);\n                 }\n@@ -227,7 +227,7 @@ impl Env {\n \n         self.infcx.resolve_regions();\n         if self.err_messages.len() != exp_count {\n-            for self.err_messages.each |msg| {\n+            for self.err_messages.iter().advance |msg| {\n                 debug!(\"Error encountered: %s\", *msg);\n             }\n             fmt!(\"Resolving regions encountered %u errors but expected %u!\","}, {"sha": "16b490cd478d4aa97f1b8d9de3568944928ec2cb", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -75,7 +75,7 @@ impl RegionParamNames {\n                             opt_vec::Vec(new_lifetimes.map(|lt| lt.ident)));\n                     }\n                     opt_vec::Vec(ref mut existing_lifetimes) => {\n-                        for new_lifetimes.each |new_lifetime| {\n+                        for new_lifetimes.iter().advance |new_lifetime| {\n                             existing_lifetimes.push(new_lifetime.ident);\n                         }\n                     }"}, {"sha": "d59a308beb53797d26392e168e8814d00cd8ecb9", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -184,7 +184,8 @@ Available lint options:\n \n pub fn describe_debug_flags() {\n     io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n-    for session::debugging_opts_map().each |pair| {\n+    let r = session::debugging_opts_map();\n+    for r.iter().advance |pair| {\n         let (name, desc, _) = /*bad*/copy *pair;\n         io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n     }\n@@ -344,13 +345,14 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n                     diagnostic::ice_msg(\"unexpected failure\"),\n                     diagnostic::error);\n \n-                for [\n+                let xs = [\n                     ~\"the compiler hit an unexpected failure path. \\\n                      this is a bug\",\n                     ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n                      to get further details and report the results \\\n                      to github.com/mozilla/rust/issues\"\n-                ].each |note| {\n+                ];\n+                for xs.iter().advance |note| {\n                     diagnostic::emit(None, *note, diagnostic::note)\n                 }\n             }"}, {"sha": "c730e74c903671f189fb6b6f5899b4ef91d049c3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -395,7 +395,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    /*for ty::type_def_id(typ).each |def_id| {\n+    /*for ty::type_def_id(typ).iter().advance |def_id| {\n         // note that this typedef cannot have type parameters\n         return ast_map::path_to_str(ty::item_path(cx, *def_id),\n                                     cx.sess.intr());\n@@ -573,7 +573,7 @@ impl Repr for ty::ParamBounds {\n                 ty::BoundSized => ~\"Sized\",\n             });\n         }\n-        for self.trait_bounds.each |t| {\n+        for self.trait_bounds.iter().advance |t| {\n             res.push(t.repr(tcx));\n         }\n         res.connect(\"+\")"}, {"sha": "52851b9100a4068fc5a0e98d981f82d82e88c2e9", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -76,7 +76,8 @@ pub fn usage() {\n \n     println(\"Usage: rustdoc [options] <cratefile>\\n\");\n     println(\"Options:\\n\");\n-    for opts().each |opt| {\n+    let r = opts();\n+    for r.iter().advance |opt| {\n         println(fmt!(\"    %s\", opt.second()));\n     }\n     println(\"\");"}, {"sha": "b6131dce9c859d5798c67213912659da4cd79ef4", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -144,7 +144,7 @@ fn nmoddoc_from_mod(\n     module_: ast::foreign_mod\n ) -> doc::NmodDoc {\n     let mut fns = ~[];\n-    for module_.items.each |item| {\n+    for module_.items.iter().advance |item| {\n         let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n         match item.node {\n           ast::foreign_item_fn(*) => {"}, {"sha": "6622ea1551bf915ce868d2044bd6e95f0cca2926", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -280,7 +280,7 @@ fn write_desc(\n }\n \n fn write_sections(ctxt: &Ctxt, sections: &[doc::Section]) {\n-    for sections.each |section| {\n+    for sections.iter().advance |section| {\n         write_section(ctxt, copy *section);\n     }\n }\n@@ -300,7 +300,7 @@ fn write_mod_contents(\n         write_index(ctxt, doc.index.get_ref());\n     }\n \n-    for doc.items.each |itemTag| {\n+    for doc.items.iter().advance |itemTag| {\n         write_item(ctxt, copy *itemTag);\n     }\n }\n@@ -350,7 +350,7 @@ fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n     ctxt.w.put_line(~\"<div class='index'>\");\n     ctxt.w.put_line(~\"\");\n \n-    for index.entries.each |entry| {\n+    for index.entries.iter().advance |entry| {\n         let header = header_text_(entry.kind, entry.name);\n         let id = copy entry.link;\n         if entry.brief.is_some() {\n@@ -371,7 +371,7 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n         write_index(ctxt, doc.index.get_ref());\n     }\n \n-    for doc.fns.each |FnDoc| {\n+    for doc.fns.iter().advance |FnDoc| {\n         write_item_header(ctxt, doc::FnTag(copy *FnDoc));\n         write_fn(ctxt, copy *FnDoc);\n     }\n@@ -441,7 +441,7 @@ fn write_variants(\n \n     write_header_(ctxt, H4, ~\"Variants\");\n \n-    for docs.each |variant| {\n+    for docs.iter().advance |variant| {\n         write_variant(ctxt, copy *variant);\n     }\n \n@@ -480,7 +480,7 @@ fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n }\n \n fn write_methods(ctxt: &Ctxt, docs: &[doc::MethodDoc]) {\n-    for docs.each |doc| {\n+    for docs.iter().advance |doc| {\n         write_method(ctxt, copy *doc);\n     }\n }"}, {"sha": "91fde3e21ae0b5118f29bfc09b9ed1582438294a", "filename": "src/librusti/program.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -112,7 +112,7 @@ impl Program {\n             None => {}\n         }\n \n-        for new_locals.each |p| {\n+        for new_locals.iter().advance |p| {\n             code.push_str(fmt!(\"assert_encodable(&%s);\\n\", *p.first_ref()));\n         }\n         code.push_str(\"};}\");\n@@ -370,7 +370,7 @@ impl Program {\n         // helper functions to perform ast iteration\n         fn each_user_local(blk: &ast::blk, f: &fn(@ast::local)) {\n             do find_user_block(blk) |blk| {\n-                for blk.node.stmts.each |stmt| {\n+                for blk.node.stmts.iter().advance |stmt| {\n                     match stmt.node {\n                         ast::stmt_decl(d, _) => {\n                             match d.node {\n@@ -385,7 +385,7 @@ impl Program {\n         }\n \n         fn find_user_block(blk: &ast::blk, f: &fn(&ast::blk)) {\n-            for blk.node.stmts.each |stmt| {\n+            for blk.node.stmts.iter().advance |stmt| {\n                 match stmt.node {\n                     ast::stmt_semi(e, _) => {\n                         match e.node {"}, {"sha": "57a2a48a0f634d8ab2c2c153d993d36cd86120a8", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -130,7 +130,7 @@ fn run(mut repl: Repl, input: ~str) -> Repl {\n     do find_main(crate, sess) |blk| {\n         // Fish out all the view items, be sure to record 'extern mod' items\n         // differently beause they must appear before all 'use' statements\n-        for blk.node.view_items.each |vi| {\n+        for blk.node.view_items.iter().advance |vi| {\n             let s = do with_pp(intr) |pp, _| {\n                 pprust::print_view_item(pp, *vi);\n             };\n@@ -144,7 +144,7 @@ fn run(mut repl: Repl, input: ~str) -> Repl {\n \n         // Iterate through all of the block's statements, inserting them into\n         // the correct portions of the program\n-        for blk.node.stmts.each |stmt| {\n+        for blk.node.stmts.iter().advance |stmt| {\n             let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n             match stmt.node {\n                 ast::stmt_decl(d, _) => {\n@@ -248,7 +248,7 @@ fn run(mut repl: Repl, input: ~str) -> Repl {\n \n     fn find_main(crate: @ast::crate, sess: session::Session,\n                  f: &fn(&ast::blk)) {\n-        for crate.node.module.items.each |item| {\n+        for crate.node.module.items.iter().advance |item| {\n             match item.node {\n                 ast::item_fn(_, _, _, _, ref blk) => {\n                     if item.ident == sess.ident_of(\"main\") {\n@@ -365,7 +365,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n         }\n         ~\"load\" => {\n             let mut loaded_crates: ~[~str] = ~[];\n-            for args.each |arg| {\n+            for args.iter().advance |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n                     (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n@@ -377,7 +377,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                     None => { }\n                 }\n             }\n-            for loaded_crates.each |crate| {\n+            for loaded_crates.iter().advance |crate| {\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n                 repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));"}, {"sha": "9b727e9d3e05980cf84e66f7a0d20762f4688f93", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -147,7 +147,7 @@ impl PkgSrc {\n         assert!(p.components.len() > prefix);\n         let mut sub = Path(\"\");\n         for vec::slice(p.components, prefix,\n-                       p.components.len()).each |c| {\n+                       p.components.len()).iter().advance |c| {\n             sub = sub.push(*c);\n         }\n         debug!(\"found crate %s\", sub.to_str());\n@@ -204,7 +204,7 @@ impl PkgSrc {\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n-        for crates.each |&crate| {\n+        for crates.iter().advance |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));"}, {"sha": "6d146145f36f103c739fdba9ed09d0ba5574f99a", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -43,7 +43,8 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n-    for os::list_dir(&src_dir).each |&p| {\n+    let dirs = os::list_dir(&src_dir);\n+    for dirs.iter().advance |&p| {\n         let p = Path(p);\n         debug!(\"=> p = %s\", p.to_str());\n         if !os::path_is_dir(&src_dir.push_rel(&p)) {\n@@ -93,7 +94,7 @@ pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n /// Returns a src for pkgid that does exist -- None if none of them do\n pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let rs = pkgid_src_in_workspace(pkgid, workspace);\n-    for rs.each |p| {\n+    for rs.iter().advance |p| {\n         if os::path_exists(p) {\n             return Some(copy *p);\n         }\n@@ -189,7 +190,7 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n \n     let mut result_filename = None;\n-    for dir_contents.each |&p| {\n+    for dir_contents.iter().advance |&p| {\n         let mut which = 0;\n         let mut hash = None;\n         let p_path = Path(p);"}, {"sha": "973b960008be409c7b9442c06200a2c7caa5d67c", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -272,7 +272,7 @@ fn touch_source_file(workspace: &Path, short_name: &str) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.push(\"src\").push(short_name);\n     let contents = os::list_dir(&pkg_src_dir);\n-    for contents.each() |p| {\n+    for contents.iter().advance |p| {\n         if Path(copy *p).filetype() == Some(~\".rs\") {\n             // should be able to do this w/o a process\n             if run::process_output(\"touch\", [p.to_str()]).status != 0 {\n@@ -289,7 +289,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId) {\n     let pkg_src_dir = workspace.push(\"src\").push(pkgid.to_str());\n     let contents = os::list_dir(&pkg_src_dir);\n     let mut maybe_p = None;\n-    for contents.each() |p| {\n+    for contents.iter().advance |p| {\n         if Path(copy *p).filetype() == Some(~\".rs\") {\n             maybe_p = Some(p);\n             break;"}, {"sha": "6d39495002a4e561da5ab7f435f9cb3048b0794d", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -103,10 +103,10 @@ fn fold_item(ctx: @mut ReadyCtx,\n     if attrs.len() > 0 {\n         let mut cmds = ~[];\n \n-        for attrs.each |attr| {\n+        for attrs.iter().advance |attr| {\n             match attr.node.value.node {\n                 ast::meta_list(_, ref mis) => {\n-                    for mis.each |mi| {\n+                    for mis.iter().advance |mi| {\n                         match mi.node {\n                             ast::meta_word(cmd) => cmds.push(cmd.to_owned()),\n                             _ => {}\n@@ -211,7 +211,7 @@ pub fn compile_input(ctxt: &Ctx,\n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n-    for addl_lib_search_paths.each() |p| {\n+    for addl_lib_search_paths.iter().advance |p| {\n         assert!(os::path_is_dir(p));\n     }\n \n@@ -280,7 +280,7 @@ pub fn compile_crate_from_input(input: &driver::input,\n \n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     debug!(\"additional libraries:\");\n-    for sess.opts.addl_lib_search_paths.each |lib| {\n+    for sess.opts.addl_lib_search_paths.iter().advance |lib| {\n         debug!(\"an additional library: %s\", lib.to_str());\n     }\n \n@@ -311,7 +311,7 @@ pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n                      what: OutputType) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n-    for flags.each |&fl| {\n+    for flags.iter().advance |&fl| {\n         debug!(\"+++ %s\", fl);\n     }\n     compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)"}, {"sha": "bd576dc44a46738cd1e6a9c18a447d712f288b84", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -25,7 +25,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n                    pkgid.remote_path.to_str(),\n                    rust_path().to_str());\n     }\n-    for workspaces.each |ws| {\n+    for workspaces.iter().advance |ws| {\n         if action(ws) {\n             break;\n         }\n@@ -36,4 +36,4 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n     rust_path().filtered(|ws|\n         workspace_contains_package_id(pkgid, ws))\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2b846c923c48fc1362c8d46935433648b74ef1f5", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -12,13 +12,14 @@\n \n use cast::transmute;\n use container::Container;\n+use iterator::IteratorUtil;\n use kinds::Copy;\n use old_iter;\n-use old_iter::BaseIter;\n use option::Option;\n use sys;\n use uint;\n use vec;\n+use vec::ImmutableVector;\n \n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n@@ -107,7 +108,7 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n #[inline]\n pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for lhs.each |x| { push(copy *x); }\n+        for lhs.iter().advance |x| { push(copy *x); }\n         for uint::range(0, rhs.len()) |i| { push(copy rhs[i]); }\n     }\n }\n@@ -116,7 +117,7 @@ pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n-        for v.each |elem| {\n+        for v.iter().advance |elem| {\n             push(f(elem));\n         }\n     }"}, {"sha": "b6da93f9d40ab53b6fdf189ab631a23dfedf81c0", "filename": "src/libstd/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -15,11 +15,11 @@\n use container::Container;\n use cmp::Eq;\n use kinds::Copy;\n-use old_iter::BaseIter;\n+use iterator::IteratorUtil;\n use result::Result;\n use result;\n use vec;\n-use vec::OwnedVector;\n+use vec::{OwnedVector, ImmutableVector};\n \n /// The either type\n #[deriving(Clone, Eq)]\n@@ -45,7 +45,7 @@ pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n /// Extracts from a vector of either all the left values\n pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     do vec::build_sized(eithers.len()) |push| {\n-        for eithers.each |elt| {\n+        for eithers.iter().advance |elt| {\n             match *elt {\n                 Left(ref l) => { push(copy *l); }\n                 _ => { /* fallthrough */ }\n@@ -57,7 +57,7 @@ pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n /// Extracts from a vector of either all the right values\n pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     do vec::build_sized(eithers.len()) |push| {\n-        for eithers.each |elt| {\n+        for eithers.iter().advance |elt| {\n             match *elt {\n                 Right(ref r) => { push(copy *r); }\n                 _ => { /* fallthrough */ }"}, {"sha": "8e88bfb463291f493c73ad4d16462032317a9eea", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -22,10 +22,11 @@\n #[allow(missing_doc)];\n \n use container::Container;\n-use old_iter::BaseIter;\n+use iterator::IteratorUtil;\n use rt::io::Writer;\n use to_bytes::IterBytes;\n use uint;\n+use vec::ImmutableVector;\n \n // Alias `SipState` to `State`.\n pub use State = hash::SipState;\n@@ -367,7 +368,7 @@ impl Streaming for SipState {\n     fn result_str(&mut self) -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n-        for r.each |b| {\n+        for r.iter().advance |b| {\n             s += uint::to_str_radix(*b as uint, 16u);\n         }\n         s\n@@ -469,7 +470,7 @@ mod tests {\n \n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n-            for (*r).each |b| {\n+            for r.iter().advance |b| {\n                 s += uint::to_str_radix(*b as uint, 16u);\n             }\n             s"}, {"sha": "02fa2de4b032cc715485b34da6536cc61a9a4965", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -20,12 +20,13 @@ use cmp::{Eq, Equiv};\n use hash::Hash;\n use old_iter::BaseIter;\n use old_iter;\n-use iterator::{IteratorUtil};\n+use iterator::IteratorUtil;\n use option::{None, Option, Some};\n use rand::RngUtil;\n use rand;\n use uint;\n use vec;\n+use vec::ImmutableVector;\n use kinds::Copy;\n use util::{replace, unreachable};\n \n@@ -310,7 +311,7 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n \n     /// Visit all key-value pairs\n     fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n-        for self.buckets.each |bucket| {\n+        for self.buckets.iter().advance |bucket| {\n             for bucket.iter().advance |pair| {\n                 if !blk(&pair.key, &pair.value) {\n                     return false;"}, {"sha": "fc0b4da79bd88364923f993a45fbdada7223da83", "filename": "src/libstd/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -57,15 +57,15 @@ use os;\n use cast;\n use path::Path;\n use ops::Drop;\n-use old_iter::{BaseIter, CopyableIter};\n+use iterator::IteratorUtil;\n use ptr;\n use result;\n use str;\n use str::StrSlice;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{OwnedVector, OwnedCopyableVector, CopyableVector};\n+use vec::{ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n \n #[allow(non_camel_case_types)] // not sure what to do about this\n pub type fd_t = c_int;\n@@ -1261,7 +1261,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-    for flags.each |f| {\n+    for flags.iter().advance |f| {\n         match *f {\n           Append => fflags |= O_APPEND as c_int,\n           Create => fflags |= O_CREAT as c_int,\n@@ -2015,15 +2015,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).get();\n-            for uints.each |i| {\n+            for uints.iter().advance |i| {\n                 file.write_le_u64(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).get();\n-            for uints.each |i| {\n+            for uints.iter().advance |i| {\n                 assert_eq!(file.read_le_u64(), *i);\n             }\n         }\n@@ -2037,15 +2037,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).get();\n-            for uints.each |i| {\n+            for uints.iter().advance |i| {\n                 file.write_be_u64(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).get();\n-            for uints.each |i| {\n+            for uints.iter().advance |i| {\n                 assert_eq!(file.read_be_u64(), *i);\n             }\n         }\n@@ -2059,15 +2059,15 @@ mod tests {\n         // write the ints to the file\n         {\n             let file = io::file_writer(&path, [io::Create]).get();\n-            for ints.each |i| {\n+            for ints.iter().advance |i| {\n                 file.write_be_i32(*i);\n             }\n         }\n \n         // then read them back and check that they are the same\n         {\n             let file = io::file_reader(&path).get();\n-            for ints.each |i| {\n+            for ints.iter().advance |i| {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n                 assert_eq!(file.read_be_int_n(4), *i as i64);"}, {"sha": "4e598a4aa1cd62132edf596df9c62c09693c0110", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -56,7 +56,7 @@ pub trait FromIter<T> {\n     ///\n     /// ~~~ {.rust}\n     /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.each(|x| f(*x)) };\n+    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n     /// assert_eq!(xs, ys);\n     /// ~~~\n     pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n@@ -69,8 +69,8 @@ pub trait FromIter<T> {\n  *\n  * ~~~ {.rust}\n  * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.each(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n+ * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+ * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n  * ~~~\n  */\n #[inline]\n@@ -109,7 +109,7 @@ pub fn all<T>(predicate: &fn(T) -> bool,\n  *\n  * ~~~ {.rust}\n  * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n+ * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n  * ~~~\n  */\n #[inline]\n@@ -130,7 +130,7 @@ pub fn find<T>(predicate: &fn(&T) -> bool,\n  *\n  * ~~~ {.rust}\n  * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.each(f)).unwrap(), &15);\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n  * ~~~\n  */\n #[inline]\n@@ -156,7 +156,7 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n  *\n  * ~~~ {.rust}\n  * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.each(f)).unwrap(), &-5);\n+ * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n  * ~~~\n  */\n #[inline]\n@@ -223,7 +223,7 @@ pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&m\n  *\n  * ~~~ {.rust}\n  * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.each(f) }, 10);\n+ * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n  * ~~~\n  */\n #[inline]\n@@ -238,7 +238,7 @@ pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n  *\n  * ~~~ {.rust}\n  * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.each(f) }, 24);\n+ * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n  * ~~~\n  */\n #[inline]\n@@ -257,15 +257,15 @@ mod tests {\n     #[test]\n     fn test_from_iter() {\n         let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.each(|x| f(*x)) };\n+        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n         assert_eq!(xs, ys);\n     }\n \n     #[test]\n     fn test_any() {\n         let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.each(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n+        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n+        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n     }\n \n     #[test]\n@@ -277,19 +277,19 @@ mod tests {\n     #[test]\n     fn test_find() {\n         let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n+        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n     }\n \n     #[test]\n     fn test_max() {\n         let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.each(f)).unwrap(), &15);\n+        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n     }\n \n     #[test]\n     fn test_min() {\n         let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.each(f)).unwrap(), &-5);\n+        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n     }\n \n     #[test]\n@@ -300,24 +300,24 @@ mod tests {\n     #[test]\n     fn test_sum() {\n         let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.each(f) }, 10);\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n     }\n \n     #[test]\n     fn test_empty_sum() {\n         let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.each(f) }, 0);\n+        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n     }\n \n     #[test]\n     fn test_product() {\n         let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.each(f) }, 24);\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n     }\n \n     #[test]\n     fn test_empty_product() {\n         let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.each(f) }, 1);\n+        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n     }\n }"}, {"sha": "1ceb22b20ca615a860bf323ab7c7d6760df7bc5e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -224,7 +224,7 @@ pub fn env() -> ~[(~str,~str)] {\n \n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n-            for input.each |p| {\n+            for input.iter().advance |p| {\n                 let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n@@ -593,7 +593,8 @@ pub fn tmpdir() -> Path {\n \n /// Recursively walk a directory structure\n pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n-    list_dir(p).each(|q| {\n+    let r = list_dir(p);\n+    r.iter().advance(|q| {\n         let path = &p.push(*q);\n         f(path) && (!path_is_dir(path) || walk_dir(path, f))\n     })\n@@ -1528,7 +1529,7 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert!(e.len() > 0u);\n-        for e.each |p| {\n+        for e.iter().advance |p| {\n             let (n, v) = copy *p;\n             debug!(copy n);\n             let v2 = getenv(n);\n@@ -1599,8 +1600,8 @@ mod tests {\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert_eq!(os::homedir(), Some(Path(\"/home/MountainView\")));\n \n-        oldhome.each(|s| { setenv(\"HOME\", *s); true });\n-        olduserprofile.each(|s| { setenv(\"USERPROFILE\", *s); true });\n+        oldhome.iter().advance(|s| { setenv(\"HOME\", *s); true });\n+        olduserprofile.iter().advance(|s| { setenv(\"USERPROFILE\", *s); true });\n     }\n \n     #[test]\n@@ -1620,7 +1621,7 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert!(dirs.len() > 0u);\n \n-        for dirs.each |dir| {\n+        for dirs.iter().advance |dir| {\n             debug!(copy *dir);\n         }\n     }"}, {"sha": "700bfff3f5d799a81c96facbcb605decf9859f07", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -25,8 +25,7 @@ use str;\n use str::{Str, StrSlice, StrVector};\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n-use old_iter::BaseIter;\n-use vec::OwnedVector;\n+use vec::{OwnedVector, ImmutableVector};\n \n #[cfg(windows)]\n pub use Path = self::WindowsPath;\n@@ -596,7 +595,7 @@ impl GenericPath for PosixPath {\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n         let mut v = copy self.components;\n-        for cs.each |e| {\n+        for cs.iter().advance |e| {\n             for e.as_slice().split_iter(windows::is_sep).advance |s| {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n@@ -853,7 +852,7 @@ impl GenericPath for WindowsPath {\n \n     fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n         let mut v = copy self.components;\n-        for cs.each |e| {\n+        for cs.iter().advance |e| {\n             for e.as_slice().split_iter(windows::is_sep).advance |s| {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n@@ -915,7 +914,7 @@ impl GenericPath for WindowsPath {\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    for components.each |c| {\n+    for components.iter().advance |c| {\n         if *c == ~\".\" && components.len() > 1 { loop; }\n         if *c == ~\"\" { loop; }\n         if *c == ~\"..\" && cs.len() != 0 {"}, {"sha": "c49e2af2f029a50207a29fe1a98b6f940e987db6", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -544,15 +544,15 @@ impl<R: Rng> RngUtil for R {\n     fn choose_weighted_option<T:Copy>(&mut self, v: &[Weighted<T>])\n                                      -> Option<T> {\n         let mut total = 0u;\n-        for v.each |item| {\n+        for v.iter().advance |item| {\n             total += item.weight;\n         }\n         if total == 0u {\n             return None;\n         }\n         let chosen = self.gen_uint_range(0u, total);\n         let mut so_far = 0u;\n-        for v.each |item| {\n+        for v.iter().advance |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n                 return Some(copy item.item);\n@@ -567,7 +567,7 @@ impl<R: Rng> RngUtil for R {\n      */\n     fn weighted_vec<T:Copy>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n-        for v.each |item| {\n+        for v.iter().advance |item| {\n             for uint::range(0u, item.weight) |_i| {\n                 r.push(copy item.item);\n             }\n@@ -746,7 +746,8 @@ impl IsaacRng {\n             }}\n         );\n \n-        for [(0, midpoint), (midpoint, 0)].each |&(mr_offset, m2_offset)| {\n+        let r = [(0, midpoint), (midpoint, 0)];\n+        for r.iter().advance |&(mr_offset, m2_offset)| {\n             for uint::range_step(0, midpoint, 4) |base| {\n                 rngstep!(0, 13);\n                 rngstep!(1, -6);"}, {"sha": "0b099b66ecf0ac1d2b18f01db239bc10d7b9d4df", "filename": "src/libstd/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -16,10 +16,10 @@ use cmp::Eq;\n use either;\n use either::Either;\n use kinds::Copy;\n+use iterator::IteratorUtil;\n use option::{None, Option, Some};\n-use old_iter::BaseIter;\n use vec;\n-use vec::OwnedVector;\n+use vec::{OwnedVector, ImmutableVector};\n use container::Container;\n \n /// The result type\n@@ -303,7 +303,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = vec::with_capacity(ts.len());\n-    for ts.each |t| {\n+    for ts.iter().advance |t| {\n         match op(t) {\n           Ok(v) => vs.push(v),\n           Err(u) => return Err(u)"}, {"sha": "ada9aee35a7e3a56cc36350af11bc5924157fa77", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -389,7 +389,8 @@ mod test {\n                     if status.is_none() {\n                         rtdebug!(\"got %d bytes\", nread);\n                         let buf = buf.unwrap();\n-                        for buf.slice(0, nread as uint).each |byte| {\n+                        let r = buf.slice(0, nread as uint);\n+                        for r.iter().advance |byte| {\n                             assert!(*byte == count as u8);\n                             rtdebug!(\"%u\", *byte as uint);\n                             count += 1;"}, {"sha": "c965af7c10ce2d98b9006f91fb64539729556b22", "filename": "src/libstd/run.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -582,7 +582,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n \n     let mut cmd = ~\"\";\n     append_arg(&mut cmd, prog);\n-    for args.each |arg| {\n+    for args.iter().advance |arg| {\n         cmd.push_char(' ');\n         append_arg(&mut cmd, *arg);\n     }\n@@ -698,7 +698,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = ~[str::as_c_str(prog, |b| b)];\n     let mut tmps = ~[];\n-    for args.each |arg| {\n+    for args.iter().advance |arg| {\n         let t = @copy *arg;\n         tmps.push(t);\n         argptrs.push(str::as_c_str(*t, |b| b));\n@@ -716,7 +716,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for es.each |&(k, v)| {\n+        for es.iter().advance |&(k, v)| {\n             let kv = @fmt!(\"%s=%s\", k, v);\n             tmps.push(kv);\n             ptrs.push(str::as_c_str(*kv, |b| b));\n@@ -739,7 +739,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     match env {\n       Some(es) => {\n         let mut blk = ~[];\n-        for es.each |&(k, v)| {\n+        for es.iter().advance |&(k, v)| {\n             let kv = fmt!(\"%s=%s\", k, v);\n             blk.push_all(kv.as_bytes_with_null_consume());\n         }\n@@ -1165,7 +1165,8 @@ mod tests {\n         let mut prog = run_env(None);\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n-        for os::env().each |&(k, v)| {\n+        let r = os::env();\n+        for r.iter().advance |&(k, v)| {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", k, v)));\n         }"}, {"sha": "45ba85283754cafc24eda33741f80c1ea83af073", "filename": "src/libstd/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -29,7 +29,7 @@ use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIter\n use libc;\n use num::Zero;\n use option::{None, Option, Some};\n-use old_iter::{BaseIter, EqIter};\n+use old_iter::EqIter;\n use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n@@ -147,7 +147,7 @@ pub fn from_char(ch: char) -> ~str {\n pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     buf.reserve(chs.len());\n-    for chs.each |ch| {\n+    for chs.iter().advance |ch| {\n         buf.push_char(*ch)\n     }\n     buf\n@@ -864,7 +864,7 @@ pub mod raw {\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n         let new_len = s.len() + bytes.len();\n         s.reserve_at_least(new_len);\n-        for bytes.each |byte| { push_byte(&mut *s, *byte); }\n+        for bytes.iter().advance |byte| { push_byte(&mut *s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n@@ -3080,7 +3080,7 @@ mod tests {\n                 0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                 0x000a_u16 ]) ];\n \n-        for pairs.each |p| {\n+        for pairs.iter().advance |p| {\n             let (s, u) = copy *p;\n             assert!(s.to_utf16() == u);\n             assert!(from_utf16(u) == s);\n@@ -3094,7 +3094,7 @@ mod tests {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n-        for v.each |ch| {\n+        for v.iter().advance |ch| {\n             assert!(s.char_at(pos) == *ch);\n             pos += from_char(*ch).len();\n         }"}, {"sha": "d8b50c96fd8d9d89f5f1fb906775870076d6f0f8", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -14,7 +14,6 @@ use to_str::{ToStr,ToStrConsume};\n use str;\n use str::StrSlice;\n use cast;\n-use old_iter::BaseIter;\n use iterator::IteratorUtil;\n use vec::{CopyableVector, ImmutableVector, OwnedVector};\n use to_bytes::IterBytes;\n@@ -94,7 +93,7 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n \n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        for self.each |b| {\n+        for self.iter().advance |b| {\n             if !b.is_ascii() { return false; }\n         }\n         true"}, {"sha": "6f0c615d007c2050227815618c3433dab867ea05", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -17,9 +17,10 @@ The `ToBytes` and `IterBytes` traits\n use cast;\n use io;\n use io::Writer;\n+use iterator::IteratorUtil;\n use option::{None, Option, Some};\n-use old_iter::BaseIter;\n use str::StrSlice;\n+use vec::ImmutableVector;\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n@@ -223,7 +224,7 @@ impl IterBytes for f64 {\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.each(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n+        self.iter().advance(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n     }\n }\n "}, {"sha": "c6ac2c89f32eeef23d3a59aa2311f5b9140c6856", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -17,10 +17,12 @@ The `ToStr` trait for converting to strings\n use str::OwnedStr;\n use hashmap::HashMap;\n use hashmap::HashSet;\n+use iterator::IteratorUtil;\n use container::Map;\n use hash::Hash;\n use cmp::Eq;\n use old_iter::BaseIter;\n+use vec::ImmutableVector;\n \n /// A generic trait for converting a value to a string\n pub trait ToStr {\n@@ -122,7 +124,7 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n-        for self.each |elt| {\n+        for self.iter().advance |elt| {\n             if first {\n                 first = false;\n             }\n@@ -140,7 +142,7 @@ impl<A:ToStr> ToStr for ~[A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n-        for self.each |elt| {\n+        for self.iter().advance |elt| {\n             if first {\n                 first = false;\n             }\n@@ -158,7 +160,7 @@ impl<A:ToStr> ToStr for @[A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"[\", true);\n-        for self.each |elt| {\n+        for self.iter().advance |elt| {\n             if first {\n                 first = false;\n             }"}, {"sha": "39980ffa59915d8b57d38c1d0fd49ca69f43d1a0", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -373,7 +373,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n \n     let mut sum = 0;\n \n-    for trie.children.each |x| {\n+    for trie.children.iter().advance |x| {\n         match *x {\n           Nothing => (),\n           Internal(ref y) => {"}, {"sha": "235dfa0184933c5b39105d6030d0e603ababf8d9", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -237,7 +237,7 @@ mod tests {\n                 }\n             };\n \n-            for futures.each |f| { f.recv() }\n+            for futures.iter().advance |f| { f.recv() }\n \n             do total.with |total| {\n                 assert!(**total == num_tasks * count)"}, {"sha": "17eb7e8e82be2f175f5ab54bc93e97a7249b8044", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -17,7 +17,6 @@ use cast;\n use container::{Container, Mutable};\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n-use old_iter::BaseIter;\n use old_iter;\n use iterator::{FromIterator, Iterator, IteratorUtil};\n use iter::FromIter;\n@@ -1025,7 +1024,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [~[T]] {\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        for self.each |&inner| {\n+        for self.iter().advance |&inner| {\n             if first { first = false; } else { r.push(copy *sep); }\n             r.push_all(inner);\n         }\n@@ -1043,7 +1042,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        for self.each |&inner| {\n+        for self.iter().advance |&inner| {\n             if first { first = false; } else { r.push(copy *sep); }\n             r.push_all(inner);\n         }\n@@ -1749,7 +1748,7 @@ impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n     fn to_owned(&self) -> ~[T] {\n         let mut result = ~[];\n         reserve(&mut result, self.len());\n-        for self.each |e| {\n+        for self.iter().advance |e| {\n             result.push(copy *e);\n         }\n         result\n@@ -2399,15 +2398,6 @@ pub mod bytes {\n     }\n }\n \n-impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n-    #[inline]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n-        each(*self, blk)\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n impl<A:Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {"}, {"sha": "f243bcb0abb055957163cacbf76b502bb16ad8bc", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -87,7 +87,7 @@ fn each_abi(op: &fn(abi: Abi) -> bool) -> bool {\n      * Iterates through each of the defined ABIs.\n      */\n \n-    AbiDatas.each(|abi_data| op(abi_data.abi))\n+    AbiDatas.iter().advance(|abi_data| op(abi_data.abi))\n }\n \n pub fn lookup(name: &str) -> Option<Abi> {\n@@ -213,7 +213,7 @@ impl AbiSet {\n \n         for abis.iter().enumerate().advance |(i, abi)| {\n             let data = abi.data();\n-            for abis.slice(0, i).each |other_abi| {\n+            for abis.slice(0, i).iter().advance |other_abi| {\n                 let other_data = other_abi.data();\n                 debug!(\"abis=(%?,%?) datas=(%?,%?)\",\n                        abi, data.abi_arch,\n@@ -389,7 +389,7 @@ fn indices_are_correct() {\n #[cfg(test)]\n fn check_arch(abis: &[Abi], arch: Architecture, expect: Option<Abi>) {\n     let mut set = AbiSet::empty();\n-    for abis.each |&abi| {\n+    for abis.iter().advance |&abi| {\n         set.add(abi);\n     }\n     let r = set.for_arch(arch);"}, {"sha": "a0e1ec69350c870cbb1016353248ee96f6837084", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -185,7 +185,7 @@ pub fn map_fn(\n     (cx,v): (@mut Ctx,\n              visit::vt<@mut Ctx>)\n ) {\n-    for decl.inputs.each |a| {\n+    for decl.inputs.iter().advance |a| {\n         cx.map.insert(a.id, node_arg);\n     }\n     visit::visit_fn(fk, decl, body, sp, id, (cx, v));\n@@ -220,19 +220,19 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     match i.node {\n         item_impl(_, _, _, ref ms) => {\n             let impl_did = ast_util::local_def(i.id);\n-            for ms.each |m| {\n+            for ms.iter().advance |m| {\n                 map_method(impl_did, extend(cx, i.ident), *m, cx);\n             }\n         }\n         item_enum(ref enum_definition, _) => {\n-            for (*enum_definition).variants.each |v| {\n+            for (*enum_definition).variants.iter().advance |v| {\n                 cx.map.insert(v.node.id, node_variant(\n                     /* FIXME (#2543) */ copy *v, i,\n                     extend(cx, i.ident)));\n             }\n         }\n         item_foreign_mod(ref nm) => {\n-            for nm.items.each |nitem| {\n+            for nm.items.iter().advance |nitem| {\n                 // Compute the visibility for this native item.\n                 let visibility = match nitem.vis {\n                     public => public,\n@@ -266,10 +266,10 @@ pub fn map_item(i: @item, (cx, v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n             );\n         }\n         item_trait(_, ref traits, ref methods) => {\n-            for traits.each |p| {\n+            for traits.iter().advance |p| {\n                 cx.map.insert(p.ref_id, node_item(i, item_path));\n             }\n-            for methods.each |tm| {\n+            for methods.iter().advance |tm| {\n                 let id = ast_util::trait_method_to_ty_method(tm).id;\n                 let d_id = ast_util::local_def(i.id);\n                 cx.map.insert("}, {"sha": "34c247662a4e175a85fb8b8ff98e852aedc81f5a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -281,7 +281,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     -> (~[ty_method], ~[@method]) {\n     let mut reqd = ~[];\n     let mut provd = ~[];\n-    for trait_methods.each |trt_method| {\n+    for trait_methods.iter().advance |trt_method| {\n         match *trt_method {\n           required(ref tm) => reqd.push(copy *tm),\n           provided(m) => provd.push(m)\n@@ -411,13 +411,13 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n             match vi.node {\n               view_item_extern_mod(_, _, id) => vfn(id, copy t),\n               view_item_use(ref vps) => {\n-                  for vps.each |vp| {\n+                  for vps.iter().advance |vp| {\n                       match vp.node {\n                           view_path_simple(_, _, id) => vfn(id, copy t),\n                           view_path_glob(_, id) => vfn(id, copy t),\n                           view_path_list(_, ref paths, id) => {\n                               vfn(id, copy t);\n-                              for paths.each |p| {\n+                              for paths.iter().advance |p| {\n                                   vfn(p.node.id, copy t);\n                               }\n                           }\n@@ -437,7 +437,7 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n             vfn(i.id, copy t);\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n-                for (*enum_definition).variants.each |v| { vfn(v.node.id, copy t); },\n+                for (*enum_definition).variants.iter().advance |v| { vfn(v.node.id, copy t); },\n               _ => ()\n             }\n             visit::visit_item(i, (t, vt));\n@@ -500,7 +500,7 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n                 }\n             }\n \n-            for d.inputs.each |arg| {\n+            for d.inputs.iter().advance |arg| {\n                 vfn(arg.id, copy t)\n             }\n             visit::visit_fn(fk, d, a, b, id, (copy t, vt));\n@@ -546,16 +546,16 @@ pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n         pat_struct(_, ref fields, _) => {\n-            fields.each(|f| walk_pat(f.pat, it))\n+            fields.iter().advance(|f| walk_pat(f.pat, it))\n         }\n         pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n-            s.each(|&p| walk_pat(p, it))\n+            s.iter().advance(|&p| walk_pat(p, it))\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n         pat_vec(ref before, ref slice, ref after) => {\n-            before.each(|&p| walk_pat(p, it)) &&\n+            before.iter().advance(|&p| walk_pat(p, it)) &&\n                 slice.iter().advance(|&p| walk_pat(p, it)) &&\n                 after.iter().advance(|&p| walk_pat(p, it))\n         }"}, {"sha": "d9fb91e6ddd8e84f018335fcd68e69a7c1c51873", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -158,7 +158,7 @@ pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n     let mut rs = ~[];\n-    for metas.each |mi| {\n+    for metas.iter().advance |mi| {\n         if name == get_meta_item_name(*mi) {\n             rs.push(*mi)\n         }\n@@ -172,7 +172,7 @@ pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n  */\n pub fn contains(haystack: &[@ast::meta_item],\n                 needle: @ast::meta_item) -> bool {\n-    for haystack.each |item| {\n+    for haystack.iter().advance |item| {\n         if eq(*item, needle) { return true; }\n     }\n     return false;\n@@ -193,7 +193,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         ast::meta_list(ref na, ref misa) => match b.node {\n             ast::meta_list(ref nb, ref misb) => {\n                 if na != nb { return false; }\n-                for misa.each |mi| {\n+                for misa.iter().advance |mi| {\n                     if !misb.iter().any_(|x| x == mi) { return false; }\n                 }\n                 true\n@@ -334,7 +334,7 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n pub fn require_unique_names(diagnostic: @span_handler,\n                             metas: &[@ast::meta_item]) {\n     let mut set = HashSet::new();\n-    for metas.each |meta| {\n+    for metas.iter().advance |meta| {\n         let name = get_meta_item_name(*meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)"}, {"sha": "bae5e943a48dfa8e93c6d806df70fdd3617cc21a", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -422,7 +422,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> @FileMap {\n-        for self.files.each |fm| { if filename == fm.name { return *fm; } }\n+        for self.files.iter().advance |fm| { if filename == fm.name { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n         fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n@@ -508,7 +508,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for map.multibyte_chars.each |mbc| {\n+        for map.multibyte_chars.iter().advance |mbc| {\n             debug!(\"codemap: %?-byte char at %?\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 total_extra_bytes += mbc.bytes;"}, {"sha": "7b4ed19fe7fa7ba6ea4e7afe0a5645fa90c2f34d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -256,7 +256,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         elided = true;\n     }\n     // Print the offending lines\n-    for display_lines.each |line| {\n+    for display_lines.iter().advance |line| {\n         io::stderr().write_str(fmt!(\"%s:%u \", fm.name, *line + 1u));\n         let s = fm.get_line(*line as int) + \"\\n\";\n         io::stderr().write_str(s);"}, {"sha": "3f64654dd802500957b39699e634286158196c07", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -21,7 +21,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n     let exprs = get_exprs_from_tts(cx, tts);\n     let mut bytes = ~[];\n \n-    for exprs.each |expr| {\n+    for exprs.iter().advance |expr| {\n         match expr.node {\n             // expression is a literal\n             ast::expr_lit(lit) => match lit.node {"}, {"sha": "dca1b7bbd593458fd6e6f96203d90e1b8bf7769d", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -286,7 +286,7 @@ impl<'self> TraitDef<'self> {\n                   _mitem: @ast::meta_item,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n-        for in_items.each |item| {\n+        for in_items.iter().advance |item| {\n             result.push(*item);\n             match item.node {\n                 ast::item_struct(struct_def, ref generics) => {\n@@ -740,7 +740,7 @@ impl<'self> MethodDef<'self> {\n \n                     let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n \n-                    for matches_so_far.tail().each |&(_, _, other_fields)| {\n+                    for matches_so_far.tail().iter().advance |&(_, _, other_fields)| {\n                         for other_fields.iter().enumerate().advance |(i, &(_, other_field))| {\n                             enum_matching_fields[i].push(other_field);\n                         }\n@@ -870,7 +870,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n                     struct_def: &struct_def) -> Either<uint, ~[ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n-    for struct_def.fields.each |field| {\n+    for struct_def.fields.iter().advance |field| {\n         match field.node.kind {\n             ast::named_field(ident, _) => named_idents.push(ident),\n             ast::unnamed_field => unnamed_count += 1,"}, {"sha": "c7949f9a8e310edd925b2ac90813d71eaa0e0c93", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -76,7 +76,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    for fields.each |&(_, field, _)| {\n+    for fields.iter().advance |&(_, field, _)| {\n         exprs.push(call_iterbytes(field));\n     }\n "}, {"sha": "4c0a85b665ae34a2b2b97b7765999982cdfb5413", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -70,7 +70,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     fn make_rt_conv_expr(cx: @ExtCtxt, sp: span, cnv: &Conv) -> @ast::expr {\n         fn make_flags(cx: @ExtCtxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n-            for flags.each |f| {\n+            for flags.iter().advance |f| {\n                 let fstr = match *f {\n                   FlagLeftJustify => \"flag_left_justify\",\n                   FlagLeftZeroPad => \"flag_left_zero_pad\",\n@@ -156,7 +156,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n           option::None => (),\n           _ => cx.span_unimpl(sp, unsupported)\n         }\n-        for cnv.flags.each |f| {\n+        for cnv.flags.iter().advance |f| {\n             match *f {\n               FlagLeftJustify => (),\n               FlagSignAlways => {\n@@ -205,7 +205,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n           Some(p) => { debug!(\"param: %s\", p.to_str()); }\n           _ => debug!(\"param: none\")\n         }\n-        for c.flags.each |f| {\n+        for c.flags.iter().advance |f| {\n             match *f {\n               FlagLeftJustify => debug!(\"flag: left justify\"),\n               FlagLeftZeroPad => debug!(\"flag: left zero pad\"),"}, {"sha": "8478a827e85d529df6684cca8497c55af236a6c2", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -209,7 +209,7 @@ impl to_type_decls for state {\n \n         let mut items_msg = ~[];\n \n-        for self.messages.each |m| {\n+        for self.messages.iter().advance |m| {\n             let message(name, span, tys, this, next) = copy *m;\n \n             let tys = match next {\n@@ -372,7 +372,7 @@ impl gen_init for protocol {\n \n     fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        for (copy self.states).each |s| {\n+        for (copy self.states).iter().advance |s| {\n             for s.generics.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n@@ -433,7 +433,7 @@ impl gen_init for protocol {\n         let mut client_states = ~[];\n         let mut server_states = ~[];\n \n-        for (copy self.states).each |s| {\n+        for (copy self.states).iter().advance |s| {\n             items += s.to_type_decls(cx);\n \n             client_states += s.to_endpoint_decls(cx, send);"}, {"sha": "d00f1fd7746dea028113e3cefb34eb12858f0c2d", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -107,7 +107,7 @@ impl state_ {\n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n     pub fn reachable(&self, f: &fn(state) -> bool) -> bool {\n-        for self.messages.each |m| {\n+        for self.messages.iter().advance |m| {\n             match *m {\n               message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n                 let state = self.proto.get_state((*id));\n@@ -165,7 +165,7 @@ impl protocol_ {\n     }\n \n     pub fn has_ty_params(&self) -> bool {\n-        for self.states.each |s| {\n+        for self.states.iter().advance |s| {\n             if s.generics.ty_params.len() > 0 {\n                 return true;\n             }"}, {"sha": "742f5a97825faa7d9bad37168af00642e74df64e", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -637,7 +637,7 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n-    for tts.each |tt| {\n+    for tts.iter().advance |tt| {\n         ss.push_all_move(mk_tt(cx, sp, tt));\n     }\n     ss"}, {"sha": "f2b57db06c15114cc581e19bd49cc6c618d95733", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -138,7 +138,7 @@ pub fn count_names(ms: &[matcher]) -> uint {\n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n-    for ms.each |elt| {\n+    for ms.iter().advance |elt| {\n         match elt.node {\n           match_tok(_) => (),\n           match_seq(_,_,_,_,hi) => {\n@@ -195,7 +195,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n         match *m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n-            for more_ms.each |next_m| {\n+            for more_ms.iter().advance |next_m| {\n                 n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n@@ -211,8 +211,8 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    for ms.each |m| { n_rec(p_s, m, res, &mut ret_val) }\n-    return ret_val;\n+    for ms.iter().advance |m| { n_rec(p_s, m, res, &mut ret_val) }\n+    ret_val\n }\n \n pub enum parse_result {"}, {"sha": "568324bc599613f1e211ebafa0e2e129718d3ff5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -378,7 +378,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n pub fn noop_fold_block(b: &blk_, fld: @ast_fold) -> blk_ {\n     let view_items = b.view_items.map(|x| fld.fold_view_item(*x));\n     let mut stmts = ~[];\n-    for b.stmts.each |stmt| {\n+    for b.stmts.iter().advance |stmt| {\n         match fld.fold_stmt(*stmt) {\n             None => {}\n             Some(stmt) => stmts.push(stmt)"}, {"sha": "c537a3e8eba36e62d71915a02fe21a65ab9d345d", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -135,7 +135,7 @@ impl<A> BaseIter<A> for OptVec<A> {\n     fn each(&self, blk: &fn(v: &A) -> bool) -> bool {\n         match *self {\n             Empty => true,\n-            Vec(ref v) => v.each(blk)\n+            Vec(ref v) => v.iter().advance(blk)\n         }\n     }\n "}, {"sha": "84915b6403a76de56486f8765bba71c8acd65de5", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -835,7 +835,7 @@ mod test {\n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n     fn check_tokenization (env: Env, expected: ~[token::Token]) {\n-        for expected.each |expected_tok| {\n+        for expected.iter().advance |expected_tok| {\n             let TokenAndSpan {tok:actual_tok, sp: _} =\n                 env.string_reader.next_token();\n             assert_eq!(&actual_tok,expected_tok);"}, {"sha": "753c69b23d6a1420911ce031c6bc94635f46c4aa", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -2746,7 +2746,7 @@ impl Parser {\n         } = self.parse_items_and_view_items(first_item_attrs,\n                                             false, false);\n \n-        for items.each |item| {\n+        for items.iter().advance |item| {\n             let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n             stmts.push(@spanned(item.span.lo, item.span.hi,\n                                 stmt_decl(decl, self.get_id())));\n@@ -3356,7 +3356,8 @@ impl Parser {\n             is_tuple_like = false;\n             fields = ~[];\n             while *self.token != token::RBRACE {\n-                for self.parse_struct_decl_field().each |struct_field| {\n+                let r = self.parse_struct_decl_field();\n+                for r.iter().advance |struct_field| {\n                     fields.push(*struct_field)\n                 }\n             }\n@@ -3825,7 +3826,8 @@ impl Parser {\n     fn parse_struct_def(&self) -> @struct_def {\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n-            for self.parse_struct_decl_field().each |struct_field| {\n+            let r = self.parse_struct_decl_field();\n+            for r.iter().advance |struct_field| {\n                 fields.push(*struct_field);\n             }\n         }\n@@ -3865,7 +3867,7 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                for arg_tys.each |ty| {\n+                for arg_tys.iter().advance |ty| {\n                     args.push(ast::variant_arg {\n                         ty: *ty,\n                         id: self.get_id(),"}, {"sha": "8e47df510108812ed06381f99ef4b7ce9f00412b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -320,7 +320,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n-    for elts.each |elt| {\n+    for elts.iter().advance |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, copy *elt);\n     }\n@@ -333,7 +333,7 @@ pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n-    for elts.each |elt| {\n+    for elts.iter().advance |elt| {\n         maybe_print_comment(s, get_span(copy *elt).hi);\n         op(s, copy *elt);\n         i += 1u;\n@@ -354,19 +354,19 @@ pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n \n pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for _mod.view_items.each |vitem| {\n+    for _mod.view_items.iter().advance |vitem| {\n         print_view_item(s, *vitem);\n     }\n-    for _mod.items.each |item| { print_item(s, *item); }\n+    for _mod.items.iter().advance |item| { print_item(s, *item); }\n }\n \n pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n-    for nmod.view_items.each |vitem| {\n+    for nmod.view_items.iter().advance |vitem| {\n         print_view_item(s, *vitem);\n     }\n-    for nmod.items.each |item| { print_foreign_item(s, *item); }\n+    for nmod.items.iter().advance |item| { print_foreign_item(s, *item); }\n }\n \n pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n@@ -580,7 +580,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n             word(s.s, \";\");\n         } else {\n             bopen(s);\n-            for methods.each |meth| {\n+            for methods.iter().advance |meth| {\n                print_method(s, *meth);\n             }\n             bclose(s, item.span);\n@@ -602,7 +602,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         }\n         word(s.s, \" \");\n         bopen(s);\n-        for methods.each |meth| {\n+        for methods.iter().advance |meth| {\n             print_trait_method(s, meth);\n         }\n         bclose(s, item.span);\n@@ -641,7 +641,7 @@ pub fn print_variants(s: @ps,\n                       variants: &[ast::variant],\n                       span: codemap::span) {\n     bopen(s);\n-    for variants.each |v| {\n+    for variants.iter().advance |v| {\n         space_if_not_bol(s);\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n@@ -706,7 +706,7 @@ pub fn print_struct(s: @ps,\n         bopen(s);\n         hardbreak_if_not_bol(s);\n \n-        for struct_def.fields.each |field| {\n+        for struct_def.fields.iter().advance |field| {\n             match field.node.kind {\n                 ast::unnamed_field => fail!(\"unexpected unnamed field\"),\n                 ast::named_field(ident, visibility) => {\n@@ -741,7 +741,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, \"$(\");\n-        for (*tts).each() |tt_elt| { print_tt(s, tt_elt); }\n+        for (*tts).iter().advance |tt_elt| { print_tt(s, tt_elt); }\n         word(s.s, \")\");\n         match (*sep) {\n           Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n@@ -827,7 +827,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n \n pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n-    for attrs.each |attr| {\n+    for attrs.iter().advance |attr| {\n         match attr.node.style {\n           ast::attr_outer => { print_attribute(s, *attr); count += 1; }\n           _ => {/* fallthrough */ }\n@@ -838,7 +838,7 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n \n pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n-    for attrs.each |attr| {\n+    for attrs.iter().advance |attr| {\n         match attr.node.style {\n           ast::attr_inner => {\n             print_attribute(s, *attr);\n@@ -944,8 +944,8 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     print_inner_attributes(s, attrs);\n \n-    for blk.node.view_items.each |vi| { print_view_item(s, *vi); }\n-    for blk.node.stmts.each |st| {\n+    for blk.node.view_items.iter().advance |vi| { print_view_item(s, *vi); }\n+    for blk.node.stmts.iter().advance |st| {\n         print_stmt(s, *st);\n     }\n     match blk.node.expr {\n@@ -1234,7 +1234,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n             cbox(s, indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n-            for arm.pats.each |p| {\n+            for arm.pats.iter().advance |p| {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n@@ -1401,15 +1401,15 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         popen(s);\n         print_string(s, a.asm);\n         word_space(s, \":\");\n-        for a.outputs.each |&(co, o)| {\n+        for a.outputs.iter().advance |&(co, o)| {\n             print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n-        for a.inputs.each |&(co, o)| {\n+        for a.inputs.iter().advance |&(co, o)| {\n             print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n@@ -1487,7 +1487,7 @@ pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n-    for path.idents.each |id| {\n+    for path.idents.iter().advance |id| {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n@@ -1678,7 +1678,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n         first = !print_explicit_self(s, *explicit_self);\n     }\n \n-    for decl.inputs.each |arg| {\n+    for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, *arg);\n     }\n@@ -1924,7 +1924,7 @@ pub fn print_ty_fn(s: @ps,\n     for opt_explicit_self.iter().advance |explicit_self| {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n-    for decl.inputs.each |arg| {\n+    for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, *arg);\n     }\n@@ -2075,7 +2075,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n       }\n       comments::isolated => {\n         pprust::hardbreak_if_not_bol(s);\n-        for cmnt.lines.each |line| {\n+        for cmnt.lines.iter().advance |line| {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n             if !line.is_empty() { word(s.s, *line); }\n@@ -2089,7 +2089,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for cmnt.lines.each |line| {\n+            for cmnt.lines.iter().advance |line| {\n                 if !line.is_empty() { word(s.s, *line); }\n                 hardbreak(s.s);\n             }"}, {"sha": "004ba7762d3a27a15a5b0b5acdf31bf29c28056c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -36,7 +36,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        for init.each() |v| { rv.intern(copy *v); }\n+        for init.iter().advance |v| { rv.intern(copy *v); }\n         rv\n     }\n \n@@ -94,7 +94,7 @@ impl StrInterner {\n \n     pub fn prefill(init: &[&str]) -> StrInterner {\n         let rv = StrInterner::new();\n-        for init.each |&v| { rv.intern(v); }\n+        for init.iter().advance |&v| { rv.intern(v); }\n         rv\n     }\n "}, {"sha": "e7afeb12a618851db438d08e400b2e0165170e3b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -127,8 +127,8 @@ pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n-    for m.view_items.each |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n-    for m.items.each |i| { (v.visit_item)(*i, (copy e, v)); }\n+    for m.view_items.iter().advance |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+    for m.items.iter().advance |i| { (v.visit_item)(*i, (copy e, v)); }\n }\n \n pub fn visit_view_item<E>(_vi: @view_item, (_e, _v): (E, vt<E>)) { }\n@@ -170,8 +170,8 @@ pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n-            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n+            for nm.view_items.iter().advance |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+            for nm.items.iter().advance |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n         }\n         item_ty(t, ref tps) => {\n             (v.visit_ty)(t, (copy e, v));\n@@ -191,7 +191,7 @@ pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n                 visit_trait_ref(p, (copy e, v));\n             }\n             (v.visit_ty)(ty, (copy e, v));\n-            for methods.each |m| {\n+            for methods.iter().advance |m| {\n                 visit_method_helper(*m, (copy e, v))\n             }\n         }\n@@ -201,8 +201,8 @@ pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (copy e, v));\n-            for traits.each |p| { visit_path(p.path, (copy e, v)); }\n-            for methods.each |m| {\n+            for traits.iter().advance |p| { visit_path(p.path, (copy e, v)); }\n+            for methods.iter().advance |m| {\n                 (v.visit_trait_method)(m, (copy e, v));\n             }\n         }\n@@ -213,10 +213,10 @@ pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                (e, v): (E, vt<E>)) {\n-    for enum_definition.variants.each |vr| {\n+    for enum_definition.variants.iter().advance |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                for variant_args.each |va| {\n+                for variant_args.iter().advance |va| {\n                     (v.visit_ty)(va.ty, (copy e, v));\n                 }\n             }\n@@ -241,16 +241,16 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n-            for ts.each |tt| {\n+            for ts.iter().advance |tt| {\n                 (v.visit_ty)(*tt, (copy e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_path(p, _) => visit_path(p, (e, v)),\n@@ -263,7 +263,7 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E: Copy>(p: @Path, (e, v): (E, vt<E>)) {\n-    for p.types.each |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n+    for p.types.iter().advance |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n }\n \n pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n@@ -278,12 +278,12 @@ pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n         }\n         pat_struct(path, ref fields, _) => {\n             visit_path(path, (copy e, v));\n-            for fields.each |f| {\n+            for fields.iter().advance |f| {\n                 (v.visit_pat)(f.pat, (copy e, v));\n             }\n         }\n         pat_tup(ref elts) => {\n-            for elts.each |elt| {\n+            for elts.iter().advance |elt| {\n                 (v.visit_pat)(*elt, (copy e, v))\n             }\n         },\n@@ -303,13 +303,13 @@ pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n-            for before.each |elt| {\n+            for before.iter().advance |elt| {\n                 (v.visit_pat)(*elt, (copy e, v));\n             }\n             for slice.iter().advance |elt| {\n                 (v.visit_pat)(*elt, (copy e, v));\n             }\n-            for after.each |tail| {\n+            for after.iter().advance |tail| {\n                 (v.visit_pat)(*tail, (copy e, v));\n             }\n         }\n@@ -345,7 +345,7 @@ pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n-    for fd.inputs.each |a| {\n+    for fd.inputs.iter().advance |a| {\n         (v.visit_pat)(a.pat, (copy e, v));\n         (v.visit_ty)(a.ty, (copy e, v));\n     }\n@@ -380,7 +380,7 @@ pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n }\n \n pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n     (v.visit_generics)(&m.generics, (copy e, v));\n     (v.visit_ty)(m.decl.output, (e, v));\n }\n@@ -399,7 +399,7 @@ pub fn visit_struct_def<E: Copy>(\n     _id: node_id,\n     (e, v): (E, vt<E>)\n ) {\n-    for sd.fields.each |f| {\n+    for sd.fields.iter().advance |f| {\n         (v.visit_struct_field)(*f, (copy e, v));\n     }\n }\n@@ -413,10 +413,10 @@ pub fn visit_struct_method<E: Copy>(m: @method, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n-    for b.node.view_items.each |vi| {\n+    for b.node.view_items.iter().advance |vi| {\n         (v.visit_view_item)(*vi, (copy e, v));\n     }\n-    for b.node.stmts.each |s| {\n+    for b.node.stmts.iter().advance |s| {\n         (v.visit_stmt)(*s, (copy e, v));\n     }\n     visit_expr_opt(b.node.expr, (e, v));\n@@ -443,7 +443,7 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_exprs<E: Copy>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    for exprs.each |ex| { (v.visit_expr)(*ex, (copy e, v)); }\n+    for exprs.iter().advance |ex| { (v.visit_expr)(*ex, (copy e, v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n@@ -460,21 +460,21 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_struct(p, ref flds, base) => {\n             visit_path(p, (copy e, v));\n-            for flds.each |f| {\n+            for flds.iter().advance |f| {\n                 (v.visit_expr)(f.node.expr, (copy e, v));\n             }\n             visit_expr_opt(base, (copy e, v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.each |el| { (v.visit_expr)(*el, (copy e, v)) }\n+            for elts.iter().advance |el| { (v.visit_expr)(*el, (copy e, v)) }\n         }\n         expr_call(callee, ref args, _) => {\n             visit_exprs(*args, (copy e, v));\n             (v.visit_expr)(callee, (copy e, v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (copy e, v));\n-            for tys.each |tp| {\n+            for tys.iter().advance |tp| {\n                 (v.visit_ty)(*tp, (copy e, v));\n             }\n             (v.visit_expr)(callee, (copy e, v));\n@@ -502,7 +502,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_loop(ref b, _) => (v.visit_block)(b, (copy e, v)),\n         expr_match(x, ref arms) => {\n             (v.visit_expr)(x, (copy e, v));\n-            for arms.each |a| { (v.visit_arm)(a, (copy e, v)); }\n+            for arms.iter().advance |a| { (v.visit_arm)(a, (copy e, v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -526,7 +526,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         }\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (copy e, v));\n-            for tys.each |tp| {\n+            for tys.iter().advance |tp| {\n                 (v.visit_ty)(*tp, (copy e, v));\n             }\n         }\n@@ -546,10 +546,10 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_mac(ref mac) => visit_mac(mac, (copy e, v)),\n         expr_paren(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_inline_asm(ref a) => {\n-            for a.inputs.each |&(_, in)| {\n+            for a.inputs.iter().advance |&(_, in)| {\n                 (v.visit_expr)(in, (copy e, v));\n             }\n-            for a.outputs.each |&(_, out)| {\n+            for a.outputs.iter().advance |&(_, out)| {\n                 (v.visit_expr)(out, (copy e, v));\n             }\n         }"}, {"sha": "2c9b28e628262a3bdf5952271eb3aa879ee9cf88", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -24,7 +24,7 @@ pub fn alist_add<A:Copy,B:Copy>(lst: &alist<A,B>, k: A, v: B) {\n \n pub fn alist_get<A:Copy,B:Copy>(lst: &alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n-    for lst.data.each |entry| {\n+    for lst.data.iter().advance |entry| {\n         if eq_fn(copy entry.key, copy k) { return copy entry.value; }\n     }\n     fail!();"}, {"sha": "14aa65219cd28fddb49569d3d00baade5115c66e", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -141,7 +141,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     while !q.is_empty() {\n         let t = q.pop_front();\n \n-        do graph[t].each() |k| {\n+        do graph[t].iter().advance |k| {\n             if marks[*k] == -1i64 {\n                 marks[*k] = t;\n                 q.add_back(*k);\n@@ -201,7 +201,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n \n                 let mut color = white;\n \n-                do neighbors.each() |k| {\n+                do neighbors.iter().advance |k| {\n                     if is_gray(&colors[*k]) {\n                         color = gray(*k);\n                         false\n@@ -286,7 +286,7 @@ fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n \n                     let mut color = white;\n \n-                    do neighbors.each() |k| {\n+                    do neighbors.iter().advance |k| {\n                         if is_gray(&colors[*k]) {\n                             color = gray(*k);\n                             false"}, {"sha": "670e77bc3a0ece751ed9b5cad8e51e0fee4e6887", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -59,7 +59,7 @@ static HOMO_SAPIENS: [AminoAcid, ..4] = [\n fn sum_and_scale(a: &'static [AminoAcid]) -> ~[AminoAcid] {\n     let mut result = ~[];\n     let mut p = 0f32;\n-    for a.each |a_i| {\n+    for a.iter().advance |a_i| {\n         let mut a_i = *a_i;\n         p += a_i.p;\n         a_i.p = p * LOOKUP_SCALE;\n@@ -151,7 +151,7 @@ impl RandomFasta {\n \n     fn nextc(&mut self) -> u8 {\n         let r = self.rng(1.0);\n-        for self.lookup.each |a| {\n+        for self.lookup.iter().advance |a| {\n             if a.p >= r {\n                 return a.c;\n             }"}, {"sha": "38c8d1903e980424a9ee307586db3abbfccc32b2", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -47,11 +47,11 @@ struct AminoAcids {\n fn make_cumulative(aa: ~[AminoAcids]) -> ~[AminoAcids] {\n     let mut cp: u32 = 0u32;\n     let mut ans: ~[AminoAcids] = ~[];\n-    for aa.each |a| {\n+    for aa.iter().advance |a| {\n         cp += a.prob;\n         ans += [AminoAcids {ch: a.ch, prob: cp}];\n     }\n-    return ans;\n+    ans\n }\n \n fn select_random(r: u32, genelist: ~[AminoAcids]) -> char {\n@@ -64,7 +64,7 @@ fn select_random(r: u32, genelist: ~[AminoAcids]) -> char {\n             } else { return bisect(v, mid, hi, target); }\n         } else { return v[hi].ch; }\n     }\n-    return bisect(copy genelist, 0, genelist.len() - 1, r);\n+    bisect(copy genelist, 0, genelist.len() - 1, r)\n }\n \n fn make_random_fasta(wr: @io::Writer,\n@@ -106,7 +106,7 @@ fn make_repeat_fasta(wr: @io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n }\n \n fn acid(ch: char, prob: u32) -> AminoAcids {\n-    return AminoAcids {ch: ch, prob: prob};\n+    AminoAcids {ch: ch, prob: prob}\n }\n \n fn main() {"}, {"sha": "c33c2258864fa5ab4e274f8b9bb56044c8cfeee2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -64,7 +64,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    let mut buffer = ~\"\";\n \n-   for pairs_sorted.each |kv| {\n+   for pairs_sorted.iter().advance |kv| {\n        let (k,v) = copy *kv;\n        unsafe {\n            let b = str::raw::from_bytes(k);"}, {"sha": "01425d82db29688641a104b88a941580d9436134", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -91,7 +91,7 @@ fn stress(num_tasks: int) {\n             stress_task(i);\n         }\n     }\n-    for results.each |r| {\n+    for results.iter().advance |r| {\n         r.recv();\n     }\n }"}, {"sha": "dd72a71b215b68458f11717d75a0dc65a21ea911", "filename": "src/test/compile-fail/borrowck-mut-boxed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-boxed-vec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let v = @mut [ 1, 2, 3 ];\n-    for v.each |_x| {\n+    for v.iter().advance |_x| {\n         v[1] = 4; //~ ERROR cannot assign\n     }\n }"}, {"sha": "f7b9371df5731b2293fcdecde71bd43987aa946a", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -15,7 +15,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(A) -> ~[B]) {\n         let mut r = fail!();\n-        for self.each |elt| { r += f(*elt); }\n+        for self.iter().advance |elt| { r += f(*elt); }\n         //~^ WARNING unreachable expression\n         //~^^ ERROR the type of this value must be known\n    }"}, {"sha": "59789223bf2597aa85da9d7f4104f9c712723ba8", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -14,7 +14,7 @@\n fn fail_len(v: ~[int]) -> uint {\n     let mut i = 3;\n     fail!();\n-    for v.each |x| { i += 1u; }\n+    for v.iter().advance |x| { i += 1u; }\n     //~^ ERROR: unreachable statement\n     return i;\n }"}, {"sha": "7a6b8c5606ba4641ea60f5b35cc592db02cc5055", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -37,7 +37,7 @@ fn main() {\n              ('c', 'd'),\n              ('e', 'f')];\n \n-    for v.each |&(x,y)| {} // should be OK\n+    for v.iter().advance |&(x,y)| {} // should be OK\n \n     // Make sure none of the errors above were fatal\n     let x: char = true; //~ ERROR expected `char` but found `bool`"}, {"sha": "dbf28caecf290dfc4a5ab2c70d63153582403285", "filename": "src/test/pretty/block-comment-wchar.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.pp?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -109,7 +109,7 @@\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n      // <= bugs in pretty-printer?\n-    for chars.each |c| {\n+    for chars.iter().advance |c| {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\" , c , ws));\n     }"}, {"sha": "148b50d9c9129a4bef628806dde998058bebae7d", "filename": "src/test/pretty/block-comment-wchar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-comment-wchar.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -102,7 +102,7 @@ fn main() {\n          '\\xA0', '\\u1680', '\\u180E', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n          '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009', '\\u200A',\n          '\\u2028', '\\u2029', '\\u202F', '\\u205F', '\\u3000'];\n-    for chars.each |c| {\n+    for chars.iter().advance |c| {\n         let ws = c.is_whitespace();\n         println(fmt!(\"%? %?\", c , ws)); // <= bugs in pretty-printer?\n     }"}, {"sha": "6da1f9131a50ddbd9e5f486e58f1dbb43727585b", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.iter().advance |x| { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "3092cd5338c02fb42bf7bcdc9e835bab23e1341a", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.iter().advance |x| { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "21ea875b2f4b5276512a95a0132fbf9bbbd27d81", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -10,7 +10,7 @@\n \n fn sum_slice(x: &[int]) -> int {\n     let mut sum = 0;\n-    for x.each |i| { sum += *i; }\n+    for x.iter().advance |i| { sum += *i; }\n     return sum;\n }\n "}, {"sha": "612a472cde58dc9750eb8fe2e998e1d4e6e57c41", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm-3.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -4,7 +4,7 @@ struct Wizard {\n \n impl Wizard {\n     pub fn cast(&mut self) {\n-        for self.spells.each |&spell| {\n+        for self.spells.iter().advance |&spell| {\n             println(spell);\n         }\n     }"}, {"sha": "9fc68cd11275184632268eef79fafb7a516ec37f", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-fast\n+\n /*!\n  * Try to double-check that static fns have the right size (with or\n  * without dummy env ptr, as appropriate) by iterating a size-2 array.\n@@ -21,6 +23,6 @@ struct S<'self>(&'self fn());\n static closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {\n-    for bare_fns.each |&bare_fn| { bare_fn() }\n-    for closures.each |&closure| { (*closure)() }\n+    for std::vec::each(bare_fns) |&bare_fn| { bare_fn() }\n+    for std::vec::each(closures) |&closure| { (*closure)() }\n }"}, {"sha": "1b87c16b4b900e3e77ab037271c38e8baa62fa48", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -16,10 +16,10 @@ struct Box {\n \n impl Box {\n     pub fn set_many(&mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = *x; }\n+        for xs.iter().advance |x| { self.x = *x; }\n     }\n     pub fn set_many2(@mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = *x; }\n+        for xs.iter().advance |x| { self.x = *x; }\n     }\n }\n "}, {"sha": "bb8df4bb33f0eced4a58a2d7c1483a1afed806e9", "filename": "src/test/run-pass/fn-pattern-expected-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type-2.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -10,7 +10,7 @@\n \n pub fn main() {\n     let v : &[(int,int)] = &[ (1, 2), (3, 4), (5, 6) ];\n-    for v.each |&(x, y)| {\n+    for v.iter().advance |&(x, y)| {\n         println(y.to_str());\n         println(x.to_str());\n     }"}, {"sha": "bf916dfa2bd250b8384f59ed661b12bb58b53653", "filename": "src/test/run-pass/for-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-fail.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let x: ~[int] = ~[]; for x.each |_i| { fail!(\"moop\"); } }\n+pub fn main() { let x: ~[int] = ~[]; for x.iter().advance |_| { fail!(\"moop\"); } }"}, {"sha": "ecf6546e741efd56fe2d7386373163b608d2b698", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -31,7 +31,7 @@ mod map_reduce {\n     enum ctrl_proto { find_reducer(~[u8], Chan<int>), mapper_done, }\n \n     fn start_mappers(ctrl: SharedChan<ctrl_proto>, inputs: ~[~str]) {\n-        for inputs.each |i| {\n+        for inputs.iter().advance |i| {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n             task::spawn(|| map_task(ctrl.clone(), i.clone()) );"}, {"sha": "bd4e3f84719f39b10ede2ec9c78e3fd29ee22fef", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -73,7 +73,7 @@ fn read_board_grid<rdr:'static + io::Reader>(in: rdr) -> ~[~[square]] {\n         grid.push(row)\n     }\n     let width = grid[0].len();\n-    for grid.each |row| { assert!(row.len() == width) }\n+    for grid.iter().advance |row| { assert!(row.len() == width) }\n     grid\n }\n "}, {"sha": "8dcf4ed4a48619f523f4e559000961d08a077d4b", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -14,7 +14,7 @@ struct trie_node {\n }\n \n fn print_str_vector(vector: ~[~str]) {\n-    for vector.each() |string| {\n+    for vector.iter().advance |string| {\n         println(*string);\n     }\n }"}, {"sha": "7d0ba866faf32dabaed67e1f54e1209c4191df96", "filename": "src/test/run-pass/issue-3563-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-2.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -12,7 +12,7 @@\n trait Canvas {\n     fn add_point(&self, point: &int);\n     fn add_points(&self, shapes: &[int]) {\n-        for shapes.each |pt| {\n+        for shapes.iter().advance |pt| {\n             self.add_point(pt)\n         }\n     }"}, {"sha": "012e70988ad1a225be9f7e883552eb9b1912d207", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 22, "deletions": 46, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -34,23 +34,20 @@ struct Point {\n \n // Represents an offset on a canvas. (This has the same structure as a Point.\n // but different semantics).\n-struct Size\n-{\n+struct Size {\n     width: int,\n     height: int,\n }\n \n-struct Rect\n-{\n+struct Rect {\n     top_left: Point,\n     size: Size,\n }\n \n // TODO: operators\n \n // Contains the information needed to do shape rendering via ASCII art.\n-struct AsciiArt\n-{\n+struct AsciiArt {\n     width: uint,\n     height: uint,\n     priv fill: char,\n@@ -67,15 +64,11 @@ impl Drop for AsciiArt {\n // It's common to define a constructor sort of function to create struct instances.\n // If there is a canonical constructor it is typically named the same as the type.\n // Other constructor sort of functions are typically named from_foo, from_bar, etc.\n-fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt\n-{\n+fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // Use an anonymous function to build a vector of vectors containing\n     // blank characters for each position in our canvas.\n-    let mut lines = do vec::build_sized(height)\n-        |push|\n-        {\n-            for height.times\n-            {\n+    let mut lines = do vec::build_sized(height) |push| {\n+            for height.times {\n                 let mut line = ~[];\n                 vec::grow_set(&mut line, width-1, &'.', '.');\n                 push(line);\n@@ -88,14 +81,10 @@ fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt\n }\n \n // Methods particular to the AsciiArt struct.\n-impl AsciiArt\n-{\n-    fn add_pt(&mut self, x: int, y: int)\n-    {\n-        if x >= 0 && x < self.width as int\n-        {\n-            if y >= 0 && y < self.height as int\n-            {\n+impl AsciiArt {\n+    fn add_pt(&mut self, x: int, y: int) {\n+        if x >= 0 && x < self.width as int {\n+            if y >= 0 && y < self.height as int {\n                 // Note that numeric types don't implicitly convert to each other.\n                 let v = y as uint;\n                 let h = x as uint;\n@@ -127,42 +116,34 @@ impl ToStr for AsciiArt {\n // This is similar to an interface in other languages: it defines a protocol which\n // developers can implement for arbitrary concrete types.\n #[allow(default_methods)]\n-trait Canvas\n-{\n+trait Canvas {\n     fn add_point(&mut self, shape: Point);\n     fn add_rect(&mut self, shape: Rect);\n \n     // Unlike interfaces traits support default implementations.\n     // Got an ICE as soon as I added this method.\n-    fn add_points(&mut self, shapes: &[Point])\n-    {\n-        for shapes.each |pt| {self.add_point(*pt)};\n+    fn add_points(&mut self, shapes: &[Point]) {\n+        for shapes.iter().advance |pt| {self.add_point(*pt)};\n     }\n }\n \n // Here we provide an implementation of the Canvas methods for AsciiArt.\n // Other implementations could also be provided (e.g. for PDF or Apple's Quartz)\n // and code can use them polymorphically via the Canvas trait.\n impl Canvas for AsciiArt {\n-    fn add_point(&mut self, shape: Point)\n-    {\n+    fn add_point(&mut self, shape: Point) {\n         self.add_pt(shape.x, shape.y);\n     }\n \n-    fn add_rect(&mut self, shape: Rect)\n-    {\n+    fn add_rect(&mut self, shape: Rect) {\n         // Add the top and bottom lines.\n-        for int::range(shape.top_left.x, shape.top_left.x + shape.size.width)\n-        |x|\n-        {\n+        for int::range(shape.top_left.x, shape.top_left.x + shape.size.width) |x| {\n             self.add_pt(x, shape.top_left.y);\n             self.add_pt(x, shape.top_left.y + shape.size.height - 1);\n         }\n \n         // Add the left and right lines.\n-        for int::range(shape.top_left.y, shape.top_left.y + shape.size.height)\n-        |y|\n-        {\n+        for int::range(shape.top_left.y, shape.top_left.y + shape.size.height) |y|{\n             self.add_pt(shape.top_left.x, y);\n             self.add_pt(shape.top_left.x + shape.size.width - 1, y);\n         }\n@@ -171,26 +152,22 @@ impl Canvas for AsciiArt {\n \n // Rust's unit testing framework is currently a bit under-developed so we'll use\n // this little helper.\n-pub fn check_strs(actual: &str, expected: &str) -> bool\n-{\n-    if actual != expected\n-    {\n+pub fn check_strs(actual: &str, expected: &str) -> bool {\n+    if actual != expected {\n         io::stderr().write_line(fmt!(\"Found:\\n%s\\nbut expected\\n%s\", actual, expected));\n         return false;\n     }\n     return true;\n }\n \n \n-fn test_ascii_art_ctor()\n-{\n+fn test_ascii_art_ctor() {\n     let art = AsciiArt(3, 3, '*');\n     assert!(check_strs(art.to_str(), \"...\\n...\\n...\"));\n }\n \n \n-fn test_add_pt()\n-{\n+fn test_add_pt() {\n     let mut art = AsciiArt(3, 3, '*');\n     art.add_pt(0, 0);\n     art.add_pt(0, -10);\n@@ -199,8 +176,7 @@ fn test_add_pt()\n }\n \n \n-fn test_shapes()\n-{\n+fn test_shapes() {\n     let mut art = AsciiArt(4, 4, '*');\n     art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n     art.add_point(Point {x: 2, y: 2});"}, {"sha": "71b87b3311baa4cc534d257f22cbbdc3602824c2", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -11,7 +11,7 @@\n pub fn main() {\n     let x = ~[1, 2, 3];\n     let mut y = 0;\n-    for x.each |i| { debug!(*i); y += *i; }\n+    for x.iter().advance |i| { debug!(*i); y += *i; }\n     debug!(y);\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";"}, {"sha": "aec16e2d47bd62abdfe4c60758c8bf9567df2a91", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -11,6 +11,6 @@\n pub fn main() {\n     let x = ~[10, 20, 30];\n     let mut sum = 0;\n-    for x.each |x| { sum += *x; }\n+    for x.iter().advance |x| { sum += *x; }\n     assert_eq!(sum, 60);\n }"}, {"sha": "3f3cf5e5aaa0eebea828908af1f6ef7679b3ec03", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -19,7 +19,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B:Copy>(&self, f: &fn(&A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n-        for self.each |elt| { r += f(elt); }\n+        for self.iter().advance |elt| { r += f(elt); }\n         r\n     }\n }"}, {"sha": "1a670960f39c5b0c29f4ca22cf78c7e2de588841", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -68,7 +68,7 @@ pub fn main() {\n         calllink10\n     ];\n     let mut rng = rand::rng();\n-    for fns.each |f| {\n+    for fns.iter().advance |f| {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;"}, {"sha": "b0ce6556cb6a6940be674124629829a62abd182e", "filename": "src/test/run-pass/mutability-inherits-through-fixed-length-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -17,7 +17,7 @@ fn test1() {\n fn test2() {\n     let mut ints = [0, ..32];\n     for ints.mut_iter().advance |i| { *i += 22; }\n-    for ints.each |i| { assert!(*i == 22); }\n+    for ints.iter().advance |i| { assert!(*i == 22); }\n }\n \n pub fn main() {"}, {"sha": "b995e9c9ed2e3c114cf33ab6792e2f9498abfd19", "filename": "src/test/run-pass/overload-index-operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverload-index-operator.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -30,7 +30,7 @@ impl<K,V> AssociationList<K,V> {\n \n impl<K:Eq,V:Copy> Index<K,V> for AssociationList<K,V> {\n     fn index(&self, index: &K) -> V {\n-        for self.pairs.each |pair| {\n+        for self.pairs.iter().advance |pair| {\n             if pair.key == *index {\n                 return copy pair.value;\n             }"}, {"sha": "de34d589afc7d65f6cbae398add91993f4a1eac8", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -27,7 +27,7 @@ fn main() {\n         assert_eq!(foos[i], Foo { bar: 1, baz: 2});\n     }\n \n-    for foos.each |&foo| {\n+    for foos.iter().advance |&foo| {\n         assert_eq!(foo, Foo { bar: 1, baz: 2 });\n     }\n }"}, {"sha": "a8571ab73254b963554530bd920e956a8e63383a", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -656,7 +656,8 @@ pub fn main() {\n         let v = @v as @TyVisitor;\n         visit_tydesc(td, v);\n \n-        for (u.vals.clone()).each |s| {\n+        let r = u.vals.clone();\n+        for r.iter().advance |s| {\n             println(fmt!(\"val: %s\", *s));\n         }\n         error!(\"%?\", u.vals.clone());"}, {"sha": "85575b2ea8bb6803f6039f6512dcbf231debe6f4", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -15,14 +15,14 @@ fn foo(c: ~[int]) {\n \n \n     match none::<int> {\n-      some::<int>(_) => {\n-        for c.each |i| {\n-            debug!(a);\n-            let a = 17;\n-            b += ~[a];\n+        some::<int>(_) => {\n+            for c.iter().advance |i| {\n+                debug!(a);\n+                let a = 17;\n+                b += ~[a];\n+            }\n         }\n-      }\n-      _ => { }\n+        _ => { }\n     }\n }\n "}, {"sha": "421cd1d4d0bb32c4a167ee0ded12deae7b89a641", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -48,10 +48,10 @@ trait vec_utils<T> {\n \n impl<T> vec_utils<T> for ~[T] {\n     fn length_(&self) -> uint { self.len() }\n-    fn iter_(&self, f: &fn(&T)) { for self.each |x| { f(x); } }\n+    fn iter_(&self, f: &fn(&T)) { for self.iter().advance |x| { f(x); } }\n     fn map_<U:Copy>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for self.each |elt| { r += ~[f(elt)]; }\n+        for self.iter().advance |elt| { r += ~[f(elt)]; }\n         r\n     }\n }"}, {"sha": "2d6b2141c5c73cdc7b9a42cbaad01f679813207d", "filename": "src/test/run-pass/static-method-test.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c9342663df3e705f6fe380f3d4f46c4a7be8035e/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9342663df3e705f6fe380f3d4f46c4a7be8035e/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=c9342663df3e705f6fe380f3d4f46c4a7be8035e", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-use std::at_vec;\n-use std::uint;\n-use std::vec;\n-\n-// A trait for objects that can be used to do an if-then-else\n-// (No actual need for this to be static, but it is a simple test.)\n-trait bool_like {\n-    fn select<A>(b: Self, x1: A, x2: A) -> A;\n-}\n-\n-fn andand<T:bool_like + Copy>(x1: T, x2: T) -> T {\n-    bool_like::select(copy x1, x2, x1)\n-}\n-\n-impl bool_like for bool {\n-    fn select<A>(b: bool, x1: A, x2: A) -> A {\n-        if b { x1 } else { x2 }\n-    }\n-}\n-\n-impl bool_like for int {\n-    fn select<A>(b: int, x1: A, x2: A) -> A {\n-        if b != 0 { x1 } else { x2 }\n-    }\n-}\n-\n-// A trait for sequences that can be constructed imperatively.\n-trait buildable<A> {\n-     fn build_sized(size: uint, builder: &fn(push: &fn(v: A))) -> Self;\n-}\n-\n-\n-impl<A> buildable<A> for @[A] {\n-    #[inline(always)]\n-     fn build_sized(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n-         at_vec::build_sized(size, builder)\n-     }\n-}\n-impl<A> buildable<A> for ~[A] {\n-    #[inline(always)]\n-     fn build_sized(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n-         vec::build_sized(size, builder)\n-     }\n-}\n-\n-#[inline(always)]\n-fn build<A, B: buildable<A>>(builder: &fn(push: &fn(v: A))) -> B {\n-    buildable::build_sized(4, builder)\n-}\n-\n-/// Apply a function to each element of an iterable and return the results\n-fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n-    (v: IT, f: &fn(&T) -> U) -> BU {\n-    do build |push| {\n-        for v.each() |elem| {\n-            push(f(elem));\n-        }\n-    }\n-}\n-\n-fn seq_range<BT:buildable<int>>(lo: uint, hi: uint) -> BT {\n-    do buildable::build_sized(hi-lo) |push| {\n-        for uint::range(lo, hi) |i| {\n-            push(i as int);\n-        }\n-    }\n-}\n-\n-pub fn main() {\n-    let v: @[int] = seq_range(0, 10);\n-    assert_eq!(v, @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n-\n-    let v: @[int] = map(&[1,2,3], |&x| 1+x);\n-    assert_eq!(v, @[2, 3, 4]);\n-    let v: ~[int] = map(&[1,2,3], |&x| 1+x);\n-    assert_eq!(v, ~[2, 3, 4]);\n-\n-    assert_eq!(bool_like::select(true, 9, 14), 9);\n-    assert!(!andand(true, false));\n-    assert_eq!(andand(7, 12), 12);\n-    assert_eq!(andand(0, 12), 0);\n-}"}, {"sha": "f94b548737491f0cedb62d31bb95515fc4ac8204", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -54,7 +54,7 @@ fn test00() {\n \n     // Read from spawned tasks...\n     let mut sum = 0;\n-    for results.each |r| {\n+    for results.iter().advance |r| {\n         i = 0;\n         while i < number_of_messages {\n             let value = po.recv();\n@@ -64,7 +64,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for results.each |r| { r.recv(); }\n+    for results.iter().advance |r| { r.recv(); }\n \n     debug!(\"Completed: Final number is: \");\n     error!(sum);"}, {"sha": "c25cdc85cb6ae025e114329dccac7212abd2a760", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e9912aea87f9b1812a0f44e093c0405848f7ce/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=d2e9912aea87f9b1812a0f44e093c0405848f7ce", "patch": "@@ -31,7 +31,7 @@ trait map<T> {\n impl<T> map<T> for ~[T] {\n     fn map<U:Copy>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for self.each |x| { r += ~[f(x)]; }\n+        for std::vec::each(*self) |x| { r += ~[f(x)]; }\n         r\n     }\n }"}]}