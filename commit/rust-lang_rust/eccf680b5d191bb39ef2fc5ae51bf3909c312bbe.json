{"sha": "eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjY2Y2ODBiNWQxOTFiYjM5ZWYyZmM1YWU1MWJmMzkwOWMzMTJiYmU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-06T14:03:24Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-06T14:03:24Z"}, "message": "Remove type_size and type_align calls", "tree": {"sha": "01f560f57c57f8a4612b1032f98435931e65bec8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01f560f57c57f8a4612b1032f98435931e65bec8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "html_url": "https://github.com/rust-lang/rust/commit/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd630a2a263105f104b82dd53a1b9b90d4206a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd630a2a263105f104b82dd53a1b9b90d4206a3d", "html_url": "https://github.com/rust-lang/rust/commit/dd630a2a263105f104b82dd53a1b9b90d4206a3d"}], "stats": {"total": 78, "additions": 30, "deletions": 48}, "files": [{"sha": "8961ae4d2029c4ff8198853260870189e4268064", "filename": "miri/fn_call.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "patch": "@@ -1,4 +1,5 @@\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::LayoutOf;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use syntax::attr;\n@@ -261,7 +262,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let result = {\n                     let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n-                    match self.machine_data.env_vars.get(name) {\n+                    match self.machine.env_vars.get(name) {\n                         Some(&var) => PrimVal::Ptr(var),\n                         None => PrimVal::Bytes(0),\n                     }\n@@ -276,7 +277,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.machine_data.env_vars.remove(name));\n+                            success = Some(self.machine.env_vars.remove(name));\n                         }\n                     }\n                 }\n@@ -313,7 +314,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n-                    if let Some(var) = self.machine_data.env_vars.insert(\n+                    if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n                         value_copy,\n                     )\n@@ -416,9 +417,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = args[0].ty.builtin_deref(true, ty::PlacePreference::NoPreference)\n+                let key_type = args[0].ty.builtin_deref(true, ty::LvaluePreference::NoPreference)\n                                    .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n-                let key_size = self.type_layout(key_type)?.size;\n+                let key_size = self.layout_of(key_type)?.size;\n \n                 // Create key and write it into the memory where key_ptr wants it\n                 let key = self.memory.create_tls_key(dtor) as u128;"}, {"sha": "9ca85a6018e1080e53b4bac90b52bf3a809e9bb0", "filename": "miri/helpers.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "patch": "@@ -1,6 +1,7 @@\n use rustc::mir::interpret::{Pointer, EvalResult, PrimVal, EvalContext};\n \n use rustc::ty::Ty;\n+use rustc::ty::layout::LayoutOf;\n \n pub trait EvalContextExt<'tcx> {\n     fn wrapping_pointer_offset(\n@@ -26,9 +27,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         offset: i64,\n     ) -> EvalResult<'tcx, Pointer> {\n         // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\n-            \"cannot offset a pointer to an unsized type\",\n-        ) as i64;\n+        let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n         ptr.wrapping_signed_offset(offset, self)\n     }\n@@ -53,9 +52,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             };\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\n-            \"cannot offset a pointer to an unsized type\",\n-        ) as i64;\n+        let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway."}, {"sha": "a509606aaaa09f6cebdac00932a894af108bb0c9", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "patch": "@@ -1,6 +1,6 @@\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::TyLayout;\n+use rustc::ty::layout::{TyLayout, LayoutOf};\n use rustc::ty;\n \n use rustc::mir::interpret::{EvalResult, Place, PlaceExtra, PrimVal, PrimValKind, Value, Pointer,\n@@ -204,12 +204,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"copy\" |\n             \"copy_nonoverlapping\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n+                let elem_layout = self.layout_of(elem_ty)?;\n+                let elem_size = elem_layout.size.bytes();\n                 let count = self.value_to_primval(args[2])?.to_u64()?;\n                 if count * elem_size != 0 {\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n-                    let elem_align = self.type_align(elem_ty)?;\n+                    let elem_align = elem_layout.align.abi();\n                     let src = args[0].into_ptr(&self.memory)?;\n                     let dest = args[1].into_ptr(&self.memory)?;\n                     self.memory.copy(\n@@ -308,7 +309,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"likely\" | \"unlikely\" | \"forget\" => {}\n \n             \"init\" => {\n-                let size = self.type_size(dest_layout.ty)?.expect(\"cannot zero unsized value\");\n+                let size = dest_layout.size.bytes();\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n                         Value::ByRef(PtrAndAlign { ptr, .. }) => {\n@@ -321,7 +322,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                             match this.ty_to_primval_kind(dest_layout.ty) {\n                                 Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                                 Err(_) => {\n-                                    let ptr = this.alloc_ptr_with_substs(dest_layout.ty, substs)?;\n+                                    // FIXME(oli-obk): pass TyLayout to alloc_ptr instead of Ty\n+                                    let ptr = this.alloc_ptr(dest_layout.ty)?;\n                                     let ptr = Pointer::from(PrimVal::Ptr(ptr));\n                                     this.memory.write_repeat(ptr, 0, size)?;\n                                     Value::by_ref(ptr)\n@@ -349,14 +351,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_align = self.type_align(elem_ty)?;\n+                let elem_align = self.layout_of(elem_ty)?.align.abi();\n                 let align_val = PrimVal::from_u128(elem_align as u128);\n                 self.write_primval(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n-                let layout = self.type_layout(ty)?;\n+                let layout = self.layout_of(ty)?;\n                 let align = layout.align.pref();\n                 let align_val = PrimVal::from_u128(align as u128);\n                 self.write_primval(dest, align_val, dest_layout.ty)?;\n@@ -492,9 +494,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                let size = self.type_size(ty)?.expect(\n-                    \"size_of intrinsic called on unsized value\",\n-                ) as u128;\n+                let size = self.layout_of(ty)?.size.bytes().into();\n                 self.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n             }\n \n@@ -544,9 +544,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"unchecked_shl\" => {\n-                let bits = self.type_size(dest_layout.ty)?.expect(\n-                    \"intrinsic can't be called on unsized type\",\n-                ) as u128 * 8;\n+                let bits = dest_layout.size.bytes() as u128 * 8;\n                 let rhs = self.value_to_primval(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n@@ -564,9 +562,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"unchecked_shr\" => {\n-                let bits = self.type_size(dest_layout.ty)?.expect(\n-                    \"intrinsic can't be called on unsized type\",\n-                ) as u128 * 8;\n+                let bits = dest_layout.size.bytes() as u128 * 8;\n                 let rhs = self.value_to_primval(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n@@ -636,18 +632,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"write_bytes\" => {\n                 let ty = substs.type_at(0);\n-                let ty_align = self.type_align(ty)?;\n+                let ty_layout = self.layout_of(ty)?;\n                 let val_byte = self.value_to_primval(args[1])?.to_u128()? as u8;\n-                let size = self.type_size(ty)?.expect(\n-                    \"write_bytes() type must be sized\",\n-                );\n                 let ptr = args[0].into_ptr(&self.memory)?;\n                 let count = self.value_to_primval(args[2])?.to_u64()?;\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_align, Some(AccessKind::Write))?;\n-                    self.memory.write_repeat(ptr, val_byte, size * count)?;\n+                    self.memory.check_align(ptr, ty_layout.align.abi(), Some(AccessKind::Write))?;\n+                    self.memory.write_repeat(ptr, val_byte, ty_layout.size.bytes() * count)?;\n                 }\n             }\n "}, {"sha": "398062b8c2245741435e102de0e954fecc886249", "filename": "miri/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eccf680b5d191bb39ef2fc5ae51bf3909c312bbe/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=eccf680b5d191bb39ef2fc5ae51bf3909c312bbe", "patch": "@@ -11,7 +11,7 @@ extern crate rustc;\n extern crate syntax;\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::TyLayout;\n+use rustc::ty::layout::{TyLayout, LayoutOf};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::traits;\n@@ -141,7 +141,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         Ok(())\n     }\n \n-    let mut ecx = EvalContext::new(tcx, limits, Default::default(), Default::default());\n+    let mut ecx = EvalContext::new(tcx, ty::ParamEnv::empty(traits::Reveal::All), limits, Default::default(), Default::default());\n     match run_main(&mut ecx, main_id, start_wrapper) {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n@@ -155,9 +155,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     }\n }\n \n-pub struct Evaluator;\n #[derive(Default)]\n-pub struct EvaluatorData {\n+pub struct Evaluator {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n     pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n@@ -181,16 +180,9 @@ pub struct MemoryData<'tcx> {\n }\n \n impl<'tcx> Machine<'tcx> for Evaluator {\n-    type Data = EvaluatorData;\n     type MemoryData = MemoryData<'tcx>;\n     type MemoryKinds = memory::MemoryKind;\n \n-    fn param_env<'a>(\n-        _: &EvalContext<'a, 'tcx, Self>,\n-    ) -> ty::ParamEnv<'tcx> {\n-        ty::ParamEnv::empty(traits::Reveal::All)\n-    }\n-\n     /// Returns Ok() when the function was handled, fail otherwise\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n@@ -239,8 +231,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ty: ty::Ty<'tcx>,\n         dest: Place,\n     ) -> EvalResult<'tcx> {\n-        let size = ecx.type_size(ty)?.expect(\"box only works with sized types\");\n-        let align = ecx.type_align(ty)?;\n+        let layout = ecx.layout_of(ty)?;\n \n         // Call the `exchange_malloc` lang item\n         let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n@@ -264,7 +255,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(size as u128)),\n+                value: Value::ByVal(PrimVal::Bytes(layout.size.bytes().into())),\n                 ty: usize,\n             },\n             dest,\n@@ -274,7 +265,7 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(align as u128)),\n+                value: Value::ByVal(PrimVal::Bytes(layout.align.abi().into())),\n                 ty: usize,\n             },\n             dest,"}]}