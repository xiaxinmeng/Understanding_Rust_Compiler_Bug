{"sha": "8b99c61701cd3230bb24fba970d2f400e6e09fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOTljNjE3MDFjZDMyMzBiYjI0ZmJhOTcwZDJmNDAwZTZlMDlmYTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-05-12T16:47:20Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-19T12:24:24Z"}, "message": "Ensure that statics are always ByRef", "tree": {"sha": "8fbb33beb424a2aef89841af69dd3df7f3e3249f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fbb33beb424a2aef89841af69dd3df7f3e3249f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b99c61701cd3230bb24fba970d2f400e6e09fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b99c61701cd3230bb24fba970d2f400e6e09fa1", "html_url": "https://github.com/rust-lang/rust/commit/8b99c61701cd3230bb24fba970d2f400e6e09fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b99c61701cd3230bb24fba970d2f400e6e09fa1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c95e1cccc9c248789230a54ecfd87971a04d5c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c95e1cccc9c248789230a54ecfd87971a04d5c0c", "html_url": "https://github.com/rust-lang/rust/commit/c95e1cccc9c248789230a54ecfd87971a04d5c0c"}], "stats": {"total": 202, "additions": 69, "deletions": 133}, "files": [{"sha": "66a8b3ca36fb0f1109079c64546912ac1ed46a71", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 46, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8b99c61701cd3230bb24fba970d2f400e6e09fa1/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b99c61701cd3230bb24fba970d2f400e6e09fa1/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=8b99c61701cd3230bb24fba970d2f400e6e09fa1", "patch": "@@ -81,49 +81,6 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n     }\n }\n \n-fn const_value_to_llvm<'tcx>(cx: &CodegenCx<'_, 'tcx>, val: ConstValue, ty: Ty<'tcx>) -> ValueRef {\n-    let layout = cx.layout_of(ty);\n-\n-    if layout.is_zst() {\n-        return C_undef(layout.immediate_llvm_type(cx));\n-    }\n-\n-    match val {\n-        ConstValue::ByVal(x) => {\n-            let scalar = match layout.abi {\n-                layout::Abi::Scalar(ref x) => x,\n-                _ => bug!(\"const_value_to_llvm: invalid ByVal layout: {:#?}\", layout)\n-            };\n-            primval_to_llvm(\n-                cx,\n-                x,\n-                scalar,\n-                layout.immediate_llvm_type(cx),\n-            )\n-        },\n-        ConstValue::ByValPair(a, b) => {\n-            let (a_scalar, b_scalar) = match layout.abi {\n-                layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n-                _ => bug!(\"const_value_to_llvm: invalid ByValPair layout: {:#?}\", layout)\n-            };\n-            let a_llval = primval_to_llvm(\n-                cx,\n-                a,\n-                a_scalar,\n-                layout.scalar_pair_element_llvm_type(cx, 0),\n-            );\n-            let b_llval = primval_to_llvm(\n-                cx,\n-                b,\n-                b_scalar,\n-                layout.scalar_pair_element_llvm_type(cx, 1),\n-            );\n-            C_struct(cx, &[a_llval, b_llval], false)\n-        },\n-        ConstValue::ByRef(alloc) => const_alloc_to_llvm(cx, alloc),\n-    }\n-}\n-\n pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n     let layout = cx.data_layout();\n@@ -171,11 +128,11 @@ pub fn codegen_static_initializer<'a, 'tcx>(\n     let param_env = ty::ParamEnv::reveal_all();\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n-    let val = match static_.val {\n-        ConstVal::Value(val) => val,\n+    let alloc = match static_.val {\n+        ConstVal::Value(ConstValue::ByRef(alloc)) => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n-    Ok(const_value_to_llvm(cx, val, static_.ty))\n+    Ok(const_alloc_to_llvm(cx, alloc))\n }\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {"}, {"sha": "1f368cd3dfc1a1e01a0de8422f649dddf2d856cd", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 59, "deletions": 86, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/8b99c61701cd3230bb24fba970d2f400e6e09fa1/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b99c61701cd3230bb24fba970d2f400e6e09fa1/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=8b99c61701cd3230bb24fba970d2f400e6e09fa1", "patch": "@@ -98,59 +98,32 @@ pub fn value_to_const_value<'tcx>(\n     mut val: Value,\n     ty: Ty<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    let result = (|| {\n+    let val = (|| {\n         // Convert to ByVal or ByValPair if possible\n         if let Value::ByRef(ptr, align) = val {\n             if let Some(read_val) = ecx.try_read_value(ptr, align, ty)? {\n                 val = read_val;\n             }\n         }\n-\n-        let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n-\n-        if layout.is_zst() {\n-            return Ok(ty::Const::from_const_value(\n-                ecx.tcx.tcx,\n-                ConstValue::ByVal(PrimVal::Undef),\n-                ty));\n-        }\n-\n-        let val = match layout.abi {\n-            layout::Abi::Scalar(..) => {\n-                if let Value::ByVal(val) = val {\n-                    ConstValue::ByVal(val)\n-                } else {\n-                    bug!(\"expected ByVal value, got {:?}\", val);\n-                }\n-            }\n-            layout::Abi::ScalarPair(..) => {\n-                if let Value::ByValPair(a, b) = val {\n-                    ConstValue::ByValPair(a, b)\n-                } else {\n-                    bug!(\"expected ByValPair value, got {:?}\", val);\n-                }\n+        match val {\n+            Value::ByVal(val) => Ok(ConstValue::ByVal(val)),\n+            Value::ByValPair(a, b) => Ok(ConstValue::ByValPair(a, b)),\n+            Value::ByRef(ptr, align) => {\n+                let ptr = ptr.primval.to_ptr().unwrap();\n+                assert_eq!(ptr.offset, 0);\n+                let alloc = ecx.memory.get(ptr.alloc_id)?;\n+                assert!(alloc.align.abi() >= layout.align.abi());\n+                assert!(alloc.bytes.len() as u64 == layout.size.bytes());\n+                let mut alloc = alloc.clone();\n+                // The align field is meaningless for values, so just use the layout's align\n+                alloc.align = layout.align;\n+                let alloc = ecx.tcx.intern_const_alloc(alloc);\n+                Ok(ConstValue::ByRef(alloc))\n             }\n-            _ => {\n-                if let Value::ByRef(ptr, _) = val {\n-                    let ptr = ptr.primval.to_ptr().unwrap();\n-                    assert_eq!(ptr.offset, 0);\n-                    let alloc = ecx.memory.get(ptr.alloc_id)?;\n-                    assert!(alloc.align.abi() >= layout.align.abi());\n-                    assert!(alloc.bytes.len() as u64 == layout.size.bytes());\n-                    let mut alloc = alloc.clone();\n-                    // The align field is meaningless for values, so just use the layout's align\n-                    alloc.align = layout.align;\n-                    let alloc = ecx.tcx.intern_const_alloc(alloc);\n-                    ConstValue::ByRef(alloc)\n-                } else {\n-                    bug!(\"expected ByRef value, got {:?}\", val);\n-                }\n-            },\n-        };\n-        Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, ty))\n+        }\n     })();\n     match result {\n-        Ok(v) => v,\n+        Ok(v) => ty::Const::from_const_value(tcx, val, ty),\n         Err(mut err) => {\n             ecx.report(&mut err, true, None);\n             bug!(\"miri error occured when converting Value to ConstValue\")\n@@ -182,49 +155,49 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n ) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n-        let mut mir = match mir {\n-            Some(mir) => mir,\n-            None => ecx.load_mir(cid.instance.def)?,\n-        };\n-        if let Some(index) = cid.promoted {\n-            mir = &mir.promoted[index];\n-        }\n-        let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n-        assert!(!layout.is_unsized());\n-        let ptr = ecx.memory.allocate(\n-            layout.size.bytes(),\n-            layout.align,\n-            None,\n-        )?;\n-        let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n-        let mutability = tcx.is_static(cid.instance.def_id());\n-        let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n-            Mutability::Mutable\n-        } else {\n-            Mutability::Immutable\n-        };\n-        let cleanup = StackPopCleanup::MarkStatic(mutability);\n-        let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n-        let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-        trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n-        assert!(mir.arg_count == 0);\n-        ecx.push_stack_frame(\n-            cid.instance,\n-            mir.span,\n-            mir,\n-            Place::from_ptr(ptr, layout.align),\n-            cleanup,\n-        )?;\n+    let mut mir = match mir {\n+        Some(mir) => mir,\n+        None => ecx.load_mir(cid.instance.def)?,\n+    };\n+    if let Some(index) = cid.promoted {\n+        mir = &mir.promoted[index];\n+    }\n+    let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n+    assert!(!layout.is_unsized());\n+    let ptr = ecx.memory.allocate(\n+        layout.size.bytes(),\n+        layout.align,\n+        None,\n+    )?;\n+    let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n+    let is_static = tcx.is_static(cid.instance.def_id());\n+    let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n+        Mutability::Mutable\n+    } else {\n+        Mutability::Immutable\n+    };\n+    let cleanup = StackPopCleanup::MarkStatic(mutability);\n+    let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+    trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n+    assert!(mir.arg_count == 0);\n+    ecx.push_stack_frame(\n+        cid.instance,\n+        mir.span,\n+        mir,\n+        Place::from_ptr(ptr, layout.align),\n+        cleanup,\n+    )?;\n \n-        while ecx.step()? {}\n-        let ptr = ptr.into();\n-        // always try to read the value and report errors\n-        let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n-            Some(val) => val,\n-            // point at the allocation\n-            _ => Value::ByRef(ptr, layout.align),\n-        };\n-        Ok((value, ptr, layout.ty))\n+    while ecx.step()? {}\n+    let ptr = ptr.into();\n+    // always try to read the value and report errors\n+    let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n+        Some(val) if is_static.is_none() => val,\n+        // point at the allocation\n+        _ => Value::ByRef(ptr, layout.align),\n+    };\n+    Ok((value, ptr, layout.ty))\n }\n \n pub struct CompileTimeEvaluator;"}, {"sha": "415ee6eb7eab8754834de460088b0ac260935313", "filename": "src/test/codegen/link_section.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b99c61701cd3230bb24fba970d2f400e6e09fa1/src%2Ftest%2Fcodegen%2Flink_section.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b99c61701cd3230bb24fba970d2f400e6e09fa1/src%2Ftest%2Fcodegen%2Flink_section.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flink_section.rs?ref=8b99c61701cd3230bb24fba970d2f400e6e09fa1", "patch": "@@ -12,11 +12,17 @@\n \n #![crate_type = \"lib\"]\n \n-// CHECK: @VAR1 = constant i32 1, section \".test_one\"\n+// CHECK: @VAR1 = constant <{ [4 x i8] }> <{ [4 x i8] c\"\\01\\00\\00\\00\" }>, section \".test_one\"\n #[no_mangle]\n #[link_section = \".test_one\"]\n+#[cfg(target_endian = \"little\")]\n pub static VAR1: u32 = 1;\n \n+#[no_mangle]\n+#[link_section = \".test_one\"]\n+#[cfg(target_endian = \"big\")]\n+pub static VAR1: u32 = 0x01000000;\n+\n pub enum E {\n     A(u32),\n     B(f32)"}]}