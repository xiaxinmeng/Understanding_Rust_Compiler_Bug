{"sha": "d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYmQwN2RjYjAyNzgzMDYzMzc1YjZjODUzMmZjZWFmOWZhOWQ1MGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-19T20:35:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-19T20:35:49Z"}, "message": "Remove effect system from src.", "tree": {"sha": "a253b5eadb140d14bc99d1456e316ce1e210a6be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a253b5eadb140d14bc99d1456e316ce1e210a6be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "html_url": "https://github.com/rust-lang/rust/commit/d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57", "html_url": "https://github.com/rust-lang/rust/commit/d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57"}], "stats": {"total": 1548, "additions": 509, "deletions": 1039}, "files": [{"sha": "e245990a1d7ee83f4d96a9497fa61e8035f67361", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -264,7 +264,7 @@ BOOT_MLS :=                                              \\\n           extfmt pexp item cexp fuzz)                    \\\n         $(addprefix boot/be/, asm il abi)                \\\n         $(addprefix boot/me/, walk semant resolve alias  \\\n-          simplify type dead layer effect typestate      \\\n+          simplify type dead layer typestate             \\\n          loop layout transutil trans dwarf)              \\\n         $(addprefix boot/be/, x86 ra pe elf macho)       \\\n         $(addprefix boot/driver/, lib glue main))        \\"}, {"sha": "0871d3065059fdd1e1c4bf685e9eb660234ba904", "filename": "src/boot/driver/main.ml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -43,7 +43,6 @@ let (sess:Session.sess) =\n     Session.sess_log_type = false;\n     Session.sess_log_simplify = false;\n     Session.sess_log_layer = false;\n-    Session.sess_log_effect = false;\n     Session.sess_log_typestate = false;\n     Session.sess_log_loop = false;\n     Session.sess_log_alias = false;\n@@ -192,8 +191,6 @@ let argspecs =\n        \"-lsimplify\" \"log simplification\");\n     (flag (fun _ -> sess.Session.sess_log_layer <- true)\n        \"-llayer\"  \"log layer checking\");\n-    (flag (fun _ -> sess.Session.sess_log_effect <- true)\n-       \"-leffect\"   \"log effect checking\");\n     (flag (fun _ -> sess.Session.sess_log_typestate <- true)\n        \"-ltypestate\" \"log typestate pass\");\n     (flag (fun _ -> sess.Session.sess_log_loop <- true)\n@@ -408,7 +405,6 @@ let main_pipeline _ =\n          Type.process_crate;\n          Typestate.process_crate;\n          Layer.process_crate;\n-         Effect.process_crate;\n          Loop.process_crate;\n          Alias.process_crate;\n          Dead.process_crate;"}, {"sha": "2f38ba4df9fa5dda8f67146b2118df0bb53b7969", "filename": "src/boot/driver/session.ml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fdriver%2Fsession.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fdriver%2Fsession.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fsession.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -25,7 +25,6 @@ type sess =\n   mutable sess_log_type: bool;\n   mutable sess_log_simplify: bool;\n   mutable sess_log_layer: bool;\n-  mutable sess_log_effect: bool;\n   mutable sess_log_typestate: bool;\n   mutable sess_log_dead: bool;\n   mutable sess_log_loop: bool;"}, {"sha": "c2387c5a8bbcff1e011acef7f1440d4c4dc8063c", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -28,10 +28,7 @@ type slot_key =\n    write foo[int,int].bar but not foo.bar.\n  *)\n \n-type effect =\n-    EFF_pure\n-  | EFF_impure\n-  | EFF_unsafe\n+type auth = AUTH_unsafe\n ;;\n \n type layer =\n@@ -174,7 +171,6 @@ and ty_sig =\n and ty_fn_aux =\n     {\n       fn_is_iter: bool;\n-      fn_effect: effect;\n     }\n \n and ty_fn = (ty_sig * ty_fn_aux)\n@@ -485,7 +481,7 @@ and crate' =\n     {\n       crate_items: (mod_view * mod_items);\n       crate_meta: Session.meta;\n-      crate_auth: (name, effect) Hashtbl.t;\n+      crate_auth: (name, auth) Hashtbl.t;\n       crate_required: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n       crate_required_syms: (node_id, string) Hashtbl.t;\n       crate_files: (node_id,filename) Hashtbl.t;\n@@ -708,22 +704,6 @@ and fmt_slots\n   done;\n   fmt ff \"@])\"\n \n-and fmt_effect\n-    (ff:Format.formatter)\n-    (effect:effect)\n-    : unit =\n-  match effect with\n-      EFF_pure -> ()\n-    | EFF_impure -> fmt ff \"impure\"\n-    | EFF_unsafe -> fmt ff \"unsafe\"\n-\n-and fmt_effect_qual\n-    (ff:Format.formatter)\n-    (e:effect)\n-    : unit =\n-  fmt_effect ff e;\n-  if e <> EFF_pure then fmt ff \" \";\n-\n and fmt_layer\n     (ff:Format.formatter)\n     (la:layer)\n@@ -762,7 +742,6 @@ and fmt_ty_fn\n     (tf:ty_fn)\n     : unit =\n   let (tsig, ta) = tf in\n-    fmt_effect_qual ff ta.fn_effect;\n     fmt ff \"%s\" (if ta.fn_is_iter then \"iter\" else \"fn\");\n     begin\n       match ident_and_params with\n@@ -1667,7 +1646,6 @@ and fmt_fn\n     (f:fn)\n     : unit =\n   fmt_obox ff;\n-  fmt_effect_qual ff f.fn_aux.fn_effect;\n   fmt ff \"%s \"(if f.fn_aux.fn_is_iter then \"iter\" else \"fn\");\n   fmt_ident_and_params ff id params;\n   fmt_header_slots ff f.fn_input_slots;\n@@ -1816,7 +1794,6 @@ let sprintf_atom = sprintf_fmt fmt_atom;;\n let sprintf_slot = sprintf_fmt fmt_slot;;\n let sprintf_slot_key = sprintf_fmt fmt_slot_key;;\n let sprintf_ty = sprintf_fmt fmt_ty;;\n-let sprintf_effect = sprintf_fmt fmt_effect;;\n let sprintf_carg = sprintf_fmt fmt_carg;;\n let sprintf_constr = sprintf_fmt fmt_constr;;\n let sprintf_mod_item ="}, {"sha": "fba2e7985cbb19dec7d97d5a4f0edd250c3b0c2f", "filename": "src/boot/fe/cexp.ml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fcexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fcexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fcexp.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -29,7 +29,7 @@ type meta = (Ast.ident * Ast.pexp) array;;\n \n type meta_pat = (Ast.ident * (Ast.pexp option)) array;;\n \n-type auth = (Ast.name * Ast.effect);;\n+type auth = (Ast.name * Ast.auth);;\n \n type cexp =\n     CEXP_alt of cexp_alt identified\n@@ -274,10 +274,10 @@ and parse_cexp (ps:pstate) : cexp =\n           bump ps;\n           let name = Pexp.parse_name ps in\n             expect ps EQ;\n-            let effect = Pexp.parse_effect ps in\n+            let au = Pexp.parse_auth ps in\n               expect ps SEMI;\n               let bpos = lexpos ps in\n-                CEXP_auth (span ps apos bpos (name, effect))\n+                CEXP_auth (span ps apos bpos (name, au))\n \n       | _ -> raise (unexpected ps)\n "}, {"sha": "df300b193f8240d635633c6918de24d1ac0d2f5d", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -610,7 +610,6 @@ and parse_stmts_including_none (ps:pstate) : Ast.stmt array =\n \n \n        | STATE | GC\n-       | IMPURE | UNSAFE\n        | ABS | NATIVE\n        | MOD | OBJ | TAG | TYPE | FN | USE ->\n           let items = ctxt \"stmt: decl\" parse_mod_item ps in\n@@ -794,7 +793,6 @@ and parse_in_and_out\n (* parse_fn starts at the first lparen of the sig. *)\n and parse_fn\n     (is_iter:bool)\n-    (effect:Ast.effect)\n     (ps:pstate)\n     : Ast.fn =\n     let (inputs, constrs, output) =\n@@ -804,8 +802,7 @@ and parse_fn\n       { Ast.fn_input_slots = inputs;\n         Ast.fn_input_constrs = constrs;\n         Ast.fn_output_slot = output;\n-        Ast.fn_aux = { Ast.fn_effect = effect;\n-                       Ast.fn_is_iter = is_iter; };\n+        Ast.fn_aux = { Ast.fn_is_iter = is_iter; };\n         Ast.fn_body = body; }\n \n and parse_meta_input (ps:pstate) : (Ast.ident * string option) =\n@@ -859,12 +856,11 @@ and parse_obj_item\n       do\n         let apos = lexpos ps in\n           match peek ps with\n-              IMPURE | UNSAFE | FN | ITER ->\n-                let effect = Pexp.parse_effect ps in\n+              FN | ITER ->\n                 let is_iter = (peek ps) = ITER in\n                   bump ps;\n                   let ident = ctxt \"obj fn: ident\" Pexp.parse_ident ps in\n-                  let fn = ctxt \"obj fn: fn\" (parse_fn is_iter effect) ps in\n+                  let fn = ctxt \"obj fn: fn\" (parse_fn is_iter) ps in\n                   let bpos = lexpos ps in\n                     htab_put fns ident (span ps apos bpos fn)\n             | DROP ->\n@@ -994,24 +990,17 @@ and parse_mod_item (ps:pstate)\n \n     match peek ps with\n \n-        STATE | GC | IMPURE | UNSAFE | ABS\n+        STATE | GC | ABS\n       | TYPE | OBJ | TAG | FN | ITER ->\n           let _ = Pexp.parse_opacity ps in\n           let layer = Pexp.parse_layer ps in\n-          let effect = Pexp.parse_effect ps in\n             begin\n               match peek ps with\n                   OBJ ->\n-                    if effect <> Ast.EFF_pure\n-                    then raise (err \"effect specified for obj\" ps);\n                     [| parse_obj_item ps apos layer |]\n                 | TAG ->\n-                    if effect <> Ast.EFF_pure\n-                    then raise (err \"effect specified for tag\" ps);\n                     parse_tag_item ps apos layer\n                 | TYPE ->\n-                    if effect <> Ast.EFF_pure\n-                    then raise (err \"effect specified for type\" ps);\n                     [| parse_type_item ps apos layer |]\n                 | _ ->\n                     if layer <> Ast.LAYER_value\n@@ -1020,7 +1009,7 @@ and parse_mod_item (ps:pstate)\n                       bump ps;\n                       let (ident, params) = parse_ident_and_params ps \"fn\" in\n                       let fn =\n-                        ctxt \"mod fn item: fn\" (parse_fn is_iter effect) ps\n+                        ctxt \"mod fn item: fn\" (parse_fn is_iter) ps\n                       in\n                       let bpos = lexpos ps in\n                         [| (ident,\n@@ -1119,8 +1108,7 @@ and parse_native_mod_item_from_signature (ps:pstate)\n             [| (ident,\n                 span ps apos bpos (decl params (Ast.MOD_ITEM_mod items))) |]\n \n-      | IMPURE | UNSAFE | FN | ITER ->\n-          let effect = Pexp.parse_effect ps in\n+      | FN | ITER ->\n           let is_iter = (peek ps) = ITER in\n             bump ps;\n             let (ident, params) = parse_ident_and_params ps \"fn signature\" in\n@@ -1132,8 +1120,7 @@ and parse_native_mod_item_from_signature (ps:pstate)\n                 { Ast.fn_input_slots = inputs;\n                   Ast.fn_input_constrs = constrs;\n                   Ast.fn_output_slot = output;\n-                  Ast.fn_aux = { Ast.fn_effect = effect;\n-                                 Ast.fn_is_iter = is_iter; };\n+                  Ast.fn_aux = { Ast.fn_is_iter = is_iter; };\n                   Ast.fn_body = body; }\n             in\n             let node = span ps apos bpos (decl params fn) in"}, {"sha": "5cf73166d5ca30f7e4bdb857187abb1321dd7da8", "filename": "src/boot/fe/lexer.mll", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -100,7 +100,6 @@\n                 (\"state\", STATE);\n                 (\"gc\", GC);\n \n-                (\"impure\", IMPURE);\n                 (\"unsafe\", UNSAFE);\n \n                 (\"native\", NATIVE);"}, {"sha": "5310f6df81397ef4ac32f025d545cf098da8b451", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -151,11 +151,10 @@ and parse_layer (ps:pstate) : Ast.layer =\n     | GC -> bump ps; Ast.LAYER_gc\n     |  _ -> Ast.LAYER_value\n \n-and parse_effect (ps:pstate) : Ast.effect =\n+and parse_auth (ps:pstate) : Ast.auth =\n   match peek ps with\n-      IMPURE -> bump ps; Ast.EFF_impure\n-    | UNSAFE -> bump ps; Ast.EFF_unsafe\n-    | _ -> Ast.EFF_pure\n+    | UNSAFE -> bump ps; Ast.AUTH_unsafe\n+    | _ -> raise (unexpected ps)\n \n and parse_mutability (ps:pstate) : Ast.mutability =\n   match peek ps with\n@@ -170,7 +169,6 @@ and parse_mutability (ps:pstate) : Ast.mutability =\n     | _ -> Ast.MUT_immutable\n \n and parse_ty_fn\n-    (effect:Ast.effect)\n     (ps:pstate)\n     : (Ast.ty_fn * Ast.ident option) =\n   match peek ps with\n@@ -198,8 +196,7 @@ and parse_ty_fn\n                        Ast.sig_input_constrs = constrs;\n                        Ast.sig_output_slot = out_slot; }\n           in\n-          let taux = { Ast.fn_effect = effect;\n-                       Ast.fn_is_iter = is_iter; }\n+          let taux = { Ast.fn_is_iter = is_iter; }\n           in\n           let tfn = (tsig, taux) in\n             (tfn, ident)\n@@ -280,19 +277,15 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n         bump ps;\n         Ast.TY_mach m\n \n-    | STATE | GC | IMPURE | UNSAFE | OBJ | FN | ITER ->\n+    | STATE | GC | UNSAFE | OBJ | FN | ITER ->\n         let layer = parse_layer ps in\n-        let effect = parse_effect ps in\n           begin\n             match peek ps with\n                 OBJ ->\n                   bump ps;\n-                  if effect <> Ast.EFF_pure\n-                  then raise (err \"effect specified for obj\" ps);\n                   let methods = Hashtbl.create 0 in\n                   let parse_method ps =\n-                    let effect = parse_effect ps in\n-                    let (tfn, ident) = parse_ty_fn effect ps in\n+                    let (tfn, ident) = parse_ty_fn ps in\n                       expect ps SEMI;\n                       match ident with\n                           None ->\n@@ -307,7 +300,7 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n               | FN | ITER ->\n                   if layer <> Ast.LAYER_value\n                   then raise (err \"layer specified for fn or iter\" ps);\n-                  Ast.TY_fn (fst (parse_ty_fn effect ps))\n+                  Ast.TY_fn (fst (parse_ty_fn ps))\n               | _ -> raise (unexpected ps)\n           end\n "}, {"sha": "7f4665c2f96299221c008ecc534b4284ddcadc48", "filename": "src/boot/fe/token.ml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -87,8 +87,7 @@ type token =\n   | STATE\n   | GC\n \n-  (* Effect keywords *)\n-  | IMPURE\n+  (* Unsafe-block keyword *)\n   | UNSAFE\n \n   (* Type qualifiers *)\n@@ -251,8 +250,7 @@ let rec string_of_tok t =\n     | STATE      -> \"state\"\n     | GC         -> \"gc\"\n \n-    (* Effect keywords *)\n-    | IMPURE     -> \"impure\"\n+    (* Unsafe-block keyword *)\n     | UNSAFE     -> \"unsafe\"\n \n     (* Type qualifiers *)"}, {"sha": "ff3786afaff8d6e74808f2794fe1f24c3a9af9fd", "filename": "src/boot/me/dwarf.ml", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1205,8 +1205,6 @@ let (abbrev_subprogram:abbrev) =\n      (DW_AT_high_pc, DW_FORM_addr);\n      (DW_AT_frame_base, DW_FORM_block1);\n      (DW_AT_return_addr, DW_FORM_block1);\n-     (DW_AT_mutable, DW_FORM_flag);\n-     (DW_AT_pure, DW_FORM_flag);\n      (DW_AT_rust_iterator, DW_FORM_flag);\n    |])\n ;;\n@@ -1389,8 +1387,6 @@ let (abbrev_subroutine_type:abbrev) =\n   (DW_TAG_subroutine_type, DW_CHILDREN_yes,\n    [|\n      (DW_AT_type, DW_FORM_ref_addr); (* NB: output type. *)\n-       (DW_AT_mutable, DW_FORM_flag);\n-       (DW_AT_pure, DW_FORM_flag);\n        (DW_AT_rust_iterator, DW_FORM_flag);\n      |])\n ;;\n@@ -1408,8 +1404,6 @@ let (abbrev_obj_subroutine_type:abbrev) =\n      [|\n        (DW_AT_name, DW_FORM_string);\n        (DW_AT_type, DW_FORM_ref_addr); (* NB: output type. *)\n-       (DW_AT_mutable, DW_FORM_flag);\n-       (DW_AT_pure, DW_FORM_flag);\n        (DW_AT_rust_iterator, DW_FORM_flag);\n      |])\n ;;\n@@ -1523,26 +1517,10 @@ let dwarf_visitor\n           SUB ((M_POS fix), M_POS cu_info_section_fixup))\n   in\n \n-  let encode_effect eff =\n-    (* Note: weird encoding: mutable+pure = unsafe. *)\n-    let mut_byte, pure_byte =\n-      match eff with\n-          Ast.EFF_unsafe -> (1,1)\n-        | Ast.EFF_impure -> (0,0)\n-        | Ast.EFF_pure -> (0,1)\n-    in\n-      SEQ [|\n-        (* DW_AT_mutable: DW_FORM_flag *)\n-        BYTE mut_byte;\n-        (* DW_AT_pure: DW_FORM_flag *)\n-        BYTE pure_byte;\n-      |]\n-  in\n-\n-  let encode_layer eff =\n+  let encode_layer lyr =\n     (* Note: weird encoding: mutable+pure = gc. *)\n     let mut_byte, pure_byte =\n-      match eff with\n+      match lyr with\n           Ast.LAYER_value -> (0,1)\n         | Ast.LAYER_state -> (1,0)\n         | Ast.LAYER_gc -> (1,1)\n@@ -1855,7 +1833,6 @@ let dwarf_visitor\n                  uleb (get_abbrev_code abbrev_subroutine_type);\n                  (* DW_AT_type: DW_FORM_ref_addr *)\n                  (ref_slot_die tsig.Ast.sig_output_slot);\n-                 encode_effect taux.Ast.fn_effect;\n                  (* DW_AT_rust_iterator: DW_FORM_flag *)\n                  BYTE (if taux.Ast.fn_is_iter then 1 else 0)\n                |])\n@@ -1876,7 +1853,6 @@ let dwarf_visitor\n             ZSTRING ident;\n             (* DW_AT_type: DW_FORM_ref_addr *)\n             (ref_slot_die tsig.Ast.sig_output_slot);\n-            encode_effect taux.Ast.fn_effect;\n             (* DW_AT_rust_iterator: DW_FORM_flag *)\n             BYTE (if taux.Ast.fn_is_iter then 1 else 0)\n           |]\n@@ -2295,7 +2271,6 @@ let dwarf_visitor\n   let emit_subprogram_die\n       (id:Ast.ident)\n       (ret_slot:Ast.slot)\n-      (effect:Ast.effect)\n       (iter:bool)\n       (fix:fixup)\n       : unit =\n@@ -2315,7 +2290,6 @@ let dwarf_visitor\n          dw_form_block1 [| DW_OP_reg abi.Abi.abi_dwarf_fp_reg |];\n          (* DW_AT_return_addr *)\n          dw_form_block1 [| DW_OP_fbreg (Asm.IMM retpc); |];\n-         encode_effect effect;\n          (* DW_AT_rust_iterator: DW_FORM_flag *)\n          BYTE (if iter then 1 else 0)\n        |])\n@@ -2429,7 +2403,7 @@ let dwarf_visitor\n                   (Array.length item.node.Ast.decl_params);\n                 emit_subprogram_die\n                   id tsig.Ast.sig_output_slot\n-                  taux.Ast.fn_effect taux.Ast.fn_is_iter\n+                  taux.Ast.fn_is_iter\n                   (Hashtbl.find cx.ctxt_fn_fixups item.id);\n                 emit_type_param_decl_dies item.node.Ast.decl_params;\n             end\n@@ -2900,15 +2874,6 @@ let rec extract_mod_items\n       | _ -> bug () \"unexpected non-flag form for %s\" (dw_at_to_string attr)\n   in\n \n-  let get_effect die =\n-    match (get_flag die DW_AT_mutable, get_flag die DW_AT_pure) with\n-        (* Note: weird encoding: mutable+pure = unsafe. *)\n-        (true, true) -> Ast.EFF_unsafe\n-      | (false, false) -> Ast.EFF_impure\n-      | (false, true) -> Ast.EFF_pure\n-      | _ -> failwith \"bad effect encoding\"\n-  in\n-\n   let get_layer die =\n     match (get_flag die DW_AT_mutable, get_flag die DW_AT_pure) with\n         (* Note: weird encoding: mutable+pure = gc. *)\n@@ -3123,16 +3088,14 @@ let rec extract_mod_items\n             else None\n         end\n     in\n-    let effect = get_effect die in\n     let iter = get_flag die DW_AT_rust_iterator in\n     let tsig =\n       { Ast.sig_input_slots = ins;\n         Ast.sig_input_constrs = [| |];\n         Ast.sig_output_slot = out; }\n     in\n     let taux =\n-      { Ast.fn_is_iter = iter;\n-        Ast.fn_effect = effect }\n+      { Ast.fn_is_iter = iter; }\n     in\n       (tsig, taux)\n   in\n@@ -3223,11 +3186,9 @@ let rec extract_mod_items\n           (* FIXME (issue #74): finish this. *)\n           let ident = get_name die in\n           let oslot = get_referenced_slot die in\n-          let effect = get_effect die in\n           let iter = get_flag die DW_AT_rust_iterator in\n           let (params, islots) = get_formals die in\n-          let taux = { Ast.fn_effect = effect;\n-                       Ast.fn_is_iter = iter }\n+          let taux = { Ast.fn_is_iter = iter }\n           in\n           let tfn = { Ast.fn_input_slots = form_header_slots islots;\n                        Ast.fn_input_constrs = [| |];"}, {"sha": "b3e818649f12c5484356555098ec8f53adbd78eb", "filename": "src/boot/me/effect.ml", "status": "removed", "additions": 0, "deletions": 317, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57", "patch": "@@ -1,317 +0,0 @@\n-open Semant;;\n-open Common;;\n-\n-let log cx = Session.log \"effect\"\n-  (should_log cx cx.ctxt_sess.Session.sess_log_effect)\n-  cx.ctxt_sess.Session.sess_log_out\n-;;\n-\n-let iflog cx thunk =\n-  if (should_log cx cx.ctxt_sess.Session.sess_log_effect)\n-  then thunk ()\n-  else ()\n-;;\n-\n-let effect_calculating_visitor\n-    (item_effect:(node_id, Ast.effect) Hashtbl.t)\n-    (cx:ctxt)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n-  (* \n-   * This visitor calculates the effect of each function according to\n-   * its statements:\n-   * \n-   *    - Communication statements lower to 'impure'\n-   *    - Writing to anything other than a local slot lowers to 'impure'\n-   *    - Native calls lower to 'unsafe'\n-   *    - Calling a function with effect e lowers to e.\n-   *)\n-  let curr_fn = Stack.create () in\n-\n-  let visit_mod_item_pre n p i =\n-    begin\n-      match i.node.Ast.decl_item with\n-          Ast.MOD_ITEM_fn _ -> Stack.push i.id curr_fn\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_mod_item_pre n p i\n-  in\n-\n-  let visit_mod_item_post n p i =\n-    inner.Walk.visit_mod_item_post n p i;\n-    match i.node.Ast.decl_item with\n-        Ast.MOD_ITEM_fn _ -> ignore (Stack.pop curr_fn)\n-      | _ -> ()\n-  in\n-\n-  let visit_obj_fn_pre o i fi =\n-    Stack.push fi.id curr_fn;\n-    inner.Walk.visit_obj_fn_pre o i fi\n-  in\n-\n-  let visit_obj_fn_post o i fi =\n-    inner.Walk.visit_obj_fn_post o i fi;\n-    ignore (Stack.pop curr_fn)\n-  in\n-\n-  let visit_obj_drop_pre o b =\n-    Stack.push b.id curr_fn;\n-    inner.Walk.visit_obj_drop_pre o b\n-  in\n-\n-  let visit_obj_drop_post o b =\n-    inner.Walk.visit_obj_drop_post o b;\n-    ignore (Stack.pop curr_fn);\n-  in\n-\n-  let lower_to s ne =\n-    let fn_id = Stack.top curr_fn in\n-    let e =\n-      match htab_search item_effect fn_id with\n-          None -> Ast.EFF_pure\n-        | Some e -> e\n-    in\n-    let ne = lower_effect_of ne e in\n-      if ne <> e\n-      then\n-        begin\n-          iflog cx\n-            begin\n-              fun _ ->\n-                let name = Hashtbl.find cx.ctxt_all_item_names fn_id in\n-                  log cx \"lowering calculated effect on '%a': '%a' -> '%a'\"\n-                    Ast.sprintf_name name\n-                    Ast.sprintf_effect e\n-                    Ast.sprintf_effect ne;\n-                  log cx \"at stmt %a\" Ast.sprintf_stmt s\n-            end;\n-          Hashtbl.replace item_effect fn_id ne\n-        end;\n-  in\n-\n-  let note_write s dst =\n-    (* FIXME (issue #182): this is too aggressive; won't permit writes to\n-     * interior components of records or tuples. It should at least do that,\n-     * possibly handle escape analysis on the pointee for things like vecs as\n-     * well.  *)\n-    if lval_base_is_slot cx dst\n-    then\n-      let base_slot = lval_base_slot cx dst in\n-        match dst, base_slot.Ast.slot_mode with\n-            (Ast.LVAL_base _, Ast.MODE_local) -> ()\n-          | _ -> lower_to s Ast.EFF_impure\n-  in\n-\n-  let visit_stmt_pre s =\n-    begin\n-      match s.node with\n-          Ast.STMT_send _\n-        | Ast.STMT_recv _ -> lower_to s Ast.EFF_impure\n-\n-        | Ast.STMT_call (lv_dst, fn, _) ->\n-            note_write s lv_dst;\n-            let lower_to_callee_ty t =\n-              match simplified_ty t with\n-                  Ast.TY_fn (_, taux) ->\n-                    lower_to s taux.Ast.fn_effect;\n-                | _ -> bug () \"non-fn callee\"\n-            in\n-              if lval_base_is_slot cx fn\n-              then\n-                lower_to_callee_ty (lval_ty cx fn)\n-              else\n-                begin\n-                  let item = lval_item cx fn in\n-                  let t = Hashtbl.find cx.ctxt_all_item_types item.id in\n-                    lower_to_callee_ty t;\n-                    match htab_search cx.ctxt_required_items item.id with\n-                        None -> ()\n-                      | Some (REQUIRED_LIB_rust _, _) -> ()\n-                      | Some _ -> lower_to s Ast.EFF_unsafe\n-                end\n-\n-        | Ast.STMT_copy (lv_dst, _)\n-        | Ast.STMT_spawn (lv_dst, _, _, _, _)\n-        | Ast.STMT_bind (lv_dst, _, _)\n-        | Ast.STMT_new_rec (lv_dst, _, _)\n-        | Ast.STMT_new_tup (lv_dst, _)\n-        | Ast.STMT_new_vec (lv_dst, _, _)\n-        | Ast.STMT_new_str (lv_dst, _)\n-        | Ast.STMT_new_port lv_dst\n-        | Ast.STMT_new_chan (lv_dst, _)\n-        | Ast.STMT_new_box (lv_dst, _, _) ->\n-            note_write s lv_dst\n-\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_stmt_pre s\n-  in\n-\n-    { inner with\n-        Walk.visit_mod_item_pre = visit_mod_item_pre;\n-        Walk.visit_mod_item_post = visit_mod_item_post;\n-        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n-        Walk.visit_obj_fn_post = visit_obj_fn_post;\n-        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n-        Walk.visit_obj_drop_post = visit_obj_drop_post;\n-        Walk.visit_stmt_pre = visit_stmt_pre }\n-;;\n-\n-\n-let effect_checking_visitor\n-    (item_auth:(node_id, Ast.effect) Hashtbl.t)\n-    (item_effect:(node_id, Ast.effect) Hashtbl.t)\n-    (cx:ctxt)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n-  (*\n-   * This visitor checks that each fn declares\n-   * effects consistent with what we calculated.\n-   *)\n-  let auth_stack = Stack.create () in\n-  let visit_mod_item_pre n p i =\n-    begin\n-      match htab_search item_auth i.id with\n-          None -> ()\n-        | Some e ->\n-            let curr =\n-              if Stack.is_empty auth_stack\n-              then Ast.EFF_pure\n-              else Stack.top auth_stack\n-            in\n-              Stack.push e auth_stack;\n-              iflog cx\n-                begin\n-                  fun _ ->\n-                    let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n-                      log cx\n-                        \"entering '%a', adjusting auth effect: '%a' -> '%a'\"\n-                        Ast.sprintf_name name\n-                        Ast.sprintf_effect curr\n-                        Ast.sprintf_effect e\n-                end\n-    end;\n-    let report_mismatch declared_effect calculated_effect =\n-      let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n-        err (Some i.id)\n-          \"%a claims effect '%a' but calculated effect is '%a'%s\"\n-          Ast.sprintf_name name\n-          Ast.sprintf_effect declared_effect\n-          Ast.sprintf_effect calculated_effect\n-          begin\n-            if Stack.is_empty auth_stack\n-            then \"\"\n-            else\n-              Printf.sprintf \" (auth effects are '%s')\"\n-                (stk_fold\n-                   auth_stack\n-                   (fun e s ->\n-                      if s = \"\"\n-                      then\n-                        Printf.sprintf \"%a\"\n-                          Ast.sprintf_effect e\n-                      else\n-                        Printf.sprintf \"%s, %a\" s\n-                          Ast.sprintf_effect e) \"\")\n-          end\n-    in\n-    begin\n-      match i.node.Ast.decl_item with\n-          Ast.MOD_ITEM_fn f\n-            when htab_search cx.ctxt_required_items i.id = None ->\n-            let calculated_effect =\n-              match htab_search item_effect i.id with\n-                None -> Ast.EFF_pure\n-              | Some e -> e\n-            in\n-            let declared_effect = f.Ast.fn_aux.Ast.fn_effect in\n-              if calculated_effect <> declared_effect\n-              then\n-                (* Something's fishy in this case. If the calculated effect\n-                 * is equal to one auth'ed by an enclosing scope -- not just\n-                 * a lower one -- we accept this mismatch; otherwise we\n-                 * complain.\n-                 * \n-                 * FIXME: this choice of \"what constitutes an error\" in\n-                 * auth/effect mismatches is subjective and could do\n-                 * with some discussion.  *)\n-                begin\n-                  match\n-                    stk_search auth_stack\n-                      (fun e ->\n-                         if e = calculated_effect then Some e else None)\n-                  with\n-                      Some _ -> ()\n-                    | None ->\n-                        report_mismatch declared_effect calculated_effect\n-                end\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_mod_item_pre n p i\n-  in\n-  let visit_mod_item_post n p i =\n-    inner.Walk.visit_mod_item_post n p i;\n-    match htab_search item_auth i.id with\n-        None -> ()\n-      | Some _ ->\n-          let curr = Stack.pop auth_stack in\n-          let next =\n-            if Stack.is_empty auth_stack\n-            then Ast.EFF_pure\n-            else Stack.top auth_stack\n-          in\n-            iflog cx\n-              begin\n-                fun _ ->\n-                  let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n-                    log cx\n-                      \"leaving '%a', restoring auth effect: '%a' -> '%a'\"\n-                      Ast.sprintf_name name\n-                      Ast.sprintf_effect curr\n-                      Ast.sprintf_effect next\n-              end\n-  in\n-    { inner with\n-        Walk.visit_mod_item_pre = visit_mod_item_pre;\n-        Walk.visit_mod_item_post = visit_mod_item_post; }\n-;;\n-\n-\n-let process_crate\n-    (_cx:ctxt)\n-    (_crate:Ast.crate)\n-    : unit = (*\n-  let item_auth = Hashtbl.create 0 in\n-  let item_effect = Hashtbl.create 0 in\n-  let passes =\n-    [|\n-      (effect_calculating_visitor item_effect cx\n-         Walk.empty_visitor);\n-      (effect_checking_visitor item_auth item_effect cx\n-         Walk.empty_visitor);\n-    |]\n-  in\n-  let root_scope = [ SCOPE_crate crate ] in\n-  let auth_effect name eff =\n-    match lookup_by_name cx [] root_scope name with\n-        RES_failed _ -> ()\n-      | RES_ok (_, id) ->\n-          if defn_id_is_item cx id\n-          then htab_put item_auth id eff\n-          else err (Some id) \"auth clause in crate refers to non-item\"\n-  in\n-    Hashtbl.iter auth_effect crate.node.Ast.crate_auth;\n-    run_passes cx \"effect\" passes\n-      cx.ctxt_sess.Session.sess_log_effect log crate\n-  *)\n-  ()\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "a877f2d051c7c888600b617c5e88796e2c509026", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1010,13 +1010,11 @@ let rec pretty_ty_str (cx:ctxt) (fallback:(Ast.ty -> string)) (ty:Ast.ty) =\n                 None -> Common.bug () \"no ty in slot\"\n               | Some ty' -> prefix ^ (pretty_ty_str cx fallback ty')\n           in\n-          let effect = aux.Ast.fn_effect in\n-          let qual = Fmt.sprintf_fmt Ast.fmt_effect_qual () effect in\n           let keyword = if aux.Ast.fn_is_iter then \"iter\" else \"fn\" in\n           let fn_args = Array.map format_slot fnsig.Ast.sig_input_slots in\n           let fn_args_str = String.concat \", \" (Array.to_list fn_args) in\n           let fn_rv_str = format_slot fnsig.Ast.sig_output_slot in\n-          Printf.sprintf \"%s%s(%s) -> %s\" qual keyword fn_args_str fn_rv_str\n+          Printf.sprintf \"%s(%s) -> %s\" keyword fn_args_str fn_rv_str\n       | Ast.TY_tag { Ast.tag_id = tag_id; Ast.tag_args = _ }\n               when Hashtbl.mem cx.ctxt_user_tag_names tag_id ->\n           let name = Hashtbl.find cx.ctxt_user_tag_names tag_id in\n@@ -1156,8 +1154,7 @@ let generic_fn_ty =\n                Ast.sig_output_slot =\n                  { Ast.slot_mode = Ast.MODE_local;\n                    Ast.slot_ty = Some Ast.TY_nil }; },\n-             { Ast.fn_is_iter = false;\n-               Ast.fn_effect = Ast.EFF_pure })\n+             { Ast.fn_is_iter = false })\n ;;\n \n let rec get_genericized_ty ty =\n@@ -1271,19 +1268,6 @@ let type_points_to_heap (cx:ctxt) (t:Ast.ty) : bool =\n \n (* Type qualifier analysis. *)\n \n-let effect_le x y =\n-  match (x,y) with\n-      (Ast.EFF_unsafe, _) -> true\n-    | (Ast.EFF_impure, Ast.EFF_pure) -> true\n-    | (Ast.EFF_impure, Ast.EFF_impure) -> true\n-    | (Ast.EFF_pure, Ast.EFF_pure) -> true\n-    | _ -> false\n-;;\n-\n-let lower_effect_of x y =\n-  if effect_le x y then x else y\n-;;\n-\n let layer_le x y =\n   match (x,y) with\n       (Ast.LAYER_gc, _) -> true\n@@ -1682,8 +1666,7 @@ let ty_of_mod_item (item:Ast.mod_item) : Ast.ty =\n     | Ast.MOD_ITEM_mod _ -> bug () \"Semant.ty_of_mod_item on mod\"\n     | Ast.MOD_ITEM_const (ty, _) -> ty\n     | Ast.MOD_ITEM_obj ob ->\n-        let taux = { Ast.fn_effect = Ast.EFF_pure;\n-                     Ast.fn_is_iter = false }\n+        let taux = { Ast.fn_is_iter = false }\n         in\n         let tobj = Ast.TY_obj (ty_obj_of_obj ob) in\n         let tsig = { Ast.sig_input_slots = arg_slots ob.Ast.obj_state;\n@@ -1705,8 +1688,7 @@ let ty_of_mod_item (item:Ast.mod_item) : Ast.ty =\n           if Array.length hdr = 0\n           then Ast.TY_tag ttag\n           else\n-            let taux = { Ast.fn_effect = Ast.EFF_pure;\n-                         Ast.fn_is_iter = false }\n+            let taux = { Ast.fn_is_iter = false }\n             in\n             let inputs = Array.map (fun (s, _) -> s.node) hdr in\n             let tsig = { Ast.sig_input_slots = inputs;\n@@ -2642,8 +2624,7 @@ let mk_ty_fn_or_iter\n     (is_iter:bool)\n     : Ast.ty =\n   (* In some cases we don't care what aux or constrs are. *)\n-  let taux = { Ast.fn_effect = Ast.EFF_pure;\n-               Ast.fn_is_iter = is_iter; }\n+  let taux = { Ast.fn_is_iter = is_iter; }\n   in\n   let tsig = { Ast.sig_input_slots = arg_slots;\n                Ast.sig_input_constrs = [| |];\n@@ -2816,6 +2797,6 @@ let glue_str (cx:ctxt) (g:glue) : string =\n  * fill-column: 78;\n  * indent-tabs-mode: nil\n  * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * compile-command: \"make -C  $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n  * End:\n  *)"}, {"sha": "fe6e8dcad6d171ec81973a038c0262beacbe5951", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -122,12 +122,7 @@ let determine_constr_key\n           then\n             begin\n               match Hashtbl.find cx.ctxt_all_item_types cid with\n-                  Ast.TY_fn (_, taux) ->\n-                    begin\n-                      if taux.Ast.fn_effect = Ast.EFF_pure\n-                      then cid\n-                      else err (Some cid) \"impure function used in constraint\"\n-                    end\n+                  Ast.TY_fn _ -> cid\n                 | _ -> bug () \"bad type of predicate\"\n             end\n           else"}, {"sha": "5acbea86cf973c860b0182ad9c024bc260528ee9", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -44,7 +44,7 @@ fn default_environment(session.session sess,\n             );\n }\n \n-impure fn parse_input(session.session sess,\n+fn parse_input(session.session sess,\n                       parser.parser p,\n                       str input) -> @front.ast.crate {\n     if (_str.ends_with(input, \".rc\")) {\n@@ -56,7 +56,7 @@ impure fn parse_input(session.session sess,\n     fail;\n }\n \n-impure fn compile_input(session.session sess,\n+fn compile_input(session.session sess,\n                         eval.env env,\n                         str input, str output,\n                         bool shared,\n@@ -79,7 +79,7 @@ impure fn compile_input(session.session sess,\n                       ot);\n }\n \n-impure fn pretty_print_input(session.session sess,\n+fn pretty_print_input(session.session sess,\n                              eval.env env,\n                              str input) {\n     auto def = tup(0, 0);\n@@ -116,7 +116,7 @@ fn get_os() -> session.os {\n     if (_str.eq(s, \"linux\")) { ret session.os_linux; }\n }\n \n-impure fn main(vec[str] args) {\n+fn main(vec[str] args) {\n \n     // FIXME: don't hard-wire this.\n     auto target_cfg = rec(os = get_os(),"}, {"sha": "7ec5e20a4e8096222042b3f17b524068f2b12e93", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -83,7 +83,7 @@ tag crate_directive_ {\n     cdir_view_item(@view_item);\n     cdir_meta(vec[@meta_item]);\n     cdir_syntax(path);\n-    cdir_auth(path, effect);\n+    cdir_auth(path, _auth);\n }\n type crate_directive = spanned[crate_directive_];\n \n@@ -130,10 +130,8 @@ tag layer {\n     layer_gc;\n }\n \n-tag effect {\n-    eff_pure;\n-    eff_impure;\n-    eff_unsafe;\n+tag _auth {\n+    auth_unsafe;\n }\n \n tag proto {\n@@ -314,7 +312,7 @@ tag lit_ {\n type mt = rec(@ty ty, mutability mut);\n type ty_field = rec(ident ident, mt mt);\n type ty_arg = rec(mode mode, @ty ty);\n-type ty_method = rec(effect effect, proto proto, ident ident,\n+type ty_method = rec(proto proto, ident ident,\n                      vec[ty_arg] inputs, @ty output);\n type ty = spanned[ty_];\n tag ty_ {\n@@ -332,7 +330,7 @@ tag ty_ {\n     ty_chan(@ty);\n     ty_tup(vec[mt]);\n     ty_rec(vec[ty_field]);\n-    ty_fn(effect, proto, vec[ty_arg], @ty);\n+    ty_fn(proto, vec[ty_arg], @ty);\n     ty_obj(vec[ty_method]);\n     ty_path(path, option.t[def]);\n     ty_type;\n@@ -348,8 +346,7 @@ type constr_ = rec(path path, vec[@constr_arg] args);\n type constr = spanned[constr_];\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n-type fn_decl = rec(effect effect,\n-                   vec[arg] inputs,\n+type fn_decl = rec(vec[arg] inputs,\n                    @ty output);\n type _fn = rec(fn_decl decl,\n                proto proto,"}, {"sha": "1c910b65c89d3cf53f5436c718b39e1c5176b89e", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -55,7 +55,7 @@ fn peek(@pstate st) -> u8 {\n     if (st.pos < st.len) {ret st.rep.(st.pos) as u8;}\n     else {ret ' ' as u8;}\n }\n-impure fn next(@pstate st) -> u8 { // ?? somehow not recognized as impure\n+fn next(@pstate st) -> u8 { // ?? somehow not recognized as impure\n     if (st.pos >= st.len) {fail;}\n     auto ch = st.rep.(st.pos);\n     st.pos = st.pos + 1u;\n@@ -74,12 +74,12 @@ fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n     ret result;\n }\n \n-impure fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n+fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n     ret @rec(struct=parse_sty(st, sd),\n              cname=option.none[str]);\n }\n \n-impure fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n+fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n     auto mut;\n     alt (peek(st) as char) {\n         case ('m') {next(st); mut = ast.mut;}\n@@ -89,7 +89,7 @@ impure fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n     ret rec(ty=parse_ty(st, sd), mut=mut);\n }\n \n-impure fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n+fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n     auto def = \"\";\n     while (peek(st) as char != '|') {\n         def += _str.unsafe_from_byte(next(st));\n@@ -98,7 +98,7 @@ impure fn parse_def(@pstate st, str_def sd) -> ast.def_id {\n     ret sd(def);\n }\n \n-impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n+fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n     alt (next(st) as char) {\n         case ('n') {ret ty.ty_nil;}\n         case ('b') {ret ty.ty_bool;}\n@@ -205,7 +205,7 @@ impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n     }\n }\n \n-impure fn parse_int(@pstate st) -> int {\n+fn parse_int(@pstate st) -> int {\n     auto n = 0;\n     while (true) {\n         auto cur = peek(st) as char;\n@@ -217,7 +217,7 @@ impure fn parse_int(@pstate st) -> int {\n     ret n;\n }\n \n-impure fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n+fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n     check(next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n     while (peek(st) as char != ']') {\n@@ -565,7 +565,7 @@ fn get_tag_variants(session.session sess, ast.def_id def)\n     ret infos;\n }\n \n-impure fn list_file_metadata(str path, io.writer out) {\n+fn list_file_metadata(str path, io.writer out) {\n     alt (get_metadata_section(path)) {\n         case (option.some[vec[u8]](?bytes)) {\n             list_crate_metadata(bytes, out);\n@@ -584,7 +584,7 @@ fn read_path(&ebml.doc d) -> tup(str, uint) {\n     ret tup(path, pos);\n }\n \n-impure fn list_crate_metadata(vec[u8] bytes, io.writer out) {\n+fn list_crate_metadata(vec[u8] bytes, io.writer out) {\n     auto md = ebml.new_doc(bytes);\n     auto paths = ebml.get_doc(md, metadata.tag_paths);\n     auto items = ebml.get_doc(md, metadata.tag_items);"}, {"sha": "06fa9cea0f5cf7bc8645c917a516efd3bb95b793", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -224,7 +224,7 @@ fn val_eq(session.session sess, span sp, val av, val bv) -> bool {\n     fail;\n }\n \n-impure fn eval_crate_directives(ctx cx,\n+fn eval_crate_directives(ctx cx,\n                                 env e,\n                                 vec[@ast.crate_directive] cdirs,\n                                 str prefix,\n@@ -240,7 +240,7 @@ impure fn eval_crate_directives(ctx cx,\n }\n \n \n-impure fn eval_crate_directives_to_mod(ctx cx, env e,\n+fn eval_crate_directives_to_mod(ctx cx, env e,\n                                        vec[@ast.crate_directive] cdirs,\n                                        str prefix) -> ast._mod {\n     let vec[@ast.view_item] view_items = vec();\n@@ -254,7 +254,7 @@ impure fn eval_crate_directives_to_mod(ctx cx, env e,\n }\n \n \n-impure fn eval_crate_directive_block(ctx cx,\n+fn eval_crate_directive_block(ctx cx,\n                                      env e,\n                                      &ast.block blk,\n                                      str prefix,\n@@ -277,7 +277,7 @@ impure fn eval_crate_directive_block(ctx cx,\n     }\n }\n \n-impure fn eval_crate_directive_expr(ctx cx,\n+fn eval_crate_directive_expr(ctx cx,\n                                     env e,\n                                     @ast.expr x,\n                                     str prefix,\n@@ -349,7 +349,7 @@ impure fn eval_crate_directive_expr(ctx cx,\n     }\n }\n \n-impure fn eval_crate_directive(ctx cx,\n+fn eval_crate_directive(ctx cx,\n                                env e,\n                                @ast.crate_directive cdir,\n                                str prefix,"}, {"sha": "3a9eb1ed99d9bfbfcc687e57e97baa1f8f726a11", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -14,8 +14,8 @@ state type reader = state obj {\n     fn is_eof() -> bool;\n     fn curr() -> char;\n     fn next() -> char;\n-    impure fn init();\n-    impure fn bump();\n+    fn init();\n+    fn bump();\n     fn mark();\n     fn get_mark_chpos() -> uint;\n     fn get_chpos() -> uint;\n@@ -24,7 +24,7 @@ state type reader = state obj {\n     fn get_filemap() -> codemap.filemap;\n };\n \n-impure fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n+fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n     -> reader {\n     state obj reader(str file,\n                      uint len,\n@@ -53,15 +53,15 @@ impure fn new_reader(io.reader rdr, str filename, codemap.filemap filemap)\n             else {ret -1 as char;}\n         }\n \n-        impure fn init() {\n+        fn init() {\n             if (pos < len) {\n                 auto next = _str.char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             }\n         }\n \n-        impure fn bump() {\n+        fn bump() {\n             if (pos < len) {\n                 chpos += 1u;\n                 if (ch == '\\n') {\n@@ -135,7 +135,6 @@ fn keyword_table() -> std.map.hashmap[str, token.token] {\n     keywords.insert(\"state\", token.STATE);\n     keywords.insert(\"gc\", token.GC);\n \n-    keywords.insert(\"impure\", token.IMPURE);\n     keywords.insert(\"unsafe\", token.UNSAFE);\n \n     keywords.insert(\"native\", token.NATIVE);\n@@ -274,14 +273,14 @@ fn is_whitespace(char c) -> bool {\n     ret c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-impure fn consume_any_whitespace(reader rdr) {\n+fn consume_any_whitespace(reader rdr) {\n     while (is_whitespace(rdr.curr())) {\n         rdr.bump();\n     }\n     be consume_any_line_comment(rdr);\n }\n \n-impure fn consume_any_line_comment(reader rdr) {\n+fn consume_any_line_comment(reader rdr) {\n     if (rdr.curr() == '/') {\n         alt (rdr.next()) {\n             case ('/') {\n@@ -304,7 +303,7 @@ impure fn consume_any_line_comment(reader rdr) {\n }\n \n \n-impure fn consume_block_comment(reader rdr) {\n+fn consume_block_comment(reader rdr) {\n     let int level = 1;\n     while (level > 0) {\n         if (rdr.curr() == '/' && rdr.next() == '*') {\n@@ -342,7 +341,7 @@ fn digits_to_string(str s) -> int {\n     ret accum_int;\n }\n \n-impure fn scan_exponent(reader rdr) -> option.t[str] {\n+fn scan_exponent(reader rdr) -> option.t[str] {\n     auto c = rdr.curr();\n     auto res = \"\";\n \n@@ -368,7 +367,7 @@ impure fn scan_exponent(reader rdr) -> option.t[str] {\n     }\n }\n \n-impure fn scan_dec_digits(reader rdr) -> str {\n+fn scan_dec_digits(reader rdr) -> str {\n \n     auto c = rdr.curr();\n     let str res = \"\";\n@@ -384,7 +383,7 @@ impure fn scan_dec_digits(reader rdr) -> str {\n     ret res;\n }\n \n-impure fn scan_number(mutable char c, reader rdr) -> token.token {\n+fn scan_number(mutable char c, reader rdr) -> token.token {\n     auto accum_int = 0;\n     let str dec_str = \"\";\n     let bool is_dec_integer = false;\n@@ -527,7 +526,7 @@ impure fn scan_number(mutable char c, reader rdr) -> token.token {\n     }\n }\n \n-impure fn scan_numeric_escape(reader rdr) -> char {\n+fn scan_numeric_escape(reader rdr) -> char {\n \n     auto n_hex_digits = 0;\n \n@@ -563,7 +562,7 @@ impure fn scan_numeric_escape(reader rdr) -> char {\n }\n \n \n-impure fn next_token(reader rdr) -> token.token {\n+fn next_token(reader rdr) -> token.token {\n     auto accum_str = \"\";\n \n     consume_any_whitespace(rdr);\n@@ -602,7 +601,7 @@ impure fn next_token(reader rdr) -> token.token {\n         ret scan_number(c, rdr);\n     }\n \n-    impure fn binop(reader rdr, token.binop op) -> token.token {\n+    fn binop(reader rdr, token.binop op) -> token.token {\n         rdr.bump();\n         if (rdr.curr() == '=') {\n             rdr.bump();\n@@ -856,7 +855,7 @@ tag cmnt_ {\n \n type cmnt = rec(cmnt_ val, uint pos, bool space_after);\n \n-impure fn consume_whitespace(reader rdr) -> uint {\n+fn consume_whitespace(reader rdr) -> uint {\n     auto lines = 0u;\n     while (is_whitespace(rdr.curr())) {\n         if (rdr.curr() == '\\n') {lines += 1u;}\n@@ -865,7 +864,7 @@ impure fn consume_whitespace(reader rdr) -> uint {\n     ret lines;\n }\n \n-impure fn read_line_comment(reader rdr) -> cmnt {\n+fn read_line_comment(reader rdr) -> cmnt {\n     auto p = rdr.get_chpos();\n     rdr.bump(); rdr.bump();\n     while (rdr.curr() == ' ') {rdr.bump();}\n@@ -879,7 +878,7 @@ impure fn read_line_comment(reader rdr) -> cmnt {\n             space_after=consume_whitespace(rdr) > 1u);\n }\n \n-impure fn read_block_comment(reader rdr) -> cmnt {\n+fn read_block_comment(reader rdr) -> cmnt {\n     auto p = rdr.get_chpos();\n     rdr.bump(); rdr.bump();\n     while (rdr.curr() == ' ') {rdr.bump();}\n@@ -912,7 +911,7 @@ impure fn read_block_comment(reader rdr) -> cmnt {\n             space_after=consume_whitespace(rdr) > 1u);\n }\n \n-impure fn gather_comments(str path) -> vec[cmnt] {\n+fn gather_comments(str path) -> vec[cmnt] {\n     auto srdr = io.file_reader(path);\n     auto rdr = new_reader(srdr, path, codemap.new_filemap(path, 0u));\n     let vec[cmnt] comments = vec();"}, {"sha": "3ed74abc582cc36428338cc56d5cfc5262d697b7", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 128, "deletions": 147, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -26,9 +26,9 @@ tag file_type {\n state type parser =\n     state obj {\n           fn peek() -> token.token;\n-          impure fn bump();\n-          impure fn err(str s);\n-          impure fn restrict(restriction r);\n+          fn bump();\n+          fn err(str s);\n+          fn restrict(restriction r);\n           fn get_restriction() -> restriction;\n           fn get_file_type() -> file_type;\n           fn get_env() -> eval.env;\n@@ -43,7 +43,7 @@ state type parser =\n           fn get_chpos() -> uint;\n     };\n \n-impure fn new_parser(session.session sess,\n+fn new_parser(session.session sess,\n                      eval.env env,\n                      ast.def_id initial_def,\n                      str path, uint pos) -> parser {\n@@ -63,19 +63,19 @@ impure fn new_parser(session.session sess,\n                 ret tok;\n             }\n \n-            impure fn bump() {\n+            fn bump() {\n                 // log rdr.get_filename()\n                 //   + \":\" + common.istr(lo.line as int);\n                 tok = lexer.next_token(rdr);\n                 lo = rdr.get_mark_chpos();\n                 hi = rdr.get_chpos();\n             }\n \n-            impure fn err(str m) {\n+            fn err(str m) {\n                 sess.span_err(rec(lo=lo, hi=hi), m);\n             }\n \n-            impure fn restrict(restriction r) {\n+            fn restrict(restriction r) {\n                 res = r;\n             }\n \n@@ -134,13 +134,13 @@ impure fn new_parser(session.session sess,\n                      rdr, prec_table());\n }\n \n-impure fn unexpected(parser p, token.token t) {\n+fn unexpected(parser p, token.token t) {\n     let str s = \"unexpected token: \";\n     s += token.to_str(t);\n     p.err(s);\n }\n \n-impure fn expect(parser p, token.token t) {\n+fn expect(parser p, token.token t) {\n     if (p.peek() == t) {\n         p.bump();\n     } else {\n@@ -156,7 +156,7 @@ fn spanned[T](uint lo, uint hi, &T node) -> ast.spanned[T] {\n     ret rec(node=node, span=rec(lo=lo, hi=hi));\n }\n \n-impure fn parse_ident(parser p) -> ast.ident {\n+fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n         case (token.IDENT(?i)) { p.bump(); ret i; }\n         case (_) {\n@@ -172,7 +172,7 @@ impure fn parse_ident(parser p) -> ast.ident {\n  * lexical sytnax-extension or something similar. For now we just imitate\n  * rustboot.\n  */\n-impure fn parse_str_lit_or_env_ident(parser p) -> ast.ident {\n+fn parse_str_lit_or_env_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n         case (token.LIT_STR(?s)) { p.bump(); ret s; }\n         case (token.IDENT(?i)) {\n@@ -192,9 +192,9 @@ impure fn parse_str_lit_or_env_ident(parser p) -> ast.ident {\n }\n \n \n-impure fn parse_ty_fn(ast.effect eff, ast.proto proto, parser p, uint lo)\n+fn parse_ty_fn(ast.proto proto, parser p, uint lo)\n     -> ast.ty_ {\n-    impure fn parse_fn_input_ty(parser p) -> rec(ast.mode mode, @ast.ty ty) {\n+    fn parse_fn_input_ty(parser p) -> rec(ast.mode mode, @ast.ty ty) {\n         auto mode;\n         if (p.peek() == token.BINOP(token.AND)) {\n             p.bump();\n@@ -236,10 +236,10 @@ impure fn parse_ty_fn(ast.effect eff, ast.proto proto, parser p, uint lo)\n         output = @spanned(lo, inputs.span.hi, ast.ty_nil);\n     }\n \n-    ret ast.ty_fn(eff, proto, inputs.node, output);\n+    ret ast.ty_fn(proto, inputs.node, output);\n }\n \n-impure fn parse_proto(parser p) -> ast.proto {\n+fn parse_proto(parser p) -> ast.proto {\n     alt (p.peek()) {\n         case (token.ITER) { p.bump(); ret ast.proto_iter; }\n         case (token.FN) { p.bump(); ret ast.proto_fn; }\n@@ -248,19 +248,18 @@ impure fn parse_proto(parser p) -> ast.proto {\n     fail;\n }\n \n-impure fn parse_ty_obj(parser p, &mutable uint hi) -> ast.ty_ {\n+fn parse_ty_obj(parser p, &mutable uint hi) -> ast.ty_ {\n     expect(p, token.OBJ);\n-    impure fn parse_method_sig(parser p) -> ast.ty_method {\n+    fn parse_method_sig(parser p) -> ast.ty_method {\n         auto flo = p.get_lo_pos();\n \n-        let ast.effect eff = parse_effect(p);\n         let ast.proto proto = parse_proto(p);\n         auto ident = parse_ident(p);\n-        auto f = parse_ty_fn(eff, proto, p, flo);\n+        auto f = parse_ty_fn(proto, p, flo);\n         expect(p, token.SEMI);\n         alt (f) {\n-            case (ast.ty_fn(?eff, ?proto, ?inputs, ?output)) {\n-                ret rec(effect=eff, proto=proto, ident=ident,\n+            case (ast.ty_fn(?proto, ?inputs, ?output)) {\n+                ret rec(proto=proto, ident=ident,\n                         inputs=inputs, output=output);\n             }\n         }\n@@ -276,19 +275,19 @@ impure fn parse_ty_obj(parser p, &mutable uint hi) -> ast.ty_ {\n     ret ast.ty_obj(meths.node);\n }\n \n-impure fn parse_mt(parser p) -> ast.mt {\n+fn parse_mt(parser p) -> ast.mt {\n     auto mut = parse_mutability(p);\n     auto t = parse_ty(p);\n     ret rec(ty=t, mut=mut);\n }\n \n-impure fn parse_ty_field(parser p) -> ast.ty_field {\n+fn parse_ty_field(parser p) -> ast.ty_field {\n     auto mt = parse_mt(p);\n     auto id = parse_ident(p);\n     ret rec(ident=id, mt=mt);\n }\n \n-impure fn parse_constr_arg(parser p) -> @ast.constr_arg {\n+fn parse_constr_arg(parser p) -> @ast.constr_arg {\n     auto sp = p.get_span();\n     auto carg = ast.carg_base;\n     if (p.peek() == token.BINOP(token.STAR)) {\n@@ -299,7 +298,7 @@ impure fn parse_constr_arg(parser p) -> @ast.constr_arg {\n     ret @rec(node=carg, span=sp);\n }\n \n-impure fn parse_ty_constr(parser p) -> @ast.constr {\n+fn parse_ty_constr(parser p) -> @ast.constr {\n     auto lo = p.get_lo_pos();\n     auto path = parse_path(p, GREEDY);\n     auto pf = parse_constr_arg;\n@@ -309,7 +308,7 @@ impure fn parse_ty_constr(parser p) -> @ast.constr {\n     ret @spanned(lo, args.span.hi, rec(path=path, args=args.node));\n }\n \n-impure fn parse_constrs(parser p) -> common.spanned[vec[@ast.constr]] {\n+fn parse_constrs(parser p) -> common.spanned[vec[@ast.constr]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     let vec[@ast.constr] constrs = vec();\n@@ -334,7 +333,7 @@ impure fn parse_constrs(parser p) -> common.spanned[vec[@ast.constr]] {\n    ret spanned(lo, hi, constrs);\n }\n \n-impure fn parse_ty_constrs(@ast.ty t, parser p) -> @ast.ty {\n+fn parse_ty_constrs(@ast.ty t, parser p) -> @ast.ty {\n    if (p.peek() == token.COLON) {\n        auto constrs = parse_constrs(p);\n        ret @spanned(t.span.lo, constrs.span.hi,\n@@ -343,13 +342,11 @@ impure fn parse_ty_constrs(@ast.ty t, parser p) -> @ast.ty {\n    ret t;\n }\n \n-impure fn parse_ty(parser p) -> @ast.ty {\n+fn parse_ty(parser p) -> @ast.ty {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n     let ast.ty_ t;\n \n-    // FIXME: make sure these are only used when valid\n-    let ast.effect eff = parse_effect(p);\n     // FIXME: do something with this\n     let ast.layer lyr = parse_layer(p);\n \n@@ -418,9 +415,9 @@ impure fn parse_ty(parser p) -> @ast.ty {\n         case (token.FN) {\n             auto flo = p.get_lo_pos();\n             p.bump();\n-            t = parse_ty_fn(eff, ast.proto_fn, p, flo);\n+            t = parse_ty_fn(ast.proto_fn, p, flo);\n             alt (t) {\n-                case (ast.ty_fn(_, _, _, ?out)) {\n+                case (ast.ty_fn(_, _, ?out)) {\n                     hi = out.span.hi;\n                 }\n             }\n@@ -429,9 +426,9 @@ impure fn parse_ty(parser p) -> @ast.ty {\n         case (token.ITER) {\n             auto flo = p.get_lo_pos();\n             p.bump();\n-            t = parse_ty_fn(eff, ast.proto_iter, p, flo);\n+            t = parse_ty_fn(ast.proto_iter, p, flo);\n             alt (t) {\n-                case (ast.ty_fn(_, _, _, ?out)) {\n+                case (ast.ty_fn(_, _, ?out)) {\n                     hi = out.span.hi;\n                 }\n             }\n@@ -482,7 +479,7 @@ impure fn parse_ty(parser p) -> @ast.ty {\n     ret parse_ty_constrs(@spanned(lo, hi, t), p);\n }\n \n-impure fn parse_arg(parser p) -> ast.arg {\n+fn parse_arg(parser p) -> ast.arg {\n     let ast.mode m = ast.val;\n     if (p.peek() == token.BINOP(token.AND)) {\n         m = ast.alias;\n@@ -498,9 +495,9 @@ impure fn parse_arg(parser p) -> ast.arg {\n     ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n-impure fn parse_seq_to_end[T](token.token ket,\n+fn parse_seq_to_end[T](token.token ket,\n                               option.t[token.token] sep,\n-                              (impure fn(parser) -> T) f,\n+                              (fn(parser) -> T) f,\n                               mutable uint hi,\n                               parser p) -> vec[T] {\n     let bool first = true;\n@@ -526,10 +523,10 @@ impure fn parse_seq_to_end[T](token.token ket,\n     ret v;\n }\n \n-impure fn parse_seq[T](token.token bra,\n+fn parse_seq[T](token.token bra,\n                        token.token ket,\n                        option.t[token.token] sep,\n-                       (impure fn(parser) -> T) f,\n+                       (fn(parser) -> T) f,\n                        parser p) -> util.common.spanned[vec[T]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n@@ -538,7 +535,7 @@ impure fn parse_seq[T](token.token bra,\n     ret spanned(lo, hi, result);\n }\n \n-impure fn parse_lit(parser p) -> ast.lit {\n+fn parse_lit(parser p) -> ast.lit {\n     auto sp = p.get_span();\n     let ast.lit_ lit = ast.lit_nil;\n     alt (p.peek()) {\n@@ -594,7 +591,7 @@ tag greed {\n     MINIMAL;\n }\n \n-impure fn parse_ty_args(parser p, uint hi) ->\n+fn parse_ty_args(parser p, uint hi) ->\n     util.common.spanned[vec[@ast.ty]] {\n \n     if (p.peek() == token.LBRACKET) {\n@@ -609,7 +606,7 @@ impure fn parse_ty_args(parser p, uint hi) ->\n     ret spanned(hi, hi, v);\n }\n \n-impure fn parse_path(parser p, greed g) -> ast.path {\n+fn parse_path(parser p, greed g) -> ast.path {\n \n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n@@ -643,7 +640,7 @@ impure fn parse_path(parser p, greed g) -> ast.path {\n     ret spanned(lo, tys.span.hi, rec(idents=ids, types=tys.node));\n }\n \n-impure fn parse_mutability(parser p) -> ast.mutability {\n+fn parse_mutability(parser p) -> ast.mutability {\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n         if (p.peek() == token.QUES) {\n@@ -655,15 +652,15 @@ impure fn parse_mutability(parser p) -> ast.mutability {\n     ret ast.imm;\n }\n \n-impure fn parse_field(parser p) -> ast.field {\n+fn parse_field(parser p) -> ast.field {\n     auto m = parse_mutability(p);\n     auto i = parse_ident(p);\n     expect(p, token.EQ);\n     auto e = parse_expr(p);\n     ret rec(mut=m, ident=i, expr=e);\n }\n \n-impure fn parse_bottom_expr(parser p) -> @ast.expr {\n+fn parse_bottom_expr(parser p) -> @ast.expr {\n \n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n@@ -701,7 +698,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n \n         case (token.TUP) {\n             p.bump();\n-            impure fn parse_elt(parser p) -> ast.elt {\n+            fn parse_elt(parser p) -> ast.elt {\n                 auto m = parse_mutability(p);\n                 auto e = parse_expr(p);\n                 ret rec(mut=m, expr=e);\n@@ -767,7 +764,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.BIND) {\n             p.bump();\n             auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-            impure fn parse_expr_opt(parser p) -> option.t[@ast.expr] {\n+            fn parse_expr_opt(parser p) -> option.t[@ast.expr] {\n                 alt (p.peek()) {\n                     case (token.UNDERSCORE) {\n                         p.bump();\n@@ -937,7 +934,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n  * rust crates. At the moment we have neither.\n  */\n \n-impure fn expand_syntax_ext(parser p, ast.span sp,\n+fn expand_syntax_ext(parser p, ast.span sp,\n                      &ast.path path, vec[@ast.expr] args,\n                      option.t[@ast.expr] body) -> ast.expr_ {\n \n@@ -956,7 +953,7 @@ impure fn expand_syntax_ext(parser p, ast.span sp,\n     }\n }\n \n-impure fn extend_expr_by_ident(parser p, uint lo, uint hi,\n+fn extend_expr_by_ident(parser p, uint lo, uint hi,\n                                @ast.expr e, ast.ident i) -> @ast.expr {\n     auto e_ = e.node;\n     alt (e.node) {\n@@ -981,14 +978,14 @@ impure fn extend_expr_by_ident(parser p, uint lo, uint hi,\n     ret @spanned(lo, hi, e_);\n }\n \n-impure fn parse_self_method(parser p) -> @ast.expr {\n+fn parse_self_method(parser p) -> @ast.expr {\n     auto sp = p.get_span();\n     let ast.ident f_name = parse_ident(p);\n     auto hi = p.get_span();\n     ret @rec(node=ast.expr_self_method(f_name, ast.ann_none), span=sp);\n }\n \n-impure fn parse_dot_or_call_expr(parser p) -> @ast.expr {\n+fn parse_dot_or_call_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n     auto e = parse_bottom_expr(p);\n     auto hi = e.span.hi;\n@@ -1043,7 +1040,7 @@ impure fn parse_dot_or_call_expr(parser p) -> @ast.expr {\n     ret e;\n }\n \n-impure fn parse_prefix_expr(parser p) -> @ast.expr {\n+fn parse_prefix_expr(parser p) -> @ast.expr {\n \n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n@@ -1140,11 +1137,11 @@ fn prec_table() -> vec[op_spec] {\n             rec(tok=token.OROR, op=ast.or, prec=1));\n }\n \n-impure fn parse_binops(parser p) -> @ast.expr {\n+fn parse_binops(parser p) -> @ast.expr {\n     ret parse_more_binops(p, parse_prefix_expr(p), 0);\n }\n \n-impure fn parse_more_binops(parser p, @ast.expr lhs, int min_prec)\n+fn parse_more_binops(parser p, @ast.expr lhs, int min_prec)\n     -> @ast.expr {\n     // Magic nonsense to work around rustboot bug\n     fn op_eq(token.token a, token.token b) -> bool {\n@@ -1176,7 +1173,7 @@ impure fn parse_more_binops(parser p, @ast.expr lhs, int min_prec)\n     ret lhs;\n }\n \n-impure fn parse_assign_expr(parser p) -> @ast.expr {\n+fn parse_assign_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n     auto lhs = parse_binops(p);\n     alt (p.peek()) {\n@@ -1223,7 +1220,7 @@ impure fn parse_assign_expr(parser p) -> @ast.expr {\n     ret lhs;\n }\n \n-impure fn parse_if_expr(parser p) -> @ast.expr {\n+fn parse_if_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n \n     expect(p, token.IF);\n@@ -1245,7 +1242,7 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_if(cond, thn, els, ast.ann_none));\n }\n \n-impure fn parse_else_expr(parser p) -> @ast.expr {\n+fn parse_else_expr(parser p) -> @ast.expr {\n     expect(p, token.ELSE);\n     alt (p.peek()) {\n         case (token.IF) {\n@@ -1259,7 +1256,7 @@ impure fn parse_else_expr(parser p) -> @ast.expr {\n     }\n }\n \n-impure fn parse_head_local(parser p) -> @ast.decl {\n+fn parse_head_local(parser p) -> @ast.decl {\n     auto lo = p.get_lo_pos();\n     let @ast.local local;\n     if (p.peek() == token.AUTO) {\n@@ -1272,7 +1269,7 @@ impure fn parse_head_local(parser p) -> @ast.decl {\n \n \n \n-impure fn parse_for_expr(parser p) -> @ast.expr {\n+fn parse_for_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n     auto is_each = false;\n \n@@ -1301,7 +1298,7 @@ impure fn parse_for_expr(parser p) -> @ast.expr {\n }\n \n \n-impure fn parse_while_expr(parser p) -> @ast.expr {\n+fn parse_while_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n \n     expect(p, token.WHILE);\n@@ -1313,7 +1310,7 @@ impure fn parse_while_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_while(cond, body, ast.ann_none));\n }\n \n-impure fn parse_do_while_expr(parser p) -> @ast.expr {\n+fn parse_do_while_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n \n     expect(p, token.DO);\n@@ -1326,7 +1323,7 @@ impure fn parse_do_while_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_do_while(body, cond, ast.ann_none));\n }\n \n-impure fn parse_alt_expr(parser p) -> @ast.expr {\n+fn parse_alt_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n     expect(p, token.ALT);\n     expect(p, token.LPAREN);\n@@ -1377,7 +1374,7 @@ impure fn parse_alt_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, expr);\n }\n \n-impure fn parse_spawn_expr(parser p) -> @ast.expr {\n+fn parse_spawn_expr(parser p) -> @ast.expr {\n     auto lo = p.get_lo_pos();\n     expect(p, token.SPAWN);\n \n@@ -1398,19 +1395,19 @@ impure fn parse_spawn_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, spawn_expr);\n }\n \n-impure fn parse_expr(parser p) -> @ast.expr {\n+fn parse_expr(parser p) -> @ast.expr {\n     ret parse_expr_res(p, UNRESTRICTED);\n }\n \n-impure fn parse_expr_res(parser p, restriction r) -> @ast.expr {\n+fn parse_expr_res(parser p, restriction r) -> @ast.expr {\n     auto old = p.get_restriction();\n     p.restrict(r);\n     auto e = parse_expr_inner(p);\n     p.restrict(old);\n     ret e;\n }\n \n-impure fn parse_expr_inner(parser p) -> @ast.expr {\n+fn parse_expr_inner(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n             auto blk = parse_block(p);\n@@ -1442,7 +1439,7 @@ impure fn parse_expr_inner(parser p) -> @ast.expr {\n     }\n }\n \n-impure fn parse_initializer(parser p) -> option.t[ast.initializer] {\n+fn parse_initializer(parser p) -> option.t[ast.initializer] {\n     alt (p.peek()) {\n         case (token.EQ) {\n             p.bump();\n@@ -1460,7 +1457,7 @@ impure fn parse_initializer(parser p) -> option.t[ast.initializer] {\n     }\n }\n \n-impure fn parse_pat(parser p) -> @ast.pat {\n+fn parse_pat(parser p) -> @ast.pat {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n     auto pat;\n@@ -1514,7 +1511,7 @@ impure fn parse_pat(parser p) -> @ast.pat {\n     ret @spanned(lo, hi, pat);\n }\n \n-impure fn parse_local_full(&option.t[@ast.ty] tyopt,\n+fn parse_local_full(&option.t[@ast.ty] tyopt,\n                            parser p) -> @ast.local {\n     auto ident = parse_ident(p);\n     auto init = parse_initializer(p);\n@@ -1526,44 +1523,44 @@ impure fn parse_local_full(&option.t[@ast.ty] tyopt,\n              ann = ast.ann_none);\n }\n \n-impure fn parse_typed_local(parser p) -> @ast.local {\n+fn parse_typed_local(parser p) -> @ast.local {\n     auto ty = parse_ty(p);\n     ret parse_local_full(some(ty), p);\n }\n \n-impure fn parse_auto_local(parser p) -> @ast.local {\n+fn parse_auto_local(parser p) -> @ast.local {\n     ret parse_local_full(none[@ast.ty], p);\n }\n \n-impure fn parse_let(parser p) -> @ast.decl {\n+fn parse_let(parser p) -> @ast.decl {\n     auto lo = p.get_lo_pos();\n     expect(p, token.LET);\n     auto local = parse_typed_local(p);\n     ret @spanned(lo, p.get_hi_pos(), ast.decl_local(local));\n }\n \n-impure fn parse_auto(parser p) -> @ast.decl {\n+fn parse_auto(parser p) -> @ast.decl {\n     auto lo = p.get_lo_pos();\n     expect(p, token.AUTO);\n     auto local = parse_auto_local(p);\n     ret @spanned(lo, p.get_hi_pos(), ast.decl_local(local));\n }\n \n-impure fn parse_stmt(parser p) -> @ast.stmt {\n+fn parse_stmt(parser p) -> @ast.stmt {\n     if (p.get_file_type() == SOURCE_FILE) {\n         ret parse_source_stmt(p);\n     } else {\n         ret parse_crate_stmt(p);\n     }\n }\n \n-impure fn parse_crate_stmt(parser p) -> @ast.stmt {\n+fn parse_crate_stmt(parser p) -> @ast.stmt {\n     auto cdir = parse_crate_directive(p);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast.stmt_crate_directive(@cdir));\n }\n \n-impure fn parse_source_stmt(parser p) -> @ast.stmt {\n+fn parse_source_stmt(parser p) -> @ast.stmt {\n     auto lo = p.get_lo_pos();\n     alt (p.peek()) {\n \n@@ -1685,7 +1682,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n     }\n }\n \n-impure fn parse_block(parser p) -> ast.block {\n+fn parse_block(parser p) -> ast.block {\n     auto lo = p.get_lo_pos();\n \n     let vec[@ast.stmt] stmts = vec();\n@@ -1746,11 +1743,11 @@ impure fn parse_block(parser p) -> ast.block {\n     ret spanned[ast.block_](lo, hi, bloc);\n }\n \n-impure fn parse_ty_param(parser p) -> ast.ty_param {\n+fn parse_ty_param(parser p) -> ast.ty_param {\n     ret parse_ident(p);\n }\n \n-impure fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n+fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n     let vec[ast.ty_param] ty_params = vec();\n     if (p.peek() == token.LBRACKET) {\n         auto f = parse_ty_param;   // FIXME: pass as lval directly\n@@ -1760,7 +1757,7 @@ impure fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n     ret ty_params;\n }\n \n-impure fn parse_fn_decl(parser p, ast.effect eff) -> ast.fn_decl {\n+fn parse_fn_decl(parser p) -> ast.fn_decl {\n     auto pf = parse_arg;\n     let util.common.spanned[vec[ast.arg]] inputs =\n         // FIXME: passing parse_arg as an lval doesn't work at the\n@@ -1783,61 +1780,59 @@ impure fn parse_fn_decl(parser p, ast.effect eff) -> ast.fn_decl {\n     } else {\n         output = @spanned(inputs.span.lo, inputs.span.hi, ast.ty_nil);\n     }\n-    ret rec(effect=eff, inputs=inputs.node, output=output);\n+    ret rec(inputs=inputs.node, output=output);\n }\n \n-impure fn parse_fn(parser p, ast.effect eff, ast.proto proto) -> ast._fn {\n-    auto decl = parse_fn_decl(p, eff);\n+fn parse_fn(parser p, ast.proto proto) -> ast._fn {\n+    auto decl = parse_fn_decl(p);\n     auto body = parse_block(p);\n     ret rec(decl = decl,\n             proto = proto,\n             body = body);\n }\n \n-impure fn parse_fn_header(parser p)\n+fn parse_fn_header(parser p)\n     -> tup(ast.ident, vec[ast.ty_param]) {\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n     ret tup(id, ty_params);\n }\n \n-impure fn parse_item_fn_or_iter(parser p, ast.effect eff) -> @ast.item {\n+fn parse_item_fn_or_iter(parser p) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);\n     auto t = parse_fn_header(p);\n-    auto f = parse_fn(p, eff, proto);\n+    auto f = parse_fn(p, proto);\n     auto item = ast.item_fn(t._0, f, t._1,\n                             p.next_def_id(), ast.ann_none);\n     ret @spanned(lo, f.body.span.hi, item);\n }\n \n \n-impure fn parse_obj_field(parser p) -> ast.obj_field {\n+fn parse_obj_field(parser p) -> ast.obj_field {\n     auto mut = parse_mutability(p); // TODO: store this, use it in typeck\n     auto ty = parse_ty(p);\n     auto ident = parse_ident(p);\n     ret rec(ty=ty, ident=ident, id=p.next_def_id(), ann=ast.ann_none);\n }\n \n-impure fn parse_method(parser p) -> @ast.method {\n+fn parse_method(parser p) -> @ast.method {\n     auto lo = p.get_lo_pos();\n-    auto eff = parse_effect(p);\n     auto proto = parse_proto(p);\n     auto ident = parse_ident(p);\n-    auto f = parse_fn(p, eff, proto);\n+    auto f = parse_fn(p, proto);\n     auto meth = rec(ident=ident, meth=f,\n                     id=p.next_def_id(), ann=ast.ann_none);\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n-impure fn parse_dtor(parser p) -> @ast.method {\n+fn parse_dtor(parser p) -> @ast.method {\n     auto lo = p.get_lo_pos();\n     expect(p, token.DROP);\n     let ast.block b = parse_block(p);\n     let vec[ast.arg] inputs = vec();\n     let @ast.ty output = @spanned(lo, lo, ast.ty_nil);\n-    let ast.fn_decl d = rec(effect=ast.eff_pure,\n-                            inputs=inputs,\n+    let ast.fn_decl d = rec(inputs=inputs,\n                             output=output);\n     let ast._fn f = rec(decl = d,\n                         proto = ast.proto_fn,\n@@ -1849,7 +1844,7 @@ impure fn parse_dtor(parser p) -> @ast.method {\n     ret @spanned(lo, f.body.span.hi, m);\n }\n \n-impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n+fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.OBJ);\n     auto ident = parse_ident(p);\n@@ -1890,7 +1885,7 @@ impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n     ret @spanned(lo, hi, item);\n }\n \n-impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n+fn parse_mod_items(parser p, token.token term) -> ast._mod {\n     auto index = new_str_hash[ast.mod_index_entry]();\n     auto view_items = parse_view(p, index);\n     let vec[@ast.item] items = vec();\n@@ -1904,7 +1899,7 @@ impure fn parse_mod_items(parser p, token.token term) -> ast._mod {\n     ret rec(view_items=view_items, items=items, index=index);\n }\n \n-impure fn parse_item_const(parser p) -> @ast.item {\n+fn parse_item_const(parser p) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.CONST);\n     auto ty = parse_ty(p);\n@@ -1917,7 +1912,7 @@ impure fn parse_item_const(parser p) -> @ast.item {\n     ret @spanned(lo, hi, item);\n }\n \n-impure fn parse_item_mod(parser p) -> @ast.item {\n+fn parse_item_mod(parser p) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.MOD);\n     auto id = parse_ident(p);\n@@ -1929,19 +1924,19 @@ impure fn parse_item_mod(parser p) -> @ast.item {\n     ret @spanned(lo, hi, item);\n }\n \n-impure fn parse_item_native_type(parser p) -> @ast.native_item {\n+fn parse_item_native_type(parser p) -> @ast.native_item {\n     auto t = parse_type_decl(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token.SEMI);\n     auto item = ast.native_item_ty(t._1, p.next_def_id());\n     ret @spanned(t._0, hi, item);\n }\n \n-impure fn parse_item_native_fn(parser p, ast.effect eff) -> @ast.native_item {\n+fn parse_item_native_fn(parser p) -> @ast.native_item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.FN);\n     auto t = parse_fn_header(p);\n-    auto decl = parse_fn_decl(p, eff);\n+    auto decl = parse_fn_decl(p);\n     auto link_name = none[str];\n     if (p.peek() == token.EQ) {\n         p.bump();\n@@ -1955,16 +1950,15 @@ impure fn parse_item_native_fn(parser p, ast.effect eff) -> @ast.native_item {\n     ret @spanned(lo, hi, item);\n }\n \n-impure fn parse_native_item(parser p) -> @ast.native_item {\n-    let ast.effect eff = parse_effect(p);\n+fn parse_native_item(parser p) -> @ast.native_item {\n     let ast.opacity opa = parse_opacity(p);\n     let ast.layer lyr = parse_layer(p);\n     alt (p.peek()) {\n         case (token.TYPE) {\n             ret parse_item_native_type(p);\n         }\n         case (token.FN) {\n-            ret parse_item_native_fn(p, eff);\n+            ret parse_item_native_fn(p);\n         }\n         case (?t) {\n             unexpected(p, t);\n@@ -1973,7 +1967,7 @@ impure fn parse_native_item(parser p) -> @ast.native_item {\n     }\n }\n \n-impure fn parse_native_mod_items(parser p,\n+fn parse_native_mod_items(parser p,\n                                  str native_name,\n                                  ast.native_abi abi) -> ast.native_mod {\n     auto index = new_str_hash[ast.native_mod_index_entry]();\n@@ -2008,7 +2002,7 @@ fn default_native_name(session.session sess, str id) -> str {\n     }\n }\n \n-impure fn parse_item_native_mod(parser p) -> @ast.item {\n+fn parse_item_native_mod(parser p) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.NATIVE);\n     auto abi = ast.native_abi_cdecl;\n@@ -2041,14 +2035,14 @@ impure fn parse_item_native_mod(parser p) -> @ast.item {\n     ret @spanned(lo, hi, item);\n }\n \n-impure fn parse_type_decl(parser p) -> tup(uint, ast.ident) {\n+fn parse_type_decl(parser p) -> tup(uint, ast.ident) {\n     auto lo = p.get_lo_pos();\n     expect(p, token.TYPE);\n     auto id = parse_ident(p);\n     ret tup(lo, id);\n }\n \n-impure fn parse_item_type(parser p) -> @ast.item {\n+fn parse_item_type(parser p) -> @ast.item {\n     auto t = parse_type_decl(p);\n     auto tps = parse_ty_params(p);\n \n@@ -2060,7 +2054,7 @@ impure fn parse_item_type(parser p) -> @ast.item {\n     ret @spanned(t._0, hi, item);\n }\n \n-impure fn parse_item_tag(parser p) -> @ast.item {\n+fn parse_item_tag(parser p) -> @ast.item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.TAG);\n     auto id = parse_ident(p);\n@@ -2112,7 +2106,7 @@ impure fn parse_item_tag(parser p) -> @ast.item {\n     ret @spanned(lo, hi, item);\n }\n \n-impure fn parse_opacity(parser p) -> ast.opacity {\n+fn parse_opacity(parser p) -> ast.opacity {\n     alt (p.peek()) {\n         case (token.ABS) {\n             p.bump();\n@@ -2125,7 +2119,7 @@ impure fn parse_opacity(parser p) -> ast.opacity {\n     fail;\n }\n \n-impure fn parse_layer(parser p) -> ast.layer {\n+fn parse_layer(parser p) -> ast.layer {\n     alt (p.peek()) {\n         case (token.STATE) {\n             p.bump();\n@@ -2143,18 +2137,14 @@ impure fn parse_layer(parser p) -> ast.layer {\n }\n \n \n-impure fn parse_effect(parser p) -> ast.effect {\n+fn parse_auth(parser p) -> ast._auth {\n     alt (p.peek()) {\n-        case (token.IMPURE) {\n-            p.bump();\n-            ret ast.eff_impure;\n-        }\n         case (token.UNSAFE) {\n             p.bump();\n-            ret ast.eff_unsafe;\n+            ret ast.auth_unsafe;\n         }\n-        case (_) {\n-            ret ast.eff_pure;\n+        case (?t) {\n+            unexpected(p, t);\n         }\n     }\n     fail;\n@@ -2164,8 +2154,6 @@ fn peeking_at_item(parser p) -> bool {\n     alt (p.peek()) {\n         case (token.STATE) { ret true; }\n         case (token.GC) { ret true; }\n-        case (token.IMPURE) { ret true; }\n-        case (token.UNSAFE) { ret true; }\n         case (token.CONST) { ret true; }\n         case (token.FN) { ret true; }\n         case (token.ITER) { ret true; }\n@@ -2178,46 +2166,39 @@ fn peeking_at_item(parser p) -> bool {\n     ret false;\n }\n \n-impure fn parse_item(parser p) -> @ast.item {\n-    let ast.effect eff = parse_effect(p);\n+fn parse_item(parser p) -> @ast.item {\n     let ast.opacity opa = parse_opacity(p);\n     let ast.layer lyr = parse_layer(p);\n \n     alt (p.peek()) {\n         case (token.CONST) {\n-            check (eff == ast.eff_pure);\n             check (lyr == ast.layer_value);\n             ret parse_item_const(p);\n         }\n \n         case (token.FN) {\n             check (lyr == ast.layer_value);\n-            ret parse_item_fn_or_iter(p, eff);\n+            ret parse_item_fn_or_iter(p);\n         }\n         case (token.ITER) {\n             check (lyr == ast.layer_value);\n-            ret parse_item_fn_or_iter(p, eff);\n+            ret parse_item_fn_or_iter(p);\n         }\n         case (token.MOD) {\n-            check (eff == ast.eff_pure);\n             check (lyr == ast.layer_value);\n             ret parse_item_mod(p);\n         }\n         case (token.NATIVE) {\n-            check (eff == ast.eff_pure);\n             check (lyr == ast.layer_value);\n             ret parse_item_native_mod(p);\n         }\n         case (token.TYPE) {\n-            check (eff == ast.eff_pure);\n             ret parse_item_type(p);\n         }\n         case (token.TAG) {\n-            check (eff == ast.eff_pure);\n             ret parse_item_tag(p);\n         }\n         case (token.OBJ) {\n-            check (eff == ast.eff_pure);\n             ret parse_item_obj(p, lyr);\n         }\n         case (?t) {\n@@ -2227,7 +2208,7 @@ impure fn parse_item(parser p) -> @ast.item {\n     fail;\n }\n \n-impure fn parse_meta_item(parser p) -> @ast.meta_item {\n+fn parse_meta_item(parser p) -> @ast.meta_item {\n     auto lo = p.get_lo_pos();\n     auto ident = parse_ident(p);\n     expect(p, token.EQ);\n@@ -2244,13 +2225,13 @@ impure fn parse_meta_item(parser p) -> @ast.meta_item {\n     fail;\n }\n \n-impure fn parse_meta(parser p) -> vec[@ast.meta_item] {\n+fn parse_meta(parser p) -> vec[@ast.meta_item] {\n     auto pf = parse_meta_item;\n     ret parse_seq[@ast.meta_item](token.LPAREN, token.RPAREN,\n                                    some(token.COMMA), pf, p).node;\n }\n \n-impure fn parse_optional_meta(parser p) -> vec[@ast.meta_item] {\n+fn parse_optional_meta(parser p) -> vec[@ast.meta_item] {\n     alt (p.peek()) {\n         case (token.LPAREN) {\n             ret parse_meta(p);\n@@ -2262,7 +2243,7 @@ impure fn parse_optional_meta(parser p) -> vec[@ast.meta_item] {\n     }\n }\n \n-impure fn parse_use(parser p) -> @ast.view_item {\n+fn parse_use(parser p) -> @ast.view_item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.USE);\n     auto ident = parse_ident(p);\n@@ -2274,7 +2255,7 @@ impure fn parse_use(parser p) -> @ast.view_item {\n     ret @spanned(lo, hi, use_decl);\n }\n \n-impure fn parse_rest_import_name(parser p, ast.ident first,\n+fn parse_rest_import_name(parser p, ast.ident first,\n                                  option.t[ast.ident] def_ident)\n         -> @ast.view_item {\n     auto lo = p.get_lo_pos();\n@@ -2302,7 +2283,7 @@ impure fn parse_rest_import_name(parser p, ast.ident first,\n     ret @spanned(lo, hi, import_decl);\n }\n \n-impure fn parse_full_import_name(parser p, ast.ident def_ident)\n+fn parse_full_import_name(parser p, ast.ident def_ident)\n        -> @ast.view_item {\n     alt (p.peek()) {\n         case (token.IDENT(?ident)) {\n@@ -2316,7 +2297,7 @@ impure fn parse_full_import_name(parser p, ast.ident def_ident)\n     fail;\n }\n \n-impure fn parse_import(parser p) -> @ast.view_item {\n+fn parse_import(parser p) -> @ast.view_item {\n     expect(p, token.IMPORT);\n     alt (p.peek()) {\n         case (token.IDENT(?ident)) {\n@@ -2338,7 +2319,7 @@ impure fn parse_import(parser p) -> @ast.view_item {\n     fail;\n }\n \n-impure fn parse_export(parser p) -> @ast.view_item {\n+fn parse_export(parser p) -> @ast.view_item {\n     auto lo = p.get_lo_pos();\n     expect(p, token.EXPORT);\n     auto id = parse_ident(p);\n@@ -2347,7 +2328,7 @@ impure fn parse_export(parser p) -> @ast.view_item {\n     ret @spanned(lo, hi, ast.view_item_export(id));\n }\n \n-impure fn parse_view_item(parser p) -> @ast.view_item {\n+fn parse_view_item(parser p) -> @ast.view_item {\n     alt (p.peek()) {\n         case (token.USE) {\n             ret parse_use(p);\n@@ -2371,7 +2352,7 @@ fn is_view_item(token.token t) -> bool {\n     ret false;\n }\n \n-impure fn parse_view(parser p, ast.mod_index index) -> vec[@ast.view_item] {\n+fn parse_view(parser p, ast.mod_index index) -> vec[@ast.view_item] {\n     let vec[@ast.view_item] items = vec();\n     while (is_view_item(p.peek())) {\n         auto item = parse_view_item(p);\n@@ -2382,7 +2363,7 @@ impure fn parse_view(parser p, ast.mod_index index) -> vec[@ast.view_item] {\n     ret items;\n }\n \n-impure fn parse_native_view(parser p, ast.native_mod_index index)\n+fn parse_native_view(parser p, ast.native_mod_index index)\n     -> vec[@ast.view_item] {\n     let vec[@ast.view_item] items = vec();\n     while (is_view_item(p.peek())) {\n@@ -2395,7 +2376,7 @@ impure fn parse_native_view(parser p, ast.native_mod_index index)\n }\n \n \n-impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n+fn parse_crate_from_source_file(parser p) -> @ast.crate {\n     auto lo = p.get_lo_pos();\n     auto m = parse_mod_items(p, token.EOF);\n     let vec[@ast.crate_directive] cdirs = vec();\n@@ -2409,18 +2390,18 @@ impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n //\n // Each directive imperatively extends its environment with 0 or more items.\n \n-impure fn parse_crate_directive(parser p) -> ast.crate_directive\n+fn parse_crate_directive(parser p) -> ast.crate_directive\n {\n     auto lo = p.get_lo_pos();\n     alt (p.peek()) {\n         case (token.AUTH) {\n             p.bump();\n             auto n = parse_path(p, GREEDY);\n             expect(p, token.EQ);\n-            auto e = parse_effect(p);\n+            auto a = parse_auth(p);\n             auto hi = p.get_hi_pos();\n             expect(p, token.SEMI);\n-            ret spanned(lo, hi, ast.cdir_auth(n, e));\n+            ret spanned(lo, hi, ast.cdir_auth(n, a));\n         }\n \n         case (token.META) {\n@@ -2510,7 +2491,7 @@ impure fn parse_crate_directive(parser p) -> ast.crate_directive\n }\n \n \n-impure fn parse_crate_directives(parser p, token.token term)\n+fn parse_crate_directives(parser p, token.token term)\n     -> vec[@ast.crate_directive] {\n \n     let vec[@ast.crate_directive] cdirs = vec();\n@@ -2523,7 +2504,7 @@ impure fn parse_crate_directives(parser p, token.token term)\n     ret cdirs;\n }\n \n-impure fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n+fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n     auto lo = p.get_lo_pos();\n     auto prefix = std.fs.dirname(p.get_filemap().name);\n     auto cdirs = parse_crate_directives(p, token.EOF);"}, {"sha": "cdc6b5031e550f1e7b329fda841bfc75af7270b4", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -100,8 +100,7 @@ tag token {\n     STATE;\n     GC;\n \n-    /* Effect keywords */\n-    IMPURE;\n+    /* Unsafe-block keyword */\n     UNSAFE;\n \n     /* Type qualifiers */\n@@ -273,8 +272,7 @@ fn to_str(token t) -> str {\n         case (STATE) { ret \"state\"; }\n         case (GC) { ret \"gc\"; }\n \n-        /* Effect keywords */\n-        case (IMPURE) { ret \"impure\"; }\n+        /* Unsafe-block keyword */\n         case (UNSAFE) { ret \"unsafe\"; }\n \n         /* Type qualifiers */"}, {"sha": "ef592fc8ab3f0e2cf6b3c298fd9e049eb935daf2", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -61,7 +61,6 @@ type ast_fold[ENV] =\n          vec[ast.ty_method] meths) -> @ty)        fold_ty_obj,\n \n      (fn(&ENV e, &span sp,\n-         ast.effect eff,\n          ast.proto proto,\n          vec[rec(ast.mode mode, @ty ty)] inputs,\n          @ty output) -> @ty)                      fold_ty_fn,\n@@ -299,7 +298,7 @@ type ast_fold[ENV] =\n          ast.proto proto,\n          &block body) -> ast._fn)                 fold_fn,\n \n-     (fn(&ENV e, ast.effect effect,\n+     (fn(&ENV e,\n          vec[arg] inputs,\n          @ty output) -> ast.fn_decl)              fold_fn_decl,\n \n@@ -398,12 +397,12 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         case (ast.ty_obj(?meths)) {\n             let vec[ast.ty_method] meths_ = vec();\n             for (ast.ty_method m in meths) {\n-                auto tfn = fold_ty_fn(env_, fld, t.span, m.effect, m.proto,\n+                auto tfn = fold_ty_fn(env_, fld, t.span, m.proto,\n                                       m.inputs, m.output);\n                 alt (tfn.node) {\n-                    case (ast.ty_fn(?eff, ?p, ?ins, ?out)) {\n+                    case (ast.ty_fn(?p, ?ins, ?out)) {\n                         _vec.push[ast.ty_method]\n-                            (meths_, rec(effect=eff, proto=p, inputs=ins,\n+                            (meths_, rec(proto=p, inputs=ins,\n                                          output=out with m));\n                     }\n                 }\n@@ -416,8 +415,8 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             ret fld.fold_ty_path(env_, t.span, pth_, ref_opt);\n         }\n \n-        case (ast.ty_fn(?eff, ?proto, ?inputs, ?output)) {\n-            ret fold_ty_fn(env_, fld, t.span, eff, proto, inputs, output);\n+        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n+            ret fold_ty_fn(env_, fld, t.span, proto, inputs, output);\n         }\n \n         case (ast.ty_chan(?ty)) {\n@@ -433,7 +432,7 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n }\n \n fn fold_ty_fn[ENV](&ENV env, ast_fold[ENV] fld, &span sp,\n-                   ast.effect eff, ast.proto proto,\n+                   ast.proto proto,\n                    vec[rec(ast.mode mode, @ty ty)] inputs,\n                    @ty output) -> @ty {\n     auto output_ = fold_ty(env, fld, output);\n@@ -443,7 +442,7 @@ fn fold_ty_fn[ENV](&ENV env, ast_fold[ENV] fld, &span sp,\n         auto input_ = rec(ty=ty_ with input);\n         inputs_ += vec(input_);\n     }\n-    ret fld.fold_ty_fn(env, sp, eff, proto, inputs_, output_);\n+    ret fld.fold_ty_fn(env, sp, proto, inputs_, output_);\n }\n \n fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n@@ -894,7 +893,7 @@ fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n         inputs += vec(fold_arg(env, fld, a));\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n-    ret fld.fold_fn_decl(env, decl.effect, inputs, output);\n+    ret fld.fold_fn_decl(env, inputs, output);\n }\n \n fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n@@ -1187,10 +1186,10 @@ fn identity_fold_ty_obj[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n-                            ast.effect eff, ast.proto proto,\n+                            ast.proto proto,\n                             vec[rec(ast.mode mode, @ty ty)] inputs,\n                             @ty output) -> @ty {\n-    ret @respan(sp, ast.ty_fn(eff, proto, inputs, output));\n+    ret @respan(sp, ast.ty_fn(proto, inputs, output));\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n@@ -1530,10 +1529,9 @@ fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n }\n \n fn identity_fold_fn_decl[ENV](&ENV e,\n-                              ast.effect effect,\n                               vec[arg] inputs,\n                               @ty output) -> ast.fn_decl {\n-    ret rec(effect=effect, inputs=inputs, output=output);\n+    ret rec(inputs=inputs, output=output);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n@@ -1638,7 +1636,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ty_tup     = bind identity_fold_ty_tup[ENV](_,_,_),\n          fold_ty_rec     = bind identity_fold_ty_rec[ENV](_,_,_),\n          fold_ty_obj     = bind identity_fold_ty_obj[ENV](_,_,_),\n-         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_,_),\n+         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_),\n          fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n          fold_ty_chan    = bind identity_fold_ty_chan[ENV](_,_,_),\n          fold_ty_port    = bind identity_fold_ty_port[ENV](_,_,_),\n@@ -1708,7 +1706,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n              bind identity_fold_native_item_ty[ENV](_,_,_,_),\n          fold_item_tag  = bind identity_fold_item_tag[ENV](_,_,_,_,_,_,_),\n          fold_item_obj  = bind identity_fold_item_obj[ENV](_,_,_,_,_,_,_),\n-       \n+\n          fold_view_item_use =\n              bind identity_fold_view_item_use[ENV](_,_,_,_,_,_),\n          fold_view_item_import =\n@@ -1720,7 +1718,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),\n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n-         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_),\n+         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n          fold_crate = bind identity_fold_crate[ENV](_,_,_,_),"}, {"sha": "fee3b30f7ee847018ed42e07a4d3859511ca79fd", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -521,8 +521,8 @@ fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n     ret buckets;\n }\n \n-impure fn encode_index[T](&ebml.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n-                          impure fn(io.writer, &T) write_fn) {\n+fn encode_index[T](&ebml.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n+                          fn(io.writer, &T) write_fn) {\n     auto writer = io.new_writer_(ebml_w.writer);\n \n     ebml.start_tag(ebml_w, tag_index);\n@@ -553,16 +553,16 @@ impure fn encode_index[T](&ebml.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n }\n \n \n-impure fn write_str(io.writer writer, &str s) {\n+fn write_str(io.writer writer, &str s) {\n     writer.write_str(s);\n }\n \n-impure fn write_int(io.writer writer, &int n) {\n+fn write_int(io.writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n \n-impure fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n+fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n         -> ValueRef {\n     auto string_w = io.string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();"}, {"sha": "06fbf76ef3c9b3370a4c6028fa81db9c8171ca1a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -54,8 +54,8 @@ tag sty {\n     ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n-    ty_fn(ast.proto, vec[arg], @t);                 // TODO: effect\n-    ty_native_fn(ast.native_abi, vec[arg], @t);     // TODO: effect\n+    ty_fn(ast.proto, vec[arg], @t);\n+    ty_native_fn(ast.native_abi, vec[arg], @t);\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var"}, {"sha": "87c11a7b90a47e0d3a9792ee0485757c5439f458", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -267,7 +267,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n             sty = ty.ty_rec(flds);\n         }\n \n-        case (ast.ty_fn(_, ?proto, ?inputs, ?output)) {\n+        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(getter, _);\n             auto i = _vec.map[ast.ty_arg, arg](f, inputs);\n             sty = ty.ty_fn(proto, i, ast_ty_to_ty(getter, output));"}, {"sha": "7d7108ff82aa3d94839fd5b4e3c56e5ced9e91f9", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -277,7 +277,7 @@ fn mk_fn_info(_fn f) -> fn_info {\n   ret res;\n }\n \n-/* extends mk_fn_info to an item, side-effecting the map fi from \n+/* extends mk_fn_info to an item, side-effecting the map fi from\n    function IDs to fn_info maps */\n fn mk_fn_info_item_fn(&_fn_info_map fi, &span sp, ident i, &ast._fn f,\n                  vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n@@ -888,14 +888,14 @@ fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n     }\n }\n \n-impure fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n+fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n   check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n \n   ret set_in_postcond(i, (ann_to_ts_ann_fail_more(a)).conditions);\n }\n \n-impure fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n+fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n   check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n \n@@ -976,7 +976,7 @@ fn find_pre_post_state_item(_fn_info_map fm, @item i) -> bool {\n   fail;\n }\n \n-impure fn set_prestate_ann(ann a, prestate pre) -> bool {\n+fn set_prestate_ann(ann a, prestate pre) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n@@ -990,7 +990,7 @@ impure fn set_prestate_ann(ann a, prestate pre) -> bool {\n }\n \n \n-impure fn extend_prestate_ann(ann a, prestate pre) -> bool {\n+fn extend_prestate_ann(ann a, prestate pre) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n@@ -1003,7 +1003,7 @@ impure fn extend_prestate_ann(ann a, prestate pre) -> bool {\n   }\n }\n \n-impure fn set_poststate_ann(ann a, poststate post) -> bool {\n+fn set_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n@@ -1016,7 +1016,7 @@ impure fn set_poststate_ann(ann a, poststate post) -> bool {\n   }\n }\n \n-impure fn extend_poststate_ann(ann a, poststate post) -> bool {\n+fn extend_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n@@ -1029,7 +1029,7 @@ impure fn extend_poststate_ann(ann a, poststate post) -> bool {\n   }\n }\n \n-impure fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n+fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n     alt (a) {\n         case (ann_type(_,_,?ts_a)) {\n             check (! is_none[@ts_ann](ts_a));\n@@ -1068,7 +1068,7 @@ fn find_pre_post_state_exprs(&_fn_info_map fm,\n   ret changed;\n }\n \n-impure fn pure_exp(&ann a, &prestate p) -> bool {\n+fn pure_exp(&ann a, &prestate p) -> bool {\n   auto changed = false;\n   changed = extend_prestate_ann(a, p) || changed;\n   changed = extend_poststate_ann(a, p) || changed;\n@@ -1363,7 +1363,7 @@ fn fixed_point_states(_fn_info_map fm, fn_info f_info,\n   }\n }\n \n-impure fn check_states_expr(fn_info enclosing, &expr e) -> () {\n+fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let precond prec    = expr_precond(e);\n   let prestate pres   = expr_prestate(e);\n "}, {"sha": "85651c78c3c7ab633285a19c5f6270f88871999b", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -48,14 +48,14 @@ fn mkstate(io.writer out, uint width) -> ps {\n            mutable potential_brk=false);\n }\n \n-impure fn write_spaces(ps p, uint i) {\n+fn write_spaces(ps p, uint i) {\n   while (i > 0u) {\n     i -= 1u;\n     p.out.write_str(\" \");\n   }\n }\n \n-impure fn push_context(ps p, contexttype tp, uint indent) {\n+fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n   _vec.push[context](p.context, rec(tp=tp, indent=indent));\n   p.start_of_box = true;\n@@ -65,13 +65,13 @@ fn pop_context(ps p) {\n   _vec.pop[context](p.context);\n }\n \n-impure fn add_token(ps p, token tok) {\n+fn add_token(ps p, token tok) {\n   if (p.width == 0u) {direct_token(p, tok);}\n   else if (p.scanning == scan_none) {do_token(p, tok);}\n   else {buffer_token(p, tok);}\n }\n \n-impure fn direct_token(ps p, token tok) {\n+fn direct_token(ps p, token tok) {\n   alt (tok) {\n     case (brk(?sz)) {write_spaces(p, sz);}\n     case (word(?w)) {p.out.write_str(w);}\n@@ -80,7 +80,7 @@ impure fn direct_token(ps p, token tok) {\n   }\n }\n \n-impure fn buffer_token(ps p, token tok) {\n+fn buffer_token(ps p, token tok) {\n   p.buffered += vec(tok);\n   auto col = p.scancol;\n   p.scancol = col + token_size(tok);\n@@ -114,14 +114,14 @@ impure fn buffer_token(ps p, token tok) {\n   }\n }\n \n-impure fn check_potential_brk(ps p) {\n+fn check_potential_brk(ps p) {\n   for (boxtype tp in p.scandepth) {\n     if (tp != box_h) {ret;}\n   }\n   p.potential_brk = true;\n }\n \n-impure fn finish_scan(ps p, bool fits) {\n+fn finish_scan(ps p, bool fits) {\n   auto buf = p.buffered;\n   auto front = _vec.shift[token](buf);\n   auto chosen_tp = cx_h;\n@@ -145,7 +145,7 @@ impure fn finish_scan(ps p, bool fits) {\n   for (token t in buf) { add_token(p, t); }\n }\n \n-impure fn start_scan(ps p, token tok, scantype tp) {\n+fn start_scan(ps p, token tok, scantype tp) {\n   p.buffered = vec();\n   p.scancol = p.col;\n   p.scanning = tp;\n@@ -174,7 +174,7 @@ fn box_is(boxtype a, boxtype b) -> bool {\n   else {ret false;}\n }\n \n-impure fn do_token(ps p, token tok) {\n+fn do_token(ps p, token tok) {\n   auto start_of_box = p.start_of_box;\n   p.start_of_box = false;\n   alt (tok) {\n@@ -223,14 +223,14 @@ impure fn do_token(ps p, token tok) {\n   }\n }\n \n-impure fn line_break(ps p) {\n+fn line_break(ps p) {\n   p.out.write_str(\"\\n\");\n   p.col = 0u;\n   p.spaces = cur_context(p).indent;\n   p.start_of_line = true;\n }\n \n-impure fn before_print(ps p, bool closing) {\n+fn before_print(ps p, bool closing) {\n   if (p.start_of_line) {\n     p.start_of_line = false;\n     if (closing) {p.spaces = base_indent(p);}\n@@ -254,14 +254,14 @@ fn token_size(token tok) -> uint {\n   }\n }\n \n-impure fn box(ps p, uint indent) {add_token(p, open(box_hv, indent));}\n-impure fn abox(ps p) {add_token(p, open(box_align, 0u));}\n-impure fn vbox(ps p, uint indent) {add_token(p, open(box_v, indent));}\n-impure fn hbox(ps p, uint indent) {add_token(p, open(box_h, indent));}\n-impure fn end(ps p) {add_token(p, close);}\n-impure fn wrd(ps p, str wrd) {add_token(p, word(wrd));}\n-impure fn cwrd(ps p, str wrd) {add_token(p, cword(wrd));}\n-impure fn space(ps p) {add_token(p, brk(1u));}\n-impure fn spaces(ps p, uint n) {add_token(p, brk(n));}\n-impure fn line(ps p) {add_token(p, brk(0u));}\n-impure fn hardbreak(ps p) {add_token(p, hardbrk);}\n+fn box(ps p, uint indent) {add_token(p, open(box_hv, indent));}\n+fn abox(ps p) {add_token(p, open(box_align, 0u));}\n+fn vbox(ps p, uint indent) {add_token(p, open(box_v, indent));}\n+fn hbox(ps p, uint indent) {add_token(p, open(box_h, indent));}\n+fn end(ps p) {add_token(p, close);}\n+fn wrd(ps p, str wrd) {add_token(p, word(wrd));}\n+fn cwrd(ps p, str wrd) {add_token(p, cword(wrd));}\n+fn space(ps p) {add_token(p, brk(1u));}\n+fn spaces(ps p, uint n) {add_token(p, brk(n));}\n+fn line(ps p) {add_token(p, brk(0u));}\n+fn hardbreak(ps p) {add_token(p, hardbrk);}"}, {"sha": "cf606d9e6f1876f5aad26751cec2cd1056a9a1f0", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -15,7 +15,7 @@ type ps = @rec(pp.ps s,\n                option.t[vec[lexer.cmnt]] comments,\n                mutable uint cur_cmnt);\n \n-impure fn print_file(ast._mod _mod, str filename, io.writer out) {\n+fn print_file(ast._mod _mod, str filename, io.writer out) {\n     auto cmnts = lexer.gather_comments(filename);\n     auto s = @rec(s=pp.mkstate(out, default_columns),\n                   comments=option.some[vec[lexer.cmnt]](cmnts),\n@@ -59,47 +59,47 @@ fn pat_to_str(&@ast.pat p) -> str {\n     ret writer.get_str();\n }\n \n-impure fn hbox(ps s) {\n+fn hbox(ps s) {\n     pp.hbox(s.s, indent_unit);\n }\n-impure fn wrd1(ps s, str word) {\n+fn wrd1(ps s, str word) {\n     wrd(s.s, word);\n     space(s.s);\n }\n-impure fn popen(ps s) {\n+fn popen(ps s) {\n     wrd(s.s, \"(\");\n     pp.abox(s.s);\n }\n-impure fn popen_h(ps s) {\n+fn popen_h(ps s) {\n     wrd(s.s, \"(\");\n     pp.hbox(s.s, 0u);\n }\n-impure fn pclose(ps s) {\n+fn pclose(ps s) {\n     end(s.s);\n     wrd(s.s, \")\");\n }\n-impure fn bopen(ps s) {\n+fn bopen(ps s) {\n     wrd(s.s, \"{\");\n     pp.vbox(s.s, indent_unit);\n     line(s.s);\n }\n-impure fn bclose(ps s) {\n+fn bclose(ps s) {\n     end(s.s);\n     pp.cwrd(s.s, \"}\");\n }\n-impure fn bclose_c(ps s, common.span span) {\n+fn bclose_c(ps s, common.span span) {\n     maybe_print_comment(s, span.hi);\n     bclose(s);\n }\n-impure fn commasep[IN](ps s, vec[IN] elts, impure fn(ps, &IN) op) {\n+fn commasep[IN](ps s, vec[IN] elts, fn(ps, &IN) op) {\n     auto first = true;\n     for (IN elt in elts) {\n         if (first) {first = false;}\n         else {wrd1(s, \",\");}\n         op(s, elt);\n     }\n }\n-impure fn commasep_cmnt[IN](ps s, vec[IN] elts, impure fn(ps, &IN) op,\n+fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n                             fn(&IN) -> common.span get_span) {\n     auto len = _vec.len[IN](elts);\n     auto i = 0u;\n@@ -112,21 +112,21 @@ impure fn commasep_cmnt[IN](ps s, vec[IN] elts, impure fn(ps, &IN) op,\n         }\n     }\n }\n-impure fn commasep_exprs(ps s, vec[@ast.expr] exprs) {\n+fn commasep_exprs(ps s, vec[@ast.expr] exprs) {\n     fn expr_span(&@ast.expr expr) -> common.span {ret expr.span;}\n     auto f = print_expr;\n     auto gs = expr_span;\n     commasep_cmnt[@ast.expr](s, exprs, f, gs);\n }\n \n-impure fn print_mod(ps s, ast._mod _mod) {\n+fn print_mod(ps s, ast._mod _mod) {\n     for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n     line(s.s);\n     for (@ast.item item in _mod.items) {print_item(s, item);}\n     print_remaining_comments(s);\n }\n \n-impure fn print_type(ps s, &@ast.ty ty) {\n+fn print_type(ps s, &@ast.ty ty) {\n     maybe_print_comment(s, ty.span.lo);\n     hbox(s);\n     alt (ty.node) {\n@@ -159,7 +159,7 @@ impure fn print_type(ps s, &@ast.ty ty) {\n         case (ast.ty_rec(?fields)) {\n             wrd(s.s, \"rec\");\n             popen(s);\n-            impure fn print_field(ps s, &ast.ty_field f) {\n+            fn print_field(ps s, &ast.ty_field f) {\n                 hbox(s);\n                 print_mt(s, f.mt);\n                 space(s.s);\n@@ -182,16 +182,16 @@ impure fn print_type(ps s, &@ast.ty ty) {\n             bopen(s);\n             for (ast.ty_method m in methods) {\n                 hbox(s);\n-                print_ty_fn(s, m.effect, m.proto, option.some[str](m.ident),\n+                print_ty_fn(s, m.proto, option.some[str](m.ident),\n                             m.inputs, m.output);\n                 wrd(s.s, \";\");\n                 end(s.s);\n                 line(s.s);\n             }\n             bclose_c(s, ty.span);\n         }\n-        case (ast.ty_fn(?eff, ?proto,?inputs,?output)) {\n-            print_ty_fn(s, eff, proto, option.none[str], inputs, output);\n+        case (ast.ty_fn(?proto,?inputs,?output)) {\n+            print_ty_fn(s, proto, option.none[str], inputs, output);\n         }\n         case (ast.ty_path(?path,_)) {\n             print_path(s, path);\n@@ -200,7 +200,7 @@ impure fn print_type(ps s, &@ast.ty ty) {\n     end(s.s);\n }\n \n-impure fn print_item(ps s, @ast.item item) {\n+fn print_item(ps s, @ast.item item) {\n     maybe_print_comment(s, item.span.lo);\n     hbox(s);\n     alt (item.node) {\n@@ -278,7 +278,7 @@ impure fn print_item(ps s, @ast.item item) {\n                 wrd(s.s, v.node.name);\n                 if (_vec.len[ast.variant_arg](v.node.args) > 0u) {\n                     popen(s);\n-                    impure fn print_variant_arg(ps s, &ast.variant_arg arg) {\n+                    fn print_variant_arg(ps s, &ast.variant_arg arg) {\n                         print_type(s, arg.ty);\n                     }\n                     auto f = print_variant_arg;\n@@ -295,7 +295,7 @@ impure fn print_item(ps s, @ast.item item) {\n             wrd(s.s, id);\n             print_type_params(s, params);\n             popen(s);\n-            impure fn print_field(ps s, &ast.obj_field field) {\n+            fn print_field(ps s, &ast.obj_field field) {\n                 hbox(s);\n                 print_type(s, field.ty);\n                 space(s.s);\n@@ -337,7 +337,7 @@ impure fn print_item(ps s, @ast.item item) {\n     line(s.s);\n }\n \n-impure fn print_block(ps s, ast.block blk) {\n+fn print_block(ps s, ast.block blk) {\n     maybe_print_comment(s, blk.span.lo);\n     bopen(s);\n     for (@ast.stmt st in blk.node.stmts) {\n@@ -359,7 +359,7 @@ impure fn print_block(ps s, ast.block blk) {\n     bclose_c(s, blk.span);\n }\n \n-impure fn print_literal(ps s, @ast.lit lit) {\n+fn print_literal(ps s, @ast.lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt (lit.node) {\n         case (ast.lit_str(?st)) {print_string(s, st);}\n@@ -392,7 +392,7 @@ impure fn print_literal(ps s, @ast.lit lit) {\n     }\n }\n \n-impure fn print_expr(ps s, &@ast.expr expr) {\n+fn print_expr(ps s, &@ast.expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n     hbox(s);\n     alt (expr.node) {\n@@ -406,7 +406,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             pclose(s);\n         }\n         case (ast.expr_tup(?exprs,_)) {\n-            impure fn printElt(ps s, &ast.elt elt) {\n+            fn printElt(ps s, &ast.elt elt) {\n                 hbox(s);\n                 if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n                 print_expr(s, elt.expr);\n@@ -421,7 +421,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             pclose(s);\n         }\n         case (ast.expr_rec(?fields,?wth,_)) {\n-            impure fn print_field(ps s, &ast.field field) {\n+            fn print_field(ps s, &ast.field field) {\n                 hbox(s);\n                 if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n                 wrd(s.s, field.ident);\n@@ -460,7 +460,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             print_ident(s, ident);\n         }\n         case (ast.expr_bind(?func,?args,_)) {\n-            impure fn print_opt(ps s, &option.t[@ast.expr] expr) {\n+            fn print_opt(ps s, &option.t[@ast.expr] expr) {\n                 alt (expr) {\n                     case (option.some[@ast.expr](?expr)) {\n                         print_expr(s, expr);\n@@ -685,7 +685,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n     end(s.s);\n }\n \n-impure fn print_decl(ps s, @ast.decl decl) {\n+fn print_decl(ps s, @ast.decl decl) {\n     maybe_print_comment(s, decl.span.lo);\n     hbox(s);\n     alt (decl.node) {\n@@ -724,11 +724,11 @@ impure fn print_decl(ps s, @ast.decl decl) {\n     end(s.s);\n }\n \n-impure fn print_ident(ps s, ast.ident ident) {\n+fn print_ident(ps s, ast.ident ident) {\n     wrd(s.s, ident);\n }\n \n-impure fn print_for_decl(ps s, @ast.decl decl) {\n+fn print_for_decl(ps s, @ast.decl decl) {\n     alt (decl.node) {\n         case (ast.decl_local(?loc)) {\n             print_type(s, option.get[@ast.ty](loc.ty));\n@@ -738,7 +738,7 @@ impure fn print_for_decl(ps s, @ast.decl decl) {\n     }\n }\n \n-impure fn print_path(ps s, ast.path path) {\n+fn print_path(ps s, ast.path path) {\n     maybe_print_comment(s, path.span.lo);\n     auto first = true;\n     for (str id in path.node.idents) {\n@@ -754,7 +754,7 @@ impure fn print_path(ps s, ast.path path) {\n     }\n }\n \n-impure fn print_pat(ps s, &@ast.pat pat) {\n+fn print_pat(ps s, &@ast.pat pat) {\n     maybe_print_comment(s, pat.span.lo);\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {wrd(s.s, \"_\");}\n@@ -772,18 +772,13 @@ impure fn print_pat(ps s, &@ast.pat pat) {\n     }\n }\n \n-impure fn print_fn(ps s, ast.fn_decl decl, str name,\n+fn print_fn(ps s, ast.fn_decl decl, str name,\n                    vec[ast.ty_param] typarams) {\n-    alt (decl.effect) {\n-        case (ast.eff_impure) {wrd1(s, \"impure\");}\n-        case (ast.eff_unsafe) {wrd1(s, \"unsafe\");}\n-        case (_) {}\n-    }\n     wrd1(s, \"fn\");\n     wrd(s.s, name);\n     print_type_params(s, typarams);\n     popen(s);\n-    impure fn print_arg(ps s, &ast.arg x) {\n+    fn print_arg(ps s, &ast.arg x) {\n         hbox(s);\n         if (x.mode == ast.alias) {wrd(s.s, \"&\");}\n         print_type(s, x.ty);\n@@ -804,10 +799,10 @@ impure fn print_fn(ps s, ast.fn_decl decl, str name,\n     }\n }\n \n-impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n+fn print_type_params(ps s, vec[ast.ty_param] params) {\n     if (_vec.len[ast.ty_param](params) > 0u) {\n         wrd(s.s, \"[\");\n-        impure fn printParam(ps s, &ast.ty_param param) {\n+        fn printParam(ps s, &ast.ty_param param) {\n             wrd(s.s, param);\n         }\n         auto f = printParam;\n@@ -816,7 +811,7 @@ impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n     }\n }\n \n-impure fn print_view_item(ps s, @ast.view_item item) {\n+fn print_view_item(ps s, @ast.view_item item) {\n     maybe_print_comment(s, item.span.lo);\n     hbox(s);\n     alt (item.node) {\n@@ -825,7 +820,7 @@ impure fn print_view_item(ps s, @ast.view_item item) {\n             wrd(s.s, id);\n             if (_vec.len[@ast.meta_item](mta) > 0u) {\n                 popen(s);\n-                impure fn print_meta(ps s, &@ast.meta_item item) {\n+                fn print_meta(ps s, &@ast.meta_item item) {\n                     hbox(s);\n                     wrd1(s, item.node.name);\n                     wrd1(s, \"=\");\n@@ -869,7 +864,7 @@ fn operator_prec(ast.binop op) -> int {\n     fail;\n }\n \n-impure fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n+fn print_maybe_parens(ps s, @ast.expr expr, int outer_prec) {\n     auto add_them;\n     alt (expr.node) {\n         case (ast.expr_binary(?op,_,_,_)) {\n@@ -907,7 +902,7 @@ fn escape_str(str st, char to_escape) -> str {\n     ret out;\n }\n \n-impure fn print_mt(ps s, &ast.mt mt) {\n+fn print_mt(ps s, &ast.mt mt) {\n     alt (mt.mut) {\n         case (ast.mut)       { wrd1(s, \"mutable\");  }\n         case (ast.maybe_mut) { wrd1(s, \"mutable?\"); }\n@@ -916,25 +911,20 @@ impure fn print_mt(ps s, &ast.mt mt) {\n     print_type(s, mt.ty);\n }\n \n-impure fn print_string(ps s, str st) {\n+fn print_string(ps s, str st) {\n     wrd(s.s, \"\\\"\"); wrd(s.s, escape_str(st, '\"')); wrd(s.s, \"\\\"\");\n }\n \n-impure fn print_ty_fn(ps s, ast.effect eff, ast.proto proto, option.t[str] id,\n-                      vec[ast.ty_arg] inputs, @ast.ty output) {\n-    alt (eff) {\n-        case (ast.eff_impure) {wrd1(s, \"impure\");}\n-        case (ast.eff_unsafe) {wrd1(s, \"unsafe\");}\n-        case (_) {}\n-    }\n+fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n+               vec[ast.ty_arg] inputs, @ast.ty output) {\n     if (proto == ast.proto_fn) {wrd(s.s, \"fn\");}\n     else {wrd(s.s, \"iter\");}\n     alt (id) {\n         case (option.some[str](?id)) {space(s.s); wrd(s.s, id);}\n         case (_) {}\n     }\n     popen_h(s);\n-    impure fn print_arg(ps s, &ast.ty_arg input) {\n+    fn print_arg(ps s, &ast.ty_arg input) {\n         if (middle.ty.mode_is_alias(input.mode)) {wrd(s.s, \"&\");}\n         print_type(s, input.ty);\n     }\n@@ -962,7 +952,7 @@ fn next_comment(ps s) -> option.t[lexer.cmnt] {\n     }\n }\n \n-impure fn maybe_print_comment(ps s, uint pos) {\n+fn maybe_print_comment(ps s, uint pos) {\n     while (true) {\n         alt (next_comment(s)) {\n             case (option.some[lexer.cmnt](?cmnt)) {\n@@ -977,7 +967,7 @@ impure fn maybe_print_comment(ps s, uint pos) {\n     }\n }\n \n-impure fn maybe_print_line_comment(ps s, common.span span) -> bool {\n+fn maybe_print_line_comment(ps s, common.span span) -> bool {\n     alt (next_comment(s)) {\n         case (option.some[lexer.cmnt](?cmnt)) {\n             if (span.hi + 4u >= cmnt.pos) {\n@@ -992,7 +982,7 @@ impure fn maybe_print_line_comment(ps s, common.span span) -> bool {\n     ret false;\n }\n \n-impure fn print_remaining_comments(ps s) {\n+fn print_remaining_comments(ps s) {\n     while (true) {\n         alt (next_comment(s)) {\n             case (option.some[lexer.cmnt](?cmnt)) {\n@@ -1005,7 +995,7 @@ impure fn print_remaining_comments(ps s) {\n     }\n }\n \n-impure fn print_comment(ps s, lexer.cmnt_ cmnt) {\n+fn print_comment(ps s, lexer.cmnt_ cmnt) {\n     alt (cmnt) {\n         case (lexer.cmnt_line(?val)) {\n             wrd(s.s, \"// \" + val);"}, {"sha": "f580edeaa1441c764b25289873111e8f4f4f9aac", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -45,37 +45,11 @@ mod util {\n     mod typestate_ann;\n }\n \n-auth driver.rustc.main = impure;\n-auth front.creader.parse_ty_str = impure;\n auth front.creader.load_crate = unsafe;\n auth front.creader.get_metadata_section = unsafe;\n-auth front.creader.lookup_def = impure;\n-auth front.creader.get_type = impure;\n-auth front.creader.get_symbol = impure;\n-auth front.creader.get_tag_variants = impure;\n-auth front.creader.impure_no_op = impure;\n auth middle.metadata = unsafe;\n-auth middle.metadata.encode_index = impure;\n-auth middle.metadata.encode_metadata = impure;\n auth middle.trans = unsafe;\n-auth middle.trans.copy_any_self_to_alloca = impure;\n-auth middle.trans.copy_args_to_allocas = impure;\n-auth middle.trans.trans_block = impure;\n-auth middle.trans.alloc_ty = impure;\n-auth middle.typestate_check.log_expr = impure;\n auth lib.llvm = unsafe;\n-auth pretty.pprust = impure;\n-auth middle.typestate_check.find_pre_post_block = impure;\n-auth middle.typestate_check.find_pre_post_state_block = impure;\n-auth middle.typestate_check.find_pre_post_state_stmt = impure;\n-auth middle.typestate_check.find_pre_post_state_expr = impure;\n-auth middle.typestate_check.find_pre_post_state_exprs = impure;\n-auth middle.typestate_check.find_pre_post_expr  = impure;\n-auth middle.typestate_check.find_pre_post_stmt  = impure;\n-auth middle.typestate_check.check_states_against_conditions = impure;\n-auth middle.typestate_check.check_states_stmt   = impure;\n-auth middle.typestate_check.log_stmt            = impure;\n-auth util.typestate_ann.implies = impure;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "b1f12ffbc8755192596ee9baf681e50317995ff9", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -85,20 +85,20 @@ fn pps_len(&pre_and_post p) -> uint {\n   ret p.precondition.nbits;\n }\n \n-impure fn require_and_preserve(uint i, &pre_and_post p) -> () {\n+fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   // sets the ith bit in p's pre and post\n   bitv.set(p.precondition, i, true);\n   bitv.set(p.postcondition, i, true);\n }\n \n-impure fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n+fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n   // sets the ith bit in p's post\n   auto was_set = bitv.get(p.postcondition, i);\n   bitv.set(p.postcondition, i, true);\n   ret !was_set;\n }\n \n-impure fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n+fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n   // sets the ith bit in p's post\n   auto was_set = bitv.get(s.poststate, i);\n   bitv.set(s.poststate, i, true);\n@@ -107,35 +107,35 @@ impure fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n-impure fn set_precondition(&ts_ann a, &precond p) -> () {\n+fn set_precondition(&ts_ann a, &precond p) -> () {\n   bitv.copy(a.conditions.precondition, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-impure fn set_postcondition(&ts_ann a, &postcond p) -> () {\n+fn set_postcondition(&ts_ann a, &postcond p) -> () {\n   bitv.copy(a.conditions.postcondition, p);\n }\n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n-impure fn set_prestate(&ts_ann a, &prestate p) -> bool {\n+fn set_prestate(&ts_ann a, &prestate p) -> bool {\n   ret bitv.copy(a.states.prestate, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-impure fn set_poststate(&ts_ann a, &poststate p) -> bool {\n+fn set_poststate(&ts_ann a, &poststate p) -> bool {\n   ret bitv.copy(a.states.poststate, p);\n }\n \n // Set all the bits in p that are set in new\n-impure fn extend_prestate(&prestate p, &poststate new) -> bool {\n+fn extend_prestate(&prestate p, &poststate new) -> bool {\n   ret bitv.union(p, new);\n }\n \n // Set all the bits in p that are set in new\n-impure fn extend_poststate(&poststate p, &poststate new) -> bool {\n+fn extend_poststate(&poststate p, &poststate new) -> bool {\n   ret bitv.union(p, new);\n }\n \n@@ -150,7 +150,7 @@ fn ann_prestate(&ts_ann a) -> prestate {\n // returns true if a implies b\n // that is, returns true except if for some bits c and d,\n // c = 1 and d = 0\n-impure fn implies(bitv.t a, bitv.t b) -> bool {\n+fn implies(bitv.t a, bitv.t b) -> bool {\n   auto tmp = bitv.clone(b);\n   bitv.difference(tmp, a);\n   ret bitv.is_false(tmp);"}, {"sha": "3922acb6a924854a26a6fda3bbcd15343af8268f", "filename": "src/lib/_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -154,11 +154,11 @@ fn unsafe_from_byte(u8 u) -> str {\n     ret rustrt.str_from_vec(vec(u));\n }\n \n-unsafe fn str_from_cstr(sbuf cstr) -> str {\n+fn str_from_cstr(sbuf cstr) -> str {\n     ret rustrt.str_from_cstr(cstr);\n }\n \n-unsafe fn str_from_buf(sbuf buf, uint len) -> str {\n+fn str_from_buf(sbuf buf, uint len) -> str {\n     ret rustrt.str_from_buf(buf, len);\n }\n "}, {"sha": "6fc1d7008864b87d4d427f0687b0b3f9166b54da", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -51,7 +51,7 @@ fn refcount[T](vec[mutable? T] v) -> uint {\n     }\n }\n \n-unsafe fn vec_from_vbuf[T](vbuf v, uint n_elts) -> vec[T] {\n+fn vec_from_vbuf[T](vbuf v, uint n_elts) -> vec[T] {\n     ret rustrt.vec_from_vbuf[T](v, n_elts);\n }\n "}, {"sha": "feb4296aa6efd09dfec0096af4eb309f28c21284", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -25,7 +25,7 @@ fn create(uint nbits, bool init) -> t {\n     ret rec(storage = storage, nbits = nbits);\n }\n \n-impure fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n+fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n     auto len = _vec.len[mutable uint](v1.storage);\n \n     check (_vec.len[mutable uint](v0.storage) == len);\n@@ -51,7 +51,7 @@ fn lor(uint w0, uint w1) -> uint {\n     ret w0 | w1;\n }\n \n-impure fn union(&t v0, &t v1) -> bool {\n+fn union(&t v0, &t v1) -> bool {\n     auto sub = lor;\n     ret process(sub, v0, v1);\n }\n@@ -60,7 +60,7 @@ fn land(uint w0, uint w1) -> uint {\n     ret w0 & w1;\n }\n \n-impure fn intersect(&t v0, &t v1) -> bool {\n+fn intersect(&t v0, &t v1) -> bool {\n     auto sub = land;\n     ret process(sub, v0, v1);\n }\n@@ -69,7 +69,7 @@ fn right(uint w0, uint w1) -> uint {\n     ret w1;\n }\n \n-impure fn copy(&t v0, t v1) -> bool {\n+fn copy(&t v0, t v1) -> bool {\n     auto sub = right;\n     ret process(sub, v0, v1);\n }\n@@ -108,27 +108,27 @@ fn equal(&t v0, &t v1) -> bool {\n     ret true;\n }\n \n-impure fn clear(&t v) {\n+fn clear(&t v) {\n     for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n \n-impure fn invert(&t v) {\n+fn invert(&t v) {\n     for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n         v.storage.(i) = ~v.storage.(i);\n     }\n }\n \n /* v0 = v0 - v1 */\n-impure fn difference(&t v0, &t v1) -> bool {\n+fn difference(&t v0, &t v1) -> bool {\n     invert(v1);\n     auto b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n-impure fn set(&t v, uint i, bool x) {\n+fn set(&t v, uint i, bool x) {\n     check (i < v.nbits);\n \n     auto bits = uint_bits();"}, {"sha": "774ce11324cbc8c963e593ef7f0f3ec8e01cddec", "filename": "src/lib/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -26,11 +26,11 @@ fn connect(path pre, path post) -> path {\n     ret pre + path_sep() + post;\n }\n \n-impure fn file_is_dir(path p) -> bool {\n+fn file_is_dir(path p) -> bool {\n   ret rustrt.rust_file_is_dir(p) != 0;\n }\n \n-impure fn list_dir(path p) -> vec[str] {\n+fn list_dir(path p) -> vec[str] {\n   auto pl = _str.byte_len(p);\n   if (pl == 0u || p.(pl - 1u) as char != os_fs.path_sep) {\n     p += path_sep();"}, {"sha": "2c2c0dbf5391c46a4f49ed168c7b8eca093125cf", "filename": "src/lib/io.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -14,37 +14,37 @@ tag seek_style {seek_set; seek_end; seek_cur;}\n // The raw underlying reader class. All readers must implement this.\n type buf_reader =\n     state obj {\n-        impure fn read(uint len) -> vec[u8];\n-        impure fn read_byte() -> int;\n-        impure fn unread_byte(int byte);\n-        impure fn eof() -> bool;\n+        fn read(uint len) -> vec[u8];\n+        fn read_byte() -> int;\n+        fn unread_byte(int byte);\n+        fn eof() -> bool;\n \n         // FIXME: Seekable really should be orthogonal. We will need\n         // inheritance.\n-        impure fn seek(int offset, seek_style whence);\n-        impure fn tell() -> uint;\n+        fn seek(int offset, seek_style whence);\n+        fn tell() -> uint;\n     };\n \n // Convenience methods for reading.\n type reader =\n     state obj {\n           // FIXME: This should inherit from buf_reader.\n-          impure fn get_buf_reader() -> buf_reader;\n-\n-          impure fn read_byte() -> int;\n-          impure fn unread_byte(int byte);\n-          impure fn read_bytes(uint len) -> vec[u8];\n-          impure fn read_char() -> char;\n-          impure fn eof() -> bool;\n-          impure fn read_line() -> str;\n-          impure fn read_c_str() -> str;\n-          impure fn read_le_uint(uint size) -> uint;\n-          impure fn read_le_int(uint size) -> int;\n-          impure fn read_be_uint(uint size) -> uint;\n-          impure fn read_whole_stream() -> vec[u8];\n-\n-          impure fn seek(int offset, seek_style whence);\n-          impure fn tell() -> uint; // FIXME: eventually u64\n+          fn get_buf_reader() -> buf_reader;\n+\n+          fn read_byte() -> int;\n+          fn unread_byte(int byte);\n+          fn read_bytes(uint len) -> vec[u8];\n+          fn read_char() -> char;\n+          fn eof() -> bool;\n+          fn read_line() -> str;\n+          fn read_c_str() -> str;\n+          fn read_le_uint(uint size) -> uint;\n+          fn read_le_int(uint size) -> int;\n+          fn read_be_uint(uint size) -> uint;\n+          fn read_whole_stream() -> vec[u8];\n+\n+          fn seek(int offset, seek_style whence);\n+          fn tell() -> uint; // FIXME: eventually u64\n     };\n \n fn convert_whence(seek_style whence) -> int {\n@@ -56,25 +56,25 @@ fn convert_whence(seek_style whence) -> int {\n }\n \n state obj FILE_buf_reader(os.libc.FILE f, bool must_close) {\n-    impure fn read(uint len) -> vec[u8] {\n+    fn read(uint len) -> vec[u8] {\n         auto buf = _vec.alloc[u8](len);\n         auto read = os.libc.fread(_vec.buf[u8](buf), 1u, len, f);\n         _vec.len_set[u8](buf, read);\n         ret buf;\n     }\n-    impure fn read_byte() -> int {\n+    fn read_byte() -> int {\n         ret os.libc.fgetc(f);\n     }\n-    impure fn unread_byte(int byte) {\n+    fn unread_byte(int byte) {\n         os.libc.ungetc(byte, f);\n     }\n-    impure fn eof() -> bool {\n+    fn eof() -> bool {\n         ret os.libc.feof(f) != 0;\n     }\n-    impure fn seek(int offset, seek_style whence) {\n+    fn seek(int offset, seek_style whence) {\n         check (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n-    impure fn tell() -> uint {\n+    fn tell() -> uint {\n         ret os.libc.ftell(f) as uint;\n     }\n     drop {\n@@ -84,19 +84,19 @@ state obj FILE_buf_reader(os.libc.FILE f, bool must_close) {\n \n // FIXME: Convert this into pseudomethods on buf_reader.\n state obj new_reader(buf_reader rdr) {\n-    impure fn get_buf_reader() -> buf_reader {\n+    fn get_buf_reader() -> buf_reader {\n         ret rdr;\n     }\n-    impure fn read_byte() -> int {\n+    fn read_byte() -> int {\n         ret rdr.read_byte();\n     }\n-    impure fn unread_byte(int byte) {\n+    fn unread_byte(int byte) {\n         ret rdr.unread_byte(byte);\n     }\n-    impure fn read_bytes(uint len) -> vec[u8] {\n+    fn read_bytes(uint len) -> vec[u8] {\n         ret rdr.read(len);\n     }\n-    impure fn read_char() -> char {\n+    fn read_char() -> char {\n         auto c0 = rdr.read_byte();\n         if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n         auto b0 = c0 as u8;\n@@ -116,10 +116,10 @@ state obj new_reader(buf_reader rdr) {\n         val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n         ret val as char;\n     }\n-    impure fn eof() -> bool {\n+    fn eof() -> bool {\n         ret rdr.eof();\n     }\n-    impure fn read_line() -> str {\n+    fn read_line() -> str {\n         let vec[u8] buf = vec();\n         // No break yet in rustc\n         auto go_on = true;\n@@ -130,7 +130,7 @@ state obj new_reader(buf_reader rdr) {\n         }\n         ret _str.unsafe_from_bytes(buf);\n     }\n-    impure fn read_c_str() -> str {\n+    fn read_c_str() -> str {\n         let vec[u8] buf = vec();\n         auto go_on = true;\n         while (go_on) {\n@@ -141,7 +141,7 @@ state obj new_reader(buf_reader rdr) {\n         ret _str.unsafe_from_bytes(buf);\n     }\n     // FIXME deal with eof?\n-    impure fn read_le_uint(uint size) -> uint {\n+    fn read_le_uint(uint size) -> uint {\n         auto val = 0u;\n         auto pos = 0u;\n         while (size > 0u) {\n@@ -151,7 +151,7 @@ state obj new_reader(buf_reader rdr) {\n         }\n         ret val;\n     }\n-    impure fn read_le_int(uint size) -> int {\n+    fn read_le_int(uint size) -> int {\n         auto val = 0u;\n         auto pos = 0u;\n         while (size > 0u) {\n@@ -162,7 +162,7 @@ state obj new_reader(buf_reader rdr) {\n         ret val as int;\n     }\n     // FIXME deal with eof?\n-    impure fn read_be_uint(uint size) -> uint {\n+    fn read_be_uint(uint size) -> uint {\n         auto val = 0u;\n         auto sz = size; // FIXME: trans.ml bug workaround\n         while (sz > 0u) {\n@@ -171,17 +171,17 @@ state obj new_reader(buf_reader rdr) {\n         }\n         ret val;\n     }\n-    impure fn read_whole_stream() -> vec[u8] {\n+    fn read_whole_stream() -> vec[u8] {\n         let vec[u8] buf = vec();\n         while (!rdr.eof()) {\n             buf += rdr.read(2048u);\n         }\n         ret buf;\n     }\n-    impure fn seek(int offset, seek_style whence) {\n+    fn seek(int offset, seek_style whence) {\n         ret rdr.seek(offset, whence);\n     }\n-    impure fn tell() -> uint {\n+    fn tell() -> uint {\n         ret rdr.tell();\n     }\n }\n@@ -211,7 +211,7 @@ fn new_reader_(buf_reader bufr) -> reader {\n type byte_buf = @rec(vec[u8] buf, mutable uint pos);\n \n state obj byte_buf_reader(byte_buf bbuf) {\n-    impure fn read(uint len) -> vec[u8] {\n+    fn read(uint len) -> vec[u8] {\n         auto rest = _vec.len[u8](bbuf.buf) - bbuf.pos;\n         auto to_read = len;\n         if (rest < to_read) {\n@@ -221,29 +221,29 @@ state obj byte_buf_reader(byte_buf bbuf) {\n         bbuf.pos += to_read;\n         ret range;\n     }\n-    impure fn read_byte() -> int {\n+    fn read_byte() -> int {\n         if (bbuf.pos == _vec.len[u8](bbuf.buf)) {ret -1;}\n         auto b = bbuf.buf.(bbuf.pos);\n         bbuf.pos += 1u;\n         ret b as int;\n     }\n \n-    impure fn unread_byte(int byte) {\n+    fn unread_byte(int byte) {\n         log_err \"TODO: unread_byte\";\n         fail;\n     }\n \n-    impure fn eof() -> bool {\n+    fn eof() -> bool {\n         ret bbuf.pos == _vec.len[u8](bbuf.buf);\n     }\n \n-    impure fn seek(int offset, seek_style whence) {\n+    fn seek(int offset, seek_style whence) {\n         auto pos = bbuf.pos;\n         auto len = _vec.len[u8](bbuf.buf);\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n-    impure fn tell() -> uint { ret bbuf.pos; }\n+    fn tell() -> uint { ret bbuf.pos; }\n }\n \n fn new_byte_buf_reader(vec[u8] buf) -> byte_buf_reader {\n@@ -355,14 +355,14 @@ type writer =\n           fn get_buf_writer() -> buf_writer;\n           // write_str will continue to do utf-8 output only. an alternative\n           // function will be provided for general encoded string output\n-          impure fn write_str(str s);\n-          impure fn write_char(char ch);\n-          impure fn write_int(int n);\n-          impure fn write_uint(uint n);\n-          impure fn write_bytes(vec[u8] bytes);\n-          impure fn write_le_uint(uint n, uint size);\n-          impure fn write_le_int(int n, uint size);\n-          impure fn write_be_uint(uint n, uint size);\n+          fn write_str(str s);\n+          fn write_char(char ch);\n+          fn write_int(int n);\n+          fn write_uint(uint n);\n+          fn write_bytes(vec[u8] bytes);\n+          fn write_le_uint(uint n, uint size);\n+          fn write_le_int(int n, uint size);\n+          fn write_be_uint(uint n, uint size);\n     };\n \n fn uint_to_le_bytes(uint n, uint size) -> vec[u8] {\n@@ -389,29 +389,29 @@ state obj new_writer(buf_writer out) {\n     fn get_buf_writer() -> buf_writer {\n         ret out;\n     }\n-    impure fn write_str(str s) {\n+    fn write_str(str s) {\n         out.write(_str.bytes(s));\n     }\n-    impure fn write_char(char ch) {\n+    fn write_char(char ch) {\n         // FIXME needlessly consy\n         out.write(_str.bytes(_str.from_char(ch)));\n     }\n-    impure fn write_int(int n) {\n+    fn write_int(int n) {\n         out.write(_str.bytes(_int.to_str(n, 10u)));\n     }\n-    impure fn write_uint(uint n) {\n+    fn write_uint(uint n) {\n         out.write(_str.bytes(_uint.to_str(n, 10u)));\n     }\n-    impure fn write_bytes(vec[u8] bytes) {\n+    fn write_bytes(vec[u8] bytes) {\n         out.write(bytes);\n     }\n-    impure fn write_le_uint(uint n, uint size) {\n+    fn write_le_uint(uint n, uint size) {\n         out.write(uint_to_le_bytes(n, size));\n     }\n-    impure fn write_le_int(int n, uint size) {\n+    fn write_le_int(int n, uint size) {\n         out.write(uint_to_le_bytes(n as uint, size));\n     }\n-    impure fn write_be_uint(uint n, uint size) {\n+    fn write_be_uint(uint n, uint size) {\n         out.write(uint_to_be_bytes(n, size));\n     }\n }"}, {"sha": "91d0a56a9ccff64d09988c02cfa9878237ee2f46", "filename": "src/lib/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -64,7 +64,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n      * We attempt to never call this with a full table.  If we do, it\n      * will fail.\n      */\n-    impure fn insert_common[K, V](&hashfn[K] hasher,\n+    fn insert_common[K, V](&hashfn[K] hasher,\n                                   &eqfn[K] eqer,\n                                   vec[mutable bucket[K, V]] bkts,\n                                   uint nbkts,\n@@ -119,7 +119,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n         }\n \n \n-   impure fn rehash[K, V](&hashfn[K] hasher,\n+   fn rehash[K, V](&hashfn[K] hasher,\n                           &eqfn[K] eqer,\n                           vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n                           vec[mutable bucket[K, V]] newbkts, uint nnewbkts)"}, {"sha": "03115fc7d331b67b94e2eb3e8c47aaae9156c0c3", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,7 +2,7 @@ native \"rust\" mod rustrt {\n   fn rust_dirent_filename(os.libc.dirent ent) -> str;\n }\n \n-impure fn list_dir(str path) -> vec[str] {\n+fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n   auto dir = os.libc.opendir(_str.buf(path));\n   check (dir as uint != 0u);"}, {"sha": "31758984f9ebffa928813b68d322f16855e8c85d", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -14,7 +14,7 @@ fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n     ret argptrs;\n }\n \n-impure fn run_program(str prog, vec[str] args) -> int {\n+fn run_program(str prog, vec[str] args) -> int {\n     auto pid = rustrt.rust_run_program(_vec.buf[sbuf](argvec(prog, args)),\n                                        0, 0, 0);\n     ret os.waitpid(pid);\n@@ -25,11 +25,11 @@ type program =\n         fn get_id() -> int;\n         fn input() -> io.writer;\n         fn output() -> io.reader;\n-        impure fn close_input();\n-        impure fn finish() -> int;\n+        fn close_input();\n+        fn finish() -> int;\n     };\n \n-impure fn start_program(str prog, vec[str] args) -> @program {\n+fn start_program(str prog, vec[str] args) -> @program {\n     auto pipe_input = os.pipe();\n     auto pipe_output = os.pipe();\n     auto pid = rustrt.rust_run_program\n@@ -50,10 +50,10 @@ impure fn start_program(str prog, vec[str] args) -> @program {\n         fn output() -> io.reader {\n             ret io.new_reader(io.FILE_buf_reader(out_file, false));\n         }\n-        impure fn close_input() {\n+        fn close_input() {\n             os.libc.close(in_fd);\n         }\n-        impure fn finish() -> int {\n+        fn finish() -> int {\n             if (finished) {ret 0;}\n             finished = true;\n             os.libc.close(in_fd);\n@@ -72,7 +72,7 @@ impure fn start_program(str prog, vec[str] args) -> @program {\n                      false);\n }\n \n-impure fn program_output(str prog, vec[str] args)\n+fn program_output(str prog, vec[str] args)\n     -> rec(int status, str out) {\n     auto pr = start_program(prog, args);\n     pr.close_input();"}, {"sha": "3866be1e04cfeb7d52b0b61fa25f650c7bb00af1", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -41,7 +41,7 @@ fn mk_sha1() -> sha1 {\n                                mutable uint msg_block_idx,\n                                mutable bool computed);\n \n-    impure fn add_input(&sha1state st, &vec[u8] msg) {\n+    fn add_input(&sha1state st, &vec[u8] msg) {\n         // FIXME: Should be typestate precondition\n         check (!st.computed);\n \n@@ -64,7 +64,7 @@ fn mk_sha1() -> sha1 {\n         }\n     }\n \n-    impure fn process_msg_block(&sha1state st) {\n+    fn process_msg_block(&sha1state st) {\n \n         // FIXME: Make precondition\n         check (_vec.len[mutable u32](st.h) == digest_buf_len);\n@@ -164,7 +164,7 @@ fn mk_sha1() -> sha1 {\n         ret (word << bits_hack) | (word >> (32u32 - bits));\n     }\n \n-    impure fn mk_result(&sha1state st) -> vec[u8] {\n+    fn mk_result(&sha1state st) -> vec[u8] {\n         if (!st.computed) {\n             pad_msg(st);\n             st.computed = true;\n@@ -190,7 +190,7 @@ fn mk_sha1() -> sha1 {\n      * call process_msg_block() appropriately.  When it returns, it\n      * can be assumed that the message digest has been computed.\n      */\n-    impure fn pad_msg(&sha1state st) {\n+    fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n         check (_vec.len[mutable u8](st.msg_block) == msg_block_len);\n "}, {"sha": "7e9e06c2ac9850bc9a857833b4659f2798078952", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -34,21 +34,6 @@ auth _str = unsafe;\n auth _vec = unsafe;\n auth _task = unsafe;\n \n-\n-// FIXME: impure on these will infect caller in a way that is totally\n-// beyond reason, if the caller's mutated-argument doesn't escape;\n-// 'impure' needs work.\n-auth _str.unshift_byte = impure;\n-auth _str.shift_byte = impure;\n-auth _str.pop_byte = impure;\n-auth _str.unshift_char = impure;\n-auth _str.shift_char = impure;\n-auth _str.pop_char = impure;\n-auth _vec.shift = impure;\n-auth _vec.unshift = impure;\n-auth _vec.pop = impure;\n-auth UFind.union = impure;\n-\n auth dbg = unsafe;\n \n auth _uint.next_power_of_two = unsafe;"}, {"sha": "2d0ea38c603168de795f61c674bcbf4be12754ba", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -3,7 +3,7 @@ native \"rust\" mod rustrt {\n   fn rust_file_is_dir(str path) -> int;\n }\n \n-impure fn list_dir(str path) -> vec[str] {\n+fn list_dir(str path) -> vec[str] {\n   ret rustrt.rust_list_files(path+\"*\");\n }\n "}, {"sha": "57a7d4260ccd4e044ce29e2d5d1914f4a0f1f08d", "filename": "src/test/bench/shootout/fannkuchredux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -6,7 +6,7 @@ use std;\n import std._int;\n import std._vec;\n \n-impure fn fannkuch(int n) -> int {\n+fn fannkuch(int n) -> int {\n \n   fn perm1init(uint i) -> mutable int {\n     ret i as int;\n@@ -94,7 +94,7 @@ impure fn fannkuch(int n) -> int {\n   ret flips;\n }\n \n-impure fn main(vec[str] args) {\n+fn main(vec[str] args) {\n   auto n = 7;\n   log #fmt(\"Pfannkuchen(%d) = %d\", n, fannkuch(n));\n }\n\\ No newline at end of file"}, {"sha": "f2041c0e33ddd7e10058c0e40211105793e74bd7", "filename": "src/test/bench/shootout/nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -218,7 +218,7 @@ mod Body {\n            );\n    }\n \n-   impure fn offsetMomentum(&Body.props props,\n+   fn offsetMomentum(&Body.props props,\n                             float px, \n                             float py, \n                             float pz) -> () {"}, {"sha": "17a651cad7a67f40c2afd409874b4c4575263916", "filename": "src/test/compile-fail/impure-pred.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=d9d5eb82a7af56c60fe09aff5d73a2fb525d7f57", "patch": "@@ -1,21 +0,0 @@\n-// xfail-stage0\n-// -*- rust -*-\n-\n-// error-pattern: impure function used in constraint\n-\n-fn f(int a, int b) : lt(a,b) {\n-}\n-\n-impure fn lt(int a, int b) -> bool {\n-  let port[int] p = port();\n-  let chan[int] c = chan(p);\n-  c <| 10;\n-  ret true;\n-}\n-\n-fn main() {\n-  let int a = 10;\n-  let int b = 23;\n-  check lt(a,b);\n-  f(a,b);\n-}"}, {"sha": "7def7c11d0a221d2f7618170518d9d63189bdac5", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -7,7 +7,7 @@ fn child() {\n   check (1 == 2);\n }\n \n-impure fn main() {\n+fn main() {\n   let port[int] p = port();\n   spawn child();\n   let int x;"}, {"sha": "3f3b108cb67972f3c2d8b09beffcd2d39fbf72d5", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn f(chan[int] c)\n+fn f(chan[int] c)\n {\n   type t = tup(int,int,int);\n \n@@ -24,7 +24,7 @@ impure fn f(chan[int] c)\n }\n \n \n-impure fn main() {\n+fn main() {\n   let port[int] p = port();\n   spawn f(chan(p));\n   let int i;"}, {"sha": "d861e45d3323bcfe405f04a4164a20f5d26a3851", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,11 +1,11 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn a(chan[int] c) {\n+fn a(chan[int] c) {\n     c <| 10;\n }\n \n-impure fn main() {\n+fn main() {\n     let port[int] p = port();\n     spawn a(chan(p));\n     spawn b(chan(p));\n@@ -15,7 +15,7 @@ impure fn main() {\n //    log \"Finished.\";\n }\n \n-impure fn b(chan[int] c) {\n+fn b(chan[int] c) {\n //    log \"task b0\";\n //    log \"task b1\";\n //    log \"task b2\";"}, {"sha": "5bd9e823315af351b345de72fd173f26babf1dcc", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,13 +1,13 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn a(chan[int] c) {\n+fn a(chan[int] c) {\n     log \"task a0\";\n     log \"task a1\";\n     c <| 10;\n }\n \n-impure fn main() {\n+fn main() {\n     let port[int] p = port();\n     spawn a(chan(p));\n     spawn b(chan(p));\n@@ -17,7 +17,7 @@ impure fn main() {\n     log \"Finished.\";\n }\n \n-impure fn b(chan[int] c) {\n+fn b(chan[int] c) {\n     log \"task b0\";\n     log \"task b1\";\n     log \"task b2\";"}, {"sha": "e538d4f203bc957d27811f302274da756659910f", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn a(chan[int] c) {\n+fn a(chan[int] c) {\n   if (true) {\n     log \"task a\";\n     log \"task a\";\n@@ -23,7 +23,7 @@ fn g(int x, str y) -> int {\n   ret z;\n }\n \n-impure fn main() {\n+fn main() {\n     let int n = 2 + 3 * 7;\n     let str s = \"hello there\";\n     let port[int] p = port();\n@@ -38,7 +38,7 @@ impure fn main() {\n     log \"children finished, root finishing\";\n }\n \n-impure fn b(chan[int] c) {\n+fn b(chan[int] c) {\n   if (true) {\n     log \"task b\";\n     log \"task b\";"}, {"sha": "53f3dc0ffa23c7fdaae3b64b6150db67d4bb25fe", "filename": "src/test/run-pass/box-in-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,4 +1,4 @@\n-impure fn main() {\n+fn main() {\n   let tup(mutable @int) i = tup(mutable @10);\n   i._0 = @11;\n }\n\\ No newline at end of file"}, {"sha": "2bca62488dc933a5b2e4a7df1a14b40f7368d8a8", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn main() {\n+fn main() {\n   let port[int] p = port();\n   spawn child(chan(p));\n   let int y;\n@@ -11,7 +11,7 @@ impure fn main() {\n   check (y == 10);\n }\n \n-impure fn child(chan[int] c) {\n+fn child(chan[int] c) {\n   c <| 10;\n }\n "}, {"sha": "5630d2e278dd91c07988f879ea959e0d5c68ddb2", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-impure fn main() {\n+fn main() {\n   let port[int] po = port();\n   let chan[int] ch = chan(po);\n "}, {"sha": "ff76f9e6192318e7eb371df05fc1b8e780fa00b5", "filename": "src/test/run-pass/deref-lval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-lval.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,4 +1,4 @@\n-impure fn main() {\n+fn main() {\n     auto x = @mutable 5;\n     *x = 1000;\n     log *x;"}, {"sha": "f09ee8234e35dc235453871881756758ba7a243d", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,13 +2,13 @@\n \n type point = rec(int x, int y, mutable int z);\n \n-impure fn f(@point p) {\n+fn f(@point p) {\n   check (p.z == 12);\n   p.z = 13;\n   check (p.z == 13);\n }\n \n-impure fn main() {\n+fn main() {\n   let point a = rec(x=10, y=11, mutable z=12);\n   let @point b = @a;\n   check (b.z == 12);"}, {"sha": "d25405d8c6e57090832600402cb9f61e462b8034", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -13,7 +13,7 @@ iter range(int start, int stop) -> int {\n     }\n }\n \n-impure fn main() {\n+fn main() {\n     let vec[mutable int] a =\n       vec(mutable -1, -1, -1, -1, -1, -1, -1, -1);\n     let int p = 0;"}, {"sha": "a655f59101988944da2bcd039a9546410859f730", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -5,7 +5,7 @@ iter two() -> int {\n     put 1;\n }\n \n-impure fn main() {\n+fn main() {\n     let vec[mutable int] a = vec(mutable -1, -1, -1, -1);\n     let int p = 0;\n "}, {"sha": "6face271eed222ed11d8d71fa6275974dfb00fd0", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn main() {\n+fn main() {\n   let port[int] p = port();\n   auto c = chan(p);\n   let int y;\n@@ -19,6 +19,6 @@ impure fn main() {\n   check (y == 10);\n }\n \n-impure fn child(chan[int] c) {\n+fn child(chan[int] c) {\n   c <| 10;\n }"}, {"sha": "5ff790799d83d712201f63a6e746ff7cfa0dad0f", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -23,7 +23,7 @@ fn test_1_element() {\n   check (bitv.eq_vec(act, vec(1u)));\n }\n \n-impure fn test_10_elements() {\n+fn test_10_elements() {\n   auto act;\n \n   // all 0\n@@ -61,7 +61,7 @@ impure fn test_10_elements() {\n   check (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n }\n \n-impure fn test_31_elements() {\n+fn test_31_elements() {\n   auto act;\n \n   // all 0\n@@ -133,7 +133,7 @@ impure fn test_31_elements() {\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n }\n \n-impure fn test_32_elements() {\n+fn test_32_elements() {\n   auto act;\n \n   // all 0\n@@ -207,7 +207,7 @@ impure fn test_32_elements() {\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n }\n \n-impure fn test_33_elements() {\n+fn test_33_elements() {\n   auto act;\n \n   // all 0\n@@ -288,7 +288,7 @@ impure fn test_33_elements() {\n                               1u)));\n }\n \n-impure fn main() {\n+fn main() {\n   test_0_elements();\n   test_1_element();\n   test_10_elements();"}, {"sha": "f83ab4fb6a328f1037a7a067e9b198d06103fa73", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage0\n // -*- rust -*-\n \n-impure fn sub(chan[int] parent, int id) {\n+fn sub(chan[int] parent, int id) {\n   if (id == 0) {\n     parent <| 0;\n   } else {\n@@ -13,7 +13,7 @@ impure fn sub(chan[int] parent, int id) {\n   }\n }\n \n-impure fn main() {\n+fn main() {\n   let port[int] p = port();\n   auto child = spawn sub(chan(p), 500);\n   let int y <- p;"}, {"sha": "86dbd403d5075f6896569e4e1adcad8080fa1d38", "filename": "src/test/run-pass/native-mod-src/inner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-unsafe fn main() {\n+fn main() {\n    auto f = \"Makefile\";\n    auto s = rustrt.str_buf(f);\n    auto buf = libc.malloc(1024);"}, {"sha": "2a5966c8acd294511f230e941b3a7caae6a1e5e9", "filename": "src/test/run-pass/native-src/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n \n-unsafe fn main() {\n+fn main() {\n   libc.puts(rustrt.str_buf(\"hello, native world 1\"));\n   libc.puts(rustrt.str_buf(\"hello, native world 2\"));\n   libc.puts(rustrt.str_buf(\"hello, native world 3\"));"}, {"sha": "3d633e725eb92b4bab6dccc3e4b9279433af5ebf", "filename": "src/test/run-pass/obj-dtor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -6,7 +6,7 @@ obj worker(chan[int] c) {\n   }\n }\n \n-impure fn do_work(chan[int] c) {\n+fn do_work(chan[int] c) {\n   log \"in child task\";\n   {\n     let worker w = worker(c);\n@@ -21,7 +21,7 @@ impure fn do_work(chan[int] c) {\n   }\n }\n \n-impure fn main() {\n+fn main() {\n   let port[int] p = port();\n   log \"spawning worker\";\n   auto w = spawn do_work(chan(p));"}, {"sha": "9668ce42c32420a43d78aba0c5652425d5835511", "filename": "src/test/run-pass/obj-self-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fobj-self-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fobj-self-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-2.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,11 +2,11 @@\n fn main() {\n \n   obj foo() {\n-      impure fn m1(mutable int i) {\n+      fn m1(mutable int i) {\n           i += 1;\n           log \"hi!\";\n       }\n-      impure fn m2(mutable int i) {\n+      fn m2(mutable int i) {\n           i += 1;\n           self.m1(i);\n       }"}, {"sha": "f777b56c15a1551eda841711cbc98394d1fe6685", "filename": "src/test/run-pass/obj-self-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-3.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,14 +2,14 @@\n fn main() {\n \n   obj foo() {\n-      impure fn m1(mutable int i) -> int {\n+      fn m1(mutable int i) -> int {\n           i += 1;\n           ret i;\n       }\n-      impure fn m2(mutable int i) -> int {\n+      fn m2(mutable int i) -> int {\n           ret self.m1(i);\n       }\n-      impure fn m3(mutable int i) -> int {\n+      fn m3(mutable int i) -> int {\n           i += 1;\n           ret self.m1(i);\n       }"}, {"sha": "cbbe1a0a1e30a879d214c49bf961d70f2c3b1946", "filename": "src/test/run-pass/preempt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fpreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fpreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpreempt.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // This checks that preemption works.\n \n-impure fn starve_main(chan[int] alive) {\n+fn starve_main(chan[int] alive) {\n   log \"signalling main\";\n   alive <| 1;\n   log \"starving main\";\n@@ -11,7 +11,7 @@ impure fn starve_main(chan[int] alive) {\n   }\n }\n \n-impure fn main() {\n+fn main() {\n   let port[int] alive = port();\n   log \"main started\";\n   let task s = spawn starve_main(chan(alive));"}, {"sha": "364e38eab450bf7148e2c23d934814cb8271a892", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -17,7 +17,7 @@ type record = rec(u32 val1, u32 val2, u32 val3);\n // then the minimum buffer size needs to be 96. That's not a\n // power of two so needs to be rounded up. Don't trigger any\n // assertions.\n-impure fn test_init() {\n+fn test_init() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n@@ -28,7 +28,7 @@ impure fn test_init() {\n \n // Dump lots of items into the channel so it has to grow.\n // Don't trigger any assertions.\n-impure fn test_grow() {\n+fn test_grow() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n@@ -40,15 +40,15 @@ impure fn test_grow() {\n }\n \n // Don't allow the buffer to shrink below it's original size\n-impure fn test_shrink1() {\n+fn test_shrink1() {\n     let port[i8] myport = port();\n     auto mychan = chan(myport);\n \n     mychan <| 0i8;\n     auto x <- myport;\n }\n \n-impure fn test_shrink2() {\n+fn test_shrink2() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n@@ -64,7 +64,7 @@ impure fn test_shrink2() {\n }\n \n // Test rotating the buffer when the unit size is not a power of two\n-impure fn test_rotate() {\n+fn test_rotate() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n@@ -83,7 +83,7 @@ impure fn test_rotate() {\n \n // Test rotating and growing the buffer when\n // the unit size is not a power of two\n-impure fn test_rotate_grow() {\n+fn test_rotate_grow() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n@@ -104,7 +104,7 @@ impure fn test_rotate_grow() {\n     }\n }\n \n-impure fn main() {\n+fn main() {\n     test_init();\n     test_grow();\n     test_shrink1();"}, {"sha": "e1473548122c9132e800823afbdb9609dc627bb3", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,15 +1,15 @@\n // xfail-stage0\n-impure fn main() -> () {\n+fn main() -> () {\n     test05();\n }\n \n-impure fn test05_start(chan[int] ch) {\n+fn test05_start(chan[int] ch) {\n     ch <| 10;\n     ch <| 20;\n     ch <| 30;\n }\n \n-impure fn test05() {\n+fn test05() {\n     let port[int] po = port();\n     let chan[int] ch = chan(po);\n     spawn test05_start(chan(po));"}, {"sha": "3c504ea751e33ae6d776f339cb651faefddf5033", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,13 +1,13 @@\n // xfail-boot\n // xfail-stage0\n-impure fn start(chan[chan[str]] c) {\n+fn start(chan[chan[str]] c) {\n     let port[str] p = port();\n     c <| chan(p);\n     auto a <- p;\n     // auto b <- p; // Never read the second string.\n }\n \n-impure fn main() {\n+fn main() {\n     let port[chan[str]] p = port();\n     auto child = spawn \"start\" start(chan(p));\n     auto c <- p;"}, {"sha": "239e7933a4fe45e7858e227b34f4e56af14ec5ef", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,10 +1,10 @@\n // xfail-stage0\n-impure fn start(chan[chan[str]] c) {\n+fn start(chan[chan[str]] c) {\n     let port[str] p = port();\n     c <| chan(p);\n }\n \n-impure fn main() {\n+fn main() {\n     let port[chan[str]] p = port();\n     auto child = spawn \"child\" start(chan(p));\n     auto c <- p;"}, {"sha": "1ad8ac7aa014964989f24000b71645fdedca8582", "filename": "src/test/run-pass/task-comm-13-thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13-thread.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std._task;\n \n-impure fn start(chan[int] c, int start, int number_of_messages) {\n+fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;"}, {"sha": "ee612ca0bbc5df288aa518b857e6f137ee8e94b0", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,7 +2,7 @@\n use std;\n import std._task;\n \n-impure fn start(chan[int] c, int start, int number_of_messages) {\n+fn start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;"}, {"sha": "197c600536eafd9dad5847c8763a89ad41eb4bba", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,6 +1,6 @@\n // xfail-boot\n // xfail-stage0\n-impure fn start(chan[int] c, int n) {\n+fn start(chan[int] c, int n) {\n     let int i = n;\n \n     while(i > 0) {\n@@ -9,7 +9,7 @@ impure fn start(chan[int] c, int n) {\n     }\n }\n \n-impure fn main() {\n+fn main() {\n     let port[int] p = port();\n     // Spawn a task that sends us back messages. The parent task\n     // is likely to terminate before the child completes, so from"}, {"sha": "16c4b93b8db58790cff85b419f8f2e0633f88efd", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,7 +2,7 @@\n \n // Tests of ports and channels on various types\n \n-impure fn test_rec() {\n+fn test_rec() {\n   type r = rec(int val0, u8 val1, char val2);\n \n   let port[r] po = port();\n@@ -19,7 +19,7 @@ impure fn test_rec() {\n   check (r1.val2 == '2');\n }\n \n-impure fn test_vec() {\n+fn test_vec() {\n   let port[vec[int]] po = port();\n   let chan[vec[int]] ch = chan(po);\n   let vec[int] v0 = vec(0, 1, 2);\n@@ -34,7 +34,7 @@ impure fn test_vec() {\n   check (v1.(2) == 2);\n }\n \n-impure fn test_str() {\n+fn test_str() {\n   let port[str] po = port();\n   let chan[str] ch = chan(po);\n   let str s0 = \"test\";\n@@ -50,7 +50,7 @@ impure fn test_str() {\n   check (s1.(3) as u8 == 't' as u8);\n }\n \n-impure fn test_tup() {\n+fn test_tup() {\n   type t = tup(int, u8, char);\n \n   let port[t] po = port();\n@@ -67,7 +67,7 @@ impure fn test_tup() {\n   check (t0._2 == '2');\n }\n \n-impure fn test_tag() {\n+fn test_tag() {\n   tag t {\n     tag1;\n     tag2(int);\n@@ -91,7 +91,7 @@ impure fn test_tag() {\n   check (t1 == tag3(10, 11u8, 'A'));\n }\n \n-impure fn test_chan() {\n+fn test_chan() {\n   let port[chan[int]] po = port();\n   let chan[chan[int]] ch = chan(po);\n \n@@ -112,7 +112,7 @@ impure fn test_chan() {\n   check (i == 10);\n }\n \n-impure fn main() {\n+fn main() {\n   test_rec();\n   test_vec();\n   test_str();"}, {"sha": "712557212c1ff0d64dd05aee64c7bfc1ab011fd2", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,13 +1,13 @@\n // xfail-boot\n // xfail-stage0\n-impure fn main() -> () {\n+fn main() -> () {\n    log \"===== WITHOUT THREADS =====\";\n    test00(false);\n    log \"====== WITH THREADS ======\";\n    test00(true);\n }\n \n-impure fn test00_start(chan[int] ch, int message, int count) {\n+fn test00_start(chan[int] ch, int message, int count) {\n     log \"Starting test00_start\";\n     let int i = 0;\n     while (i < count) {\n@@ -18,7 +18,7 @@ impure fn test00_start(chan[int] ch, int message, int count) {\n     log \"Ending test00_start\";\n }\n \n-impure fn test00(bool is_multithreaded) {\n+fn test00(bool is_multithreaded) {\n     let int number_of_tasks = 16;\n     let int number_of_messages = 4;\n     "}, {"sha": "121a9e6e1345cf2c7591feef9f597c3527d72ca7", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,8 +1,8 @@\n-impure fn main() -> () {\n+fn main() -> () {\n    test00();\n }\n \n-impure fn test00() {\n+fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "d0f3994effb2db3ecd5db2fa72b43e07a913a994", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,8 +1,8 @@\n-impure fn main() -> () {\n+fn main() -> () {\n    test00();\n }\n \n-impure fn test00() {\n+fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "74b40a9098af86df6b28b6da5a9412fe4a4df6f5", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,8 +1,8 @@\n-impure fn main() -> () {\n+fn main() -> () {\n    test00();\n }\n \n-impure fn test00() {\n+fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "b5b95db9605f2b2f380b93411bdbd9be5075c88c", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,17 +1,17 @@\n // xfail-stage0\n-impure fn main() -> () {\n+fn main() -> () {\n    test00();\n }\n \n-impure fn test00_start(chan[int] c, int start, int number_of_messages) {\n+fn test00_start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n     }    \n }\n \n-impure fn test00() {\n+fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "a3876bdae5ab52781d84851120b0ed7bee548386", "filename": "src/test/run-pass/task-comm-8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,18 +1,18 @@\n // xfail-boot\n // xfail-stage0\n-impure fn main() -> () {\n+fn main() -> () {\n    test00();\n }\n \n-impure fn test00_start(chan[int] c, int start, int number_of_messages) {\n+fn test00_start(chan[int] c, int start, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| start + i;\n         i += 1;\n     }    \n }\n \n-impure fn test00() {\n+fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "a9ac1688cd25b4a6b15c43181d7850e1524150bb", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,18 +1,18 @@\n // xfail-boot\n // xfail-stage0\n-impure fn main() -> () {\n+fn main() -> () {\n    test00();\n }\n \n-impure fn test00_start(chan[int] c, int number_of_messages) {\n+fn test00_start(chan[int] c, int number_of_messages) {\n     let int i = 0;\n     while (i < number_of_messages) {\n         c <| i;\n         i += 1;\n     }    \n }\n \n-impure fn test00() {\n+fn test00() {\n     let int r = 0;    \n     let int sum = 0;\n     let port[int] p = port();"}, {"sha": "aae788a5128c49450db5518162f9b746d7a56558", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -5,7 +5,7 @@\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n \n-impure fn main() {\n+fn main() {\n   let port[()] po = port();\n   let chan[()] ch = chan(po);\n "}, {"sha": "0a91b98abdf8ed1a4230cfb3f86b6ae2ea79426c", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,7 +1,7 @@\n // xfail-boot\n // xfail-stage0\n \n-impure fn main() -> () {\n+fn main() -> () {\n     test00(true);\n     // test01();\n     test02();\n@@ -11,7 +11,7 @@ impure fn main() -> () {\n     test06();\n }\n \n-impure fn test00_start(chan[int] ch, int message, int count) {\n+fn test00_start(chan[int] ch, int message, int count) {\n     log \"Starting test00_start\";\n     let int i = 0;\n     while (i < count) {\n@@ -22,7 +22,7 @@ impure fn test00_start(chan[int] ch, int message, int count) {\n     log \"Ending test00_start\";\n }\n \n-impure fn test00(bool is_multithreaded) {\n+fn test00(bool is_multithreaded) {\n     let int number_of_tasks = 1;\n     let int number_of_messages = 4;\n     log \"Creating tasks\";\n@@ -62,14 +62,14 @@ impure fn test00(bool is_multithreaded) {\n            (number_of_tasks * number_of_tasks + number_of_tasks) / 2);\n }\n \n-impure fn test01() {\n+fn test01() {\n     let port[int] p = port();\n     log \"Reading from a port that is never written to.\";\n     let int value <- p;\n     log value;\n }\n \n-impure fn test02() {\n+fn test02() {\n     let port[int] p = port();\n     let chan[int] c = chan(p);\n     log \"Writing to a local task channel.\";\n@@ -113,15 +113,15 @@ fn test04() {\n     log \"Finishing up.\";\n }\n \n-impure fn test05_start(chan[int] ch) {\n+fn test05_start(chan[int] ch) {\n     ch <| 10;\n     ch <| 20;\n     ch <| 30;\n     ch <| 30;\n     ch <| 30;    \n }\n \n-impure fn test05() {\n+fn test05() {\n     let port[int] po = port();\n     let chan[int] ch = chan(po);\n     spawn thread test05_start(ch);"}, {"sha": "415554dd374f3d9334b94080646bb85a726b631c", "filename": "src/test/run-pass/vec-in-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -1,4 +1,4 @@\n-impure fn main() {\n+fn main() {\n   let tup(mutable vec[int]) i = tup(mutable vec(1,2,3));\n   i._0 = vec(4,5,6);\n }"}, {"sha": "8bf8140f315805566e42599cbe3c3a4f3960d9df", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2bd07dcb02783063375b6c8532fceaf9fa9d50f/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=d2bd07dcb02783063375b6c8532fceaf9fa9d50f", "patch": "@@ -2,11 +2,11 @@\n \n type point = rec(int x, int y, mutable int z);\n \n-impure fn f(& mutable point p) {\n+fn f(& mutable point p) {\n   p.z = 13;\n }\n \n-impure fn main() {\n+fn main() {\n   let point x = rec(x=10, y=11, mutable z=12);\n   f(x);\n   check (x.z == 13);"}]}