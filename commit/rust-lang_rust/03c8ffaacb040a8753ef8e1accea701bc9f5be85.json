{"sha": "03c8ffaacb040a8753ef8e1accea701bc9f5be85", "node_id": "C_kwDOAAsO6NoAKDAzYzhmZmFhY2IwNDBhODc1M2VmOGUxYWNjZWE3MDFiYzlmNWJlODU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T08:40:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T08:40:34Z"}, "message": "Auto merge of #94350 - matthiaskrgr:rollup-eesfiyr, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #92714 (Provide ignore message in the result of test)\n - #93273 (Always check cg_llvm with ./x.py check)\n - #94068 (Consider mutations as borrows in generator drop tracking)\n - #94184 (BTree: simplify test code)\n - #94297 (update const_generics_defaults release notes)\n - #94341 (Remove a duplicate space)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "243ffcf7568eceb6515c48a28f5d78b8a3a05038", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/243ffcf7568eceb6515c48a28f5d78b8a3a05038"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03c8ffaacb040a8753ef8e1accea701bc9f5be85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03c8ffaacb040a8753ef8e1accea701bc9f5be85", "html_url": "https://github.com/rust-lang/rust/commit/03c8ffaacb040a8753ef8e1accea701bc9f5be85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03c8ffaacb040a8753ef8e1accea701bc9f5be85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ece55d416e65256e4da274988651c20e5d5cb4ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/ece55d416e65256e4da274988651c20e5d5cb4ea", "html_url": "https://github.com/rust-lang/rust/commit/ece55d416e65256e4da274988651c20e5d5cb4ea"}, {"sha": "cff3472ef1d21ca2ed5be4c8f6444df3967c61a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff3472ef1d21ca2ed5be4c8f6444df3967c61a8", "html_url": "https://github.com/rust-lang/rust/commit/cff3472ef1d21ca2ed5be4c8f6444df3967c61a8"}], "stats": {"total": 502, "additions": 354, "deletions": 148}, "files": [{"sha": "b96eb18cf86d8ed973a795c10885a87e6f0bdc28", "filename": "RELEASES.md", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -4,7 +4,7 @@ Version 1.59.0 (2022-02-24)\n Language\n --------\n \n-- [Stabilize default arguments for const generics][90207]\n+- [Stabilize default arguments for const parameters and remove the ordering restriction for type and const parameters][90207]\n - [Stabilize destructuring assignment][90521]\n - [Relax private in public lint on generic bounds and where clauses of trait impls][90586]\n - [Stabilize asm! and global_asm! for x86, x86_64, ARM, Aarch64, and RISC-V][91728]\n@@ -18,6 +18,21 @@ Compiler\n - [Warn when a `#[test]`-like built-in attribute macro is present multiple times.][91172]\n - [Add support for riscv64gc-unknown-freebsd][91284]\n - [Stabilize `-Z emit-future-incompat` as `--json future-incompat`][91535]\n+- [Soft disable incremental compilation][94124]\n+\n+This release disables incremental compilation, unless the user has explicitly\n+opted in via the newly added RUSTC_FORCE_INCREMENTAL=1 environment variable.\n+This is due to a known and relatively frequently occurring bug in incremental\n+compilation, which causes builds to issue internal compiler errors. This\n+particular bug is already fixed on nightly, but that fix has not yet rolled out\n+to stable and is deemed too risky for a direct stable backport.\n+\n+As always, we encourage users to test with nightly and report bugs so that we\n+can track failures and fix issues earlier.\n+\n+See [94124] for more details.\n+\n+[94124]: https://github.com/rust-lang/rust/issues/94124\n \n Libraries\n ---------\n@@ -86,6 +101,7 @@ Compatibility Notes\n - [Weaken guarantee around advancing underlying iterators in zip][83791]\n - [Make split_inclusive() on an empty slice yield an empty output][89825]\n - [Update std::env::temp_dir to use GetTempPath2 on Windows when available.][89999]\n+- [unreachable! was updated to match other formatting macro behavior on Rust 2021][92137]\n \n Internal Changes\n ----------------\n@@ -127,6 +143,7 @@ and related tools.\n [91984]: https://github.com/rust-lang/rust/pull/91984/\n [92020]: https://github.com/rust-lang/rust/pull/92020/\n [92034]: https://github.com/rust-lang/rust/pull/92034/\n+[92137]: https://github.com/rust-lang/rust/pull/92137/\n [92483]: https://github.com/rust-lang/rust/pull/92483/\n [cargo/10088]: https://github.com/rust-lang/cargo/pull/10088/\n [cargo/10133]: https://github.com/rust-lang/cargo/pull/10133/"}, {"sha": "e658631d09038ee22ec243927e53074810f4c970", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -262,6 +262,15 @@ pub fn expand_test_or_bench(\n                                         \"ignore\",\n                                         cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n                                     ),\n+                                    // ignore_message: Some(\"...\") | None\n+                                    field(\n+                                        \"ignore_message\",\n+                                        if let Some(msg) = should_ignore_message(cx, &item) {\n+                                            cx.expr_some(sp, cx.expr_str(sp, msg))\n+                                        } else {\n+                                            cx.expr_none(sp)\n+                                        },\n+                                    ),\n                                     // compile_fail: true | false\n                                     field(\"compile_fail\", cx.expr_bool(sp, false)),\n                                     // no_run: true | false\n@@ -364,6 +373,20 @@ fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n     sess.contains_name(&i.attrs, sym::ignore)\n }\n \n+fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n+    match cx.sess.find_by_name(&i.attrs, sym::ignore) {\n+        Some(attr) => {\n+            match attr.meta_item_list() {\n+                // Handle #[ignore(bar = \"foo\")]\n+                Some(_) => None,\n+                // Handle #[ignore] and #[ignore = \"message\"]\n+                None => attr.value_str(),\n+            }\n+        }\n+        None => None,\n+    }\n+}\n+\n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n     match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {"}, {"sha": "b8ed75cb6bb74750074cd93c925b8e4f7c5851c5", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -329,6 +329,10 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, some, vec![expr])\n     }\n \n+    pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n+        let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n+        self.expr_path(self.path_global(sp, none))\n+    }\n     pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }"}, {"sha": "8cad4fc707ea3a7488e8f3ba9ec5386c5f82bc7a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -633,7 +633,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n             .collect::<Result<Vec<_>, _>>();\n \n-        let Ok(where_predicates) =  where_predicates else { return };\n+        let Ok(where_predicates) = where_predicates else { return };\n \n         // now get all predicates in the same types as the where bounds, so we can chain them\n         let predicates_from_where ="}, {"sha": "03d3b23bb23d5cc35d4f6ab5e048bd338c401ef2", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -93,19 +93,25 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n     fn borrow(\n         &mut self,\n         place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: HirId,\n+        diag_expr_id: HirId,\n         _bk: rustc_middle::ty::BorrowKind,\n     ) {\n+        debug!(\"borrow {:?}; diag_expr_id={:?}\", place_with_id, diag_expr_id);\n         self.places\n             .borrowed\n             .insert(TrackedValue::from_place_with_projections_allowed(place_with_id));\n     }\n \n     fn mutate(\n         &mut self,\n-        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: HirId,\n+        assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: HirId,\n     ) {\n+        debug!(\"mutate {:?}; diag_expr_id={:?}\", assignee_place, diag_expr_id);\n+        // Count mutations as a borrow.\n+        self.places\n+            .borrowed\n+            .insert(TrackedValue::from_place_with_projections_allowed(assignee_place));\n     }\n \n     fn fake_read("}, {"sha": "65468d5fe57166222a53de3fb2ce0efce3dc64ec", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 89, "deletions": 108, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -17,14 +17,10 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n-// Capacity of a tree with a single level,\n-// i.e., a tree who's root is a leaf node at height 0.\n-const NODE_CAPACITY: usize = node::CAPACITY;\n-\n // Minimum number of elements to insert, to guarantee a tree with 2 levels,\n // i.e., a tree who's root is an internal node at height 1, with edges to leaf nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n-const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n+const MIN_INSERTS_HEIGHT_1: usize = node::CAPACITY + 1;\n \n // Minimum number of elements to insert in ascending order, to guarantee a tree with 3 levels,\n // i.e., a tree who's root is an internal node at height 2, with edges to more internal nodes.\n@@ -180,7 +176,7 @@ fn test_levels() {\n #[should_panic]\n fn test_check_ord_chaos() {\n     let gov = Governor::new();\n-    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    let map = BTreeMap::from([(Governed(1, &gov), ()), (Governed(2, &gov), ())]);\n     gov.flip();\n     map.check();\n }\n@@ -189,7 +185,7 @@ fn test_check_ord_chaos() {\n #[test]\n fn test_check_invariants_ord_chaos() {\n     let gov = Governor::new();\n-    let map: BTreeMap<_, _> = (0..2).map(|i| (Governed(i, &gov), ())).collect();\n+    let map = BTreeMap::from([(Governed(1, &gov), ()), (Governed(2, &gov), ())]);\n     gov.flip();\n     map.check_invariants();\n }\n@@ -337,8 +333,7 @@ fn test_basic_small() {\n fn test_iter() {\n     // Miri is too slow\n     let size = if cfg!(miri) { 200 } else { 10000 };\n-\n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test<T>(size: usize, mut iter: T)\n     where\n@@ -360,8 +355,7 @@ fn test_iter() {\n fn test_iter_rev() {\n     // Miri is too slow\n     let size = if cfg!(miri) { 200 } else { 10000 };\n-\n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test<T>(size: usize, mut iter: T)\n     where\n@@ -386,7 +380,7 @@ where\n     <T as TryFrom<usize>>::Error: Debug,\n {\n     let zero = T::try_from(0).unwrap();\n-    let mut map: BTreeMap<T, T> = (0..size).map(|i| (T::try_from(i).unwrap(), zero)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (T::try_from(i).unwrap(), zero)));\n \n     // Forward and backward iteration sees enough pairs (also tested elsewhere)\n     assert_eq!(map.iter_mut().count(), size);\n@@ -452,7 +446,7 @@ fn test_iter_mut_mutation() {\n \n #[test]\n fn test_values_mut() {\n-    let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    let mut a = BTreeMap::from_iter((0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)));\n     test_all_refs(&mut 13, a.values_mut());\n     a.check();\n }\n@@ -467,14 +461,14 @@ fn test_values_mut_mutation() {\n         value.push_str(\"!\");\n     }\n \n-    let values: Vec<String> = a.values().cloned().collect();\n+    let values = Vec::from_iter(a.values().cloned());\n     assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n     a.check();\n }\n \n #[test]\n fn test_iter_entering_root_twice() {\n-    let mut map: BTreeMap<_, _> = (0..2).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from([(0, 0), (1, 1)]);\n     let mut it = map.iter_mut();\n     let front = it.next().unwrap();\n     let back = it.next_back().unwrap();\n@@ -491,7 +485,7 @@ fn test_iter_entering_root_twice() {\n \n #[test]\n fn test_iter_descending_to_same_node_twice() {\n-    let mut map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i)));\n     let mut it = map.iter_mut();\n     // Descend into first child.\n     let front = it.next().unwrap();\n@@ -509,7 +503,7 @@ fn test_iter_mixed() {\n     // Miri is too slow\n     let size = if cfg!(miri) { 200 } else { 10000 };\n \n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test<T>(size: usize, mut iter: T)\n     where\n@@ -569,21 +563,19 @@ fn test_iter_min_max() {\n }\n \n fn range_keys(map: &BTreeMap<i32, i32>, range: impl RangeBounds<i32>) -> Vec<i32> {\n-    map.range(range)\n-        .map(|(&k, &v)| {\n-            assert_eq!(k, v);\n-            k\n-        })\n-        .collect()\n+    Vec::from_iter(map.range(range).map(|(&k, &v)| {\n+        assert_eq!(k, v);\n+        k\n+    }))\n }\n \n #[test]\n fn test_range_small() {\n     let size = 4;\n \n-    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n-    let all: Vec<_> = (1..=size).collect();\n+    let all = Vec::from_iter(1..=size);\n     let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+    let map = BTreeMap::from_iter(all.iter().copied().map(|i| (i, i)));\n \n     assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n     assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n@@ -638,10 +630,9 @@ fn test_range_small() {\n \n #[test]\n fn test_range_height_1() {\n-    // Tests tree with a root and 2 leaves. The single key in the root node is\n-    // close to the middle among the keys.\n-\n-    let map: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n+    // Tests tree with a root and 2 leaves. We test around the middle of the\n+    // keys because one of those is the single key in the root node.\n+    let map = BTreeMap::from_iter((0..MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)));\n     let middle = MIN_INSERTS_HEIGHT_1 as i32 / 2;\n     for root in middle - 2..=middle + 2 {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n@@ -660,9 +651,9 @@ fn test_range_height_1() {\n fn test_range_large() {\n     let size = 200;\n \n-    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n-    let all: Vec<_> = (1..=size).collect();\n+    let all = Vec::from_iter(1..=size);\n     let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+    let map = BTreeMap::from_iter(all.iter().copied().map(|i| (i, i)));\n \n     assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n     assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n@@ -715,9 +706,7 @@ fn test_range_large() {\n         L: IntoIterator<Item = (&'a i32, &'a i32)>,\n         R: IntoIterator<Item = (&'a i32, &'a i32)>,\n     {\n-        let lhs: Vec<_> = lhs.into_iter().collect();\n-        let rhs: Vec<_> = rhs.into_iter().collect();\n-        assert_eq!(lhs, rhs);\n+        assert_eq!(Vec::from_iter(lhs), Vec::from_iter(rhs));\n     }\n \n     check(map.range(..=100), map.range(..101));\n@@ -728,50 +717,49 @@ fn test_range_large() {\n #[test]\n fn test_range_inclusive_max_value() {\n     let max = usize::MAX;\n-    let map: BTreeMap<_, _> = [(max, 0)].into_iter().collect();\n-\n-    assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);\n+    let map = BTreeMap::from([(max, 0)]);\n+    assert_eq!(Vec::from_iter(map.range(max..=max)), &[(&max, &0)]);\n }\n \n #[test]\n fn test_range_equal_empty_cases() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     assert_eq!(map.range((Included(2), Excluded(2))).next(), None);\n     assert_eq!(map.range((Excluded(2), Included(2))).next(), None);\n }\n \n #[test]\n #[should_panic]\n fn test_range_equal_excluded() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_1() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_2() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_3() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n fn test_range_backwards_4() {\n-    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..5).map(|i| (i, i)));\n     let _ = map.range((Excluded(3), Excluded(2)));\n }\n \n@@ -823,15 +811,15 @@ fn test_range_finding_ill_order_in_range_ord() {\n         }\n     }\n \n-    let map = (0..12).map(|i| (CompositeKey(i, EvilTwin(i)), ())).collect::<BTreeMap<_, _>>();\n+    let map = BTreeMap::from_iter((0..12).map(|i| (CompositeKey(i, EvilTwin(i)), ())));\n     let _ = map.range(EvilTwin(5)..=EvilTwin(7));\n }\n \n #[test]\n fn test_range_1000() {\n     // Miri is too slow\n     let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 as u32 } else { 1000 };\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n         let mut kvs = map.range((min, max)).map(|(&k, &v)| (k, v));\n@@ -870,7 +858,7 @@ fn test_range() {\n     let size = 200;\n     // Miri is too slow\n     let step = if cfg!(miri) { 66 } else { 1 };\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     for i in (0..size).step_by(step) {\n         for j in (i..size).step_by(step) {\n@@ -891,7 +879,7 @@ fn test_range_mut() {\n     let size = 200;\n     // Miri is too slow\n     let step = if cfg!(miri) { 66 } else { 1 };\n-    let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    let mut map = BTreeMap::from_iter((0..size).map(|i| (i, i)));\n \n     for i in (0..size).step_by(step) {\n         for j in (i..size).step_by(step) {\n@@ -910,7 +898,7 @@ fn test_range_mut() {\n \n #[test]\n fn test_retain() {\n-    let mut map: BTreeMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n+    let mut map = BTreeMap::from_iter((0..100).map(|x| (x, x * 10)));\n \n     map.retain(|&k, _| k % 2 == 0);\n     assert_eq!(map.len(), 50);\n@@ -934,7 +922,7 @@ mod test_drain_filter {\n     #[test]\n     fn consumed_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n@@ -943,7 +931,7 @@ mod test_drain_filter {\n     #[test]\n     fn consumed_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        let mut map = BTreeMap::from_iter(pairs.clone());\n         assert!(map.drain_filter(|_, _| true).eq(pairs));\n         assert!(map.is_empty());\n         map.check();\n@@ -953,7 +941,7 @@ mod test_drain_filter {\n     #[test]\n     fn mutating_and_keeping() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         assert!(\n             map.drain_filter(|_, v| {\n                 *v += 6;\n@@ -970,7 +958,7 @@ mod test_drain_filter {\n     #[test]\n     fn mutating_and_removing() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         assert!(\n             map.drain_filter(|_, v| {\n                 *v += 6;\n@@ -985,7 +973,7 @@ mod test_drain_filter {\n     #[test]\n     fn underfull_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| false);\n         assert!(map.keys().copied().eq(0..3));\n         map.check();\n@@ -995,7 +983,7 @@ mod test_drain_filter {\n     fn underfull_removing_one() {\n         let pairs = (0..3).map(|i| (i, i));\n         for doomed in 0..3 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), 2);\n             map.check();\n@@ -1006,7 +994,7 @@ mod test_drain_filter {\n     fn underfull_keeping_one() {\n         let pairs = (0..3).map(|i| (i, i));\n         for sacred in 0..3 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1016,37 +1004,37 @@ mod test_drain_filter {\n     #[test]\n     fn underfull_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n     }\n \n     #[test]\n     fn height_0_keeping_all() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| false);\n-        assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+        assert!(map.keys().copied().eq(0..node::CAPACITY));\n         map.check();\n     }\n \n     #[test]\n     fn height_0_removing_one() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        for doomed in 0..NODE_CAPACITY {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        for doomed in 0..node::CAPACITY {\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n-            assert_eq!(map.len(), NODE_CAPACITY - 1);\n+            assert_eq!(map.len(), node::CAPACITY - 1);\n             map.check();\n         }\n     }\n \n     #[test]\n     fn height_0_keeping_one() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        for sacred in 0..NODE_CAPACITY {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        for sacred in 0..node::CAPACITY {\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1055,16 +1043,16 @@ mod test_drain_filter {\n \n     #[test]\n     fn height_0_removing_all() {\n-        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let pairs = (0..node::CAPACITY).map(|i| (i, i));\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n     }\n \n     #[test]\n     fn height_0_keeping_half() {\n-        let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n+        let mut map = BTreeMap::from_iter((0..16).map(|i| (i, i)));\n         assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n         assert_eq!(map.len(), 8);\n         map.check();\n@@ -1073,7 +1061,7 @@ mod test_drain_filter {\n     #[test]\n     fn height_1_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n@@ -1083,7 +1071,7 @@ mod test_drain_filter {\n     fn height_1_removing_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n             map.check();\n@@ -1094,7 +1082,7 @@ mod test_drain_filter {\n     fn height_1_keeping_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1105,7 +1093,7 @@ mod test_drain_filter {\n     fn height_2_removing_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n             map.check();\n@@ -1116,7 +1104,7 @@ mod test_drain_filter {\n     fn height_2_keeping_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n-            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            let mut map = BTreeMap::from_iter(pairs.clone());\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n@@ -1126,7 +1114,7 @@ mod test_drain_filter {\n     #[test]\n     fn height_2_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n-        let mut map: BTreeMap<_, _> = pairs.collect();\n+        let mut map = BTreeMap::from_iter(pairs);\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n         map.check();\n@@ -1287,7 +1275,7 @@ fn test_borrow() {\n fn test_entry() {\n     let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-    let mut map: BTreeMap<_, _> = xs.iter().cloned().collect();\n+    let mut map = BTreeMap::from(xs);\n \n     // Existing key (insert)\n     match map.entry(1) {\n@@ -1415,7 +1403,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clear() {\n     let mut map = BTreeMap::new();\n-    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, NODE_CAPACITY] {\n+    for &len in &[MIN_INSERTS_HEIGHT_1, MIN_INSERTS_HEIGHT_2, 0, node::CAPACITY] {\n         for i in 0..len {\n             map.insert(i, ());\n         }\n@@ -1485,7 +1473,7 @@ fn test_clone() {\n     }\n \n     // Test a tree with 2 semi-full levels and a tree with 3 levels.\n-    map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    map = BTreeMap::from_iter((1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)));\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n     assert_eq!(map, map.clone());\n     map.insert(0, 0);\n@@ -1496,14 +1484,11 @@ fn test_clone() {\n \n fn test_clone_panic_leak(size: usize) {\n     for i in 0..size {\n-        let dummies: Vec<CrashTestDummy> = (0..size).map(|id| CrashTestDummy::new(id)).collect();\n-        let map: BTreeMap<_, ()> = dummies\n-            .iter()\n-            .map(|dummy| {\n-                let panic = if dummy.id == i { Panic::InClone } else { Panic::Never };\n-                (dummy.spawn(panic), ())\n-            })\n-            .collect();\n+        let dummies = Vec::from_iter((0..size).map(|id| CrashTestDummy::new(id)));\n+        let map = BTreeMap::from_iter(dummies.iter().map(|dummy| {\n+            let panic = if dummy.id == i { Panic::InClone } else { Panic::Never };\n+            (dummy.spawn(panic), ())\n+        }));\n \n         catch_unwind(|| map.clone()).unwrap_err();\n         for d in &dummies {\n@@ -1864,24 +1849,24 @@ fn test_first_last_entry() {\n \n #[test]\n fn test_insert_into_full_height_0() {\n-    let size = NODE_CAPACITY;\n+    let size = node::CAPACITY;\n     for pos in 0..=size {\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i * 2 + 1, ())).collect();\n+        let mut map = BTreeMap::from_iter((0..size).map(|i| (i * 2 + 1, ())));\n         assert!(map.insert(pos * 2, ()).is_none());\n         map.check();\n     }\n }\n \n #[test]\n fn test_insert_into_full_height_1() {\n-    let size = NODE_CAPACITY + 1 + NODE_CAPACITY;\n+    let size = node::CAPACITY + 1 + node::CAPACITY;\n     for pos in 0..=size {\n-        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i * 2 + 1, ())).collect();\n+        let mut map = BTreeMap::from_iter((0..size).map(|i| (i * 2 + 1, ())));\n         map.compact();\n         let root_node = map.root.as_ref().unwrap().reborrow();\n         assert_eq!(root_node.len(), 1);\n-        assert_eq!(root_node.first_leaf_edge().into_node().len(), NODE_CAPACITY);\n-        assert_eq!(root_node.last_leaf_edge().into_node().len(), NODE_CAPACITY);\n+        assert_eq!(root_node.first_leaf_edge().into_node().len(), node::CAPACITY);\n+        assert_eq!(root_node.last_leaf_edge().into_node().len(), node::CAPACITY);\n \n         assert!(map.insert(pos * 2, ()).is_none());\n         map.check();\n@@ -2022,7 +2007,7 @@ fn test_split_off_empty_left() {\n #[test]\n fn test_split_off_tiny_left_height_2() {\n     let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n-    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let mut left = BTreeMap::from_iter(pairs.clone());\n     let right = left.split_off(&1);\n     left.check();\n     right.check();\n@@ -2038,7 +2023,7 @@ fn test_split_off_tiny_left_height_2() {\n fn test_split_off_tiny_right_height_2() {\n     let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n     let last = MIN_INSERTS_HEIGHT_2 - 1;\n-    let mut left: BTreeMap<_, _> = pairs.clone().collect();\n+    let mut left = BTreeMap::from_iter(pairs.clone());\n     assert_eq!(*left.last_key_value().unwrap().0, last);\n     let right = left.split_off(&last);\n     left.check();\n@@ -2052,7 +2037,7 @@ fn test_split_off_tiny_right_height_2() {\n #[test]\n fn test_split_off_halfway() {\n     let mut rng = DeterministicRng::new();\n-    for &len in &[NODE_CAPACITY, 25, 50, 75, 100] {\n+    for &len in &[node::CAPACITY, 25, 50, 75, 100] {\n         let mut data = Vec::from_iter((0..len).map(|_| (rng.next(), ())));\n         // Insertion in non-ascending order creates some variation in node length.\n         let mut map = BTreeMap::from_iter(data.iter().copied());\n@@ -2112,13 +2097,11 @@ fn test_into_iter_drop_leak_height_0() {\n fn test_into_iter_drop_leak_height_1() {\n     let size = MIN_INSERTS_HEIGHT_1;\n     for panic_point in vec![0, 1, size - 2, size - 1] {\n-        let dummies: Vec<_> = (0..size).map(|i| CrashTestDummy::new(i)).collect();\n-        let map: BTreeMap<_, _> = (0..size)\n-            .map(|i| {\n-                let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n-                (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n-            })\n-            .collect();\n+        let dummies = Vec::from_iter((0..size).map(|i| CrashTestDummy::new(i)));\n+        let map = BTreeMap::from_iter((0..size).map(|i| {\n+            let panic = if i == panic_point { Panic::InDrop } else { Panic::Never };\n+            (dummies[i].spawn(Panic::Never), dummies[i].spawn(panic))\n+        }));\n         catch_unwind(move || drop(map.into_iter())).unwrap_err();\n         for i in 0..size {\n             assert_eq!(dummies[i].dropped(), 2);\n@@ -2128,9 +2111,8 @@ fn test_into_iter_drop_leak_height_1() {\n \n #[test]\n fn test_into_keys() {\n-    let vec = [(1, 'a'), (2, 'b'), (3, 'c')];\n-    let map: BTreeMap<_, _> = vec.into_iter().collect();\n-    let keys: Vec<_> = map.into_keys().collect();\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let keys = Vec::from_iter(map.into_keys());\n \n     assert_eq!(keys.len(), 3);\n     assert!(keys.contains(&1));\n@@ -2140,9 +2122,8 @@ fn test_into_keys() {\n \n #[test]\n fn test_into_values() {\n-    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-    let map: BTreeMap<_, _> = vec.into_iter().collect();\n-    let values: Vec<_> = map.into_values().collect();\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+    let values = Vec::from_iter(map.into_values());\n \n     assert_eq!(values.len(), 3);\n     assert!(values.contains(&'a'));"}, {"sha": "3031bf86a7be154a3030a42860bc04adab929344", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -1539,7 +1539,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_len, b_len) = self.0.lens();\n         // No checked_add, because even if a and b refer to the same set,\n-        // and T is an empty type, the storage overhead of sets limits\n+        // and T is a zero-sized type, the storage overhead of sets limits\n         // the number of elements to less than half the range of usize.\n         (0, Some(a_len + b_len))\n     }"}, {"sha": "7865d37ae51f1cde0a29e538d1496c980e3c4d24", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -91,7 +91,7 @@ fn test_intersection() {\n         return;\n     }\n \n-    let large = (0..100).collect::<Vec<_>>();\n+    let large = Vec::from_iter(0..100);\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n     check_intersection(&[-1], &large, &[]);\n@@ -107,8 +107,8 @@ fn test_intersection() {\n \n #[test]\n fn test_intersection_size_hint() {\n-    let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n-    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let x = BTreeSet::from([3, 4]);\n+    let y = BTreeSet::from([1, 2, 3]);\n     let mut iter = x.intersection(&y);\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n     assert_eq!(iter.next(), Some(&3));\n@@ -145,7 +145,7 @@ fn test_difference() {\n         return;\n     }\n \n-    let large = (0..100).collect::<Vec<_>>();\n+    let large = Vec::from_iter(0..100);\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n     check_difference(&[0], &large, &[]);\n@@ -159,43 +159,43 @@ fn test_difference() {\n \n #[test]\n fn test_difference_size_hint() {\n-    let s246: BTreeSet<i32> = [2, 4, 6].iter().copied().collect();\n-    let s23456: BTreeSet<i32> = (2..=6).collect();\n+    let s246 = BTreeSet::from([2, 4, 6]);\n+    let s23456 = BTreeSet::from_iter(2..=6);\n     let mut iter = s246.difference(&s23456);\n     assert_eq!(iter.size_hint(), (0, Some(3)));\n     assert_eq!(iter.next(), None);\n \n-    let s12345: BTreeSet<i32> = (1..=5).collect();\n+    let s12345 = BTreeSet::from_iter(1..=5);\n     iter = s246.difference(&s12345);\n     assert_eq!(iter.size_hint(), (0, Some(3)));\n     assert_eq!(iter.next(), Some(&6));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n \n-    let s34567: BTreeSet<i32> = (3..=7).collect();\n+    let s34567 = BTreeSet::from_iter(3..=7);\n     iter = s246.difference(&s34567);\n     assert_eq!(iter.size_hint(), (0, Some(3)));\n     assert_eq!(iter.next(), Some(&2));\n     assert_eq!(iter.size_hint(), (0, Some(2)));\n     assert_eq!(iter.next(), None);\n \n-    let s1: BTreeSet<i32> = (-9..=1).collect();\n+    let s1 = BTreeSet::from_iter(-9..=1);\n     iter = s246.difference(&s1);\n     assert_eq!(iter.size_hint(), (3, Some(3)));\n \n-    let s2: BTreeSet<i32> = (-9..=2).collect();\n+    let s2 = BTreeSet::from_iter(-9..=2);\n     iter = s246.difference(&s2);\n     assert_eq!(iter.size_hint(), (2, Some(2)));\n     assert_eq!(iter.next(), Some(&4));\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n \n-    let s23: BTreeSet<i32> = (2..=3).collect();\n+    let s23 = BTreeSet::from([2, 3]);\n     iter = s246.difference(&s23);\n     assert_eq!(iter.size_hint(), (1, Some(3)));\n     assert_eq!(iter.next(), Some(&4));\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n \n-    let s4: BTreeSet<i32> = (4..=4).collect();\n+    let s4 = BTreeSet::from([4]);\n     iter = s246.difference(&s4);\n     assert_eq!(iter.size_hint(), (2, Some(3)));\n     assert_eq!(iter.next(), Some(&2));\n@@ -204,19 +204,19 @@ fn test_difference_size_hint() {\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n \n-    let s56: BTreeSet<i32> = (5..=6).collect();\n+    let s56 = BTreeSet::from([5, 6]);\n     iter = s246.difference(&s56);\n     assert_eq!(iter.size_hint(), (1, Some(3)));\n     assert_eq!(iter.next(), Some(&2));\n     assert_eq!(iter.size_hint(), (0, Some(2)));\n \n-    let s6: BTreeSet<i32> = (6..=19).collect();\n+    let s6 = BTreeSet::from_iter(6..=19);\n     iter = s246.difference(&s6);\n     assert_eq!(iter.size_hint(), (2, Some(2)));\n     assert_eq!(iter.next(), Some(&2));\n     assert_eq!(iter.size_hint(), (1, Some(1)));\n \n-    let s7: BTreeSet<i32> = (7..=19).collect();\n+    let s7 = BTreeSet::from_iter(7..=19);\n     iter = s246.difference(&s7);\n     assert_eq!(iter.size_hint(), (3, Some(3)));\n }\n@@ -235,8 +235,8 @@ fn test_symmetric_difference() {\n \n #[test]\n fn test_symmetric_difference_size_hint() {\n-    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n-    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let x = BTreeSet::from([2, 4]);\n+    let y = BTreeSet::from([1, 2, 3]);\n     let mut iter = x.symmetric_difference(&y);\n     assert_eq!(iter.size_hint(), (0, Some(5)));\n     assert_eq!(iter.next(), Some(&1));\n@@ -263,8 +263,8 @@ fn test_union() {\n \n #[test]\n fn test_union_size_hint() {\n-    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n-    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let x = BTreeSet::from([2, 4]);\n+    let y = BTreeSet::from([1, 2, 3]);\n     let mut iter = x.union(&y);\n     assert_eq!(iter.size_hint(), (3, Some(5)));\n     assert_eq!(iter.next(), Some(&1));\n@@ -276,17 +276,17 @@ fn test_union_size_hint() {\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n-    let one = [1].iter().collect::<BTreeSet<_>>();\n-    let two = [2].iter().collect::<BTreeSet<_>>();\n+    let one = BTreeSet::from([1]);\n+    let two = BTreeSet::from([2]);\n     assert!(one.is_disjoint(&two));\n }\n \n #[test]\n // Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n-        let set_a = a.iter().collect::<BTreeSet<_>>();\n-        let set_b = b.iter().collect::<BTreeSet<_>>();\n+        let set_a = BTreeSet::from_iter(a.iter());\n+        let set_b = BTreeSet::from_iter(b.iter());\n         set_a.is_subset(&set_b)\n     }\n \n@@ -310,7 +310,7 @@ fn test_is_subset() {\n         return;\n     }\n \n-    let large = (0..100).collect::<Vec<_>>();\n+    let large = Vec::from_iter(0..100);\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n     assert_eq!(is_subset(&[-1], &large), false);\n@@ -321,8 +321,7 @@ fn test_is_subset() {\n \n #[test]\n fn test_retain() {\n-    let xs = [1, 2, 3, 4, 5, 6];\n-    let mut set: BTreeSet<i32> = xs.iter().cloned().collect();\n+    let mut set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n     set.retain(|&k| k % 2 == 0);\n     assert_eq!(set.len(), 3);\n     assert!(set.contains(&2));\n@@ -332,8 +331,8 @@ fn test_retain() {\n \n #[test]\n fn test_drain_filter() {\n-    let mut x: BTreeSet<_> = [1].iter().copied().collect();\n-    let mut y: BTreeSet<_> = [1].iter().copied().collect();\n+    let mut x = BTreeSet::from([1]);\n+    let mut y = BTreeSet::from([1]);\n \n     x.drain_filter(|_| true);\n     y.drain_filter(|_| false);\n@@ -417,7 +416,7 @@ fn test_zip() {\n fn test_from_iter() {\n     let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-    let set: BTreeSet<_> = xs.iter().cloned().collect();\n+    let set = BTreeSet::from_iter(xs.iter());\n \n     for x in &xs {\n         assert!(set.contains(x));"}, {"sha": "22fcd77dccc52a5f32a5a1d51a09fd2cfa3995e6", "filename": "library/test/src/console.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -103,17 +103,32 @@ impl ConsoleTestState {\n         exec_time: Option<&TestExecTime>,\n     ) -> io::Result<()> {\n         self.write_log(|| {\n+            let TestDesc {\n+                name,\n+                #[cfg(not(bootstrap))]\n+                ignore_message,\n+                ..\n+            } = test;\n             format!(\n                 \"{} {}\",\n                 match *result {\n                     TestResult::TrOk => \"ok\".to_owned(),\n                     TestResult::TrFailed => \"failed\".to_owned(),\n                     TestResult::TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n-                    TestResult::TrIgnored => \"ignored\".to_owned(),\n+                    TestResult::TrIgnored => {\n+                        #[cfg(not(bootstrap))]\n+                        if let Some(msg) = ignore_message {\n+                            format!(\"ignored, {}\", msg)\n+                        } else {\n+                            \"ignored\".to_owned()\n+                        }\n+                        #[cfg(bootstrap)]\n+                        \"ignored\".to_owned()\n+                    }\n                     TestResult::TrBench(ref bs) => fmt_bench_samples(bs),\n                     TestResult::TrTimedFail => \"failed (time limit exceeded)\".to_owned(),\n                 },\n-                test.name,\n+                name,\n             )\n         })?;\n         if let Some(exec_time) = exec_time {"}, {"sha": "e99089e453e7fa131d485c30d8bb49f9218b1a9f", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -61,6 +61,8 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n             desc: TestDesc {\n                 name: StaticTestName(\"1\"),\n                 ignore: true,\n+                #[cfg(not(bootstrap))]\n+                ignore_message: None,\n                 should_panic: ShouldPanic::No,\n                 compile_fail: false,\n                 no_run: false,\n@@ -74,6 +76,8 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n             desc: TestDesc {\n                 name: StaticTestName(\"2\"),\n                 ignore: false,\n+                #[cfg(not(bootstrap))]\n+                ignore_message: None,\n                 should_panic: ShouldPanic::No,\n                 compile_fail: false,\n                 no_run: false,\n@@ -95,6 +99,8 @@ pub fn do_not_run_ignored_tests() {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: true,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -117,6 +123,8 @@ pub fn ignored_tests_result_in_ignored() {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: true,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -143,6 +151,8 @@ fn test_should_panic() {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::Yes,\n             compile_fail: false,\n             no_run: false,\n@@ -169,6 +179,8 @@ fn test_should_panic_good_message() {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n             compile_fail: false,\n             no_run: false,\n@@ -200,6 +212,8 @@ fn test_should_panic_bad_message() {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::YesWithMessage(expected),\n             compile_fail: false,\n             no_run: false,\n@@ -235,6 +249,8 @@ fn test_should_panic_non_string_message_type() {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::YesWithMessage(expected),\n             compile_fail: false,\n             no_run: false,\n@@ -262,6 +278,8 @@ fn test_should_panic_but_succeeds() {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n+                #[cfg(not(bootstrap))]\n+                ignore_message: None,\n                 should_panic,\n                 compile_fail: false,\n                 no_run: false,\n@@ -297,6 +315,8 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -333,6 +353,8 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -373,6 +395,8 @@ fn typed_test_desc(test_type: TestType) -> TestDesc {\n     TestDesc {\n         name: StaticTestName(\"whatever\"),\n         ignore: false,\n+        #[cfg(not(bootstrap))]\n+        ignore_message: None,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -486,6 +510,8 @@ pub fn exclude_should_panic_option() {\n         desc: TestDesc {\n             name: StaticTestName(\"3\"),\n             ignore: false,\n+            #[cfg(not(bootstrap))]\n+            ignore_message: None,\n             should_panic: ShouldPanic::Yes,\n             compile_fail: false,\n             no_run: false,\n@@ -511,6 +537,8 @@ pub fn exact_filter_match() {\n                 desc: TestDesc {\n                     name: StaticTestName(name),\n                     ignore: false,\n+                    #[cfg(not(bootstrap))]\n+                    ignore_message: None,\n                     should_panic: ShouldPanic::No,\n                     compile_fail: false,\n                     no_run: false,\n@@ -601,6 +629,8 @@ fn sample_tests() -> Vec<TestDescAndFn> {\n             desc: TestDesc {\n                 name: DynTestName((*name).clone()),\n                 ignore: false,\n+                #[cfg(not(bootstrap))]\n+                ignore_message: None,\n                 should_panic: ShouldPanic::No,\n                 compile_fail: false,\n                 no_run: false,\n@@ -753,6 +783,8 @@ pub fn test_bench_no_iter() {\n     let desc = TestDesc {\n         name: StaticTestName(\"f\"),\n         ignore: false,\n+        #[cfg(not(bootstrap))]\n+        ignore_message: None,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -776,6 +808,8 @@ pub fn test_bench_iter() {\n     let desc = TestDesc {\n         name: StaticTestName(\"f\"),\n         ignore: false,\n+        #[cfg(not(bootstrap))]\n+        ignore_message: None,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -793,6 +827,8 @@ fn should_sort_failures_before_printing_them() {\n     let test_a = TestDesc {\n         name: StaticTestName(\"a\"),\n         ignore: false,\n+        #[cfg(not(bootstrap))]\n+        ignore_message: None,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -804,6 +840,8 @@ fn should_sort_failures_before_printing_them() {\n     let test_b = TestDesc {\n         name: StaticTestName(\"b\"),\n         ignore: false,\n+        #[cfg(not(bootstrap))]\n+        ignore_message: None,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,"}, {"sha": "cc75220aa003217c9a9ed51c0c2215215687f6be", "filename": "library/test/src/types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Ftest%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/library%2Ftest%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftypes.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -117,6 +117,8 @@ pub struct TestId(pub usize);\n pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,\n+    #[cfg(not(bootstrap))]\n+    pub ignore_message: Option<&'static str>,\n     pub should_panic: options::ShouldPanic,\n     pub compile_fail: bool,\n     pub no_run: bool,"}, {"sha": "b2805d93b70fc82778ebbd7760472d3ecfef2c3e", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -648,7 +648,7 @@ impl Step for Rustc {\n pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelection) {\n     cargo\n         .arg(\"--features\")\n-        .arg(builder.rustc_features())\n+        .arg(builder.rustc_features(builder.kind))\n         .arg(\"--manifest-path\")\n         .arg(builder.src.join(\"compiler/rustc/Cargo.toml\"));\n     rustc_cargo_env(builder, cargo, target);"}, {"sha": "86339c8d7f88d2992458fcc197c0b2d8eb2aa35f", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -119,6 +119,7 @@ use std::os::windows::fs::symlink_file;\n use build_helper::{mtime, output, run, run_suppressed, t, try_run, try_run_suppressed};\n use filetime::FileTime;\n \n+use crate::builder::Kind;\n use crate::config::{LlvmLibunwind, TargetSelection};\n use crate::util::{exe, libdir, CiEnv};\n \n@@ -669,12 +670,12 @@ impl Build {\n     }\n \n     /// Gets the space-separated set of activated features for the compiler.\n-    fn rustc_features(&self) -> String {\n+    fn rustc_features(&self, kind: Kind) -> String {\n         let mut features = String::new();\n         if self.config.jemalloc {\n             features.push_str(\"jemalloc\");\n         }\n-        if self.config.llvm_enabled() {\n+        if self.config.llvm_enabled() || kind == Kind::Check {\n             features.push_str(\" llvm\");\n         }\n "}, {"sha": "dc9ce052cb5eece54aac61c451e5acc1925cf94e", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -946,6 +946,8 @@ impl Tester for Collector {\n                     Ignore::None => false,\n                     Ignore::Some(ref ignores) => ignores.iter().any(|s| target_str.contains(s)),\n                 },\n+                #[cfg(not(bootstrap))]\n+                ignore_message: None,\n                 // compiler failures are test failures\n                 should_panic: test::ShouldPanic::No,\n                 compile_fail: config.compile_fail,"}, {"sha": "b6c0fda15216a71ad062bb725dcc5f4b54d8ae78", "filename": "src/test/ui/async-await/drop-track-field-assign-nonsend.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign-nonsend.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -0,0 +1,45 @@\n+// Derived from an ICE found in tokio-xmpp during a crater run.\n+// edition:2021\n+// compile-flags: -Zdrop-tracking\n+\n+#![allow(dead_code)]\n+\n+#[derive(Clone)]\n+struct InfoResult {\n+    node: Option<std::rc::Rc<String>>\n+}\n+\n+struct Agent {\n+    info_result: InfoResult\n+}\n+\n+impl Agent {\n+    async fn handle(&mut self) {\n+        let mut info = self.info_result.clone();\n+        info.node = None;\n+        let element = parse_info(info);\n+        let _ = send_element(element).await;\n+    }\n+}\n+\n+struct Element {\n+}\n+\n+async fn send_element(_: Element) {}\n+\n+fn parse(_: &[u8]) -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn parse_info(_: InfoResult) -> Element {\n+    Element { }\n+}\n+\n+fn assert_send<T: Send>(_: T) {}\n+\n+fn main() {\n+    let agent = Agent { info_result: InfoResult { node: None } };\n+    // FIXME: It would be nice for this to work. See #94067.\n+    assert_send(agent.handle());\n+    //~^ cannot be sent between threads safely\n+}"}, {"sha": "d95483c81195ce679345bb25a1facb7de7da0f34", "filename": "src/test/ui/async-await/drop-track-field-assign-nonsend.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign-nonsend.stderr?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -0,0 +1,25 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/drop-track-field-assign-nonsend.rs:43:17\n+   |\n+LL |     assert_send(agent.handle());\n+   |                 ^^^^^^^^^^^^^^ future returned by `handle` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<String>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/drop-track-field-assign-nonsend.rs:21:38\n+   |\n+LL |         let mut info = self.info_result.clone();\n+   |             -------- has type `InfoResult` which is not `Send`\n+...\n+LL |         let _ = send_element(element).await;\n+   |                                      ^^^^^^ await occurs here, with `mut info` maybe used later\n+LL |     }\n+   |     - `mut info` is later dropped here\n+note: required by a bound in `assert_send`\n+  --> $DIR/drop-track-field-assign-nonsend.rs:38:19\n+   |\n+LL | fn assert_send<T: Send>(_: T) {}\n+   |                   ^^^^ required by this bound in `assert_send`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a393cd164b9980a9423cad19bf599e4f65f551b", "filename": "src/test/ui/async-await/drop-track-field-assign.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-field-assign.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -0,0 +1,44 @@\n+// Derived from an ICE found in tokio-xmpp during a crater run.\n+// edition:2021\n+// compile-flags: -Zdrop-tracking\n+// build-pass\n+\n+#![allow(dead_code)]\n+\n+#[derive(Clone)]\n+struct InfoResult {\n+    node: Option<String>\n+}\n+\n+struct Agent {\n+    info_result: InfoResult\n+}\n+\n+impl Agent {\n+    async fn handle(&mut self) {\n+        let mut info = self.info_result.clone();\n+        info.node = Some(\"bar\".into());\n+        let element = parse_info(info);\n+        let _ = send_element(element).await;\n+    }\n+}\n+\n+struct Element {\n+}\n+\n+async fn send_element(_: Element) {}\n+\n+fn parse(_: &[u8]) -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn parse_info(_: InfoResult) -> Element {\n+    Element { }\n+}\n+\n+fn main() {\n+    let mut agent = Agent {\n+        info_result: InfoResult { node: None }\n+    };\n+    let _ = agent.handle();\n+}"}, {"sha": "2c2239f2b83d19ccf3521a018de2a6d1c5063267", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c8ffaacb040a8753ef8e1accea701bc9f5be85/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=03c8ffaacb040a8753ef8e1accea701bc9f5be85", "patch": "@@ -806,6 +806,8 @@ pub fn make_test_description<R: Read>(\n     cfg: Option<&str>,\n ) -> test::TestDesc {\n     let mut ignore = false;\n+    #[cfg(not(bootstrap))]\n+    let ignore_message: Option<String> = None;\n     let mut should_fail = false;\n \n     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n@@ -877,6 +879,8 @@ pub fn make_test_description<R: Read>(\n     test::TestDesc {\n         name,\n         ignore,\n+        #[cfg(not(bootstrap))]\n+        ignore_message,\n         should_panic,\n         compile_fail: false,\n         no_run: false,"}]}