{"sha": "30d563839eb496fcc20c333a3eda2cee16966534", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZDU2MzgzOWViNDk2ZmNjMjBjMzMzYTNlZGEyY2VlMTY5NjY1MzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-21T17:04:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-23T15:02:59Z"}, "message": "Various regions fixes.", "tree": {"sha": "7d84b2fb84e9b1f82a0bd1963ad473f5db7d1c94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d84b2fb84e9b1f82a0bd1963ad473f5db7d1c94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30d563839eb496fcc20c333a3eda2cee16966534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30d563839eb496fcc20c333a3eda2cee16966534", "html_url": "https://github.com/rust-lang/rust/commit/30d563839eb496fcc20c333a3eda2cee16966534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30d563839eb496fcc20c333a3eda2cee16966534/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d3658bb43455fc1d52662dca17789e689914879", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3658bb43455fc1d52662dca17789e689914879", "html_url": "https://github.com/rust-lang/rust/commit/0d3658bb43455fc1d52662dca17789e689914879"}], "stats": {"total": 236, "additions": 146, "deletions": 90}, "files": [{"sha": "f2e41da9b4e44c674fab5194da5dee893205a9b0", "filename": "src/etc/indenter", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Fetc%2Findenter", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Fetc%2Findenter", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Findenter?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -6,10 +6,12 @@ my $indent = 0;\n while (<>) {\n     if (/^rust: \">>/) {\n         $indent += 1;\n-    } elsif (/^rust: \"<</) {\n-        $indent -= 1;\n     }\n \n     printf \"%03d  %s%s\", $indent, (\"  \" x $indent), $_;\n+\n+    if (/^rust: \"<</) {\n+        $indent -= 1;\n+    }\n }\n "}, {"sha": "1e513d3da8c8ae3c1bc44b6cf3835da1ca2b2f48", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 64, "deletions": 69, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -92,21 +92,19 @@ fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n     mk_eqty(infcx, a, b)\n }\n \n-// Resolves one level of type structure but not any type variables\n-// that may be nested within.\n-fn resolve_shallow(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n-    resolver(cx, false, false).resolve(a)\n+// See comment on the type `resolve_state` below\n+fn resolve_shallow(cx: infer_ctxt, a: ty::t,\n+                   force_vars: bool) -> fres<ty::t> {\n+    resolver(cx, false, force_vars).resolve(a)\n }\n \n-// see resolve_deep()\n+// See comment on the type `resolve_state` below\n fn resolve_deep_var(cx: infer_ctxt, vid: ty_vid,\n                     force_vars: bool) -> fres<ty::t> {\n     resolver(cx, true, force_vars).resolve(ty::mk_var(cx.tcx, vid))\n }\n \n-// Resolves all levels of type structure.  If `force_vars` is true,\n-// then we will resolve unconstrained type/region variables to\n-// something arbitrary.  Otherwise, we preserve them as variables.\n+// See comment on the type `resolve_state` below\n fn resolve_deep(cx: infer_ctxt, a: ty::t, force_vars: bool) -> fres<ty::t> {\n     resolver(cx, true, force_vars).resolve(a)\n }\n@@ -556,8 +554,12 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn eq_regions(a: ty::region, b: ty::region) -> ures {\n-        self.sub_regions(a, b).then {||\n-            self.sub_regions(b, a)\n+        #debug[\"eq_regions(%s, %s)\",\n+               a.to_str(self), b.to_str(self)];\n+        indent {||\n+            self.sub_regions(a, b).then {||\n+                self.sub_regions(b, a)\n+            }\n         }\n     }\n }\n@@ -599,16 +601,20 @@ impl methods for resolve_state {\n     fn resolve(typ: ty::t) -> fres<ty::t> {\n         self.err = none;\n \n+        #debug[\"Resolving %s (deep=%b, force_vars=%b)\",\n+               ty_to_str(self.infcx.tcx, typ),\n+               self.deep,\n+               self.force_vars];\n+\n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n-        let rty = self.resolve1(typ);\n+        let rty = indent {|| self.resolve1(typ) };\n         assert vec::is_empty(self.v_seen) && vec::is_empty(self.r_seen);\n         alt self.err {\n           none {\n-            #debug[\"Resolved %s to %s (deep=%b, force_vars=%b)\",\n-                   ty_to_str(self.infcx.tcx, typ),\n+            #debug[\"Resolved to %s (deep=%b, force_vars=%b)\",\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.deep,\n                    self.force_vars];\n@@ -619,25 +625,32 @@ impl methods for resolve_state {\n     }\n \n     fn resolve1(typ: ty::t) -> ty::t {\n-        let tb = ty::get(typ);\n-        alt tb.struct {\n-          ty::ty_var(vid) { self.resolve_ty_var(vid) }\n-          _ if !tb.has_regions && !self.deep { typ }\n-          _ {\n-            ty::fold_regions_and_ty(\n-                self.infcx.tcx, typ,\n-                { |r| self.resolve_region(r) },\n-                { |t| self.resolve_if_deep(t) },\n-                { |t| self.resolve_if_deep(t) })\n-          }\n-        }\n+        #debug(\"Resolve1(%s)\", typ.to_str(self.infcx));\n+        indent(fn&() -> ty::t {\n+            if !ty::get(typ).has_vars { ret typ; }\n+\n+            let tb = ty::get(typ);\n+            alt tb.struct {\n+              ty::ty_var(vid) { self.resolve_ty_var(vid) }\n+              _ if !tb.has_regions && !self.deep { typ }\n+              _ {\n+                ty::fold_regions_and_ty(\n+                    self.infcx.tcx, typ,\n+                    { |r| self.resolve_region(r) },\n+                    { |t| self.resolve_if_deep(t) },\n+                    { |t| self.resolve_if_deep(t) })\n+              }\n+            }\n+        })\n     }\n \n     fn resolve_if_deep(typ: ty::t) -> ty::t {\n+        #debug(\"Resolve_if_deep(%s)\", typ.to_str(self.infcx));\n         if !self.deep {typ} else {self.resolve1(typ)}\n     }\n \n     fn resolve_region(orig: ty::region) -> ty::region {\n+        #debug(\"Resolve_region(%s)\", orig.to_str(self.infcx));\n         alt orig {\n           ty::re_var(rid) { self.resolve_region_var(rid) }\n           _ { orig }\n@@ -650,16 +663,15 @@ impl methods for resolve_state {\n             ret ty::re_var(rid);\n         } else {\n             vec::push(self.r_seen, rid);\n-            let r = self.resolve_var(\n-                self.infcx.rb,\n-                {|_t| false },\n-                rid,\n-                {||\n-                    if self.force_vars {ty::re_static}\n-                    else {ty::re_var(rid)}\n-                });\n+            let {root:_, bounds} = self.infcx.get(self.infcx.rb, rid);\n+            let r1 = alt bounds {\n+              { ub:_, lb:some(t) } { self.resolve_region(t) }\n+              { ub:some(t), lb:_ } { self.resolve_region(t) }\n+              { ub:none, lb:none } if self.force_vars { ty::re_static }\n+              { ub:none, lb:none } { ty::re_var(rid) }\n+            };\n             vec::pop(self.r_seen);\n-            ret r;\n+            ret r1;\n         }\n     }\n \n@@ -670,43 +682,25 @@ impl methods for resolve_state {\n         } else {\n             vec::push(self.v_seen, vid);\n             let tcx = self.infcx.tcx;\n-            let t0 = self.resolve_var(\n-                self.infcx.vb,\n-                {|t| type_is_bot(t) },\n-                vid,\n-                {||\n-                    if self.force_vars {ty::mk_bot(tcx)}\n-                    else {ty::mk_var(tcx, vid)}\n-                });\n-            let t1 = self.resolve1(t0);\n+\n+            // Nonobvious: prefer the most specific type\n+            // (i.e., the lower bound) to the more general\n+            // one.  More general types in Rust (e.g., fn())\n+            // tend to carry more restrictions or higher\n+            // perf. penalties, so it pays to know more.\n+\n+            let {root:_, bounds} = self.infcx.get(self.infcx.vb, vid);\n+            let t1 = alt bounds {\n+              { ub:_, lb:some(t) } if !type_is_bot(t) { self.resolve1(t) }\n+              { ub:some(t), lb:_ } { self.resolve1(t) }\n+              { ub:_, lb:some(t) } { self.resolve1(t) }\n+              { ub:none, lb:none } if self.force_vars { ty::mk_bot(tcx) }\n+              { ub:none, lb:none } { ty::mk_var(tcx, vid) }\n+            };\n             vec::pop(self.v_seen);\n             ret t1;\n         }\n     }\n-\n-    fn resolve_var<V: copy vid, T:copy to_str>(\n-        vb: vals_and_bindings<V, T>, bot_guard: fn(T)->bool,\n-        vid: V, unbound: fn() -> T) -> T {\n-\n-        let {root:_, bounds} = self.infcx.get(vb, vid);\n-\n-        #debug[\"resolve_var(%s) bounds=%s\",\n-               vid.to_str(),\n-               bounds.to_str(self.infcx)];\n-\n-        // Nonobvious: prefer the most specific type\n-        // (i.e., the lower bound) to the more general\n-        // one.  More general types in Rust (e.g., fn())\n-        // tend to carry more restrictions or higher\n-        // perf. penalties, so it pays to know more.\n-\n-        alt bounds {\n-          { ub:_, lb:some(t) } if !bot_guard(t) { t }\n-          { ub:some(t), lb:_ } { t }\n-          { ub:_, lb:some(t) } { t }\n-          { ub:none, lb:none } { unbound() }\n-        }\n-    }\n }\n \n // ______________________________________________________________________\n@@ -958,8 +952,9 @@ fn super_substs<C:combine>(\n             ok(none)\n           }\n           (some(a), some(b)) {\n-            infcx.eq_regions(a, b);\n-            ok(some(a))\n+            infcx.eq_regions(a, b).then {||\n+                ok(some(a))\n+            }\n           }\n           (_, _) {\n             // If these two substitutions are for the same type (and"}, {"sha": "9b25b057c3fd3eb3359415d3b15a6b8175b63c5f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -483,12 +483,26 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         has_vars |= t.has_vars;\n         has_regions |= t.has_regions;\n     }\n-    alt st {\n-      ty_estr(vstore_slice(_)) {\n+    fn derive_rflags(&has_vars: bool, &has_regions: bool, r: region) {\n         has_regions = true;\n+        alt r {\n+          ty::re_var(_) { has_vars = true; }\n+          _ { }\n+        }\n+    }\n+    fn derive_sflags(&has_params: bool, &has_vars: bool, &has_regions: bool,\n+                     substs: substs) {\n+        for substs.tps.each {|tt|\n+            derive_flags(has_params, has_vars, has_regions, tt);\n+        }\n+        substs.self_r.iter { |r| derive_rflags(has_vars, has_regions, r) }\n+    }\n+    alt st {\n+      ty_estr(vstore_slice(r)) {\n+        derive_rflags(has_vars, has_regions, r);\n       }\n-      ty_evec(mt, vstore_slice(_)) {\n-        has_regions = true;\n+      ty_evec(mt, vstore_slice(r)) {\n+        derive_rflags(has_vars, has_regions, r);\n         derive_flags(has_params, has_vars, has_regions, mt.ty);\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n@@ -497,10 +511,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n       ty_enum(_, substs) | ty_class(_, substs) {\n-        for substs.tps.each {|tt|\n-            derive_flags(has_params, has_vars, has_regions, tt);\n-        }\n-        substs.self_r.iter { |_i| has_regions = true; }\n+        derive_sflags(has_params, has_vars, has_regions, substs);\n       }\n       ty_iface(_, tys) {\n         for tys.each {|tt|\n@@ -511,11 +522,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         derive_flags(has_params, has_vars, has_regions, m.ty);\n       }\n       ty_rptr(r, m) {\n-        alt r {\n-          ty::re_var(_) { has_vars = true; }\n-          _ { }\n-        }\n-        has_regions = true;\n+        derive_rflags(has_vars, has_regions, r);\n         derive_flags(has_params, has_vars, has_regions, m.ty);\n       }\n       ty_rec(flds) {\n@@ -535,9 +542,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       }\n       ty_res(_, tt, substs) {\n         derive_flags(has_params, has_vars, has_regions, tt);\n-        for substs.tps.each {|tt|\n-            derive_flags(has_params, has_vars, has_regions, tt);\n-        }\n+        derive_sflags(has_params, has_vars, has_regions, substs);\n       }\n       ty_constr(tt, _) {\n         derive_flags(has_params, has_vars, has_regions, tt);\n@@ -933,10 +938,11 @@ fn subst(cx: ctxt,\n          substs: substs,\n          typ: t) -> t {\n \n-    if substs_is_noop(substs) { ret typ; }\n     #debug[\"subst(substs=%s, typ=%s)\",\n            substs_to_str(cx, substs),\n            ty_to_str(cx, typ)];\n+\n+    if substs_is_noop(substs) { ret typ; }\n     let r = do_subst(cx, substs, typ);\n     #debug[\"  r = %s\", ty_to_str(cx, r)];\n     ret r;"}, {"sha": "d9324a74d7b3d50e072b02fb4cbda6baf96a80d7", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -258,7 +258,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n \n // Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt infer::resolve_shallow(fcx.infcx, tp) {\n+    alt infer::resolve_shallow(fcx.infcx, tp, true) {\n       // note: the bot type doesn't count as resolved; it's what we use when\n       // there is no information about a variable.\n       result::ok(t_s) if !ty::type_is_bot(t_s) { ret t_s; }\n@@ -1348,7 +1348,7 @@ mod collect {\n                                 constraints: []})\n             };\n             let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                       rp: ast::rp_none,\n+                       rp: rp,\n                        ty: result_ty};\n             tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write_ty_to_tcx(tcx, variant.node.id, result_ty);"}, {"sha": "d650441aab7a55876f7988d9911494ce77030b73", "filename": "src/test/compile-fail/regions-creating-enums3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -0,0 +1,11 @@\n+enum ast/& {\n+    num(uint),\n+    add(&ast, &ast)\n+}\n+\n+fn mk_add_bad1(x: &a.ast, y: &b.ast) -> ast/&a {\n+    add(x, y) //! ERROR mismatched types: expected `&a.ast/&a` but found `&b.ast/&b`\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "f80334d3fea573db11a6c0b50f1c3dcf42039735", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -0,0 +1,11 @@\n+enum ast/& {\n+    num(uint),\n+    add(&ast, &ast)\n+}\n+\n+fn mk_add_bad2(x: &a.ast, y: &a.ast, z: &ast) -> ast {\n+    add(x, y) //! ERROR mismatched types: expected `ast/&` but found `ast/&a`\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "27559ea894200ba2fac987ca935d30747a01438e", "filename": "src/test/run-pass/regions-creating-enums2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -0,0 +1,11 @@\n+enum ast/& {\n+    num(uint),\n+    add(&ast, &ast)\n+}\n+\n+fn mk_add_ok(x: &ast, y: &ast) -> ast {\n+    add(x, y)\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "a7982cb9374d59896d670f5f34b296e2af3ac72e", "filename": "src/test/run-pass/regions-creating-enums5.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -0,0 +1,11 @@\n+enum ast/& {\n+    num(uint),\n+    add(&ast, &ast)\n+}\n+\n+fn mk_add_ok(x: &a.ast, y: &a.ast, z: &ast) -> ast/&a {\n+    add(x, y)\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "ad08ec1f67bc25fb15a5fe893d8fe808898b71df", "filename": "src/test/run-pass/regions-nullary-variant.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30d563839eb496fcc20c333a3eda2cee16966534/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs?ref=30d563839eb496fcc20c333a3eda2cee16966534", "patch": "@@ -0,0 +1,9 @@\n+enum roption/& {\n+    a, b(&uint)\n+}\n+\n+fn mk(cond: bool, ptr: &uint) -> roption {\n+    if cond {a} else {b(ptr)}\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}]}