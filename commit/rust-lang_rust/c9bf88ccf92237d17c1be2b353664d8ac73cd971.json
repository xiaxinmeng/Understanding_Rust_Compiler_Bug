{"sha": "c9bf88ccf92237d17c1be2b353664d8ac73cd971", "node_id": "C_kwDOAAsO6NoAKGM5YmY4OGNjZjkyMjM3ZDE3YzFiZTJiMzUzNjY0ZDhhYzczY2Q5NzE", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-23T20:38:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2022-06-23T20:38:24Z"}, "message": "coallesce docs", "tree": {"sha": "3032814a6ed0ef3754b37bb4f269509dc6bd2a53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3032814a6ed0ef3754b37bb4f269509dc6bd2a53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9bf88ccf92237d17c1be2b353664d8ac73cd971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9bf88ccf92237d17c1be2b353664d8ac73cd971", "html_url": "https://github.com/rust-lang/rust/commit/c9bf88ccf92237d17c1be2b353664d8ac73cd971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9bf88ccf92237d17c1be2b353664d8ac73cd971/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e0f7a8864ebd64eda4737f74b1324a98da2e95", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e0f7a8864ebd64eda4737f74b1324a98da2e95", "html_url": "https://github.com/rust-lang/rust/commit/27e0f7a8864ebd64eda4737f74b1324a98da2e95"}], "stats": {"total": 97, "additions": 32, "deletions": 65}, "files": [{"sha": "19f83e3377a675248103a238a6b0f9f6d0e90e40", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 32, "deletions": 65, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c9bf88ccf92237d17c1be2b353664d8ac73cd971/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9bf88ccf92237d17c1be2b353664d8ac73cd971/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c9bf88ccf92237d17c1be2b353664d8ac73cd971", "patch": "@@ -190,44 +190,7 @@ pub enum GenericKind<'tcx> {\n /// This is described with an `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n-    /// This is a \"conditional bound\" that checks the result of inference\n-    /// and supplies a bound if it ended up being relevant. It's used in situations\n-    /// like this:\n-    ///\n-    /// ```rust\n-    /// fn foo<'a, 'b, T: SomeTrait<'a>>\n-    /// where\n-    ///    <T as SomeTrait<'a>>::Item: 'b\n-    /// ```\n-    ///\n-    /// If we have an obligation like `<T as SomeTrait<'?x>>::Item: 'c`, then\n-    /// we don't know yet whether it suffices to show that `'b: 'c`. If `'?x` winds\n-    /// up being equal to `'a`, then the where-clauses on function applies, and\n-    /// in that case we can show `'b: 'c`. But if `'?x` winds up being something\n-    /// else, the bound isn't relevant.\n-    ///\n-    /// More abstractly, this function takes a `Binder<VerifyIfEq>`. The binder\n-    /// represents an existential binder -- i.e., if you have something like\n-    ///\n-    /// ```rust\n-    /// where for<'a> <T as SomeTrait<'a>::Item: 'a\n-    /// ```\n-    ///\n-    /// then the `for<'a>` corresponds to the binder. The idea is that we have\n-    /// to find some instantiation of `'a` that can make `<T as SomeTrait<'a>>::Item`\n-    /// equal to the final value of `G`, the generic we are checking.\n-    ///\n-    /// ```ignore (pseudo-rust)\n-    /// fn(min) -> bool {\n-    ///     exists<'a> {\n-    ///         if G == K {\n-    ///             B(min)\n-    ///         } else {\n-    ///             false\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n+    /// See [`VerifyIfEq`] docs\n     IfEq(ty::Binder<'tcx, VerifyIfEq<'tcx>>),\n \n     /// Given a region `R`, expands to the function:\n@@ -271,40 +234,44 @@ pub enum VerifyBound<'tcx> {\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n-/// Given a kind K and a bound B, expands to a function like the\n-/// following, where `G` is the generic for which this verify\n-/// bound was created:\n+/// This is a \"conditional bound\" that checks the result of inference\n+/// and supplies a bound if it ended up being relevant. It's used in situations\n+/// like this:\n ///\n-/// ```ignore (pseudo-rust)\n-/// fn(min) -> bool {\n-///     if G == K {\n-///         B(min)\n-///     } else {\n-///         false\n-///     }\n-/// }\n+/// ```rust\n+/// fn foo<'a, 'b, T: SomeTrait<'a>>\n+/// where\n+///    <T as SomeTrait<'a>>::Item: 'b\n /// ```\n ///\n-/// In other words, if the generic `G` that we are checking is\n-/// equal to `K`, then check the associated verify bound\n-/// (otherwise, false).\n-///\n-/// This is used when we have something in the environment that\n-/// may or may not be relevant, depending on the region inference\n-/// results. For example, we may have `where <T as\n-/// Trait<'a>>::Item: 'b` in our where-clauses. If we are\n-/// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n-/// this where-clause is only relevant if `'0` winds up inferred\n-/// to `'a`.\n+/// If we have an obligation like `<T as SomeTrait<'?x>>::Item: 'c`, then\n+/// we don't know yet whether it suffices to show that `'b: 'c`. If `'?x` winds\n+/// up being equal to `'a`, then the where-clauses on function applies, and\n+/// in that case we can show `'b: 'c`. But if `'?x` winds up being something\n+/// else, the bound isn't relevant.\n ///\n-/// So we would compile to a verify-bound like\n+/// In the [`VerifyBound`], this struct is enclosed in `Binder to account\n+/// for cases like\n ///\n-/// ```ignore (illustrative)\n-/// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+/// ```rust\n+/// where for<'a> <T as SomeTrait<'a>::Item: 'a\n /// ```\n ///\n-/// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n-/// (after inference), and `'a: min`, then `G: min`.\n+/// The idea is that we have to find some instantiation of `'a` that can\n+/// make `<T as SomeTrait<'a>>::Item` equal to the final value of `G`,\n+/// the generic we are checking.\n+///\n+/// ```ignore (pseudo-rust)\n+/// fn(min) -> bool {\n+///     exists<'a> {\n+///         if G == K {\n+///             B(min)\n+///         } else {\n+///             false\n+///         }\n+///     }\n+/// }\n+/// ```\n #[derive(Debug, Copy, Clone, TypeFoldable)]\n pub struct VerifyIfEq<'tcx> {\n     /// Type which must match the generic `G`"}]}