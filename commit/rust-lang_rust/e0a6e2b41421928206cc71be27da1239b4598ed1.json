{"sha": "e0a6e2b41421928206cc71be27da1239b4598ed1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYTZlMmI0MTQyMTkyODIwNmNjNzFiZTI3ZGExMjM5YjQ1OThlZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T12:26:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T12:26:39Z"}, "message": "auto merge of #15765 : luqmana/rust/iec, r=pcwalton\n\nFixes #15400.", "tree": {"sha": "09df47d31f54d773b355884f74b6323b1e08d14b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09df47d31f54d773b355884f74b6323b1e08d14b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0a6e2b41421928206cc71be27da1239b4598ed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a6e2b41421928206cc71be27da1239b4598ed1", "html_url": "https://github.com/rust-lang/rust/commit/e0a6e2b41421928206cc71be27da1239b4598ed1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0a6e2b41421928206cc71be27da1239b4598ed1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05a2c97b8e41177e531c4440519333057f9ac55", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a2c97b8e41177e531c4440519333057f9ac55", "html_url": "https://github.com/rust-lang/rust/commit/f05a2c97b8e41177e531c4440519333057f9ac55"}, {"sha": "61ded48fbcc79e0b3d532bb17f38b1c1baf56d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/61ded48fbcc79e0b3d532bb17f38b1c1baf56d41", "html_url": "https://github.com/rust-lang/rust/commit/61ded48fbcc79e0b3d532bb17f38b1c1baf56d41"}], "stats": {"total": 233, "additions": 144, "deletions": 89}, "files": [{"sha": "439455ff3d15ce3291c07acd9955b1fd852266bd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -314,8 +314,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n-                            index: &mut Vec<entry<i64>>,\n-                            generics: &ast::Generics) {\n+                            index: &mut Vec<entry<i64>>) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n     let mut disr_val = 0;\n@@ -343,10 +342,6 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_stability(ebml_w, stab);\n \n         match variant.node.kind {\n-            ast::TupleVariantKind(ref args)\n-                    if args.len() > 0 && generics.ty_params.len() == 0 => {\n-                encode_symbol(ecx, ebml_w, variant.node.id);\n-            }\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(_) => {\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n@@ -1019,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(ebml_w, stab);\n         ebml_w.end_tag();\n       }\n-      ItemEnum(ref enum_definition, ref generics) => {\n+      ItemEnum(ref enum_definition, _) => {\n         add_to_index(item, ebml_w, index);\n \n         ebml_w.start_tag(tag_items_data_item);\n@@ -1046,8 +1041,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  ebml_w,\n                                  item.id,\n                                  (*enum_definition).variants.as_slice(),\n-                                 index,\n-                                 generics);\n+                                 index);\n       }\n       ItemStruct(struct_def, _) => {\n         let fields = ty::lookup_struct_fields(tcx, def_id);"}, {"sha": "54c30e721548d4b93073bbe58db8f9691b1ef84d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -674,11 +674,10 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n }\n \n /**\n- * Begin initializing a new value of the given case of the given\n- * representation.  The fields, if any, should then be initialized via\n- * `trans_field_ptr`.\n+ * Set the discriminant for a new value of the given case of the given\n+ * representation.\n  */\n-pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_set_discr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);"}, {"sha": "7d7922ebfa90c56be16c22103456a4ac6b9f7c02", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -80,7 +80,6 @@ use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n use std::{i8, i16, i32, i64};\n-use std::gc::Gc;\n use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel, Rust, RustCall};\n use syntax::abi::{RustIntrinsic, Abi};\n use syntax::ast_util::{local_def, is_local};\n@@ -1704,6 +1703,59 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n         llfndecl);\n }\n \n+pub fn trans_named_tuple_constructor<'a>(mut bcx: &'a Block<'a>,\n+                                         ctor_ty: ty::t,\n+                                         disr: ty::Disr,\n+                                         args: callee::CallArgs,\n+                                         dest: expr::Dest) -> Result<'a> {\n+\n+    let ccx = bcx.fcx.ccx;\n+    let tcx = &ccx.tcx;\n+\n+    let result_ty = match ty::get(ctor_ty).sty {\n+        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        _ => ccx.sess().bug(\n+            format!(\"trans_enum_variant_constructor: \\\n+                     unexpected ctor return type {}\",\n+                     ctor_ty.repr(tcx)).as_slice())\n+    };\n+\n+    // Get location to store the result. If the user does not care about\n+    // the result, just make a stack slot\n+    let llresult = match dest {\n+        expr::SaveIn(d) => d,\n+        expr::Ignore => {\n+            if !type_is_zero_size(ccx, result_ty) {\n+                alloc_ty(bcx, result_ty, \"constructor_result\")\n+            } else {\n+                C_undef(type_of::type_of(ccx, result_ty))\n+            }\n+        }\n+    };\n+\n+    if !type_is_zero_size(ccx, result_ty) {\n+        let repr = adt::represent_type(ccx, result_ty);\n+\n+        match args {\n+            callee::ArgExprs(exprs) => {\n+                let fields = exprs.iter().map(|x| *x).enumerate().collect::<Vec<_>>();\n+                bcx = expr::trans_adt(bcx, &*repr, disr, fields.as_slice(),\n+                                      None, expr::SaveIn(llresult));\n+            }\n+            _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")\n+        }\n+    }\n+\n+    // If the caller doesn't care about the result\n+    // drop the temporary we made\n+    let bcx = match dest {\n+        expr::SaveIn(_) => bcx,\n+        expr::Ignore => glue::drop_ty(bcx, llresult, result_ty)\n+    };\n+\n+    Result::new(bcx, llresult)\n+}\n+\n pub fn trans_tuple_struct(ccx: &CrateContext,\n                           _fields: &[ast::StructField],\n                           ctor_id: ast::NodeId,\n@@ -1746,7 +1798,6 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     if !type_is_zero_size(fcx.ccx, result_ty) {\n         let repr = adt::represent_type(ccx, result_ty);\n-        adt::trans_start_init(bcx, &*repr, fcx.llretptr.get().unwrap(), disr);\n         for (i, arg_datum) in arg_datums.move_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n@@ -1755,36 +1806,12 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                                                  i);\n             arg_datum.store_to(bcx, lldestptr);\n         }\n+        adt::trans_set_discr(bcx, &*repr, fcx.llretptr.get().unwrap(), disr);\n     }\n \n     finish_fn(&fcx, bcx, result_ty);\n }\n \n-fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n-                  sp: Span, id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n-                  i: &mut uint) {\n-    for variant in enum_definition.variants.iter() {\n-        let disr_val = vi[*i].disr_val;\n-        *i += 1;\n-\n-        match variant.node.kind {\n-            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n-                let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, &**variant, args.as_slice(),\n-                                   disr_val, &param_substs::empty(), llfn);\n-            }\n-            ast::TupleVariantKind(_) => {\n-                // Nothing to do.\n-            }\n-            ast::StructVariantKind(struct_def) => {\n-                trans_struct_def(ccx, struct_def);\n-            }\n-        }\n-    }\n-\n-    enum_variant_size_lint(ccx, enum_definition, sp, id);\n-}\n-\n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n@@ -1877,12 +1904,8 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemMod(ref m) => {\n         trans_mod(ccx, m);\n       }\n-      ast::ItemEnum(ref enum_definition, ref generics) => {\n-        if !generics.is_type_parameterized() {\n-            let vi = ty::enum_variants(ccx.tcx(), local_def(item.id));\n-            let mut i = 0;\n-            trans_enum_def(ccx, enum_definition, item.span, item.id, vi.as_slice(), &mut i);\n-        }\n+      ast::ItemEnum(ref enum_definition, _) => {\n+        enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n       }\n       ast::ItemStatic(_, m, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n@@ -1909,11 +1932,6 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemForeignMod(ref foreign_mod) => {\n         foreign::trans_foreign_mod(ccx, foreign_mod);\n       }\n-      ast::ItemStruct(struct_def, ref generics) => {\n-        if !generics.is_type_parameterized() {\n-            trans_struct_def(ccx, struct_def);\n-        }\n-      }\n       ast::ItemTrait(..) => {\n         // Inside of this trait definition, we won't be actually translating any\n         // functions, but the trait still needs to be walked. Otherwise default\n@@ -1926,20 +1944,6 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: &CrateContext, struct_def: Gc<ast::StructDef>) {\n-    // If this is a tuple-like struct, translate the constructor.\n-    match struct_def.ctor_id {\n-        // We only need to translate a constructor if there are fields;\n-        // otherwise this is a unit-like struct.\n-        Some(ctor_id) if struct_def.fields.len() > 0 => {\n-            let llfndecl = get_item_val(ccx, ctor_id);\n-            trans_tuple_struct(ccx, struct_def.fields.as_slice(),\n-                               ctor_id, &param_substs::empty(), llfndecl);\n-        }\n-        Some(_) | None => {}\n-    }\n-}\n-\n // Translate a module. Doing this amounts to translating the items in the\n // module; there ends up being no artifact (aside from linkage names) of\n // separate modules in the compiled program.  That's because modules exist"}, {"sha": "e2ad8b4fd4680a6891587f6b76d42b3a23181707", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -19,6 +19,7 @@\n use arena::TypedArena;\n use back::abi;\n use back::link;\n+use driver::session;\n use llvm::{ValueRef, get_param};\n use llvm;\n use metadata::csearch;\n@@ -54,6 +55,7 @@ use util::ppaux::Repr;\n \n use std::gc::Gc;\n use syntax::ast;\n+use syntax::ast_map;\n use synabi = syntax::abi;\n \n pub struct MethodData {\n@@ -64,6 +66,10 @@ pub struct MethodData {\n pub enum CalleeData {\n     Closure(Datum<Lvalue>),\n \n+    // Constructor for enum variant/tuple-like-struct\n+    // i.e. Some, Ok\n+    NamedTupleConstructor(subst::Substs, ty::Disr),\n+\n     // Represents a (possibly monomorphized) top-level fn item or method\n     // item. Note that this is just the fn-ptr and is not a Rust closure\n     // value (which is a pair).\n@@ -134,6 +140,23 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n         let expr_ty = node_id_type(bcx, ref_expr.id);\n         match def {\n+            def::DefFn(did, _) if {\n+                let def_id = if did.krate != ast::LOCAL_CRATE {\n+                    inline::maybe_instantiate_inline(bcx.ccx(), did)\n+                } else {\n+                    did\n+                };\n+                match bcx.tcx().map.find(def_id.node) {\n+                    Some(ast_map::NodeStructCtor(_)) => true,\n+                    _ => false\n+                }\n+            } => {\n+                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+                Callee {\n+                    bcx: bcx,\n+                    data: NamedTupleConstructor(substs, 0)\n+                }\n+            }\n             def::DefFn(did, _) if match ty::get(expr_ty).sty {\n                 ty::ty_bare_fn(ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n@@ -158,14 +181,23 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n                                                                 ref_expr.id))\n             }\n             def::DefVariant(tid, vid, _) => {\n-                // nullary variants are not callable\n-                assert!(ty::enum_variant_with_id(bcx.tcx(),\n-                                                      tid,\n-                                                      vid).args.len() > 0u);\n-                fn_callee(bcx, trans_fn_ref(bcx, vid, ExprId(ref_expr.id)))\n+                let vinfo = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n+                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+\n+                // Nullary variants are not callable\n+                assert!(vinfo.args.len() > 0u);\n+\n+                Callee {\n+                    bcx: bcx,\n+                    data: NamedTupleConstructor(substs, vinfo.disr_val)\n+                }\n             }\n-            def::DefStruct(def_id) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, def_id, ExprId(ref_expr.id)))\n+            def::DefStruct(_) => {\n+                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+                Callee {\n+                    bcx: bcx,\n+                    data: NamedTupleConstructor(substs, 0)\n+                }\n             }\n             def::DefStatic(..) |\n             def::DefArg(..) |\n@@ -490,8 +522,27 @@ pub fn trans_fn_ref_with_vtables(\n         }\n     };\n \n-    // We must monomorphise if the fn has type parameters or is a default method.\n-    let must_monomorphise = !substs.types.is_empty() || is_default;\n+    // We must monomorphise if the fn has type parameters, is a default method,\n+    // or is a named tuple constructor.\n+    let must_monomorphise = if !substs.types.is_empty() || is_default {\n+        true\n+    } else if def_id.krate == ast::LOCAL_CRATE {\n+        let map_node = session::expect(\n+            ccx.sess(),\n+            tcx.map.find(def_id.node),\n+            || \"local item should be in ast map\".to_string());\n+\n+        match map_node {\n+            ast_map::NodeVariant(v) => match v.node.kind {\n+                ast::TupleVariantKind(ref args) => args.len() > 0,\n+                _ => false\n+            },\n+            ast_map::NodeStructCtor(_) => true,\n+            _ => false\n+        }\n+    } else {\n+        false\n+    };\n \n     // Create a monomorphic version of generic functions\n     if must_monomorphise {\n@@ -710,6 +761,14 @@ pub fn trans_call_inner<'a>(\n                                                    arg_cleanup_scope, args,\n                                                    dest.unwrap(), substs);\n         }\n+        NamedTupleConstructor(substs, disr) => {\n+            assert!(dest.is_some());\n+            fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n+\n+            let ctor_ty = callee_ty.subst(bcx.tcx(), &substs);\n+            return base::trans_named_tuple_constructor(bcx, ctor_ty, disr,\n+                                                       args, dest.unwrap());\n+        }\n     };\n \n     // Intrinsics should not become actual functions."}, {"sha": "ed6050b6543bc40c5235c4a624d6736e2600e1bb", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -502,7 +502,6 @@ pub fn trans_unboxed_closure<'a>(\n     let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n \n     // Create the closure.\n-    adt::trans_start_init(bcx, &*repr, dest_addr, 0);\n     for freevar in freevars_ptr.iter() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(bcx,\n@@ -512,6 +511,7 @@ pub fn trans_unboxed_closure<'a>(\n                                                    0);\n         bcx = datum.store_to(bcx, upvar_slot_dest);\n     }\n+    adt::trans_set_discr(bcx, &*repr, dest_addr, 0);\n \n     bcx\n }"}, {"sha": "68f577faefed0521a7295b3ea8d552153e7bf22c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -876,8 +876,8 @@ fn trans_def_dps_unadjusted<'a>(\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_start_init(bcx, &*repr, lldest,\n-                                      variant_info.disr_val);\n+                adt::trans_set_discr(bcx, &*repr, lldest,\n+                                     variant_info.disr_val);\n                 return bcx;\n             }\n         }\n@@ -886,7 +886,7 @@ fn trans_def_dps_unadjusted<'a>(\n             match ty::get(ty).sty {\n                 ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_start_init(bcx, &*repr, lldest, 0);\n+                    adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }\n                 _ => {}\n             }\n@@ -1098,7 +1098,7 @@ fn trans_rec_or_struct<'a>(\n  * Note that `fields` may be empty; the base expression must always be\n  * evaluated for side-effects.\n  */\n-struct StructBaseInfo {\n+pub struct StructBaseInfo {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: Gc<ast::Expr>,\n     /// The indices of fields to copy paired with their types.\n@@ -1114,14 +1114,12 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt<'a>(\n-             bcx: &'a Block<'a>,\n-             repr: &adt::Repr,\n-             discr: ty::Disr,\n-             fields: &[(uint, Gc<ast::Expr>)],\n-             optbase: Option<StructBaseInfo>,\n-             dest: Dest)\n-             -> &'a Block<'a> {\n+pub fn trans_adt<'a>(bcx: &'a Block<'a>,\n+                     repr: &adt::Repr,\n+                     discr: ty::Disr,\n+                     fields: &[(uint, Gc<ast::Expr>)],\n+                     optbase: Option<StructBaseInfo>,\n+                     dest: Dest) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -1143,8 +1141,6 @@ fn trans_adt<'a>(\n     // failure occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    adt::trans_start_init(bcx, repr, addr, discr);\n-\n     for &(i, ref e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty_adjusted(bcx, &**e);\n@@ -1166,6 +1162,8 @@ fn trans_adt<'a>(\n         }\n     }\n \n+    adt::trans_set_discr(bcx, repr, addr, discr);\n+\n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n \n     return bcx;"}, {"sha": "a56904c9ef4db700d0c2917d7f5b531082327488", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0a6e2b41421928206cc71be27da1239b4598ed1/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e0a6e2b41421928206cc71be27da1239b4598ed1", "patch": "@@ -2795,6 +2795,7 @@ mod tests {\n         }\n     }\n     #[test]\n+    #[ignore] // FIXME(#15763)\n     fn test_decode_errors_struct() {\n         check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\","}]}