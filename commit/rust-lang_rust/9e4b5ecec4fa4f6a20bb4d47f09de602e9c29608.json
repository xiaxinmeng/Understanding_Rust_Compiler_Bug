{"sha": "9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNGI1ZWNlYzRmYTRmNmEyMGJiNGQ0N2YwOWRlNjAyZTljMjk2MDg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-19T14:48:55Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-19T15:02:06Z"}, "message": "Make generics work in struct patterns", "tree": {"sha": "b94dd19bc5c2acd05b4de97e27ed4491d54cb78f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b94dd19bc5c2acd05b4de97e27ed4491d54cb78f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "html_url": "https://github.com/rust-lang/rust/commit/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d37bb128effd19e3aec347e3d4f2e27b5cdb9404", "url": "https://api.github.com/repos/rust-lang/rust/commits/d37bb128effd19e3aec347e3d4f2e27b5cdb9404", "html_url": "https://github.com/rust-lang/rust/commit/d37bb128effd19e3aec347e3d4f2e27b5cdb9404"}], "stats": {"total": 104, "additions": 87, "deletions": 17}, "files": [{"sha": "3608daae46d0180777631e37ac9f879e7997c3b4", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "patch": "@@ -683,9 +683,9 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n \n pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Option<Ty> {\n     let def = def_id.resolve(db);\n-    let variant_data = match def {\n-        Def::Struct(s) => s.variant_data(db),\n-        Def::EnumVariant(ev) => ev.variant_data(db),\n+    let (variant_data, generics) = match def {\n+        Def::Struct(s) => (s.variant_data(db), s.generics(db)),\n+        Def::EnumVariant(ev) => (ev.variant_data(db), ev.parent_enum(db).generics(db)),\n         // TODO: unions\n         _ => panic!(\n             \"trying to get type for field in non-struct/variant {:?}\",\n@@ -694,7 +694,6 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n     };\n     let module = def_id.module(db);\n     let impl_block = def_id.impl_block(db);\n-    let generics = db.generics(def_id);\n     let type_ref = variant_data.get_field_type_ref(&field)?;\n     Some(Ty::from_hir(\n         db,\n@@ -893,6 +892,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n+    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs) -> bool {\n+        substs1\n+            .0\n+            .iter()\n+            .zip(substs2.0.iter())\n+            .all(|(t1, t2)| self.unify(t1, t2))\n+    }\n+\n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         // try to resolve type vars first\n         let ty1 = self.resolve_ty_shallow(ty1);\n@@ -913,12 +920,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n             (\n                 Ty::Adt {\n-                    def_id: def_id1, ..\n+                    def_id: def_id1,\n+                    substs: substs1,\n+                    ..\n                 },\n                 Ty::Adt {\n-                    def_id: def_id2, ..\n+                    def_id: def_id2,\n+                    substs: substs2,\n+                    ..\n                 },\n-            ) if def_id1 == def_id2 => true,\n+            ) if def_id1 == def_id2 => self.unify_substs(substs1, substs2),\n             (Ty::Slice(t1), Ty::Slice(t2)) => self.unify(t1, t2),\n             (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n             (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n@@ -1088,49 +1099,65 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    fn resolve_fields(&self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n-        let def_id = self.module.resolve_path(self.db, path?).take_types()?;\n+    fn resolve_fields(&mut self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n+        let (ty, def_id) = self.resolve_variant(path);\n+        let def_id = def_id?;\n         let def = def_id.resolve(self.db);\n \n         match def {\n             Def::Struct(s) => {\n                 let fields = s.fields(self.db);\n-                Some((type_for_struct(self.db, s), fields))\n+                Some((ty, fields))\n             }\n             Def::EnumVariant(ev) => {\n                 let fields = ev.fields(self.db);\n-                Some((type_for_enum_variant(self.db, ev), fields))\n+                Some((ty, fields))\n             }\n             _ => None,\n         }\n     }\n \n-    fn infer_tuple_struct_pat(&mut self, path: Option<&Path>, subpats: &[PatId]) -> Ty {\n+    fn infer_tuple_struct_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[PatId],\n+        expected: &Ty,\n+    ) -> Ty {\n         let (ty, fields) = self\n             .resolve_fields(path)\n             .unwrap_or((Ty::Unknown, Vec::new()));\n \n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().expect(\"adt should have substs\");\n+\n         for (i, &subpat) in subpats.iter().enumerate() {\n             let expected_ty = fields\n                 .get(i)\n                 .and_then(|field| field.ty(self.db))\n-                .unwrap_or(Ty::Unknown);\n+                .unwrap_or(Ty::Unknown)\n+                .subst(&substs);\n             self.infer_pat(subpat, &expected_ty);\n         }\n \n         ty\n     }\n \n-    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat]) -> Ty {\n+    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n         let (ty, fields) = self\n             .resolve_fields(path)\n             .unwrap_or((Ty::Unknown, Vec::new()));\n \n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().expect(\"adt should have substs\");\n+\n         for subpat in subpats {\n             let matching_field = fields.iter().find(|field| field.name() == &subpat.name);\n             let expected_ty = matching_field\n                 .and_then(|field| field.ty(self.db))\n-                .unwrap_or(Ty::Unknown);\n+                .unwrap_or(Ty::Unknown)\n+                .subst(&substs);\n             self.infer_pat(subpat.pat, &expected_ty);\n         }\n \n@@ -1175,11 +1202,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Pat::TupleStruct {\n                 path: ref p,\n                 args: ref subpats,\n-            } => self.infer_tuple_struct_pat(p.as_ref(), subpats),\n+            } => self.infer_tuple_struct_pat(p.as_ref(), subpats, expected),\n             Pat::Struct {\n                 path: ref p,\n                 args: ref fields,\n-            } => self.infer_struct_pat(p.as_ref(), fields),\n+            } => self.infer_struct_pat(p.as_ref(), fields, expected),\n             Pat::Path(path) => self\n                 .module\n                 .resolve_path(self.db, &path)"}, {"sha": "06e32df597017035910348842b0968fb5886ceb0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "patch": "@@ -438,6 +438,32 @@ fn test(a1: A<u32>, i: i32) {\n     );\n }\n \n+#[test]\n+fn infer_generics_in_patterns() {\n+    check_inference(\n+        r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+fn test(a1: A<u32>, o: Option<u64>) {\n+    let A { x: x2 } = a1;\n+    let A::<i64> { x: x3 } = A { x: 1 };\n+    match o {\n+        Option::Some(t) => t,\n+        _ => 1,\n+    };\n+}\n+\"#,\n+        \"generics_in_patterns.txt\",\n+    );\n+}\n+\n #[test]\n fn infer_function_generics() {\n     check_inference("}, {"sha": "1b01ef19ec15e8d224867cd8fd3eb415c8b5cf06", "filename": "crates/ra_hir/src/ty/tests/data/generics_in_patterns.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgenerics_in_patterns.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgenerics_in_patterns.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgenerics_in_patterns.txt?ref=9e4b5ecec4fa4f6a20bb4d47f09de602e9c29608", "patch": "@@ -0,0 +1,17 @@\n+[79; 81) 'a1': A<u32>\n+[91; 92) 'o': Option<u64>\n+[107; 244) '{     ...  }; }': ()\n+[117; 128) 'A { x: x2 }': A<u32>\n+[124; 126) 'x2': u32\n+[131; 133) 'a1': A<u32>\n+[143; 161) 'A::<i6...: x3 }': A<i64>\n+[157; 159) 'x3': i64\n+[164; 174) 'A { x: 1 }': A<i64>\n+[171; 172) '1': i64\n+[180; 241) 'match ...     }': u64\n+[186; 187) 'o': Option<u64>\n+[198; 213) 'Option::Some(t)': Option<u64>\n+[211; 212) 't': u64\n+[217; 218) 't': u64\n+[228; 229) '_': Option<u64>\n+[233; 234) '1': u64"}]}