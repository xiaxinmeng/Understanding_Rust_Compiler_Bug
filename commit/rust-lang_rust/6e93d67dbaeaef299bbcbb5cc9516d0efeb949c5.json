{"sha": "6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOTNkNjdkYmFlYWVmMjk5YmJjYmI1Y2M5NTE2ZDBlZmViOTQ5YzU=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-13T20:47:35Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-13T21:31:28Z"}, "message": "Add more rwlock tests", "tree": {"sha": "5ef46092c5455aa73a944a4ea3d74d93715bb976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ef46092c5455aa73a944a4ea3d74d93715bb976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5", "html_url": "https://github.com/rust-lang/rust/commit/6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "html_url": "https://github.com/rust-lang/rust/commit/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e"}], "stats": {"total": 108, "additions": 92, "deletions": 16}, "files": [{"sha": "5f08cf9128c7f7af262ff53528bbb28e84705f75", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 92, "deletions": 16, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=6e93d67dbaeaef299bbcbb5cc9516d0efeb949c5", "patch": "@@ -783,11 +783,11 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(mode1: rwlock_mode, mode2: rwlock_mode) {\n+    fn test_rwlock_exclusion(x: ~rwlock, mode1: rwlock_mode,\n+                             mode2: rwlock_mode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n         let (c,p) = pipes::stream();\n-        let x = ~rwlock();\n         let x2 = ~x.clone();\n         let sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n@@ -815,23 +815,22 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(read, write);\n-        test_rwlock_exclusion(write, read);\n-        test_rwlock_exclusion(read, downgrade);\n-        test_rwlock_exclusion(downgrade, read);\n+        test_rwlock_exclusion(~rwlock(), read, write);\n+        test_rwlock_exclusion(~rwlock(), write, read);\n+        test_rwlock_exclusion(~rwlock(), read, downgrade);\n+        test_rwlock_exclusion(~rwlock(), downgrade, read);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(write, write);\n-        test_rwlock_exclusion(write, downgrade);\n-        test_rwlock_exclusion(downgrade, write);\n-        test_rwlock_exclusion(downgrade, downgrade);\n+        test_rwlock_exclusion(~rwlock(), write, write);\n+        test_rwlock_exclusion(~rwlock(), write, downgrade);\n+        test_rwlock_exclusion(~rwlock(), downgrade, write);\n+        test_rwlock_exclusion(~rwlock(), downgrade, downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(mode1: rwlock_mode, mode2: rwlock_mode,\n-                             make_mode2_go_first: bool) {\n+    fn test_rwlock_handshake(x: ~rwlock, mode1: rwlock_mode,\n+                             mode2: rwlock_mode, make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n-        let x = ~rwlock();\n         let x2 = ~x.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n@@ -860,14 +859,29 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(read, read, false);\n+        test_rwlock_handshake(~rwlock(), read, read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(downgrade_read, read, false);\n-        test_rwlock_handshake(read, downgrade_read, true);\n+        test_rwlock_handshake(~rwlock(), downgrade_read, read, false);\n+        test_rwlock_handshake(~rwlock(), read, downgrade_read, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n+    fn test_rwlock_downgrade_unlock() {\n+        // Tests that downgrade can unlock the lock in both modes\n+        let x = ~rwlock();\n+        do lock_rwlock_in_mode(x, downgrade) { }\n+        test_rwlock_handshake(x, read, read, false);\n+        let y = ~rwlock();\n+        do lock_rwlock_in_mode(y, downgrade_read) { }\n+        test_rwlock_exclusion(y, write, write);\n+    }\n+    #[test]\n+    fn test_rwlock_read_recursive() {\n+        let x = ~rwlock();\n+        do x.read { do x.read { } }\n+    }\n+    #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = ~rwlock();\n@@ -902,6 +916,53 @@ mod tests {\n         let _ = port.recv(); // Wait until child wakes up\n         do x.read { } // Just for good measure\n     }\n+    #[cfg(test)]\n+    fn test_rwlock_cond_broadcast_helper(num_waiters: uint, dg1: bool,\n+                                         dg2: bool) {\n+        // Much like the mutex broadcast test. Downgrade-enabled.\n+        fn lock_cond(x: &rwlock, downgrade: bool, blk: fn(c: &condvar)) {\n+            if downgrade {\n+                do x.write_downgrade |mode| { mode.write_cond(blk) }\n+            } else {\n+                x.write_cond(blk)\n+            }\n+        }\n+        let x = ~rwlock();\n+        let mut ports = ~[];\n+\n+        for num_waiters.times {\n+            let xi = ~x.clone();\n+            let (chan, port) = pipes::stream();\n+            vec::push(ports, port);\n+            do task::spawn {\n+                do lock_cond(xi, dg1) |cond| {\n+                    chan.send(());\n+                    cond.wait();\n+                    chan.send(());\n+                }\n+            }\n+        }\n+\n+        // wait until all children get in the mutex\n+        for ports.each |port| { let _ = port.recv(); }\n+        do lock_cond(x, dg2) |cond| {\n+            let num_woken = cond.broadcast();\n+            assert num_woken == num_waiters;\n+        }\n+        // wait until all children wake up\n+        for ports.each |port| { let _ = port.recv(); }\n+    }\n+    #[test]\n+    fn test_rwlock_cond_broadcast() {\n+        test_rwlock_cond_broadcast_helper(0, true, true);\n+        test_rwlock_cond_broadcast_helper(0, true, false);\n+        test_rwlock_cond_broadcast_helper(0, false, true);\n+        test_rwlock_cond_broadcast_helper(0, false, false);\n+        test_rwlock_cond_broadcast_helper(12, true, true);\n+        test_rwlock_cond_broadcast_helper(12, true, false);\n+        test_rwlock_cond_broadcast_helper(12, false, true);\n+        test_rwlock_cond_broadcast_helper(12, false, false);\n+    }\n     #[cfg(test)] #[ignore(cfg(windows))]\n     fn rwlock_kill_helper(mode1: rwlock_mode, mode2: rwlock_mode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n@@ -925,6 +986,21 @@ mod tests {\n     fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(read, read ); }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(write,write); }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rwlock_kill_downgrader() {\n+        rwlock_kill_helper(downgrade, read);\n+        rwlock_kill_helper(read, downgrade);\n+        rwlock_kill_helper(downgrade, write);\n+        rwlock_kill_helper(write, downgrade);\n+        rwlock_kill_helper(downgrade_read, read);\n+        rwlock_kill_helper(read, downgrade_read);\n+        rwlock_kill_helper(downgrade_read, write);\n+        rwlock_kill_helper(write, downgrade_read);\n+        rwlock_kill_helper(downgrade_read, downgrade);\n+        rwlock_kill_helper(downgrade_read, downgrade);\n+        rwlock_kill_helper(downgrade, downgrade_read);\n+        rwlock_kill_helper(downgrade, downgrade_read);\n+    }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token."}]}