{"sha": "6a607faba43a818e2a9d63f87316256a963277bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNjA3ZmFiYTQzYTgxOGUyYTlkNjNmODczMTYyNTZhOTYzMjc3YmI=", "commit": {"author": {"name": "Alexey Tarasov", "email": "tarasov@dodologics.com", "date": "2017-08-12T08:43:59Z"}, "committer": {"name": "Alexey Tarasov", "email": "tarasov@dodologics.com", "date": "2017-08-12T08:51:10Z"}, "message": "Follow up commit for the issue 39827\n\n - updates documentation on volatile memory intrinsics, now the case of\n   zero-sized types is mentioned explicitly.\n\nVolatile memory operations which doesn't affect memory at all are omitted\nin LLVM backend, e.g. if number of elements is zero or type used in\ngeneric specialisation is zero-sized, then LLVM intrinsic or related code\nis not generated. This was not explicitly documented before in Rust\ndocumentation and potentially could cause issues.", "tree": {"sha": "7dddaa1975cc9dd71b4e5a56fb8b5ada0daad87e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dddaa1975cc9dd71b4e5a56fb8b5ada0daad87e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a607faba43a818e2a9d63f87316256a963277bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a607faba43a818e2a9d63f87316256a963277bb", "html_url": "https://github.com/rust-lang/rust/commit/6a607faba43a818e2a9d63f87316256a963277bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a607faba43a818e2a9d63f87316256a963277bb/comments", "author": {"login": "taleks", "id": 93178, "node_id": "MDQ6VXNlcjkzMTc4", "avatar_url": "https://avatars.githubusercontent.com/u/93178?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taleks", "html_url": "https://github.com/taleks", "followers_url": "https://api.github.com/users/taleks/followers", "following_url": "https://api.github.com/users/taleks/following{/other_user}", "gists_url": "https://api.github.com/users/taleks/gists{/gist_id}", "starred_url": "https://api.github.com/users/taleks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taleks/subscriptions", "organizations_url": "https://api.github.com/users/taleks/orgs", "repos_url": "https://api.github.com/users/taleks/repos", "events_url": "https://api.github.com/users/taleks/events{/privacy}", "received_events_url": "https://api.github.com/users/taleks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "taleks", "id": 93178, "node_id": "MDQ6VXNlcjkzMTc4", "avatar_url": "https://avatars.githubusercontent.com/u/93178?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taleks", "html_url": "https://github.com/taleks", "followers_url": "https://api.github.com/users/taleks/followers", "following_url": "https://api.github.com/users/taleks/following{/other_user}", "gists_url": "https://api.github.com/users/taleks/gists{/gist_id}", "starred_url": "https://api.github.com/users/taleks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taleks/subscriptions", "organizations_url": "https://api.github.com/users/taleks/orgs", "repos_url": "https://api.github.com/users/taleks/repos", "events_url": "https://api.github.com/users/taleks/events{/privacy}", "received_events_url": "https://api.github.com/users/taleks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cd358742dfcf3fa6b0d8a318cfb5cc748dc905d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cd358742dfcf3fa6b0d8a318cfb5cc748dc905d", "html_url": "https://github.com/rust-lang/rust/commit/0cd358742dfcf3fa6b0d8a318cfb5cc748dc905d"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "ad776c8605ac83cef3dec2ce8194603fa6f1a5f8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a607faba43a818e2a9d63f87316256a963277bb/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a607faba43a818e2a9d63f87316256a963277bb/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6a607faba43a818e2a9d63f87316256a963277bb", "patch": "@@ -1044,20 +1044,23 @@ extern \"rust-intrinsic\" {\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero.\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n                                                   count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero..\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Perform a volatile load from the `src` pointer."}, {"sha": "b37e3a5236d1cec88fc0baa91ae5e6aff47940b5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a607faba43a818e2a9d63f87316256a963277bb/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a607faba43a818e2a9d63f87316256a963277bb/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6a607faba43a818e2a9d63f87316256a963277bb", "patch": "@@ -384,6 +384,12 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// over time. That being said, the semantics will almost always end up pretty\n /// similar to [C11's definition of volatile][c11].\n ///\n+/// Compiler shouldn't change relative order or number of volatile memory\n+/// operations, however this implies that memory operation actually takes place.\n+/// If a zero-sized type is used in a specialisation of `read_volatile`, value\n+/// is known at any time and can not be modified outside of program control.\n+/// In this case such operation may be omitted by compiler backend.\n+///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety\n@@ -427,6 +433,12 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// over time. That being said, the semantics will almost always end up pretty\n /// similar to [C11's definition of volatile][c11].\n ///\n+/// Compiler shouldn't change relative order or number of volatile memory\n+/// operations, however this implies that memory operation actually takes place.\n+/// If a zero-sized type is used in a specialisation of `write_volatile`, value\n+/// is known at any time and can not be modified outside of program control.\n+/// In this case such operation may be omitted by compiler backend.\n+///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety"}]}