{"sha": "7731714578d4ae6eb7a54ead2e51ae032e9a700a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MzE3MTQ1NzhkNGFlNmViN2E1NGVhZDJlNTFhZTAzMmU5YTcwMGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-12T19:05:23Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-12T19:05:23Z"}, "message": "internal: move diagnostics infra to hir", "tree": {"sha": "f8dc2d68cfc72c1fcb839ec85093fb49f479663d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8dc2d68cfc72c1fcb839ec85093fb49f479663d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7731714578d4ae6eb7a54ead2e51ae032e9a700a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7731714578d4ae6eb7a54ead2e51ae032e9a700a", "html_url": "https://github.com/rust-lang/rust/commit/7731714578d4ae6eb7a54ead2e51ae032e9a700a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7731714578d4ae6eb7a54ead2e51ae032e9a700a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6940cfed1e24a67e816e69e1093e04c0eb73e070", "url": "https://api.github.com/repos/rust-lang/rust/commits/6940cfed1e24a67e816e69e1093e04c0eb73e070", "html_url": "https://github.com/rust-lang/rust/commit/6940cfed1e24a67e816e69e1093e04c0eb73e070"}], "stats": {"total": 937, "additions": 417, "deletions": 520}, "files": [{"sha": "8a7c3a4fd6b157700d74ec3db05c1ff3b612b54f", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "patch": "@@ -11,9 +11,8 @@ use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-pub use hir_ty::{\n-    diagnostics::IncorrectCase,\n-    diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder},\n+pub use crate::diagnostics_sink::{\n+    Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n };\n \n // Diagnostic: unresolved-module\n@@ -578,3 +577,33 @@ impl Diagnostic for InternalBailedOut {\n         self\n     }\n }\n+\n+pub use hir_ty::diagnostics::IncorrectCase;\n+\n+impl Diagnostic for IncorrectCase {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"incorrect-ident-case\")\n+    }\n+\n+    fn message(&self) -> String {\n+        format!(\n+            \"{} `{}` should have {} name, e.g. `{}`\",\n+            self.ident_type,\n+            self.ident_text,\n+            self.expected_case.to_string(),\n+            self.suggested_text\n+        )\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.ident.clone().into())\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}"}, {"sha": "084fa8b06aa2c4eb53abcf8ba1cb624c2cc5d640", "filename": "crates/hir/src/diagnostics_sink.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics_sink.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "previous_filename": "crates/hir_ty/src/diagnostics_sink.rs"}, {"sha": "2468c0dc61a77c7485e1f70e4b4a546ffc7c301c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "patch": "@@ -27,6 +27,7 @@ mod attrs;\n mod has_source;\n \n pub mod diagnostics;\n+pub mod diagnostics_sink;\n pub mod db;\n \n mod display;\n@@ -35,13 +36,6 @@ use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n-use diagnostics::{\n-    BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError, MismatchedArgCount,\n-    MissingFields, MissingOkOrSomeInTailExpr, MissingPatFields, MissingUnsafe, NoSuchField,\n-    RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnimplementedBuiltinMacro,\n-    UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-    UnresolvedProcMacro,\n-};\n use either::Either;\n use hir_def::{\n     adt::{ReprKind, VariantData},\n@@ -64,8 +58,7 @@ use hir_ty::{\n     consteval::ConstExt,\n     could_unify,\n     diagnostics::BodyValidationDiagnostic,\n-    diagnostics_sink::DiagnosticSink,\n-    method_resolution::{self, def_crates, TyFingerprint},\n+    method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n     subst_prefix,\n     traits::FnTrait,\n@@ -87,7 +80,14 @@ use tt::{Ident, Leaf, Literal, TokenTree};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    diagnostics::MissingMatchArms,\n+    diagnostics::{\n+        BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError, MismatchedArgCount,\n+        MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr, MissingPatFields,\n+        MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n+        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n+    },\n+    diagnostics_sink::DiagnosticSink,\n };\n \n pub use crate::{\n@@ -361,7 +361,9 @@ impl ModuleDef {\n             None => return,\n         };\n \n-        hir_ty::diagnostics::validate_module_item(db, module.id.krate(), id, sink)\n+        for diag in hir_ty::diagnostics::validate_module_item(db, module.id.krate(), id) {\n+            sink.push(diag)\n+        }\n     }\n }\n \n@@ -1225,7 +1227,9 @@ impl Function {\n             }\n         }\n \n-        hir_ty::diagnostics::validate_module_item(db, krate, self.id.into(), sink);\n+        for diag in hir_ty::diagnostics::validate_module_item(db, krate, self.id.into()) {\n+            sink.push(diag)\n+        }\n     }\n \n     /// Whether this function declaration has a definition.\n@@ -1944,7 +1948,7 @@ impl Impl {\n     }\n \n     pub fn all_for_type(db: &dyn HirDatabase, Type { krate, ty, .. }: Type) -> Vec<Impl> {\n-        let def_crates = match def_crates(db, &ty, krate) {\n+        let def_crates = match method_resolution::def_crates(db, &ty, krate) {\n             Some(def_crates) => def_crates,\n             None => return Vec::new(),\n         };\n@@ -2350,7 +2354,7 @@ impl Type {\n         krate: Crate,\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n-        for krate in def_crates(db, &self.ty, krate.id)? {\n+        for krate in method_resolution::def_crates(db, &self.ty, krate.id)? {\n             let impls = db.inherent_impls_in_crate(krate);\n \n             for impl_def in impls.for_self_ty(&self.ty) {"}, {"sha": "4072739434c7942f7d49086acc83d38ad3d89f22", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 149, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "patch": "@@ -4,17 +4,14 @@ mod match_check;\n mod unsafe_check;\n mod decl_check;\n \n-use std::{any::Any, fmt};\n+use std::fmt;\n \n use base_db::CrateId;\n use hir_def::ModuleDefId;\n-use hir_expand::{HirFileId, InFile};\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use hir_expand::HirFileId;\n+use syntax::{ast, AstPtr};\n \n-use crate::{\n-    db::HirDatabase,\n-    diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink},\n-};\n+use crate::db::HirDatabase;\n \n pub use crate::diagnostics::{\n     expr::{\n@@ -27,11 +24,11 @@ pub fn validate_module_item(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     owner: ModuleDefId,\n-    sink: &mut DiagnosticSink<'_>,\n-) {\n+) -> Vec<IncorrectCase> {\n     let _p = profile::span(\"validate_module_item\");\n-    let mut validator = decl_check::DeclValidator::new(db, krate, sink);\n+    let mut validator = decl_check::DeclValidator::new(db, krate);\n     validator.validate_item(owner);\n+    validator.sink\n }\n \n #[derive(Debug)]\n@@ -99,142 +96,3 @@ pub struct IncorrectCase {\n     pub ident_text: String,\n     pub suggested_text: String,\n }\n-\n-impl Diagnostic for IncorrectCase {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"incorrect-ident-case\")\n-    }\n-\n-    fn message(&self) -> String {\n-        format!(\n-            \"{} `{}` should have {} name, e.g. `{}`\",\n-            self.ident_type,\n-            self.ident_text,\n-            self.expected_case.to_string(),\n-            self.suggested_text\n-        )\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file, self.ident.clone().into())\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n-    use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n-    use hir_expand::db::AstDatabase;\n-    use rustc_hash::FxHashMap;\n-    use syntax::{TextRange, TextSize};\n-\n-    use crate::{\n-        diagnostics::validate_module_item,\n-        diagnostics_sink::{Diagnostic, DiagnosticSinkBuilder},\n-        test_db::TestDB,\n-    };\n-\n-    impl TestDB {\n-        fn diagnostics<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n-            let crate_graph = self.crate_graph();\n-            for krate in crate_graph.iter() {\n-                let crate_def_map = self.crate_def_map(krate);\n-\n-                let mut fns = Vec::new();\n-                for (module_id, _) in crate_def_map.modules() {\n-                    for decl in crate_def_map[module_id].scope.declarations() {\n-                        let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n-                        validate_module_item(self, krate, decl, &mut sink);\n-\n-                        if let ModuleDefId::FunctionId(f) = decl {\n-                            fns.push(f)\n-                        }\n-                    }\n-\n-                    for impl_id in crate_def_map[module_id].scope.impls() {\n-                        let impl_data = self.impl_data(impl_id);\n-                        for item in impl_data.items.iter() {\n-                            if let AssocItemId::FunctionId(f) = item {\n-                                let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n-                                validate_module_item(\n-                                    self,\n-                                    krate,\n-                                    ModuleDefId::FunctionId(*f),\n-                                    &mut sink,\n-                                );\n-                                fns.push(*f)\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n-        let db = TestDB::with_files(ra_fixture);\n-        let annotations = db.extract_annotations();\n-\n-        let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n-        db.diagnostics(|d| {\n-            let src = d.display_source();\n-            let root = db.parse_or_expand(src.file_id).unwrap();\n-            // FIXME: macros...\n-            let file_id = src.file_id.original_file(&db);\n-            let range = src.value.to_node(&root).text_range();\n-            let message = d.message();\n-            actual.entry(file_id).or_default().push((range, message));\n-        });\n-\n-        for (file_id, diags) in actual.iter_mut() {\n-            diags.sort_by_key(|it| it.0.start());\n-            let text = db.file_text(*file_id);\n-            // For multiline spans, place them on line start\n-            for (range, content) in diags {\n-                if text[*range].contains('\\n') {\n-                    *range = TextRange::new(range.start(), range.start() + TextSize::from(1));\n-                    *content = format!(\"... {}\", content);\n-                }\n-            }\n-        }\n-\n-        assert_eq!(annotations, actual);\n-    }\n-\n-    #[test]\n-    fn import_extern_crate_clash_with_inner_item() {\n-        // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n-\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:lib deps:jwt\n-mod permissions;\n-\n-use permissions::jwt;\n-\n-fn f() {\n-    fn inner() {}\n-    jwt::Claims {}; // should resolve to the local one with 0 fields, and not get a diagnostic\n-}\n-\n-//- /permissions.rs\n-pub mod jwt  {\n-    pub struct Claims {}\n-}\n-\n-//- /jwt/lib.rs crate:jwt\n-pub struct Claims {\n-    field: u8,\n-}\n-        \"#,\n-        );\n-    }\n-}"}, {"sha": "ca452e8793e8c81201baf2623dabd32b709773de", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 6, "deletions": 353, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "patch": "@@ -29,7 +29,6 @@ use syntax::{\n use crate::{\n     db::HirDatabase,\n     diagnostics::{decl_check::case_conv::*, CaseType, IdentType, IncorrectCase},\n-    diagnostics_sink::DiagnosticSink,\n };\n \n mod allow {\n@@ -40,10 +39,10 @@ mod allow {\n     pub(super) const NON_CAMEL_CASE_TYPES: &str = \"non_camel_case_types\";\n }\n \n-pub(super) struct DeclValidator<'a, 'b> {\n+pub(super) struct DeclValidator<'a> {\n     db: &'a dyn HirDatabase,\n     krate: CrateId,\n-    sink: &'a mut DiagnosticSink<'b>,\n+    pub(super) sink: Vec<IncorrectCase>,\n }\n \n #[derive(Debug)]\n@@ -53,13 +52,9 @@ struct Replacement {\n     expected_case: CaseType,\n }\n \n-impl<'a, 'b> DeclValidator<'a, 'b> {\n-    pub(super) fn new(\n-        db: &'a dyn HirDatabase,\n-        krate: CrateId,\n-        sink: &'a mut DiagnosticSink<'b>,\n-    ) -> DeclValidator<'a, 'b> {\n-        DeclValidator { db, krate, sink }\n+impl<'a> DeclValidator<'a> {\n+    pub(super) fn new(db: &'a dyn HirDatabase, krate: CrateId) -> DeclValidator<'a> {\n+        DeclValidator { db, krate, sink: Vec::new() }\n     }\n \n     pub(super) fn validate_item(&mut self, item: ModuleDefId) {\n@@ -121,7 +116,6 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     fn validate_func(&mut self, func: FunctionId) {\n         let data = self.db.function_data(func);\n         if data.is_in_extern_block() {\n-            cov_mark::hit!(extern_func_incorrect_case_ignored);\n             return;\n         }\n \n@@ -131,7 +125,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         for (_, block_def_map) in body.blocks(self.db.upcast()) {\n             for (_, module) in block_def_map.modules() {\n                 for def_id in module.scope.declarations() {\n-                    let mut validator = DeclValidator::new(self.db, self.krate, self.sink);\n+                    let mut validator = DeclValidator::new(self.db, self.krate);\n                     validator.validate_item(def_id);\n                 }\n             }\n@@ -578,7 +572,6 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     fn validate_static(&mut self, static_id: StaticId) {\n         let data = self.db.static_data(static_id);\n         if data.is_extern {\n-            cov_mark::hit!(extern_static_incorrect_case_ignored);\n             return;\n         }\n \n@@ -623,343 +616,3 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         self.sink.push(diagnostic);\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn incorrect_function_name() {\n-        check_diagnostics(\n-            r#\"\n-fn NonSnakeCaseName() {}\n-// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_function_params() {\n-        check_diagnostics(\n-            r#\"\n-fn foo(SomeParam: u8) {}\n-    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n-\n-fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n-                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_variable_names() {\n-        check_diagnostics(\n-            r#\"\n-fn foo() {\n-    let SOME_VALUE = 10;\n-     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n-    let AnotherValue = 20;\n-     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_struct_names() {\n-        check_diagnostics(\n-            r#\"\n-struct non_camel_case_name {}\n-    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n-\n-struct SCREAMING_CASE {}\n-    // ^^^^^^^^^^^^^^ Structure `SCREAMING_CASE` should have CamelCase name, e.g. `ScreamingCase`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_camel_cased_acronyms_in_struct_name() {\n-        check_diagnostics(\n-            r#\"\n-struct AABB {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_struct_field() {\n-        check_diagnostics(\n-            r#\"\n-struct SomeStruct { SomeField: u8 }\n-                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_enum_names() {\n-        check_diagnostics(\n-            r#\"\n-enum some_enum { Val(u8) }\n-  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n-\n-enum SOME_ENUM\n-  // ^^^^^^^^^ Enum `SOME_ENUM` should have CamelCase name, e.g. `SomeEnum`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_camel_cased_acronyms_in_enum_name() {\n-        check_diagnostics(\n-            r#\"\n-enum AABB {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_enum_variant_name() {\n-        check_diagnostics(\n-            r#\"\n-enum SomeEnum { SOME_VARIANT(u8) }\n-             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_const_name() {\n-        check_diagnostics(\n-            r#\"\n-const some_weird_const: u8 = 10;\n-   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n-\n-fn func() {\n-    const someConstInFunc: &str = \"hi there\";\n-       // ^^^^^^^^^^^^^^^ Constant `someConstInFunc` should have UPPER_SNAKE_CASE name, e.g. `SOME_CONST_IN_FUNC`\n-\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_static_name() {\n-        check_diagnostics(\n-            r#\"\n-static some_weird_const: u8 = 10;\n-    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n-\n-fn func() {\n-    static someConstInFunc: &str = \"hi there\";\n-        // ^^^^^^^^^^^^^^^ Static variable `someConstInFunc` should have UPPER_SNAKE_CASE name, e.g. `SOME_CONST_IN_FUNC`\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fn_inside_impl_struct() {\n-        check_diagnostics(\n-            r#\"\n-struct someStruct;\n-    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n-\n-impl someStruct {\n-    fn SomeFunc(&self) {\n-    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n-        static someConstInFunc: &str = \"hi there\";\n-            // ^^^^^^^^^^^^^^^ Static variable `someConstInFunc` should have UPPER_SNAKE_CASE name, e.g. `SOME_CONST_IN_FUNC`\n-        let WHY_VAR_IS_CAPS = 10;\n-         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_enum_varinats() {\n-        check_diagnostics(\n-            r#\"\n-enum Option { Some, None }\n-\n-fn main() {\n-    match Option::None {\n-        None => (),\n-        Some => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn non_let_bind() {\n-        check_diagnostics(\n-            r#\"\n-enum Option { Some, None }\n-\n-fn main() {\n-    match Option::None {\n-        SOME_VAR @ None => (),\n-     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n-        Some => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn allow_attributes() {\n-        check_diagnostics(\n-            r#\"\n-#[allow(non_snake_case)]\n-fn NonSnakeCaseName(SOME_VAR: u8) -> u8{\n-    // cov_flags generated output from elsewhere in this file\n-    extern \"C\" {\n-        #[no_mangle]\n-        static lower_case: u8;\n-    }\n-\n-    let OtherVar = SOME_VAR + 1;\n-    OtherVar\n-}\n-\n-#[allow(nonstandard_style)]\n-mod CheckNonstandardStyle {\n-    fn HiImABadFnName() {}\n-}\n-\n-#[allow(bad_style)]\n-mod CheckBadStyle {\n-    fn HiImABadFnName() {}\n-}\n-\n-mod F {\n-    #![allow(non_snake_case)]\n-    fn CheckItWorksWithModAttr(BAD_NAME_HI: u8) {}\n-}\n-\n-#[allow(non_snake_case, non_camel_case_types)]\n-pub struct some_type {\n-    SOME_FIELD: u8,\n-    SomeField: u16,\n-}\n-\n-#[allow(non_upper_case_globals)]\n-pub const some_const: u8 = 10;\n-\n-#[allow(non_upper_case_globals)]\n-pub static SomeStatic: u8 = 10;\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn allow_attributes_crate_attr() {\n-        check_diagnostics(\n-            r#\"\n-#![allow(non_snake_case)]\n-\n-mod F {\n-    fn CheckItWorksWithCrateAttr(BAD_NAME_HI: u8) {}\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn bug_trait_inside_fn() {\n-        // FIXME:\n-        // This is broken, and in fact, should not even be looked at by this\n-        // lint in the first place. There's weird stuff going on in the\n-        // collection phase.\n-        // It's currently being brought in by:\n-        // * validate_func on `a` recursing into modules\n-        // * then it finds the trait and then the function while iterating\n-        //   through modules\n-        // * then validate_func is called on Dirty\n-        // * ... which then proceeds to look at some unknown module taking no\n-        //   attrs from either the impl or the fn a, and then finally to the root\n-        //   module\n-        //\n-        // It should find the attribute on the trait, but it *doesn't even see\n-        // the trait* as far as I can tell.\n-\n-        check_diagnostics(\n-            r#\"\n-trait T { fn a(); }\n-struct U {}\n-impl T for U {\n-    fn a() {\n-        // this comes out of bitflags, mostly\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            const HiImAlsoBad: u8 = 2;\n-            #[inline]\n-            fn Dirty(&self) -> bool {\n-                false\n-            }\n-        }\n-\n-    }\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn bug_traits_arent_checked() {\n-        // FIXME: Traits and functions in traits aren't currently checked by\n-        // r-a, even though rustc will complain about them.\n-        check_diagnostics(\n-            r#\"\n-trait BAD_TRAIT {\n-    // ^^^^^^^^^ Trait `BAD_TRAIT` should have CamelCase name, e.g. `BadTrait`\n-    fn BAD_FUNCTION();\n-    // ^^^^^^^^^^^^ Function `BAD_FUNCTION` should have snake_case name, e.g. `bad_function`\n-    fn BadFunction();\n-    // ^^^^^^^^^^^^ Function `BadFunction` should have snake_case name, e.g. `bad_function`\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn ignores_extern_items() {\n-        cov_mark::check!(extern_func_incorrect_case_ignored);\n-        cov_mark::check!(extern_static_incorrect_case_ignored);\n-        check_diagnostics(\n-            r#\"\n-extern {\n-    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n-    pub static SomeStatic: u8 = 10;\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn infinite_loop_inner_items() {\n-        check_diagnostics(\n-            r#\"\n-fn qualify() {\n-    mod foo {\n-        use super::*;\n-    }\n-}\n-            \"#,\n-        )\n-    }\n-\n-    #[test] // Issue #8809.\n-    fn parenthesized_parameter() {\n-        check_diagnostics(r#\"fn f((O): _) {}\"#)\n-    }\n-}"}, {"sha": "128cae830ffc061816c3f607154360c6c9ba7a30", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "patch": "@@ -21,7 +21,6 @@ mod utils;\n mod walk;\n pub mod db;\n pub mod diagnostics;\n-pub mod diagnostics_sink;\n pub mod display;\n pub mod method_resolution;\n pub mod primitive;"}, {"sha": "e343416317ff19023190a0fb603708fc549aceb3", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7731714578d4ae6eb7a54ead2e51ae032e9a700a/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=7731714578d4ae6eb7a54ead2e51ae032e9a700a", "patch": "@@ -1338,6 +1338,35 @@ fn main() {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn import_extern_crate_clash_with_inner_item() {\n+        // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n+\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:lib deps:jwt\n+mod permissions;\n+\n+use permissions::jwt;\n+\n+fn f() {\n+    fn inner() {}\n+    jwt::Claims {}; // should resolve to the local one with 0 fields, and not get a diagnostic\n+}\n+\n+//- /permissions.rs\n+pub mod jwt  {\n+    pub struct Claims {}\n+}\n+\n+//- /jwt/lib.rs crate:jwt\n+pub struct Claims {\n+    field: u8,\n+}\n+        \"#,\n+        );\n+    }\n }\n \n #[cfg(test)]\n@@ -2245,3 +2274,328 @@ fn main() {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod decl_check_tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn incorrect_function_name() {\n+        check_diagnostics(\n+            r#\"\n+fn NonSnakeCaseName() {}\n+// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_function_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(SomeParam: u8) {}\n+    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n+\n+fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n+                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_variable_names() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let SOME_VALUE = 10;\n+     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n+    let AnotherValue = 20;\n+     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_names() {\n+        check_diagnostics(\n+            r#\"\n+struct non_camel_case_name {}\n+    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n+\n+struct SCREAMING_CASE {}\n+    // ^^^^^^^^^^^^^^ Structure `SCREAMING_CASE` should have CamelCase name, e.g. `ScreamingCase`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_camel_cased_acronyms_in_struct_name() {\n+        check_diagnostics(\n+            r#\"\n+struct AABB {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_field() {\n+        check_diagnostics(\n+            r#\"\n+struct SomeStruct { SomeField: u8 }\n+                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_names() {\n+        check_diagnostics(\n+            r#\"\n+enum some_enum { Val(u8) }\n+  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n+\n+enum SOME_ENUM {}\n+  // ^^^^^^^^^ Enum `SOME_ENUM` should have CamelCase name, e.g. `SomeEnum`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_camel_cased_acronyms_in_enum_name() {\n+        check_diagnostics(\n+            r#\"\n+enum AABB {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_variant_name() {\n+        check_diagnostics(\n+            r#\"\n+enum SomeEnum { SOME_VARIANT(u8) }\n+             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_const_name() {\n+        check_diagnostics(\n+            r#\"\n+const some_weird_const: u8 = 10;\n+   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_static_name() {\n+        check_diagnostics(\n+            r#\"\n+static some_weird_const: u8 = 10;\n+    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_inside_impl_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct someStruct;\n+    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n+\n+impl someStruct {\n+    fn SomeFunc(&self) {\n+    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n+        let WHY_VAR_IS_CAPS = 10;\n+         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_enum_varinats() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        None => (),\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_let_bind() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        SOME_VAR @ None => (),\n+     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_attributes() {\n+        check_diagnostics(\n+            r#\"\n+#[allow(non_snake_case)]\n+fn NonSnakeCaseName(SOME_VAR: u8) -> u8{\n+    // cov_flags generated output from elsewhere in this file\n+    extern \"C\" {\n+        #[no_mangle]\n+        static lower_case: u8;\n+    }\n+\n+    let OtherVar = SOME_VAR + 1;\n+    OtherVar\n+}\n+\n+#[allow(nonstandard_style)]\n+mod CheckNonstandardStyle {\n+    fn HiImABadFnName() {}\n+}\n+\n+#[allow(bad_style)]\n+mod CheckBadStyle {\n+    fn HiImABadFnName() {}\n+}\n+\n+mod F {\n+    #![allow(non_snake_case)]\n+    fn CheckItWorksWithModAttr(BAD_NAME_HI: u8) {}\n+}\n+\n+#[allow(non_snake_case, non_camel_case_types)]\n+pub struct some_type {\n+    SOME_FIELD: u8,\n+    SomeField: u16,\n+}\n+\n+#[allow(non_upper_case_globals)]\n+pub const some_const: u8 = 10;\n+\n+#[allow(non_upper_case_globals)]\n+pub static SomeStatic: u8 = 10;\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_attributes_crate_attr() {\n+        check_diagnostics(\n+            r#\"\n+#![allow(non_snake_case)]\n+\n+mod F {\n+    fn CheckItWorksWithCrateAttr(BAD_NAME_HI: u8) {}\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn bug_trait_inside_fn() {\n+        // FIXME:\n+        // This is broken, and in fact, should not even be looked at by this\n+        // lint in the first place. There's weird stuff going on in the\n+        // collection phase.\n+        // It's currently being brought in by:\n+        // * validate_func on `a` recursing into modules\n+        // * then it finds the trait and then the function while iterating\n+        //   through modules\n+        // * then validate_func is called on Dirty\n+        // * ... which then proceeds to look at some unknown module taking no\n+        //   attrs from either the impl or the fn a, and then finally to the root\n+        //   module\n+        //\n+        // It should find the attribute on the trait, but it *doesn't even see\n+        // the trait* as far as I can tell.\n+\n+        check_diagnostics(\n+            r#\"\n+trait T { fn a(); }\n+struct U {}\n+impl T for U {\n+    fn a() {\n+        // this comes out of bitflags, mostly\n+        #[allow(non_snake_case)]\n+        trait __BitFlags {\n+            const HiImAlsoBad: u8 = 2;\n+            #[inline]\n+            fn Dirty(&self) -> bool {\n+                false\n+            }\n+        }\n+\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn bug_traits_arent_checked() {\n+        // FIXME: Traits and functions in traits aren't currently checked by\n+        // r-a, even though rustc will complain about them.\n+        check_diagnostics(\n+            r#\"\n+trait BAD_TRAIT {\n+    // ^^^^^^^^^ Trait `BAD_TRAIT` should have CamelCase name, e.g. `BadTrait`\n+    fn BAD_FUNCTION();\n+    // ^^^^^^^^^^^^ Function `BAD_FUNCTION` should have snake_case name, e.g. `bad_function`\n+    fn BadFunction();\n+    // ^^^^^^^^^^^^ Function `BadFunction` should have snake_case name, e.g. `bad_function`\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ignores_extern_items() {\n+        check_diagnostics(\n+            r#\"\n+extern {\n+    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n+    pub static SomeStatic: u8 = 10;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn infinite_loop_inner_items() {\n+        check_diagnostics(\n+            r#\"\n+fn qualify() {\n+    mod foo {\n+        use super::*;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test] // Issue #8809.\n+    fn parenthesized_parameter() {\n+        check_diagnostics(r#\"fn f((O): _) {}\"#)\n+    }\n+}"}]}