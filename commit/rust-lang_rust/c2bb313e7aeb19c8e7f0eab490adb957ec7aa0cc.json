{"sha": "c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmIzMTNlN2FlYjE5YzhlN2YwZWFiNDkwYWRiOTU3ZWM3YWEwY2M=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-08-27T13:38:07Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-09-02T11:41:30Z"}, "message": "Add higher docs and remove some unneeded fields", "tree": {"sha": "834414463a1976c82fc9c41a219e3d51a6d44ce2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834414463a1976c82fc9c41a219e3d51a6d44ce2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmEwuGoACgkQHKDfKvWd\naKWVBg/+J18fOHgHK8YA7RG2qeodke5x1K+52Rqrd+8GkPrDskj70nPZVYztEgOt\naLLqhrpTgRGs3KgsHDSdrj6wtksnSezwEy1q+eYqVXG5hZEp054PV2A24Hya5oiz\nRht5urTbBZOdSFLX3TVqng7Gb3kzo9GEjMiXU7Hl7C/aleRP3ojVYqblYJRJe4K6\nqCUzrSvrL5Y5IxNZ4SLuCIurWx/45/B1uXBQeYxr42fnLZmyT5xZzxy74mrshqih\nSbVRlGBKildHI0uzD8U6I1Ou2CvtTjlSK85Uj/TFwR46cEQ8tjz7C11WP+RZsXEl\nY5eBzkkkJYBjNXJg56n7oaBN+GrBP7p67y5q1piq9TcyppIlKrHIUr+u/ig1b1gv\nlkszwBkmHi0DpRi9Lke+6+BNBEztb4vxfnZFGn0b+NNm4UHwq0ZxQGLLw1VOpXMU\nN12jbeVjwtuRRoggIlzmm0yHT4jUBYS/bzJYrGZ6SHIJUB5DkEc1inrpMkp5VttV\ntR8UvfZ2CMiedkl7IRCZSYQUobVUebj6ULE2dd3YWpVDNx6mcgE+LiHuKbNCp7zL\nR4E2OMShWYdVLL3z4CDMhdv3AzVzFHdvS21gJwTZ2XycESzImGcNEDI7nlORVU6d\nAxSUjNzQIW+kpJhf2fEApmYZkG5nOUVXZw8e1OagBcgjZhRwNpU=\n=Q7NU\n-----END PGP SIGNATURE-----", "payload": "tree 834414463a1976c82fc9c41a219e3d51a6d44ce2\nparent c7c2036cb92dae475d7d6ef6b03919fead5bf052\nauthor Cameron Steffen <cam.steffen94@gmail.com> 1630071487 -0500\ncommitter flip1995 <philipp.krones@embecosm.com> 1630582890 +0100\n\nAdd higher docs and remove some unneeded fields\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "html_url": "https://github.com/rust-lang/rust/commit/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7c2036cb92dae475d7d6ef6b03919fead5bf052", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7c2036cb92dae475d7d6ef6b03919fead5bf052", "html_url": "https://github.com/rust-lang/rust/commit/c7c2036cb92dae475d7d6ef6b03919fead5bf052"}], "stats": {"total": 114, "additions": 65, "deletions": 49}, "files": [{"sha": "97cbe2c53ddac430fe000126fe49de44e0b776b7", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "patch": "@@ -580,8 +580,8 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some(higher::While { if_cond, if_then, .. }) = higher::While::hir(expr) {\n-            while_immutable_condition::check(cx, if_cond, if_then);\n+        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+            while_immutable_condition::check(cx, condition, body);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "79527e3bfa92f1b4b790d88319de759db0d8de5d", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "patch": "@@ -14,12 +14,7 @@ use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n-        if let Some(higher::WhileLet {\n-            if_then,\n-            let_pat,\n-            let_expr,\n-            ..\n-        }) = higher::WhileLet::hir(expr);\n+        if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n         if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n         if let Res::Def(_, pat_did) = pat_path.res;"}, {"sha": "05a4a0143195080328d5d06788bb9d1bd75ffdc8", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 62, "deletions": 41, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=c2bb313e7aeb19c8e7f0eab490adb957ec7aa0cc", "patch": "@@ -13,14 +13,19 @@ use rustc_span::{sym, ExpnKind, Span, Symbol};\n /// The essential nodes of a desugared for loop as well as the entire span:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n pub struct ForLoop<'tcx> {\n+    /// `for` loop item\n     pub pat: &'tcx hir::Pat<'tcx>,\n+    /// `IntoIterator` argument\n     pub arg: &'tcx hir::Expr<'tcx>,\n+    /// `for` loop body\n     pub body: &'tcx hir::Expr<'tcx>,\n+    /// entire `for` loop span\n     pub span: Span,\n }\n \n impl<'tcx> ForLoop<'tcx> {\n     #[inline]\n+    /// Parses a desugared `for` loop\n     pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n         if_chain! {\n             if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n@@ -46,14 +51,19 @@ impl<'tcx> ForLoop<'tcx> {\n     }\n }\n \n+/// An `if` expression without `DropTemps`\n pub struct If<'hir> {\n+    /// `if` condition\n     pub cond: &'hir Expr<'hir>,\n-    pub r#else: Option<&'hir Expr<'hir>>,\n+    /// `if` then expression\n     pub then: &'hir Expr<'hir>,\n+    /// `else` expression\n+    pub r#else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> If<'hir> {\n     #[inline]\n+    /// Parses an `if` expression\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(\n             Expr {\n@@ -64,21 +74,27 @@ impl<'hir> If<'hir> {\n             r#else,\n         ) = expr.kind\n         {\n-            Some(Self { cond, r#else, then })\n+            Some(Self { cond, then, r#else })\n         } else {\n             None\n         }\n     }\n }\n \n+/// An `if let` expression\n pub struct IfLet<'hir> {\n+    /// `if let` pattern\n     pub let_pat: &'hir Pat<'hir>,\n+    /// `if let` scrutinee\n     pub let_expr: &'hir Expr<'hir>,\n+    /// `if let` then expression\n     pub if_then: &'hir Expr<'hir>,\n+    /// `if let` else expression\n     pub if_else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> IfLet<'hir> {\n+    /// Parses an `if let` expression\n     pub fn hir(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(\n             Expr {\n@@ -115,7 +131,9 @@ impl<'hir> IfLet<'hir> {\n     }\n }\n \n+/// An `if let` or `match` expression. Useful for lints that trigger on one or the other.\n pub enum IfLetOrMatch<'hir> {\n+    /// Any `match` expression\n     Match(&'hir Expr<'hir>, &'hir [Arm<'hir>], MatchSource),\n     /// scrutinee, pattern, then block, else block\n     IfLet(\n@@ -127,6 +145,7 @@ pub enum IfLetOrMatch<'hir> {\n }\n \n impl<'hir> IfLetOrMatch<'hir> {\n+    /// Parses an `if let` or `match` expression\n     pub fn parse(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n         match expr.kind {\n             ExprKind::Match(expr, arms, source) => Some(Self::Match(expr, arms, source)),\n@@ -142,14 +161,19 @@ impl<'hir> IfLetOrMatch<'hir> {\n     }\n }\n \n+/// An `if` or `if let` expression\n pub struct IfOrIfLet<'hir> {\n+    /// `if` condition that is maybe a `let` expression\n     pub cond: &'hir Expr<'hir>,\n-    pub r#else: Option<&'hir Expr<'hir>>,\n+    /// `if` then expression\n     pub then: &'hir Expr<'hir>,\n+    /// `else` expression\n+    pub r#else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> IfOrIfLet<'hir> {\n     #[inline]\n+    /// Parses an `if` or `if let` expression\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(cond, then, r#else) = expr.kind {\n             if let ExprKind::DropTemps(new_cond) = cond.kind {\n@@ -160,7 +184,7 @@ impl<'hir> IfOrIfLet<'hir> {\n                 });\n             }\n             if let ExprKind::Let(..) = cond.kind {\n-                return Some(Self { cond, r#else, then });\n+                return Some(Self { cond, then, r#else });\n             }\n         }\n         None\n@@ -281,14 +305,17 @@ impl<'a> VecArgs<'a> {\n     }\n }\n \n+/// A desugared `while` loop\n pub struct While<'hir> {\n-    pub if_cond: &'hir Expr<'hir>,\n-    pub if_then: &'hir Expr<'hir>,\n-    pub if_else: Option<&'hir Expr<'hir>>,\n+    /// `while` loop condition\n+    pub condition: &'hir Expr<'hir>,\n+    /// `while` loop body\n+    pub body: &'hir Expr<'hir>,\n }\n \n impl<'hir> While<'hir> {\n     #[inline]\n+    /// Parses a desugared `while` loop\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::Loop(\n             Block {\n@@ -297,11 +324,11 @@ impl<'hir> While<'hir> {\n                         kind:\n                             ExprKind::If(\n                                 Expr {\n-                                    kind: ExprKind::DropTemps(if_cond),\n+                                    kind: ExprKind::DropTemps(condition),\n                                     ..\n                                 },\n-                                if_then,\n-                                if_else_ref,\n+                                body,\n+                                _,\n                             ),\n                         ..\n                     }),\n@@ -312,59 +339,53 @@ impl<'hir> While<'hir> {\n             _,\n         ) = expr.kind\n         {\n-            let if_else = *if_else_ref;\n-            return Some(Self {\n-                if_cond,\n-                if_then,\n-                if_else,\n-            });\n+            return Some(Self { condition, body });\n         }\n         None\n     }\n }\n \n+/// A desugared `while let` loop\n pub struct WhileLet<'hir> {\n-    pub if_expr: &'hir Expr<'hir>,\n+    /// `while let` loop item pattern\n     pub let_pat: &'hir Pat<'hir>,\n+    /// `while let` loop scrutinee\n     pub let_expr: &'hir Expr<'hir>,\n+    /// `while let` loop body\n     pub if_then: &'hir Expr<'hir>,\n-    pub if_else: Option<&'hir Expr<'hir>>,\n }\n \n impl<'hir> WhileLet<'hir> {\n     #[inline]\n+    /// Parses a desugared `while let` loop\n     pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::Loop(\n             Block {\n-                expr: Some(if_expr), ..\n+                expr:\n+                    Some(Expr {\n+                        kind:\n+                            ExprKind::If(\n+                                Expr {\n+                                    kind: ExprKind::Let(let_pat, let_expr, _),\n+                                    ..\n+                                },\n+                                if_then,\n+                                _,\n+                            ),\n+                        ..\n+                    }),\n+                ..\n             },\n             _,\n             LoopSource::While,\n             _,\n         ) = expr.kind\n         {\n-            if let Expr {\n-                kind:\n-                    ExprKind::If(\n-                        Expr {\n-                            kind: ExprKind::Let(let_pat, let_expr, _),\n-                            ..\n-                        },\n-                        if_then,\n-                        if_else_ref,\n-                    ),\n-                ..\n-            } = if_expr\n-            {\n-                let if_else = *if_else_ref;\n-                return Some(Self {\n-                    if_expr,\n-                    let_pat,\n-                    let_expr,\n-                    if_then,\n-                    if_else,\n-                });\n-            }\n+            return Some(Self {\n+                let_pat,\n+                let_expr,\n+                if_then,\n+            });\n         }\n         None\n     }"}]}