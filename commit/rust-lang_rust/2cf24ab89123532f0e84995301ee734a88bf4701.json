{"sha": "2cf24ab89123532f0e84995301ee734a88bf4701", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZjI0YWI4OTEyMzUzMmYwZTg0OTk1MzAxZWU3MzRhODhiZjQ3MDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-21T15:29:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-21T15:29:18Z"}, "message": "Auto merge of #65672 - ecstatic-morse:unified-dataflow-proto, r=pnkfelix\n\nA single framework for gen-kill and generic dataflow problems\n\nThis is the prototype implementation discussed in rust-lang/compiler-team#202. You can read a high-level description of it in [the proposal](https://hackmd.io/@39Qr_z9cQhasi25sGjmFnA/Skvd9rztS) for that design meeting. This would eventually supersede the existing `BitDenotation` interface.\n\nr? @ghost\n\ncc @rust-lang/compiler (esp. @eddyb and @pnkfelix)", "tree": {"sha": "a5a5ecd488d56781a4e3ff1634545444ec2f4b47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5a5ecd488d56781a4e3ff1634545444ec2f4b47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cf24ab89123532f0e84995301ee734a88bf4701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cf24ab89123532f0e84995301ee734a88bf4701", "html_url": "https://github.com/rust-lang/rust/commit/2cf24ab89123532f0e84995301ee734a88bf4701", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cf24ab89123532f0e84995301ee734a88bf4701/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce361fb24f0896bf7d983549117cbe1f70f32dcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce361fb24f0896bf7d983549117cbe1f70f32dcf", "html_url": "https://github.com/rust-lang/rust/commit/ce361fb24f0896bf7d983549117cbe1f70f32dcf"}, {"sha": "7b4dca282a0bfad265238d04b22f7bdb0d498d74", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4dca282a0bfad265238d04b22f7bdb0d498d74", "html_url": "https://github.com/rust-lang/rust/commit/7b4dca282a0bfad265238d04b22f7bdb0d498d74"}], "stats": {"total": 2545, "additions": 1824, "deletions": 721}, "files": [{"sha": "3a7c650c4618c1df20a0b7e8645ab8254bf6d5c4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -215,6 +215,31 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n+    /// Returns a partially initialized MIR body containing only a list of basic blocks.\n+    ///\n+    /// The returned MIR contains no `LocalDecl`s (even for the return place) or source scopes. It\n+    /// is only useful for testing but cannot be `#[cfg(test)]` because it is used in a different\n+    /// crate.\n+    pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n+        Body {\n+            phase: MirPhase::Build,\n+            basic_blocks,\n+            source_scopes: IndexVec::new(),\n+            yield_ty: None,\n+            generator_drop: None,\n+            generator_layout: None,\n+            local_decls: IndexVec::new(),\n+            user_type_annotations: IndexVec::new(),\n+            arg_count: 0,\n+            spread_arg: None,\n+            span: DUMMY_SP,\n+            control_flow_destroyed: Vec::new(),\n+            generator_kind: None,\n+            var_debug_info: Vec::new(),\n+            ignore_interior_mut_in_const_validation: false,\n+        }\n+    }\n+\n     #[inline]\n     pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n         &self.basic_blocks"}, {"sha": "d2ca4f1572c1f6a3d53fc34a3f664bf2252e5537", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "removed", "additions": 0, "deletions": 595, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/ce361fb24f0896bf7d983549117cbe1f70f32dcf/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce361fb24f0896bf7d983549117cbe1f70f32dcf/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=ce361fb24f0896bf7d983549117cbe1f70f32dcf", "patch": "@@ -1,595 +0,0 @@\n-//! Dataflow analysis with arbitrary transfer functions.\n-//!\n-//! This module is a work in progress. You should instead use `BitDenotation` in\n-//! `librustc_mir/dataflow/mod.rs` and encode your transfer function as a [gen/kill set][gk]. In\n-//! doing so, your analysis will run faster and you will be able to generate graphviz diagrams for\n-//! debugging with no extra effort. The interface in this module is intended only for dataflow\n-//! problems that cannot be expressed using gen/kill sets.\n-//!\n-//! FIXME(ecstaticmorse): In the long term, the plan is to preserve the existing `BitDenotation`\n-//! interface, but make `Engine` and `ResultsCursor` the canonical way to perform and inspect a\n-//! dataflow analysis. This requires porting the graphviz debugging logic to this module, deciding\n-//! on a way to handle the `before` methods in `BitDenotation` and creating an adapter so that\n-//! gen-kill problems can still be evaluated efficiently. See the discussion in [#64566] for more\n-//! information.\n-//!\n-//! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n-//! [#64566]: https://github.com/rust-lang/rust/pull/64566\n-\n-use std::borrow::Borrow;\n-use std::cmp::Ordering;\n-use std::ffi::OsString;\n-use std::path::{Path, PathBuf};\n-use std::{fs, io, ops};\n-\n-use rustc::mir::{self, traversal, BasicBlock, Location};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_span::symbol::sym;\n-\n-use crate::dataflow::BottomValue;\n-\n-mod graphviz;\n-\n-/// A specific kind of dataflow analysis.\n-///\n-/// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n-/// `initialize_start_block` and define a transfer function for each statement or terminator via\n-/// the various `effect` methods. The entry set for all other basic blocks is initialized to\n-/// `Self::BOTTOM_VALUE`. The dataflow `Engine` then iteratively updates the various entry sets for\n-/// each block with the cumulative effects of the transfer functions of all preceding blocks.\n-///\n-/// You should use an `Engine` to actually run an analysis, and a `ResultsCursor` to inspect the\n-/// results of that analysis like so:\n-///\n-/// ```ignore(cross-crate-imports)\n-/// fn do_my_analysis(body: &mir::Body<'tcx>, dead_unwinds: &BitSet<BasicBlock>) {\n-///     // `MyAnalysis` implements `Analysis`.\n-///     let analysis = MyAnalysis::new();\n-///\n-///     let results = Engine::new(body, dead_unwinds, analysis).iterate_to_fixpoint();\n-///     let mut cursor = ResultsCursor::new(body, results);\n-///\n-///     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n-///         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n-///         let state = cursor.get();\n-///         println!(\"{:?}\", state);\n-///     }\n-/// }\n-/// ```\n-pub trait Analysis<'tcx>: BottomValue {\n-    /// The index type used to access the dataflow state.\n-    type Idx: Idx;\n-\n-    /// A name, used for debugging, that describes this dataflow analysis.\n-    ///\n-    /// The name should be suitable as part of a filename, so avoid whitespace, slashes or periods\n-    /// and try to keep it short.\n-    const NAME: &'static str;\n-\n-    /// How each element of your dataflow state will be displayed during debugging.\n-    ///\n-    /// By default, this is the `fmt::Debug` representation of `Self::Idx`.\n-    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n-        write!(w, \"{:?}\", idx)\n-    }\n-\n-    /// The size of each bitvector allocated for each block.\n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n-\n-    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n-    /// analysis.\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n-\n-    /// Updates the current dataflow state with the effect of evaluating a statement.\n-    fn apply_statement_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        statement: &mir::Statement<'tcx>,\n-        location: Location,\n-    );\n-\n-    /// Updates the current dataflow state with the effect of evaluating a terminator.\n-    ///\n-    /// Note that the effect of a successful return from a `Call` terminator should **not** be\n-    /// acounted for in this function. That should go in `apply_call_return_effect`. For example,\n-    /// in the `InitializedPlaces` analyses, the return place is not marked as initialized here.\n-    fn apply_terminator_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        location: Location,\n-    );\n-\n-    /// Updates the current dataflow state with the effect of a successful return from a `Call`\n-    /// terminator.\n-    ///\n-    /// This is separated from `apply_terminator_effect` to properly track state across\n-    /// unwind edges for `Call`s.\n-    fn apply_call_return_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n-        func: &mir::Operand<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n-        return_place: &mir::Place<'tcx>,\n-    );\n-\n-    /// Applies the cumulative effect of an entire basic block to the dataflow state (except for\n-    /// `call_return_effect`, which is handled in the `Engine`).\n-    ///\n-    /// The default implementation calls `statement_effect` for every statement in the block before\n-    /// finally calling `terminator_effect`. However, some dataflow analyses are able to coalesce\n-    /// transfer functions for an entire block and apply them at once. Such analyses should\n-    /// override `block_effect`.\n-    fn apply_whole_block_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n-        block_data: &mir::BasicBlockData<'tcx>,\n-    ) {\n-        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n-            let location = Location { block, statement_index };\n-            self.apply_statement_effect(state, stmt, location);\n-        }\n-\n-        let location = Location { block, statement_index: block_data.statements.len() };\n-        self.apply_terminator_effect(state, block_data.terminator(), location);\n-    }\n-\n-    /// Applies the cumulative effect of a sequence of statements (and possibly a terminator)\n-    /// within a single basic block.\n-    ///\n-    /// When called with `0..block_data.statements.len() + 1` as the statement range, this function\n-    /// is equivalent to `apply_whole_block_effect`.\n-    fn apply_partial_block_effect(\n-        &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n-        block_data: &mir::BasicBlockData<'tcx>,\n-        mut range: ops::Range<usize>,\n-    ) {\n-        if range.is_empty() {\n-            return;\n-        }\n-\n-        // The final location might be a terminator, so iterate through all statements until the\n-        // final one, then check to see whether the final one is a statement or terminator.\n-        //\n-        // This can't cause the range to wrap-around since we check that the range contains at\n-        // least one element above.\n-        range.end -= 1;\n-        let final_location = Location { block, statement_index: range.end };\n-\n-        for statement_index in range {\n-            let location = Location { block, statement_index };\n-            let stmt = &block_data.statements[statement_index];\n-            self.apply_statement_effect(state, stmt, location);\n-        }\n-\n-        if final_location.statement_index == block_data.statements.len() {\n-            let terminator = block_data.terminator();\n-            self.apply_terminator_effect(state, terminator, final_location);\n-        } else {\n-            let stmt = &block_data.statements[final_location.statement_index];\n-            self.apply_statement_effect(state, stmt, final_location);\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-enum CursorPosition {\n-    AtBlockStart(BasicBlock),\n-    After(Location),\n-}\n-\n-impl CursorPosition {\n-    fn block(&self) -> BasicBlock {\n-        match *self {\n-            Self::AtBlockStart(block) => block,\n-            Self::After(Location { block, .. }) => block,\n-        }\n-    }\n-}\n-\n-type ResultsRefCursor<'a, 'mir, 'tcx, A> = ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n-\n-/// Inspect the results of dataflow analysis.\n-///\n-/// This cursor has linear performance when visiting statements in a block in order. Visiting\n-/// statements within a block in reverse order is `O(n^2)`, where `n` is the number of statements\n-/// in that block.\n-pub struct ResultsCursor<'mir, 'tcx, A, R = Results<'tcx, A>>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    body: &'mir mir::Body<'tcx>,\n-    results: R,\n-    state: BitSet<A::Idx>,\n-\n-    pos: CursorPosition,\n-\n-    /// Whether the effects of `apply_call_return_effect` are currently stored in `state`.\n-    ///\n-    /// This flag ensures that multiple calls to `seek_after_assume_call_returns` with the same\n-    /// target only result in one invocation of `apply_call_return_effect`.\n-    is_call_return_effect_applied: bool,\n-}\n-\n-impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n-where\n-    A: Analysis<'tcx>,\n-    R: Borrow<Results<'tcx, A>>,\n-{\n-    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n-    pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n-        ResultsCursor {\n-            body,\n-            pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n-            is_call_return_effect_applied: false,\n-            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n-            results,\n-        }\n-    }\n-\n-    pub fn analysis(&self) -> &A {\n-        &self.results.borrow().analysis\n-    }\n-\n-    /// Resets the cursor to the start of the given `block`.\n-    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n-        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n-        self.pos = CursorPosition::AtBlockStart(block);\n-        self.is_call_return_effect_applied = false;\n-    }\n-\n-    /// Updates the cursor to hold the dataflow state immediately before `target`.\n-    pub fn seek_before(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        if target.statement_index == 0 {\n-            self.seek_to_block_start(target.block);\n-        } else {\n-            self._seek_after(Location {\n-                block: target.block,\n-                statement_index: target.statement_index - 1,\n-            });\n-        }\n-    }\n-\n-    /// Updates the cursor to hold the dataflow state at `target`.\n-    ///\n-    /// If `target` is a `Call` terminator, `apply_call_return_effect` will not be called. See\n-    /// `seek_after_assume_call_returns` if you wish to observe the dataflow state upon a\n-    /// successful return.\n-    pub fn seek_after(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        // This check ensures the correctness of a call to `seek_after_assume_call_returns`\n-        // followed by one to `seek_after` with the same target.\n-        if self.is_call_return_effect_applied {\n-            self.seek_to_block_start(target.block);\n-        }\n-\n-        self._seek_after(target);\n-    }\n-\n-    /// Equivalent to `seek_after`, but also calls `apply_call_return_effect` if `target` is a\n-    /// `Call` terminator whose callee is convergent.\n-    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        self._seek_after(target);\n-\n-        if target != self.body.terminator_loc(target.block) {\n-            return;\n-        }\n-\n-        let term = self.body.basic_blocks()[target.block].terminator();\n-        if let mir::TerminatorKind::Call {\n-            destination: Some((return_place, _)), func, args, ..\n-        } = &term.kind\n-        {\n-            if !self.is_call_return_effect_applied {\n-                self.is_call_return_effect_applied = true;\n-                self.results.borrow().analysis.apply_call_return_effect(\n-                    &mut self.state,\n-                    target.block,\n-                    func,\n-                    args,\n-                    return_place,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn _seek_after(&mut self, target: Location) {\n-        let Location { block: target_block, statement_index: target_index } = target;\n-\n-        if self.pos.block() != target_block {\n-            self.seek_to_block_start(target_block);\n-        }\n-\n-        // If we're in the same block but after the target statement, we need to reset to the start\n-        // of the block.\n-        if let CursorPosition::After(Location { statement_index: curr_index, .. }) = self.pos {\n-            match curr_index.cmp(&target_index) {\n-                Ordering::Equal => return,\n-                Ordering::Less => {}\n-                Ordering::Greater => self.seek_to_block_start(target_block),\n-            }\n-        }\n-\n-        // The cursor is now in the same block as the target location pointing at an earlier\n-        // statement.\n-        debug_assert_eq!(self.pos.block(), target_block);\n-        if let CursorPosition::After(Location { statement_index, .. }) = self.pos {\n-            debug_assert!(statement_index < target_index);\n-        }\n-\n-        let first_unapplied_statement = match self.pos {\n-            CursorPosition::AtBlockStart(_) => 0,\n-            CursorPosition::After(Location { statement_index, .. }) => statement_index + 1,\n-        };\n-\n-        let block_data = &self.body.basic_blocks()[target_block];\n-        self.results.borrow().analysis.apply_partial_block_effect(\n-            &mut self.state,\n-            target_block,\n-            block_data,\n-            first_unapplied_statement..target_index + 1,\n-        );\n-\n-        self.pos = CursorPosition::After(target);\n-        self.is_call_return_effect_applied = false;\n-    }\n-\n-    /// Gets the dataflow state at the current location.\n-    pub fn get(&self) -> &BitSet<A::Idx> {\n-        &self.state\n-    }\n-}\n-\n-/// A completed dataflow analysis.\n-pub struct Results<'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    analysis: A,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n-}\n-\n-/// All information required to iterate a dataflow analysis to fixpoint.\n-pub struct Engine<'a, 'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    analysis: A,\n-    bits_per_block: usize,\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n-    def_id: DefId,\n-    dead_unwinds: &'a BitSet<BasicBlock>,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n-}\n-\n-impl<A> Engine<'a, 'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n-        def_id: DefId,\n-        dead_unwinds: &'a BitSet<BasicBlock>,\n-        analysis: A,\n-    ) -> Self {\n-        let bits_per_block = analysis.bits_per_block(body);\n-\n-        let bottom_value_set = if A::BOTTOM_VALUE == true {\n-            BitSet::new_filled(bits_per_block)\n-        } else {\n-            BitSet::new_empty(bits_per_block)\n-        };\n-\n-        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n-        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n-\n-        Engine { analysis, bits_per_block, tcx, body, def_id, dead_unwinds, entry_sets }\n-    }\n-\n-    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n-        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n-\n-        let mut dirty_queue: WorkQueue<BasicBlock> =\n-            WorkQueue::with_none(self.body.basic_blocks().len());\n-\n-        for (bb, _) in traversal::reverse_postorder(self.body) {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        for bb in self.body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        while let Some(bb) = dirty_queue.pop() {\n-            let bb_data = &self.body[bb];\n-            let on_entry = &self.entry_sets[bb];\n-\n-            temp_state.overwrite(on_entry);\n-            self.analysis.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n-\n-            self.propagate_bits_into_graph_successors_of(\n-                &mut temp_state,\n-                (bb, bb_data),\n-                &mut dirty_queue,\n-            );\n-        }\n-\n-        let Engine { tcx, body, def_id, analysis, entry_sets, .. } = self;\n-\n-        let results = Results { analysis, entry_sets };\n-\n-        let attrs = tcx.get_attrs(def_id);\n-        if let Some(path) = get_dataflow_graphviz_output_path(tcx, attrs, A::NAME) {\n-            let result = write_dataflow_graphviz_results(body, def_id, &path, &results);\n-            if let Err(e) = result {\n-                warn!(\"Failed to write dataflow results to {}: {}\", path.display(), e);\n-            }\n-        }\n-\n-        results\n-    }\n-\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        match bb_data.terminator().kind {\n-            mir::TerminatorKind::Return\n-            | mir::TerminatorKind::Resume\n-            | mir::TerminatorKind::Abort\n-            | mir::TerminatorKind::GeneratorDrop\n-            | mir::TerminatorKind::Unreachable => {}\n-\n-            mir::TerminatorKind::Goto { target }\n-            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n-            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n-            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n-            {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-\n-            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-            }\n-\n-            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n-            | mir::TerminatorKind::DropAndReplace {\n-                target,\n-                value: _,\n-                location: _,\n-                unwind: Some(unwind),\n-            } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if !self.dead_unwinds.contains(bb) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-\n-            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n-                }\n-            }\n-\n-            mir::TerminatorKind::Call { cleanup, ref destination, ref func, ref args, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-\n-                if let Some((ref dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-\n-            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-\n-            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<A::Idx>,\n-        bb: BasicBlock,\n-        dirty_queue: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        let entry_set = &mut self.entry_sets[bb];\n-        let set_changed = self.analysis.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-}\n-\n-/// Looks for attributes like `#[rustc_mir(borrowck_graphviz_postflow=\"./path/to/suffix.dot\")]` and\n-/// extracts the path with the given analysis name prepended to the suffix.\n-///\n-/// Returns `None` if no such attribute exists.\n-fn get_dataflow_graphviz_output_path(\n-    tcx: TyCtxt<'tcx>,\n-    attrs: ty::Attributes<'tcx>,\n-    analysis: &str,\n-) -> Option<PathBuf> {\n-    let mut rustc_mir_attrs = attrs\n-        .into_iter()\n-        .filter(|attr| attr.check_name(sym::rustc_mir))\n-        .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n-\n-    let borrowck_graphviz_postflow =\n-        rustc_mir_attrs.find(|attr| attr.check_name(sym::borrowck_graphviz_postflow))?;\n-\n-    let path_and_suffix = match borrowck_graphviz_postflow.value_str() {\n-        Some(p) => p,\n-        None => {\n-            tcx.sess.span_err(\n-                borrowck_graphviz_postflow.span(),\n-                \"borrowck_graphviz_postflow requires a path\",\n-            );\n-\n-            return None;\n-        }\n-    };\n-\n-    // Change \"path/suffix.dot\" to \"path/analysis_name_suffix.dot\"\n-    let mut ret = PathBuf::from(path_and_suffix.to_string());\n-    let suffix = ret.file_name().unwrap();\n-\n-    let mut file_name: OsString = analysis.into();\n-    file_name.push(\"_\");\n-    file_name.push(suffix);\n-    ret.set_file_name(file_name);\n-\n-    Some(ret)\n-}\n-\n-fn write_dataflow_graphviz_results<A: Analysis<'tcx>>(\n-    body: &mir::Body<'tcx>,\n-    def_id: DefId,\n-    path: &Path,\n-    results: &Results<'tcx, A>,\n-) -> io::Result<()> {\n-    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n-\n-    let mut buf = Vec::new();\n-    let graphviz = graphviz::Formatter::new(body, def_id, results);\n-\n-    dot::render(&graphviz, &mut buf)?;\n-    fs::write(path, buf)\n-}"}, {"sha": "d2eff494ad701b4b963d64288c9bbe46f91603bf", "filename": "src/librustc_mir/dataflow/generic/cursor.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fcursor.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -0,0 +1,265 @@\n+//! Random access inspection of the results of a dataflow analysis.\n+\n+use std::borrow::Borrow;\n+\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc_index::bit_set::BitSet;\n+\n+use super::{Analysis, Results};\n+\n+/// A `ResultsCursor` that borrows the underlying `Results`.\n+pub type ResultsRefCursor<'a, 'mir, 'tcx, A> = ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n+\n+/// Allows random access inspection of the results of a dataflow analysis.\n+///\n+/// This cursor only has linear performance within a basic block when its statements are visited in\n+/// order. In the worst case\u2014when statements are visited in *reverse* order\u2014performance will be\n+/// quadratic in the number of statements in the block. The order in which basic blocks are\n+/// inspected has no impact on performance.\n+///\n+/// A `ResultsCursor` can either own (the default) or borrow the dataflow results it inspects. The\n+/// type of ownership is determined by `R` (see `ResultsRefCursor` above).\n+pub struct ResultsCursor<'mir, 'tcx, A, R = Results<'tcx, A>>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'mir mir::Body<'tcx>,\n+    results: R,\n+    state: BitSet<A::Idx>,\n+\n+    pos: CursorPosition,\n+\n+    /// When this flag is set, the cursor is pointing at a `Call` terminator whose call return\n+    /// effect has been applied to `state`.\n+    ///\n+    /// This flag helps to ensure that multiple calls to `seek_after_assume_call_returns` with the\n+    /// same target will result in exactly one invocation of `apply_call_return_effect`. It is\n+    /// sufficient to clear this only in `seek_to_block_start`, since seeking away from a\n+    /// terminator will always require a cursor reset.\n+    call_return_effect_applied: bool,\n+}\n+\n+impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n+where\n+    A: Analysis<'tcx>,\n+    R: Borrow<Results<'tcx, A>>,\n+{\n+    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n+        ResultsCursor {\n+            body,\n+            pos: CursorPosition::BlockStart(mir::START_BLOCK),\n+            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n+            call_return_effect_applied: false,\n+            results,\n+        }\n+    }\n+\n+    /// Returns the `Analysis` used to generate the underlying results.\n+    pub fn analysis(&self) -> &A {\n+        &self.results.borrow().analysis\n+    }\n+\n+    /// Returns the dataflow state at the current location.\n+    pub fn get(&self) -> &BitSet<A::Idx> {\n+        &self.state\n+    }\n+\n+    /// Resets the cursor to the start of the given basic block.\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n+        self.pos = CursorPosition::BlockStart(block);\n+        self.call_return_effect_applied = false;\n+    }\n+\n+    /// Advances the cursor to hold all effects up to and including to the \"before\" effect of the\n+    /// statement (or terminator) at the given location.\n+    ///\n+    /// If you wish to observe the full effect of a statement or terminator, not just the \"before\"\n+    /// effect, use `seek_after` or `seek_after_assume_call_returns`.\n+    pub fn seek_before(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+        self.seek_(target, false);\n+    }\n+\n+    /// Advances the cursor to hold the full effect of all statements (and possibly closing\n+    /// terminators) up to and including the `target`.\n+    ///\n+    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n+    /// **not** be observed. Use `seek_after_assume_call_returns` if you wish to observe the call\n+    /// return effect.\n+    pub fn seek_after(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        // If we have already applied the call return effect, we are currently pointing at a `Call`\n+        // terminator. Unconditionally reset the dataflow cursor, since there is no way to \"undo\"\n+        // the call return effect.\n+        if self.call_return_effect_applied {\n+            self.seek_to_block_start(target.block);\n+        }\n+\n+        self.seek_(target, true);\n+    }\n+\n+    /// Advances the cursor to hold all effects up to and including of the statement (or\n+    /// terminator) at the given location.\n+    ///\n+    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n+    /// be observed. Use `seek_after` if you do **not** wish to observe the call return effect.\n+    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+        let terminator_loc = self.body.terminator_loc(target.block);\n+        assert!(target.statement_index <= terminator_loc.statement_index);\n+\n+        self.seek_(target, true);\n+\n+        if target != terminator_loc {\n+            return;\n+        }\n+\n+        let terminator = self.body.basic_blocks()[target.block].terminator();\n+        if let mir::TerminatorKind::Call {\n+            destination: Some((return_place, _)), func, args, ..\n+        } = &terminator.kind\n+        {\n+            if !self.call_return_effect_applied {\n+                self.call_return_effect_applied = true;\n+                self.results.borrow().analysis.apply_call_return_effect(\n+                    &mut self.state,\n+                    target.block,\n+                    func,\n+                    args,\n+                    return_place,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn seek_(&mut self, target: Location, apply_after_effect_at_target: bool) {\n+        use CursorPosition::*;\n+\n+        match self.pos {\n+            // Return early if we are already at the target location.\n+            Before(curr) if curr == target && !apply_after_effect_at_target => return,\n+            After(curr) if curr == target && apply_after_effect_at_target => return,\n+\n+            // Otherwise, we must reset to the start of the target block if...\n+\n+            // we are in a different block entirely.\n+            BlockStart(block) | Before(Location { block, .. }) | After(Location { block, .. })\n+                if block != target.block =>\n+            {\n+                self.seek_to_block_start(target.block)\n+            }\n+\n+            // we are in the same block but have advanced past the target statement.\n+            Before(curr) | After(curr) if curr.statement_index > target.statement_index => {\n+                self.seek_to_block_start(target.block)\n+            }\n+\n+            // we have already applied the entire effect of a statement but only wish to observe\n+            // its \"before\" effect.\n+            After(curr)\n+                if curr.statement_index == target.statement_index\n+                    && !apply_after_effect_at_target =>\n+            {\n+                self.seek_to_block_start(target.block)\n+            }\n+\n+            // N.B., `call_return_effect_applied` is checked in `seek_after`, not here.\n+            _ => (),\n+        }\n+\n+        let analysis = &self.results.borrow().analysis;\n+        let block_data = &self.body.basic_blocks()[target.block];\n+\n+        // At this point, the cursor is in the same block as the target location at an earlier\n+        // statement.\n+        debug_assert_eq!(target.block, self.pos.block());\n+\n+        // Find the first statement whose transfer function has not yet been applied.\n+        let first_unapplied_statement = match self.pos {\n+            BlockStart(_) => 0,\n+            After(Location { statement_index, .. }) => statement_index + 1,\n+\n+            // If we have only applied the \"before\" effect for the current statement, apply the\n+            // remainder before continuing.\n+            Before(curr) => {\n+                if curr.statement_index == block_data.statements.len() {\n+                    let terminator = block_data.terminator();\n+                    analysis.apply_terminator_effect(&mut self.state, terminator, curr);\n+                } else {\n+                    let statement = &block_data.statements[curr.statement_index];\n+                    analysis.apply_statement_effect(&mut self.state, statement, curr);\n+                }\n+\n+                // If all we needed to do was go from `Before` to `After` in the same statement,\n+                // we are now done.\n+                if curr.statement_index == target.statement_index {\n+                    debug_assert!(apply_after_effect_at_target);\n+                    self.pos = After(target);\n+                    return;\n+                }\n+\n+                curr.statement_index + 1\n+            }\n+        };\n+\n+        // We have now applied all effects prior to `first_unapplied_statement`.\n+\n+        // Apply the effects of all statements before `target`.\n+        let mut location = Location { block: target.block, statement_index: 0 };\n+        for statement_index in first_unapplied_statement..target.statement_index {\n+            location.statement_index = statement_index;\n+            let statement = &block_data.statements[statement_index];\n+            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n+            analysis.apply_statement_effect(&mut self.state, statement, location);\n+        }\n+\n+        // Apply the effect of the statement (or terminator) at `target`.\n+        location.statement_index = target.statement_index;\n+        if target.statement_index == block_data.statements.len() {\n+            let terminator = &block_data.terminator();\n+            analysis.apply_before_terminator_effect(&mut self.state, terminator, location);\n+\n+            if apply_after_effect_at_target {\n+                analysis.apply_terminator_effect(&mut self.state, terminator, location);\n+                self.pos = After(target);\n+            } else {\n+                self.pos = Before(target);\n+            }\n+        } else {\n+            let statement = &block_data.statements[target.statement_index];\n+            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n+\n+            if apply_after_effect_at_target {\n+                analysis.apply_statement_effect(&mut self.state, statement, location);\n+                self.pos = After(target)\n+            } else {\n+                self.pos = Before(target);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum CursorPosition {\n+    /// No effects within this block have been applied.\n+    BlockStart(BasicBlock),\n+\n+    /// Only the \"before\" effect of the statement (or terminator) at this location has been\n+    /// applied (along with the effects of all previous statements).\n+    Before(Location),\n+\n+    /// The effects of all statements up to and including the one at this location have been\n+    /// applied.\n+    After(Location),\n+}\n+\n+impl CursorPosition {\n+    fn block(&self) -> BasicBlock {\n+        match *self {\n+            Self::BlockStart(block) => block,\n+            Self::Before(loc) | Self::After(loc) => loc.block,\n+        }\n+    }\n+}"}, {"sha": "c0152b0c7d5040c50e7a330c1c4faa0a6ad7e184", "filename": "src/librustc_mir/dataflow/generic/engine.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fengine.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -0,0 +1,427 @@\n+//! A solver for dataflow problems.\n+\n+use std::ffi::OsString;\n+use std::fs;\n+use std::path::PathBuf;\n+\n+use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::work_queue::WorkQueue;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_span::symbol::{sym, Symbol};\n+use syntax::ast;\n+\n+use super::graphviz;\n+use super::{Analysis, GenKillAnalysis, GenKillSet, Results};\n+\n+/// A solver for dataflow problems.\n+pub struct Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    bits_per_block: usize,\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a mir::Body<'tcx>,\n+    def_id: DefId,\n+    dead_unwinds: Option<&'a BitSet<BasicBlock>>,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+    analysis: A,\n+\n+    /// Cached, cumulative transfer functions for each block.\n+    trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: GenKillAnalysis<'tcx>,\n+{\n+    /// Creates a new `Engine` to solve a gen-kill dataflow problem.\n+    pub fn new_gen_kill(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n+        analysis: A,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+        let mut trans_for_block =\n+            IndexVec::from_elem(GenKillSet::identity(bits_per_block), body.basic_blocks());\n+\n+        // Compute cumulative block transfer functions.\n+        //\n+        // FIXME: we may want to skip this if the MIR is acyclic, since we will never access a\n+        // block transfer function more than once.\n+\n+        for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+            let trans = &mut trans_for_block[block];\n+\n+            for (i, statement) in block_data.statements.iter().enumerate() {\n+                let loc = Location { block, statement_index: i };\n+                analysis.before_statement_effect(trans, statement, loc);\n+                analysis.statement_effect(trans, statement, loc);\n+            }\n+\n+            if let Some(terminator) = &block_data.terminator {\n+                let loc = Location { block, statement_index: block_data.statements.len() };\n+                analysis.before_terminator_effect(trans, terminator, loc);\n+                analysis.terminator_effect(trans, terminator, loc);\n+            }\n+        }\n+\n+        Self::new(tcx, body, def_id, analysis, Some(trans_for_block))\n+    }\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Creates a new `Engine` to solve a dataflow problem with an arbitrary transfer\n+    /// function.\n+    ///\n+    /// Gen-kill problems should use `new_gen_kill`, which will coalesce transfer functions for\n+    /// better performance.\n+    pub fn new_generic(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n+        analysis: A,\n+    ) -> Self {\n+        Self::new(tcx, body, def_id, analysis, None)\n+    }\n+\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n+        analysis: A,\n+        trans_for_block: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+\n+        let bottom_value_set = if A::BOTTOM_VALUE == true {\n+            BitSet::new_filled(bits_per_block)\n+        } else {\n+            BitSet::new_empty(bits_per_block)\n+        };\n+\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n+\n+        Engine {\n+            analysis,\n+            bits_per_block,\n+            tcx,\n+            body,\n+            def_id,\n+            dead_unwinds: None,\n+            entry_sets,\n+            trans_for_block,\n+        }\n+    }\n+\n+    /// Signals that we do not want dataflow state to propagate across unwind edges for these\n+    /// `BasicBlock`s.\n+    ///\n+    /// You must take care that `dead_unwinds` does not contain a `BasicBlock` that *can* actually\n+    /// unwind during execution. Otherwise, your dataflow results will not be correct.\n+    pub fn dead_unwinds(mut self, dead_unwinds: &'a BitSet<BasicBlock>) -> Self {\n+        self.dead_unwinds = Some(dead_unwinds);\n+        self\n+    }\n+\n+    /// Computes the fixpoint for this dataflow problem and returns it.\n+    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n+        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+\n+        let mut dirty_queue: WorkQueue<BasicBlock> =\n+            WorkQueue::with_none(self.body.basic_blocks().len());\n+\n+        for (bb, _) in traversal::reverse_postorder(self.body) {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n+        // be processed after the ones added above.\n+        for bb in self.body.basic_blocks().indices() {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        while let Some(bb) = dirty_queue.pop() {\n+            let bb_data = &self.body[bb];\n+            let on_entry = &self.entry_sets[bb];\n+\n+            temp_state.overwrite(on_entry);\n+            self.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+\n+            self.propagate_bits_into_graph_successors_of(\n+                &mut temp_state,\n+                (bb, bb_data),\n+                &mut dirty_queue,\n+            );\n+        }\n+\n+        let Engine { tcx, body, def_id, trans_for_block, entry_sets, analysis, .. } = self;\n+        let results = Results { analysis, entry_sets };\n+\n+        let res = write_graphviz_results(tcx, def_id, body, &results, trans_for_block);\n+        if let Err(e) = res {\n+            warn!(\"Failed to write graphviz dataflow results: {}\", e);\n+        }\n+\n+        results\n+    }\n+\n+    /// Applies the cumulative effect of an entire block, excluding the call return effect if one\n+    /// exists.\n+    fn apply_whole_block_effect(\n+        &self,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) {\n+        // Use the cached block transfer function if available.\n+        if let Some(trans_for_block) = &self.trans_for_block {\n+            trans_for_block[block].apply(state);\n+            return;\n+        }\n+\n+        // Otherwise apply effects one-by-one.\n+\n+        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            self.analysis.apply_before_statement_effect(state, statement, location);\n+            self.analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        self.analysis.apply_before_terminator_effect(state, terminator, location);\n+        self.analysis.apply_terminator_effect(state, terminator, location);\n+    }\n+\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n+        dirty_list: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        use mir::TerminatorKind::*;\n+\n+        match bb_data.terminator().kind {\n+            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n+\n+            Goto { target }\n+            | Assert { target, cleanup: None, .. }\n+            | Yield { resume: target, drop: None, .. }\n+            | Drop { target, location: _, unwind: None }\n+            | DropAndReplace { target, value: _, location: _, unwind: None } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list)\n+            }\n+\n+            Yield { resume: target, drop: Some(drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+            }\n+\n+            Assert { target, cleanup: Some(unwind), .. }\n+            | Drop { target, location: _, unwind: Some(unwind) }\n+            | DropAndReplace { target, value: _, location: _, unwind: Some(unwind) } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n+                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                }\n+            }\n+\n+            SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n+                }\n+            }\n+\n+            Call { cleanup, ref destination, ref func, ref args, .. } => {\n+                if let Some(unwind) = cleanup {\n+                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+\n+                if let Some((ref dest_place, dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, otherwise the unwind path will see the call\n+                    // return effect.\n+                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n+                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n+                }\n+            }\n+\n+            FalseEdges { real_target, imaginary_target } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n+            }\n+\n+            FalseUnwind { real_target, unwind } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                if let Some(unwind) = unwind {\n+                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(\n+        &mut self,\n+        in_out: &BitSet<A::Idx>,\n+        bb: BasicBlock,\n+        dirty_queue: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        let entry_set = &mut self.entry_sets[bb];\n+        let set_changed = self.analysis.join(entry_set, &in_out);\n+        if set_changed {\n+            dirty_queue.insert(bb);\n+        }\n+    }\n+}\n+\n+// Graphviz\n+\n+/// Writes a DOT file containing the results of a dataflow analysis if the user requested it via\n+/// `rustc_mir` attributes.\n+fn write_graphviz_results<A>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    body: &mir::Body<'tcx>,\n+    results: &Results<'tcx, A>,\n+    block_transfer_functions: Option<IndexVec<BasicBlock, GenKillSet<A::Idx>>>,\n+) -> std::io::Result<()>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n+        Ok(attrs) => attrs,\n+\n+        // Invalid `rustc_mir` attrs will be reported using `span_err`.\n+        Err(()) => return Ok(()),\n+    };\n+\n+    let path = match attrs.output_path(A::NAME) {\n+        Some(path) => path,\n+        None => return Ok(()),\n+    };\n+\n+    let bits_per_block = results.analysis.bits_per_block(body);\n+\n+    let mut formatter: Box<dyn graphviz::StateFormatter<'tcx, _>> = match attrs.formatter {\n+        Some(sym::two_phase) => Box::new(graphviz::TwoPhaseDiff::new(bits_per_block)),\n+        Some(sym::gen_kill) => {\n+            if let Some(trans_for_block) = block_transfer_functions {\n+                Box::new(graphviz::BlockTransferFunc::new(body, trans_for_block))\n+            } else {\n+                Box::new(graphviz::SimpleDiff::new(bits_per_block))\n+            }\n+        }\n+\n+        // Default to the `SimpleDiff` output style.\n+        _ => Box::new(graphviz::SimpleDiff::new(bits_per_block)),\n+    };\n+\n+    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n+    let mut buf = Vec::new();\n+\n+    let graphviz = graphviz::Formatter::new(body, def_id, results, &mut *formatter);\n+    dot::render(&graphviz, &mut buf)?;\n+    fs::write(&path, buf)?;\n+    Ok(())\n+}\n+\n+#[derive(Default)]\n+struct RustcMirAttrs {\n+    basename_and_suffix: Option<PathBuf>,\n+    formatter: Option<Symbol>,\n+}\n+\n+impl RustcMirAttrs {\n+    fn parse(tcx: TyCtxt<'tcx>, def_id: DefId) -> Result<Self, ()> {\n+        let attrs = tcx.get_attrs(def_id);\n+\n+        let mut result = Ok(());\n+        let mut ret = RustcMirAttrs::default();\n+\n+        let rustc_mir_attrs = attrs\n+            .into_iter()\n+            .filter(|attr| attr.check_name(sym::rustc_mir))\n+            .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n+\n+        for attr in rustc_mir_attrs {\n+            let attr_result = if attr.check_name(sym::borrowck_graphviz_postflow) {\n+                Self::set_field(&mut ret.basename_and_suffix, tcx, &attr, |s| {\n+                    let path = PathBuf::from(s.to_string());\n+                    match path.file_name() {\n+                        Some(_) => Ok(path),\n+                        None => {\n+                            tcx.sess.span_err(attr.span(), \"path must end in a filename\");\n+                            Err(())\n+                        }\n+                    }\n+                })\n+            } else if attr.check_name(sym::borrowck_graphviz_format) {\n+                Self::set_field(&mut ret.formatter, tcx, &attr, |s| match s {\n+                    sym::gen_kill | sym::two_phase => Ok(s),\n+                    _ => {\n+                        tcx.sess.span_err(attr.span(), \"unknown formatter\");\n+                        Err(())\n+                    }\n+                })\n+            } else {\n+                Ok(())\n+            };\n+\n+            result = result.and(attr_result);\n+        }\n+\n+        result.map(|()| ret)\n+    }\n+\n+    fn set_field<T>(\n+        field: &mut Option<T>,\n+        tcx: TyCtxt<'tcx>,\n+        attr: &ast::NestedMetaItem,\n+        mapper: impl FnOnce(Symbol) -> Result<T, ()>,\n+    ) -> Result<(), ()> {\n+        if field.is_some() {\n+            tcx.sess\n+                .span_err(attr.span(), &format!(\"duplicate values for `{}`\", attr.name_or_empty()));\n+\n+            return Err(());\n+        }\n+\n+        if let Some(s) = attr.value_str() {\n+            *field = Some(mapper(s)?);\n+            Ok(())\n+        } else {\n+            tcx.sess\n+                .span_err(attr.span(), &format!(\"`{}` requires an argument\", attr.name_or_empty()));\n+            Err(())\n+        }\n+    }\n+\n+    /// Returns the path where dataflow results should be written, or `None`\n+    /// `borrowck_graphviz_postflow` was not specified.\n+    ///\n+    /// This performs the following transformation to the argument of `borrowck_graphviz_postflow`:\n+    ///\n+    /// \"path/suffix.dot\" -> \"path/analysis_name_suffix.dot\"\n+    fn output_path(&self, analysis_name: &str) -> Option<PathBuf> {\n+        let mut ret = self.basename_and_suffix.as_ref().cloned()?;\n+        let suffix = ret.file_name().unwrap(); // Checked when parsing attrs\n+\n+        let mut file_name: OsString = analysis_name.into();\n+        file_name.push(\"_\");\n+        file_name.push(suffix);\n+        ret.set_file_name(file_name);\n+\n+        Some(ret)\n+    }\n+}"}, {"sha": "fdf86e7b53f607d4ce0a8338ef9e4fadd5111f4a", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "modified", "additions": 402, "deletions": 116, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -1,13 +1,14 @@\n+//! A helpful diagram for debugging dataflow problems.\n+\n use std::cell::RefCell;\n-use std::io::{self, Write};\n-use std::{ops, str};\n+use std::{io, ops, str};\n \n use rustc::mir::{self, BasicBlock, Body, Location};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::Idx;\n+use rustc_index::vec::{Idx, IndexVec};\n \n-use super::{Analysis, Results, ResultsRefCursor};\n+use super::{Analysis, GenKillSet, Results, ResultsRefCursor};\n use crate::util::graphviz_safe_def_name;\n \n pub struct Formatter<'a, 'tcx, A>\n@@ -25,11 +26,16 @@ impl<A> Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    pub fn new(body: &'a Body<'tcx>, def_id: DefId, results: &'a Results<'tcx, A>) -> Self {\n+    pub fn new(\n+        body: &'a Body<'tcx>,\n+        def_id: DefId,\n+        results: &'a Results<'tcx, A>,\n+        state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n+    ) -> Self {\n         let block_formatter = BlockFormatter {\n             bg: Background::Light,\n-            prev_state: BitSet::new_empty(results.analysis.bits_per_block(body)),\n             results: ResultsRefCursor::new(body, results),\n+            state_formatter,\n         };\n \n         Formatter { body, def_id, block_formatter: RefCell::new(block_formatter) }\n@@ -117,15 +123,21 @@ struct BlockFormatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    prev_state: BitSet<A::Idx>,\n     results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n     bg: Background,\n+    state_formatter: &'a mut dyn StateFormatter<'tcx, A>,\n }\n \n impl<A> BlockFormatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n+    const HEADER_COLOR: &'static str = \"#a0a0a0\";\n+\n+    fn num_state_columns(&self) -> usize {\n+        std::cmp::max(1, self.state_formatter.column_names().len())\n+    }\n+\n     fn toggle_background(&mut self) -> Background {\n         let bg = self.bg;\n         self.bg = !bg;\n@@ -164,196 +176,470 @@ where\n             r#\"<table border=\"1\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"3\" sides=\"rb\">\"#,\n         )?;\n \n-        // A: Block info\n-        write!(\n-            w,\n-            r#\"<tr>\n-                 <td colspan=\"{num_headers}\" sides=\"tl\">bb{block_id}</td>\n-               </tr>\"#,\n-            num_headers = 3,\n-            block_id = block.index(),\n-        )?;\n-\n-        // B: Column headings\n-        write!(\n-            w,\n-            r#\"<tr>\n-                 <td colspan=\"2\" {fmt}>MIR</td>\n-                 <td {fmt}>STATE</td>\n-               </tr>\"#,\n-            fmt = r##\"bgcolor=\"#a0a0a0\" sides=\"tl\"\"##,\n-        )?;\n+        // A + B: Block header\n+        if self.state_formatter.column_names().is_empty() {\n+            self.write_block_header_simple(w, block)?;\n+        } else {\n+            self.write_block_header_with_state_columns(w, block)?;\n+        }\n \n         // C: Entry state\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n-        self.write_row_with_curr_state(w, \"\", \"(on entry)\")?;\n-        self.prev_state.overwrite(self.results.get());\n+        self.write_row_with_full_state(w, \"\", \"(on_entry)\")?;\n \n         // D: Statement transfer functions\n         for (i, statement) in body[block].statements.iter().enumerate() {\n             let location = Location { block, statement_index: i };\n-\n-            let mir_col = format!(\"{:?}\", statement);\n-            let i_col = i.to_string();\n-\n-            self.results.seek_after(location);\n-            self.write_row_with_curr_diff(w, &i_col, &mir_col)?;\n-            self.prev_state.overwrite(self.results.get());\n+            let statement_str = format!(\"{:?}\", statement);\n+            self.write_row_for_location(w, &i.to_string(), &statement_str, location)?;\n         }\n \n         // E: Terminator transfer function\n         let terminator = body[block].terminator();\n-        let location = body.terminator_loc(block);\n+        let terminator_loc = body.terminator_loc(block);\n+        let mut terminator_str = String::new();\n+        terminator.kind.fmt_head(&mut terminator_str).unwrap();\n \n-        let mut mir_col = String::new();\n-        terminator.kind.fmt_head(&mut mir_col).unwrap();\n-\n-        self.results.seek_after(location);\n-        self.write_row_with_curr_diff(w, \"T\", &mir_col)?;\n-        self.prev_state.overwrite(self.results.get());\n+        self.write_row_for_location(w, \"T\", &terminator_str, terminator_loc)?;\n \n         // F: Exit state\n+        self.results.seek_after(terminator_loc);\n         if let mir::TerminatorKind::Call { destination: Some(_), .. } = &terminator.kind {\n-            self.write_row_with_curr_state(w, \"\", \"(on unwind)\")?;\n-\n-            self.results.seek_after_assume_call_returns(location);\n-            self.write_row_with_curr_diff(w, \"\", \"(on successful return)\")?;\n+            self.write_row_with_full_state(w, \"\", \"(on unwind)\")?;\n+\n+            let num_state_columns = self.num_state_columns();\n+            self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n+                write!(\n+                    w,\n+                    r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                    colspan = num_state_columns,\n+                    fmt = fmt,\n+                )?;\n+\n+                let state_on_unwind = this.results.get().clone();\n+                this.results.seek_after_assume_call_returns(terminator_loc);\n+                write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n+\n+                write!(w, \"</td>\")\n+            })?;\n         } else {\n-            self.write_row_with_curr_state(w, \"\", \"(on exit)\")?;\n+            self.write_row_with_full_state(w, \"\", \"(on exit)\")?;\n         }\n \n         write!(w, \"</table>\")\n     }\n \n-    fn write_row_with_curr_state(\n+    fn write_block_header_simple(\n         &mut self,\n         w: &mut impl io::Write,\n-        i: &str,\n-        mir: &str,\n+        block: BasicBlock,\n     ) -> io::Result<()> {\n-        let bg = self.toggle_background();\n+        //   +-------------------------------------------------+\n+        // A |                      bb4                        |\n+        //   +-----------------------------------+-------------+\n+        // B |                MIR                |    STATE    |\n+        //   +-+---------------------------------+-------------+\n+        //   | |              ...                |             |\n \n-        let mut out = Vec::new();\n-        write!(&mut out, \"{{\")?;\n-        pretty_print_state_elems(&mut out, self.results.analysis(), self.results.get().iter())?;\n-        write!(&mut out, \"}}\")?;\n+        // A\n+        write!(\n+            w,\n+            concat!(\"<tr>\", r#\"<td colspan=\"3\" sides=\"tl\">bb{block_id}</td>\"#, \"</tr>\",),\n+            block_id = block.index(),\n+        )?;\n \n+        // B\n         write!(\n             w,\n-            r#\"<tr>\n-                 <td {fmt} align=\"right\">{i}</td>\n-                 <td {fmt} align=\"left\">{mir}</td>\n-                 <td {fmt} align=\"left\">{state}</td>\n-               </tr>\"#,\n-            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n-            i = i,\n-            mir = dot::escape_html(mir),\n-            state = dot::escape_html(str::from_utf8(&out).unwrap()),\n+            concat!(\n+                \"<tr>\",\n+                r#\"<td colspan=\"2\" {fmt}>MIR</td>\"#,\n+                r#\"<td {fmt}>STATE</td>\"#,\n+                \"</tr>\",\n+            ),\n+            fmt = format!(\"bgcolor=\\\"{}\\\" sides=\\\"tl\\\"\", Self::HEADER_COLOR),\n         )\n     }\n \n-    fn write_row_with_curr_diff(\n+    fn write_block_header_with_state_columns(\n         &mut self,\n         w: &mut impl io::Write,\n-        i: &str,\n-        mir: &str,\n+        block: BasicBlock,\n     ) -> io::Result<()> {\n-        let bg = self.toggle_background();\n-        let analysis = self.results.analysis();\n+        //   +------------------------------------+-------------+\n+        // A |                bb4                 |    STATE    |\n+        //   +------------------------------------+------+------+\n+        // B |                MIR                 |  GEN | KILL |\n+        //   +-+----------------------------------+------+------+\n+        //   | |              ...                 |      |      |\n \n-        let diff = BitSetDiff::compute(&self.prev_state, self.results.get());\n+        let state_column_names = self.state_formatter.column_names();\n \n-        let mut set = Vec::new();\n-        pretty_print_state_elems(&mut set, analysis, diff.set.iter())?;\n+        // A\n+        write!(\n+            w,\n+            concat!(\n+                \"<tr>\",\n+                r#\"<td {fmt} colspan=\"2\">bb{block_id}</td>\"#,\n+                r#\"<td {fmt} colspan=\"{num_state_cols}\">STATE</td>\"#,\n+                \"</tr>\",\n+            ),\n+            fmt = \"sides=\\\"tl\\\"\",\n+            num_state_cols = state_column_names.len(),\n+            block_id = block.index(),\n+        )?;\n+\n+        // B\n+        let fmt = format!(\"bgcolor=\\\"{}\\\" sides=\\\"tl\\\"\", Self::HEADER_COLOR);\n+        write!(w, concat!(\"<tr>\", r#\"<td colspan=\"2\" {fmt}>MIR</td>\"#,), fmt = fmt,)?;\n \n-        let mut clear = Vec::new();\n-        pretty_print_state_elems(&mut clear, analysis, diff.clear.iter())?;\n+        for name in state_column_names {\n+            write!(w, \"<td {fmt}>{name}</td>\", fmt = fmt, name = name)?;\n+        }\n+\n+        write!(w, \"</tr>\")\n+    }\n+\n+    /// Write a row with the given index and MIR, using the function argument to fill in the\n+    /// \"STATE\" column(s).\n+    fn write_row<W: io::Write>(\n+        &mut self,\n+        w: &mut W,\n+        i: &str,\n+        mir: &str,\n+        f: impl FnOnce(&mut Self, &mut W, &str) -> io::Result<()>,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+        let fmt = format!(\"sides=\\\"tl\\\" {}\", bg.attr());\n \n         write!(\n             w,\n-            r#\"<tr>\n-                 <td {fmt} align=\"right\">{i}</td>\n-                 <td {fmt} align=\"left\">{mir}</td>\n-                 <td {fmt} align=\"left\">\"#,\n+            concat!(\n+                \"<tr>\",\n+                r#\"<td {fmt} align=\"right\">{i}</td>\"#,\n+                r#\"<td {fmt} align=\"left\">{mir}</td>\"#,\n+            ),\n             i = i,\n-            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            fmt = fmt,\n             mir = dot::escape_html(mir),\n         )?;\n \n-        if !set.is_empty() {\n+        f(self, w, &fmt)?;\n+        write!(w, \"</tr>\")\n+    }\n+\n+    fn write_row_with_full_state(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        self.write_row(w, i, mir, |this, w, fmt| {\n+            let state = this.results.get();\n+            let analysis = this.results.analysis();\n+\n             write!(\n                 w,\n-                r#\"<font color=\"darkgreen\">+{}</font>\"#,\n-                dot::escape_html(str::from_utf8(&set).unwrap()),\n+                r#\"<td colspan=\"{colspan}\" {fmt} align=\"left\">{{\"#,\n+                colspan = this.num_state_columns(),\n+                fmt = fmt,\n             )?;\n+            pretty_print_state_elems(w, analysis, state.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+            write!(w, \"}}</td>\")\n+        })\n+    }\n+\n+    fn write_row_for_location(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        self.write_row(w, i, mir, |this, w, fmt| {\n+            this.state_formatter.write_state_for_location(w, fmt, &mut this.results, location)\n+        })\n+    }\n+}\n+\n+/// Controls what gets printed under the `STATE` header.\n+pub trait StateFormatter<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// The columns that will get printed under `STATE`.\n+    fn column_names(&self) -> &[&str];\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()>;\n+}\n+\n+/// Prints a single column containing the state vector immediately *after* each statement.\n+pub struct SimpleDiff<T: Idx> {\n+    prev_state: BitSet<T>,\n+    prev_loc: Location,\n+}\n+\n+impl<T: Idx> SimpleDiff<T> {\n+    #![allow(unused)]\n+    pub fn new(bits_per_block: usize) -> Self {\n+        SimpleDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+    }\n+}\n+\n+impl<A> StateFormatter<'tcx, A> for SimpleDiff<A::Idx>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn column_names(&self) -> &[&str] {\n+        &[]\n+    }\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        mut w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        if location.statement_index == 0 {\n+            results.seek_to_block_start(location.block);\n+            self.prev_state.overwrite(results.get());\n+        } else {\n+            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n+            assert_eq!(self.prev_loc.successor_within_block(), location);\n+        }\n+\n+        self.prev_loc = location;\n+        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_before(location);\n+        let curr_state = results.get();\n+        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n+        self.prev_state.overwrite(curr_state);\n+        write!(w, \"</td>\")\n+    }\n+}\n+\n+/// Prints two state columns, one containing only the \"before\" effect of each statement and one\n+/// containing the full effect.\n+pub struct TwoPhaseDiff<T: Idx> {\n+    prev_state: BitSet<T>,\n+    prev_loc: Location,\n+}\n+\n+impl<T: Idx> TwoPhaseDiff<T> {\n+    #![allow(unused)]\n+    pub fn new(bits_per_block: usize) -> Self {\n+        TwoPhaseDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+    }\n+}\n+\n+impl<A> StateFormatter<'tcx, A> for TwoPhaseDiff<A::Idx>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn column_names(&self) -> &[&str] {\n+        &[\"ENTRY\", \" EXIT\"]\n+    }\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        mut w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        if location.statement_index == 0 {\n+            results.seek_to_block_start(location.block);\n+            self.prev_state.overwrite(results.get());\n+        } else {\n+            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n+            assert_eq!(self.prev_loc.successor_within_block(), location);\n         }\n \n-        if !set.is_empty() && !clear.is_empty() {\n-            write!(w, \"  \")?;\n+        self.prev_loc = location;\n+\n+        // Entry\n+\n+        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_before(location);\n+        let curr_state = results.get();\n+        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n+        self.prev_state.overwrite(curr_state);\n+        write!(w, \"</td>\")?;\n+\n+        // Exit\n+\n+        write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n+        results.seek_after(location);\n+        let curr_state = results.get();\n+        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n+        self.prev_state.overwrite(curr_state);\n+        write!(w, \"</td>\")\n+    }\n+}\n+\n+/// Prints the gen/kill set for the entire block.\n+pub struct BlockTransferFunc<'a, 'tcx, T: Idx> {\n+    body: &'a mir::Body<'tcx>,\n+    trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n+}\n+\n+impl<T: Idx> BlockTransferFunc<'mir, 'tcx, T> {\n+    #![allow(unused)]\n+    pub fn new(\n+        body: &'mir mir::Body<'tcx>,\n+        trans_for_block: IndexVec<BasicBlock, GenKillSet<T>>,\n+    ) -> Self {\n+        BlockTransferFunc { body, trans_for_block }\n+    }\n+}\n+\n+impl<A> StateFormatter<'tcx, A> for BlockTransferFunc<'mir, 'tcx, A::Idx>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn column_names(&self) -> &[&str] {\n+        &[\"GEN\", \"KILL\"]\n+    }\n+\n+    fn write_state_for_location(\n+        &mut self,\n+        mut w: &mut dyn io::Write,\n+        fmt: &str,\n+        results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n+        location: Location,\n+    ) -> io::Result<()> {\n+        // Only print a single row.\n+        if location.statement_index != 0 {\n+            return Ok(());\n         }\n \n-        if !clear.is_empty() {\n+        let block_trans = &self.trans_for_block[location.block];\n+        let rowspan = self.body.basic_blocks()[location.block].statements.len();\n+\n+        for set in &[&block_trans.gen, &block_trans.kill] {\n             write!(\n                 w,\n-                r#\"<font color=\"red\">-{}</font>\"#,\n-                dot::escape_html(str::from_utf8(&clear).unwrap()),\n+                r#\"<td {fmt} rowspan=\"{rowspan}\" align=\"center\">\"#,\n+                fmt = fmt,\n+                rowspan = rowspan\n             )?;\n+\n+            pretty_print_state_elems(&mut w, results.analysis(), set.iter(), \"\\n\", None)?;\n+            write!(w, \"</td>\")?;\n         }\n \n-        write!(w, \"</td></tr>\")\n+        Ok(())\n     }\n }\n \n-/// The operations required to transform one `BitSet` into another.\n-struct BitSetDiff<T: Idx> {\n-    set: HybridBitSet<T>,\n-    clear: HybridBitSet<T>,\n-}\n+/// Writes two lines, one containing the added bits and one the removed bits.\n+fn write_diff<A: Analysis<'tcx>>(\n+    w: &mut impl io::Write,\n+    analysis: &A,\n+    from: &BitSet<A::Idx>,\n+    to: &BitSet<A::Idx>,\n+) -> io::Result<()> {\n+    assert_eq!(from.domain_size(), to.domain_size());\n+    let len = from.domain_size();\n+\n+    let mut set = HybridBitSet::new_empty(len);\n+    let mut clear = HybridBitSet::new_empty(len);\n+\n+    // FIXME: Implement a lazy iterator over the symmetric difference of two bitsets.\n+    for i in (0..len).map(|i| A::Idx::new(i)) {\n+        match (from.contains(i), to.contains(i)) {\n+            (false, true) => set.insert(i),\n+            (true, false) => clear.insert(i),\n+            _ => continue,\n+        };\n+    }\n \n-impl<T: Idx> BitSetDiff<T> {\n-    fn compute(from: &BitSet<T>, to: &BitSet<T>) -> Self {\n-        assert_eq!(from.domain_size(), to.domain_size());\n-        let len = from.domain_size();\n-\n-        let mut set = HybridBitSet::new_empty(len);\n-        let mut clear = HybridBitSet::new_empty(len);\n-\n-        // FIXME: This could be made faster if `BitSet::xor` were implemented.\n-        for i in (0..len).map(|i| T::new(i)) {\n-            match (from.contains(i), to.contains(i)) {\n-                (false, true) => set.insert(i),\n-                (true, false) => clear.insert(i),\n-                _ => continue,\n-            };\n-        }\n+    if !set.is_empty() {\n+        write!(w, r#\"<font color=\"darkgreen\">+\"#)?;\n+        pretty_print_state_elems(w, analysis, set.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+        write!(w, r#\"</font>\"#)?;\n+    }\n \n-        BitSetDiff { set, clear }\n+    if !set.is_empty() && !clear.is_empty() {\n+        write!(w, \"<br/>\")?;\n     }\n+\n+    if !clear.is_empty() {\n+        write!(w, r#\"<font color=\"red\">-\"#)?;\n+        pretty_print_state_elems(w, analysis, clear.iter(), \",\", LIMIT_40_ALIGN_1)?;\n+        write!(w, r#\"</font>\"#)?;\n+    }\n+\n+    Ok(())\n }\n \n-/// Formats each `elem` using the pretty printer provided by `analysis` into a comma-separated\n-/// list.\n+/// Line break policy that breaks at 40 characters and starts the next line with a single space.\n+const LIMIT_40_ALIGN_1: Option<LineBreak> = Some(LineBreak { sequence: \"<br/> \", limit: 40 });\n+\n+struct LineBreak {\n+    sequence: &'static str,\n+    limit: usize,\n+}\n+\n+/// Formats each `elem` using the pretty printer provided by `analysis` into a list with the given\n+/// separator (`sep`).\n+///\n+/// Optionally, it will break lines using the given character sequence (usually `<br/>`) and\n+/// character limit.\n fn pretty_print_state_elems<A>(\n     w: &mut impl io::Write,\n     analysis: &A,\n     elems: impl Iterator<Item = A::Idx>,\n-) -> io::Result<()>\n+    sep: &str,\n+    line_break: Option<LineBreak>,\n+) -> io::Result<bool>\n where\n     A: Analysis<'tcx>,\n {\n+    let sep_width = sep.chars().count();\n+\n+    let mut buf = Vec::new();\n+\n     let mut first = true;\n+    let mut curr_line_width = 0;\n+    let mut line_break_inserted = false;\n+\n     for idx in elems {\n         if first {\n             first = false;\n         } else {\n-            write!(w, \",\")?;\n+            write!(w, \"{}\", sep)?;\n+            curr_line_width += sep_width;\n+        }\n+\n+        buf.clear();\n+        analysis.pretty_print_idx(&mut buf, idx)?;\n+        let idx_str =\n+            str::from_utf8(&buf).expect(\"Output of `pretty_print_idx` must be valid UTF-8\");\n+        let escaped = dot::escape_html(idx_str);\n+        let escaped_width = escaped.chars().count();\n+\n+        if let Some(line_break) = &line_break {\n+            if curr_line_width + sep_width + escaped_width > line_break.limit {\n+                write!(w, \"{}\", line_break.sequence)?;\n+                line_break_inserted = true;\n+                curr_line_width = 0;\n+            }\n         }\n \n-        analysis.pretty_print_idx(w, idx)?;\n+        write!(w, \"{}\", escaped)?;\n+        curr_line_width += escaped_width;\n     }\n \n-    Ok(())\n+    Ok(line_break_inserted)\n }\n \n /// The background color used for zebra-striping the table."}, {"sha": "c9b4f875ebdf85f7b28e6022579ca4ef7a12575d", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -0,0 +1,358 @@\n+//! A framework that can express both [gen-kill] and generic dataflow problems.\n+//!\n+//! There is another interface for dataflow in the compiler in `librustc_mir/dataflow/mod.rs`. The\n+//! interface in this module will eventually [replace that one][design-meeting].\n+//!\n+//! To actually use this framework, you must implement either the `Analysis` or the `GenKillAnalysis`\n+//! trait. If your transfer function can be expressed with only gen/kill operations, prefer\n+//! `GenKillAnalysis` since it will run faster while iterating to fixpoint. Create an `Engine` using\n+//! the appropriate constructor and call `iterate_to_fixpoint`. You can use a `ResultsCursor` to\n+//! inspect the fixpoint solution to your dataflow problem.\n+//!\n+//! ```ignore(cross-crate-imports)\n+//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>, did: DefId) {\n+//!     let analysis = MyAnalysis::new();\n+//!\n+//!     // If `MyAnalysis` implements `GenKillAnalysis`.\n+//!     let results = Engine::new_gen_kill(tcx, body, did, analysis).iterate_to_fixpoint();\n+//!\n+//!     // If `MyAnalysis` implements `Analysis`.\n+//!     // let results = Engine::new_generic(tcx, body, did, analysis).iterate_to_fixpoint();\n+//!\n+//!     let mut cursor = ResultsCursor::new(body, results);\n+//!\n+//!     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n+//!         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n+//!         let state = cursor.get();\n+//!         println!(\"{:?}\", state);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n+//! [design-meeting]https://github.com/rust-lang/compiler-team/issues/202\n+\n+use std::io;\n+\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+use crate::dataflow::BottomValue;\n+\n+mod cursor;\n+mod engine;\n+mod graphviz;\n+\n+pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n+pub use self::engine::Engine;\n+\n+/// A dataflow analysis that has converged to fixpoint.\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub analysis: A,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Creates a `ResultsCursor` that can inspect these `Results`.\n+    pub fn into_results_cursor(self, body: &'mir mir::Body<'tcx>) -> ResultsCursor<'mir, 'tcx, A> {\n+        ResultsCursor::new(body, self)\n+    }\n+\n+    /// Gets the entry set for the given block.\n+    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n+        &self.entry_sets[block]\n+    }\n+}\n+\n+/// Define the domain of a dataflow problem.\n+///\n+/// This trait specifies the lattice on which this analysis operates. For now, this must be a\n+/// powerset of values of type `Idx`. The elements of this lattice are represented with a `BitSet`\n+/// and referred to as the state vector.\n+///\n+/// This trait also defines the initial value for the dataflow state upon entry to the\n+/// `START_BLOCK`, as well as some names used to refer to this analysis when debugging.\n+pub trait AnalysisDomain<'tcx>: BottomValue {\n+    /// The type of the elements in the state vector.\n+    type Idx: Idx;\n+\n+    /// A descriptive name for this analysis. Used only for debugging.\n+    ///\n+    /// This name should be brief and contain no spaces, periods or other characters that are not\n+    /// suitable as part of a filename.\n+    const NAME: &'static str;\n+\n+    /// The size of the state vector.\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+\n+    /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n+    /// analysis.\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n+\n+    /// Prints an element in the state vector for debugging.\n+    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n+        write!(w, \"{:?}\", idx)\n+    }\n+}\n+\n+/// A dataflow problem with an arbitrarily complex transfer function.\n+pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n+    /// Updates the current dataflow state with the effect of evaluating a statement.\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with an effect that occurs immediately *before* the\n+    /// given statement.\n+    ///\n+    /// This method is useful if the consumer of the results of this analysis needs only to observe\n+    /// *part* of the effect of a statement (e.g. for two-phase borrows). As a general rule,\n+    /// analyses should not implement this without implementing `apply_statement_effect`.\n+    fn apply_before_statement_effect(\n+        &self,\n+        _state: &mut BitSet<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Updates the current dataflow state with the effect of evaluating a terminator.\n+    ///\n+    /// The effect of a successful return from a `Call` terminator should **not** be accounted for\n+    /// in this function. That should go in `apply_call_return_effect`. For example, in the\n+    /// `InitializedPlaces` analyses, the return place for a function call is not marked as\n+    /// initialized here.\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// Updates the current dataflow state with an effect that occurs immediately *before* the\n+    /// given terminator.\n+    ///\n+    /// This method is useful if the consumer of the results of this analysis needs only to observe\n+    /// *part* of the effect of a terminator (e.g. for two-phase borrows). As a general rule,\n+    /// analyses should not implement this without implementing `apply_terminator_effect`.\n+    fn apply_before_terminator_effect(\n+        &self,\n+        _state: &mut BitSet<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Updates the current dataflow state with the effect of a successful return from a `Call`\n+    /// terminator.\n+    ///\n+    /// This is separate from `apply_terminator_effect` to properly track state across unwind\n+    /// edges.\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+}\n+\n+/// A gen/kill dataflow problem.\n+///\n+/// Each method in this trait has a corresponding one in `Analysis`. However, these methods only\n+/// allow modification of the dataflow state via \"gen\" and \"kill\" operations. By defining transfer\n+/// functions for each statement in this way, the transfer function for an entire basic block can\n+/// be computed efficiently.\n+///\n+/// `Analysis` is automatically implemented for all implementers of `GenKillAnalysis`.\n+pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n+    /// See `Analysis::apply_statement_effect`.\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// See `Analysis::apply_before_statement_effect`.\n+    fn before_statement_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// See `Analysis::apply_terminator_effect`.\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    /// See `Analysis::apply_before_terminator_effect`.\n+    fn before_terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// See `Analysis::apply_call_return_effect`.\n+    fn call_return_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+}\n+\n+impl<A> Analysis<'tcx> for A\n+where\n+    A: GenKillAnalysis<'tcx>,\n+{\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.statement_effect(state, statement, location);\n+    }\n+\n+    fn apply_before_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.before_statement_effect(state, statement, location);\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.terminator_effect(state, terminator, location);\n+    }\n+\n+    fn apply_before_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.before_terminator_effect(state, terminator, location);\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    ) {\n+        self.call_return_effect(state, block, func, args, return_place);\n+    }\n+}\n+\n+/// The legal operations for a transfer function in a gen/kill problem.\n+///\n+/// This abstraction exists because there are two different contexts in which we call the methods in\n+/// `GenKillAnalysis`. Sometimes we need to store a single transfer function that can be efficiently\n+/// applied multiple times, such as when computing the cumulative transfer function for each block.\n+/// These cases require a `GenKillSet`, which in turn requires two `BitSet`s of storage. Oftentimes,\n+/// however, we only need to apply an effect once. In *these* cases, it is more efficient to pass the\n+/// `BitSet` representing the state vector directly into the `*_effect` methods as opposed to\n+/// building up a `GenKillSet` and then throwing it away.\n+pub trait GenKill<T> {\n+    /// Inserts `elem` into the state vector.\n+    fn gen(&mut self, elem: T);\n+\n+    /// Removes `elem` from the state vector.\n+    fn kill(&mut self, elem: T);\n+\n+    /// Calls `gen` for each element in `elems`.\n+    fn gen_all(&mut self, elems: impl IntoIterator<Item = T>) {\n+        for elem in elems {\n+            self.gen(elem);\n+        }\n+    }\n+\n+    /// Calls `kill` for each element in `elems`.\n+    fn kill_all(&mut self, elems: impl IntoIterator<Item = T>) {\n+        for elem in elems {\n+            self.kill(elem);\n+        }\n+    }\n+}\n+\n+/// Stores a transfer function for a gen/kill problem.\n+///\n+/// Calling `gen`/`kill` on a `GenKillSet` will \"build up\" a transfer function so that it can be\n+/// applied multiple times efficiently. When there are multiple calls to `gen` and/or `kill` for\n+/// the same element, the most recent one takes precedence.\n+#[derive(Clone)]\n+pub struct GenKillSet<T: Idx> {\n+    gen: HybridBitSet<T>,\n+    kill: HybridBitSet<T>,\n+}\n+\n+impl<T: Idx> GenKillSet<T> {\n+    /// Creates a new transfer function that will leave the dataflow state unchanged.\n+    pub fn identity(universe: usize) -> Self {\n+        GenKillSet {\n+            gen: HybridBitSet::new_empty(universe),\n+            kill: HybridBitSet::new_empty(universe),\n+        }\n+    }\n+\n+    /// Applies this transfer function to the given state vector.\n+    pub fn apply(&self, state: &mut BitSet<T>) {\n+        state.union(&self.gen);\n+        state.subtract(&self.kill);\n+    }\n+}\n+\n+impl<T: Idx> GenKill<T> for GenKillSet<T> {\n+    fn gen(&mut self, elem: T) {\n+        self.gen.insert(elem);\n+        self.kill.remove(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.kill.insert(elem);\n+        self.gen.remove(elem);\n+    }\n+}\n+\n+impl<T: Idx> GenKill<T> for BitSet<T> {\n+    fn gen(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.remove(elem);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "50d4bdb67f755bfdc15ff68f31e61798129d57c8", "filename": "src/librustc_mir/dataflow/generic/tests.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Ftests.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -0,0 +1,332 @@\n+//! A test for the logic that updates the state in a `ResultsCursor` during seek.\n+\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc::ty;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_span::DUMMY_SP;\n+\n+use super::*;\n+use crate::dataflow::BottomValue;\n+\n+/// Returns `true` if the given location points to a `Call` terminator that can return\n+/// successfully.\n+fn is_call_terminator_non_diverging(body: &mir::Body<'_>, loc: Location) -> bool {\n+    loc == body.terminator_loc(loc.block)\n+        && matches!(\n+            body[loc.block].terminator().kind,\n+            mir::TerminatorKind::Call { destination: Some(_), ..  }\n+        )\n+}\n+\n+/// Creates a `mir::Body` with a few disconnected basic blocks.\n+///\n+/// This is the `Body` that will be used by the `MockAnalysis` below. The shape of its CFG is not\n+/// important.\n+fn mock_body() -> mir::Body<'static> {\n+    let source_info = mir::SourceInfo { scope: mir::OUTERMOST_SOURCE_SCOPE, span: DUMMY_SP };\n+\n+    let mut blocks = IndexVec::new();\n+    let mut block = |n, kind| {\n+        let nop = mir::Statement { source_info, kind: mir::StatementKind::Nop };\n+\n+        blocks.push(mir::BasicBlockData {\n+            statements: std::iter::repeat(&nop).cloned().take(n).collect(),\n+            terminator: Some(mir::Terminator { source_info, kind }),\n+            is_cleanup: false,\n+        })\n+    };\n+\n+    let dummy_place = mir::Place { local: mir::RETURN_PLACE, projection: ty::List::empty() };\n+\n+    block(4, mir::TerminatorKind::Return);\n+    block(1, mir::TerminatorKind::Return);\n+    block(\n+        2,\n+        mir::TerminatorKind::Call {\n+            func: mir::Operand::Copy(dummy_place.clone()),\n+            args: vec![],\n+            destination: Some((dummy_place.clone(), mir::START_BLOCK)),\n+            cleanup: None,\n+            from_hir_call: false,\n+        },\n+    );\n+    block(3, mir::TerminatorKind::Return);\n+    block(0, mir::TerminatorKind::Return);\n+    block(\n+        4,\n+        mir::TerminatorKind::Call {\n+            func: mir::Operand::Copy(dummy_place.clone()),\n+            args: vec![],\n+            destination: Some((dummy_place.clone(), mir::START_BLOCK)),\n+            cleanup: None,\n+            from_hir_call: false,\n+        },\n+    );\n+\n+    mir::Body::new_cfg_only(blocks)\n+}\n+\n+/// A dataflow analysis whose state is unique at every possible `SeekTarget`.\n+///\n+/// Uniqueness is achieved by having a *locally* unique effect before and after each statement and\n+/// terminator (see `effect_at_target`) while ensuring that the entry set for each block is\n+/// *globally* unique (see `mock_entry_set`).\n+///\n+/// For example, a `BasicBlock` with ID `2` and a `Call` terminator has the following state at each\n+/// location (\"+x\" indicates that \"x\" is added to the state).\n+///\n+/// | Location               | Before            | After  |\n+/// |------------------------|-------------------|--------|\n+/// | (on_entry)             | {102}                     ||\n+/// | Statement 0            | +0                | +1     |\n+/// | statement 1            | +2                | +3     |\n+/// | `Call` terminator      | +4                | +5     |\n+/// | (on unwind)            | {102,0,1,2,3,4,5}         ||\n+/// | (on successful return) | +6                        ||\n+///\n+/// The `102` in the block's entry set is derived from the basic block index and ensures that the\n+/// expected state is unique across all basic blocks. Remember, it is generated by\n+/// `mock_entry_sets`, not from actually running `MockAnalysis` to fixpoint.\n+struct MockAnalysis<'tcx> {\n+    body: &'tcx mir::Body<'tcx>,\n+}\n+\n+impl MockAnalysis<'tcx> {\n+    const BASIC_BLOCK_OFFSET: usize = 100;\n+\n+    /// The entry set for each `BasicBlock` is the ID of that block offset by a fixed amount to\n+    /// avoid colliding with the statement/terminator effects.\n+    fn mock_entry_set(&self, bb: BasicBlock) -> BitSet<usize> {\n+        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        ret.insert(Self::BASIC_BLOCK_OFFSET + bb.index());\n+        ret\n+    }\n+\n+    fn mock_entry_sets(&self) -> IndexVec<BasicBlock, BitSet<usize>> {\n+        let empty = BitSet::new_empty(self.bits_per_block(self.body));\n+        let mut ret = IndexVec::from_elem(empty, &self.body.basic_blocks());\n+\n+        for (bb, _) in self.body.basic_blocks().iter_enumerated() {\n+            ret[bb] = self.mock_entry_set(bb);\n+        }\n+\n+        ret\n+    }\n+\n+    /// Returns the index that should be added to the dataflow state at the given target.\n+    ///\n+    /// This index is only unique within a given basic block. `SeekAfter` and\n+    /// `SeekAfterAssumeCallReturns` have the same effect unless `target` is a `Call` terminator.\n+    fn effect_at_target(&self, target: SeekTarget) -> Option<usize> {\n+        use SeekTarget::*;\n+\n+        let idx = match target {\n+            BlockStart(_) => return None,\n+\n+            AfterAssumeCallReturns(loc) if is_call_terminator_non_diverging(self.body, loc) => {\n+                loc.statement_index * 2 + 2\n+            }\n+\n+            Before(loc) => loc.statement_index * 2,\n+            After(loc) | AfterAssumeCallReturns(loc) => loc.statement_index * 2 + 1,\n+        };\n+\n+        assert!(idx < Self::BASIC_BLOCK_OFFSET, \"Too many statements in basic block\");\n+        Some(idx)\n+    }\n+\n+    /// Returns the expected state at the given `SeekTarget`.\n+    ///\n+    /// This is the union of index of the target basic block, the index assigned to the\n+    /// target statement or terminator, and the indices of all preceding statements in the target\n+    /// basic block.\n+    ///\n+    /// For example, the expected state when calling\n+    /// `seek_before(Location { block: 2, statement_index: 2 })` would be `[102, 0, 1, 2, 3, 4]`.\n+    fn expected_state_at_target(&self, target: SeekTarget) -> BitSet<usize> {\n+        let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n+        ret.insert(Self::BASIC_BLOCK_OFFSET + target.block().index());\n+\n+        if let Some(target_effect) = self.effect_at_target(target) {\n+            for i in 0..=target_effect {\n+                ret.insert(i);\n+            }\n+        }\n+\n+        ret\n+    }\n+}\n+\n+impl BottomValue for MockAnalysis<'tcx> {\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+impl AnalysisDomain<'tcx> for MockAnalysis<'tcx> {\n+    type Idx = usize;\n+\n+    const NAME: &'static str = \"mock\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        Self::BASIC_BLOCK_OFFSET + body.basic_blocks().len()\n+    }\n+\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+        unimplemented!(\"This is never called since `MockAnalysis` is never iterated to fixpoint\");\n+    }\n+}\n+\n+impl Analysis<'tcx> for MockAnalysis<'tcx> {\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = self.effect_at_target(SeekTarget::After(location)).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_before_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = self.effect_at_target(SeekTarget::Before(location)).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = self.effect_at_target(SeekTarget::After(location)).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_before_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        let idx = self.effect_at_target(SeekTarget::Before(location)).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _return_place: &mir::Place<'tcx>,\n+    ) {\n+        let location = self.body.terminator_loc(block);\n+        let idx = self.effect_at_target(SeekTarget::AfterAssumeCallReturns(location)).unwrap();\n+        assert!(state.insert(idx));\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+enum SeekTarget {\n+    BlockStart(BasicBlock),\n+    Before(Location),\n+    After(Location),\n+    AfterAssumeCallReturns(Location),\n+}\n+\n+impl SeekTarget {\n+    fn block(&self) -> BasicBlock {\n+        use SeekTarget::*;\n+\n+        match *self {\n+            BlockStart(block) => block,\n+            Before(loc) | After(loc) | AfterAssumeCallReturns(loc) => loc.block,\n+        }\n+    }\n+\n+    /// An iterator over all possible `SeekTarget`s in a given block in order, starting with\n+    /// `BlockStart`.\n+    ///\n+    /// This includes both `After` and `AfterAssumeCallReturns` for every `Location`.\n+    fn iter_in_block(body: &mir::Body<'_>, block: BasicBlock) -> impl Iterator<Item = Self> {\n+        let statements_and_terminator = (0..=body[block].statements.len())\n+            .flat_map(|i| (0..3).map(move |j| (i, j)))\n+            .map(move |(i, kind)| {\n+                let loc = Location { block, statement_index: i };\n+                match kind {\n+                    0 => SeekTarget::Before(loc),\n+                    1 => SeekTarget::After(loc),\n+                    2 => SeekTarget::AfterAssumeCallReturns(loc),\n+                    _ => unreachable!(),\n+                }\n+            });\n+\n+        std::iter::once(SeekTarget::BlockStart(block)).chain(statements_and_terminator)\n+    }\n+}\n+\n+#[test]\n+fn cursor_seek() {\n+    let body = mock_body();\n+    let body = &body;\n+    let analysis = MockAnalysis { body };\n+\n+    let mut cursor =\n+        Results { entry_sets: analysis.mock_entry_sets(), analysis }.into_results_cursor(body);\n+\n+    // Sanity check: the mock call return effect is unique and actually being applied.\n+    let call_terminator_loc = Location { block: BasicBlock::from_usize(2), statement_index: 2 };\n+    assert!(is_call_terminator_non_diverging(body, call_terminator_loc));\n+\n+    let call_return_effect = cursor\n+        .analysis()\n+        .effect_at_target(SeekTarget::AfterAssumeCallReturns(call_terminator_loc))\n+        .unwrap();\n+    assert_ne!(\n+        call_return_effect,\n+        cursor.analysis().effect_at_target(SeekTarget::After(call_terminator_loc)).unwrap()\n+    );\n+\n+    cursor.seek_after(call_terminator_loc);\n+    assert!(!cursor.get().contains(call_return_effect));\n+    cursor.seek_after_assume_call_returns(call_terminator_loc);\n+    assert!(cursor.get().contains(call_return_effect));\n+\n+    let every_target = || {\n+        body.basic_blocks()\n+            .iter_enumerated()\n+            .flat_map(|(bb, _)| SeekTarget::iter_in_block(body, bb))\n+    };\n+\n+    let mut seek_to_target = |targ| {\n+        use SeekTarget::*;\n+\n+        match targ {\n+            BlockStart(block) => cursor.seek_to_block_start(block),\n+            Before(loc) => cursor.seek_before(loc),\n+            After(loc) => cursor.seek_after(loc),\n+            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_call_returns(loc),\n+        }\n+\n+        assert_eq!(cursor.get(), &cursor.analysis().expected_state_at_target(targ));\n+    };\n+\n+    // Seek *to* every possible `SeekTarget` *from* every possible `SeekTarget`.\n+    //\n+    // By resetting the cursor to `from` each time it changes, we end up checking some edges twice.\n+    // What we really want is an Eulerian cycle for the complete digraph over all possible\n+    // `SeekTarget`s, but it's not worth spending the time to compute it.\n+    for from in every_target() {\n+        seek_to_target(from);\n+\n+        for to in every_target() {\n+            seek_to_target(to);\n+            seek_to_target(from);\n+        }\n+    }\n+}"}, {"sha": "2cd2495eef8a29523281a3c1c2f4195758377d33", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -158,7 +158,7 @@ impl<Q> old_dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n     const BOTTOM_VALUE: bool = false;\n }\n \n-impl<Q> dataflow::Analysis<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n+impl<Q> dataflow::AnalysisDomain<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n where\n     Q: Qualif,\n {\n@@ -173,7 +173,12 @@ where\n     fn initialize_start_block(&self, _body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n         self.transfer_function(state).initialize_state();\n     }\n+}\n \n+impl<Q> dataflow::Analysis<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n     fn apply_statement_effect(\n         &self,\n         state: &mut BitSet<Self::Idx>,"}, {"sha": "44b2a90053a385e4472d902bfb4af28d354aefcd", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -32,11 +32,10 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n }\n \n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, item: &'a Item<'mir, 'tcx>, dead_unwinds: &BitSet<BasicBlock>) -> Self {\n+    pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n         let analysis = FlowSensitiveAnalysis::new(q, item);\n-        let results =\n-            dataflow::Engine::new(item.tcx, &item.body, item.def_id, dead_unwinds, analysis)\n-                .iterate_to_fixpoint();\n+        let results = dataflow::Engine::new_generic(item.tcx, &item.body, item.def_id, analysis)\n+            .iterate_to_fixpoint();\n         let cursor = dataflow::ResultsCursor::new(*item.body, results);\n \n         let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n@@ -145,12 +144,10 @@ impl Deref for Validator<'_, 'mir, 'tcx> {\n \n impl Validator<'a, 'mir, 'tcx> {\n     pub fn new(item: &'a Item<'mir, 'tcx>) -> Self {\n-        let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n-\n-        let needs_drop = QualifCursor::new(NeedsDrop, item, &dead_unwinds);\n-\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, item, &dead_unwinds);\n+        let needs_drop = QualifCursor::new(NeedsDrop, item);\n+        let has_mut_interior = QualifCursor::new(HasMutInterior, item);\n \n+        let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n         let indirectly_mutable = old_dataflow::do_dataflow(\n             item.tcx,\n             &*item.body,"}, {"sha": "e4f8b5a0143890ea3ba4fe971346fb58eb244bfc", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cf24ab89123532f0e84995301ee734a88bf4701/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=2cf24ab89123532f0e84995301ee734a88bf4701", "patch": "@@ -167,6 +167,7 @@ symbols! {\n         bindings_after_at,\n         block,\n         bool,\n+        borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n         borrowck_graphviz_preflow,\n         box_patterns,\n@@ -337,6 +338,7 @@ symbols! {\n         FxHashSet,\n         FxHashMap,\n         gen_future,\n+        gen_kill,\n         generators,\n         generic_associated_types,\n         generic_param_attrs,\n@@ -735,6 +737,7 @@ symbols! {\n         try_trait,\n         tt,\n         tuple_indexing,\n+        two_phase,\n         Ty,\n         ty,\n         type_alias_impl_trait,"}]}