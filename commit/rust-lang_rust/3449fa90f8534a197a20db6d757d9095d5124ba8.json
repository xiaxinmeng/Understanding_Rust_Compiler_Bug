{"sha": "3449fa90f8534a197a20db6d757d9095d5124ba8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NDlmYTkwZjg1MzRhMTk3YTIwZGI2ZDc1N2Q5MDk1ZDUxMjRiYTg=", "commit": {"author": {"name": "Loo Maclin", "email": "loo.maclin@protonmail.com", "date": "2019-04-02T19:06:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-02T19:06:08Z"}, "message": "Merge branch 'master' into issue_57128_improve_miri_error_reporting_in_check_in_alloc", "tree": {"sha": "609f931610a1b4f72512390c02db7432f55d0b8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/609f931610a1b4f72512390c02db7432f55d0b8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3449fa90f8534a197a20db6d757d9095d5124ba8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJco7KgCRBK7hj4Ov3rIwAAdHIIAKLXpI1N7tm6sZiFr6UQZU8A\nihYvlQoXcyiD70M/HdKx+UjtYZfIeV/50yNRdkK17xTVAFgsY3tvqR3GIuAOwFJd\nrCrJ7Qo9/lJ8Ba3spR0YCzrgBgQslKjyItCUTxab51Dlu/EM+y4Y/+NDzZQjou7Q\ne7+bV3C6OyfKTWlR7Vq4KTb0J5n4qxZI4Hy8pHfjkqkrsQ6VP50Gaxbzl0kxAm9B\nY+PrULvp6MPuaHMOvlSCrsEPsy0O38EzEvBqs5cNt6zXZ7y/nSRu7fe2cPOrj8jY\naHZjrvDbBC8/Eq58qYDcjyuzL+2lQpztf0VG7/fAag3j4fffvDZdCIF1VzLLPJw=\n=oJIu\n-----END PGP SIGNATURE-----\n", "payload": "tree 609f931610a1b4f72512390c02db7432f55d0b8c\nparent 4c4dbb12d35c502c27b6cf284fcc4d0000661f8c\nparent e008e4fde837313d4a72da603ef492a721afc998\nauthor Loo Maclin <loo.maclin@protonmail.com> 1554231968 +0300\ncommitter GitHub <noreply@github.com> 1554231968 +0300\n\nMerge branch 'master' into issue_57128_improve_miri_error_reporting_in_check_in_alloc"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3449fa90f8534a197a20db6d757d9095d5124ba8", "html_url": "https://github.com/rust-lang/rust/commit/3449fa90f8534a197a20db6d757d9095d5124ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3449fa90f8534a197a20db6d757d9095d5124ba8/comments", "author": {"login": "LooMaclin", "id": 10957765, "node_id": "MDQ6VXNlcjEwOTU3NzY1", "avatar_url": "https://avatars.githubusercontent.com/u/10957765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LooMaclin", "html_url": "https://github.com/LooMaclin", "followers_url": "https://api.github.com/users/LooMaclin/followers", "following_url": "https://api.github.com/users/LooMaclin/following{/other_user}", "gists_url": "https://api.github.com/users/LooMaclin/gists{/gist_id}", "starred_url": "https://api.github.com/users/LooMaclin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LooMaclin/subscriptions", "organizations_url": "https://api.github.com/users/LooMaclin/orgs", "repos_url": "https://api.github.com/users/LooMaclin/repos", "events_url": "https://api.github.com/users/LooMaclin/events{/privacy}", "received_events_url": "https://api.github.com/users/LooMaclin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c4dbb12d35c502c27b6cf284fcc4d0000661f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4dbb12d35c502c27b6cf284fcc4d0000661f8c", "html_url": "https://github.com/rust-lang/rust/commit/4c4dbb12d35c502c27b6cf284fcc4d0000661f8c"}, {"sha": "e008e4fde837313d4a72da603ef492a721afc998", "url": "https://api.github.com/repos/rust-lang/rust/commits/e008e4fde837313d4a72da603ef492a721afc998", "html_url": "https://github.com/rust-lang/rust/commit/e008e4fde837313d4a72da603ef492a721afc998"}], "stats": {"total": 1811, "additions": 1093, "deletions": 718}, "files": [{"sha": "c7007017078e64d583b75d9ff06d98a22bea5754", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -54,6 +54,7 @@ name = \"arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures 0.0.0\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1520,7 +1521,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.28\"\n+version = \"0.0.29\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"macro-utils 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3039,7 +3040,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"minifier 0.0.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"minifier 0.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4149,7 +4150,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a3eb002f0535929f1199681417029ebea04aadc0c7a4224b46be99c7f5d6a16\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n-\"checksum minifier 0.0.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a2898502751dcc9d66b6fff57f3cf63cc91605e83e1a33515396f5027f8e4ca\"\n+\"checksum minifier 0.0.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f4950cb2617b1933e2da0446e864dfe0d6a22c22ff72297996c46e6a63b210b\"\n \"checksum miniz-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0300eafb20369952951699b68243ab4334f4b10a88f411c221d444b36c40e649\"\n \"checksum miniz_oxide 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ad30a47319c16cde58d0314f5d98202a80c9083b5f61178457403dfb14e509c\"\n \"checksum miniz_oxide_c_api 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28edaef377517fd9fe3e085c37d892ce7acd1fbeab9239c5a36eec352d8a8b7e\""}, {"sha": "464cb5b166378dff64619081dd4c42533a1eb989", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1 +1 @@\n-Subproject commit 344c4e437ba4cfa5c14db643ec4d6b68dcd164c5\n+Subproject commit 464cb5b166378dff64619081dd4c42533a1eb989"}, {"sha": "aa1bf38b995976f2d26c424b697281384eb75474", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "0a5b79c36aad86c1326f4959414a1bade713a24e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 139, "deletions": 16, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -23,7 +23,9 @@\n \n extern crate alloc;\n \n+use rustc_data_structures::cold_path;\n use rustc_data_structures::sync::MTLock;\n+use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -55,13 +57,16 @@ pub struct TypedArena<T> {\n struct TypedArenaChunk<T> {\n     /// The raw storage for the arena chunk.\n     storage: RawVec<T>,\n+    /// The number of valid entries in the chunk.\n+    entries: usize,\n }\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n         TypedArenaChunk {\n             storage: RawVec::with_capacity(capacity),\n+            entries: 0,\n         }\n     }\n \n@@ -149,6 +154,34 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n+    #[inline]\n+    fn can_allocate(&self, len: usize) -> bool {\n+        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        let at_least_bytes = len.checked_mul(mem::size_of::<T>()).unwrap();\n+        available_capacity_bytes >= at_least_bytes\n+    }\n+\n+    /// Ensures there's enough space in the current chunk to fit `len` objects.\n+    #[inline]\n+    fn ensure_capacity(&self, len: usize) {\n+        if !self.can_allocate(len) {\n+            self.grow(len);\n+            debug_assert!(self.can_allocate(len));\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_raw_slice(&self, len: usize) -> *mut T {\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(len != 0);\n+\n+        self.ensure_capacity(len);\n+\n+        let start_ptr = self.ptr.get();\n+        self.ptr.set(start_ptr.add(len));\n+        start_ptr\n+    }\n+\n     /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n     /// reference to it. Will panic if passed a zero-sized types.\n     ///\n@@ -161,21 +194,64 @@ impl<T> TypedArena<T> {\n     where\n         T: Copy,\n     {\n+        unsafe {\n+            let len = slice.len();\n+            let start_ptr = self.alloc_raw_slice(len);\n+            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+            slice::from_raw_parts_mut(start_ptr, len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);\n-        assert!(slice.len() != 0);\n+        let mut iter = iter.into_iter();\n+        let size_hint = iter.size_hint();\n \n-        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n-        let at_least_bytes = slice.len() * mem::size_of::<T>();\n-        if available_capacity_bytes < at_least_bytes {\n-            self.grow(slice.len());\n-        }\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n \n-        unsafe {\n-            let start_ptr = self.ptr.get();\n-            let arena_slice = slice::from_raw_parts_mut(start_ptr, slice.len());\n-            self.ptr.set(start_ptr.add(arena_slice.len()));\n-            arena_slice.copy_from_slice(slice);\n-            arena_slice\n+                if len == 0 {\n+                    return &mut [];\n+                }\n+\n+                self.ensure_capacity(len);\n+\n+                let slice = self.ptr.get();\n+\n+                unsafe {\n+                    let mut ptr = self.ptr.get();\n+                    for _ in 0..len {\n+                        // Write into uninitialized memory.\n+                        ptr::write(ptr, iter.next().unwrap());\n+                        // Advance the pointer.\n+                        ptr = ptr.offset(1);\n+                        // Update the pointer per iteration so if `iter.next()` panics\n+                        // we destroy the correct amount\n+                        self.ptr.set(ptr);\n+                    }\n+                    slice::from_raw_parts_mut(slice, len)\n+                }\n+            }\n+            _ => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr = self.alloc_raw_slice(len);\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        vec.set_len(0);\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n         }\n     }\n \n@@ -189,6 +265,7 @@ impl<T> TypedArena<T> {\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n                 let currently_used_cap = used_bytes / mem::size_of::<T>();\n+                last_chunk.entries = currently_used_cap;\n                 if last_chunk.storage.reserve_in_place(currently_used_cap, n) {\n                     self.end.set(last_chunk.end());\n                     return;\n@@ -222,8 +299,7 @@ impl<T> TypedArena<T> {\n                 let len = chunks_borrow.len();\n                 // If `T` is ZST, code below has no effect.\n                 for mut chunk in chunks_borrow.drain(..len-1) {\n-                    let cap = chunk.storage.cap();\n-                    chunk.destroy(cap);\n+                    chunk.destroy(chunk.entries);\n                 }\n             }\n         }\n@@ -265,8 +341,7 @@ unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n                 self.clear_last_chunk(&mut last_chunk);\n                 // The last chunk will be dropped. Destroy all other chunks.\n                 for chunk in chunks_borrow.iter_mut() {\n-                    let cap = chunk.storage.cap();\n-                    chunk.destroy(cap);\n+                    chunk.destroy(chunk.entries);\n                 }\n             }\n             // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n@@ -410,6 +485,54 @@ impl DroplessArena {\n             arena_slice\n         }\n     }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let mut iter = iter.into_iter();\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let size_hint = iter.size_hint();\n+\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n+\n+                if len == 0 {\n+                    return &mut []\n+                }\n+                let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n+                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n+                unsafe {\n+                    for i in 0..len {\n+                        ptr::write(mem.offset(i as isize), iter.next().unwrap())\n+                    }\n+                    slice::from_raw_parts_mut(mem, len)\n+                }\n+            }\n+            (_, _) => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr = self.alloc_raw(\n+                            len * mem::size_of::<T>(),\n+                            mem::align_of::<T>()\n+                        ) as *mut _ as *mut T;\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        vec.set_len(0);\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n+        }\n+    }\n }\n \n #[derive(Default)]"}, {"sha": "7dcfad8306fceab448ae1a3899f2b946648c3603", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -334,3 +334,13 @@ fn bench_filter_chain_ref_count(b: &mut Bencher) {\n         (0i64..1000000).chain(0..1000000).map(black_box).by_ref().filter(|x| x % 3 == 0).count()\n     })\n }\n+\n+#[bench]\n+fn bench_partial_cmp(b: &mut Bencher) {\n+    b.iter(|| (0..100000).map(black_box).partial_cmp((0..100000).map(black_box)))\n+}\n+\n+#[bench]\n+fn bench_lt(b: &mut Bencher) {\n+    b.iter(|| (0..100000).map(black_box).lt((0..100000).map(black_box)))\n+}"}, {"sha": "aefed1890fef8bd8cd81242a05d1c765e3dee691", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 10, "deletions": 51, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -68,11 +68,9 @@ macro_rules! step_impl_unsigned {\n                    issue = \"42168\")]\n         impl Step for $t {\n             #[inline]\n-            #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                 if *start < *end {\n-                    // Note: We assume $t <= usize here\n-                    Some((*end - *start) as usize)\n+                    usize::try_from(*end - *start).ok()\n                 } else {\n                     Some(0)\n                 }\n@@ -98,13 +96,11 @@ macro_rules! step_impl_signed {\n                    issue = \"42168\")]\n         impl Step for $t {\n             #[inline]\n-            #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n                 if *start < *end {\n-                    // Note: We assume $t <= isize here\n-                    // Use .wrapping_sub and cast to usize to compute the\n-                    // difference that may not fit inside the range of isize.\n-                    Some((*end as isize).wrapping_sub(*start as isize) as usize)\n+                    // Use .wrapping_sub and cast to unsigned to compute the\n+                    // difference that may not fit inside the range of $t.\n+                    usize::try_from(end.wrapping_sub(*start) as $unsigned).ok()\n                 } else {\n                     Some(0)\n                 }\n@@ -134,46 +130,9 @@ macro_rules! step_impl_signed {\n     )*)\n }\n \n-macro_rules! step_impl_no_between {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(_start: &Self, _end: &Self) -> Option<usize> {\n-                None\n-            }\n-\n-            #[inline]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                self.checked_add(n as $t)\n-            }\n-\n-            step_identical_methods!();\n-        }\n-    )*)\n-}\n-\n-step_impl_unsigned!(usize u8 u16);\n-#[cfg(not(target_pointer_width = \"16\"))]\n-step_impl_unsigned!(u32);\n-#[cfg(target_pointer_width = \"16\")]\n-step_impl_no_between!(u32);\n+step_impl_unsigned!(usize u8 u16 u32 u64 u128);\n step_impl_signed!([isize: usize] [i8: u8] [i16: u16]);\n-#[cfg(not(target_pointer_width = \"16\"))]\n-step_impl_signed!([i32: u32]);\n-#[cfg(target_pointer_width = \"16\")]\n-step_impl_no_between!(i32);\n-#[cfg(target_pointer_width = \"64\")]\n-step_impl_unsigned!(u64);\n-#[cfg(target_pointer_width = \"64\")]\n-step_impl_signed!([i64: u64]);\n-// If the target pointer width is not 64-bits, we\n-// assume here that it is less than 64-bits.\n-#[cfg(not(target_pointer_width = \"64\"))]\n-step_impl_no_between!(u64 i64);\n-step_impl_no_between!(u128 i128);\n+step_impl_signed!([i32: u32] [i64: u64] [i128: u128]);\n \n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n@@ -229,7 +188,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint, Some(hint)),\n-            None => (0, None)\n+            None => (usize::MAX, None)\n         }\n     }\n \n@@ -273,8 +232,8 @@ range_incl_exact_iter_impl!(u8 u16 i8 i16);\n //\n // They need to guarantee that .size_hint() is either exact, or that\n // the upper bound is None when it does not fit the type limits.\n-range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n-range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 i64 u64);\n+range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n+range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n@@ -350,7 +309,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n         match Step::steps_between(&self.start, &self.end) {\n             Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),\n-            None => (0, None),\n+            None => (usize::MAX, None),\n         }\n     }\n "}, {"sha": "6df4a457655c5e3e92ad62efa6b02b294fcf5bd2", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 14, "deletions": 98, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -2435,145 +2435,61 @@ pub trait Iterator {\n     /// Determines if the elements of this `Iterator` are unequal to those of\n     /// another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn ne<I>(mut self, other: I) -> bool where\n+    fn ne<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_some(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return true,\n-                Some(val) => val,\n-            };\n-\n-            if x != y { return true }\n-        }\n+        !self.eq(other)\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less than those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn lt<I>(mut self, other: I) -> bool where\n+    fn lt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_some(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return false,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return true,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return false,\n-                None => return false,\n-            }\n-        }\n+        self.partial_cmp(other) == Some(Ordering::Less)\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less or equal to those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn le<I>(mut self, other: I) -> bool where\n+    fn le<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => { other.next(); return true; },\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return false,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return true,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return false,\n-                None => return false,\n-            }\n+        match self.partial_cmp(other) {\n+            Some(Ordering::Less) | Some(Ordering::Equal) => true,\n+            _ => false,\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn gt<I>(mut self, other: I) -> bool where\n+    fn gt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => { other.next(); return false; },\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return true,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return false,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return true,\n-                None => return false,\n-            }\n-        }\n+        self.partial_cmp(other) == Some(Ordering::Greater)\n     }\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than or equal to those of another.\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn ge<I>(mut self, other: I) -> bool where\n+    fn ge<I>(self, other: I) -> bool where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n     {\n-        let mut other = other.into_iter();\n-\n-        loop {\n-            let x = match self.next() {\n-                None => return other.next().is_none(),\n-                Some(val) => val,\n-            };\n-\n-            let y = match other.next() {\n-                None => return true,\n-                Some(val) => val,\n-            };\n-\n-            match x.partial_cmp(&y) {\n-                Some(Ordering::Less) => return false,\n-                Some(Ordering::Equal) => (),\n-                Some(Ordering::Greater) => return true,\n-                None => return false,\n-            }\n+        match self.partial_cmp(other) {\n+            Some(Ordering::Greater) | Some(Ordering::Equal) => true,\n+            _ => false,\n         }\n     }\n "}, {"sha": "4a7a16b2c94e0ecef4d86756e050737e2ff2b70d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -2561,7 +2561,6 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n /// # Examples\n ///\n /// ```\n-/// #![feature(ptr_hash)]\n /// use std::collections::hash_map::DefaultHasher;\n /// use std::hash::{Hash, Hasher};\n /// use std::ptr;\n@@ -2579,7 +2578,7 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n ///\n /// assert_eq!(actual, expected);\n /// ```\n-#[unstable(feature = \"ptr_hash\", reason = \"newly added\", issue = \"56286\")]\n+#[stable(feature = \"ptr_hash\", since = \"1.35.0\")]\n pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n     use hash::Hash;\n     hashee.hash(into);"}, {"sha": "d5b581d336d2f6f254a4fd7e10c6d6c418ca18f2", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1,4 +1,5 @@\n use core::cell::Cell;\n+use core::convert::TryFrom;\n use core::iter::*;\n use core::{i8, i16, isize};\n use core::usize;\n@@ -1800,6 +1801,66 @@ fn test_range_inclusive_folds() {\n     assert!(it.is_empty());\n }\n \n+#[test]\n+fn test_range_size_hint() {\n+    use core::usize::MAX as UMAX;\n+    assert_eq!((0..0usize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..100usize).size_hint(), (100, Some(100)));\n+    assert_eq!((0..UMAX).size_hint(), (UMAX, Some(UMAX)));\n+\n+    let umax = u128::try_from(UMAX).unwrap();\n+    assert_eq!((0..0u128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..100u128).size_hint(), (100, Some(100)));\n+    assert_eq!((0..umax).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((0..umax + 1).size_hint(), (UMAX, None));\n+\n+    use core::isize::{MAX as IMAX, MIN as IMIN};\n+    assert_eq!((0..0isize).size_hint(), (0, Some(0)));\n+    assert_eq!((-100..100isize).size_hint(), (200, Some(200)));\n+    assert_eq!((IMIN..IMAX).size_hint(), (UMAX, Some(UMAX)));\n+\n+    let imin = i128::try_from(IMIN).unwrap();\n+    let imax = i128::try_from(IMAX).unwrap();\n+    assert_eq!((0..0i128).size_hint(), (0, Some(0)));\n+    assert_eq!((-100..100i128).size_hint(), (200, Some(200)));\n+    assert_eq!((imin..imax).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((imin..imax + 1).size_hint(), (UMAX, None));\n+}\n+\n+#[test]\n+fn test_range_inclusive_size_hint() {\n+    use core::usize::MAX as UMAX;\n+    assert_eq!((1..=0usize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0usize).size_hint(), (1, Some(1)));\n+    assert_eq!((0..=100usize).size_hint(), (101, Some(101)));\n+    assert_eq!((0..=UMAX - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((0..=UMAX).size_hint(), (UMAX, None));\n+\n+    let umax = u128::try_from(UMAX).unwrap();\n+    assert_eq!((1..=0u128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0u128).size_hint(), (1, Some(1)));\n+    assert_eq!((0..=100u128).size_hint(), (101, Some(101)));\n+    assert_eq!((0..=umax - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((0..=umax).size_hint(), (UMAX, None));\n+    assert_eq!((0..=umax + 1).size_hint(), (UMAX, None));\n+\n+    use core::isize::{MAX as IMAX, MIN as IMIN};\n+    assert_eq!((0..=-1isize).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0isize).size_hint(), (1, Some(1)));\n+    assert_eq!((-100..=100isize).size_hint(), (201, Some(201)));\n+    assert_eq!((IMIN..=IMAX - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((IMIN..=IMAX).size_hint(), (UMAX, None));\n+\n+    let imin = i128::try_from(IMIN).unwrap();\n+    let imax = i128::try_from(IMAX).unwrap();\n+    assert_eq!((0..=-1i128).size_hint(), (0, Some(0)));\n+    assert_eq!((0..=0i128).size_hint(), (1, Some(1)));\n+    assert_eq!((-100..=100i128).size_hint(), (201, Some(201)));\n+    assert_eq!((imin..=imax - 1).size_hint(), (UMAX, Some(UMAX)));\n+    assert_eq!((imin..=imax).size_hint(), (UMAX, None));\n+    assert_eq!((imin..=imax + 1).size_hint(), (UMAX, None));\n+}\n+\n #[test]\n fn test_repeat() {\n     let mut it = repeat(42);"}, {"sha": "c2265eeb30d741d40d6b964146d647a398e6f385", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -490,7 +490,11 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n-        ItemKind::Existential(ExistTy { ref generics, ref bounds, impl_trait_fn: _ }) => {\n+        ItemKind::Existential(ExistTy {\n+            ref generics,\n+            ref bounds,\n+            ..\n+        }) => {\n             visitor.visit_id(item.hir_id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);"}, {"sha": "2a255523676784cc9e556cbb29ca72e03220e94c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 377, "deletions": 284, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -66,7 +66,7 @@ use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -318,6 +318,49 @@ enum AnonymousLifetimeMode {\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n     PassThrough,\n+\n+    /// Used in the return types of `async fn` where there exists\n+    /// exactly one argument-position elided lifetime.\n+    ///\n+    /// In `async fn`, we lower the arguments types using the `CreateParameter`\n+    /// mode, meaning that non-`dyn` elided lifetimes are assigned a fresh name.\n+    /// If any corresponding elided lifetimes appear in the output, we need to\n+    /// replace them with references to the fresh name assigned to the corresponding\n+    /// elided lifetime in the arguments.\n+    ///\n+    /// For **Modern cases**, replace the anonymous parameter with a\n+    /// reference to a specific freshly-named lifetime that was\n+    /// introduced in argument\n+    ///\n+    /// For **Dyn Bound** cases, pass responsibility to\n+    /// `resole_lifetime` code.\n+    Replace(LtReplacement),\n+}\n+\n+/// The type of elided lifetime replacement to perform on `async fn` return types.\n+#[derive(Copy, Clone)]\n+enum LtReplacement {\n+    /// Fresh name introduced by the single non-dyn elided lifetime\n+    /// in the arguments of the async fn.\n+    Some(ParamName),\n+\n+    /// There is no single non-dyn elided lifetime because no lifetimes\n+    /// appeared in the arguments.\n+    NoLifetimes,\n+\n+    /// There is no single non-dyn elided lifetime because multiple\n+    /// lifetimes appeared in the arguments.\n+    MultipleLifetimes,\n+}\n+\n+/// Calculates the `LtReplacement` to use for elided lifetimes in the return\n+/// type based on the fresh elided lifetimes introduced in argument position.\n+fn get_elided_lt_replacement(arg_position_lifetimes: &[(Span, ParamName)]) -> LtReplacement {\n+    match arg_position_lifetimes {\n+        [] => LtReplacement::NoLifetimes,\n+        [(_span, param)] => LtReplacement::Some(*param),\n+        _ => LtReplacement::MultipleLifetimes,\n+    }\n }\n \n struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n@@ -778,53 +821,63 @@ impl<'a> LoweringContext<'a> {\n \n         let params = lifetimes_to_define\n             .into_iter()\n-            .map(|(span, hir_name)| {\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n-\n-                // Get the name we'll use to make the def-path. Note\n-                // that collisions are ok here and this shouldn't\n-                // really show up for end-user.\n-                let (str_name, kind) = match hir_name {\n-                    ParamName::Plain(ident) => (\n-                        ident.as_interned_str(),\n-                        hir::LifetimeParamKind::InBand,\n-                    ),\n-                    ParamName::Fresh(_) => (\n-                        keywords::UnderscoreLifetime.name().as_interned_str(),\n-                        hir::LifetimeParamKind::Elided,\n-                    ),\n-                    ParamName::Error => (\n-                        keywords::UnderscoreLifetime.name().as_interned_str(),\n-                        hir::LifetimeParamKind::Error,\n-                    ),\n-                };\n-\n-                // Add a definition for the in-band lifetime def.\n-                self.resolver.definitions().create_def_with_parent(\n-                    parent_id.index,\n-                    node_id,\n-                    DefPathData::LifetimeParam(str_name),\n-                    DefIndexAddressSpace::High,\n-                    Mark::root(),\n-                    span,\n-                );\n-\n-                hir::GenericParam {\n-                    hir_id,\n-                    name: hir_name,\n-                    attrs: hir_vec![],\n-                    bounds: hir_vec![],\n-                    span,\n-                    pure_wrt_drop: false,\n-                    kind: hir::GenericParamKind::Lifetime { kind }\n-                }\n-            })\n+            .map(|(span, hir_name)| self.lifetime_to_generic_param(\n+                span, hir_name, parent_id.index,\n+            ))\n             .chain(in_band_ty_params.into_iter())\n             .collect();\n \n         (params, res)\n     }\n \n+    /// Converts a lifetime into a new generic parameter.\n+    fn lifetime_to_generic_param(\n+        &mut self,\n+        span: Span,\n+        hir_name: ParamName,\n+        parent_index: DefIndex,\n+    ) -> hir::GenericParam {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n+        // Get the name we'll use to make the def-path. Note\n+        // that collisions are ok here and this shouldn't\n+        // really show up for end-user.\n+        let (str_name, kind) = match hir_name {\n+            ParamName::Plain(ident) => (\n+                ident.as_interned_str(),\n+                hir::LifetimeParamKind::InBand,\n+            ),\n+            ParamName::Fresh(_) => (\n+                keywords::UnderscoreLifetime.name().as_interned_str(),\n+                hir::LifetimeParamKind::Elided,\n+            ),\n+            ParamName::Error => (\n+                keywords::UnderscoreLifetime.name().as_interned_str(),\n+                hir::LifetimeParamKind::Error,\n+            ),\n+        };\n+\n+        // Add a definition for the in-band lifetime def.\n+        self.resolver.definitions().create_def_with_parent(\n+            parent_index,\n+            node_id,\n+            DefPathData::LifetimeParam(str_name),\n+            DefIndexAddressSpace::High,\n+            Mark::root(),\n+            span,\n+        );\n+\n+        hir::GenericParam {\n+            hir_id,\n+            name: hir_name,\n+            attrs: hir_vec![],\n+            bounds: hir_vec![],\n+            span,\n+            pure_wrt_drop: false,\n+            kind: hir::GenericParamKind::Lifetime { kind }\n+        }\n+    }\n+\n     /// When there is a reference to some lifetime `'a`, and in-band\n     /// lifetimes are enabled, then we want to push that lifetime into\n     /// the vector of names to define later. In that case, it will get\n@@ -928,6 +981,13 @@ impl<'a> LoweringContext<'a> {\n             |this| {\n                 this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n                     let mut params = Vec::new();\n+                    // Note: it is necessary to lower generics *before* calling `f`.\n+                    // When lowering `async fn`, there's a final step when lowering\n+                    // the return type that assumes that all in-scope lifetimes have\n+                    // already been added to either `in_scope_lifetimes` or\n+                    // `lifetimes_to_define`. If we swapped the order of these two,\n+                    // in-band-lifetimes introduced by generics or where-clauses\n+                    // wouldn't have been added yet.\n                     let generics = this.lower_generics(\n                         generics,\n                         ImplTraitContext::Universal(&mut params),\n@@ -1426,42 +1486,62 @@ impl<'a> LoweringContext<'a> {\n \n         self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n             let LoweredNodeId { node_id: _, hir_id } = lctx.next_id();\n-            let exist_ty_item_kind = hir::ItemKind::Existential(hir::ExistTy {\n+            let exist_ty_item = hir::ExistTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n                         hir_id,\n-                        predicates: Vec::new().into(),\n+                        predicates: hir_vec![],\n                     },\n                     span,\n                 },\n                 bounds: hir_bounds,\n                 impl_trait_fn: fn_def_id,\n-            });\n-            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n-            // Generate an `existential type Foo: Trait;` declaration.\n-            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n-\n-            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n-            let exist_ty_item = hir::Item {\n-                hir_id: exist_ty_id.hir_id,\n-                ident: keywords::Invalid.ident(),\n-                attrs: Default::default(),\n-                node: exist_ty_item_kind,\n-                vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n-                span: exist_ty_span,\n+                origin: hir::ExistTyOrigin::ReturnImplTrait,\n             };\n \n-            // Insert the item into the global list. This usually happens\n-            // automatically for all AST items. But this existential type item\n-            // does not actually exist in the AST.\n-            lctx.insert_item(exist_ty_item);\n+            trace!(\"exist ty from impl trait def index: {:#?}\", exist_ty_def_index);\n+            let exist_ty_id = lctx.generate_existential_type(\n+                exist_ty_node_id,\n+                exist_ty_item,\n+                span,\n+                exist_ty_span,\n+            );\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n             hir::TyKind::Def(hir::ItemId { id: exist_ty_id.hir_id }, lifetimes)\n         })\n     }\n \n+    /// Registers a new existential type with the proper NodeIds and\n+    /// returns the lowered node ID for the existential type.\n+    fn generate_existential_type(\n+        &mut self,\n+        exist_ty_node_id: NodeId,\n+        exist_ty_item: hir::ExistTy,\n+        span: Span,\n+        exist_ty_span: Span,\n+    ) -> LoweredNodeId {\n+        let exist_ty_item_kind = hir::ItemKind::Existential(exist_ty_item);\n+        let exist_ty_id = self.lower_node_id(exist_ty_node_id);\n+        // Generate an `existential type Foo: Trait;` declaration.\n+        trace!(\"registering existential type with id {:#?}\", exist_ty_id);\n+        let exist_ty_item = hir::Item {\n+            hir_id: exist_ty_id.hir_id,\n+            ident: keywords::Invalid.ident(),\n+            attrs: Default::default(),\n+            node: exist_ty_item_kind,\n+            vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n+            span: exist_ty_span,\n+        };\n+\n+        // Insert the item into the global item list. This usually happens\n+        // automatically for all AST items. But this existential type item\n+        // does not actually exist in the AST.\n+        self.insert_item(exist_ty_item);\n+        exist_ty_id\n+    }\n+\n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n         exist_ty_id: NodeId,\n@@ -1569,9 +1649,6 @@ impl<'a> LoweringContext<'a> {\n                         name,\n                     }));\n \n-                    // We need to manually create the ids here, because the\n-                    // definitions will go into the explicit `existential type`\n-                    // declaration and thus need to have their owner set to that item\n                     let def_node_id = self.context.sess.next_node_id();\n                     let LoweredNodeId { node_id: _, hir_id } =\n                         self.context.lower_node_id_with_owner(def_node_id, self.exist_ty_id);\n@@ -2108,23 +2185,42 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n     ) -> P<hir::FnDecl> {\n-        let inputs = decl.inputs\n-            .iter()\n-            .map(|arg| {\n-                if let Some((_, ref mut ibty)) = in_band_ty_params {\n-                    self.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n-                } else {\n-                    self.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n-                }\n-            })\n-            .collect::<HirVec<_>>();\n+        let lt_mode = if make_ret_async.is_some() {\n+            // In `async fn`, argument-position elided lifetimes\n+            // must be transformed into fresh generic parameters so that\n+            // they can be applied to the existential return type.\n+            AnonymousLifetimeMode::CreateParameter\n+        } else {\n+            self.anonymous_lifetime_mode\n+        };\n+\n+        // Remember how many lifetimes were already around so that we can\n+        // only look at the lifetime parameters introduced by the arguments.\n+        let lifetime_count_before_args = self.lifetimes_to_define.len();\n+        let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n+            decl.inputs\n+                .iter()\n+                .map(|arg| {\n+                    if let Some((_, ibty)) = &mut in_band_ty_params {\n+                        this.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n+                    } else {\n+                        this.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n+                    }\n+                })\n+                .collect::<HirVec<_>>()\n+        });\n \n         let output = if let Some(ret_id) = make_ret_async {\n+            // Calculate the `LtReplacement` to use for any return-position elided\n+            // lifetimes based on the elided lifetime parameters introduced in the args.\n+            let lt_replacement = get_elided_lt_replacement(\n+                &self.lifetimes_to_define[lifetime_count_before_args..]\n+            );\n             self.lower_async_fn_ret_ty(\n-                &inputs,\n                 &decl.output,\n                 in_band_ty_params.expect(\"make_ret_async but no fn_def_id\").0,\n                 ret_id,\n+                lt_replacement,\n             )\n         } else {\n             match decl.output {\n@@ -2173,233 +2269,171 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    // Transform `-> T` into `-> impl Future<Output = T>` for `async fn`\n+    // Transform `-> T` for `async fn` into -> ExistTy { .. }\n+    // combined with the following definition of `ExistTy`:\n+    //\n+    // existential type ExistTy<generics_from_parent_fn>: Future<Output = T>;\n     //\n-    // fn_span: the span of the async function declaration. Used for error reporting.\n     // inputs: lowered types of arguments to the function. Used to collect lifetimes.\n     // output: unlowered output type (`T` in `-> T`)\n     // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n+    // exist_ty_node_id: NodeId of the existential type that should be created.\n+    // elided_lt_replacement: replacement for elided lifetimes in the return type\n     fn lower_async_fn_ret_ty(\n         &mut self,\n-        inputs: &[hir::Ty],\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n-        return_impl_trait_id: NodeId,\n+        exist_ty_node_id: NodeId,\n+        elided_lt_replacement: LtReplacement,\n     ) -> hir::FunctionRetTy {\n-        // Get lifetimes used in the input arguments to the function. Our output type must also\n-        // have the same lifetime.\n-        // FIXME(cramertj): multiple different lifetimes are not allowed because\n-        // `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither is a subset\n-        // of the other. We really want some new lifetime that is a subset of all input lifetimes,\n-        // but that doesn't exist at the moment.\n-\n-        struct AsyncFnLifetimeCollector<'r, 'a: 'r> {\n-            context: &'r mut LoweringContext<'a>,\n-            // Lifetimes bound by HRTB.\n-            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n-            // Whether to count elided lifetimes.\n-            // Disabled inside of `Fn` or `fn` syntax.\n-            collect_elided_lifetimes: bool,\n-            // The lifetime found.\n-            // Multiple different or elided lifetimes cannot appear in async fn for now.\n-            output_lifetime: Option<(hir::LifetimeName, Span)>,\n-        }\n-\n-        impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for AsyncFnLifetimeCollector<'r, 'a> {\n-            fn nested_visit_map<'this>(\n-                &'this mut self,\n-            ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n-                hir::intravisit::NestedVisitorMap::None\n-            }\n+        let span = output.span();\n \n-            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs) {\n-                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n-                if parameters.parenthesized {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-                    hir::intravisit::walk_generic_args(self, span, parameters);\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    hir::intravisit::walk_generic_args(self, span, parameters);\n-                }\n-            }\n-\n-            fn visit_ty(&mut self, t: &'v hir::Ty) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax.\n-                if let &hir::TyKind::BareFn(_) = &t.node {\n-                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                    self.collect_elided_lifetimes = false;\n-\n-                    // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                    // to be able to later fully undo their introduction.\n-                    let old_len = self.currently_bound_lifetimes.len();\n-                    hir::intravisit::walk_ty(self, t);\n-                    self.currently_bound_lifetimes.truncate(old_len);\n-\n-                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-                } else {\n-                    hir::intravisit::walk_ty(self, t);\n-                }\n-            }\n+        let exist_ty_span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Async,\n+            span,\n+            None,\n+        );\n \n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &'v hir::PolyTraitRef,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                // to be able to later fully undo their introduction.\n-                let old_len = self.currently_bound_lifetimes.len();\n-                hir::intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.currently_bound_lifetimes.truncate(old_len);\n-            }\n+        let exist_ty_def_index = self\n+            .resolver\n+            .definitions()\n+            .opt_def_index(exist_ty_node_id)\n+            .unwrap();\n \n-            fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n-                 // Record the introduction of 'a in `for<'a> ...`\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n-                    let lt_name = hir::LifetimeName::Param(param.name);\n-                    self.currently_bound_lifetimes.push(lt_name);\n-                }\n+        self.allocate_hir_id_counter(exist_ty_node_id);\n \n-                hir::intravisit::walk_generic_param(self, param);\n-            }\n+        let (exist_ty_node_id, lifetime_params) = self.with_hir_id_owner(exist_ty_node_id, |this| {\n+            let future_bound = this.with_anonymous_lifetime_mode(\n+                AnonymousLifetimeMode::Replace(elided_lt_replacement),\n+                |this| this.lower_async_fn_output_type_to_future_bound(\n+                    output,\n+                    fn_def_id,\n+                    span,\n+                ),\n+            );\n \n-            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-                let name = match lifetime.name {\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n-                        if self.collect_elided_lifetimes {\n-                            // Use `'_` for both implicit and underscore lifetimes in\n-                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n-                            hir::LifetimeName::Underscore\n-                        } else {\n-                            return;\n-                        }\n-                    }\n-                    hir::LifetimeName::Param(_) => lifetime.name,\n-                    hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n-                };\n+            // Calculate all the lifetimes that should be captured\n+            // by the existential type. This should include all in-scope\n+            // lifetime parameters, including those defined in-band.\n+            //\n+            // Note: this must be done after lowering the output type,\n+            // as the output type may introduce new in-band lifetimes.\n+            let lifetime_params: Vec<(Span, ParamName)> =\n+                this.in_scope_lifetimes\n+                    .iter().cloned()\n+                    .map(|ident| (ident.span, ParamName::Plain(ident)))\n+                    .chain(this.lifetimes_to_define.iter().cloned())\n+                    .collect();\n \n-                if !self.currently_bound_lifetimes.contains(&name) {\n-                    if let Some((current_lt_name, current_lt_span)) = self.output_lifetime {\n-                        // We don't currently have a reliable way to desugar `async fn` with\n-                        // multiple potentially unrelated input lifetimes into\n-                        // `-> impl Trait + 'lt`, so we report an error in this case.\n-                        if current_lt_name != name {\n-                            struct_span_err!(\n-                                self.context.sess,\n-                                MultiSpan::from_spans(vec![current_lt_span, lifetime.span]),\n-                                E0709,\n-                                \"multiple different lifetimes used in arguments of `async fn`\",\n-                            )\n-                                .span_label(current_lt_span, \"first lifetime here\")\n-                                .span_label(lifetime.span, \"different lifetime here\")\n-                                .help(\"`async fn` can only accept borrowed values \\\n-                                      with identical lifetimes\")\n-                                .emit()\n-                        } else if current_lt_name.is_elided() && name.is_elided() {\n-                            struct_span_err!(\n-                                self.context.sess,\n-                                MultiSpan::from_spans(vec![current_lt_span, lifetime.span]),\n-                                E0707,\n-                                \"multiple elided lifetimes used in arguments of `async fn`\",\n-                            )\n-                                .span_label(current_lt_span, \"first lifetime here\")\n-                                .span_label(lifetime.span, \"different lifetime here\")\n-                                .help(\"consider giving these arguments named lifetimes\")\n-                                .emit()\n-                        }\n-                    } else {\n-                        self.output_lifetime = Some((name, lifetime.span));\n-                    }\n-                }\n-            }\n-        }\n+            let generic_params =\n+                lifetime_params\n+                    .iter().cloned()\n+                    .map(|(span, hir_name)| {\n+                        this.lifetime_to_generic_param(span, hir_name, exist_ty_def_index)\n+                    })\n+                    .collect();\n \n-        let bound_lifetime = {\n-            let mut lifetime_collector = AsyncFnLifetimeCollector {\n-                context: self,\n-                currently_bound_lifetimes: Vec::new(),\n-                collect_elided_lifetimes: true,\n-                output_lifetime: None,\n+            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n+            let exist_ty_item = hir::ExistTy {\n+                generics: hir::Generics {\n+                    params: generic_params,\n+                    where_clause: hir::WhereClause {\n+                        hir_id,\n+                        predicates: hir_vec![],\n+                    },\n+                    span,\n+                },\n+                bounds: hir_vec![future_bound],\n+                impl_trait_fn: Some(fn_def_id),\n+                origin: hir::ExistTyOrigin::AsyncFn,\n             };\n \n-            for arg in inputs {\n-                hir::intravisit::walk_ty(&mut lifetime_collector, arg);\n-            }\n-            lifetime_collector.output_lifetime\n-        };\n+            trace!(\"exist ty from async fn def index: {:#?}\", exist_ty_def_index);\n+            let exist_ty_id = this.generate_existential_type(\n+                exist_ty_node_id,\n+                exist_ty_item,\n+                span,\n+                exist_ty_span,\n+            );\n \n-        let span = match output {\n-            FunctionRetTy::Ty(ty) => ty.span,\n-            FunctionRetTy::Default(span) => *span,\n-        };\n+            (exist_ty_id.node_id, lifetime_params)\n+        });\n \n-        let impl_trait_ty = self.lower_existential_impl_trait(\n-            span, Some(fn_def_id), return_impl_trait_id, |this| {\n-            let output_ty = match output {\n-                FunctionRetTy::Ty(ty) => {\n-                    this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n-                }\n-                FunctionRetTy::Default(span) => {\n-                    let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-                    P(hir::Ty {\n+        let generic_args =\n+            lifetime_params\n+                .iter().cloned()\n+                .map(|(span, hir_name)| {\n+                    let LoweredNodeId { node_id: _, hir_id  } = self.next_id();\n+                    GenericArg::Lifetime(hir::Lifetime {\n                         hir_id,\n-                        node: hir::TyKind::Tup(hir_vec![]),\n-                        span: *span,\n+                        span,\n+                        name: hir::LifetimeName::Param(hir_name),\n                     })\n-                }\n-            };\n-\n-            // \"<Output = T>\"\n-            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-            let future_params = P(hir::GenericArgs {\n-                args: hir_vec![],\n-                bindings: hir_vec![hir::TypeBinding {\n-                    ident: Ident::from_str(FN_OUTPUT_NAME),\n-                    ty: output_ty,\n-                    hir_id,\n-                    span,\n-                }],\n-                parenthesized: false,\n-            });\n+                })\n+                .collect();\n \n-            let future_path =\n-                this.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+        let exist_ty_hir_id = self.lower_node_id(exist_ty_node_id).hir_id;\n+        let exist_ty_ref = hir::TyKind::Def(hir::ItemId { id: exist_ty_hir_id }, generic_args);\n \n-            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-            let mut bounds = vec![\n-                hir::GenericBound::Trait(\n-                    hir::PolyTraitRef {\n-                        trait_ref: hir::TraitRef {\n-                            path: future_path,\n-                            hir_ref_id: hir_id,\n-                        },\n-                        bound_generic_params: hir_vec![],\n-                        span,\n-                    },\n-                    hir::TraitBoundModifier::None\n-                ),\n-            ];\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+        hir::FunctionRetTy::Return(P(hir::Ty {\n+            node: exist_ty_ref,\n+            span,\n+            hir_id,\n+        }))\n+    }\n \n-            if let Some((name, span)) = bound_lifetime {\n-                let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n-                bounds.push(hir::GenericBound::Outlives(\n-                    hir::Lifetime { hir_id, name, span }));\n+    /// Turns `-> T` into `Future<Output = T>`\n+    fn lower_async_fn_output_type_to_future_bound(\n+        &mut self,\n+        output: &FunctionRetTy,\n+        fn_def_id: DefId,\n+        span: Span,\n+    ) -> hir::GenericBound {\n+        // Compute the `T` in `Future<Output = T>` from the return type.\n+        let output_ty = match output {\n+            FunctionRetTy::Ty(ty) => {\n+                self.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n             }\n+            FunctionRetTy::Default(ret_ty_span) => {\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+                P(hir::Ty {\n+                    hir_id,\n+                    node: hir::TyKind::Tup(hir_vec![]),\n+                    span: *ret_ty_span,\n+                })\n+            }\n+        };\n \n-            hir::HirVec::from(bounds)\n-        });\n-\n+        // \"<Output = T>\"\n         let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n-        let impl_trait_ty = P(hir::Ty {\n-            node: impl_trait_ty,\n-            span,\n-            hir_id,\n+        let future_params = P(hir::GenericArgs {\n+            args: hir_vec![],\n+            bindings: hir_vec![hir::TypeBinding {\n+                ident: Ident::from_str(FN_OUTPUT_NAME),\n+                ty: output_ty,\n+                hir_id,\n+                span,\n+            }],\n+            parenthesized: false,\n         });\n \n-        hir::FunctionRetTy::Return(impl_trait_ty)\n+        // ::std::future::Future<future_params>\n+        let future_path =\n+            self.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+        hir::GenericBound::Trait(\n+            hir::PolyTraitRef {\n+                trait_ref: hir::TraitRef {\n+                    path: future_path,\n+                    hir_ref_id: hir_id,\n+                },\n+                bound_generic_params: hir_vec![],\n+                span,\n+            },\n+            hir::TraitBoundModifier::None,\n+        )\n     }\n \n     fn lower_param_bound(\n@@ -2437,6 +2471,11 @@ impl<'a> LoweringContext<'a> {\n                     }\n \n                     AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n+\n+                    AnonymousLifetimeMode::Replace(replacement) => {\n+                        let LoweredNodeId { node_id: _, hir_id  } = self.lower_node_id(l.id);\n+                        self.replace_elided_lifetime(hir_id, span, replacement)\n+                    }\n                 },\n             ident => {\n                 self.maybe_collect_in_band_lifetime(ident);\n@@ -2461,6 +2500,39 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    /// Replace a return-position elided lifetime with the elided lifetime\n+    /// from the arguments.\n+    fn replace_elided_lifetime(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        replacement: LtReplacement,\n+    ) -> hir::Lifetime {\n+        let multiple_or_none = match replacement {\n+            LtReplacement::Some(name) => {\n+                return hir::Lifetime {\n+                    hir_id,\n+                    span,\n+                    name: hir::LifetimeName::Param(name),\n+                };\n+            }\n+            LtReplacement::MultipleLifetimes => \"multiple\",\n+            LtReplacement::NoLifetimes => \"none\",\n+        };\n+\n+        let mut err = crate::middle::resolve_lifetime::report_missing_lifetime_specifiers(\n+            self.sess,\n+            span,\n+            1,\n+        );\n+        err.note(&format!(\n+            \"return-position elided lifetimes require exactly one \\\n+             input-position elided lifetime, found {}.\", multiple_or_none));\n+        err.emit();\n+\n+        hir::Lifetime { hir_id, span, name: hir::LifetimeName::Error }\n+    }\n+\n     fn lower_generic_params(\n         &mut self,\n         params: &[GenericParam],\n@@ -2941,6 +3013,7 @@ impl<'a> LoweringContext<'a> {\n                 generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 bounds: self.lower_param_bounds(b, ImplTraitContext::disallowed()),\n                 impl_trait_fn: None,\n+                origin: hir::ExistTyOrigin::ExistentialType,\n             }),\n             ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n@@ -5083,7 +5156,8 @@ impl<'a> LoweringContext<'a> {\n     /// with no explicit lifetime.\n     fn elided_ref_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n-            // Intercept when we are in an impl header and introduce an in-band lifetime.\n+            // Intercept when we are in an impl header or async fn and introduce an in-band\n+            // lifetime.\n             // Hence `impl Foo for &u32` becomes `impl<'f> Foo for &'f u32` for some fresh\n             // `'f`.\n             AnonymousLifetimeMode::CreateParameter => {\n@@ -5099,6 +5173,10 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n \n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n+\n+            AnonymousLifetimeMode::Replace(replacement) => {\n+                self.new_replacement_lifetime(replacement, span)\n+            }\n         }\n     }\n \n@@ -5133,28 +5211,29 @@ impl<'a> LoweringContext<'a> {\n     /// sorts of cases are deprecated. This may therefore report a warning or an\n     /// error, depending on the mode.\n     fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n+        (0..count)\n+            .map(|_| self.elided_path_lifetime(span))\n+            .collect()\n+    }\n+\n+    fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n             // N.B., We intentionally ignore the create-parameter mode here\n             // and instead \"pass through\" to resolve-lifetimes, which will then\n             // report an error. This is because we don't want to support\n             // impl elision for deprecated forms like\n             //\n             //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-            AnonymousLifetimeMode::CreateParameter => {}\n+            AnonymousLifetimeMode::CreateParameter |\n+            // This is the normal case.\n+            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n \n-            AnonymousLifetimeMode::ReportError => {\n-                return (0..count)\n-                    .map(|_| self.new_error_lifetime(None, span))\n-                    .collect();\n+            AnonymousLifetimeMode::Replace(replacement) => {\n+                self.new_replacement_lifetime(replacement, span)\n             }\n \n-            // This is the normal case.\n-            AnonymousLifetimeMode::PassThrough => {}\n+            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n         }\n-\n-        (0..count)\n-            .map(|_| self.new_implicit_lifetime(span))\n-            .collect()\n     }\n \n     /// Invoked to create the lifetime argument(s) for an elided trait object\n@@ -5184,11 +5263,25 @@ impl<'a> LoweringContext<'a> {\n \n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => {}\n+\n+            // We don't need to do any replacement here as this lifetime\n+            // doesn't refer to an elided lifetime elsewhere in the function\n+            // signature.\n+            AnonymousLifetimeMode::Replace(_) => {}\n         }\n \n         self.new_implicit_lifetime(span)\n     }\n \n+    fn new_replacement_lifetime(\n+        &mut self,\n+        replacement: LtReplacement,\n+        span: Span,\n+    ) -> hir::Lifetime {\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n+        self.replace_elided_lifetime(hir_id, span, replacement)\n+    }\n+\n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n "}, {"sha": "58a27d3f78eec3fb98379d9f2ad4d18d18cd2ce5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1799,6 +1799,18 @@ pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n+    pub origin: ExistTyOrigin,\n+}\n+\n+/// Where the existential type came from\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub enum ExistTyOrigin {\n+    /// `existential type Foo: Trait;`\n+    ExistentialType,\n+    /// `-> impl Trait`\n+    ReturnImplTrait,\n+    /// `async fn`\n+    AsyncFn,\n }\n \n /// The various kinds of types recognized by the compiler."}, {"sha": "7403a5d7dbb09e80219a9441da7b95c3abf2a222", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1,6 +1,7 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::hir::{FunctionRetTy, TyKind};\n use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n@@ -11,9 +12,10 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let (span, sub, sup) = self.get_regions();\n \n         debug!(\n-            \"try_report_named_anon_conflict(sub={:?}, sup={:?})\",\n+            \"try_report_named_anon_conflict(sub={:?}, sup={:?}, error={:?})\",\n             sub,\n-            sup\n+            sup,\n+            self.error,\n         );\n \n         // Determine whether the sub and sup consist of one named region ('a)\n@@ -84,6 +86,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             {\n                 return None;\n             }\n+            if let FunctionRetTy::Return(ty) = &fndecl.output {\n+                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.node, sub) {\n+                    // This is an impl Trait return that evaluates de need of 'static.\n+                    // We handle this case better in `static_impl_trait`.\n+                    return None;\n+                }\n+            }\n         }\n \n         let (error_var, span_label_var) = if let Some(simple_ident) = arg.pat.simple_ident() {\n@@ -103,13 +112,13 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             error_var\n         );\n \n+        diag.span_label(span, format!(\"lifetime `{}` required\", named));\n         diag.span_suggestion(\n-                new_ty_span,\n-                &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-                new_ty.to_string(),\n-                Applicability::Unspecified,\n-            )\n-            .span_label(span, format!(\"lifetime `{}` required\", named));\n+            new_ty_span,\n+            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n+            new_ty.to_string(),\n+            Applicability::Unspecified,\n+        );\n \n         Some(diag)\n     }"}, {"sha": "be9460ad86fc4524384b06298379242fec9222df", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -67,6 +67,9 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// the fn body). (Ultimately, writeback is responsible for this\n     /// check.)\n     pub has_required_region_bounds: bool,\n+\n+    /// The origin of the existential type\n+    pub origin: hir::ExistTyOrigin,\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -326,14 +329,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // There are two regions (`lr` and\n                         // `subst_arg`) which are not relatable. We can't\n                         // find a best choice.\n-                        self.tcx\n+                        let context_name = match opaque_defn.origin {\n+                            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n+                            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n+                            hir::ExistTyOrigin::AsyncFn => \"async fn\",\n+                        };\n+                        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n+                        let mut err = self.tcx\n                             .sess\n-                            .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n-                            .span_label(\n-                                span,\n-                                format!(\"neither `{}` nor `{}` outlives the other\", lr, subst_arg),\n-                            )\n-                            .emit();\n+                            .struct_span_err(span, &msg);\n+\n+                        let lr_name = lr.to_string();\n+                        let subst_arg_name = subst_arg.to_string();\n+                        let label_owned;\n+                        let label = match (&*lr_name, &*subst_arg_name) {\n+                            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n+                            _ => {\n+                                label_owned = format!(\n+                                    \"neither `{}` nor `{}` outlives the other\",\n+                                    lr_name,\n+                                    subst_arg_name,\n+                                );\n+                                &label_owned\n+                            }\n+                        };\n+                        err.span_label(span, label);\n+\n+                        if let hir::ExistTyOrigin::AsyncFn = opaque_defn.origin {\n+                            err.note(\"multiple unrelated lifetimes are not allowed in \\\n+                                     `async fn`.\");\n+                            err.note(\"if you're using argument-position elided lifetimes, consider \\\n+                                switching to a single named lifetime.\");\n+                        }\n+                        err.emit();\n \n                         least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n                         break;\n@@ -692,39 +720,49 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             parent_def_id == tcx.hir()\n                                                 .local_def_id_from_hir_id(opaque_parent_hir_id)\n                         };\n-                        let in_definition_scope = match tcx.hir().find_by_hir_id(opaque_hir_id) {\n+                        let (in_definition_scope, origin) =\n+                            match tcx.hir().find_by_hir_id(opaque_hir_id)\n+                        {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n+                                    origin,\n                                     ..\n-                                }) => parent == self.parent_def_id,\n+                                }) => (parent == self.parent_def_id, origin),\n                                 // named existential types\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: None,\n+                                    origin,\n                                     ..\n-                                }) => may_define_existential_type(\n-                                    tcx,\n-                                    self.parent_def_id,\n-                                    opaque_hir_id,\n+                                }) => (\n+                                    may_define_existential_type(\n+                                        tcx,\n+                                        self.parent_def_id,\n+                                        opaque_hir_id,\n+                                    ),\n+                                    origin,\n                                 ),\n-                                _ => def_scope_default(),\n+                                _ => (def_scope_default(), hir::ExistTyOrigin::ExistentialType),\n                             },\n                             Some(Node::ImplItem(item)) => match item.node {\n-                                hir::ImplItemKind::Existential(_) => may_define_existential_type(\n-                                    tcx,\n-                                    self.parent_def_id,\n-                                    opaque_hir_id,\n+                                hir::ImplItemKind::Existential(_) => (\n+                                    may_define_existential_type(\n+                                        tcx,\n+                                        self.parent_def_id,\n+                                        opaque_hir_id,\n+                                    ),\n+                                    hir::ExistTyOrigin::ExistentialType,\n                                 ),\n-                                _ => def_scope_default(),\n+                                _ => (def_scope_default(), hir::ExistTyOrigin::ExistentialType),\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n                                 tcx.hir().hir_to_string(opaque_hir_id),\n                             ),\n                         };\n                         if in_definition_scope {\n-                            return self.fold_opaque_ty(ty, def_id, substs);\n+                            return self.fold_opaque_ty(ty, def_id, substs, origin);\n                         }\n \n                         debug!(\n@@ -746,6 +784,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n+        origin: hir::ExistTyOrigin,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n@@ -795,6 +834,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                 substs,\n                 concrete_ty: ty_var,\n                 has_required_region_bounds: !required_region_bounds.is_empty(),\n+                origin,\n             },\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);"}, {"sha": "3306bcae2123d648c5731c70a8cc64721c4de763", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -2891,7 +2891,7 @@ fn insert_late_bound_lifetimes(\n     }\n }\n \n-fn report_missing_lifetime_specifiers(\n+pub fn report_missing_lifetime_specifiers(\n     sess: &Session,\n     span: Span,\n     count: usize,"}, {"sha": "23a47fb1a35ead457bd5156cde3dc83ce6350042", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -43,7 +43,7 @@ pub type ConstEvalResult<'tcx> = Result<ty::Const<'tcx>, ErrorHandled>;\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub error: crate::mir::interpret::EvalErrorKind<'tcx, u64>,\n+    pub error: crate::mir::interpret::InterpError<'tcx, u64>,\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n@@ -135,10 +135,10 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         match self.error {\n-            EvalErrorKind::Layout(LayoutError::Unknown(_)) |\n-            EvalErrorKind::TooGeneric => return Err(ErrorHandled::TooGeneric),\n-            EvalErrorKind::Layout(LayoutError::SizeOverflow(_)) |\n-            EvalErrorKind::TypeckError => return Err(ErrorHandled::Reported),\n+            InterpError::Layout(LayoutError::Unknown(_)) |\n+            InterpError::TooGeneric => return Err(ErrorHandled::TooGeneric),\n+            InterpError::Layout(LayoutError::SizeOverflow(_)) |\n+            InterpError::TypeckError => return Err(ErrorHandled::Reported),\n             _ => {},\n         }\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n@@ -180,7 +180,7 @@ pub fn struct_error<'a, 'gcx, 'tcx>(\n \n #[derive(Debug, Clone)]\n pub struct EvalError<'tcx> {\n-    pub kind: EvalErrorKind<'tcx, u64>,\n+    pub kind: InterpError<'tcx, u64>,\n     pub backtrace: Option<Box<Backtrace>>,\n }\n \n@@ -197,8 +197,8 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n-impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n-    fn from(kind: EvalErrorKind<'tcx, u64>) -> Self {\n+impl<'tcx> From<InterpError<'tcx, u64>> for EvalError<'tcx> {\n+    fn from(kind: InterpError<'tcx, u64>) -> Self {\n         let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n             // matching RUST_BACKTRACE, we treat \"0\" the same as \"not present\".\n             Ok(ref val) if val != \"0\" => {\n@@ -221,10 +221,10 @@ impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n     }\n }\n \n-pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n+pub type AssertMessage<'tcx> = InterpError<'tcx, mir::Operand<'tcx>>;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum EvalErrorKind<'tcx, O> {\n+pub enum InterpError<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant.\n     MachineError(String),\n@@ -312,9 +312,9 @@ pub enum EvalErrorKind<'tcx, O> {\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n-impl<'tcx, O> EvalErrorKind<'tcx, O> {\n+impl<'tcx, O> InterpError<'tcx, O> {\n     pub fn description(&self) -> &str {\n-        use self::EvalErrorKind::*;\n+        use self::InterpError::*;\n         match *self {\n             MachineError(ref inner) => inner,\n             FunctionAbiMismatch(..) | FunctionArgMismatch(..) | FunctionRetMismatch(..)\n@@ -450,15 +450,15 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Display for EvalErrorKind<'tcx, u64> {\n+impl<'tcx> fmt::Display for InterpError<'tcx, u64> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self)\n     }\n }\n \n-impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n+impl<'tcx, O: fmt::Debug> fmt::Debug for InterpError<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::EvalErrorKind::*;\n+        use self::InterpError::*;\n         match *self {\n             PointerOutOfBounds { ptr, msg, allocation_size } => {\n                 write!(f, \"Pointer must be in-bounds{} at offset {}, but is outside bounds of \\"}, {"sha": "595ea8bd34687c6451960d1e7e407b98ba064563", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -2,7 +2,7 @@\n \n #[macro_export]\n macro_rules! err {\n-    ($($tt:tt)*) => { Err($crate::mir::interpret::EvalErrorKind::$($tt)*.into()) };\n+    ($($tt:tt)*) => { Err($crate::mir::interpret::InterpError::$($tt)*.into()) };\n }\n \n mod error;\n@@ -11,7 +11,7 @@ mod allocation;\n mod pointer;\n \n pub use self::error::{\n-    EvalError, EvalResult, EvalErrorKind, AssertMessage, ConstEvalErr, struct_error,\n+    EvalError, EvalResult, InterpError, AssertMessage, ConstEvalErr, struct_error,\n     FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n };\n "}, {"sha": "a7ab0d6cb0408cca715fdcccf166a8496abcf575", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -5,7 +5,7 @@\n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, HirId, InlineAsm};\n-use crate::mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n+use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -3226,8 +3226,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 target,\n                 cleanup,\n             } => {\n-                let msg = if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n-                    EvalErrorKind::BoundsCheck {\n+                let msg = if let InterpError::BoundsCheck { ref len, ref index } = *msg {\n+                    InterpError::BoundsCheck {\n                         len: len.fold_with(folder),\n                         index: index.fold_with(folder),\n                     }\n@@ -3301,7 +3301,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 ref cond, ref msg, ..\n             } => {\n                 if cond.visit_with(visitor) {\n-                    if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n+                    if let InterpError::BoundsCheck { ref len, ref index } = *msg {\n                         len.visit_with(visitor) || index.visit_with(visitor)\n                     } else {\n                         false"}, {"sha": "4d44dc197cb783e7eb698126382a930d997a5d26", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -560,7 +560,7 @@ macro_rules! make_mir_visitor {\n             fn super_assert_message(&mut self,\n                                     msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n-                use crate::mir::interpret::EvalErrorKind::*;\n+                use crate::mir::interpret::InterpError::*;\n                 if let BoundsCheck { len, index } = msg {\n                     self.visit_operand(len, location);\n                     self.visit_operand(index, location);"}, {"sha": "988e4a9ff23a2809d159411e73b515bd355a6cfc", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1200,6 +1200,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"when using two-phase-borrows, allow two phases even for non-autoref `&mut` borrows\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n+    time: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of rustc processes\"),\n     count_llvm_insns: bool = (false, parse_bool,\n         [UNTRACKED_WITH_WARNING(true,\n         \"The output generated by `-Z count_llvm_insns` might not be reliable \\"}, {"sha": "2f3df32945ceb050be73e4c93b2825203fbdba30", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -504,6 +504,9 @@ impl Session {\n         self.opts.debugging_opts.verbose\n     }\n     pub fn time_passes(&self) -> bool {\n+        self.opts.debugging_opts.time_passes || self.opts.debugging_opts.time\n+    }\n+    pub fn time_extended(&self) -> bool {\n         self.opts.debugging_opts.time_passes\n     }\n     pub fn profile_queries(&self) -> bool {"}, {"sha": "28cf3f5245ef87c4a014cc0e862ba16491b95682", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -12,7 +12,7 @@ use crate::session::{CrateDisambiguator, Session};\n use crate::ty;\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n-use crate::util::common::time;\n+use crate::util::common::{time, time_ext};\n \n use errors::Diagnostic;\n use rustc_data_structures::fx::FxHashMap;\n@@ -1080,23 +1080,22 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let desc = &format!(\"encode_query_results for {}\",\n         unsafe { ::std::intrinsics::type_name::<Q>() });\n \n-    time(tcx.sess, desc, || {\n+    time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n+        let map = Q::query_cache(tcx).borrow();\n+        assert!(map.active.is_empty());\n+        for (key, entry) in map.results.iter() {\n+            if Q::cache_on_disk(tcx, key.clone()) {\n+                let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n-    let map = Q::query_cache(tcx).borrow();\n-    assert!(map.active.is_empty());\n-    for (key, entry) in map.results.iter() {\n-        if Q::cache_on_disk(tcx, key.clone()) {\n-            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n+                // Record position of the cache entry\n+                query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-            // Record position of the cache entry\n-            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n-\n-            // Encode the type check tables with the SerializedDepNodeIndex\n-            // as tag.\n-            encoder.encode_tagged(dep_node, &entry.value)?;\n+                // Encode the type check tables with the SerializedDepNodeIndex\n+                // as tag.\n+                encoder.encode_tagged(dep_node, &entry.value)?;\n+            }\n         }\n-    }\n \n-    Ok(())\n+        Ok(())\n     })\n }"}, {"sha": "f10bc0516e5bf38a9c049ab3e053bd3d9d40dd93", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -18,7 +18,7 @@ use rustc::session::Session;\n use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use rustc_codegen_ssa::CodegenResults;\n-use rustc::util::common::time;\n+use rustc::util::common::{time, time_ext};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc::hir::def_id::CrateNum;\n use tempfile::{Builder as TempFileBuilder, TempDir};\n@@ -1319,7 +1319,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        time(sess, &format!(\"altering {}.rlib\", name), || {\n+        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n             let cfg = archive_config(sess, &dst, Some(cratepath));\n             let mut archive = ArchiveBuilder::new(cfg);\n             archive.update_symbols();"}, {"sha": "fa8c4177eafe23fb900cad53b86c625bcc2ffb0d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -125,7 +125,7 @@ impl ModuleConfig {\n         self.verify_llvm_ir = sess.verify_llvm_ir();\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n         self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n-        self.time_passes = sess.time_passes();\n+        self.time_passes = sess.time_extended();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode ||\n                               sess.opts.cg.linker_plugin_lto.enabled();\n@@ -1091,7 +1091,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         fewer_names: sess.fewer_names(),\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n-        time_passes: sess.time_passes(),\n+        time_passes: sess.time_extended(),\n         profiler: sess.self_profiling.clone(),\n         exported_symbols,\n         plugin_passes: sess.plugin_llvm_passes.borrow().clone(),"}, {"sha": "53e8f7ed88b4eb5bf9ec056f970f0de68574761e", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -2,7 +2,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n-use rustc::mir::interpret::EvalErrorKind;\n+use rustc::mir::interpret::InterpError;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n use rustc_mir::monomorphize;\n@@ -365,7 +365,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // checked operation, just a comparison with the minimum\n         // value, so we have to check for the assert message.\n         if !bx.check_overflow() {\n-            if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n+            if let mir::interpret::InterpError::OverflowNeg = *msg {\n                 const_cond = Some(expected);\n             }\n         }\n@@ -400,7 +400,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match *msg {\n-            EvalErrorKind::BoundsCheck { ref len, ref index } => {\n+            InterpError::BoundsCheck { ref len, ref index } => {\n                 let len = self.codegen_operand(&mut bx, len).immediate();\n                 let index = self.codegen_operand(&mut bx, index).immediate();\n "}, {"sha": "a94350f9cde005d1d808b8441862e13514682538", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -511,14 +511,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 )\n             }\n \n-            (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n-            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _) => {\n-                // Shallow borrows are uses from the user's point of view.\n-                self.report_use_while_mutably_borrowed(context, (place, span), issued_borrow);\n-                return;\n-            }\n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n             | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n             | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n             | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n         };"}, {"sha": "820a990c633e04f5f78dce181fe61fd45649c0ce", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -688,7 +688,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 cleanup: _,\n             } => {\n                 self.consume_operand(ContextKind::Assert.new(loc), (cond, span), flow_state);\n-                use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+                use rustc::mir::interpret::InterpError::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n                     self.consume_operand(ContextKind::Assert.new(loc), (index, span), flow_state);"}, {"sha": "9f51fb9e969c30c7e1b667fb26c36ee1b9dbd990", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -215,7 +215,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 cleanup: _,\n             } => {\n                 self.consume_operand(ContextKind::Assert.new(location), cond);\n-                use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+                use rustc::mir::interpret::InterpError::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n                     self.consume_operand(ContextKind::Assert.new(location), len);\n                     self.consume_operand(ContextKind::Assert.new(location), index);"}, {"sha": "3773f1a40c7924545878b83ec8b7dc0c03a4370d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -132,6 +132,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         });\n         if let Some(i) = best_choice {\n+            if let Some(next) = categorized_path.get(i + 1) {\n+                if categorized_path[i].0 == ConstraintCategory::Return\n+                    && next.0 == ConstraintCategory::OpaqueType\n+                {\n+                    // The return expression is being influenced by the return type being\n+                    // impl Trait, point at the return type and not the return expr.\n+                    return *next;\n+                }\n+            }\n             return categorized_path[i];\n         }\n \n@@ -240,6 +249,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.provides_universal_region(r, fr, outlived_fr)\n         });\n \n+        debug!(\"report_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);"}, {"sha": "ac10683598aa7e183262881ffc85669db03dfc23", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -403,8 +403,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n-        common::time(\n-            infcx.tcx.sess,\n+        common::time_ext(\n+            infcx.tcx.sess.time_extended(),\n+            Some(infcx.tcx.sess),\n             &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n             || self.solve_inner(infcx, mir, mir_def_id, errors_buffer),\n         )"}, {"sha": "5041a7ffee258ef8c916e00b6425100ae508a7bd", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -28,7 +28,7 @@ use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::mir::interpret::{EvalErrorKind::BoundsCheck, ConstValue};\n+use rustc::mir::interpret::{InterpError::BoundsCheck, ConstValue};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;"}, {"sha": "f7cf09020138c7592e29e1c3972b1a25ce7b03b1", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -4,7 +4,7 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n-use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+use rustc::mir::interpret::InterpError::BoundsCheck;\n use rustc::mir::*;\n use rustc::ty::{CanonicalUserTypeAnnotation, Variance};\n "}, {"sha": "7289dd96edb8dcf4a733f8221984c345b7658e2a", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -7,7 +7,7 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::middle::region;\n-use rustc::mir::interpret::EvalErrorKind;\n+use rustc::mir::interpret::InterpError;\n use rustc::mir::*;\n use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, UpvarSubsts};\n use syntax_pos::Span;\n@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         block,\n                         Operand::Move(is_min),\n                         false,\n-                        EvalErrorKind::OverflowNeg,\n+                        InterpError::OverflowNeg,\n                         expr_span,\n                     );\n                 }\n@@ -433,7 +433,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let val = result_value.clone().field(val_fld, ty);\n             let of = result_value.field(of_fld, bool_ty);\n \n-            let err = EvalErrorKind::Overflow(op);\n+            let err = InterpError::Overflow(op);\n \n             block = self.assert(block, Operand::Move(of), false, err, span);\n \n@@ -444,9 +444,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n                 let (zero_err, overflow_err) = if op == BinOp::Div {\n-                    (EvalErrorKind::DivisionByZero, EvalErrorKind::Overflow(op))\n+                    (InterpError::DivisionByZero, InterpError::Overflow(op))\n                 } else {\n-                    (EvalErrorKind::RemainderByZero, EvalErrorKind::Overflow(op))\n+                    (InterpError::RemainderByZero, InterpError::Overflow(op))\n                 };\n \n                 // Check for / 0"}, {"sha": "33715b749f9942b5100886409688be9dd51c076d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -23,7 +23,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue,\n-    EvalResult, EvalError, EvalErrorKind, GlobalId, InterpretCx, StackPopCleanup,\n+    EvalResult, EvalError, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n };\n@@ -173,7 +173,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     fn into(self) -> EvalError<'tcx> {\n-        EvalErrorKind::MachineError(self.to_string()).into()\n+        InterpError::MachineError(self.to_string()).into()\n     }\n }\n \n@@ -351,7 +351,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         Ok(Some(match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(err) => {\n-                if let EvalErrorKind::NoMirFor(ref path) = err.kind {\n+                if let InterpError::NoMirFor(ref path) = err.kind {\n                     return Err(\n                         ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n                             .into(),\n@@ -679,7 +679,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // any other kind of error will be reported to the user as a deny-by-default lint\n                 _ => if let Some(p) = cid.promoted {\n                     let span = tcx.optimized_mir(def_id).promoted[p].span;\n-                    if let EvalErrorKind::ReferencedConstant = err.error {\n+                    if let InterpError::ReferencedConstant = err.error {\n                         err.report_as_error(\n                             tcx.at(span),\n                             \"evaluation of constant expression failed\","}, {"sha": "5056d79bec4b1c0dc92e41799bc747faf09c6a2d", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind, truncate\n+    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError, truncate\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -85,7 +85,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                             self.param_env,\n                             def_id,\n                             substs,\n-                        ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n+                        ).ok_or_else(|| InterpError::TooGeneric.into());\n                         let fn_ptr = self.memory.create_fn_alloc(instance?).with_default_tag();\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }"}, {"sha": "535fc58299bc4bfd37f067c579890fbb75ddb37b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n     ErrorHandled,\n     GlobalId, Scalar, FrameInfo, AllocId,\n-    EvalResult, EvalErrorKind,\n+    EvalResult, InterpError,\n     truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n@@ -167,7 +167,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n-            .map_err(|layout| EvalErrorKind::Layout(layout).into())\n+            .map_err(|layout| InterpError::Layout(layout).into())\n     }\n }\n \n@@ -255,7 +255,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n             self.param_env,\n             def_id,\n             substs,\n-        ).ok_or_else(|| EvalErrorKind::TooGeneric.into())\n+        ).ok_or_else(|| InterpError::TooGeneric.into())\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n@@ -647,8 +647,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n         let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n             match err {\n-                ErrorHandled::Reported => EvalErrorKind::ReferencedConstant,\n-                ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric,\n+                ErrorHandled::Reported => InterpError::ReferencedConstant,\n+                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n             }\n         })?;\n         self.raw_const_to_mplace(val)\n@@ -670,7 +670,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n \n                 match self.stack[frame].locals[local].access() {\n                     Err(err) => {\n-                        if let EvalErrorKind::DeadLocal = err.kind {\n+                        if let InterpError::DeadLocal = err.kind {\n                             write!(msg, \" is dead\").unwrap();\n                         } else {\n                             panic!(\"Failed to access local: {:?}\", err);"}, {"sha": "d9721a8cadff9ff55547136b492fb8a231770074", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -7,7 +7,7 @@ use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::mir::BinOp;\n use rustc::mir::interpret::{\n-    EvalResult, EvalErrorKind, Scalar,\n+    EvalResult, InterpError, Scalar,\n };\n \n use super::{\n@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n+                    _ => Err(::rustc::mir::interpret::InterpError::TypeNotPrimitive(ty))?,\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n@@ -248,7 +248,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n-            return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n+            return Err(InterpError::Panic { msg, file, line, col }.into());\n         } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n             assert!(args.len() == 2);\n             // &'static str, &(&'static str, u32, u32)\n@@ -266,7 +266,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n-            return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n+            return Err(InterpError::Panic { msg, file, line, col }.into());\n         } else {\n             return Ok(false);\n         }"}, {"sha": "b5e3f818699194fb1a72911ec05bdb7195827c17", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -19,7 +19,7 @@ use syntax::ast::Mutability;\n \n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n-    EvalResult, Scalar, EvalErrorKind, AllocKind, PointerArithmetic,\n+    EvalResult, Scalar, InterpError, AllocKind, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n };\n \n@@ -344,8 +344,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             // no need to report anything, the const_eval call takes care of that for statics\n             assert!(tcx.is_static(def_id).is_some());\n             match err {\n-                ErrorHandled::Reported => EvalErrorKind::ReferencedConstant.into(),\n-                ErrorHandled::TooGeneric => EvalErrorKind::TooGeneric.into(),\n+                ErrorHandled::Reported => InterpError::ReferencedConstant.into(),\n+                ErrorHandled::TooGeneric => InterpError::TooGeneric.into(),\n             }\n         }).map(|raw_const| {\n             let allocation = tcx.alloc_map.lock().unwrap_memory(raw_const.alloc_id);\n@@ -458,7 +458,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n             Some(AllocKind::Function(instance)) => Ok(instance),\n-            _ => Err(EvalErrorKind::ExecuteMemory.into()),\n+            _ => Err(InterpError::ExecuteMemory.into()),\n         }\n     }\n "}, {"sha": "166e79c12d806cca06377cb2f20e8bd32b53a061", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerEx\n use rustc::mir::interpret::{\n     GlobalId, AllocId, CheckInAllocMsg,\n     ConstValue, Pointer, Scalar,\n-    EvalResult, EvalErrorKind,\n+    EvalResult, InterpError,\n     sign_extend, truncate,\n };\n use super::{\n@@ -369,7 +369,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n+            .map_err(|err| InterpError::ValidationFailure(err.to_string()))?;\n         Ok(str)\n     }\n \n@@ -653,7 +653,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     .expect(\"tagged layout for non adt\")\n                     .discriminants(self.tcx.tcx)\n                     .find(|(_, var)| var.val == real_discr)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(raw_discr.erase_tag()))?;\n+                    .ok_or_else(|| InterpError::InvalidDiscriminant(raw_discr.erase_tag()))?;\n                 (real_discr, index.0)\n             },\n             layout::DiscriminantKind::Niche {"}, {"sha": "0bafe6d107a20e458f1bb59ea83ea350e4c765e2", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -12,7 +12,7 @@ use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n     Relocations, Allocation, UndefMask,\n-    EvalResult, EvalErrorKind,\n+    EvalResult, InterpError,\n };\n \n use rustc::ty::{self, TyCtxt};\n@@ -78,7 +78,7 @@ impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n         }\n \n         // Second cycle\n-        Err(EvalErrorKind::InfiniteLoop.into())\n+        Err(InterpError::InfiniteLoop.into())\n     }\n }\n \n@@ -431,7 +431,7 @@ impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n impl<'a, 'mir, 'tcx> PartialEq for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn eq(&self, other: &Self) -> bool {\n-        // FIXME: This looks to be a *ridicolously expensive* comparison operation.\n+        // FIXME: This looks to be a *ridiculously expensive* comparison operation.\n         // Doesn't this make tons of copies?  Either `snapshot` is very badly named,\n         // or it does!\n         self.snapshot() == other.snapshot()"}, {"sha": "2080a329bb06fc1c026a8de062195b0a61a8e9e2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n+use rustc::mir::interpret::{EvalResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n     InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n@@ -134,7 +134,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     self.goto_block(Some(target))?;\n                 } else {\n                     // Compute error message\n-                    use rustc::mir::interpret::EvalErrorKind::*;\n+                    use rustc::mir::interpret::InterpError::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.read_immediate(self.eval_operand(len, None)?)\n@@ -212,7 +212,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             return Ok(());\n         }\n         let caller_arg = caller_arg.next()\n-            .ok_or_else(|| EvalErrorKind::FunctionArgCountMismatch)?;\n+            .ok_or_else(|| InterpError::FunctionArgCountMismatch)?;\n         if rust_abi {\n             debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }"}, {"sha": "37c880ccf72bf4af0fe980b4d0cf86f65e3b2251", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocKind, EvalResult, EvalErrorKind, CheckInAllocMsg,\n+    Scalar, AllocKind, EvalResult, InterpError, CheckInAllocMsg,\n };\n \n use super::{\n@@ -258,11 +258,11 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         match self.walk_value(op) {\n             Ok(()) => Ok(()),\n             Err(err) => match err.kind {\n-                EvalErrorKind::InvalidDiscriminant(val) =>\n+                InterpError::InvalidDiscriminant(val) =>\n                     validation_failure!(\n                         val, self.path, \"a valid enum discriminant\"\n                     ),\n-                EvalErrorKind::ReadPointerAsBytes =>\n+                InterpError::ReadPointerAsBytes =>\n                     validation_failure!(\n                         \"a pointer\", self.path, \"plain (non-pointer) bytes\"\n                     ),\n@@ -355,9 +355,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     Err(err) => {\n                         error!(\"{:?} is not aligned to {:?}\", ptr, align);\n                         match err.kind {\n-                            EvalErrorKind::InvalidNullPointerUsage =>\n+                            InterpError::InvalidNullPointerUsage =>\n                                 return validation_failure!(\"NULL reference\", self.path),\n-                            EvalErrorKind::AlignmentCheckFailed { required, has } =>\n+                            InterpError::AlignmentCheckFailed { required, has } =>\n                                 return validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n@@ -562,7 +562,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n                         match err.kind {\n-                            EvalErrorKind::ReadUndefBytes(offset) => {\n+                            InterpError::ReadUndefBytes(offset) => {\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index."}, {"sha": "0d43602d89986c732e3486ca0bc07d0aaa9eab22", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Loc\n use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind, Static, StaticKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n-use rustc::mir::interpret::{EvalErrorKind, Scalar, GlobalId, EvalResult};\n+use rustc::mir::interpret::{InterpError, Scalar, GlobalId, EvalResult};\n use rustc::ty::{TyCtxt, self, Instance};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n@@ -144,7 +144,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Ok(val) => Some(val),\n             Err(error) => {\n                 let diagnostic = error_to_const_error(&self.ecx, error);\n-                use rustc::mir::interpret::EvalErrorKind::*;\n+                use rustc::mir::interpret::InterpError::*;\n                 match diagnostic.error {\n                     // don't report these, they make no sense in a const prop context\n                     | MachineError(_)\n@@ -457,7 +457,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     )\n                 } else {\n                     if overflow {\n-                        let err = EvalErrorKind::Overflow(op).into();\n+                        let err = InterpError::Overflow(op).into();\n                         let _: Option<()> = self.use_ecx(source_info, |_| Err(err));\n                         return None;\n                     }\n@@ -611,7 +611,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         .hir()\n                         .as_local_hir_id(self.source.def_id())\n                         .expect(\"some part of a failing const eval must be local\");\n-                    use rustc::mir::interpret::EvalErrorKind::*;\n+                    use rustc::mir::interpret::InterpError::*;\n                     let msg = match msg {\n                         Overflow(_) |\n                         OverflowNeg |"}, {"sha": "e63c1899fe583ecae177cb72cbcf24f3a54294d4", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -773,7 +773,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n \n     let mut cases = create_cases(mir, &transform, |point| Some(point.resume));\n \n-    use rustc::mir::interpret::EvalErrorKind::{\n+    use rustc::mir::interpret::InterpError::{\n         GeneratorResumedAfterPanic,\n         GeneratorResumedAfterReturn,\n     };"}, {"sha": "e533066e6b9e223ececc343af49a4f10fdfb3ce2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -728,7 +728,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                                    interior mutability, create a static instead\");\n                     }\n                 }\n-            } else {\n+            } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n+                // Don't promote BorrowKind::Shallow borrows, as they don't\n+                // reach codegen.\n+\n                 // We might have a candidate for promotion.\n                 let candidate = Candidate::Ref(location);\n                 // We can only promote interior borrows of promotable temps."}, {"sha": "f92fa2e9799adfdc9da72b04122398a42a64bb9b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1979,6 +1979,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     ref bounds,\n                     impl_trait_fn,\n                     ref generics,\n+                    origin: _,\n                 }) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);"}, {"sha": "4d2c03a4f2fdb1eebe12bc094287b5d7ae2f2e25", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -10,6 +10,6 @@ path = \"lib.rs\"\n \n [dependencies]\n pulldown-cmark = { version = \"0.1.2\", default-features = false }\n-minifier = \"0.0.28\"\n+minifier = \"0.0.29\"\n tempfile = \"3\"\n parking_lot = \"0.7\""}, {"sha": "de434e9d2e36cd904553dc233b5e6bf5eaa8c94c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 47, "deletions": 38, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -965,7 +965,11 @@ themePicker.onblur = handleThemeButtonsBlur;\n                 if for_search_index && line.starts_with(\"var R\") {\n                     variables.push(line.clone());\n                     // We need to check if the crate name has been put into a variable as well.\n-                    let tokens = js::simple_minify(&line).apply(js::clean_tokens);\n+                    let tokens: js::Tokens<'_> = js::simple_minify(&line)\n+                                                    .into_iter()\n+                                                    .filter(js::clean_token)\n+                                                    .collect::<Vec<_>>()\n+                                                    .into();\n                     let mut pos = 0;\n                     while pos < tokens.len() {\n                         if let Some((var_pos, Some(value_pos))) =\n@@ -1288,46 +1292,51 @@ fn write_minify_replacer<W: Write>(\n     contents: &str,\n     enable_minification: bool,\n ) -> io::Result<()> {\n-    use minifier::js::{Keyword, ReservedChar, Token};\n+    use minifier::js::{simple_minify, Keyword, ReservedChar, Token, Tokens};\n \n     if enable_minification {\n         writeln!(dst, \"{}\",\n-                 minifier::js::simple_minify(contents)\n-                              .apply(|f| {\n-                                  // We keep backlines.\n-                                  minifier::js::clean_tokens_except(f, |c| {\n-                                      c.get_char() != Some(ReservedChar::Backline)\n-                                  })\n-                              })\n-                              .apply(|f| {\n-                                  minifier::js::replace_token_with(f, |t| {\n-                                      match *t {\n-                                          Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n-                                          Token::String(s) => {\n-                                              let s = &s[1..s.len() -1]; // The quotes are included\n-                                              if s.is_empty() {\n-                                                  Some(Token::Other(\"E\"))\n-                                              } else if s == \"t\" {\n-                                                  Some(Token::Other(\"T\"))\n-                                              } else if s == \"u\" {\n-                                                  Some(Token::Other(\"U\"))\n-                                              } else {\n-                                                  None\n-                                              }\n-                                          }\n-                                          _ => None,\n-                                      }\n-                                  })\n-                              })\n-                              .apply(|f| {\n-                                  // We add a backline after the newly created variables.\n-                                  minifier::js::aggregate_strings_into_array_with_separation(\n-                                      f,\n-                                      \"R\",\n-                                      Token::Char(ReservedChar::Backline),\n-                                  )\n-                              })\n-                              .to_string())\n+                 {\n+                    let tokens: Tokens<'_> = simple_minify(contents)\n+                        .into_iter()\n+                        .filter(|f| {\n+                            // We keep backlines.\n+                            minifier::js::clean_token_except(f, &|c: &Token<'_>| {\n+                                c.get_char() != Some(ReservedChar::Backline)\n+                            })\n+                        })\n+                        .map(|f| {\n+                            minifier::js::replace_token_with(f, &|t: &Token<'_>| {\n+                                match *t {\n+                                    Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n+                                    Token::String(s) => {\n+                                        let s = &s[1..s.len() -1]; // The quotes are included\n+                                        if s.is_empty() {\n+                                            Some(Token::Other(\"E\"))\n+                                        } else if s == \"t\" {\n+                                            Some(Token::Other(\"T\"))\n+                                        } else if s == \"u\" {\n+                                            Some(Token::Other(\"U\"))\n+                                        } else {\n+                                            None\n+                                        }\n+                                    }\n+                                    _ => None,\n+                                }\n+                            })\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .into();\n+                    tokens.apply(|f| {\n+                        // We add a backline after the newly created variables.\n+                        minifier::js::aggregate_strings_into_array_with_separation(\n+                            f,\n+                            \"R\",\n+                            Token::Char(ReservedChar::Backline),\n+                        )\n+                    })\n+                    .to_string()\n+                })\n     } else {\n         writeln!(dst, \"{}\", contents)\n     }"}, {"sha": "1f433e25ee16ccf4669f84d6ae2b44e93ecc27be", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -69,9 +69,9 @@ extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64\n         }\n \n         // check entry is being called according to ABI\n-        assert_eq!(p3, 0);\n-        assert_eq!(p4, 0);\n-        assert_eq!(p5, 0);\n+        rtassert!(p3 == 0);\n+        rtassert!(p4 == 0);\n+        rtassert!(p5 == 0);\n \n         unsafe {\n             // The actual types of these arguments are `p1: *const Arg, p2:"}, {"sha": "6dd24c524fc3067506817de8c9ada99fc33270b1", "filename": "src/libstd/sys/sgx/abi/reloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -23,7 +23,7 @@ pub fn relocate_elf_rela() {\n     };\n     for rela in relas {\n         if rela.info != (/*0 << 32 |*/ R_X86_64_RELATIVE as u64) {\n-            panic!(\"Invalid relocation\");\n+            rtabort!(\"Invalid relocation\");\n         }\n         unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };\n     }"}, {"sha": "03e08ad547d3655a40db005b94e8aa3e083db547", "filename": "src/libstd/sys/sgx/abi/tls.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -100,20 +100,24 @@ impl Tls {\n     }\n \n     pub fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-        let index = TLS_KEY_IN_USE.set().expect(\"TLS limit exceeded\");\n+        let index = if let Some(index) = TLS_KEY_IN_USE.set() {\n+            index\n+        } else {\n+            rtabort!(\"TLS limit exceeded\")\n+        };\n         TLS_DESTRUCTOR[index].store(dtor.map_or(0, |f| f as usize), Ordering::Relaxed);\n         Key::from_index(index)\n     }\n \n     pub fn set(key: Key, value: *mut u8) {\n         let index = key.to_index();\n-        assert!(TLS_KEY_IN_USE.get(index));\n+        rtassert!(TLS_KEY_IN_USE.get(index));\n         unsafe { Self::current() }.data[index].set(value);\n     }\n \n     pub fn get(key: Key) -> *mut u8 {\n         let index = key.to_index();\n-        assert!(TLS_KEY_IN_USE.get(index));\n+        rtassert!(TLS_KEY_IN_USE.get(index));\n         unsafe { Self::current() }.data[index].get()\n     }\n "}, {"sha": "22ae2a8e07d313a3745c903a0513e94404684219", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -190,11 +190,15 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n         unsafe {\n             // Mustn't call alloc with size 0.\n             let ptr = if size > 0 {\n-                super::alloc(size, T::align_of()).expect(\"User memory allocation failed\") as _\n+                rtunwrap!(Ok, super::alloc(size, T::align_of())) as _\n             } else {\n                 T::align_of() as _ // dangling pointer ok for size 0\n             };\n-            User(NonNull::new_userref(T::from_raw_sized(ptr, size)))\n+            if let Ok(v) = crate::panic::catch_unwind(|| T::from_raw_sized(ptr, size)) {\n+                User(NonNull::new_userref(v))\n+            } else {\n+                rtabort!(\"Got invalid pointer from alloc() usercall\")\n+            }\n         }\n     }\n "}, {"sha": "0abfc26bced0025d4188ef341c8302d773295e9e", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -52,7 +52,7 @@ pub fn close(fd: Fd) {\n \n fn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n     String::from_utf8(buf.copy_user_buffer())\n-        .unwrap_or_else(|_| panic!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n+        .unwrap_or_else(|_| rtabort!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n }\n \n /// Usercall `bind_stream`. See the ABI documentation for more information.\n@@ -176,7 +176,7 @@ fn check_os_error(err: Result) -> i32 {\n     {\n         err\n     } else {\n-        panic!(\"Usercall: returned invalid error value {}\", err)\n+        rtabort!(\"Usercall: returned invalid error value {}\", err)\n     }\n }\n "}, {"sha": "e4694a8827a0d8b20e1307eba1ec4947f149cce4", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -131,22 +131,22 @@ impl<T: RegisterArgument> RegisterArgument for Option<NonNull<T>> {\n \n impl ReturnValue for ! {\n     fn from_registers(call: &'static str, _regs: (Register, Register)) -> Self {\n-        panic!(\"Usercall {}: did not expect to be re-entered\", call);\n+        rtabort!(\"Usercall {}: did not expect to be re-entered\", call);\n     }\n }\n \n impl ReturnValue for () {\n-    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n-        assert_eq!(regs.0, 0, \"Usercall {}: expected {} return value to be 0\", call, \"1st\");\n-        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n+    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n+        rtassert!(usercall_retval.0 == 0);\n+        rtassert!(usercall_retval.1 == 0);\n         ()\n     }\n }\n \n impl<T: RegisterArgument> ReturnValue for T {\n-    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n-        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n-        T::from_register(regs.0)\n+    fn from_registers(call: &'static str, usercall_retval: (Register, Register)) -> Self {\n+        rtassert!(usercall_retval.1 == 0);\n+        T::from_register(usercall_retval.0)\n     }\n }\n \n@@ -174,8 +174,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 RegisterArgument::into_register($n3),\n@@ -191,8 +190,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 RegisterArgument::into_register($n3),\n@@ -208,8 +206,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 RegisterArgument::into_register($n2),\n                 0,0,\n@@ -224,8 +221,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 RegisterArgument::into_register($n1),\n                 0,0,0,\n                 return_type_is_abort!($r)\n@@ -239,8 +235,7 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[inline(always)]\n         pub unsafe fn $f() -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n-                NonZeroU64::new(Usercalls::$f as Register)\n-                    .expect(\"Usercall number must be non-zero\"),\n+                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n                 0,0,0,0,\n                 return_type_is_abort!($r)\n             ))"}, {"sha": "000bb19f2692ae8807551a5f7ba94271f41db1b8", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -32,9 +32,8 @@ impl Condvar {\n         mutex.lock()\n     }\n \n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, _dur: Duration) -> bool {\n-        mutex.unlock(); // don't hold the lock while panicking\n-        panic!(\"timeout not supported in SGX\");\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        rtabort!(\"timeout not supported in SGX\");\n     }\n \n     #[inline]"}, {"sha": "b0679f65f0d68fc028064dbd8dfd14e7113fbb1e", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -139,7 +139,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n                     return ret;\n                 }\n             }\n-            panic!(\"Failed to obtain random data\");\n+            rtabort!(\"Failed to obtain random data\");\n         }\n     }\n     (rdrand64(), rdrand64())"}, {"sha": "09b5ffb199676d07464b7113daeb09d080517a9b", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -105,7 +105,7 @@ impl RWLock {\n                 *wguard.lock_var_mut() = true;\n             } else {\n                 // No writers were waiting, the lock is released\n-                assert!(rguard.queue_empty());\n+                rtassert!(rguard.queue_empty());\n             }\n         }\n     }"}, {"sha": "565a523ebe06f3461907456a162965b169c2ac57", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -62,25 +62,23 @@ impl Thread {\n     }\n \n     pub(super) fn entry() {\n-        let mut guard = task_queue::lock();\n-        let task = guard.pop().expect(\"Thread started but no tasks pending\");\n-        drop(guard); // make sure to not hold the task queue lock longer than necessary\n+        let mut pending_tasks = task_queue::lock();\n+        let task = rtunwrap!(Some, pending_tasks.pop());\n+        drop(pending_tasks); // make sure to not hold the task queue lock longer than necessary\n         task.run()\n     }\n \n     pub fn yield_now() {\n-        assert_eq!(\n-            usercalls::wait(0, usercalls::raw::WAIT_NO).unwrap_err().kind(),\n-            io::ErrorKind::WouldBlock\n-        );\n+        let wait_error = rtunwrap!(Err, usercalls::wait(0, usercalls::raw::WAIT_NO));\n+        rtassert!(wait_error.kind() == io::ErrorKind::WouldBlock);\n     }\n \n     pub fn set_name(_name: &CStr) {\n         // FIXME: could store this pointer in TLS somewhere\n     }\n \n     pub fn sleep(_dur: Duration) {\n-        panic!(\"can't sleep\"); // FIXME\n+        rtabort!(\"can't sleep\"); // FIXME\n     }\n \n     pub fn join(self) {"}, {"sha": "d542f9b41012793bc4b90d62e827c901dde9515a", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -121,7 +121,7 @@ impl<'a, T> Drop for WaitGuard<'a, T> {\n             NotifiedTcs::Single(tcs) => Some(tcs),\n             NotifiedTcs::All { .. } => None\n         };\n-        usercalls::send(EV_UNPARK, target_tcs).unwrap();\n+        rtunwrap!(Ok, usercalls::send(EV_UNPARK, target_tcs));\n     }\n }\n \n@@ -141,6 +141,7 @@ impl WaitQueue {\n     ///\n     /// This function does not return until this thread has been awoken.\n     pub fn wait<T>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>) {\n+        // very unsafe: check requirements of UnsafeList::push\n         unsafe {\n             let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n                 tcs: thread::current(),\n@@ -149,10 +150,9 @@ impl WaitQueue {\n             let entry = guard.queue.inner.push(&mut entry);\n             drop(guard);\n             while !entry.lock().wake {\n-                assert_eq!(\n-                    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap() & EV_UNPARK,\n-                    EV_UNPARK\n-                );\n+                // don't panic, this would invalidate `entry` during unwinding\n+                let eventset = rtunwrap!(Ok, usercalls::wait(EV_UNPARK, WAIT_INDEFINITE));\n+                rtassert!(eventset & EV_UNPARK == EV_UNPARK);\n             }\n         }\n     }\n@@ -269,7 +269,7 @@ mod unsafe_list {\n                         // ,-------> /---------\\ next ---,\n                         // |         |head_tail|         |\n                         // `--- prev \\---------/ <-------`\n-                        assert_eq!(self.head_tail.as_ref().prev, first);\n+                        rtassert!(self.head_tail.as_ref().prev == first);\n                         true\n                     } else {\n                         false\n@@ -285,7 +285,9 @@ mod unsafe_list {\n         /// # Safety\n         ///\n         /// The entry must remain allocated until the entry is removed from the\n-        /// list AND the caller who popped is done using the entry.\n+        /// list AND the caller who popped is done using the entry. Special\n+        /// care must be taken in the caller of `push` to ensure unwinding does\n+        /// not destroy the stack frame containing the entry.\n         pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n             self.init();\n \n@@ -303,6 +305,7 @@ mod unsafe_list {\n             entry.as_mut().prev = prev_tail;\n             entry.as_mut().next = self.head_tail;\n             prev_tail.as_mut().next = entry;\n+            // unwrap ok: always `Some` on non-dummy entries\n             (*entry.as_ptr()).value.as_ref().unwrap()\n         }\n \n@@ -333,6 +336,7 @@ mod unsafe_list {\n                 second.as_mut().prev = self.head_tail;\n                 first.as_mut().next = NonNull::dangling();\n                 first.as_mut().prev = NonNull::dangling();\n+                // unwrap ok: always `Some` on non-dummy entries\n                 Some((*first.as_ptr()).value.as_ref().unwrap())\n             }\n         }"}, {"sha": "4c64e9f3afba7731cf0b7d461fa895f1623d3007", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -28,6 +28,15 @@ macro_rules! rtassert {\n     })\n }\n \n+#[allow(unused_macros)] // not used on all platforms\n+macro_rules! rtunwrap {\n+    ($ok:ident, $e:expr) => (if let $ok(v) = $e {\n+        v\n+    } else {\n+        rtabort!(concat!(\"unwrap failed: \", stringify!($e)));\n+    })\n+}\n+\n pub mod alloc;\n pub mod at_exit_imp;\n #[cfg(feature = \"backtrace\")]"}, {"sha": "37360a563950b89fbf33f9a1fc6ce55e15d40662", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -6722,6 +6722,22 @@ impl<'a> Parser<'a> {\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mut trait_items = vec![];\n             while !self.eat(&token::CloseDelim(token::Brace)) {\n+                if let token::DocComment(_) = self.token {\n+                    if self.look_ahead(1,\n+                    |tok| tok == &token::Token::CloseDelim(token::Brace)) {\n+                        let mut err = self.diagnostic().struct_span_err_with_code(\n+                            self.span,\n+                            \"found a documentation comment that doesn't document anything\",\n+                            DiagnosticId::Error(\"E0584\".into()),\n+                        );\n+                        err.help(\"doc comments must come before what they document, maybe a \\\n+                            comment was intended with `//`?\",\n+                        );\n+                        err.emit();\n+                        self.bump();\n+                        continue;\n+                    }\n+                }\n                 let mut at_end = false;\n                 match self.parse_trait_item(&mut at_end) {\n                     Ok(item) => trait_items.push(item),"}, {"sha": "7ac36a22274f33897dfe8e2a827b7c97f373a010", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -70,8 +70,8 @@ fn main() {\n //  }\n //  bb8: { // binding1 and guard\n //      StorageLive(_6);\n-//      _6 = &(((promoted[1]: std::option::Option<i32>) as Some).0: i32);\n-//      _4 = &shallow (promoted[0]: std::option::Option<i32>);\n+//      _6 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n+//      _4 = &shallow _2;\n //      StorageLive(_7);\n //      _7 = const guard() -> [return: bb9, unwind: bb1];\n //  }"}, {"sha": "72af51629927d79a814db3a596d922a74060807a", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -79,6 +79,11 @@ async fn async_fn(x: u8) -> u8 {\n     x\n }\n \n+async fn generic_async_fn<T>(x: T) -> T {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n async fn async_fn_with_borrow(x: &u8) -> u8 {\n     await!(wake_and_yield_once());\n     *x\n@@ -96,14 +101,21 @@ fn async_fn_with_impl_future_named_lifetime<'a>(x: &'a u8) -> impl Future<Output\n     }\n }\n \n-async fn async_fn_with_named_lifetime_multiple_args<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n+/* FIXME(cramertj) support when `existential type T<'a, 'b>:;` works\n+async fn async_fn_multiple_args(x: &u8, _y: &u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+*/\n+\n+async fn async_fn_multiple_args_named_lifetime<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n     await!(wake_and_yield_once());\n     *x\n }\n \n fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n     async move {\n-        await!(async_fn_with_borrow(&y))\n+        await!(async_fn_with_borrow_named_lifetime(&y))\n     }\n }\n \n@@ -162,6 +174,7 @@ fn main() {\n         async_nonmove_block,\n         async_closure,\n         async_fn,\n+        generic_async_fn,\n         async_fn_with_internal_borrow,\n         Foo::async_method,\n         |x| {\n@@ -170,15 +183,14 @@ fn main() {\n             }\n         },\n     }\n-\n     test_with_borrow! {\n         async_block_with_borrow_named_lifetime,\n         async_fn_with_borrow,\n         async_fn_with_borrow_named_lifetime,\n         async_fn_with_impl_future_named_lifetime,\n         |x| {\n             async move {\n-                await!(async_fn_with_named_lifetime_multiple_args(x, x))\n+                await!(async_fn_multiple_args_named_lifetime(x, x))\n             }\n         },\n     }"}, {"sha": "fccc4fdb9172591a51f2e92d7f5db1d47d71517a", "filename": "src/test/ui/async-fn-multiple-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -5,7 +5,7 @@\n use std::ops::Add;\n \n async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n-//~^ ERROR multiple different lifetimes used in arguments of `async fn`\n+//~^ ERROR ambiguous lifetime bound in `async fn`\n \n async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n     _: impl for<'a> Add<&'a u8>,\n@@ -14,7 +14,6 @@ async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n ) {}\n \n async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-//~^ ERROR multiple elided lifetimes used\n-//~^^ ERROR missing lifetime specifier\n+//~^ ambiguous lifetime bound in `async fn`\n \n fn main() {}"}, {"sha": "8c3ee2bed830b7bb88cc3990f95b480dc337a625", "filename": "src/test/ui/async-fn-multiple-lifetimes.stderr", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1,32 +1,20 @@\n-error[E0709]: multiple different lifetimes used in arguments of `async fn`\n-  --> $DIR/async-fn-multiple-lifetimes.rs:7:47\n+error: ambiguous lifetime bound in `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:7:65\n    |\n LL | async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n-   |                                               ^^         ^^ different lifetime here\n-   |                                               |\n-   |                                               first lifetime here\n+   |                                                                 ^ neither `'a` nor `'b` outlives the other\n    |\n-   = help: `async fn` can only accept borrowed values with identical lifetimes\n+   = note: multiple unrelated lifetimes are not allowed in `async fn`.\n+   = note: if you're using argument-position elided lifetimes, consider switching to a single named lifetime.\n \n-error[E0707]: multiple elided lifetimes used in arguments of `async fn`\n-  --> $DIR/async-fn-multiple-lifetimes.rs:16:39\n+error: ambiguous lifetime bound in `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:16:52\n    |\n LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-   |                                       ^       ^ different lifetime here\n-   |                                       |\n-   |                                       first lifetime here\n+   |                                                    ^ the elided lifetimes here do not outlive one another\n    |\n-   = help: consider giving these arguments named lifetimes\n+   = note: multiple unrelated lifetimes are not allowed in `async fn`.\n+   = note: if you're using argument-position elided lifetimes, consider switching to a single named lifetime.\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/async-fn-multiple-lifetimes.rs:16:39\n-   |\n-LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n-   |                                       ^ expected lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `_` or `_`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0106, E0707, E0709.\n-For more information about an error, try `rustc --explain E0106`."}, {"sha": "1c3b5ac76138f2eb56f25c2effda0fb28a494d14", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Debug;\n \n fn elided(x: &i32) -> impl Copy { x }\n-//~^ ERROR explicit lifetime required in the type of `x` [E0621]\n+//~^ ERROR cannot infer an appropriate lifetime\n \n fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n //~^ ERROR cannot infer an appropriate lifetime"}, {"sha": "9339a83b09a9df8388a63cfc8e7a33bf3bb5227f", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1,10 +1,20 @@\n-error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^ lifetime `'static` required\n-   |              |\n-   |              help: add explicit lifetime `'static` to the type of `x`: `&'static i32`\n+   |                       ---------   ^ ...but this borrow...\n+   |                       |\n+   |                       this return type evaluates to the `'static` lifetime...\n+   |\n+note: ...can't outlive the anonymous lifetime #1 defined on the function body at 3:1\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:1\n+   |\n+LL | fn elided(x: &i32) -> impl Copy { x }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: you can add a constraint to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the function body at 3:1\n+   |\n+LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n+   |                       ^^^^^^^^^^^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n@@ -67,5 +77,5 @@ LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n \n error: aborting due to 5 previous errors\n \n-Some errors occurred: E0310, E0621, E0623.\n+Some errors occurred: E0310, E0623.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "b2624ec92a184c75df4663601e95a0db0982611f", "filename": "src/test/ui/issues/issue-54974.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54974.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -0,0 +1,16 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+use std::sync::Arc;\n+\n+trait SomeTrait: Send + Sync + 'static {\n+    fn do_something(&self);\n+}\n+\n+async fn my_task(obj: Arc<SomeTrait>) {\n+    unimplemented!()\n+}\n+\n+fn main() {}"}, {"sha": "6160fbabd96d747556d3d9aaac3437305f843fc4", "filename": "src/test/ui/issues/issue-55324.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55324.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -0,0 +1,14 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+use std::future::Future;\n+\n+#[allow(unused)]\n+async fn foo<F: Future<Output = i32>>(x: &i32, future: F) -> i32 {\n+    let y = await!(future);\n+    *x + y\n+}\n+\n+fn main() {}"}, {"sha": "559899194fbe74b00e23566107b991ad4a8eec7f", "filename": "src/test/ui/issues/issue-58885.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58885.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+struct Xyz {\n+    a: u64,\n+}\n+\n+trait Foo {}\n+\n+impl Xyz {\n+    async fn do_sth<'a>(\n+        &'a self, foo: &'a dyn Foo\n+    ) -> bool\n+    {\n+        true\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a310653fbce4886492bff22dded2b4618c83a6e8", "filename": "src/test/ui/issues/issue-59001.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59001.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -0,0 +1,17 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await, await_macro, futures_api)]\n+\n+use std::future::Future;\n+\n+#[allow(unused)]\n+async fn enter<'a, F, R>(mut callback: F)\n+where\n+    F: FnMut(&'a mut i32) -> R,\n+    R: Future<Output = ()> + 'a,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() {}"}, {"sha": "bcdf643c0b9d1136001d98643105630f55fe0231", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -8,8 +8,8 @@ trait Foo<'a> {\n impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n+//~^ ERROR explicit lifetime required in the type of `x` [E0621]\n     x\n-        //~^ ERROR explicit lifetime required in the type of `x` [E0621]\n }\n \n fn main() {}"}, {"sha": "3a1e3ce3ad1a0d3a539b60618d939688e2a6b65e", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -1,8 +1,8 @@\n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/impl-trait-captures.rs:11:5\n+  --> $DIR/impl-trait-captures.rs:10:25\n    |\n-LL |     x\n-   |     ^ lifetime `ReEarlyBound(0, 'a)` required\n+LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n+   |                         ^^^^^^^^^^^^ lifetime `ReEarlyBound(0, 'a)` required\n help: add explicit lifetime `ReEarlyBound(0, 'a)` to the type of `x`\n    |\n LL | fn foo<'a, T>(x: &ReEarlyBound(0, 'a) T) -> impl Foo<'a> {"}, {"sha": "87b501bd2a2df616e945ae64e4dc137caee3750d", "filename": "src/test/ui/parser/doc-inside-trait-item.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -0,0 +1,6 @@\n+trait User{\n+    fn test();\n+    /// empty doc\n+    //~^ ERROR found a documentation comment that doesn't document anything\n+}\n+fn main() {}"}, {"sha": "261e27b6e0d18fc808f52fe1874efca7e89ea8f9", "filename": "src/test/ui/parser/doc-inside-trait-item.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -0,0 +1,11 @@\n+error[E0584]: found a documentation comment that doesn't document anything\n+  --> $DIR/doc-inside-trait-item.rs:3:5\n+   |\n+LL |     /// empty doc\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0584`."}, {"sha": "3126b44f0d61846a835aefcad4367106c4cf4759", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3449fa90f8534a197a20db6d757d9095d5124ba8/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=3449fa90f8534a197a20db6d757d9095d5124ba8", "patch": "@@ -30,7 +30,7 @@ const TEST_REPOS: &'static [Test] = &[\n     },\n     Test {\n         name: \"tokei\",\n-        repo: \"https://github.com/Aaronepower/tokei\",\n+        repo: \"https://github.com/XAMPPRocky/tokei\",\n         sha: \"5e11c4852fe4aa086b0e4fe5885822fbe57ba928\",\n         lock: None,\n         packages: &[],"}]}