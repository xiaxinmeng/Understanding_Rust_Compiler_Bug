{"sha": "ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMGNiMTQ0ZmJmZDM2MWI0OGE3NzEwZDNlYjhhNTc2ZmZkYTdlZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-06T04:15:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-06T04:15:02Z"}, "message": "Auto merge of #50453 - alexcrichton:proc-macro-not-send, r=eddyb\n\nproc_macro: Explicitly make everything !Send/Sync\n\nThis commit adds explicit imp blocks to ensure that all publicly exported types\n(except simple enums) are not `Send` nor `Sync` in the `proc_macro` crate.\n\ncc #38356", "tree": {"sha": "71a7d2628c5e84a17e3d6e0a0c68ff3bb8eee297", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71a7d2628c5e84a17e3d6e0a0c68ff3bb8eee297"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8", "html_url": "https://github.com/rust-lang/rust/commit/ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c315475eaf22c1e1d1c3e8efc0f9d1c720eb886", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c315475eaf22c1e1d1c3e8efc0f9d1c720eb886", "html_url": "https://github.com/rust-lang/rust/commit/2c315475eaf22c1e1d1c3e8efc0f9d1c720eb886"}, {"sha": "3e0ed2fc05780f2d2a0709fb2716631c9eaa47df", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0ed2fc05780f2d2a0709fb2716631c9eaa47df", "html_url": "https://github.com/rust-lang/rust/commit/3e0ed2fc05780f2d2a0709fb2716631c9eaa47df"}], "stats": {"total": 47, "additions": 46, "deletions": 1}, "files": [{"sha": "8451e5987e908d1a77067729428622723691395d", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=ce0cb144fbfd361b48a7710d3eb8a576ffda7ef8", "patch": "@@ -74,13 +74,23 @@ use syntax_pos::hygiene::Mark;\n #[derive(Clone)]\n pub struct TokenStream(tokenstream::TokenStream);\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for TokenStream {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for TokenStream {}\n+\n /// Error returned from `TokenStream::from_str`.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct LexError {\n     _inner: (),\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for LexError {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for LexError {}\n+\n impl TokenStream {\n     /// Returns an empty `TokenStream`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -231,6 +241,11 @@ pub fn quote_span(span: Span) -> TokenStream {\n #[derive(Copy, Clone)]\n pub struct Span(syntax_pos::Span);\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Span {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Span {}\n+\n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n         /// Create a new `Diagnostic` with the given `message` at the span\n@@ -363,6 +378,11 @@ pub struct LineColumn {\n     pub column: usize\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for LineColumn {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for LineColumn {}\n+\n /// The source file of a given `Span`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone)]\n@@ -393,7 +413,7 @@ impl SourceFile {\n \n     /// Returns `true` if this source file is a real source file, and not generated by an external\n     /// macro's expansion.\n-    # [unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn is_real(&self) -> bool {\n         // This is a hack until intercrate spans are implemented and we can have real source files\n         // for spans generated in external macros.\n@@ -450,6 +470,11 @@ pub enum TokenTree {\n     Literal(Literal),\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for TokenTree {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for TokenTree {}\n+\n impl TokenTree {\n     /// Returns the span of this token, accessing the `span` method of each of\n     /// the internal tokens.\n@@ -546,6 +571,11 @@ pub struct Group {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Group {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Group {}\n+\n /// Describes how a sequence of token trees is delimited.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -628,6 +658,11 @@ pub struct Op {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Op {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Op {}\n+\n /// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -694,6 +729,11 @@ pub struct Term {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Term {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Term {}\n+\n impl Term {\n     /// Creates a new `Term` with the given `string` as well as the specified\n     /// `span`.\n@@ -752,6 +792,11 @@ pub struct Literal {\n     span: Span,\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Send for Literal {}\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl !Sync for Literal {}\n+\n macro_rules! suffixed_int_literals {\n     ($($name:ident => $kind:ident,)*) => ($(\n         /// Creates a new suffixed integer literal with the specified value."}]}