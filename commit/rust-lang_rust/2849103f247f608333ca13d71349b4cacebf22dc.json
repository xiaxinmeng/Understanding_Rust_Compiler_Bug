{"sha": "2849103f247f608333ca13d71349b4cacebf22dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NDkxMDNmMjQ3ZjYwODMzM2NhMTNkNzEzNDliNGNhY2ViZjIyZGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-10T21:03:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-10T21:04:34Z"}, "message": "rustc: Get rid of native Rust glue for all upcalls except the exit task glue", "tree": {"sha": "151afcfd029fcb96d08118589b34d53415279b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/151afcfd029fcb96d08118589b34d53415279b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2849103f247f608333ca13d71349b4cacebf22dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2849103f247f608333ca13d71349b4cacebf22dc", "html_url": "https://github.com/rust-lang/rust/commit/2849103f247f608333ca13d71349b4cacebf22dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2849103f247f608333ca13d71349b4cacebf22dc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55f0f79a46c230767c35a2b0d35718f71ae6fd11", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f0f79a46c230767c35a2b0d35718f71ae6fd11", "html_url": "https://github.com/rust-lang/rust/commit/55f0f79a46c230767c35a2b0d35718f71ae6fd11"}], "stats": {"total": 247, "additions": 114, "deletions": 133}, "files": [{"sha": "9e166737189abd88b9375b1f97c978e759cc2988", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2849103f247f608333ca13d71349b4cacebf22dc/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2849103f247f608333ca13d71349b4cacebf22dc/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=2849103f247f608333ca13d71349b4cacebf22dc", "patch": "@@ -84,18 +84,18 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n         log_str=dv(\"log_str\", vec(T_i32(), T_ptr(T_str()))),\n         trace_word=dv(\"trace_word\", vec(T_int())),\n         trace_str=dv(\"trace_str\", vec(T_ptr(T_i8()))),\n-        new_port=d(\"new_port\", vec(T_size_t()), T_opaque_port_ptr(tn)),\n-        del_port=dv(\"del_port\", vec(T_opaque_port_ptr(tn))),\n-        new_chan=dv(\"new_chan\", vec(T_opaque_port_ptr(tn))),\n-        flush_chan=dv(\"flush_chan\", vec(T_opaque_chan_ptr(tn))),\n-        del_chan=dv(\"del_chan\", vec(T_opaque_chan_ptr(tn))),\n-        clone_chan=d(\"clone_chan\", vec(T_taskptr(tn), T_opaque_chan_ptr(tn)),\n-                     T_opaque_chan_ptr(tn)),\n+        new_port=d(\"new_port\", vec(T_size_t()), T_opaque_port_ptr()),\n+        del_port=dv(\"del_port\", vec(T_opaque_port_ptr())),\n+        new_chan=d(\"new_chan\", vec(T_opaque_port_ptr()), T_opaque_chan_ptr()),\n+        flush_chan=dv(\"flush_chan\", vec(T_opaque_chan_ptr())),\n+        del_chan=dv(\"del_chan\", vec(T_opaque_chan_ptr())),\n+        clone_chan=d(\"clone_chan\", vec(T_taskptr(tn), T_opaque_chan_ptr()),\n+                     T_opaque_chan_ptr()),\n         _yield=dv(\"yield\", empty_vec),\n         sleep=dv(\"sleep\", vec(T_size_t())),\n         _join=dv(\"join\", vec(T_taskptr(tn))),\n-        send=dv(\"send\", vec(T_opaque_chan_ptr(tn), T_ptr(T_i8()))),\n-        recv=dv(\"recv\", vec(T_ptr(T_int()), T_opaque_port_ptr(tn))),\n+        send=dv(\"send\", vec(T_opaque_chan_ptr(), T_ptr(T_i8()))),\n+        recv=dv(\"recv\", vec(T_ptr(T_ptr(T_i8())), T_opaque_port_ptr())),\n         _fail=dv(\"fail\", vec(T_ptr(T_i8()), T_ptr(T_i8()), T_size_t())),\n         kill=dv(\"kill\", vec(T_taskptr(tn))),\n         exit=dv(\"exit\", empty_vec),"}, {"sha": "cd2dfede4ec2b9fc7b0760b309a49a8e2ed8fe1e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 105, "deletions": 124, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/2849103f247f608333ca13d71349b4cacebf22dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2849103f247f608333ca13d71349b4cacebf22dc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2849103f247f608333ca13d71349b4cacebf22dc", "patch": "@@ -17,6 +17,7 @@ import middle.ty;\n import back.Link;\n import back.x86;\n import back.abi;\n+import back.upcall;\n \n import middle.ty.pat_ty;\n \n@@ -112,7 +113,8 @@ state type crate_ctxt = rec(session.session sess,\n                             std.SHA1.sha1 sha,\n                             hashmap[ty.t, str] type_sha1s,\n                             hashmap[ty.t, metadata.ty_abbrev] type_abbrevs,\n-                            ty.ctxt tcx);\n+                            ty.ctxt tcx,\n+                            @upcall.upcalls upcalls);\n \n type local_ctxt = rec(vec[str] path,\n                       vec[str] module_path,\n@@ -589,25 +591,9 @@ fn T_opaque_obj_ptr(type_names tn) -> TypeRef {\n     ret T_obj_ptr(tn, 0u);\n }\n \n-fn T_opaque_port_ptr(type_names tn) -> TypeRef {\n-    auto s = \"*port\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n+fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n-    auto t = T_ptr(T_i8());\n-\n-    tn.associate(s, t);\n-    ret t;\n-}\n-\n-fn T_opaque_chan_ptr(type_names tn) -> TypeRef {\n-    auto s = \"*chan\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-\n-    auto t = T_ptr(T_i8());\n-\n-    tn.associate(s, t);\n-    ret t;\n-}\n+fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n \n // This function now fails if called on a type with dynamic size (as its\n@@ -1092,17 +1078,6 @@ fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n     ret get_extern_fn(externs, llmod, name, lib.llvm.LLVMCCallConv, t);\n }\n \n-fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args, bool pure)\n-        -> result {\n-    auto cxx = cx.fcx.lcx.ccx;\n-    auto lltaskptr = cx.build.PtrToInt(cx.fcx.lltaskptr, T_int());\n-    auto args2 = vec(lltaskptr) + args;\n-    auto t = trans_native_call(cx.build, cxx.glues, lltaskptr,\n-                               cxx.externs, cxx.tn, cxx.llmod, name,\n-                               true, args2);\n-    ret res(cx, t);\n-}\n-\n fn trans_native_call(builder b, @glue_fns glues, ValueRef lltaskptr,\n                      &hashmap[str, ValueRef] externs,\n                      type_names tn, ModuleRef llmod, str name,\n@@ -1131,7 +1106,10 @@ fn trans_native_call(builder b, @glue_fns glues, ValueRef lltaskptr,\n }\n \n fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n-    ret trans_upcall(cx, \"upcall_free\", vec(vp2i(cx, v), C_int(0)), false);\n+    cx.build.Call(cx.fcx.lcx.ccx.upcalls.free,\n+                  vec(cx.fcx.lltaskptr,\n+                      cx.build.PointerCast(v, T_ptr(T_i8())), C_int(0)));\n+    ret res(cx, C_int(0));\n }\n \n fn find_scope_cx(@block_ctxt cx) -> @block_ctxt {\n@@ -1552,10 +1530,10 @@ fn GEP_tag(@block_ctxt cx,\n fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n         -> result {\n     // FIXME: need a table to collect tydesc globals.\n-    auto tydesc = C_int(0);\n-    auto rslt = trans_upcall(cx, \"upcall_malloc\", vec(llsize, tydesc), false);\n-    rslt = res(rslt.bcx, vi2p(rslt.bcx, rslt.val, llptr_ty));\n-    ret rslt;\n+    auto tydesc = C_null(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)));\n+    auto rval = cx.build.Call(cx.fcx.lcx.ccx.upcalls.malloc,\n+                              vec(cx.fcx.lltaskptr, llsize, tydesc));\n+    ret res(cx, cx.build.PointerCast(rval, llptr_ty));\n }\n \n fn trans_malloc_boxed(@block_ctxt cx, ty.t t) -> result {\n@@ -1687,12 +1665,16 @@ fn mk_derived_tydesc(@block_ctxt cx, ty.t t, bool escapes) -> result {\n             i += 1;\n         }\n \n-        v = trans_upcall(bcx, \"upcall_get_type_desc\",\n-                         vec(p2i(bcx.fcx.lcx.ccx.crate_ptr),\n-                             sz.val,\n-                             align.val,\n-                             C_int((1u + n_params) as int),\n-                             vp2i(bcx, tydescs)), true);\n+        auto lltydescsptr = bcx.build.PointerCast(tydescs,\n+            T_ptr(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn))));\n+        auto td_val = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.get_type_desc,\n+            vec(bcx.fcx.lltaskptr,\n+                bcx.fcx.lcx.ccx.crate_ptr,\n+                sz.val,\n+                align.val,\n+                C_int((1u + n_params) as int),\n+                lltydescsptr));\n+        v = res(bcx, td_val);\n     } else {\n         auto llparamtydescs_opt;\n         if (n_params == 0u) {\n@@ -1716,7 +1698,7 @@ fn mk_derived_tydesc(@block_ctxt cx, ty.t t, bool escapes) -> result {\n                                              llparamtydescs_opt);\n     }\n \n-    ret res(v.bcx, vi2p(v.bcx, v.val, T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn))));\n+    ret v;\n }\n \n fn get_tydesc(&@block_ctxt cx, ty.t t, bool escapes) -> result {\n@@ -1999,8 +1981,10 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n \n         case (ty.ty_port(_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n-                ret trans_upcall(cx, \"upcall_del_port\",\n-                                 vec(vp2i(cx, v)), true);\n+                cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_port,\n+                    vec(cx.fcx.lltaskptr,\n+                        cx.build.PointerCast(v, T_opaque_port_ptr())));\n+                ret res(cx, C_int(0));\n             }\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero(cx, v,\n@@ -2011,8 +1995,10 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n \n         case (ty.ty_chan(_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n-                ret trans_upcall(cx, \"upcall_del_chan\",\n-                                 vec(vp2i(cx, v)), true);\n+                cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_chan,\n+                    vec(cx.fcx.lltaskptr,\n+                        cx.build.PointerCast(v, T_opaque_chan_ptr())));\n+                ret res(cx, C_int(0));\n             }\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero(cx, v,\n@@ -4409,6 +4395,22 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n     fail;\n }\n \n+fn int_cast(@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n+            ValueRef llsrc, bool signed) -> ValueRef {\n+    if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n+            llvm.LLVMGetIntTypeWidth(llsrctype)) {\n+        if (signed) {\n+            // Widening signed cast.\n+            ret bcx.build.SExtOrBitCast(llsrc, lldsttype);\n+        }\n+\n+        // Widening unsigned cast.\n+        ret bcx.build.ZExtOrBitCast(llsrc, lldsttype);\n+    }\n+\n+    ret bcx.build.TruncOrBitCast(llsrc, lldsttype);\n+}\n+\n fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n@@ -4421,24 +4423,9 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n             e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n         } else if (ty.type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n-        } else if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n-            llvm.LLVMGetIntTypeWidth(llsrctype)) {\n-            if (ty.type_is_signed(cx.fcx.lcx.ccx.tcx, t)) {\n-                // Widening signed cast.\n-                e_res.val =\n-                    e_res.bcx.build.SExtOrBitCast(e_res.val,\n-                                                  lldsttype);\n-            } else {\n-                // Widening unsigned cast.\n-                e_res.val =\n-                    e_res.bcx.build.ZExtOrBitCast(e_res.val,\n-                                                  lldsttype);\n-            }\n         } else {\n-            // Narrowing cast.\n-            e_res.val =\n-                e_res.bcx.build.TruncOrBitCast(e_res.val,\n-                                               lldsttype);\n+            e_res.val = int_cast(e_res.bcx, lldsttype, llsrctype, e_res.val,\n+                ty.type_is_signed(cx.fcx.lcx.ccx.tcx, t));\n         }\n     } else {\n         cx.fcx.lcx.ccx.sess.unimpl(\"fp cast\");\n@@ -5081,12 +5068,12 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                                  unit_sz.val);\n \n     // FIXME: pass tydesc properly.\n-    auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)),\n-                            false);\n-    bcx = sub.bcx;\n-\n+    auto vec_val = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_vec,\n+        vec(bcx.fcx.lltaskptr, data_sz,\n+            C_null(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)))));\n     auto llty = type_of(bcx.fcx.lcx.ccx, t);\n-    auto vec_val = vi2p(bcx, sub.val, llty);\n+    vec_val = bcx.build.PointerCast(vec_val, llty);\n+\n     find_scope_cx(bcx).cleanups +=\n         vec(clean(bind drop_ty(_, vec_val, t)));\n \n@@ -5446,34 +5433,30 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n             }\n         }\n         if (is32bit) {\n-            auto uval = trans_upcall(log_bcx,\n-                                     \"upcall_log_float\",\n-                                     vec(C_int(lvl), sub.val),\n-                                     false);\n-            log_bcx = uval.bcx;\n+            log_bcx.build.Call(log_bcx.fcx.lcx.ccx.upcalls.log_float,\n+                               vec(log_bcx.fcx.lltaskptr, C_int(lvl),\n+                                   sub.val));\n         } else {\n+            // FIXME: Eliminate this level of indirection.\n             auto tmp = alloca(log_bcx, tr);\n             sub.bcx.build.Store(sub.val, tmp);\n-            auto uval = trans_upcall(log_bcx,\n-                                     \"upcall_log_double\",\n-                                     vec(C_int(lvl), vp2i(log_bcx, tmp)),\n-                                     false);\n-            log_bcx = uval.bcx;\n+            log_bcx.build.Call(log_bcx.fcx.lcx.ccx.upcalls.log_double,\n+                               vec(log_bcx.fcx.lltaskptr, C_int(lvl), tmp));\n         }\n     } else {\n         alt (ty.struct(cx.fcx.lcx.ccx.tcx, e_ty)) {\n             case (ty.ty_str) {\n-                auto v = vp2i(log_bcx, sub.val);\n-                log_bcx = trans_upcall(log_bcx,\n-                                       \"upcall_log_str\",\n-                                       vec(C_int(lvl), v),\n-                                       false).bcx;\n+                log_bcx.build.Call(log_bcx.fcx.lcx.ccx.upcalls.log_str,\n+                                   vec(log_bcx.fcx.lltaskptr, C_int(lvl),\n+                                       sub.val));\n             }\n             case (_) {\n-                auto v = vec(C_int(lvl), sub.val);\n-                log_bcx = trans_upcall(log_bcx,\n-                                       \"upcall_log_int\",\n-                                       v, false).bcx;\n+                // FIXME: Handle signedness properly.\n+                auto llintval = int_cast(log_bcx, T_int(), val_ty(sub.val),\n+                                         sub.val, false);\n+                log_bcx.build.Call(log_bcx.fcx.lcx.ccx.upcalls.log_int,\n+                                   vec(log_bcx.fcx.lltaskptr, C_int(lvl),\n+                                       llintval));\n             }\n         }\n     }\n@@ -5500,26 +5483,29 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n fn trans_fail(@block_ctxt cx, Option.t[common.span] sp_opt, str fail_str)\n         -> result {\n-    auto V_fail_str = p2i(C_cstr(cx.fcx.lcx.ccx, fail_str));\n+    auto V_fail_str = C_cstr(cx.fcx.lcx.ccx, fail_str);\n \n     auto V_filename; auto V_line;\n     alt (sp_opt) {\n         case (some[common.span](?sp)) {\n             auto loc = cx.fcx.lcx.ccx.sess.lookup_pos(sp.lo);\n-            V_filename = p2i(C_cstr(cx.fcx.lcx.ccx, loc.filename));\n+            V_filename = C_cstr(cx.fcx.lcx.ccx, loc.filename);\n             V_line = loc.line as int;\n         }\n         case (none[common.span]) {\n-            V_filename = p2i(C_str(cx.fcx.lcx.ccx, \"<runtime>\"));\n+            V_filename = C_cstr(cx.fcx.lcx.ccx, \"<runtime>\");\n             V_line = 0;\n         }\n     }\n \n-    auto args = vec(V_fail_str, V_filename, C_int(V_line));\n+    V_fail_str = cx.build.PointerCast(V_fail_str, T_ptr(T_i8()));\n+    V_filename = cx.build.PointerCast(V_filename, T_ptr(T_i8()));\n+\n+    auto args = vec(cx.fcx.lltaskptr, V_fail_str, V_filename, C_int(V_line));\n \n-    auto sub = trans_upcall(cx, \"upcall_fail\", args, false);\n-    sub.bcx.build.Unreachable();\n-    ret res(sub.bcx, C_nil());\n+    cx.build.Call(cx.fcx.lcx.ccx.upcalls._fail, args);\n+    cx.build.Unreachable();\n+    ret res(cx, C_nil());\n }\n \n fn trans_put(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n@@ -5665,10 +5651,10 @@ fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    auto sub = trans_upcall(bcx, \"upcall_new_port\", vec(unit_sz.val), false);\n-    bcx = sub.bcx;\n+    auto port_raw_val = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_port,\n+                                       vec(bcx.fcx.lltaskptr, unit_sz.val));\n     auto llty = type_of(cx.fcx.lcx.ccx, t);\n-    auto port_val = vi2p(bcx, sub.val, llty);\n+    auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n     auto dropref = clean(bind drop_ty(_, port_val, t));\n     find_scope_cx(bcx).cleanups += vec(dropref);\n \n@@ -5681,13 +5667,13 @@ fn trans_chan(@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n     auto prt = trans_expr(bcx, e);\n     bcx = prt.bcx;\n \n-    auto prt_val = vp2i(bcx, prt.val);\n-    auto sub = trans_upcall(bcx, \"upcall_new_chan\", vec(prt_val), false);\n-    bcx = sub.bcx;\n+    auto prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n+    auto chan_raw_val = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n+                                       vec(bcx.fcx.lltaskptr, prt_val));\n \n     auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto chan_llty = type_of(bcx.fcx.lcx.ccx, chan_ty);\n-    auto chan_val = vi2p(bcx, sub.val, chan_llty);\n+    auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n     auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n     find_scope_cx(bcx).cleanups += vec(dropref);\n \n@@ -5723,10 +5709,10 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     find_scope_cx(bcx).cleanups +=\n         vec(clean(bind drop_ty(_, data_alloc.val, unit_ty)));\n \n-    auto sub = trans_upcall(bcx, \"upcall_send\",\n-                            vec(vp2i(bcx, chn.val),\n-                                vp2i(bcx, data_alloc.val)), false);\n-    bcx = sub.bcx;\n+    auto llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n+    auto lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n+    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n+                   vec(bcx.fcx.lltaskptr, llchanval, lldataptr));\n \n     ret res(bcx, chn.val);\n }\n@@ -5751,10 +5737,10 @@ fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n     auto prt = trans_expr(bcx, rhs);\n     bcx = prt.bcx;\n \n-    auto sub = trans_upcall(bcx, \"upcall_recv\",\n-                            vec(vp2i(bcx, lhs),\n-                                vp2i(bcx, prt.val)), false);\n-    bcx = sub.bcx;\n+    auto lldataptr = bcx.build.PointerCast(lhs, T_ptr(T_ptr(T_i8())));\n+    auto llportptr = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n+    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.recv,\n+                   vec(bcx.fcx.lltaskptr, lldataptr, llportptr));\n \n     auto data_load = load_if_immediate(bcx, lhs, unit_ty);\n     auto cp = copy_ty(bcx, action, lhs, data_load, unit_ty);\n@@ -7349,12 +7335,13 @@ fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n \n fn trace_str(@block_ctxt cx, str s) {\n-    trans_upcall(cx, \"upcall_trace_str\", vec(p2i(C_cstr(cx.fcx.lcx.ccx, s))),\n-                 false);\n+    cx.build.Call(cx.fcx.lcx.ccx.upcalls.trace_str,\n+                  vec(cx.fcx.lltaskptr, C_cstr(cx.fcx.lcx.ccx, s)));\n }\n \n fn trace_word(@block_ctxt cx, ValueRef v) {\n-    trans_upcall(cx, \"upcall_trace_word\", vec(v), false);\n+    cx.build.Call(cx.fcx.lcx.ccx.upcalls.trace_word,\n+                  vec(cx.fcx.lltaskptr, v));\n }\n \n fn trace_ptr(@block_ctxt cx, ValueRef v) {\n@@ -7485,17 +7472,10 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n     // To do this we have to figure out how many bytes to add.\n \n     auto llcopy_dst_ptr = alloca(bcx, T_int());\n-    auto llnew_vec_res =\n-        trans_upcall(bcx, \"upcall_vec_grow\",\n-                     vec(vp2i(bcx, lldst_vec),\n-                         vec_fill_adjusted(bcx, llsrc_vec, llskipnull),\n-                         vp2i(bcx, llcopy_dst_ptr),\n-                         vp2i(bcx, llvec_tydesc)),\n-                     false);\n-\n-    bcx = llnew_vec_res.bcx;\n-    auto llnew_vec = vi2p(bcx, llnew_vec_res.val,\n-                          T_opaque_vec_ptr());\n+    auto llnew_vec = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.vec_grow,\n+        vec(bcx.fcx.lltaskptr, lldst_vec,\n+            vec_fill_adjusted(bcx, llsrc_vec, llskipnull),\n+            llcopy_dst_ptr, llvec_tydesc));\n     llvm.LLVMSetValueName(llnew_vec, Str.buf(\"llnew_vec\"));\n \n     auto copy_dst_cx = new_sub_block_ctxt(bcx, \"copy new <- dst\");\n@@ -7742,7 +7722,8 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n                     sha = std.SHA1.mk_sha1(),\n                     type_sha1s = sha1s,\n                     type_abbrevs = abbrevs,\n-                    tcx = tcx);\n+                    tcx = tcx,\n+                    upcalls = upcall.declare_upcalls(tn, llmod));\n     auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);"}]}