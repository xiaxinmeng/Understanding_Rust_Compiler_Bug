{"sha": "c196cc9f125b1a121cc2a636b21143a2bb0b7cdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOTZjYzlmMTI1YjFhMTIxY2MyYTYzNmIyMTE0M2EyYmIwYjdjZGY=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-24T17:33:51Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-24T17:33:51Z"}, "message": "option/result overviews: address feedback\n\n(Most of these are from a review by joshtriplett. Thanks!)\n\nFix errors in `as_pin_ref` and `as_pin_mut` in the \"Adapters for\nworking with references\" overview.\n\nReword some headings about transformation methods.\n\nReclassify `map`, `map_or`, `map_or_else`, `map_err`, etc. to more\naccurately reflect which variants they transform.\n\nDocument `Debug` requirement for `get_or_insert_default`.\n\nReword text about `take` and `replace` to be more accurate.\n\nAdd examples for the `Product` and `Sum` traits.\n\nAlso:\n\nMove link reference definitions closer to their uses. Warn about making\nlink reference definintions for `err` and `ok`. Avoid making other link\nreference definitions that might conflict in the future (foreign methods\nthat share a name with local ones, etc.)\n\nWrite out the generics of `Option` and `Result` when the following\ntext refers to the type parameters.", "tree": {"sha": "9f61a4183a6b2bbf1b0422fb6165c15a34e4ef25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f61a4183a6b2bbf1b0422fb6165c15a34e4ef25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf", "html_url": "https://github.com/rust-lang/rust/commit/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "771f35ce84477595e43bce2f262778c841d36963", "url": "https://api.github.com/repos/rust-lang/rust/commits/771f35ce84477595e43bce2f262778c841d36963", "html_url": "https://github.com/rust-lang/rust/commit/771f35ce84477595e43bce2f262778c841d36963"}], "stats": {"total": 284, "additions": 160, "deletions": 124}, "files": [{"sha": "bd9ac7bb3d9f015c413a6d649f61c30bffb7ff6c", "filename": "library/core/src/option.rs", "status": "modified", "additions": 88, "deletions": 70, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=c196cc9f125b1a121cc2a636b21143a2bb0b7cdf", "patch": "@@ -49,6 +49,8 @@\n //! no \"null\" references. Instead, Rust has *optional* pointers, like\n //! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//!\n //! The following example uses [`Option`] to create an optional box of\n //! [`i32`]. Notice that in order to use the inner [`i32`] value, the\n //! `check_optional` function first needs to use pattern matching to\n@@ -83,6 +85,10 @@\n //! * [`ptr::NonNull<U>`]\n //! * `#[repr(transparent)]` struct around one of the types in this list.\n //!\n+//! [`Box<U>`]: ../../std/boxed/struct.Box.html\n+//! [`num::NonZero*`]: crate::num\n+//! [`ptr::NonNull<U>`]: crate::ptr::NonNull\n+//!\n //! This is called the \"null pointer optimization\" or NPO.\n //!\n //! It is further guaranteed that, for the cases above, one can\n@@ -100,32 +106,32 @@\n //! The [`is_some`] and [`is_none`] methods return [`true`] if the [`Option`]\n //! is [`Some`] or [`None`], respectively.\n //!\n-//! [`is_some`]: Option::is_some\n //! [`is_none`]: Option::is_none\n+//! [`is_some`]: Option::is_some\n //!\n //! ## Adapters for working with references\n //!\n //! * [`as_ref`] converts from `&Option<T>` to `Option<&T>`\n //! * [`as_mut`] converts from `&mut Option<T>` to `Option<&mut T>`\n //! * [`as_deref`] converts from `&Option<T>` to `Option<&T::Target>`\n-//! * [`as_deref_mut`] converts from `&mut Option<T>` to `Option<&mut T::Target>`\n-//! * [`as_pin_ref`] converts from [`&Pin`]`<Option<T>>` to `Option<`[`Pin`]`<&T>>`\n-//! * [`as_pin_mut`] converts from [`&mut Pin`]`<Option<T>>` to `Option<`[`Pin`]`<&mut T>>`\n+//! * [`as_deref_mut`] converts from `&mut Option<T>` to\n+//!   `Option<&mut T::Target>`\n+//! * [`as_pin_ref`] converts from [`Pin`]`<&Option<T>>` to\n+//!   `Option<`[`Pin`]`<&T>>`\n+//! * [`as_pin_mut`] converts from [`Pin`]`<&mut Option<T>>` to\n+//!   `Option<`[`Pin`]`<&mut T>>`\n //!\n-//! [`&mut Pin`]: crate::pin::Pin\n-//! [`&Pin`]: crate::pin::Pin\n //! [`as_deref`]: Option::as_deref\n //! [`as_deref_mut`]: Option::as_deref_mut\n //! [`as_mut`]: Option::as_mut\n-//! [`as_pin_ref`]: Option::as_pin_ref\n //! [`as_pin_mut`]: Option::as_pin_mut\n+//! [`as_pin_ref`]: Option::as_pin_ref\n //! [`as_ref`]: Option::as_ref\n-//! [`Pin`]: crate::pin::Pin\n //!\n //! ## Extracting the contained value\n //!\n-//! These methods extract the contained value in an [`Option`] when it is\n-//! the [`Some`] variant. If the [`Option`] is [`None`]:\n+//! These methods extract the contained value in an [`Option<T>`] when it\n+//! is the [`Some`] variant. If the [`Option`] is [`None`]:\n //!\n //! * [`expect`] panics with a provided custom message\n //! * [`unwrap`] panics with a generic message\n@@ -135,7 +141,6 @@\n //! * [`unwrap_or_else`] returns the result of evaluating the provided\n //!   function\n //!\n-//! [`Default`]: crate::default::Default\n //! [`expect`]: Option::expect\n //! [`unwrap`]: Option::unwrap\n //! [`unwrap_or`]: Option::unwrap_or\n@@ -144,7 +149,7 @@\n //!\n //! ## Transforming contained values\n //!\n-//! These transformations are from [`Option`] to [`Result`].\n+//! These methods transform [`Option`] to [`Result`]:\n //!\n //! * [`ok_or`] transforms [`Some(v)`] to [`Ok(v)`], and [`None`] to\n //!   [`Err(err)`] using the provided default `err` value\n@@ -153,7 +158,14 @@\n //! * [`transpose`] transposes an [`Option`] of a [`Result`] into a\n //!   [`Result`] of an [`Option`]\n //!\n-//! These transformations are on [`Some`] values.\n+//! [`Err(err)`]: Err\n+//! [`Ok(v)`]: Ok\n+//! [`Some(v)`]: Some\n+//! [`ok_or`]: Option::ok_or\n+//! [`ok_or_else`]: Option::ok_or_else\n+//! [`transpose`]: Option::transpose\n+//!\n+//! These methods transform the [`Some`] variant:\n //!\n //! * [`filter`] calls the provided predicate function on the contained\n //!   value `t` if the [`Option`] is [`Some(t)`], and returns [`Some(t)`]\n@@ -163,38 +175,37 @@\n //! * [`map`] transforms [`Option<T>`] to [`Option<U>`] by applying the\n //!   provided function to the contained value of [`Some`] and leaving\n //!   [`None`] values unchanged\n-//! * [`map_or`] transforms [`Option<T>`] to a value of `U` by applying the\n-//!   provided function to the contained value of [`Some`], or transforms\n-//!   [`None`] to a provided default value of `U`\n-//! * [`map_or_else`] transforms [`Option<T>`] to a value of `U` by\n-//!   applying the provided function to the contained value of [`Some`], or\n-//!   transforms [`None`] to a value of `U` using a provided fallback\n-//!   function\n //!\n-//! These transformations combine two [`Some`] values.\n+//! [`Some(t)`]: Some\n+//! [`filter`]: Option::filter\n+//! [`flatten`]: Option::flatten\n+//! [`map`]: Option::map\n+//!\n+//! These methods transform [`Option<T>`] to a value of a possibly\n+//! different type `U`:\n+//!\n+//! * [`map_or`] applies the provided function to the contained value of\n+//!   [`Some`], or returns the provided default value if the [`Option`] is\n+//!   [`None`]\n+//! * [`map_or_else`] applies the provided function to the contained value\n+//!   of [`Some`], or returns the result of evaluating the provided\n+//!   fallback function if the [`Option`] is [`None`]\n+//!\n+//! [`map_or`]: Option::map_or\n+//! [`map_or_else`]: Option::map_or_else\n+//!\n+//! These methods combine the [`Some`] variants of two [`Option`] values:\n //!\n //! * [`zip`] returns [`Some((s, o))`] if `self` is [`Some(s)`] and the\n //!   provided [`Option`] value is [`Some(o)`]; otherwise, returns [`None`]\n //! * [`zip_with`] calls the provided function `f` and returns\n //!   [`Some(f(s, o))`] if `self` is [`Some(s)`] and the provided\n //!   [`Option`] value is [`Some(o)`]; otherwise, returns [`None`]\n //!\n-//! [`Err(err)`]: Err\n-//! [`filter`]: Option::filter\n-//! [`flatten`]: Option::flatten\n-//! [`map`]: Option::map\n-//! [`map_or`]: Option::map_or\n-//! [`map_or_else`]: Option::map_or_else\n-//! [`Ok(v)`]: Ok\n-//! [`ok_or`]: Option::ok_or\n-//! [`ok_or_else`]: Option::ok_or_else\n //! [`Some(f(s, o))`]: Some\n //! [`Some(o)`]: Some\n //! [`Some(s)`]: Some\n //! [`Some((s, o))`]: Some\n-//! [`Some(t)`]: Some\n-//! [`Some(v)`]: Some\n-//! [`transpose`]: Option::transpose\n //! [`zip`]: Option::zip\n //! [`zip_with`]: Option::zip_with\n //!\n@@ -223,6 +234,10 @@\n //! | [`xor`] | `Some(x)` | `None`    | `Some(x)` |\n //! | [`xor`] | `Some(x)` | `Some(y)` | `None`    |\n //!\n+//! [`and`]: Option::and\n+//! [`or`]: Option::or\n+//! [`xor`]: Option::xor\n+//!\n //! The [`and_then`] and [`or_else`] methods take a function as input, and\n //! only evaluate the function when they need to produce a new value. Only\n //! the [`and_then`] method can produce an [`Option<U>`] value having a\n@@ -237,11 +252,8 @@\n //! | [`or_else`]  | `None`    | (not provided) | `Some(y)`       | `Some(y)` |\n //! | [`or_else`]  | `Some(x)` | (not provided) | (not evaluated) | `Some(x)` |\n //!\n-//! [`and`]: Option::and\n //! [`and_then`]: Option::and_then\n-//! [`or`]: Option::or\n //! [`or_else`]: Option::or_else\n-//! [`xor`]: Option::xor\n //!\n //! This is an example of using methods like [`and_then`] and [`or`] in a\n //! pipeline of method calls. Early stages of the pipeline pass failure\n@@ -282,7 +294,11 @@\n //! [`once(v)`] if the [`Option`] is [`Some(v)`], and like [`empty()`] if\n //! the [`Option`] is [`None`].\n //!\n-//! Iterators over [`Option`] come in three types:\n+//! [`Some(v)`]: Some\n+//! [`empty()`]: crate::iter::empty\n+//! [`once(v)`]: crate::iter::once\n+//!\n+//! Iterators over [`Option<T>`] come in three types:\n //!\n //! * [`into_iter`] consumes the [`Option`] and produces the contained\n //!   value\n@@ -291,12 +307,9 @@\n //! * [`iter_mut`] produces a mutable reference of type `&mut T` to the\n //!   contained value\n //!\n-//! [`empty()`]: crate::iter::empty\n //! [`into_iter`]: Option::into_iter\n //! [`iter`]: Option::iter\n //! [`iter_mut`]: Option::iter_mut\n-//! [`once(v)`]: crate::iter::once\n-//! [`Some(v)`]: Some\n //!\n //! An iterator over [`Option`] can be useful when chaining iterators, for\n //! example, to conditionally insert items. (It's not always necessary to\n@@ -334,6 +347,9 @@\n //! we can't return `impl Iterator` anymore because the concrete types of\n //! the return values differ.\n //!\n+//! [`empty()`]: crate::iter::empty\n+//! [`once()`]: crate::iter::once\n+//!\n //! ```compile_fail,E0308\n //! # use std::iter::{empty, once};\n //! // This won't compile because all possible returns from the function\n@@ -347,16 +363,14 @@\n //! }\n //! ```\n //!\n-//! [`once()`]: crate::iter::once\n-//!\n //! ## Collecting into `Option`\n //!\n-//! [`Option`] implements the [`FromIterator`] trait, which allows an\n-//! iterator over [`Option`] values to be collected into an [`Option`] of a\n-//! collection of each contained value of the original [`Option`] values,\n-//! or [`None`] if any of the elements was [`None`].\n+//! [`Option`] implements the [`FromIterator`][impl-FromIterator] trait,\n+//! which allows an iterator over [`Option`] values to be collected into an\n+//! [`Option`] of a collection of each contained value of the original\n+//! [`Option`] values, or [`None`] if any of the elements was [`None`].\n //!\n-//! [`FromIterator`]: Option#impl-FromIterator%3COption%3CA%3E%3E\n+//! [impl-FromIterator]: Option#impl-FromIterator%3COption%3CA%3E%3E\n //!\n //! ```\n //! let v = vec![Some(2), Some(4), None, Some(8)];\n@@ -367,43 +381,52 @@\n //! assert_eq!(res, Some(vec![2, 4, 8]));\n //! ```\n //!\n-//! [`Option`] also implements the [`Product`] and [`Sum`] traits, allowing\n-//! an iterator over [`Option`] values to provide the\n-//! [`product`][m.product] and [`sum`][m.sum] methods.\n+//! [`Option`] also implements the [`Product`][impl-Product] and\n+//! [`Sum`][impl-Sum] traits, allowing an iterator over [`Option`] values\n+//! to provide the [`product`][Iterator::product] and\n+//! [`sum`][Iterator::sum] methods.\n //!\n-//! [`Product`]: Option#impl-Product%3COption%3CU%3E%3E\n-//! [`Sum`]: Option#impl-Sum%3COption%3CU%3E%3E\n-//! [m.product]: crate::iter::Iterator::product\n-//! [m.sum]: crate::iter::Iterator::sum\n+//! [impl-Product]: Option#impl-Product%3COption%3CU%3E%3E\n+//! [impl-Sum]: Option#impl-Sum%3COption%3CU%3E%3E\n+//!\n+//! ```\n+//! let v = vec![None, Some(1), Some(2), Some(3)];\n+//! let res: Option<i32> = v.into_iter().sum();\n+//! assert_eq!(res, None);\n+//! let v = vec![Some(1), Some(2), Some(21)];\n+//! let res: Option<i32> = v.into_iter().product();\n+//! assert_eq!(res, Some(42));\n+//! ```\n //!\n //! ## Modifying an [`Option`] in-place\n //!\n-//! These methods return a mutable reference to the contained value of a\n-//! [`Some`].\n+//! These methods return a mutable reference to the contained value of an\n+//! [`Option<T>`]:\n //!\n //! * [`insert`] inserts a value, dropping any old contents\n //! * [`get_or_insert`] gets the current value, inserting a provided\n //!   default value if it is [`None`]\n //! * [`get_or_insert_default`] gets the current value, inserting the\n-//!   default value of type `T` if it is [`None`]\n+//!   default value of type `T` (which must implement [`Default`]) if it is\n+//!   [`None`]\n //! * [`get_or_insert_with`] gets the current value, inserting a default\n //!   computed by the provided function if it is [`None`]\n //!\n-//! [`insert`]: Option::insert\n //! [`get_or_insert`]: Option::get_or_insert\n //! [`get_or_insert_default`]: Option::get_or_insert_default\n //! [`get_or_insert_with`]: Option::get_or_insert_with\n+//! [`insert`]: Option::insert\n //!\n-//! These methods transfer ownership of the [`Option`].\n+//! These methods transfer ownership of the contained of an [`Option`]:\n //!\n-//! * [`take`] takes ownership of the [`Option`], including any contained\n-//!   value, replacing it with [`None`]\n-//! * [`replace`] takes ownership of the [`Option`], including any\n-//!   contained value, replacing it with a [`Some`] containing the provided\n-//!   value\n+//! * [`take`] takes ownership of the contained value of an [`Option`], if\n+//!   any, replacing the [`Option`] with [`None`]\n+//! * [`replace`] takes ownership of the contained value of an [`Option`],\n+//!   if any, replacing the [`Option`] with a [`Some`] containing the\n+//!   provided value\n //!\n-//! [`take`]: Option::take\n //! [`replace`]: Option::replace\n+//! [`take`]: Option::take\n //!\n //! # Examples\n //!\n@@ -456,11 +479,6 @@\n //!     None => println!(\"there are no animals :(\"),\n //! }\n //! ```\n-//!\n-//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n-//! [`Box<U>`]: ../../std/boxed/struct.Box.html\n-//! [`num::NonZero*`]: crate::num\n-//! [`ptr::NonNull<U>`]: crate::ptr::NonNull\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "b9bb8cc9406cc3d6f1970c27185557c7da1ef4db", "filename": "library/core/src/result.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196cc9f125b1a121cc2a636b21143a2bb0b7cdf/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=c196cc9f125b1a121cc2a636b21143a2bb0b7cdf", "patch": "@@ -242,8 +242,9 @@\n //!\n //! * [`as_ref`] converts from `&Result<T, E>` to `Result<&T, &E>`\n //! * [`as_mut`] converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`\n-//! * [`as_deref`] converts from `&Result<T>` to `Result<&T::Target, &E>`\n-//! * [`as_deref_mut`] converts from `&mut Result<T>` to `Result<&mut T::Target, &mut E>`\n+//! * [`as_deref`] converts from `&Result<T, E>` to `Result<&T::Target, &E>`\n+//! * [`as_deref_mut`] converts from `&mut Result<T, E>` to\n+//!   `Result<&mut T::Target, &mut E>`\n //!\n //! [`as_deref`]: Result::as_deref\n //! [`as_deref_mut`]: Result::as_deref_mut\n@@ -252,8 +253,8 @@\n //!\n //! ## Extracting contained values\n //!\n-//! These methods extract the contained value in a [`Result`] when it is\n-//! the [`Ok`] variant. If the [`Result`] is [`Err`]:\n+//! These methods extract the contained value in a [`Result<T, E>`] when it\n+//! is the [`Ok`] variant. If the [`Result`] is [`Err`]:\n //!\n //! * [`expect`] panics with a provided custom message\n //! * [`unwrap`] panics with a generic message\n@@ -266,26 +267,27 @@\n //! The panicking methods [`expect`] and [`unwrap`] require `E` to\n //! implement the [`Debug`] trait.\n //!\n-//! These methods extract the contained value in a [`Result`] when it is\n-//! the [`Err`] variant. They require `T` to implement the [`Debug`] trait.\n-//! If the [`Result`] is [`Ok`]:\n+//! [`Debug`]: crate::fmt::Debug\n+//! [`expect`]: Result::expect\n+//! [`unwrap`]: Result::unwrap\n+//! [`unwrap_or`]: Result::unwrap_or\n+//! [`unwrap_or_default`]: Result::unwrap_or_default\n+//! [`unwrap_or_else`]: Result::unwrap_or_else\n+//!\n+//! These methods extract the contained value in a [`Result<T, E>`] when it\n+//! is the [`Err`] variant. They require `T` to implement the [`Debug`]\n+//! trait. If the [`Result`] is [`Ok`]:\n //!\n //! * [`expect_err`] panics with a provided custom message\n //! * [`unwrap_err`] panics with a generic message\n //!\n //! [`Debug`]: crate::fmt::Debug\n-//! [`Default`]: crate::default::Default\n-//! [`expect`]: Result::expect\n //! [`expect_err`]: Result::expect_err\n-//! [`unwrap`]: Result::unwrap\n //! [`unwrap_err`]: Result::unwrap_err\n-//! [`unwrap_or`]: Result::unwrap_or\n-//! [`unwrap_or_default`]: Result::unwrap_or_default\n-//! [`unwrap_or_else`]: Result::unwrap_or_else\n //!\n //! ## Transforming contained values\n //!\n-//! These transformations are from [`Result`] to [`Option`]:\n+//! These methods transform [`Result`] to [`Option`]:\n //!\n //! * [`err`][Result::err] transforms [`Result<T, E>`] into [`Option<E>`],\n //!   mapping [`Err(e)`] to [`Some(e)`] and [`Ok(v)`] to [`None`]\n@@ -294,35 +296,44 @@\n //! * [`transpose`] transposes a [`Result`] of an [`Option`] into an\n //!   [`Option`] of a [`Result`]\n //!\n-//! These transformations are on [`Ok`] values:\n+// Do NOT add link reference definitions for `err` or `ok`, because they\n+// will generate numerous incorrect URLs for `Err` and `Ok` elsewhere, due\n+// to case folding.\n+//!\n+//! [`Err(e)`]: Err\n+//! [`Ok(v)`]: Ok\n+//! [`Some(e)`]: Option::Some\n+//! [`Some(v)`]: Option::Some\n+//! [`transpose`]: Result::transpose\n+//!\n+//! This method transforms the contained value of the [`Ok`] variant:\n //!\n //! * [`map`] transforms [`Result<T, E>`] into [`Result<U, E>`] by applying\n //!   the provided function to the contained value of [`Ok`] and leaving\n //!   [`Err`] values unchanged\n-//! * [`map_or`] transforms [`Result<T, E>`] into a value of `U` by\n-//!   applying the provided function to the contained value of [`Ok`], or\n-//!   returns the provided default value of `U` if the [`Result`] is\n-//!   [`Err`]\n-//! * [`map_or_else`] transforms [`Result<T, E>`] into a value of `U` by\n-//!   applying the provided function to the contained value of [`Ok`], or\n-//!   applies the provided fallback function to the contained value of\n-//!   [`Err`]\n //!\n-//! This transformation is on [`Err`] values:\n+//! [`map`]: Result::map\n+//!\n+//! This method transforms the contained value of the [`Err`] variant:\n //!\n //! * [`map_err`] transforms [`Result<T, E>`] into [`Result<T, F>`] by\n //!   applying the provided function to the contained value of [`Err`] and\n //!   leaving [`Ok`] values unchanged\n //!\n-//! [`Err(e)`]: Err\n-//! [`Ok(v)`]: Ok\n-//! [`Some(e)`]: Option::Some\n-//! [`Some(v)`]: Option::Some\n-//! [`map`]: Result::map\n //! [`map_err`]: Result::map_err\n+//!\n+//! These methods transform a [`Result<T, E>`] into a value of a possibly\n+//! different type `U`:\n+//!\n+//! * [`map_or`] applies the provided function to the contained value of\n+//!   [`Ok`], or returns the provided default value if the [`Result`] is\n+//!   [`Err`]\n+//! * [`map_or_else`] applies the provided function to the contained value\n+//!   of [`Ok`], or applies the provided fallback function to the contained\n+//!   value of [`Err`]\n+//!\n //! [`map_or`]: Result::map_or\n //! [`map_or_else`]: Result::map_or_else\n-//! [`transpose`]: Result::transpose\n //!\n //! ## Boolean operators\n //!\n@@ -346,6 +357,9 @@\n //! | [`or`]  | `Err(e)` | `Ok(y)`   | `Ok(y)`  |\n //! | [`or`]  | `Ok(x)`  | (ignored) | `Ok(x)`  |\n //!\n+//! [`and`]: Result::and\n+//! [`or`]: Result::or\n+//!\n //! The [`and_then`] and [`or_else`] methods take a function as input, and\n //! only evaluate the function when they need to produce a new value. The\n //! [`and_then`] method can produce a [`Result<U, E>`] value having a\n@@ -362,9 +376,7 @@\n //! | [`or_else`]  | `Err(e)` | `e`            | `Ok(y)`         | `Ok(y)`  |\n //! | [`or_else`]  | `Ok(x)`  | (not provided) | (not evaluated) | `Ok(x)`  |\n //!\n-//! [`and`]: Result::and\n //! [`and_then`]: Result::and_then\n-//! [`or`]: Result::or\n //! [`or_else`]: Result::or_else\n //!\n //! ## Iterating over `Result`\n@@ -373,10 +385,14 @@\n //! iterator that is conditionally empty. The iterator will either produce\n //! a single value (when the [`Result`] is [`Ok`]), or produce no values\n //! (when the [`Result`] is [`Err`]). For example, [`into_iter`] acts like\n-//! [`once(v)`] if the [`Result`] is [`Ok(v)`], and like [`empty()`] if\n-//! the [`Result`] is [`Err(err)`].\n+//! [`once(v)`] if the [`Result`] is [`Ok(v)`], and like [`empty()`] if the\n+//! [`Result`] is [`Err`].\n+//!\n+//! [`Ok(v)`]: Ok\n+//! [`empty()`]: crate::iter::empty\n+//! [`once(v)`]: crate::iter::once\n //!\n-//! Iterators over [`Result`] come in three types:\n+//! Iterators over [`Result<T, E>`] come in three types:\n //!\n //! * [`into_iter`] consumes the [`Result`] and produces the contained\n //!   value\n@@ -387,22 +403,16 @@\n //!\n //! See [Iterating over `Option`] for examples of how this can be useful.\n //!\n-//! [`Err(err)`]: Err\n //! [Iterating over `Option`]: crate::option#iterating-over-option\n-//! [`Ok(v)`]: Ok\n-//! [`empty()`]: crate::iter::empty\n //! [`into_iter`]: Result::into_iter\n //! [`iter`]: Result::iter\n //! [`iter_mut`]: Result::iter_mut\n-//! [`once(v)`]: crate::iter::once\n //!\n //! You might want to use an iterator chain to do multiple instances of an\n //! operation that can fail, but would like to ignore failures while\n //! continuing to process the successful results. In this example, we take\n //! advantage of the iterable nature of [`Result`] to select only the\n-//! [`Ok`] values using [`flatten`].\n-//!\n-//! [`flatten`]: crate::iter::Iterator::flatten\n+//! [`Ok`] values using [`flatten`][Iterator::flatten].\n //!\n //! ```\n //! # use std::str::FromStr;\n@@ -426,12 +436,12 @@\n //!\n //! ## Collecting into `Result`\n //!\n-//! [`Result`] implements the [`FromIterator`] trait, which allows an\n-//! iterator over [`Result`] values to be collected into a [`Result`] of a\n-//! collection of each contained value of the original [`Result`] values,\n-//! or [`Err`] if any of the elements was [`Err`].\n+//! [`Result`] implements the [`FromIterator`][impl-FromIterator] trait,\n+//! which allows an iterator over [`Result`] values to be collected into a\n+//! [`Result`] of a collection of each contained value of the original\n+//! [`Result`] values, or [`Err`] if any of the elements was [`Err`].\n //!\n-//! [`FromIterator`]: Result#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E\n+//! [impl-FromIterator]: Result#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E\n //!\n //! ```\n //! let v = vec![Ok(2), Ok(4), Err(\"err!\"), Ok(8)];\n@@ -442,14 +452,22 @@\n //! assert_eq!(res, Ok(vec![2, 4, 8]));\n //! ```\n //!\n-//! [`Result`] also implements the [`Product`] and [`Sum`] traits, allowing\n-//! an iterator over [`Result`] values to provide the\n-//! [`product`][m.product] and [`sum`][m.sum] methods.\n+//! [`Result`] also implements the [`Product`][impl-Product] and\n+//! [`Sum`][impl-Sum] traits, allowing an iterator over [`Result`] values\n+//! to provide the [`product`][Iterator::product] and\n+//! [`sum`][Iterator::sum] methods.\n //!\n-//! [`Product`]: Result#impl-Product%3CResult%3CU%2C%20E%3E%3E\n-//! [`Sum`]: Result#impl-Sum%3CResult%3CU%2C%20E%3E%3E\n-//! [m.product]: crate::iter::Iterator::product\n-//! [m.sum]: crate::iter::Iterator::sum\n+//! [impl-Product]: Result#impl-Product%3CResult%3CU%2C%20E%3E%3E\n+//! [impl-Sum]: Result#impl-Sum%3CResult%3CU%2C%20E%3E%3E\n+//!\n+//! ```\n+//! let v = vec![Err(\"error!\"), Ok(1), Ok(2), Ok(3), Err(\"foo\")];\n+//! let res: Result<i32, &str> = v.into_iter().sum();\n+//! assert_eq!(res, Err(\"error!\"));\n+//! let v: Vec<Result<i32, &str>> = vec![Ok(1), Ok(2), Ok(21)];\n+//! let res: Result<i32, &str> = v.into_iter().product();\n+//! assert_eq!(res, Ok(42));\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}