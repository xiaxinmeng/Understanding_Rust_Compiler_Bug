{"sha": "e33fca9ffefffc982bbde860251f11b191457412", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzM2ZjYTlmZmVmZmZjOTgyYmJkZTg2MDI1MWYxMWIxOTE0NTc0MTI=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-07-27T21:38:38Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-07-30T10:55:48Z"}, "message": "Added str::char_offset_iter() and str::rev_char_offset_iter()\nRenamed bytes_iter to byte_iter to match other iterators\nRefactored str Iterators to use DoubleEnded Iterators and typedefs instead of wrapper structs\nReordered the Iterator section\nWhitespace fixup\nMoved clunky `each_split_within` function to the one place in the tree where it's actually needed\nReplaced all block doccomments in str with line doccomments", "tree": {"sha": "96aa8a71d31a63dd53446af3e0c235e8128305d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96aa8a71d31a63dd53446af3e0c235e8128305d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e33fca9ffefffc982bbde860251f11b191457412", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e33fca9ffefffc982bbde860251f11b191457412", "html_url": "https://github.com/rust-lang/rust/commit/e33fca9ffefffc982bbde860251f11b191457412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e33fca9ffefffc982bbde860251f11b191457412/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d75ab4a5d798164c37e04a0794f2e28acdb76dd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d75ab4a5d798164c37e04a0794f2e28acdb76dd4", "html_url": "https://github.com/rust-lang/rust/commit/d75ab4a5d798164c37e04a0794f2e28acdb76dd4"}], "stats": {"total": 1189, "additions": 592, "deletions": 597}, "files": [{"sha": "8db32c8cca4eac5f472a06501440e9fbaaac2a1b", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -476,7 +476,6 @@ pub mod groups {\n     use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n     use getopts::{Short, Yes};\n \n-    use std::str;\n     use std::vec;\n \n     /** one group of options, e.g., both -h and --help, along with\n@@ -667,7 +666,7 @@ pub mod groups {\n \n             // FIXME: #5516\n             let mut desc_rows = ~[];\n-            for str::each_split_within(desc_normalized_whitespace, 54) |substr| {\n+            for each_split_within(desc_normalized_whitespace, 54) |substr| {\n                 desc_rows.push(substr.to_owned());\n             }\n \n@@ -683,6 +682,103 @@ pub mod groups {\n                rows.collect::<~[~str]>().connect(\"\\n\") +\n                \"\\n\\n\";\n     }\n+\n+    /** Splits a string into substrings with possibly internal whitespace,\n+     *  each of them at most `lim` bytes long. The substrings have leading and trailing\n+     *  whitespace removed, and are only cut at whitespace boundaries.\n+     *\n+     *  Note: Function was moved here from `std::str` because this module is the only place that\n+     *  uses it, and because it was to specific for a general string function.\n+     *\n+     *  #Failure:\n+     *\n+     *  Fails during iteration if the string contains a non-whitespace\n+     *  sequence longer than the limit.\n+     */\n+    priv fn each_split_within<'a>(ss: &'a str,\n+                                lim: uint,\n+                                it: &fn(&'a str) -> bool) -> bool {\n+        // Just for fun, let's write this as an state machine:\n+\n+        enum SplitWithinState {\n+            A,  // leading whitespace, initial state\n+            B,  // words\n+            C,  // internal and trailing whitespace\n+        }\n+        enum Whitespace {\n+            Ws, // current char is whitespace\n+            Cr  // current char is not whitespace\n+        }\n+        enum LengthLimit {\n+            UnderLim, // current char makes current substring still fit in limit\n+            OverLim   // current char makes current substring no longer fit in limit\n+        }\n+\n+        let mut slice_start = 0;\n+        let mut last_start = 0;\n+        let mut last_end = 0;\n+        let mut state = A;\n+        let mut fake_i = ss.len();\n+        let mut lim = lim;\n+\n+        let mut cont = true;\n+        let slice: &fn() = || { cont = it(ss.slice(slice_start, last_end)) };\n+\n+        // if the limit is larger than the string, lower it to save cycles\n+        if (lim >= fake_i) {\n+            lim = fake_i;\n+        }\n+\n+        let machine: &fn((uint, char)) -> bool = |(i, c)| {\n+            let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n+            let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n+\n+            state = match (state, whitespace, limit) {\n+                (A, Ws, _)        => { A }\n+                (A, Cr, _)        => { slice_start = i; last_start = i; B }\n+\n+                (B, Cr, UnderLim) => { B }\n+                (B, Cr, OverLim)  if (i - last_start + 1) > lim\n+                                => fail!(\"word starting with %? longer than limit!\",\n+                                        ss.slice(last_start, i + 1)),\n+                (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n+                (B, Ws, UnderLim) => { last_end = i; C }\n+                (B, Ws, OverLim)  => { last_end = i; slice(); A }\n+\n+                (C, Cr, UnderLim) => { last_start = i; B }\n+                (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n+                (C, Ws, OverLim)  => { slice(); A }\n+                (C, Ws, UnderLim) => { C }\n+            };\n+\n+            cont\n+        };\n+\n+        ss.iter().enumerate().advance(|x| machine(x));\n+\n+        // Let the automaton 'run out' by supplying trailing whitespace\n+        while cont && match state { B | C => true, A => false } {\n+            machine((fake_i, ' '));\n+            fake_i += 1;\n+        }\n+        return cont;\n+    }\n+\n+    #[test]\n+    priv fn test_split_within() {\n+        fn t(s: &str, i: uint, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n+        }\n+        t(\"\", 0, []);\n+        t(\"\", 15, []);\n+        t(\"hello\", 15, [~\"hello\"]);\n+        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n+            [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n+        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::max_value,\n+            [~\"Mary had a little lamb\\nLittle lamb\"]);\n+    }\n } // end groups module\n \n #[cfg(test)]"}, {"sha": "b07c18f0e4d908351f11cb172fc196044d4d8ef8", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -260,7 +260,7 @@ impl Tm {\n priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        for needle.bytes_iter().advance |ch| {\n+        for needle.byte_iter().advance |ch| {\n             if s[i] != ch {\n                 return false;\n             }"}, {"sha": "311b22ad6209690b41a464ba8ccbceebb736f648", "filename": "src/libstd/str.rs", "status": "modified", "additions": 489, "deletions": 590, "changes": 1079, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -25,6 +25,7 @@ use container::{Container, Mutable};\n use iter::Times;\n use iterator::{Iterator, FromIterator, Extendable, IteratorUtil};\n use iterator::{Filter, AdditiveIterator, Map};\n+use iterator::{Invert, DoubleEndedIterator, DoubleEndedIteratorUtil};\n use libc;\n use num::Zero;\n use option::{None, Option, Some};\n@@ -39,6 +40,7 @@ use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n /*\n Section: Conditions\n */\n+\n condition! {\n     not_utf8: (~str) -> ~str;\n }\n@@ -47,33 +49,28 @@ condition! {\n Section: Creating a string\n */\n \n-/**\n- * Convert a vector of bytes to a new UTF-8 string\n- *\n- * # Failure\n- *\n- * Raises the `not_utf8` condition if invalid UTF-8\n- */\n+/// Convert a vector of bytes to a new UTF-8 string\n+///\n+/// # Failure\n+///\n+/// Raises the `not_utf8` condition if invalid UTF-8\n pub fn from_bytes(vv: &[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n         let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).get();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n-    }\n-    else {\n+    } else {\n         return unsafe { raw::from_bytes(vv) }\n     }\n }\n \n-/**\n- * Consumes a vector of bytes to create a new utf-8 string\n- *\n- * # Failure\n- *\n- * Raises the `not_utf8` condition if invalid UTF-8\n- */\n+/// Consumes a vector of bytes to create a new utf-8 string\n+///\n+/// # Failure\n+///\n+/// Raises the `not_utf8` condition if invalid UTF-8\n pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n@@ -86,33 +83,29 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n     }\n }\n \n-/**\n- * Convert a vector of bytes to a UTF-8 string.\n- * The vector needs to be one byte longer than the string, and end with a 0 byte.\n- *\n- * Compared to `from_bytes()`, this fn doesn't need to allocate a new owned str.\n- *\n- * # Failure\n- *\n- * Fails if invalid UTF-8\n- * Fails if not null terminated\n- */\n+/// Convert a vector of bytes to a UTF-8 string.\n+/// The vector needs to be one byte longer than the string, and end with a 0 byte.\n+///\n+/// Compared to `from_bytes()`, this fn doesn't need to allocate a new owned str.\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n+/// Fails if not null terminated\n pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n     assert_eq!(vv[vv.len() - 1], 0);\n     assert!(is_utf8(vv));\n     return unsafe { raw::from_bytes_with_null(vv) };\n }\n \n-/**\n- * Converts a vector to a string slice without performing any allocations.\n- *\n- * Once the slice has been validated as utf-8, it is transmuted in-place and\n- * returned as a '&str' instead of a '&[u8]'\n- *\n- * # Failure\n- *\n- * Fails if invalid UTF-8\n- */\n+/// Converts a vector to a string slice without performing any allocations.\n+///\n+/// Once the slice has been validated as utf-8, it is transmuted in-place and\n+/// returned as a '&str' instead of a '&[u8]'\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     unsafe {\n         assert!(is_utf8(vector));\n@@ -135,13 +128,11 @@ impl ToStr for @str {\n     fn to_str(&self) -> ~str { self.to_owned() }\n }\n \n-/**\n- * Convert a byte to a UTF-8 string\n- *\n- * # Failure\n- *\n- * Fails if invalid UTF-8\n- */\n+/// Convert a byte to a UTF-8 string\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n     unsafe { cast::transmute(~[b, 0u8]) }\n@@ -249,18 +240,21 @@ pub trait CharEq {\n     /// which can allow for a faster implementation.\n     fn only_ascii(&self) -> bool;\n }\n+\n impl CharEq for char {\n     #[inline]\n     fn matches(&self, c: char) -> bool { *self == c }\n \n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n+\n impl<'self> CharEq for &'self fn(char) -> bool {\n     #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n+\n impl CharEq for extern \"Rust\" fn(char) -> bool {\n     #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n@@ -279,6 +273,70 @@ impl<'self, C: CharEq> CharEq for &'self [C] {\n     }\n }\n \n+/*\n+Section: Iterators\n+*/\n+\n+/// External iterator for a string's characters and their byte offsets.\n+/// Use with the `std::iterator` module.\n+#[deriving(Clone)]\n+pub struct CharOffsetIterator<'self> {\n+    priv index_front: uint,\n+    priv index_back: uint,\n+    priv string: &'self str,\n+}\n+\n+impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, char)> {\n+        if self.index_front < self.index_back {\n+            let CharRange {ch, next} = self.string.char_range_at(self.index_front);\n+            let index = self.index_front;\n+            self.index_front = next;\n+            Some((index, ch))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(uint, char)> {\n+        if self.index_front < self.index_back {\n+            let CharRange {ch, next} = self.string.char_range_at_reverse(self.index_back);\n+            self.index_back = next;\n+            Some((next, ch))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// External iterator for a string's characters and their byte offsets in reverse order.\n+/// Use with the `std::iterator` module.\n+pub type CharOffsetRevIterator<'self> =\n+    Invert<CharOffsetIterator<'self>>;\n+\n+/// External iterator for a string's characters.\n+/// Use with the `std::iterator` module.\n+pub type CharIterator<'self> =\n+    Map<'self, (uint, char), char, CharOffsetIterator<'self>>;\n+\n+/// External iterator for a string's characters in reverse order.\n+/// Use with the `std::iterator` module.\n+pub type CharRevIterator<'self> =\n+    Invert<Map<'self, (uint, char), char, CharOffsetIterator<'self>>>;\n+\n+/// External iterator for a string's bytes.\n+/// Use with the `std::iterator` module.\n+pub type ByteIterator<'self> =\n+    Map<'self, &'self u8, u8, vec::VecIterator<'self, u8>>;\n+\n+/// External iterator for a string's bytes in reverse order.\n+/// Use with the `std::iterator` module.\n+pub type ByteRevIterator<'self> =\n+    Invert<Map<'self, &'self u8, u8, vec::VecIterator<'self, u8>>>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n@@ -414,97 +472,17 @@ impl<'self> Iterator<&'self str> for StrSplitIterator<'self> {\n     }\n }\n \n-/** Splits a string into substrings with possibly internal whitespace,\n- *  each of them at most `lim` bytes long. The substrings have leading and trailing\n- *  whitespace removed, and are only cut at whitespace boundaries.\n- *\n- *  #Failure:\n- *\n- *  Fails during iteration if the string contains a non-whitespace\n- *  sequence longer than the limit.\n- */\n-pub fn each_split_within<'a>(ss: &'a str,\n-                              lim: uint,\n-                              it: &fn(&'a str) -> bool) -> bool {\n-    // Just for fun, let's write this as an state machine:\n-\n-    enum SplitWithinState {\n-        A,  // leading whitespace, initial state\n-        B,  // words\n-        C,  // internal and trailing whitespace\n-    }\n-    enum Whitespace {\n-        Ws, // current char is whitespace\n-        Cr  // current char is not whitespace\n-    }\n-    enum LengthLimit {\n-        UnderLim, // current char makes current substring still fit in limit\n-        OverLim   // current char makes current substring no longer fit in limit\n-    }\n-\n-    let mut slice_start = 0;\n-    let mut last_start = 0;\n-    let mut last_end = 0;\n-    let mut state = A;\n-    let mut fake_i = ss.len();\n-    let mut lim = lim;\n-\n-    let mut cont = true;\n-    let slice: &fn() = || { cont = it(ss.slice(slice_start, last_end)) };\n-\n-    // if the limit is larger than the string, lower it to save cycles\n-    if (lim >= fake_i) {\n-        lim = fake_i;\n-    }\n-\n-    let machine: &fn((uint, char)) -> bool = |(i, c)| {\n-        let whitespace = if char::is_whitespace(c)       { Ws }       else { Cr };\n-        let limit      = if (i - slice_start + 1) <= lim { UnderLim } else { OverLim };\n-\n-        state = match (state, whitespace, limit) {\n-            (A, Ws, _)        => { A }\n-            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n-\n-            (B, Cr, UnderLim) => { B }\n-            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                              => fail!(\"word starting with %? longer than limit!\",\n-                                       ss.slice(last_start, i + 1)),\n-            (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n-            (B, Ws, UnderLim) => { last_end = i; C }\n-            (B, Ws, OverLim)  => { last_end = i; slice(); A }\n-\n-            (C, Cr, UnderLim) => { last_start = i; B }\n-            (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n-            (C, Ws, OverLim)  => { slice(); A }\n-            (C, Ws, UnderLim) => { C }\n-        };\n-\n-        cont\n-    };\n-\n-    ss.iter().enumerate().advance(|x| machine(x));\n-\n-    // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont && match state { B | C => true, A => false } {\n-        machine((fake_i, ' '));\n-        fake_i += 1;\n-    }\n-    return cont;\n-}\n-\n-/**\n- * Replace all occurrences of one string with another\n- *\n- * # Arguments\n- *\n- * * s - The string containing substrings to replace\n- * * from - The string to replace\n- * * to - The replacement string\n- *\n- * # Return value\n- *\n- * The original string with all occurances of `from` replaced with `to`\n- */\n+/// Replace all occurrences of one string with another\n+///\n+/// # Arguments\n+///\n+/// * s - The string containing substrings to replace\n+/// * from - The string to replace\n+/// * to - The replacement string\n+///\n+/// # Return value\n+///\n+/// The original string with all occurances of `from` replaced with `to`\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\";\n     let mut last_end = 0;\n@@ -578,7 +556,7 @@ Section: Searching\n // Utility used by various searching functions\n fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n-    for needle.bytes_iter().advance |c| { if haystack[i] != c { return false; } i += 1u; }\n+    for needle.byte_iter().advance |c| { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n }\n \n@@ -663,40 +641,34 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     }\n }\n \n-/**\n- * Allocates a new string from the utf-16 slice provided\n- */\n+/// Allocates a new string from the utf-16 slice provided\n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     buf.reserve(v.len());\n     utf16_chars(v, |ch| buf.push_char(ch));\n     buf\n }\n \n-/**\n- * Allocates a new string with the specified capacity. The string returned is\n- * the empty string, but has capacity for much more.\n- */\n+/// Allocates a new string with the specified capacity. The string returned is\n+/// the empty string, but has capacity for much more.\n #[inline]\n pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n     buf.reserve(capacity);\n     buf\n }\n \n-/**\n- * As char_len but for a slice of a string\n- *\n- * # Arguments\n- *\n- * * s - A valid string\n- * * start - The position inside `s` where to start counting in bytes\n- * * end - The position where to stop counting\n- *\n- * # Return value\n- *\n- * The number of Unicode characters in `s` between the given indices.\n- */\n+/// As char_len but for a slice of a string\n+///\n+/// # Arguments\n+///\n+/// * s - A valid string\n+/// * start - The position inside `s` where to start counting in bytes\n+/// * end - The position where to stop counting\n+///\n+/// # Return value\n+///\n+/// The number of Unicode characters in `s` between the given indices.\n pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert!(s.is_char_boundary(start));\n     assert!(s.is_char_boundary(end));\n@@ -851,16 +823,14 @@ pub mod raw {\n         cast::transmute(v)\n     }\n \n-    /**\n-     * Takes a bytewise (not UTF-8) slice from a string.\n-     *\n-     * Returns the substring from [`begin`..`end`).\n-     *\n-     * # Failure\n-     *\n-     * If begin is greater than end.\n-     * If end is greater than the length of the string.\n-     */\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Failure\n+    ///\n+    /// If begin is greater than end.\n+    /// If end is greater than the length of the string.\n     #[inline]\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do s.as_imm_buf |sbuf, n| {\n@@ -931,6 +901,10 @@ pub mod raw {\n \n }\n \n+/*\n+Section: Trait implementations\n+*/\n+\n #[cfg(not(test))]\n pub mod traits {\n     use ops::Add;\n@@ -949,7 +923,7 @@ pub mod traits {\n     impl<'self> TotalOrd for &'self str {\n         #[inline]\n         fn cmp(&self, other: & &'self str) -> Ordering {\n-            for self.bytes_iter().zip(other.bytes_iter()).advance |(s_b, o_b)| {\n+            for self.byte_iter().zip(other.byte_iter()).advance |(s_b, o_b)| {\n                 match s_b.cmp(&o_b) {\n                     Greater => return Greater,\n                     Less => return Less,\n@@ -1081,12 +1055,14 @@ impl<'self> Str for &'self str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { *self }\n }\n+\n impl<'self> Str for ~str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n     }\n }\n+\n impl<'self> Str for @str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n@@ -1121,15 +1097,16 @@ impl Mutable for ~str {\n     }\n }\n \n-\n #[allow(missing_doc)]\n pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n     fn iter(&self) -> CharIterator<'self>;\n     fn rev_iter(&self) -> CharRevIterator<'self>;\n-    fn bytes_iter(&self) -> BytesIterator<'self>;\n-    fn bytes_rev_iter(&self) -> BytesRevIterator<'self>;\n+    fn byte_iter(&self) -> ByteIterator<'self>;\n+    fn byte_rev_iter(&self) -> ByteRevIterator<'self>;\n+    fn char_offset_iter(&self) -> CharOffsetIterator<'self>;\n+    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self>;\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n     fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep>;\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n@@ -1190,28 +1167,26 @@ pub trait StrSlice<'self> {\n \n /// Extension methods for strings\n impl<'self> StrSlice<'self> for &'self str {\n-    /**\n-     * Returns true if one string contains another\n-     *\n-     * # Arguments\n-     *\n-     * * needle - The string to look for\n-     */\n+    /// Returns true if one string contains another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * needle - The string to look for\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n         self.find_str(needle).is_some()\n     }\n-    /**\n-     * Returns true if a string contains a char.\n-     *\n-     * # Arguments\n-     *\n-     * * needle - The char to look for\n-     */\n+\n+    /// Returns true if a string contains a char.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * needle - The char to look for\n     #[inline]\n     fn contains_char(&self, needle: char) -> bool {\n         self.find(needle).is_some()\n     }\n+\n     /// An iterator over the characters of `self`. Note, this iterates\n     /// over unicode code-points, not unicode graphemes.\n     ///\n@@ -1223,29 +1198,41 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~\n     #[inline]\n     fn iter(&self) -> CharIterator<'self> {\n-        CharIterator {\n-            index: 0,\n-            string: *self\n-        }\n+        self.char_offset_iter().transform(|(_, c)| c)\n     }\n+\n     /// An iterator over the characters of `self`, in reverse order.\n     #[inline]\n     fn rev_iter(&self) -> CharRevIterator<'self> {\n-        CharRevIterator {\n-            index: self.len(),\n-            string: *self\n-        }\n+        self.iter().invert()\n     }\n \n     /// An iterator over the bytes of `self`\n     #[inline]\n-    fn bytes_iter(&self) -> BytesIterator<'self> {\n-        BytesIterator { it: self.as_bytes().iter() }\n+    fn byte_iter(&self) -> ByteIterator<'self> {\n+        self.as_bytes().iter().transform(|&b| b)\n     }\n+\n     /// An iterator over the bytes of `self`, in reverse order\n     #[inline]\n-    fn bytes_rev_iter(&self) -> BytesRevIterator<'self> {\n-        BytesRevIterator { it: self.as_bytes().rev_iter() }\n+    fn byte_rev_iter(&self) -> ByteRevIterator<'self> {\n+        self.byte_iter().invert()\n+    }\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    #[inline]\n+    fn char_offset_iter(&self) -> CharOffsetIterator<'self> {\n+        CharOffsetIterator {\n+            index_front: 0,\n+            index_back: self.len(),\n+            string: *self\n+        }\n+    }\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    #[inline]\n+    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self> {\n+        self.char_offset_iter().invert()\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -1291,6 +1278,7 @@ impl<'self> StrSlice<'self> for &'self str {\n             only_ascii: only_ascii\n         }\n     }\n+\n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n     #[inline]\n@@ -1302,16 +1290,15 @@ impl<'self> StrSlice<'self> for &'self str {\n             position: 0\n         }\n     }\n-    /**\n-     * An iterator over the substrings of `self` separated by `sep`.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * let v: ~[&str] = \"abcXXXabcYYYabc\".split_str_iter(\"abc\").collect()\n-     * assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n-     * ~~~\n-     */\n+\n+    /// An iterator over the substrings of `self` separated by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str_iter(\"abc\").collect()\n+    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n+    /// ~~~\n     #[inline]\n     fn split_str_iter(&self, sep: &'self str) -> StrSplitIterator<'self> {\n         StrSplitIterator {\n@@ -1345,37 +1332,34 @@ impl<'self> StrSlice<'self> for &'self str {\n         self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n-    /**\n-     * Returns true if the string contains only whitespace\n-     *\n-     * Whitespace characters are determined by `char::is_whitespace`\n-     */\n+    /// Returns true if the string contains only whitespace\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`\n     #[inline]\n     fn is_whitespace(&self) -> bool { self.iter().all(char::is_whitespace) }\n-    /**\n-     * Returns true if the string contains only alphanumerics\n-     *\n-     * Alphanumeric characters are determined by `char::is_alphanumeric`\n-     */\n+\n+    /// Returns true if the string contains only alphanumerics\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n+\n     /// Returns the number of characters that a string holds\n     #[inline]\n     fn char_len(&self) -> uint { self.iter().len_() }\n \n-    /**\n-     * Returns a slice of the given string from the byte range\n-     * [`begin`..`end`)\n-     *\n-     * Fails when `begin` and `end` do not point to valid characters or\n-     * beyond the last character of the string\n-     */\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`)\n+    ///\n+    /// Fails when `begin` and `end` do not point to valid characters or\n+    /// beyond the last character of the string\n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'self str {\n         assert!(self.is_char_boundary(begin));\n         assert!(self.is_char_boundary(end));\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n+\n     /// Returns a slice of the string from `begin` to its end.\n     ///\n     /// Fails when `begin` does not point to a valid character, or is\n@@ -1384,6 +1368,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn slice_from(&self, begin: uint) -> &'self str {\n         self.slice(begin, self.len())\n     }\n+\n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n@@ -1427,6 +1412,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         else if needle_len > self_len { false }\n         else { match_at(*self, needle, 0u) }\n     }\n+\n     /// Returns true if `needle` is a suffix of the string.\n     fn ends_with(&self, needle: &str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n@@ -1464,73 +1450,71 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn trim(&self) -> &'self str {\n         self.trim_left().trim_right()\n     }\n+\n     /// Returns a string with leading whitespace removed\n     #[inline]\n     fn trim_left(&self) -> &'self str {\n         self.trim_left_chars(&char::is_whitespace)\n     }\n+\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n     fn trim_right(&self) -> &'self str {\n         self.trim_right_chars(&char::is_whitespace)\n     }\n \n-    /**\n-     * Returns a string with characters that match `to_trim` removed.\n-     *\n-     * # Arguments\n-     *\n-     * * to_trim - a character matcher\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n-     * assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n-     * assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n-     * ~~~\n-     */\n+    /// Returns a string with characters that match `to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n+    /// ~~~\n     #[inline]\n     fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n     }\n-    /**\n-     * Returns a string with leading `chars_to_trim` removed.\n-     *\n-     * # Arguments\n-     *\n-     * * to_trim - a character matcher\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n-     * assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n-     * assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n-     * ~~~\n-     */\n+\n+    /// Returns a string with leading `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n+    /// ~~~\n     #[inline]\n     fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n         }\n     }\n-    /**\n-     * Returns a string with trailing `chars_to_trim` removed.\n-     *\n-     * # Arguments\n-     *\n-     * * to_trim - a character matcher\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n-     * assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n-     * assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n-     * ~~~\n-     */\n+\n+    /// Returns a string with trailing `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n+    /// ~~~\n     #[inline]\n     fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n@@ -1542,18 +1526,16 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /**\n-     * Replace all occurrences of one string with another\n-     *\n-     * # Arguments\n-     *\n-     * * from - The string to replace\n-     * * to - The replacement string\n-     *\n-     * # Return value\n-     *\n-     * The original string with all occurances of `from` replaced with `to`\n-     */\n+    /// Replace all occurrences of one string with another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * from - The string to replace\n+    /// * to - The replacement string\n+    ///\n+    /// # Return value\n+    ///\n+    /// The original string with all occurances of `from` replaced with `to`\n     pub fn replace(&self, from: &str, to: &str) -> ~str {\n         let mut result = ~\"\";\n         let mut last_end = 0;\n@@ -1616,65 +1598,61 @@ impl<'self> StrSlice<'self> for &'self str {\n         u\n     }\n \n-    /**\n-     * Returns false if the index points into the middle of a multi-byte\n-     * character sequence.\n-     */\n+    /// Returns false if the index points into the middle of a multi-byte\n+    /// character sequence.\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n         let b = self[index];\n         return b < 128u8 || b >= 192u8;\n     }\n \n-    /**\n-     * Pluck a character out of a string and return the index of the next\n-     * character.\n-     *\n-     * This function can be used to iterate over the unicode characters of a\n-     * string.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-     * let i = 0u;\n-     * while i < s.len() {\n-     *     let CharRange {ch, next} = s.char_range_at(i);\n-     *     printfln!(\"%u: %c\", i, ch);\n-     *     i = next;\n-     * }\n-     * ~~~\n-     *\n-     * # Example output\n-     *\n-     * ~~~\n-     * 0: \u4e2d\n-     * 3: \u534e\n-     * 6: V\n-     * 7: i\n-     * 8: \u1ec7\n-     * 11: t\n-     * 12:\n-     * 13: N\n-     * 14: a\n-     * 15: m\n-     * ~~~\n-     *\n-     * # Arguments\n-     *\n-     * * s - The string\n-     * * i - The byte offset of the char to extract\n-     *\n-     * # Return value\n-     *\n-     * A record {ch: char, next: uint} containing the char value and the byte\n-     * index of the next unicode character.\n-     *\n-     * # Failure\n-     *\n-     * If `i` is greater than or equal to the length of the string.\n-     * If `i` is not the index of the beginning of a valid UTF-8 character.\n-     */\n+    /// Pluck a character out of a string and return the index of the next\n+    /// character.\n+    ///\n+    /// This function can be used to iterate over the unicode characters of a\n+    /// string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let i = 0u;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     printfln!(\"%u: %c\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ~~~\n+    ///\n+    /// # Example output\n+    ///\n+    /// ~~~\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ~~~\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - The string\n+    /// * i - The byte offset of the char to extract\n+    ///\n+    /// # Return value\n+    ///\n+    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// index of the next unicode character.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n         if (self[i] < 128u8) {\n@@ -1704,13 +1682,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     #[inline]\n     fn char_at(&self, i: uint) -> char { self.char_range_at(i).ch }\n \n-    /**\n-     * Given a byte position and a str, return the previous char and its position.\n-     *\n-     * This function can be used to iterate over a unicode string in reverse.\n-     *\n-     * Returns 0 for next index if called on start index 0.\n-     */\n+    /// Given a byte position and a str, return the previous char and its position.\n+    ///\n+    /// This function can be used to iterate over a unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         let mut prev = start;\n \n@@ -1737,11 +1713,9 @@ impl<'self> StrSlice<'self> for &'self str {\n         self.char_range_at_reverse(i).ch\n     }\n \n-    /**\n-     * Work with the byte buffer of a string as a byte slice.\n-     *\n-     * The byte slice does not include the null terminator.\n-     */\n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// The byte slice does not include the null terminator.\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe {\n             let mut slice = self.repr();\n@@ -1750,17 +1724,15 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /**\n-     * Returns the byte index of the first character of `self` that matches `search`\n-     *\n-     * # Return value\n-     *\n-     * `Some` containing the byte index of the last matching character\n-     * or `None` if there is no match\n-     */\n+    /// Returns the byte index of the first character of `self` that matches `search`\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n-            for self.bytes_iter().enumerate().advance |(i, b)| {\n+            for self.byte_iter().enumerate().advance |(i, b)| {\n                 if search.matches(b as char) { return Some(i) }\n             }\n         } else {\n@@ -1773,18 +1745,17 @@ impl<'self> StrSlice<'self> for &'self str {\n \n         None\n     }\n-    /**\n-     * Returns the byte index of the last character of `self` that matches `search`\n-     *\n-     * # Return value\n-     *\n-     * `Some` containing the byte index of the last matching character\n-     * or `None` if there is no match\n-     */\n+\n+    /// Returns the byte index of the last character of `self` that matches `search`\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         let mut index = self.len();\n         if search.only_ascii() {\n-            for self.bytes_rev_iter().advance |b| {\n+            for self.byte_rev_iter().advance |b| {\n                 index -= 1;\n                 if search.matches(b as char) { return Some(index); }\n             }\n@@ -1798,18 +1769,16 @@ impl<'self> StrSlice<'self> for &'self str {\n         None\n     }\n \n-    /**\n-     * Returns the byte index of the first matching substring\n-     *\n-     * # Arguments\n-     *\n-     * * `needle` - The string to search for\n-     *\n-     * # Return value\n-     *\n-     * `Some` containing the byte index of the first matching substring\n-     * or `None` if there is no match\n-     */\n+    /// Returns the byte index of the first matching substring\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `needle` - The string to search for\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the first matching substring\n+    /// or `None` if there is no match\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         if needle.is_empty() {\n             Some(0)\n@@ -1842,24 +1811,21 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /**\n-     * Retrieves the first character from a string slice and returns\n-     * it. This does not allocate a new string; instead, it returns a\n-     * slice that point one character beyond the character that was\n-     * shifted.\n-     *\n-     * # Failure\n-     *\n-     * If the string does not contain any characters\n-     */\n+    /// Retrieves the first character from a string slice and returns\n+    /// it. This does not allocate a new string; instead, it returns a\n+    /// slice that point one character beyond the character that was\n+    /// shifted.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the string does not contain any characters\n     #[inline]\n     fn slice_shift_char(&self) -> (char, &'self str) {\n         let CharRange {ch, next} = self.char_range_at(0u);\n         let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n         return (ch, next_s);\n     }\n \n-\n     /// Apply a function to each character.\n     fn map_chars(&self, ff: &fn(char) -> char) -> ~str {\n         let mut result = with_capacity(self.len());\n@@ -1902,24 +1868,21 @@ impl<'self> StrSlice<'self> for &'self str {\n         return dcol[tlen];\n     }\n \n-\n-    /**\n-     * Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-     *\n-     * Fails if `inner` is not a direct slice contained within self.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * let string = \"a\\nb\\nc\";\n-     * let mut lines = ~[];\n-     * for string.line_iter().advance |line| { lines.push(line) }\n-     *\n-     * assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-     * assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-     * assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-     * ~~~\n-     */\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// Fails if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let string = \"a\\nb\\nc\";\n+    /// let mut lines = ~[];\n+    /// for string.line_iter().advance |line| { lines.push(line) }\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ~~~\n     #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         do self.as_imm_buf |a, a_len| {\n@@ -1939,35 +1902,31 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /**\n-     * Work with the byte buffer and length of a slice.\n-     *\n-     * The given length is one byte longer than the 'official' indexable\n-     * length of the string. This is to permit probing the byte past the\n-     * indexable area for a null byte, as is the case in slices pointing\n-     * to full strings, or suffixes of them.\n-     */\n+    /// Work with the byte buffer and length of a slice.\n+    ///\n+    /// The given length is one byte longer than the 'official' indexable\n+    /// length of the string. This is to permit probing the byte past the\n+    /// indexable area for a null byte, as is the case in slices pointing\n+    /// to full strings, or suffixes of them.\n     #[inline]\n     fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n         v.as_imm_buf(f)\n     }\n \n-    /**\n-     * Work with the byte buffer of a string as a null-terminated C string.\n-     *\n-     * Allows for unsafe manipulation of strings, which is useful for foreign\n-     * interop. This is similar to `str::as_buf`, but guarantees null-termination.\n-     * If the given slice is not already null-terminated, this function will\n-     * allocate a temporary, copy the slice, null terminate it, and pass\n-     * that instead.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * let s = \"PATH\".as_c_str(|path| libc::getenv(path));\n-     * ~~~\n-     */\n+    /// Work with the byte buffer of a string as a null-terminated C string.\n+    ///\n+    /// Allows for unsafe manipulation of strings, which is useful for foreign\n+    /// interop. This is similar to `str::as_buf`, but guarantees null-termination.\n+    /// If the given slice is not already null-terminated, this function will\n+    /// allocate a temporary, copy the slice, null terminate it, and pass\n+    /// that instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let s = \"PATH\".as_c_str(|path| libc::getenv(path));\n+    /// ~~~\n     #[inline]\n     fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n         do self.as_imm_buf |buf, len| {\n@@ -1988,24 +1947,21 @@ pub trait NullTerminatedStr {\n }\n \n impl NullTerminatedStr for ~str {\n-    /**\n-     * Work with the byte buffer of a string as a byte slice.\n-     *\n-     * The byte slice does include the null terminator.\n-     */\n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// The byte slice does include the null terminator.\n     #[inline]\n     fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n         let ptr: &'a ~[u8] = unsafe { cast::transmute(self) };\n         let slice: &'a [u8] = *ptr;\n         slice\n     }\n }\n+\n impl NullTerminatedStr for @str {\n-    /**\n-     * Work with the byte buffer of a string as a byte slice.\n-     *\n-     * The byte slice does include the null terminator.\n-     */\n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// The byte slice does include the null terminator.\n     #[inline]\n     fn as_bytes_with_null<'a>(&'a self) -> &'a [u8] {\n         let ptr: &'a @[u8] = unsafe { cast::transmute(self) };\n@@ -2028,16 +1984,14 @@ pub trait OwnedStr {\n     fn capacity(&self) -> uint;\n     fn to_bytes_with_null(self) -> ~[u8];\n \n-    /**\n-     * Work with the mutable byte buffer and length of a slice.\n-     *\n-     * The given length is one byte longer than the 'official' indexable\n-     * length of the string. This is to permit probing the byte past the\n-     * indexable area for a null byte, as is the case in slices pointing\n-     * to full strings, or suffixes of them.\n-     *\n-     * Make sure any mutations to this buffer keep this string valid UTF8.\n-     */\n+    /// Work with the mutable byte buffer and length of a slice.\n+    ///\n+    /// The given length is one byte longer than the 'official' indexable\n+    /// length of the string. This is to permit probing the byte past the\n+    /// indexable area for a null byte, as is the case in slices pointing\n+    /// to full strings, or suffixes of them.\n+    ///\n+    /// Make sure any mutations to this buffer keep this string valid UTF8.\n     fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T;\n }\n \n@@ -2077,6 +2031,7 @@ impl OwnedStr for ~str {\n             raw::set_len(self, llen + rlen);\n         }\n     }\n+\n     /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n@@ -2117,13 +2072,12 @@ impl OwnedStr for ~str {\n             raw::set_len(self, new_len);\n         }\n     }\n-    /**\n-     * Remove the final character from a string and return it\n-     *\n-     * # Failure\n-     *\n-     * If the string does not contain any characters\n-     */\n+\n+    /// Remove the final character from a string and return it\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the string does not contain any characters\n     fn pop_char(&mut self) -> char {\n         let end = self.len();\n         assert!(end > 0u);\n@@ -2132,13 +2086,11 @@ impl OwnedStr for ~str {\n         return ch;\n     }\n \n-    /**\n-     * Remove the first character from a string and return it\n-     *\n-     * # Failure\n-     *\n-     * If the string does not contain any characters\n-     */\n+    /// Remove the first character from a string and return it\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the string does not contain any characters\n     fn shift_char(&mut self) -> char {\n         let CharRange {ch, next} = self.char_range_at(0u);\n         *self = self.slice(next, self.len()).to_owned();\n@@ -2162,22 +2114,20 @@ impl OwnedStr for ~str {\n         new_str\n     }\n \n-    /**\n-     * Reserves capacity for exactly `n` bytes in the given string, not including\n-     * the null terminator.\n-     *\n-     * Assuming single-byte characters, the resulting string will be large\n-     * enough to hold a string of length `n`. To account for the null terminator,\n-     * the underlying buffer will have the size `n` + 1.\n-     *\n-     * If the capacity for `s` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * s - A string\n-     * * n - The number of bytes to reserve space for\n-     */\n+    /// Reserves capacity for exactly `n` bytes in the given string, not including\n+    /// the null terminator.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`. To account for the null terminator,\n+    /// the underlying buffer will have the size `n` + 1.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n     #[inline]\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n@@ -2186,35 +2136,31 @@ impl OwnedStr for ~str {\n         }\n     }\n \n-    /**\n-     * Reserves capacity for at least `n` bytes in the given string, not including\n-     * the null terminator.\n-     *\n-     * Assuming single-byte characters, the resulting string will be large\n-     * enough to hold a string of length `n`. To account for the null terminator,\n-     * the underlying buffer will have the size `n` + 1.\n-     *\n-     * This function will over-allocate in order to amortize the allocation costs\n-     * in scenarios where the caller may need to repeatedly reserve additional\n-     * space.\n-     *\n-     * If the capacity for `s` is already equal to or greater than the requested\n-     * capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * s - A string\n-     * * n - The number of bytes to reserve space for\n-     */\n+    /// Reserves capacity for at least `n` bytes in the given string, not including\n+    /// the null terminator.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`. To account for the null terminator,\n+    /// the underlying buffer will have the size `n` + 1.\n+    ///\n+    /// This function will over-allocate in order to amortize the allocation costs\n+    /// in scenarios where the caller may need to repeatedly reserve additional\n+    /// space.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n \n-    /**\n-     * Returns the number of single-byte characters the string can hold without\n-     * reallocating\n-     */\n+    /// Returns the number of single-byte characters the string can hold without\n+    /// reallocating\n     fn capacity(&self) -> uint {\n         let buf: &~[u8] = unsafe { cast::transmute(self) };\n         let vcap = buf.capacity();\n@@ -2250,75 +2196,6 @@ impl Clone for @str {\n     }\n }\n \n-/// External iterator for a string's characters. Use with the `std::iterator`\n-/// module.\n-#[deriving(Clone)]\n-pub struct CharIterator<'self> {\n-    priv index: uint,\n-    priv string: &'self str,\n-}\n-\n-impl<'self> Iterator<char> for CharIterator<'self> {\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        if self.index < self.string.len() {\n-            let CharRange {ch, next} = self.string.char_range_at(self.index);\n-            self.index = next;\n-            Some(ch)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-/// External iterator for a string's characters in reverse order. Use\n-/// with the `std::iterator` module.\n-#[deriving(Clone)]\n-pub struct CharRevIterator<'self> {\n-    priv index: uint,\n-    priv string: &'self str,\n-}\n-\n-impl<'self> Iterator<char> for CharRevIterator<'self> {\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        if self.index > 0 {\n-            let CharRange {ch, next} = self.string.char_range_at_reverse(self.index);\n-            self.index = next;\n-            Some(ch)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// External iterator for a string's bytes. Use with the `std::iterator`\n-/// module.\n-#[deriving(Clone)]\n-pub struct BytesIterator<'self> {\n-    priv it: vec::VecIterator<'self, u8>\n-}\n-\n-impl<'self> Iterator<u8> for BytesIterator<'self> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u8> {\n-        self.it.next().map_consume(|&x| x)\n-    }\n-}\n-\n-/// External iterator for a string's bytes in reverse order. Use with\n-/// the `std::iterator` module.\n-#[deriving(Clone)]\n-pub struct BytesRevIterator<'self> {\n-    priv it: vec::RevIterator<'self, u8>\n-}\n-\n-impl<'self> Iterator<u8> for BytesRevIterator<'self> {\n-    #[inline]\n-    fn next(&mut self) -> Option<u8> {\n-        self.it.next().map_consume(|&x| x)\n-    }\n-}\n-\n impl<T: Iterator<char>> FromIterator<char, T> for ~str {\n     #[inline]\n     fn from_iterator(iterator: &mut T) -> ~str {\n@@ -2443,6 +2320,7 @@ mod tests {\n         s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n         assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n+\n     #[test]\n     fn test_append() {\n         let mut s = ~\"\";\n@@ -2536,22 +2414,6 @@ mod tests {\n         assert_eq!(\"\u534e\", data.as_slice());\n     }\n \n-    #[test]\n-    fn test_split_within() {\n-        fn t(s: &str, i: uint, u: &[~str]) {\n-            let mut v = ~[];\n-            for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n-            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n-        }\n-        t(\"\", 0, []);\n-        t(\"\", 15, []);\n-        t(\"hello\", 15, [~\"hello\"]);\n-        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n-            [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n-        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", uint::max_value,\n-            [~\"Mary had a little lamb\\nLittle lamb\"]);\n-    }\n-\n     #[test]\n     fn test_find_str() {\n         // byte positions\n@@ -3398,7 +3260,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bytes_iterator() {\n+    fn test_byte_iterator() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n@@ -3407,14 +3269,14 @@ mod tests {\n         ];\n         let mut pos = 0;\n \n-        for s.bytes_iter().advance |b| {\n+        for s.byte_iter().advance |b| {\n             assert_eq!(b, v[pos]);\n             pos += 1;\n         }\n     }\n \n     #[test]\n-    fn test_bytes_rev_iterator() {\n+    fn test_byte_rev_iterator() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n@@ -3423,12 +3285,48 @@ mod tests {\n         ];\n         let mut pos = v.len();\n \n-        for s.bytes_rev_iter().advance |b| {\n+        for s.byte_rev_iter().advance |b| {\n             pos -= 1;\n             assert_eq!(b, v[pos]);\n         }\n     }\n \n+    #[test]\n+    fn test_char_offset_iterator() {\n+        use iterator::*;\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let p = [0, 3, 6, 9, 12, 15, 18, 19, 20, 23, 24, 25, 26, 27];\n+        let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+\n+        let mut pos = 0;\n+        let mut it = s.char_offset_iter();\n+\n+        for it.advance |c| {\n+            assert_eq!(c, (p[pos], v[pos]));\n+            pos += 1;\n+        }\n+        assert_eq!(pos, v.len());\n+        assert_eq!(pos, p.len());\n+    }\n+\n+    #[test]\n+    fn test_char_offset_rev_iterator() {\n+        use iterator::*;\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let p = [27, 26, 25, 24, 23, 20, 19, 18, 15, 12, 9, 6, 3, 0];\n+        let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+\n+        let mut pos = 0;\n+        let mut it = s.char_offset_rev_iter();\n+\n+        for it.advance |c| {\n+            assert_eq!(c, (p[pos], v[pos]));\n+            pos += 1;\n+        }\n+        assert_eq!(pos, v.len());\n+        assert_eq!(pos, p.len());\n+    }\n+\n     #[test]\n     fn test_split_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n@@ -3446,6 +3344,7 @@ mod tests {\n         let split: ~[&str] = data.split_iter(|c: char| c == '\u00e4').collect();\n         assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n+\n     #[test]\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "24e48dbe139e9e4d186d11af75f4deb8ee14233e", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -115,7 +115,7 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n \n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        self.bytes_iter().all(|b| b.is_ascii())\n+        self.byte_iter().all(|b| b.is_ascii())\n     }\n }\n "}, {"sha": "e1face8a9b339f788e8c9a3194d07c2cdb2f6200", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -27,7 +27,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n             ast::expr_lit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n-                    for s.bytes_iter().advance |byte| {\n+                    for s.byte_iter().advance |byte| {\n                         bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }"}, {"sha": "c4e73dfcda5f5cabe6715fbb75983d7e2f4305f0", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";\n     let mut i: int = 0;\n-    for s.bytes_iter().advance |c| {\n+    for s.byte_iter().advance |c| {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "955e6118c830e3bcf8c1ec8772a1325fee04743f", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33fca9ffefffc982bbde860251f11b191457412/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33fca9ffefffc982bbde860251f11b191457412/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=e33fca9ffefffc982bbde860251f11b191457412", "patch": "@@ -41,7 +41,7 @@ pub fn main() {\n \n     fn check_str_eq(a: ~str, b: ~str) {\n         let mut i: int = 0;\n-        for a.bytes_iter().advance |ab| {\n+        for a.byte_iter().advance |ab| {\n             info!(i);\n             info!(ab);\n             let bb: u8 = b[i];"}]}