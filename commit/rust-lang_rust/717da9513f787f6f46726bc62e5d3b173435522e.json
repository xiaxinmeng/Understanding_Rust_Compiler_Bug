{"sha": "717da9513f787f6f46726bc62e5d3b173435522e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxN2RhOTUxM2Y3ODdmNmY0NjcyNmJjNjJlNWQzYjE3MzQzNTUyMmU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-06T18:11:26Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:38Z"}, "message": "Create \"platform-intrinsic\" ABI for SIMD/platform intrinsics.\n\nThis is purposely separate to the \"rust-intrinsic\" ABI, because these\nintrinsics are theoretically going to become stable, and should be fine\nto be independent of the compiler/language internals since they're\nintimately to the platform.", "tree": {"sha": "55bd67cfdd8f0c8b6ec444fbfbc3b7c5e6579750", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55bd67cfdd8f0c8b6ec444fbfbc3b7c5e6579750"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/717da9513f787f6f46726bc62e5d3b173435522e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/717da9513f787f6f46726bc62e5d3b173435522e", "html_url": "https://github.com/rust-lang/rust/commit/717da9513f787f6f46726bc62e5d3b173435522e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/717da9513f787f6f46726bc62e5d3b173435522e/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58891278a322f5e09ea0b9da762e37b57fc39d1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/58891278a322f5e09ea0b9da762e37b57fc39d1f", "html_url": "https://github.com/rust-lang/rust/commit/58891278a322f5e09ea0b9da762e37b57fc39d1f"}], "stats": {"total": 346, "additions": 207, "deletions": 139}, "files": [{"sha": "3f182b4d2b5bb4e40531428b80793ecab5932048", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -704,7 +704,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     }\n \n     fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n-        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic || fm.abi == abi::PlatformIntrinsic {\n             return;\n         }\n "}, {"sha": "d9e6e8c12f1e3b4d6e16c01d20a413f2047e3342", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -1501,7 +1501,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n-        if abi == abi::RustIntrinsic {\n+        if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);"}, {"sha": "523ab7b527a14e9b870230b0822a0980e8446361", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -603,6 +603,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 match bare_fn.abi {\n                     abi::Rust |\n                     abi::RustIntrinsic |\n+                    abi::PlatformIntrinsic |\n                     abi::RustCall => {\n                         return FfiUnsafe(\n                             \"found function pointer with Rust calling \\\n@@ -717,7 +718,9 @@ impl LintPass for ImproperCTypes {\n         }\n \n         match it.node {\n-            ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n+            ast::ItemForeignMod(ref nmod)\n+                if nmod.abi != abi::RustIntrinsic &&\n+                   nmod.abi != abi::PlatformIntrinsic => {\n                 for ni in &nmod.items {\n                     match ni.node {\n                         ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),"}, {"sha": "6be2bb0846463146ad71490219486f598b209e21", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -91,7 +91,7 @@ use std::collections::{HashMap, HashSet};\n use std::mem;\n use std::str;\n use std::{i8, i16, i32, i64};\n-use syntax::abi::{Rust, RustCall, RustIntrinsic, Abi};\n+use syntax::abi::{Rust, RustCall, RustIntrinsic, PlatformIntrinsic, Abi};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -671,7 +671,7 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 Rust | RustCall => {\n                     get_extern_rust_fn(ccx, t, &name[..], did)\n                 }\n-                RustIntrinsic => {\n+                RustIntrinsic | PlatformIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {"}, {"sha": "d201114fd82f97b57eb919e92e49e118ebd48f9e", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -150,7 +150,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefFn(did, _) if match expr_ty.sty {\n-                ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic,\n+                ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic ||\n+                                          f.abi == synabi::PlatformIntrinsic,\n                 _ => false\n             } => {\n                 let substs = common::node_id_substs(bcx.ccx(),\n@@ -671,7 +672,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             (d.llfn, Some(d.llself))\n         }\n         Intrinsic(node, substs) => {\n-            assert!(abi == synabi::RustIntrinsic);\n+            assert!(abi == synabi::RustIntrinsic || abi == synabi::PlatformIntrinsic);\n             assert!(dest.is_some());\n \n             let call_info = match debug_loc {\n@@ -701,7 +702,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     // Intrinsics should not become actual functions.\n     // We trans them in place in `trans_intrinsic_call`\n-    assert!(abi != synabi::RustIntrinsic);\n+    assert!(abi != synabi::RustIntrinsic && abi != synabi::PlatformIntrinsic);\n \n     let is_rust_fn = abi == synabi::Rust || abi == synabi::RustCall;\n "}, {"sha": "b316d105d0cdf7d9b7c86cb4422cbc600b41ad33", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -34,7 +34,7 @@ use middle::subst::Substs;\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n-use syntax::abi::{RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n+use syntax::abi::{PlatformIntrinsic, RustIntrinsic, Rust, RustCall, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::ast;\n@@ -81,6 +81,10 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n             // Intrinsics are emitted at the call site\n             ccx.sess().bug(\"asked to register intrinsic fn\");\n         }\n+        PlatformIntrinsic => {\n+            // Intrinsics are emitted at the call site\n+            ccx.sess().bug(\"asked to register platform intrinsic fn\");\n+        }\n \n         Rust => {\n             // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n@@ -475,7 +479,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n \n         if let ast::ForeignItemFn(ref decl, _) = foreign_item.node {\n             match foreign_mod.abi {\n-                Rust | RustIntrinsic => {}\n+                Rust | RustIntrinsic | PlatformIntrinsic => {}\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n@@ -612,7 +616,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n             ty::TyBareFn(_, ref f) => {\n-                assert!(f.abi != Rust && f.abi != RustIntrinsic);\n+                assert!(f.abi != Rust && f.abi != RustIntrinsic && f.abi != PlatformIntrinsic);\n             }\n             _ => {\n                 ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\"}, {"sha": "6527136b60294e79600063508a987fc6448bdffd", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -90,7 +90,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n \n     if let ast_map::NodeForeignItem(_) = map_node {\n-        if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n+        let abi = ccx.tcx().map.get_foreign_abi(fn_id.node);\n+        if abi != abi::RustIntrinsic && abi != abi::PlatformIntrinsic {\n             // Foreign externs don't have to be monomorphized.\n             return (get_item_val(ccx, fn_id.node), mono_ty, true);\n         }"}, {"sha": "47bdd5da1ec568ef85b2637c46492aac25ef7578", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 171, "deletions": 123, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -720,6 +720,10 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n             for item in &m.items {\n                 check_intrinsic_type(ccx, &**item);\n             }\n+        } else if m.abi == abi::PlatformIntrinsic {\n+            for item in &m.items {\n+                check_platform_intrinsic_type(ccx, &**item);\n+            }\n         } else {\n             for item in &m.items {\n                 let pty = ccx.tcx.lookup_item_type(local_def(item.id));\n@@ -5093,7 +5097,6 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n     let tcx = ccx.tcx;\n     let name = it.ident.name.as_str();\n-    let mut infer_ctxt = None;\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n@@ -5342,35 +5345,6 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                    param(ccx, 0))], tcx.types.u64),\n-            \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n-                (2, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 1))\n-            }\n-            \"simd_add\" | \"simd_sub\" | \"simd_mul\" |\n-            \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n-            \"simd_and\" | \"simd_or\" | \"simd_xor\" => {\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0))\n-            }\n-            \"simd_insert\" => (2, vec![param(ccx, 0), tcx.types.u32, param(ccx, 1)], param(ccx, 0)),\n-            \"simd_extract\" => (2, vec![param(ccx, 0), tcx.types.u32], param(ccx, 1)),\n-            \"simd_cast\" => (2, vec![param(ccx, 0)], param(ccx, 1)),\n-            name if name.starts_with(\"simd_shuffle\") => {\n-                match name[\"simd_shuffle\".len()..].parse() {\n-                    Ok(n) => {\n-                        let mut params = vec![param(ccx, 0), param(ccx, 0)];\n-                        params.extend(iter::repeat(tcx.types.u32).take(n));\n-\n-                        let ictxt = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-                        let ret = ictxt.next_ty_var();\n-                        infer_ctxt = Some(ictxt);\n-                        (2, params, ret)\n-                    }\n-                    Err(_) => {\n-                        span_err!(tcx.sess, it.span, E0439,\n-                                  \"invalid `simd_shuffle`, needs length: `{}`\", name);\n-                        return\n-                    }\n-                }\n-            }\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n@@ -5388,17 +5362,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             }\n \n             ref other => {\n-                match intrinsics::Intrinsic::find(tcx, other) {\n-                    Some(intr) => {\n-                        check_platform_intrinsic_type(ccx, intr, it);\n-                        return\n-                    }\n-                    None => {\n-                        span_err!(tcx.sess, it.span, E0093,\n-                                  \"unrecognized intrinsic function: `{}`\", *other);\n-                        return;\n-                    }\n-                }\n+                span_err!(tcx.sess, it.span, E0093,\n+                          \"unrecognized intrinsic function: `{}`\", *other);\n+                return;\n             }\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n@@ -5421,7 +5387,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n              i_n_tps, n_tps);\n     } else {\n         require_same_types(tcx,\n-                           infer_ctxt.as_ref(),\n+                           None,\n                            false,\n                            it.span,\n                            i_ty.ty,\n@@ -5434,95 +5400,177 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n }\n \n fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n-                                 expected: intrinsics::Intrinsic, it: &ast::ForeignItem) {\n+                                 it: &ast::ForeignItem) {\n+    let param = |n| {\n+        let name = token::intern(&format!(\"P{}\", n));\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+    };\n+\n     let tcx = ccx.tcx;\n     let i_ty = tcx.lookup_item_type(local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    if i_n_tps != 0 {\n-        tcx.sess.span_err(it.span,\n-                          &format!(\"intrinsic has wrong number of type parameters: \\\n-                                    found {}, expected 0\",\n-                                   i_n_tps));\n-        return\n-    }\n-\n-    let mut structural_to_nomimal = HashMap::new();\n-\n-    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n-    for (i, (expected_arg, arg)) in expected.inputs.iter().zip(&sig.inputs).enumerate() {\n-        match_types(tcx, &format!(\"argument {}\", i + 1), it.span,\n-                    &mut structural_to_nomimal, expected_arg, arg);\n-    }\n-    match_types(tcx, \"return value\", it.span, &mut structural_to_nomimal,\n-                &expected.output, sig.output.unwrap());\n-\n-    // walk the expected type and the actual type in lock step, checking they're\n-    // the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n-    // exactly the right element type\n-    fn match_types<'tcx, 'a>(tcx: &ty::ctxt<'tcx>,\n-                             position: &str,\n-                             span: Span,\n-                             structural_to_nominal: &mut HashMap<&'a intrinsics::Type,\n-                                                                 ty::Ty<'tcx>>,\n-                             expected: &'a intrinsics::Type, t: ty::Ty<'tcx>) {\n-        use intrinsics::Type::*;\n-        match *expected {\n-            Integer(bits) => match (bits, &t.sty) {\n-                (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n-                (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n-                (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n-                (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n-                _ => tcx.sess.span_err(span,\n-                                       &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                                 expected `i{n}` or `u{n}`\",\n-                                                position,\n-                                                t, n = bits)),\n-            },\n-            Float(bits) => match (bits, &t.sty) {\n-                (32, &ty::TyFloat(ast::TyF32)) |\n-                (64, &ty::TyFloat(ast::TyF64)) => {},\n-                _ => tcx.sess.span_err(span,\n-                                       &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                                 expected `f{n}`\",\n-                                                position,\n-                                                t, n = bits)),\n-            },\n-            Pointer(_) => unimplemented!(),\n-            Vector(ref inner_expected, len) => {\n-                if t.is_simd(tcx) {\n-                    let t_len = t.simd_size(tcx);\n-                    if len as usize != t_len {\n-                        tcx.sess.span_err(span,\n-                                          &format!(\"intrinsic {} has wrong type: found \\\n-                                                    vector with length {}, expected length {}\",\n-                                                   position,\n-                                                   t_len, len));\n-                        return;\n+    let name = it.ident.name.as_str();\n+    let mut infer_ctxt = None;\n+\n+    let (n_tps, inputs, output) = match &*name {\n+        \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n+            (2, vec![param(0), param(0)], param(1))\n+        }\n+        \"simd_add\" | \"simd_sub\" | \"simd_mul\" |\n+        \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n+        \"simd_and\" | \"simd_or\" | \"simd_xor\" => {\n+            (1, vec![param(0), param(0)], param(0))\n+        }\n+        \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n+        \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n+        \"simd_cast\" => (2, vec![param(0)], param(1)),\n+        name if name.starts_with(\"simd_shuffle\") => {\n+            match name[\"simd_shuffle\".len()..].parse() {\n+                Ok(n) => {\n+                    let mut params = vec![param(0), param(0)];\n+                    params.extend(iter::repeat(tcx.types.u32).take(n));\n+\n+                    let ictxt = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                    let ret = ictxt.next_ty_var();\n+                    infer_ctxt = Some(ictxt);\n+                    (2, params, ret)\n+                }\n+                Err(_) => {\n+                    span_err!(tcx.sess, it.span, E0439,\n+                              \"invalid `simd_shuffle`, needs length: `{}`\", name);\n+                    return\n+                }\n+            }\n+        }\n+        _ => {\n+            match intrinsics::Intrinsic::find(tcx, &name) {\n+                Some(intr) => {\n+                    // this function is a platform specific intrinsic\n+                    if i_n_tps != 0 {\n+                        tcx.sess.span_err(it.span,\n+                                         &format!(\"intrinsic has wrong number of type parameters: \\\n+                                                    found {}, expected 0\",\n+                                                   i_n_tps));\n+                        return\n                     }\n-                    let t_ty = t.simd_type(tcx);\n-                    {\n-                        let previous = structural_to_nominal.entry(expected).or_insert(t);\n-                        if *previous != t {\n-                            tcx.sess.span_err(span,\n-                                              &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                                        but already seen this vector type as `{}`\",\n-                                                       position, t, previous));\n-                            return;\n-                        }\n+\n+                    let mut structural_to_nomimal = HashMap::new();\n+\n+                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+                    let input_pairs = intr.inputs.iter().zip(&sig.inputs);\n+                    for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n+                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n+                                                     &mut structural_to_nomimal, expected_arg, arg);\n                     }\n-                    match_types(tcx,\n-                                position,\n-                                span,\n-                                structural_to_nominal,\n-                                inner_expected,\n-                                t_ty)\n-                } else {\n+                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n+                                                 &mut structural_to_nomimal,\n+                                                 &intr.output, sig.output.unwrap());\n+                    return\n+                }\n+                None => {\n+                    tcx.sess.span_err(it.span,\n+                                      &format!(\"unrecognized intrinsic function: `{}`\", name));\n+                    return;\n+                }\n+            }\n+        }\n+    };\n+\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi::PlatformIntrinsic,\n+        sig: ty::Binder(FnSig {\n+            inputs: inputs,\n+            output: ty::FnConverging(output),\n+            variadic: false,\n+        }),\n+    }));\n+    if i_n_tps != n_tps {\n+        span_err!(tcx.sess, it.span, E0094,\n+            \"intrinsic has wrong number of type \\\n+             parameters: found {}, expected {}\",\n+             i_n_tps, n_tps);\n+    } else {\n+        require_same_types(tcx,\n+                           infer_ctxt.as_ref(),\n+                           false,\n+                           it.span,\n+                           i_ty.ty,\n+                           fty,\n+                           || {\n+                format!(\"intrinsic has wrong type: expected `{}`\",\n+                         fty)\n+            });\n+    }\n+}\n+\n+// walk the expected type and the actual type in lock step, checking they're\n+// the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n+// exactly the right element type\n+fn match_intrinsic_type_to_type<'tcx, 'a>(\n+        tcx: &ty::ctxt<'tcx>,\n+        position: &str,\n+        span: Span,\n+        structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n+{\n+    use intrinsics::Type::*;\n+    match *expected {\n+        Integer(bits) => match (bits, &t.sty) {\n+            (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n+            (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n+            (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n+            (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n+            _ => tcx.sess.span_err(span,\n+                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                             expected `i{n}` or `u{n}`\",\n+                                            position,\n+                                            t, n = bits)),\n+        },\n+        Float(bits) => match (bits, &t.sty) {\n+            (32, &ty::TyFloat(ast::TyF32)) |\n+            (64, &ty::TyFloat(ast::TyF64)) => {},\n+            _ => tcx.sess.span_err(span,\n+                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                             expected `f{n}`\",\n+                                            position,\n+                                            t, n = bits)),\n+        },\n+        Pointer(_) => unimplemented!(),\n+        Vector(ref inner_expected, len) => {\n+            if !t.is_simd(tcx) {\n+                tcx.sess.span_err(span,\n+                                  &format!(\"intrinsic {} has wrong type: found non-simd type {}, \\\n+                                           expected simd type\",\n+                                           position, t));\n+                return;\n+            }\n+            let t_len = t.simd_size(tcx);\n+            if len as usize != t_len {\n+                tcx.sess.span_err(span,\n+                                  &format!(\"intrinsic {} has wrong type: found \\\n+                                            vector with length {}, expected length {}\",\n+                                           position,\n+                                           t_len, len));\n+                return;\n+            }\n+            let t_ty = t.simd_type(tcx);\n+            {\n+                let previous = structural_to_nominal.entry(expected).or_insert(t);\n+                if *previous != t {\n                     tcx.sess.span_err(span,\n-                                      &format!(\"intrinsic {} has wrong type: found non-simd type {}, \\\n-                                               expected simd type\",\n-                                               position, t));\n+                                      &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                                but already seen this vector type as `{}`\",\n+                                               position, t, previous));\n+                    return;\n                 }\n             }\n+            match_intrinsic_type_to_type(tcx,\n+                                         position,\n+                                         span,\n+                                         structural_to_nominal,\n+                                         inner_expected,\n+                                         t_ty)\n         }\n     }\n }"}, {"sha": "c0fe541ead510356ecd3b8e7e119ccf40c5debe0", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -47,6 +47,7 @@ pub enum Abi {\n     System,\n     RustIntrinsic,\n     RustCall,\n+    PlatformIntrinsic,\n }\n \n #[allow(non_camel_case_types)]\n@@ -95,6 +96,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: System, name: \"system\" },\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\" },\n     AbiData {abi: RustCall, name: \"rust-call\" },\n+    AbiData {abi: PlatformIntrinsic, name: \"platform-intrinsic\" }\n ];\n \n /// Returns the ABI with the given name (if any)."}, {"sha": "b0167d75bc00729802c122b732a5cf0592a79d2d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717da9513f787f6f46726bc62e5d3b173435522e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=717da9513f787f6f46726bc62e5d3b173435522e", "patch": "@@ -184,6 +184,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // Allows cfg(target_feature = \"...\").\n     (\"cfg_target_feature\", \"1.3.0\", Active),\n+\n+    // allow `extern \"platform-intrinsic\" { ... }`\n+    (\"platform_intrinsics\", \"1.4.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -694,10 +697,16 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        across platforms, it is recommended to \\\n                                        use `#[link(name = \\\"foo\\\")]` instead\")\n                 }\n-                if foreign_module.abi == Abi::RustIntrinsic {\n-                    self.gate_feature(\"intrinsics\",\n-                                      i.span,\n-                                      \"intrinsics are subject to change\")\n+                let maybe_feature = match foreign_module.abi {\n+                    Abi::RustIntrinsic => Some((\"intrinsics\", \"intrinsics are subject to change\")),\n+                    Abi::PlatformIntrinsic => {\n+                        Some((\"platform_intrinsics\",\n+                              \"platform intrinsics are experimental and possibly buggy\"))\n+                    }\n+                    _ => None\n+                };\n+                if let Some((feature, msg)) = maybe_feature {\n+                    self.gate_feature(feature, i.span, msg)\n                 }\n             }\n "}]}