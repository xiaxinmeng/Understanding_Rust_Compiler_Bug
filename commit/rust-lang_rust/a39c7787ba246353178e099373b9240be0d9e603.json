{"sha": "a39c7787ba246353178e099373b9240be0d9e603", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzOWM3Nzg3YmEyNDYzNTMxNzhlMDk5MzczYjkyNDBiZTBkOWU2MDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T01:20:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T01:20:49Z"}, "message": "Auto merge of #73486 - Manishearth:rollup-11iyqpc, r=Manishearth\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #70551 (Make all uses of ty::Error delay a span bug)\n - #71338 (Expand \"recursive opaque type\" diagnostic)\n - #71976 (Improve diagnostics for `let x += 1`)\n - #72279 (add raw_ref macros)\n - #72628 (Add tests for 'impl Default for [T; N]')\n - #72804 (Further tweak lifetime errors involving `dyn Trait` and `impl Trait` in return position)\n - #72814 (remove visit_terminator_kind from MIR visitor)\n - #72836 (Complete the std::time documentation to warn about the inconsistencies between OS)\n - #72968 (Only highlight doc search results via mouseover if mouse has moved)\n - #73034 (Export `#[inline]` fns with extern indicators)\n - #73315 (Clean up some weird command strings)\n - #73320 (Make new type param suggestion more targetted)\n - #73361 (Tweak \"non-primitive cast\" error)\n - #73425 (Mention functions pointers in the documentation)\n - #73428 (Fix typo in librustc_ast docs)\n - #73447 (Improve document for `Result::as_deref(_mut)` methods)\n - #73476 (Added tooltip for should_panic code examples)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "430bf1c2e278fb07e781e03a4a5035b6397baf82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/430bf1c2e278fb07e781e03a4a5035b6397baf82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a39c7787ba246353178e099373b9240be0d9e603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a39c7787ba246353178e099373b9240be0d9e603", "html_url": "https://github.com/rust-lang/rust/commit/a39c7787ba246353178e099373b9240be0d9e603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a39c7787ba246353178e099373b9240be0d9e603/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "036b5fec49aa5d5143b83360442400d1e83ccefa", "url": "https://api.github.com/repos/rust-lang/rust/commits/036b5fec49aa5d5143b83360442400d1e83ccefa", "html_url": "https://github.com/rust-lang/rust/commit/036b5fec49aa5d5143b83360442400d1e83ccefa"}, {"sha": "6c53a0c2b5c73a0ea0750dd6c84298ce9348ecff", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c53a0c2b5c73a0ea0750dd6c84298ce9348ecff", "html_url": "https://github.com/rust-lang/rust/commit/6c53a0c2b5c73a0ea0750dd6c84298ce9348ecff"}], "stats": {"total": 3031, "additions": 2110, "deletions": 921}, "files": [{"sha": "8ff1ced53b071840f45edad5e3c3184804fb90c2", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -374,6 +374,7 @@ pub trait Into<T>: Sized {\n /// [`Into`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n+#[rustc_diagnostic_item = \"from_trait\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(on(\n     all(_Self = \"&str\", T = \"std::string::String\"),"}, {"sha": "066bb8b3dc787a40ec00d36d7883dbcffb7a9ad6", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -581,11 +581,12 @@ pub const fn needs_drop<T>() -> bool {\n /// This means that, for example, the padding byte in `(u8, u16)` is not\n /// necessarily zeroed.\n ///\n-/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n-/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n-/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n-/// that there always is a valid value in a variable it considers initialized.\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value\n+/// of some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T`, `&mut T`) and functions pointers. Using `zeroed`\n+/// on such types causes immediate [undefined behavior][ub] because [the Rust\n+/// compiler assumes][inv] that there always is a valid value in a variable it\n+/// considers initialized.\n ///\n /// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n /// It is useful for FFI sometimes, but should generally be avoided.\n@@ -612,6 +613,7 @@ pub const fn needs_drop<T>() -> bool {\n /// use std::mem;\n ///\n /// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// let _y: fn() = unsafe { mem::zeroed() }; // And again!\n /// ```\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "172b23a8d5a26a778e6c150c4f9fdd54b3491ea2", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1399,3 +1399,70 @@ fnptr_impls_args! { A, B, C, D, E, F, G, H, I }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\n fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n+\n+/// Create a `const` raw pointer to a place, without creating an intermediate reference.\n+///\n+/// Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned\n+/// and points to initialized data. For cases where those requirements do not hold,\n+/// raw pointers should be used instead. However, `&expr as *const _` creates a reference\n+/// before casting it to a raw pointer, and that reference is subject to the same rules\n+/// as all other references. This macro can create a raw pointer *without* creating\n+/// a reference first.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(raw_ref_macros)]\n+/// use std::ptr;\n+///\n+/// #[repr(packed)]\n+/// struct Packed {\n+///     f1: u8,\n+///     f2: u16,\n+/// }\n+///\n+/// let packed = Packed { f1: 1, f2: 2 };\n+/// // `&packed.f2` would create an unaligned reference, and thus be Undefined Behavior!\n+/// let raw_f2 = ptr::raw_const!(packed.f2);\n+/// assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n+/// ```\n+#[unstable(feature = \"raw_ref_macros\", issue = \"73394\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[allow_internal_unstable(raw_ref_op)]\n+pub macro raw_const($e:expr) {\n+    &raw const $e\n+}\n+\n+/// Create a `mut` raw pointer to a place, without creating an intermediate reference.\n+///\n+/// Creating a reference with `&`/`&mut` is only allowed if the pointer is properly aligned\n+/// and points to initialized data. For cases where those requirements do not hold,\n+/// raw pointers should be used instead. However, `&mut expr as *mut _` creates a reference\n+/// before casting it to a raw pointer, and that reference is subject to the same rules\n+/// as all other references. This macro can create a raw pointer *without* creating\n+/// a reference first.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(raw_ref_macros)]\n+/// use std::ptr;\n+///\n+/// #[repr(packed)]\n+/// struct Packed {\n+///     f1: u8,\n+///     f2: u16,\n+/// }\n+///\n+/// let mut packed = Packed { f1: 1, f2: 2 };\n+/// // `&mut packed.f2` would create an unaligned reference, and thus be Undefined Behavior!\n+/// let raw_f2 = ptr::raw_mut!(packed.f2);\n+/// unsafe { raw_f2.write_unaligned(42); }\n+/// assert_eq!({packed.f2}, 42); // `{...}` forces copying the field instead of creating a reference.\n+/// ```\n+#[unstable(feature = \"raw_ref_macros\", issue = \"73394\")]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+#[allow_internal_unstable(raw_ref_op)]\n+pub macro raw_mut($e:expr) {\n+    &raw mut $e\n+}"}, {"sha": "2080ae193667e8c6945161df6102dd049c64bab5", "filename": "src/libcore/result.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1145,45 +1145,69 @@ impl<T, E: Into<!>> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T: Deref, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n-    /// `Ok` type's `Deref::Target` type.\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&str, &u32> = Ok(\"hello\");\n+    /// assert_eq!(x.as_deref(), y);\n+    ///\n+    /// let x: Result<String, u32> = Err(42);\n+    /// let y: Result<&str, &u32> = Err(&42);\n+    /// assert_eq!(x.as_deref(), y);\n+    /// ```\n     pub fn as_deref(&self) -> Result<&T::Target, &E> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T, E: Deref> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T, &E::Target>`.\n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T, &<E as Deref>::Target>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n-    /// `Err` type's `Deref::Target` type.\n+    /// Coerces the [`Err`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n+    /// and returns the new [`Result`].\n     pub fn as_deref_err(&self) -> Result<&T, &E::Target> {\n         self.as_ref().map_err(|e| e.deref())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T: DerefMut, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T::Target, &mut E>`.\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n-    /// the `Ok` type's `Deref::Target` type.\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&mut str, &mut u32> = Ok(\"HELLO\");\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    ///\n+    /// let mut x: Result<String, u32> = Err(42);\n+    /// let y: Result<&mut str, &mut u32> = Err(&42);\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    /// ```\n     pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n+#[unstable(feature = \"inner_deref\", issue = \"50264\")]\n impl<T, E: DerefMut> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T, &mut E::Target>`.\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T, &mut <E as DerefMut>::Target>`.\n     ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n-    /// the `Err` type's `Deref::Target` type.\n+    /// Coerces the [`Err`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n+    /// and returns the new [`Result`].\n     pub fn as_deref_mut_err(&mut self) -> Result<&mut T, &mut E::Target> {\n         self.as_mut().map_err(|e| e.deref_mut())\n     }"}, {"sha": "4bc44e98fc802a7efee5106bac8409c3b0cfa9e7", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -241,3 +241,52 @@ fn iterator_drops() {\n     }\n     assert_eq!(i.get(), 5);\n }\n+\n+// This test does not work on targets without panic=unwind support.\n+// To work around this problem, test is marked is should_panic, so it will\n+// be automagically skipped on unsuitable targets, such as\n+// wasm32-unknown-unkown.\n+//\n+// It means that we use panic for indicating success.\n+#[test]\n+#[should_panic(expected = \"test succeeded\")]\n+fn array_default_impl_avoids_leaks_on_panic() {\n+    use core::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+    static COUNTER: AtomicUsize = AtomicUsize::new(0);\n+    #[derive(Debug)]\n+    struct Bomb(usize);\n+\n+    impl Default for Bomb {\n+        fn default() -> Bomb {\n+            if COUNTER.load(Relaxed) == 3 {\n+                panic!(\"bomb limit exceeded\");\n+            }\n+\n+            COUNTER.fetch_add(1, Relaxed);\n+            Bomb(COUNTER.load(Relaxed))\n+        }\n+    }\n+\n+    impl Drop for Bomb {\n+        fn drop(&mut self) {\n+            COUNTER.fetch_sub(1, Relaxed);\n+        }\n+    }\n+\n+    let res = std::panic::catch_unwind(|| <[Bomb; 5]>::default());\n+    let panic_msg = match res {\n+        Ok(_) => unreachable!(),\n+        Err(p) => p.downcast::<&'static str>().unwrap(),\n+    };\n+    assert_eq!(*panic_msg, \"bomb limit exceeded\");\n+    // check that all bombs are successfully dropped\n+    assert_eq!(COUNTER.load(Relaxed), 0);\n+    panic!(\"test succeeded\")\n+}\n+\n+#[test]\n+fn empty_array_is_always_default() {\n+    struct DoesNotImplDefault;\n+\n+    let _arr = <[DoesNotImplDefault; 0]>::default();\n+}"}, {"sha": "ce186c4834d72cd60ec37a68c0780639c0015362", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -5,7 +5,7 @@\n //! additional metadata), and [`ItemKind`] (which represents a concrete type and contains\n //! information specific to the type of the item).\n //!\n-//! Other module items that worth mentioning:\n+//! Other module items worth mentioning:\n //! - [`Ty`] and [`TyKind`]: A parsed Rust type.\n //! - [`Expr`] and [`ExprKind`]: A parsed Rust expression.\n //! - [`Pat`] and [`PatKind`]: A parsed Rust pattern. Patterns are often dual to expressions."}, {"sha": "98f7da8361cc408b9041265f0e9a43dfa2bd5bf8", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -89,10 +89,12 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n                 | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n                     let def_id = tcx.hir().local_def_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n-                    if !generics.requires_monomorphization(tcx) &&\n-                        // Functions marked with #[inline] are only ever codegened\n-                        // with \"internal\" linkage and are never exported.\n-                        !Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                    if !generics.requires_monomorphization(tcx)\n+                        // Functions marked with #[inline] are codegened with \"internal\"\n+                        // linkage and are not exported unless marked with an extern\n+                        // inidicator\n+                        && (!Instance::mono(tcx, def_id.to_def_id()).def.generates_cgu_internal_copy(tcx)\n+                            || tcx.codegen_fn_attrs(def_id.to_def_id()).contains_extern_indicator())\n                     {\n                         Some(def_id)\n                     } else {"}, {"sha": "a64489c04c81dc4e07df0656f11415f4c42b2060", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -195,7 +195,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 tcx.def_key(def_id).disambiguated_data.disambiguator\n             ));\n         }\n-        ty::Error\n+        ty::Error(_)\n         | ty::Infer(_)\n         | ty::Placeholder(..)\n         | ty::Projection(..)"}, {"sha": "db935c2b3e2658a027ba7525da21a38e90146a44", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -234,8 +234,8 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         self.visit_rvalue(rvalue, location);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n-        let check = match *kind {\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        let check = match terminator.kind {\n             mir::TerminatorKind::Call { func: mir::Operand::Constant(ref c), ref args, .. } => {\n                 match c.literal.ty.kind {\n                     ty::FnDef(did, _) => Some((did, args)),\n@@ -259,7 +259,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             }\n         }\n \n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n \n     fn visit_place(&mut self, place: &mir::Place<'tcx>, context: PlaceContext, location: Location) {"}, {"sha": "c486d5c64baa27d3e120441825fd13c30f0256f5", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -998,8 +998,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.unreachable();\n             }\n \n-            mir::TerminatorKind::Drop { location, target, unwind } => {\n-                self.codegen_drop_terminator(helper, bx, location, target, unwind);\n+            mir::TerminatorKind::Drop { place, target, unwind } => {\n+                self.codegen_drop_terminator(helper, bx, place, target, unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {"}, {"sha": "99ef226f94aaeba79ba54f86f629c160374d4c44", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -439,6 +439,7 @@ E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n E0754: include_str!(\"./error_codes/E0754.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n+E0759: include_str!(\"./error_codes/E0759.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n E0761: include_str!(\"./error_codes/E0761.md\"),\n E0762: include_str!(\"./error_codes/E0762.md\"),"}, {"sha": "a74759bdf634b0c5deb874b8269468d5d2981507", "filename": "src/librustc_error_codes/error_codes/E0759.md", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_error_codes%2Ferror_codes%2FE0759.md", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_error_codes%2Ferror_codes%2FE0759.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0759.md?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,67 @@\n+A `'static` requirement in a return type involving a trait is not fulfilled.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0759\n+use std::fmt::Debug;\n+\n+fn foo(x: &i32) -> impl Debug {\n+    x\n+}\n+```\n+\n+```compile_fail,E0759\n+# use std::fmt::Debug;\n+fn bar(x: &i32) -> Box<dyn Debug> {\n+    Box::new(x)\n+}\n+```\n+\n+These examples have the same semantics as the following:\n+\n+```compile_fail,E0759\n+# use std::fmt::Debug;\n+fn foo(x: &i32) -> impl Debug + 'static {\n+    x\n+}\n+```\n+\n+```compile_fail,E0759\n+# use std::fmt::Debug;\n+fn bar(x: &i32) -> Box<dyn Debug + 'static> {\n+    Box::new(x)\n+}\n+```\n+\n+Both [`dyn Trait`] and [`impl Trait`] in return types have a an implicit\n+`'static` requirement, meaning that the value implementing them that is being\n+returned has to be either a `'static` borrow or an owned value.\n+\n+In order to change the requirement from `'static` to be a lifetime derived from\n+its arguments, you can add an explicit bound, either to an anonymous lifetime\n+`'_` or some appropriate named lifetime.\n+\n+```\n+# use std::fmt::Debug;\n+fn foo(x: &i32) -> impl Debug + '_ {\n+    x\n+}\n+fn bar(x: &i32) -> Box<dyn Debug + '_> {\n+    Box::new(x)\n+}\n+```\n+\n+These are equivalent to the following explicit lifetime annotations:\n+\n+```\n+# use std::fmt::Debug;\n+fn foo<'a>(x: &'a i32) -> impl Debug + 'a {\n+    x\n+}\n+fn bar<'a>(x: &'a i32) -> Box<dyn Debug + 'a> {\n+    Box::new(x)\n+}\n+```\n+\n+[`dyn Trait`]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n+[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits"}, {"sha": "0c1418d3cad279ebe8d806b3dd9d62af87d1d6fe", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -5,6 +5,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n+#![feature(track_caller)]\n \n pub use emitter::ColorConfig;\n \n@@ -621,6 +622,7 @@ impl Handler {\n         self.inner.borrow_mut().span_bug(span, msg)\n     }\n \n+    #[track_caller]\n     pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) {\n         self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n@@ -873,6 +875,7 @@ impl HandlerInner {\n         self.emit_diagnostic(diag.set_span(sp));\n     }\n \n+    #[track_caller]\n     fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n@@ -883,6 +886,7 @@ impl HandlerInner {\n         }\n         let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n         diagnostic.set_span(sp.into());\n+        diagnostic.note(&format!(\"delayed at {}\", std::panic::Location::caller()));\n         self.delay_as_bug(diagnostic)\n     }\n "}, {"sha": "bed2044c7085515dbef5371c87dd9e176334ae6a", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2726,6 +2726,18 @@ impl Node<'_> {\n         }\n     }\n \n+    pub fn body_id(&self) -> Option<BodyId> {\n+        match self {\n+            Node::TraitItem(TraitItem {\n+                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+                ..\n+            })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n+            | Node::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })"}, {"sha": "427cc55a428ae163846b9230c729e3383c52efa0", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -403,7 +403,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Float(..)\n             | ty::Adt(..)\n             | ty::Str\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Array(..)\n             | ty::Slice(..)\n             | ty::RawPtr(..)"}, {"sha": "2b8c46f1de42def2944d6e2af76d3b18bd56279e", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -154,7 +154,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 self.tcx\n                     .mk_const(ty::Const {\n                         val: ty::ConstKind::Placeholder(placeholder_mapped),\n-                        ty: self.tcx.types.err, // FIXME(const_generics)\n+                        ty: self.tcx.ty_error(), // FIXME(const_generics)\n                     })\n                     .into()\n             }"}, {"sha": "9cfa11dd7c813ff7ffdb2aeab7847b821fbdb939", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2035,8 +2035,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.tcx.sess,\n             var_origin.span(),\n             E0495,\n-            \"cannot infer an appropriate lifetime{} \\\n-             due to conflicting requirements\",\n+            \"cannot infer an appropriate lifetime{} due to conflicting requirements\",\n             var_description\n         )\n     }"}, {"sha": "82feebc80292a27476089da8f8cfbc7b271fdec5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 157, "deletions": 33, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,14 +1,15 @@\n //! Error Reporting for static impl Traits.\n \n-use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use rustc_errors::{Applicability, ErrorReported};\n+use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n+use rustc_hir::{GenericBound, ItemKind, Lifetime, LifetimeName, TyKind};\n use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n+        debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n         if let Some(ref error) = self.error {\n             if let RegionResolutionError::SubSupConflict(\n                 _,\n@@ -17,18 +18,36 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 sub_r,\n                 sup_origin,\n                 sup_r,\n-            ) = error.clone()\n+            ) = error\n             {\n+                debug!(\n+                    \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+                    var_origin, sub_origin, sub_r, sup_origin, sup_r\n+                );\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                let (fn_return_span, is_dyn) =\n-                    self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n-                if sub_r == &RegionKind::ReStatic {\n+                debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+                let fn_return = self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_return);\n+                if **sub_r == RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n-                    let mut err =\n-                        self.tcx().sess.struct_span_err(sp, \"cannot infer an appropriate lifetime\");\n                     let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                    err.span_label(param_info.param_ty_span, \"data with this lifetime...\");\n+                    let (lifetime_name, lifetime) = if sup_r.has_name() {\n+                        (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                    } else {\n+                        (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+                    };\n+                    let mut err = struct_span_err!(\n+                        self.tcx().sess,\n+                        sp,\n+                        E0759,\n+                        \"cannot infer an appropriate lifetime\"\n+                    );\n+                    err.span_label(\n+                        param_info.param_ty_span,\n+                        &format!(\"this data with {}...\", lifetime),\n+                    );\n+                    debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n \n                     // We try to make the output have fewer overlapping spans if possible.\n                     if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n@@ -38,41 +57,146 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n                         // Customize the spans and labels depending on their relative order so\n                         // that split sentences flow correctly.\n-                        if sup_origin.span().shrink_to_hi() <= return_sp.shrink_to_lo() {\n-                            err.span_label(sup_origin.span(), \"...is captured here...\");\n-                            err.span_label(return_sp, \"...and required to be `'static` by this\");\n+                        if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                            // Avoid the following:\n+                            //\n+                            // error: cannot infer an appropriate lifetime\n+                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                            //    |\n+                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                            //    |           ----                      ---------^-\n+                            //\n+                            // and instead show:\n+                            //\n+                            // error: cannot infer an appropriate lifetime\n+                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                            //    |\n+                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                            //    |           ----                               ^\n+                            err.span_label(\n+                                sup_origin.span(),\n+                                \"...is captured here, requiring it to live as long as `'static`\",\n+                            );\n                         } else {\n-                            err.span_label(return_sp, \"...is required to be `'static` by this...\");\n-                            err.span_label(sup_origin.span(), \"...and is captured here\");\n+                            err.span_label(sup_origin.span(), \"...is captured here...\");\n+                            if return_sp < sup_origin.span() {\n+                                err.span_note(\n+                                    return_sp,\n+                                    \"...and is required to live as long as `'static` here\",\n+                                );\n+                            } else {\n+                                err.span_label(\n+                                    return_sp,\n+                                    \"...and is required to live as long as `'static` here\",\n+                                );\n+                            }\n                         }\n                     } else {\n                         err.span_label(\n                             return_sp,\n-                            \"...is captured and required to be `'static` here\",\n+                            \"...is captured and required to live as long as `'static` here\",\n                         );\n                     }\n \n-                    let (lifetime, _) = msg_span_from_free_region(self.tcx(), sup_r);\n-\n-                    let lifetime_name =\n-                        if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n                     // only apply this suggestion onto functions with\n                     // explicit non-desugar'able return.\n-                    if fn_return_span.desugaring_kind().is_none() {\n-                        let msg = format!(\n-                            \"to permit non-static references in {} `{} Trait` value, you can add \\\n-                             an explicit bound for {}\",\n-                            if is_dyn { \"a\" } else { \"an\" },\n-                            if is_dyn { \"dyn\" } else { \"impl\" },\n-                            lifetime,\n-                        );\n+                    if fn_return.span.desugaring_kind().is_none() {\n                         // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                        err.span_suggestion_verbose(\n-                            fn_return_span.shrink_to_hi(),\n-                            &msg,\n-                            format!(\" + {}\", lifetime_name),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+\n+                        let consider = \"consider changing the\";\n+                        let declare = \"to declare that the\";\n+                        let arg = match param_info.param.pat.simple_ident() {\n+                            Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                            None => \"the argument\".to_string(),\n+                        };\n+                        let explicit =\n+                            format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                        let explicit_static =\n+                            format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                        let captures = format!(\"captures data from {}\", arg);\n+                        let add_static_bound =\n+                            \"alternatively, add an explicit `'static` bound to this reference\";\n+                        let plus_lt = format!(\" + {}\", lifetime_name);\n+                        match fn_return.kind {\n+                            TyKind::OpaqueDef(item_id, _) => {\n+                                let item = self.tcx().hir().item(item_id.id);\n+                                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                                    opaque\n+                                } else {\n+                                    err.emit();\n+                                    return Some(ErrorReported);\n+                                };\n+\n+                                if let Some(span) = opaque\n+                                    .bounds\n+                                    .iter()\n+                                    .filter_map(|arg| match arg {\n+                                        GenericBound::Outlives(Lifetime {\n+                                            name: LifetimeName::Static,\n+                                            span,\n+                                            ..\n+                                        }) => Some(*span),\n+                                        _ => None,\n+                                    })\n+                                    .next()\n+                                {\n+                                    err.span_suggestion_verbose(\n+                                        span,\n+                                        &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                                        lifetime_name,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    err.span_suggestion_verbose(\n+                                        param_info.param_ty_span,\n+                                        add_static_bound,\n+                                        param_info.param_ty.to_string(),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                } else {\n+                                    err.span_suggestion_verbose(\n+                                        fn_return.span.shrink_to_hi(),\n+                                        &format!(\n+                                            \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                            declare = declare,\n+                                            captures = captures,\n+                                            explicit = explicit,\n+                                        ),\n+                                        plus_lt,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                };\n+                            }\n+                            TyKind::TraitObject(_, lt) => match lt.name {\n+                                LifetimeName::ImplicitObjectLifetimeDefault => {\n+                                    err.span_suggestion_verbose(\n+                                        fn_return.span.shrink_to_hi(),\n+                                        &format!(\n+                                            \"{declare} trait object {captures}, {explicit}\",\n+                                            declare = declare,\n+                                            captures = captures,\n+                                            explicit = explicit,\n+                                        ),\n+                                        plus_lt,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                                _ => {\n+                                    err.span_suggestion_verbose(\n+                                        lt.span,\n+                                        &format!(\"{} trait object's {}\", consider, explicit_static),\n+                                        lifetime_name,\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    err.span_suggestion_verbose(\n+                                        param_info.param_ty_span,\n+                                        add_static_bound,\n+                                        param_info.param_ty.to_string(),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            },\n+                            _ => {}\n+                        }\n                     }\n                     err.emit();\n                     return Some(ErrorReported);"}, {"sha": "02bebe10ed04afa124c57bb82733c103d2c92b4e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Float(..)\n             | ty::Adt(..)\n             | ty::Str\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Array(..)\n             | ty::Slice(..)\n             | ty::RawPtr(..)\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ConstKind::Param(_)\n             | ty::ConstKind::Value(_)\n             | ty::ConstKind::Unevaluated(..)\n-            | ty::ConstKind::Error => {}\n+            | ty::ConstKind::Error(_) => {}\n         }\n \n         ct.super_fold_with(self)"}, {"sha": "91f4b3323f30efc82a5e2f21e3c3b73cbc221e4d", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1751,9 +1751,10 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n \n     pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n+        let err = tcx.ty_error();\n         TypeTrace {\n             cause: ObligationCause::dummy(),\n-            values: Types(ExpectedFound { expected: tcx.types.err, found: tcx.types.err }),\n+            values: Types(ExpectedFound { expected: err, found: err }),\n         }\n     }\n }"}, {"sha": "df166d21a36c3dce423913bb5beeeceb24ed9aa1", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -189,15 +189,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             match t.kind {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n-                    self.tcx().types.err\n+                    self.tcx().ty_error()\n                 }\n                 ty::Infer(ty::IntVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedIntTy(vid));\n-                    self.tcx().types.err\n+                    self.tcx().ty_error()\n                 }\n                 ty::Infer(ty::FloatVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedFloatTy(vid));\n-                    self.tcx().types.err\n+                    self.tcx().ty_error()\n                 }\n                 ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             match c.val {\n                 ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                     self.err = Some(FixupError::UnresolvedConst(vid));\n-                    return self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty: c.ty });\n+                    return self.tcx().const_error(c.ty);\n                 }\n                 ty::ConstKind::Infer(InferConst::Fresh(_)) => {\n                     bug!(\"Unexpected const in full const resolver: {:?}\", c);"}, {"sha": "90962d210b5b48198f35f9e1391bda8cf16c6aeb", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -119,9 +119,9 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 Ok(a)\n             }\n \n-            (&ty::Error, _) | (_, &ty::Error) => {\n+            (&ty::Error(_), _) | (_, &ty::Error(_)) => {\n                 infcx.set_tainted_by_errors();\n-                Ok(self.tcx().types.err)\n+                Ok(self.tcx().ty_error())\n             }\n \n             _ => {"}, {"sha": "1dd6d837d4eafdaffe1f8bdfea93591d07f78eb6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -889,7 +889,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::Param(..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)"}, {"sha": "f281c1351766350f0d907a656c5d9ab3eed2cda7", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1112,7 +1112,7 @@ pub enum TerminatorKind<'tcx> {\n     Unreachable,\n \n     /// Drop the `Place`.\n-    Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n     /// Drop the `Place` and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n@@ -1141,7 +1141,7 @@ pub enum TerminatorKind<'tcx> {\n     /// }\n     /// ```\n     DropAndReplace {\n-        location: Place<'tcx>,\n+        place: Place<'tcx>,\n         value: Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n@@ -1607,9 +1607,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Abort => write!(fmt, \"abort\"),\n             Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n             Unreachable => write!(fmt, \"unreachable\"),\n-            Drop { location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace { location, value, .. } => {\n-                write!(fmt, \"replace({:?} <- {:?})\", location, value)\n+            Drop { place, .. } => write!(fmt, \"drop({:?})\", place),\n+            DropAndReplace { place, value, .. } => {\n+                write!(fmt, \"replace({:?} <- {:?})\", place, value)\n             }\n             Call { func, args, destination, .. } => {\n                 if let Some((destination, _)) = destination {"}, {"sha": "f1c1b962ab997fbbd698cd6380083aa851240444", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -91,9 +91,9 @@ impl<'tcx> MonoItem<'tcx> {\n         match *self {\n             MonoItem::Fn(ref instance) => {\n                 let entry_def_id = tcx.entry_fn(LOCAL_CRATE).map(|(id, _)| id);\n-                // If this function isn't inlined or otherwise has explicit\n-                // linkage, then we'll be creating a globally shared version.\n-                if self.explicit_linkage(tcx).is_some()\n+                // If this function isn't inlined or otherwise has an extern\n+                // indicator, then we'll be creating a globally shared version.\n+                if tcx.codegen_fn_attrs(instance.def_id()).contains_extern_indicator()\n                     || !instance.def.generates_cgu_internal_copy(tcx)\n                     || Some(instance.def_id()) == entry_def_id.map(LocalDefId::to_def_id)\n                 {\n@@ -102,7 +102,7 @@ impl<'tcx> MonoItem<'tcx> {\n \n                 // At this point we don't have explicit linkage and we're an\n                 // inlined function. If we're inlining into all CGUs then we'll\n-                // be creating a local copy per CGU\n+                // be creating a local copy per CGU.\n                 if generate_cgu_internal_copies {\n                     return InstantiationMode::LocalCopy;\n                 }"}, {"sha": "89f8f10449e2de05d26190f3b3b9a56da37ded3d", "filename": "src/librustc_middle/mir/type_foldable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftype_foldable.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -27,11 +27,11 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 values: values.clone(),\n                 targets: targets.clone(),\n             },\n-            Drop { ref location, target, unwind } => {\n-                Drop { location: location.fold_with(folder), target, unwind }\n+            Drop { ref place, target, unwind } => {\n+                Drop { place: place.fold_with(folder), target, unwind }\n             }\n-            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n-                location: location.fold_with(folder),\n+            DropAndReplace { ref place, ref value, target, unwind } => DropAndReplace {\n+                place: place.fold_with(folder),\n                 value: value.fold_with(folder),\n                 target,\n                 unwind,\n@@ -97,9 +97,9 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             SwitchInt { ref discr, switch_ty, .. } => {\n                 discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n             }\n-            Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace { ref location, ref value, .. } => {\n-                location.visit_with(visitor) || value.visit_with(visitor)\n+            Drop { ref place, .. } => place.visit_with(visitor),\n+            DropAndReplace { ref place, ref value, .. } => {\n+                place.visit_with(visitor) || value.visit_with(visitor)\n             }\n             Yield { ref value, .. } => value.visit_with(visitor),\n             Call { ref func, ref args, ref destination, .. } => {"}, {"sha": "2efc5f1dabedca48ffe6eeb95c2b02efcc8e0f8e", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -108,12 +108,6 @@ macro_rules! make_mir_visitor {\n                 self.super_terminator(terminator, location);\n             }\n \n-            fn visit_terminator_kind(&mut self,\n-                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n-                                     location: Location) {\n-                self.super_terminator_kind(kind, location);\n-            }\n-\n             fn visit_assert_message(&mut self,\n                                     msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n@@ -417,12 +411,6 @@ macro_rules! make_mir_visitor {\n                 let Terminator { source_info, kind } = terminator;\n \n                 self.visit_source_info(source_info);\n-                self.visit_terminator_kind(kind, location);\n-            }\n-\n-            fn super_terminator_kind(&mut self,\n-                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n-                                     source_location: Location) {\n                 match kind {\n                     TerminatorKind::Goto { .. } |\n                     TerminatorKind::Resume |\n@@ -440,7 +428,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_local(\n                             & $($mutability)? local,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n-                            source_location,\n+                            location,\n                         );\n \n                         assert_eq!(\n@@ -456,34 +444,34 @@ macro_rules! make_mir_visitor {\n                         values: _,\n                         targets: _\n                     } => {\n-                        self.visit_operand(discr, source_location);\n-                        self.visit_ty(switch_ty, TyContext::Location(source_location));\n+                        self.visit_operand(discr, location);\n+                        self.visit_ty(switch_ty, TyContext::Location(location));\n                     }\n \n                     TerminatorKind::Drop {\n-                        location,\n+                        place,\n                         target: _,\n                         unwind: _,\n                     } => {\n                         self.visit_place(\n-                            location,\n+                            place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n-                            source_location\n+                            location\n                         );\n                     }\n \n                     TerminatorKind::DropAndReplace {\n-                        location,\n+                        place,\n                         value,\n                         target: _,\n                         unwind: _,\n                     } => {\n                         self.visit_place(\n-                            location,\n+                            place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n-                            source_location\n+                            location\n                         );\n-                        self.visit_operand(value, source_location);\n+                        self.visit_operand(value, location);\n                     }\n \n                     TerminatorKind::Call {\n@@ -494,15 +482,15 @@ macro_rules! make_mir_visitor {\n                         from_hir_call: _,\n                         fn_span: _\n                     } => {\n-                        self.visit_operand(func, source_location);\n+                        self.visit_operand(func, location);\n                         for arg in args {\n-                            self.visit_operand(arg, source_location);\n+                            self.visit_operand(arg, location);\n                         }\n                         if let Some((destination, _)) = destination {\n                             self.visit_place(\n                                 destination,\n                                 PlaceContext::MutatingUse(MutatingUseContext::Call),\n-                                source_location\n+                                location\n                             );\n                         }\n                     }\n@@ -514,8 +502,8 @@ macro_rules! make_mir_visitor {\n                         target: _,\n                         cleanup: _,\n                     } => {\n-                        self.visit_operand(cond, source_location);\n-                        self.visit_assert_message(msg, source_location);\n+                        self.visit_operand(cond, location);\n+                        self.visit_assert_message(msg, location);\n                     }\n \n                     TerminatorKind::Yield {\n@@ -524,11 +512,11 @@ macro_rules! make_mir_visitor {\n                         resume_arg,\n                         drop: _,\n                     } => {\n-                        self.visit_operand(value, source_location);\n+                        self.visit_operand(value, location);\n                         self.visit_place(\n                             resume_arg,\n                             PlaceContext::MutatingUse(MutatingUseContext::Yield),\n-                            source_location,\n+                            location,\n                         );\n                     }\n \n@@ -543,29 +531,29 @@ macro_rules! make_mir_visitor {\n                             match op {\n                                 InlineAsmOperand::In { value, .. }\n                                 | InlineAsmOperand::Const { value } => {\n-                                    self.visit_operand(value, source_location);\n+                                    self.visit_operand(value, location);\n                                 }\n                                 InlineAsmOperand::Out { place, .. } => {\n                                     if let Some(place) = place {\n                                         self.visit_place(\n                                             place,\n                                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                                            source_location,\n+                                            location,\n                                         );\n                                     }\n                                 }\n                                 InlineAsmOperand::InOut { in_value, out_place, .. } => {\n-                                    self.visit_operand(in_value, source_location);\n+                                    self.visit_operand(in_value, location);\n                                     if let Some(out_place) = out_place {\n                                         self.visit_place(\n                                             out_place,\n                                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                                            source_location,\n+                                            location,\n                                         );\n                                     }\n                                 }\n                                 InlineAsmOperand::SymFn { value } => {\n-                                    self.visit_constant(value, source_location);\n+                                    self.visit_constant(value, location);\n                                 }\n                                 InlineAsmOperand::SymStatic { def_id: _ } => {}\n                             }"}, {"sha": "69696ac9e93c062dbd36636b7394b39d149e3541", "filename": "src/librustc_middle/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fquery.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -221,7 +221,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Ref(..)\n         | ty::Str\n         | ty::Foreign(..)\n-        | ty::Error => true,\n+        | ty::Error(_) => true,\n \n         // [T; N] and [T] have same properties as T.\n         ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),"}, {"sha": "db9229ae3d214b8a49b410908a22acac4e5df86a", "filename": "src/librustc_middle/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2F_match.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -79,7 +79,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n                 Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n             }\n \n-            (&ty::Error, _) | (_, &ty::Error) => Ok(self.tcx().types.err),\n+            (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(self.tcx().ty_error()),\n \n             _ => relate::super_relate_tys(self, a, b),\n         }"}, {"sha": "62d6de2d71e6ddb10f6789b5a0923034bce2c795", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -46,7 +46,7 @@ use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n \n@@ -145,7 +145,6 @@ pub struct CommonTypes<'tcx> {\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n     pub self_param: Ty<'tcx>,\n-    pub err: Ty<'tcx>,\n \n     /// Dummy type used for the `Self` of a `TraitRef` created for converting\n     /// a trait object, and which gets removed in `ExistentialTraitRef`.\n@@ -803,7 +802,6 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: mk(Bool),\n             char: mk(Char),\n             never: mk(Never),\n-            err: mk(Error),\n             isize: mk(Int(ast::IntTy::Isize)),\n             i8: mk(Int(ast::IntTy::I8)),\n             i16: mk(Int(ast::IntTy::I16)),\n@@ -1142,6 +1140,31 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n+    #[track_caller]\n+    pub fn ty_error(self) -> Ty<'tcx> {\n+        self.ty_error_with_message(DUMMY_SP, \"TyKind::Error constructed but no error reported\")\n+    }\n+\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    /// ensure it gets used.\n+    #[track_caller]\n+    pub fn ty_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Ty<'tcx> {\n+        self.sess.delay_span_bug(span, msg);\n+        self.mk_ty(Error(super::sty::DelaySpanBugEmitted(())))\n+    }\n+\n+    /// Like `err` but for constants.\n+    #[track_caller]\n+    pub fn const_error(self, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+        self.sess\n+            .delay_span_bug(DUMMY_SP, \"ty::ConstKind::Error constructed but no error reported.\");\n+        self.mk_const(ty::Const {\n+            val: ty::ConstKind::Error(super::sty::DelaySpanBugEmitted(())),\n+            ty,\n+        })\n+    }\n+\n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n         let cname = self.crate_name(LOCAL_CRATE).as_str();\n         self.sess.consider_optimizing(&cname, msg)\n@@ -1382,7 +1405,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Option<(Span, bool)> {\n+    pub fn return_type_impl_or_dyn_trait(\n+        &self,\n+        scope_def_id: DefId,\n+    ) -> Option<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n@@ -1428,15 +1454,17 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let output = self.erase_late_bound_regions(&sig.output());\n                 if output.is_impl_trait() {\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n-                    Some((fn_decl.output.span(), false))\n+                    if let hir::FnRetTy::Return(ty) = fn_decl.output {\n+                        return Some(ty);\n+                    }\n                 } else {\n                     let mut v = TraitObjectVisitor(vec![]);\n                     rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n                     if v.0.len() == 1 {\n-                        return Some((v.0[0], true));\n+                        return Some(v.0[0]);\n                     }\n-                    None\n                 }\n+                None\n             }\n             _ => None,\n         }\n@@ -1845,7 +1873,7 @@ macro_rules! sty_debug_print {\n                     let variant = match t.kind {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n-                        ty::Error => /* unimportant */ continue,\n+                        ty::Error(_) => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n                     let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);"}, {"sha": "a2812e117ed39571f9e7e154bfdf27c4f1237143", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -236,21 +236,24 @@ pub fn suggest_constraining_type_param(\n     }\n }\n \n-pub struct TraitObjectVisitor(pub Vec<rustc_span::Span>);\n-impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor {\n+pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>);\n+impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     type Map = rustc_hir::intravisit::ErasedMap<'v>;\n \n     fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n         hir::intravisit::NestedVisitorMap::None\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+    fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n         if let hir::TyKind::TraitObject(\n             _,\n-            hir::Lifetime { name: hir::LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+            hir::Lifetime {\n+                name: hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n+                ..\n+            },\n         ) = ty.kind\n         {\n-            self.0.push(ty.span);\n+            self.0.push(ty);\n         }\n     }\n }"}, {"sha": "6113359ca93a72787597bd7ce95eb02757779d6c", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -286,14 +286,14 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Projection(_) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n-            ty::Error => \"type error\".into(),\n+            ty::Error(_) => \"type error\".into(),\n         }\n     }\n \n     pub fn prefix_string(&self) -> Cow<'static, str> {\n         match self.kind {\n             ty::Infer(_)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Bool\n             | ty::Char\n             | ty::Int(_)"}, {"sha": "b0fb179b18bdfbaecc242c11802e45c46843b99f", "filename": "src/librustc_middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -104,7 +104,7 @@ pub fn simplify_type(\n         }\n         ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error => None,\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n     }\n }\n "}, {"sha": "bee42be8a5388912e758d69499f9399a163b77ae", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -70,7 +70,7 @@ impl FlagComputation {\n             | &ty::Str\n             | &ty::Foreign(..) => {}\n \n-            &ty::Error => self.add_flags(TypeFlags::HAS_ERROR),\n+            &ty::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n \n             &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_TY_PARAM);\n@@ -227,7 +227,7 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Value(_) => {}\n-            ty::ConstKind::Error => self.add_flags(TypeFlags::HAS_ERROR),\n+            ty::ConstKind::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n         }\n     }\n "}, {"sha": "d58ebdc8dfc4d08789e1337b67e894d26a61d696", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1245,7 +1245,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n \n-            ty::Param(_) | ty::Error => {\n+            ty::Param(_) | ty::Error(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n         })\n@@ -2141,7 +2141,7 @@ where\n             | ty::Opaque(..)\n             | ty::Param(_)\n             | ty::Infer(_)\n-            | ty::Error => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n+            | ty::Error(_) => bug!(\"TyAndLayout::field_type: unexpected type `{}`\", this.ty),\n         })\n     }\n "}, {"sha": "1a8693b8df711fa0f7e69513604607813260b4ea", "filename": "src/librustc_middle/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Foutlives.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -171,7 +171,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n             ty::Dynamic(..) |     // OutlivesObject, OutlivesFragment (*)\n             ty::Placeholder(..) |\n             ty::Bound(..) |\n-            ty::Error => {\n+            ty::Error(_) => {\n                 // (*) Function pointers and trait objects are both binders.\n                 // In the RFC, this means we would add the bound regions to\n                 // the \"bound regions list\".  In our representation, no such"}, {"sha": "6c8f23c139f6ecf6b6ca579d06c41dceb86c18dc", "filename": "src/librustc_middle/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -298,7 +298,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         | ty::Opaque(..)\n         | ty::Infer(_)\n         | ty::Bound(..)\n-        | ty::Error\n+        | ty::Error(_)\n         | ty::GeneratorWitness(..)\n         | ty::Never\n         | ty::Float(_) => None,"}, {"sha": "67b6433b6114327e31737dd164bc38d72d1253a5", "filename": "src/librustc_middle/ty/print/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fobsolete.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -144,7 +144,7 @@ impl DefPathBasedNames<'tcx> {\n                 let substs = substs.truncate_to(self.tcx, generics);\n                 self.push_generic_params(substs, iter::empty(), output, debug);\n             }\n-            ty::Error\n+            ty::Error(_)\n             | ty::Bound(..)\n             | ty::Infer(_)\n             | ty::Placeholder(..)"}, {"sha": "17203fcce5e59e7583e6e3f329bdb55035b6e8e2", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -518,7 +518,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}\", infer_ty))\n                 }\n             }\n-            ty::Error => p!(write(\"[type error]\")),\n+            ty::Error(_) => p!(write(\"[type error]\")),\n             ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n                 ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n@@ -919,7 +919,7 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::ConstKind::Error => p!(write(\"[const error]\")),\n+            ty::ConstKind::Error(_) => p!(write(\"[const error]\")),\n         };\n         Ok(self)\n     }"}, {"sha": "0a0ff101b52032fcf2066e08b35800b1c600aaf8", "filename": "src/librustc_middle/ty/query/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fvalues.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -17,7 +17,7 @@ impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n-        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.types.err) }\n+        unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n     }\n }\n \n@@ -33,7 +33,7 @@ impl<'tcx> Value<'tcx> for AdtSizedConstraint<'_> {\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n             std::mem::transmute::<AdtSizedConstraint<'tcx>, AdtSizedConstraint<'_>>(\n-                AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err])),\n+                AdtSizedConstraint(tcx.intern_type_list(&[tcx.ty_error()])),\n             )\n         }\n     }"}, {"sha": "14cddd11c438d813d7ca81dda150f71ef5fc5e0a", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -354,7 +354,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             bug!(\"bound types encountered in super_relate_tys\")\n         }\n \n-        (&ty::Error, _) | (_, &ty::Error) => Ok(tcx.types.err),\n+        (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(tcx.ty_error()),\n \n         (&ty::Never, _)\n         | (&ty::Char, _)\n@@ -524,7 +524,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n \n-        (ty::ConstKind::Error, _) | (_, ty::ConstKind::Error) => Ok(ty::ConstKind::Error),\n+        (ty::ConstKind::Error(d), _) | (_, ty::ConstKind::Error(d)) => Ok(ty::ConstKind::Error(d)),\n \n         (ty::ConstKind::Param(a_p), ty::ConstKind::Param(b_p)) if a_p.index == b_p.index => {\n             return Ok(a);"}, {"sha": "f04d31601ea5b5a8e0310d77ccdb1590a282dfed", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -911,7 +911,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Int(_)\n             | ty::Uint(_)\n             | ty::Float(_)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Infer(_)\n             | ty::Param(..)\n             | ty::Bound(..)\n@@ -952,7 +952,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Int(_)\n             | ty::Uint(_)\n             | ty::Float(_)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Infer(_)\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n@@ -1051,7 +1051,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n-            | ty::ConstKind::Error => *self,\n+            | ty::ConstKind::Error(_) => *self,\n         }\n     }\n \n@@ -1063,7 +1063,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(_)\n-            | ty::ConstKind::Error => false,\n+            | ty::ConstKind::Error(_) => false,\n         }\n     }\n }"}, {"sha": "cf11adb0285ac3ad38837dd373426e4f5b4a8127", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -203,9 +203,15 @@ pub enum TyKind<'tcx> {\n \n     /// A placeholder for a type which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error,\n+    Error(DelaySpanBugEmitted),\n }\n \n+/// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n+/// except through `tcx.err*()`.\n+#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub struct DelaySpanBugEmitted(pub(super) ());\n+\n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TyKind<'_>, 24);\n@@ -1984,7 +1990,7 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n         match self.kind {\n-            Param(_) | Infer(_) | Error => false,\n+            Param(_) | Infer(_) | Error(_) => false,\n             _ => true,\n         }\n     }\n@@ -2016,7 +2022,7 @@ impl<'tcx> TyS<'tcx> {\n         match self.kind {\n             FnDef(def_id, substs) => tcx.fn_sig(def_id).subst(tcx, substs),\n             FnPtr(f) => f,\n-            Error => {\n+            Error(_) => {\n                 // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n             }\n@@ -2140,7 +2146,7 @@ impl<'tcx> TyS<'tcx> {\n             // closure type is not yet known\n             Bound(..) | Infer(_) => None,\n \n-            Error => Some(ty::ClosureKind::Fn),\n+            Error(_) => Some(ty::ClosureKind::Fn),\n \n             _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n         }\n@@ -2167,7 +2173,7 @@ impl<'tcx> TyS<'tcx> {\n             | ty::Array(..)\n             | ty::Closure(..)\n             | ty::Never\n-            | ty::Error => true,\n+            | ty::Error(_) => true,\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => false,\n \n@@ -2372,9 +2378,7 @@ impl<'tcx> Const<'tcx> {\n                 // can leak through `val` into the const we return.\n                 Ok(val) => Const::from_value(tcx, val, self.ty),\n                 Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => self,\n-                Err(ErrorHandled::Reported(ErrorReported)) => {\n-                    tcx.mk_const(ty::Const { val: ty::ConstKind::Error, ty: self.ty })\n-                }\n+                Err(ErrorHandled::Reported(ErrorReported)) => tcx.const_error(self.ty),\n             }\n         } else {\n             self\n@@ -2434,7 +2438,7 @@ pub enum ConstKind<'tcx> {\n \n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    Error,\n+    Error(DelaySpanBugEmitted),\n }\n \n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "47110be53b2521ad09b296e7ecf5793122054996", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -176,7 +176,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let ty::Adt(def, substs) = ty.kind {\n             for field in def.all_fields() {\n                 let field_ty = field.ty(self, substs);\n-                if let Error = field_ty.kind {\n+                if let Error(_) = field_ty.kind {\n                     return true;\n                 }\n             }\n@@ -731,7 +731,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::Ref(..)\n             | ty::RawPtr(_)\n             | ty::FnDef(..)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::FnPtr(_) => true,\n             ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_freeze),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n@@ -826,7 +826,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             // called for known, fully-monomorphized types.\n             Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n \n-            Foreign(_) | GeneratorWitness(..) | Error => false,\n+            Foreign(_) | GeneratorWitness(..) | Error(_) => false,\n         }\n     }\n \n@@ -1109,7 +1109,7 @@ pub fn needs_drop_components(\n         // Foreign types can never have destructors.\n         ty::Foreign(..) => Ok(SmallVec::new()),\n \n-        ty::Dynamic(..) | ty::Error => Err(AlwaysRequiresDrop),\n+        ty::Dynamic(..) | ty::Error(_) => Err(AlwaysRequiresDrop),\n \n         ty::Slice(ty) => needs_drop_components(ty, target_layout),\n         ty::Array(elem_ty, size) => {"}, {"sha": "d6f504fdb338bff1e68880aa7d2e48b2b2569eab", "filename": "src/librustc_middle/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_middle%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fwalk.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -108,7 +108,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             | ty::Infer(_)\n             | ty::Param(_)\n             | ty::Never\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Foreign(..) => {}\n@@ -171,7 +171,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Placeholder(_)\n                 | ty::ConstKind::Bound(..)\n                 | ty::ConstKind::Value(_)\n-                | ty::ConstKind::Error => {}\n+                | ty::ConstKind::Error(_) => {}\n \n                 ty::ConstKind::Unevaluated(_, substs, _) => {\n                     stack.extend(substs.iter().rev());"}, {"sha": "fd8f17718e795b48f5bacc0e569eb8e8932bf9e2", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{BasicBlock, Body, Location, Place, Rvalue};\n use rustc_middle::mir::{BorrowKind, Mutability, Operand};\n-use rustc_middle::mir::{InlineAsmOperand, TerminatorKind};\n+use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{Statement, StatementKind};\n use rustc_middle::ty::TyCtxt;\n \n@@ -112,14 +112,14 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.super_statement(statement, location);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         self.check_activations(location);\n \n-        match kind {\n+        match &terminator.kind {\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n-            TerminatorKind::Drop { location: drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n                 self.access_place(\n                     location,\n                     *drop_place,\n@@ -128,7 +128,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: drop_place,\n+                place: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,\n@@ -222,7 +222,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n         }\n \n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n }\n "}, {"sha": "83691d439eb81c983dc1af5da94f01eb310ce4c2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -663,7 +663,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n-            TerminatorKind::Drop { location: ref drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place: ref drop_place, target: _, unwind: _ } => {\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n@@ -692,7 +692,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n-                location: drop_place,\n+                place: drop_place,\n                 value: ref new_value,\n                 target: _,\n                 unwind: _,"}, {"sha": "beee31812563ed4d536ea5abd4b58fb81222a767", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -264,7 +264,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                             .tcx\n                             .sess\n                             .delay_span_bug(DUMMY_SP, &format!(\"failed to normalize {:?}\", ty));\n-                        (self.infcx.tcx.types.err, None)\n+                        (self.infcx.tcx.ty_error(), None)\n                     });\n                 let constraints2 = self.add_implied_bounds(ty);\n                 normalized_inputs_and_output.push(ty);"}, {"sha": "0e35cafb9f3e928a7a29dd39a2c76161a24345cc", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             if place_ty.variant_index.is_none() {\n                 if place_ty.ty.references_error() {\n                     assert!(self.errors_reported);\n-                    return PlaceTy::from_ty(self.tcx().types.err);\n+                    return PlaceTy::from_ty(self.tcx().ty_error());\n                 }\n             }\n             place_ty = self.sanitize_projection(place_ty, elem, place, location)\n@@ -725,7 +725,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n     fn error(&mut self) -> Ty<'tcx> {\n         self.errors_reported = true;\n-        self.tcx().types.err\n+        self.tcx().ty_error()\n     }\n \n     fn field_ty(\n@@ -1558,8 +1558,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { ref location, ref value, target: _, unwind: _ } => {\n-                let place_ty = location.ty(body, tcx).ty;\n+            TerminatorKind::DropAndReplace { ref place, ref value, target: _, unwind: _ } => {\n+                let place_ty = place.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n                 let locations = term_location.to_locations();"}, {"sha": "e027056842db97d20cf69c0109df7def59377a78", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,5 +1,7 @@\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n-use rustc_middle::mir::{Local, Location, Place, Statement, StatementKind, TerminatorKind};\n+use rustc_middle::mir::{\n+    Local, Location, Place, Statement, StatementKind, Terminator, TerminatorKind,\n+};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -62,20 +64,22 @@ impl GatherUsedMutsVisitor<'_, '_, '_> {\n }\n \n impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n-    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, _location: Location) {\n-        debug!(\"visit_terminator_kind: kind={:?}\", kind);\n-        match &kind {\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        debug!(\"visit_terminator: terminator={:?}\", terminator);\n+        match &terminator.kind {\n             TerminatorKind::Call { destination: Some((into, _)), .. } => {\n                 self.remove_never_initialized_mut_locals(*into);\n             }\n-            TerminatorKind::DropAndReplace { location, .. } => {\n-                self.remove_never_initialized_mut_locals(*location);\n+            TerminatorKind::DropAndReplace { place, .. } => {\n+                self.remove_never_initialized_mut_locals(*place);\n             }\n             _ => {}\n         }\n+\n+        self.super_terminator(terminator, location);\n     }\n \n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         if let StatementKind::Assign(box (into, _)) = &statement.kind {\n             debug!(\n                 \"visit_statement: statement={:?} local={:?} \\\n@@ -84,6 +88,8 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n             );\n             self.remove_never_initialized_mut_locals(*into);\n         }\n+\n+        self.super_statement(statement, location);\n     }\n \n     fn visit_local(&mut self, local: &Local, place_context: PlaceContext, location: Location) {"}, {"sha": "4512ae96c0833f24d7af72180987e40b10d58fe0", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -441,8 +441,8 @@ impl Direction for Forward {\n             Goto { target } => propagate(target, exit_state),\n \n             Assert { target, cleanup: unwind, expected: _, msg: _, cond: _ }\n-            | Drop { target, unwind, location: _ }\n-            | DropAndReplace { target, unwind, value: _, location: _ }\n+            | Drop { target, unwind, place: _ }\n+            | DropAndReplace { target, unwind, value: _, place: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n                 if let Some(unwind) = unwind {\n                     if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {"}, {"sha": "70c916a089270dd108cbddfb72dfad01e478a591", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -189,8 +189,8 @@ where\n         self.super_terminator(terminator, location);\n \n         match terminator.kind {\n-            mir::TerminatorKind::Drop { location: dropped_place, .. }\n-            | mir::TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. }\n+            | mir::TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // See documentation for `unsound_ignore_borrow_on_drop` for an explanation.\n                 if !self.ignore_borrow_on_drop {\n                     self.trans.gen(dropped_place.local);"}, {"sha": "7c8aa1db71ff873f56ff15d916a1ff14e138b87b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -387,13 +387,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n \n-            TerminatorKind::Drop { location, target: _, unwind: _ } => {\n-                self.gather_move(location);\n+            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n+                self.gather_move(place);\n             }\n-            TerminatorKind::DropAndReplace { location, ref value, .. } => {\n-                self.create_move_path(location);\n+            TerminatorKind::DropAndReplace { place, ref value, .. } => {\n+                self.create_move_path(place);\n                 self.gather_operand(value);\n-                self.gather_init(location.as_ref(), InitKind::Deep);\n+                self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n             TerminatorKind::Call {\n                 ref func,"}, {"sha": "379117f3b846a26135307518fd57b5e90267f7f8", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             | ty::Dynamic(_, _) => self.pretty_print_type(ty),\n \n             // Placeholders (all printed as `_` to uniformize them).\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => {\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => {\n                 write!(self, \"_\")?;\n                 Ok(self)\n             }"}, {"sha": "0cb878a49dcf1d59c2d9d519eb89abc78eea48dd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -527,7 +527,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         let val_val = match val.val {\n             ty::ConstKind::Param(_) => throw_inval!(TooGeneric),\n-            ty::ConstKind::Error => throw_inval!(TypeckError(ErrorReported)),\n+            ty::ConstKind::Error(_) => throw_inval!(TypeckError(ErrorReported)),\n             ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 // We use `const_eval` here and `const_eval_raw` elsewhere in mir interpretation."}, {"sha": "1d57fce39734e9119c93f8cf8a21030a00fca6d7", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -91,10 +91,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Drop { location, target, unwind } => {\n-                let place = self.eval_place(location)?;\n+            Drop { place, target, unwind } => {\n+                let place = self.eval_place(place)?;\n                 let ty = place.layout.ty;\n-                trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n+                trace!(\"TerminatorKind::drop: {:?}, type {}\", place, ty);\n \n                 let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_in_place(place, instance, target, unwind)?;"}, {"sha": "999f2fe76b4dae6cf7d49982e26f847e12228c86", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -561,7 +561,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Generator(..) => Ok(false),\n             // Some types only occur during typechecking, they have no layout.\n             // We should not see them here and we could not check them anyway.\n-            ty::Error\n+            ty::Error(_)\n             | ty::Infer(..)\n             | ty::Placeholder(..)\n             | ty::Bound(..)"}, {"sha": "36f3947d8301711dabb4f7b99223193c9e474735", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -624,19 +624,19 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_const(constant);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n-        debug!(\"visiting terminator {:?} @ {:?}\", kind, location);\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        debug!(\"visiting terminator {:?} @ {:?}\", terminator, location);\n \n         let tcx = self.tcx;\n-        match *kind {\n+        match terminator.kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.body, tcx);\n                 let callee_ty = self.monomorphize(callee_ty);\n                 visit_fn_use(self.tcx, callee_ty, true, &mut self.output);\n             }\n-            mir::TerminatorKind::Drop { ref location, .. }\n-            | mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.body, self.tcx).ty;\n+            mir::TerminatorKind::Drop { ref place, .. }\n+            | mir::TerminatorKind::DropAndReplace { ref place, .. } => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n                 let ty = self.monomorphize(ty);\n                 visit_drop_use(self.tcx, ty, true, self.output);\n             }\n@@ -671,7 +671,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             | mir::TerminatorKind::FalseUnwind { .. } => bug!(),\n         }\n \n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n \n     fn visit_local("}, {"sha": "71fff851531414be7586b3e03cd2fea759685203", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -582,7 +582,7 @@ impl CloneShimBuilder<'tcx> {\n         self.block(\n             vec![],\n             TerminatorKind::Drop {\n-                location: self.tcx.mk_place_index(dest, beg),\n+                place: self.tcx.mk_place_index(dest, beg),\n                 target: BasicBlock::new(8),\n                 unwind: None,\n             },\n@@ -634,7 +634,7 @@ impl CloneShimBuilder<'tcx> {\n                 self.block(\n                     vec![],\n                     TerminatorKind::Drop {\n-                        location: previous_field,\n+                        place: previous_field,\n                         target: previous_cleanup,\n                         unwind: None,\n                     },\n@@ -799,11 +799,7 @@ fn build_call_shim<'tcx>(\n         block(\n             &mut blocks,\n             vec![],\n-            TerminatorKind::Drop {\n-                location: rcvr_place(),\n-                target: BasicBlock::new(2),\n-                unwind: None,\n-            },\n+            TerminatorKind::Drop { place: rcvr_place(), target: BasicBlock::new(2), unwind: None },\n             false,\n         );\n     }\n@@ -814,11 +810,7 @@ fn build_call_shim<'tcx>(\n         block(\n             &mut blocks,\n             vec![],\n-            TerminatorKind::Drop {\n-                location: rcvr_place(),\n-                target: BasicBlock::new(4),\n-                unwind: None,\n-            },\n+            TerminatorKind::Drop { place: rcvr_place(), target: BasicBlock::new(4), unwind: None },\n             true,\n         );\n "}, {"sha": "a02d0f655600d9db337171f54348b88e702083dd", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -64,8 +64,8 @@ fn add_moves_for_packed_drops_patch<'tcx>(\n         let terminator = data.terminator();\n \n         match terminator.kind {\n-            TerminatorKind::Drop { location, .. }\n-                if util::is_disaligned(tcx, body, param_env, location) =>\n+            TerminatorKind::Drop { place, .. }\n+                if util::is_disaligned(tcx, body, param_env, place) =>\n             {\n                 add_move_for_packed_drop(tcx, body, &mut patch, terminator, loc, data.is_cleanup);\n             }\n@@ -88,13 +88,13 @@ fn add_move_for_packed_drop<'tcx>(\n     is_cleanup: bool,\n ) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n-    let (location, target, unwind) = match terminator.kind {\n-        TerminatorKind::Drop { ref location, target, unwind } => (location, target, unwind),\n+    let (place, target, unwind) = match terminator.kind {\n+        TerminatorKind::Drop { ref place, target, unwind } => (place, target, unwind),\n         _ => unreachable!(),\n     };\n \n     let source_info = terminator.source_info;\n-    let ty = location.ty(body, tcx).ty;\n+    let ty = place.ty(body, tcx).ty;\n     let temp = patch.new_temp(ty, terminator.source_info.span);\n \n     let storage_dead_block = patch.new_block(BasicBlockData {\n@@ -104,9 +104,9 @@ fn add_move_for_packed_drop<'tcx>(\n     });\n \n     patch.add_statement(loc, StatementKind::StorageLive(temp));\n-    patch.add_assign(loc, Place::from(temp), Rvalue::Use(Operand::Move(*location)));\n+    patch.add_assign(loc, Place::from(temp), Rvalue::Use(Operand::Move(*place)));\n     patch.patch_terminator(\n         loc.block,\n-        TerminatorKind::Drop { location: Place::from(temp), target: storage_dead_block, unwind },\n+        TerminatorKind::Drop { place: Place::from(temp), target: storage_dead_block, unwind },\n     );\n }"}, {"sha": "124606fb423e61c164aee58662215ad4128a2fee", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -78,7 +78,7 @@ impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n         trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n \n         match &terminator.kind {\n-            mir::TerminatorKind::Drop { location: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. } => {\n                 let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n                 if !NeedsDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n                     return;"}, {"sha": "b8104292aab23cf47c8d76181b352ce8abb08c29", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -121,25 +121,25 @@ where\n         self.super_assign(place, rvalue, location);\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         // The effect of assignment to the return place in `TerminatorKind::Call` is not applied\n         // here; that occurs in `apply_call_return_effect`.\n \n-        if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n+        if let mir::TerminatorKind::DropAndReplace { value, place, .. } = &terminator.kind {\n             let qualif = qualifs::in_operand::<Q, _>(\n                 self.ccx,\n                 &mut |l| self.qualifs_per_local.contains(l),\n                 value,\n             );\n \n-            if !dest.is_indirect() {\n-                self.assign_qualif_direct(dest, qualif);\n+            if !place.is_indirect() {\n+                self.assign_qualif_direct(place, qualif);\n             }\n         }\n \n         // We need to assign qualifs to the dropped location before visiting the operand that\n         // replaces it since qualifs can be cleared on move.\n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n }\n "}, {"sha": "35a8df62cb83a967620c92d4fa1482dfddfd9bcb", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -560,8 +560,8 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n             // Forbid all `Drop` terminators unless the place being dropped is a local with no\n             // projections that cannot be `NeedsDrop`.\n-            TerminatorKind::Drop { location: dropped_place, .. }\n-            | TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+            TerminatorKind::Drop { place: dropped_place, .. }\n+            | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // If we are checking live drops after drop-elaboration, don't emit duplicate\n                 // errors here.\n                 if super::post_drop_elaboration::checking_enabled(self.tcx) {"}, {"sha": "1704d8baabdc8c24a617498e5e7c938be844fbca", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -85,15 +85,15 @@ fn find_dead_unwinds<'tcx>(\n         .iterate_to_fixpoint()\n         .into_results_cursor(body);\n     for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n-        let location = match bb_data.terminator().kind {\n-            TerminatorKind::Drop { ref location, unwind: Some(_), .. }\n-            | TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => location,\n+        let place = match bb_data.terminator().kind {\n+            TerminatorKind::Drop { ref place, unwind: Some(_), .. }\n+            | TerminatorKind::DropAndReplace { ref place, unwind: Some(_), .. } => place,\n             _ => continue,\n         };\n \n         debug!(\"find_dead_unwinds @ {:?}: {:?}\", bb, bb_data);\n \n-        let path = match env.move_data.rev_lookup.find(location.as_ref()) {\n+        let path = match env.move_data.rev_lookup.find(place.as_ref()) {\n             LookupResult::Exact(e) => e,\n             LookupResult::Parent(..) => {\n                 debug!(\"find_dead_unwinds: has parent; skipping\");\n@@ -105,7 +105,7 @@ fn find_dead_unwinds<'tcx>(\n         debug!(\n             \"find_dead_unwinds @ {:?}: path({:?})={:?}; init_data={:?}\",\n             bb,\n-            location,\n+            place,\n             path,\n             flow_inits.get()\n         );\n@@ -294,16 +294,16 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn collect_drop_flags(&mut self) {\n         for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             let terminator = data.terminator();\n-            let location = match terminator.kind {\n-                TerminatorKind::Drop { ref location, .. }\n-                | TerminatorKind::DropAndReplace { ref location, .. } => location,\n+            let place = match terminator.kind {\n+                TerminatorKind::Drop { ref place, .. }\n+                | TerminatorKind::DropAndReplace { ref place, .. } => place,\n                 _ => continue,\n             };\n \n             self.init_data.seek_before(self.body.terminator_loc(bb));\n \n-            let path = self.move_data().rev_lookup.find(location.as_ref());\n-            debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\", bb, location, path);\n+            let path = self.move_data().rev_lookup.find(place.as_ref());\n+            debug!(\"collect_drop_flags: {:?}, place {:?} ({:?})\", bb, place, path);\n \n             let path = match path {\n                 LookupResult::Exact(e) => e,\n@@ -315,7 +315,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             terminator.source_info.span,\n                             \"drop of untracked, uninitialized value {:?}, place {:?} ({:?})\",\n                             bb,\n-                            location,\n+                            place,\n                             path\n                         );\n                     }\n@@ -328,7 +328,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\n                     \"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n                     child,\n-                    location,\n+                    place,\n                     path,\n                     (maybe_live, maybe_dead)\n                 );\n@@ -346,13 +346,13 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n             let resume_block = self.patch.resume_block();\n             match terminator.kind {\n-                TerminatorKind::Drop { location, target, unwind } => {\n+                TerminatorKind::Drop { place, target, unwind } => {\n                     self.init_data.seek_before(loc);\n-                    match self.move_data().rev_lookup.find(location.as_ref()) {\n+                    match self.move_data().rev_lookup.find(place.as_ref()) {\n                         LookupResult::Exact(path) => elaborate_drop(\n                             &mut Elaborator { ctxt: self },\n                             terminator.source_info,\n-                            location,\n+                            place,\n                             path,\n                             target,\n                             if data.is_cleanup {\n@@ -371,10 +371,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         }\n                     }\n                 }\n-                TerminatorKind::DropAndReplace { location, ref value, target, unwind } => {\n+                TerminatorKind::DropAndReplace { place, ref value, target, unwind } => {\n                     assert!(!data.is_cleanup);\n \n-                    self.elaborate_replace(loc, location, value, target, unwind);\n+                    self.elaborate_replace(loc, place, value, target, unwind);\n                 }\n                 _ => continue,\n             }\n@@ -396,7 +396,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn elaborate_replace(\n         &mut self,\n         loc: Location,\n-        location: Place<'tcx>,\n+        place: Place<'tcx>,\n         value: &Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n@@ -407,7 +407,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n-            kind: StatementKind::Assign(box (location, Rvalue::Use(value.clone()))),\n+            kind: StatementKind::Assign(box (place, Rvalue::Use(value.clone()))),\n             source_info: terminator.source_info,\n         };\n \n@@ -427,14 +427,14 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             is_cleanup: false,\n         });\n \n-        match self.move_data().rev_lookup.find(location.as_ref()) {\n+        match self.move_data().rev_lookup.find(place.as_ref()) {\n             LookupResult::Exact(path) => {\n                 debug!(\"elaborate_drop_and_replace({:?}) - tracked {:?}\", terminator, path);\n                 self.init_data.seek_before(loc);\n                 elaborate_drop(\n                     &mut Elaborator { ctxt: self },\n                     terminator.source_info,\n-                    location,\n+                    place,\n                     path,\n                     target,\n                     Unwind::To(unwind),\n@@ -459,7 +459,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\"elaborate_drop_and_replace({:?}) - untracked {:?}\", terminator, parent);\n                 self.patch.patch_terminator(\n                     bb,\n-                    TerminatorKind::Drop { location, target, unwind: Some(unwind) },\n+                    TerminatorKind::Drop { place, target, unwind: Some(unwind) },\n                 );\n             }\n         }"}, {"sha": "c8702eeae1d5b15ebb1bcfc632cd2d2f36d7aa88", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -93,13 +93,13 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, location: Location) {\n-        match kind {\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n+        match terminator.kind {\n             TerminatorKind::Return => {\n                 // Do not replace the implicit `_0` access here, as that's not possible. The\n                 // transform already handles `return` correctly.\n             }\n-            _ => self.super_terminator_kind(kind, location),\n+            _ => self.super_terminator(terminator, location),\n         }\n     }\n }\n@@ -835,8 +835,8 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n \n     for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            Terminator { source_info, kind: TerminatorKind::Drop { location, target, unwind } } => {\n-                if let Some(local) = location.as_local() {\n+            Terminator { source_info, kind: TerminatorKind::Drop { place, target, unwind } } => {\n+                if let Some(local) = place.as_local() {\n                     if local == SELF_ARG {\n                         (target, unwind, source_info)\n                     } else {\n@@ -1102,11 +1102,8 @@ fn create_generator_resume_function<'tcx>(\n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n-    let term = TerminatorKind::Drop {\n-        location: Place::from(SELF_ARG),\n-        target: return_block,\n-        unwind: None,\n-    };\n+    let term =\n+        TerminatorKind::Drop { place: Place::from(SELF_ARG), target: return_block, unwind: None };\n     let source_info = SourceInfo::outermost(body.span);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars."}, {"sha": "db909494aed6b53f6c103158cb20c1ef24f37c0a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -319,13 +319,13 @@ impl Inliner<'tcx> {\n             let term = blk.terminator();\n             let mut is_drop = false;\n             match term.kind {\n-                TerminatorKind::Drop { ref location, target, unwind }\n-                | TerminatorKind::DropAndReplace { ref location, target, unwind, .. } => {\n+                TerminatorKind::Drop { ref place, target, unwind }\n+                | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } => {\n                     is_drop = true;\n                     work_list.push(target);\n-                    // If the location doesn't actually need dropping, treat it like\n+                    // If the place doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n+                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -731,14 +731,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, loc: Location) {\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, loc: Location) {\n         // Don't try to modify the implicit `_0` access on return (`return` terminators are\n         // replaced down below anyways).\n-        if !matches!(kind, TerminatorKind::Return) {\n-            self.super_terminator_kind(kind, loc);\n+        if !matches!(terminator.kind, TerminatorKind::Return) {\n+            self.super_terminator(terminator, loc);\n         }\n \n-        match *kind {\n+        match terminator.kind {\n             TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => bug!(),\n             TerminatorKind::Goto { ref mut target } => {\n                 *target = self.update_target(*target);\n@@ -782,11 +782,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Return => {\n-                *kind = TerminatorKind::Goto { target: self.return_block };\n+                terminator.kind = TerminatorKind::Goto { target: self.return_block };\n             }\n             TerminatorKind::Resume => {\n                 if let Some(tgt) = self.cleanup_block {\n-                    *kind = TerminatorKind::Goto { target: tgt }\n+                    terminator.kind = TerminatorKind::Goto { target: tgt }\n                 }\n             }\n             TerminatorKind::Abort => {}"}, {"sha": "1d83733e4cd306bc88868a32f6195286df53327d", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -34,10 +34,10 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads<'tcx> {\n         self.tcx\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &mut TerminatorKind<'tcx>, location: Location) {\n-        if let Some(unwind) = kind.unwind_mut() {\n+    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n+        if let Some(unwind) = terminator.kind.unwind_mut() {\n             unwind.take();\n         }\n-        self.super_terminator_kind(kind, location);\n+        self.super_terminator(terminator, location);\n     }\n }"}, {"sha": "330f6c1640ff493ecd0b9ce443982a6ae22943f7", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -147,7 +147,6 @@ struct Collector<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n     temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n-    span: Span,\n }\n \n impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n@@ -216,10 +215,10 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n-        self.super_terminator_kind(kind, location);\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n \n-        match *kind {\n+        match terminator.kind {\n             TerminatorKind::Call { ref func, .. } => {\n                 if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n                     let fn_sig = self.ccx.tcx.fn_sig(def_id);\n@@ -254,10 +253,6 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             _ => {}\n         }\n     }\n-\n-    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n-        self.span = source_info.span;\n-    }\n }\n \n pub fn collect_temps_and_candidates(\n@@ -267,7 +262,6 @@ pub fn collect_temps_and_candidates(\n     let mut collector = Collector {\n         temps: IndexVec::from_elem(TempState::Undefined, &ccx.body.local_decls),\n         candidates: vec![],\n-        span: ccx.body.span,\n         ccx,\n     };\n     for (bb, data) in rpo {\n@@ -1192,7 +1186,7 @@ pub fn promote_candidates<'tcx>(\n             _ => true,\n         });\n         let terminator = block.terminator_mut();\n-        if let TerminatorKind::Drop { location: place, target, .. } = &terminator.kind {\n+        if let TerminatorKind::Drop { place, target, .. } = &terminator.kind {\n             if let Some(index) = place.as_local() {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto { target: *target };"}, {"sha": "caf6c7715a9e1caa3cc717c266e1a1a670cc5b87", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -349,9 +349,9 @@ fn check_terminator(\n         | TerminatorKind::Resume\n         | TerminatorKind::Unreachable => Ok(()),\n \n-        TerminatorKind::Drop { location, .. } => check_place(tcx, *location, span, def_id, body),\n-        TerminatorKind::DropAndReplace { location, value, .. } => {\n-            check_place(tcx, *location, span, def_id, body)?;\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, def_id, body),\n+        TerminatorKind::DropAndReplace { place, value, .. } => {\n+            check_place(tcx, *place, span, def_id, body)?;\n             check_operand(tcx, value, span, def_id, body)\n         }\n "}, {"sha": "5f55a812a4e0dc2cdfbc63c0022b17ff1627dd17", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -238,7 +238,7 @@ where\n                 self.elaborator.patch().patch_terminator(\n                     bb,\n                     TerminatorKind::Drop {\n-                        location: self.place,\n+                        place: self.place,\n                         target: self.succ,\n                         unwind: self.unwind.into_option(),\n                     },\n@@ -723,7 +723,7 @@ where\n         self.elaborator.patch().patch_terminator(\n             drop_block,\n             TerminatorKind::Drop {\n-                location: tcx.mk_place_deref(ptr),\n+                place: tcx.mk_place_deref(ptr),\n                 target: loop_block,\n                 unwind: unwind.into_option(),\n             },\n@@ -1000,7 +1000,7 @@ where\n \n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block =\n-            TerminatorKind::Drop { location: self.place, target, unwind: unwind.into_option() };\n+            TerminatorKind::Drop { place: self.place, target, unwind: unwind.into_option() };\n         self.new_block(unwind, block)\n     }\n "}, {"sha": "e2cf1bce733d6b2c70959c507cdb39a9b357c86e", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -687,7 +687,7 @@ fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'t\n     let tcx = hir.tcx();\n     let owner_id = tcx.hir().body_owner(body_id);\n     let span = tcx.hir().span(owner_id);\n-    let ty = tcx.types.err;\n+    let ty = tcx.ty_error();\n     let num_params = match hir.body_owner_kind {\n         hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len(),\n         hir::BodyOwnerKind::Closure => {\n@@ -909,7 +909,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n                         self.local_decls[local].local_info = if let Some(kind) = self_binding {\n-                            Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind))))\n+                            Some(box LocalInfo::User(ClearCrossCrate::Set(\n+                                BindingForm::ImplicitSelf(*kind),\n+                            )))\n                         } else {\n                             let binding_mode = ty::BindingMode::BindByValue(mutability);\n                             Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var("}, {"sha": "b8df27094471ffcc87b4aa02cc39c026d8e5e400", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         span: Span,\n-        location: Place<'tcx>,\n+        place: Place<'tcx>,\n         value: Operand<'tcx>,\n     ) -> BlockAnd<()> {\n         let source_info = self.source_info(span);\n@@ -1047,7 +1047,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block,\n             source_info,\n             TerminatorKind::DropAndReplace {\n-                location,\n+                place,\n                 value,\n                 target: next_target,\n                 unwind: Some(diverge_target),\n@@ -1158,7 +1158,7 @@ fn build_scope_drops<'tcx>(\n                     block,\n                     source_info,\n                     TerminatorKind::Drop {\n-                        location: local.into(),\n+                        place: local.into(),\n                         target: next,\n                         unwind: Some(unwind_to),\n                     },\n@@ -1272,7 +1272,7 @@ fn build_diverge_scope<'tcx>(\n                         block,\n                         source_info(drop_data.span),\n                         TerminatorKind::Drop {\n-                            location: drop_data.local.into(),\n+                            place: drop_data.local.into(),\n                             target,\n                             unwind: None,\n                         },"}, {"sha": "a1796c9433eac0329d92b86558bf7c66303f5cbc", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -478,7 +478,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                                     );\n \n                                     // Not a real fn, but we're not reaching codegen anyways...\n-                                    ty = cx.tcx.types.err;\n+                                    ty = cx.tcx.ty_error();\n                                     InlineAsmOperand::SymFn {\n                                         expr: Expr {\n                                             ty,"}, {"sha": "5c30b2a448c6d3a6b6d86f6c161df8870355f1ef", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -509,7 +509,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n-        if let ty::Error = ty.kind {\n+        if let ty::Error(_) = ty.kind {\n             // Avoid ICEs (e.g., #50577 and #50585).\n             return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n         }\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 if adt_def.is_enum() {\n                     let substs = match ty.kind {\n                         ty::Adt(_, substs) | ty::FnDef(_, substs) => substs,\n-                        ty::Error => {\n+                        ty::Error(_) => {\n                             // Avoid ICE (#50585)\n                             return PatKind::Wild;\n                         }\n@@ -1051,7 +1051,7 @@ crate fn compare_const_vals<'tcx>(\n     let b_bits = b.try_eval_bits(tcx, param_env, ty);\n \n     if let (Some(a), Some(b)) = (a_bits, b_bits) {\n-        use ::rustc_apfloat::Float;\n+        use rustc_apfloat::Float;\n         return match ty.kind {\n             ty::Float(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);"}, {"sha": "fc9ffc3092447e7941668e671f6f6702ffd2abc3", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -961,7 +961,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let sp = self.prev_token.span;\n             self.struct_span_err(sp, &msg)\n-                .span_suggestion(sp, \"change this to `;`\", \";\".to_string(), appl)\n+                .span_suggestion_short(sp, \"change this to `;`\", \";\".to_string(), appl)\n                 .emit();\n             return Ok(());\n         } else if self.look_ahead(0, |t| {"}, {"sha": "53f32b7c800bdaf74af35dfcba588571e1be4f16", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -216,8 +216,28 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n-    fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n-        if self.eat(&token::Eq) || skip_eq { Ok(Some(self.parse_expr()?)) } else { Ok(None) }\n+    fn parse_initializer(&mut self, eq_optional: bool) -> PResult<'a, Option<P<Expr>>> {\n+        let eq_consumed = match self.token.kind {\n+            token::BinOpEq(..) => {\n+                // Recover `let x <op>= 1` as `let x = 1`\n+                self.struct_span_err(\n+                    self.token.span,\n+                    \"can't reassign to an uninitialized variable\",\n+                )\n+                .span_suggestion_short(\n+                    self.token.span,\n+                    \"initialize the variable\",\n+                    \"=\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+                self.bump();\n+                true\n+            }\n+            _ => self.eat(&token::Eq),\n+        };\n+\n+        Ok(if eq_consumed || eq_optional { Some(self.parse_expr()?) } else { None })\n     }\n \n     /// Parses a block. No inner attributes are allowed."}, {"sha": "88fb78f85e423add2e3303342314fcd09f6485f5", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -150,7 +150,7 @@ impl ExprVisitor<'tcx> {\n             _ => unreachable!(),\n         };\n         let asm_ty = match ty.kind {\n-            ty::Never | ty::Error => return None,\n+            ty::Never | ty::Error(_) => return None,\n             ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::I8),\n             ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => Some(InlineAsmType::I16),\n             ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => Some(InlineAsmType::I32),\n@@ -167,7 +167,7 @@ impl ExprVisitor<'tcx> {\n                 let fields = &adt.non_enum_variant().fields;\n                 let elem_ty = fields[0].ty(self.tcx, substs);\n                 match elem_ty.kind {\n-                    ty::Never | ty::Error => return None,\n+                    ty::Never | ty::Error(_) => return None,\n                     ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {\n                         Some(InlineAsmType::VecI8(fields.len() as u64))\n                     }"}, {"sha": "9e6e7ea962bc378f21f3dc34aab3a50e22cdb68b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -220,7 +220,7 @@ where\n             | ty::Ref(..)\n             | ty::FnPtr(..)\n             | ty::Param(..)\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::GeneratorWitness(..) => {}\n             ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) => {\n                 bug!(\"unexpected type: {:?}\", ty)"}, {"sha": "8432e34a5271ceef7ddc9eed6de8b256f671f5cb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -485,6 +485,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             module_path.push(Segment {\n                                 ident: Ident { name: kw::PathRoot, span: source.ident.span },\n                                 id: Some(self.r.next_node_id()),\n+                                has_generic_args: false,\n                             });\n                             source.ident.name = crate_name;\n                         }"}, {"sha": "05ef0aa0bb689f5e6f2c85c3778baa3d1fa90fca", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -920,20 +920,47 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         &self,\n         path: &[Segment],\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n-        let ident = match path {\n-            [segment] => segment.ident,\n+        let (ident, span) = match path {\n+            [segment] if !segment.has_generic_args => {\n+                (segment.ident.to_string(), segment.ident.span)\n+            }\n             _ => return None,\n         };\n-        match (\n-            self.diagnostic_metadata.current_item,\n-            self.diagnostic_metadata.currently_processing_generics,\n-        ) {\n-            (Some(Item { kind: ItemKind::Fn(..), ident, .. }), true) if ident.name == sym::main => {\n+        let mut iter = ident.chars().map(|c| c.is_uppercase());\n+        let single_uppercase_char =\n+            matches!(iter.next(), Some(true)) && matches!(iter.next(), None);\n+        if !self.diagnostic_metadata.currently_processing_generics && !single_uppercase_char {\n+            return None;\n+        }\n+        match (self.diagnostic_metadata.current_item, single_uppercase_char) {\n+            (Some(Item { kind: ItemKind::Fn(..), ident, .. }), _) if ident.name == sym::main => {\n                 // Ignore `fn main()` as we don't want to suggest `fn main<T>()`\n             }\n-            (Some(Item { kind, .. }), true) => {\n+            (\n+                Some(Item {\n+                    kind:\n+                        kind @ ItemKind::Fn(..)\n+                        | kind @ ItemKind::Enum(..)\n+                        | kind @ ItemKind::Struct(..)\n+                        | kind @ ItemKind::Union(..),\n+                    ..\n+                }),\n+                true,\n+            )\n+            | (Some(Item { kind, .. }), false) => {\n                 // Likely missing type parameter.\n                 if let Some(generics) = kind.generics() {\n+                    if span.overlaps(generics.span) {\n+                        // Avoid the following:\n+                        // error[E0405]: cannot find trait `A` in this scope\n+                        //  --> $DIR/typo-suggestion-named-underscore.rs:CC:LL\n+                        //   |\n+                        // L | fn foo<T: A>(x: T) {} // Shouldn't suggest underscore\n+                        //   |           ^- help: you might be missing a type parameter: `, A`\n+                        //   |           |\n+                        //   |           not found in this scope\n+                        return None;\n+                    }\n                     let msg = \"you might be missing a type parameter\";\n                     let (span, sugg) = if let [.., param] = &generics.params[..] {\n                         let span = if let [.., bound] = &param.bounds[..] {"}, {"sha": "cca9eabe7bcf898d82945497a49d3c26cecb9b49", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -225,13 +225,15 @@ enum VisResolutionError<'a> {\n     ModuleOnly(Span),\n }\n \n-// A minimal representation of a path segment. We use this in resolve because\n-// we synthesize 'path segments' which don't have the rest of an AST or HIR\n-// `PathSegment`.\n+/// A minimal representation of a path segment. We use this in resolve because we synthesize 'path\n+/// segments' which don't have the rest of an AST or HIR `PathSegment`.\n #[derive(Clone, Copy, Debug)]\n pub struct Segment {\n     ident: Ident,\n     id: Option<NodeId>,\n+    /// Signals whether this `PathSegment` has generic arguments. Used to avoid providing\n+    /// nonsensical suggestions.\n+    has_generic_args: bool,\n }\n \n impl Segment {\n@@ -240,7 +242,7 @@ impl Segment {\n     }\n \n     fn from_ident(ident: Ident) -> Segment {\n-        Segment { ident, id: None }\n+        Segment { ident, id: None, has_generic_args: false }\n     }\n \n     fn names_to_string(segments: &[Segment]) -> String {\n@@ -250,7 +252,7 @@ impl Segment {\n \n impl<'a> From<&'a ast::PathSegment> for Segment {\n     fn from(seg: &'a ast::PathSegment) -> Segment {\n-        Segment { ident: seg.ident, id: Some(seg.id) }\n+        Segment { ident: seg.ident, id: Some(seg.id), has_generic_args: seg.args.is_some() }\n     }\n }\n \n@@ -2017,7 +2019,7 @@ impl<'a> Resolver<'a> {\n             path, opt_ns, record_used, path_span, crate_lint,\n         );\n \n-        for (i, &Segment { ident, id }) in path.iter().enumerate() {\n+        for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n                 if record_used {"}, {"sha": "cae501e942b6552eca0e156cc1b403db4a83fddf", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -520,7 +520,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n         let hir_node = self.tcx.hir().expect_expr(expr.hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n-        if ty.is_none() || ty.unwrap().kind == ty::Error {\n+        if ty.is_none() || matches!(ty.unwrap().kind, ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {"}, {"sha": "6f334bf37f5f1cb0e067a204420106b12a5c227c", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -345,6 +345,7 @@ symbols! {\n         from_method,\n         from_ok,\n         from_usize,\n+        from_trait,\n         fundamental,\n         future,\n         Future,"}, {"sha": "7d117b77cf5e5ab95484cf54b8cdb8fdd5812fb9", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -345,7 +345,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Never => \"z\",\n \n             // Placeholders (should be demangled as `_`).\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => \"p\",\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => \"p\",\n \n             _ => \"\",\n         };\n@@ -367,7 +367,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             ty::Tuple(_) if ty.is_unit() => unreachable!(),\n \n             // Placeholders, also handled as part of basic types.\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error => {\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) | ty::Infer(_) | ty::Error(_) => {\n                 unreachable!()\n             }\n "}, {"sha": "adccdd0b2617a4760602c13c8569fe0fd6c13492", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -941,7 +941,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().types.err\n+                        self.tcx().ty_error()\n                     }\n                 }\n             }\n@@ -974,7 +974,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty: ct.ty })\n+                        self.tcx().const_error(ct.ty)\n                     }\n                 }\n             }\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             tcx,\n             ty_op: |ty| {\n                 if ty.references_error() {\n-                    return tcx.types.err;\n+                    return tcx.ty_error();\n                 } else if let ty::Opaque(def_id, substs) = ty.kind {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose"}, {"sha": "706cbf058b713b354ce7d985d4bba9772790c044", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -565,7 +565,7 @@ fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>>\n             }\n         }\n \n-        ty::Error => None,\n+        ty::Error(_) => None,\n \n         ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)"}, {"sha": "e5a6c9a2e391a2a548ce895628124e121d676be7", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1246,7 +1246,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ty::Generator(..) => Some(18),\n                 ty::Foreign(..) => Some(19),\n                 ty::GeneratorWitness(..) => Some(20),\n-                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => None,\n             }\n         }\n "}, {"sha": "dfd7dac72d8e1702996d1cec1954a39415d038d7", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n              ty| {\n                 let ty = self.resolve_vars_if_possible(&ty);\n                 same &=\n-                    ty.kind != ty::Error\n+                    !matches!(ty.kind, ty::Error(_))\n                         && last_ty.map_or(true, |last_ty| {\n                             // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n                             // *after* in the dependency graph.\n@@ -1992,8 +1992,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n /// Collect all the returned expressions within the input expression.\n /// Used to point at the return spans when we want to suggest some change to them.\n #[derive(Default)]\n-struct ReturnsVisitor<'v> {\n-    returns: Vec<&'v hir::Expr<'v>>,\n+pub struct ReturnsVisitor<'v> {\n+    pub returns: Vec<&'v hir::Expr<'v>>,\n     in_block_tail: bool,\n }\n "}, {"sha": "ed108613bfa233735952dcd4dc35c60c5e22be2d", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -784,7 +784,7 @@ struct Progress<'tcx> {\n \n impl<'tcx> Progress<'tcx> {\n     fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { ty: tcx.types.err, obligations: vec![] }\n+        Progress { ty: tcx.ty_error(), obligations: vec![] }\n     }\n \n     fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n@@ -1085,7 +1085,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     | ty::Bound(..)\n                     | ty::Placeholder(..)\n                     | ty::Infer(..)\n-                    | ty::Error => false,\n+                    | ty::Error(_) => false,\n                 }\n             }\n             super::ImplSourceParam(..) => {\n@@ -1440,8 +1440,8 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n                 obligation, poly_cache_entry, e,\n             );\n             debug!(\"confirm_param_env_candidate: {}\", msg);\n-            infcx.tcx.sess.delay_span_bug(obligation.cause.span, &msg);\n-            Progress { ty: infcx.tcx.types.err, obligations: vec![] }\n+            let err = infcx.tcx.ty_error_with_message(obligation.cause.span, &msg);\n+            Progress { ty: err, obligations: vec![] }\n         }\n     }\n }\n@@ -1460,7 +1460,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let param_env = obligation.param_env;\n     let assoc_ty = match assoc_ty_def(selcx, impl_def_id, assoc_item_id) {\n         Ok(assoc_ty) => assoc_ty,\n-        Err(ErrorReported) => return Progress { ty: tcx.types.err, obligations: nested },\n+        Err(ErrorReported) => return Progress { ty: tcx.ty_error(), obligations: nested },\n     };\n \n     if !assoc_ty.item.defaultness.has_value() {\n@@ -1472,16 +1472,18 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n             assoc_ty.item.ident, obligation.predicate\n         );\n-        return Progress { ty: tcx.types.err, obligations: nested };\n+        return Progress { ty: tcx.ty_error(), obligations: nested };\n     }\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = tcx.type_of(assoc_ty.item.def_id);\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n-        tcx.sess\n-            .delay_span_bug(DUMMY_SP, \"impl item and trait item have different parameter counts\");\n-        Progress { ty: tcx.types.err, obligations: nested }\n+        let err = tcx.ty_error_with_message(\n+            DUMMY_SP,\n+            \"impl item and trait item have different parameter counts\",\n+        );\n+        Progress { ty: err, obligations: nested }\n     } else {\n         Progress { ty: ty.subst(tcx, substs), obligations: nested }\n     }"}, {"sha": "d07c95270e0040411e00fe825053eb5c15cd85cc", "filename": "src/librustc_trait_selection/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -101,7 +101,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Ref(..)\n         | ty::Str\n         | ty::Foreign(..)\n-        | ty::Error => true,\n+        | ty::Error(_) => true,\n \n         // [T; N] and [T] have same properties as T.\n         ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),"}, {"sha": "3fd566eab437e8899c4f2e7b7cdf7ae57dc27eb0", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1569,7 +1569,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Array(..)\n             | ty::Closure(..)\n             | ty::Never\n-            | ty::Error => {\n+            | ty::Error(_) => {\n                 // safe for everything\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n@@ -1613,7 +1613,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Infer(ty::FloatVar(_))\n             | ty::FnDef(..)\n             | ty::FnPtr(_)\n-            | ty::Error => Where(ty::Binder::dummy(Vec::new())),\n+            | ty::Error(_) => Where(ty::Binder::dummy(Vec::new())),\n \n             ty::Uint(_)\n             | ty::Int(_)\n@@ -1690,7 +1690,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::FnDef(..)\n             | ty::FnPtr(_)\n             | ty::Str\n-            | ty::Error\n+            | ty::Error(_)\n             | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Never\n             | ty::Char => Vec::new(),"}, {"sha": "201edf27a655cbba3d77ea2eb6e96492c8c8f26c", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n             ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n                 bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n             }\n-            ty::Error => {\n+            ty::Error(_) => {\n                 self.tcx().sess.delay_span_bug(self.span, \"ty::Error in structural-match check\");\n                 // We still want to check other types after encountering an error,\n                 // as this may still emit relevant errors."}, {"sha": "1825c159ff3fba47bedffdf47e277c2becd5b95f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -392,7 +392,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 ));\n                             }\n                         }\n-                        ty::ConstKind::Error\n+                        ty::ConstKind::Error(_)\n                         | ty::ConstKind::Param(_)\n                         | ty::ConstKind::Bound(..)\n                         | ty::ConstKind::Placeholder(..) => {\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 | ty::Int(..)\n                 | ty::Uint(..)\n                 | ty::Float(..)\n-                | ty::Error\n+                | ty::Error(_)\n                 | ty::Str\n                 | ty::GeneratorWitness(..)\n                 | ty::Never"}, {"sha": "c9dd06e9f1ba2ade7d14e1c19bc517a7acb6fbe9", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -168,7 +168,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind {\n                     // These types are always WF.\n-                    ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n+                    ty::Str | ty::Placeholder(..) | ty::Error(_) | ty::Never => {\n                         chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n                     }\n \n@@ -376,7 +376,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             })\n             .intern(interner),\n             Infer(_infer) => unimplemented!(),\n-            Error => unimplemented!(),\n+            Error(_) => unimplemented!(),\n         }\n     }\n }"}, {"sha": "6339f8288d54e7f3c370b574099aeffc4e9451fd", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -271,7 +271,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n             constraints.dtorck_types.push(ty);\n         }\n \n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => {\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n             // By the time this code runs, all type variables ought to\n             // be fully resolved.\n             return Err(NoSolution);"}, {"sha": "cf70a845af0aa54c3c83795e3b810d6d96eb7844", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -20,7 +20,7 @@ fn sized_constraint_for_ty<'tcx>(\n         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n         | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n \n-        Str | Dynamic(..) | Slice(_) | Foreign(..) | Error | GeneratorWitness(..) => {\n+        Str | Dynamic(..) | Slice(_) | Foreign(..) | Error(_) | GeneratorWitness(..) => {\n             // these are never sized - return the target type\n             vec![ty]\n         }"}, {"sha": "7cdcb2face8232f97a4ba43dc3caed1d084b128d", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -819,7 +819,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n                     if let (hir::TyKind::Infer, false) = (&ty.kind, self.allow_ty_infer()) {\n                         inferred_params.push(ty.span);\n-                        tcx.types.err.into()\n+                        tcx.ty_error().into()\n                     } else {\n                         self.ast_ty_to_ty(&ty).into()\n                     }\n@@ -845,7 +845,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             // careful!\n                             if default_needs_object_self(param) {\n                                 missing_type_params.push(param.name.to_string());\n-                                tcx.types.err.into()\n+                                tcx.ty_error().into()\n                             } else {\n                                 // This is a default type parameter.\n                                 self.normalize_ty(\n@@ -865,7 +865,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             self.ty_infer(param, span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            tcx.types.err.into()\n+                            tcx.ty_error().into()\n                         }\n                     }\n                     GenericParamDefKind::Const => {\n@@ -876,7 +876,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             self.ct_infer(ty, Some(param), span).into()\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            tcx.mk_const(ty::Const { val: ty::ConstKind::Error, ty }).into()\n+                            tcx.const_error(ty).into()\n                         }\n                     }\n                 }\n@@ -1607,7 +1607,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"at least one trait is required for an object type\"\n             )\n             .emit();\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1624,7 +1624,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &object_safety_violations[..],\n                 )\n                 .emit();\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n         }\n \n@@ -2434,7 +2434,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 &path_str,\n                 item_segment.ident.name,\n             );\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         };\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n@@ -2792,7 +2792,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                self.tcx().types.err\n+                self.tcx().ty_error()\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }\n@@ -2860,7 +2860,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 };\n                 self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, res, segment, false)\n                     .map(|(ty, _, _)| ty)\n-                    .unwrap_or(tcx.types.err)\n+                    .unwrap_or_else(|_| tcx.ty_error())\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.hir_id);\n@@ -2878,7 +2878,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .span_label(ast_ty.span, \"reserved keyword\")\n                 .emit();\n \n-                tcx.types.err\n+                tcx.ty_error()\n             }\n             hir::TyKind::Infer => {\n                 // Infer also appears as the type of arguments or return\n@@ -2887,7 +2887,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)\n             }\n-            hir::TyKind::Err => tcx.types.err,\n+            hir::TyKind::Err => tcx.ty_error(),\n         };\n \n         debug!(\"ast_ty_to_ty: result_ty={:?}\", result_ty);"}, {"sha": "9e23f5df3c6a8a367d9fc5821979f40ec464be49", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && i != 0\n                 && self.if_fallback_coercion(expr.span, &arms[0].body, &mut coercion)\n             {\n-                tcx.types.err\n+                tcx.ty_error()\n             } else {\n                 // Only call this if this is not an `if` expr with an expected type and no `else`\n                 // clause to avoid duplicated type errors. (#60254)"}, {"sha": "13695be83a9da7bfe0b1dbcff73ae87421b88965", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (\n                     ty::Binder::bind(self.tcx.mk_fn_sig(\n                         self.err_args(arg_exprs.len()).into_iter(),\n-                        self.tcx.types.err,\n+                        self.tcx.ty_error(),\n                         false,\n                         hir::Unsafety::Normal,\n                         abi::Abi::Rust,"}, {"sha": "78474dac76f6779351b1826bff561e2fc51141a7", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 89, "deletions": 20, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -43,6 +43,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_session::lint;\n use rustc_session::Session;\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n@@ -135,7 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             | ty::Generator(..)\n             | ty::Adt(..)\n             | ty::Never\n-            | ty::Error => {\n+            | ty::Error(_) => {\n                 self.tcx\n                     .sess\n                     .delay_span_bug(span, &format!(\"`{:?}` should be sized but is not?\", t));\n@@ -333,23 +334,87 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     \"only `u8` can be cast as `char`, not `{}`\",\n                     self.expr_ty\n                 )\n+                .span_label(self.span, \"invalid cast\")\n                 .emit();\n             }\n             CastError::NonScalar => {\n-                type_error_struct!(\n+                let mut err = type_error_struct!(\n                     fcx.tcx.sess,\n                     self.span,\n                     self.expr_ty,\n                     E0605,\n                     \"non-primitive cast: `{}` as `{}`\",\n                     self.expr_ty,\n                     fcx.ty_to_string(self.cast_ty)\n-                )\n-                .note(\n-                    \"an `as` expression can only be used to convert between \\\n-                                         primitive types. Consider using the `From` trait\",\n-                )\n-                .emit();\n+                );\n+                let mut sugg = None;\n+                if let ty::Ref(reg, _, mutbl) = self.cast_ty.kind {\n+                    if fcx\n+                        .try_coerce(\n+                            self.expr,\n+                            fcx.tcx.mk_ref(reg, TypeAndMut { ty: self.expr_ty, mutbl }),\n+                            self.cast_ty,\n+                            AllowTwoPhase::No,\n+                        )\n+                        .is_ok()\n+                    {\n+                        sugg = Some(format!(\"&{}\", mutbl.prefix_str()));\n+                    }\n+                }\n+                if let Some(sugg) = sugg {\n+                    err.span_label(self.span, \"invalid cast\");\n+                    err.span_suggestion_verbose(\n+                        self.expr.span.shrink_to_lo(),\n+                        \"borrow the value for the cast to be valid\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if !matches!(\n+                    self.cast_ty.kind,\n+                    ty::FnDef(..) | ty::FnPtr(..) | ty::Closure(..)\n+                ) {\n+                    let mut label = true;\n+                    // Check `impl From<self.expr_ty> for self.cast_ty {}` for accurate suggestion:\n+                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                        if let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::from_trait) {\n+                            let ty = fcx.resolve_vars_if_possible(&self.cast_ty);\n+                            // Erase regions to avoid panic in `prove_value` when calling\n+                            // `type_implements_trait`.\n+                            let ty = fcx.tcx.erase_regions(&ty);\n+                            let expr_ty = fcx.resolve_vars_if_possible(&self.expr_ty);\n+                            let expr_ty = fcx.tcx.erase_regions(&expr_ty);\n+                            let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n+                            // Check for infer types because cases like `Option<{integer}>` would\n+                            // panic otherwise.\n+                            if !expr_ty.has_infer_types()\n+                                && fcx.tcx.type_implements_trait((\n+                                    from_trait,\n+                                    ty,\n+                                    ty_params,\n+                                    fcx.param_env,\n+                                ))\n+                            {\n+                                label = false;\n+                                err.span_suggestion(\n+                                    self.span,\n+                                    \"consider using the `From` trait instead\",\n+                                    format!(\"{}::from({})\", self.cast_ty, snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    let msg = \"an `as` expression can only be used to convert between primitive \\\n+                               types or to coerce to a specific trait object\";\n+                    if label {\n+                        err.span_label(self.span, msg);\n+                    } else {\n+                        err.note(msg);\n+                    }\n+                } else {\n+                    err.span_label(self.span, \"invalid cast\");\n+                }\n+                err.emit();\n             }\n             CastError::SizedUnsizedCast => {\n                 use crate::structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n@@ -370,21 +435,22 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 };\n                 let mut err = struct_span_err!(\n                     fcx.tcx.sess,\n-                    self.span,\n+                    if unknown_cast_to { self.cast_span } else { self.span },\n                     E0641,\n                     \"cannot cast {} a pointer of an unknown kind\",\n                     if unknown_cast_to { \"to\" } else { \"from\" }\n                 );\n-                err.note(\n-                    \"the type information given here is insufficient to check whether \\\n-                          the pointer cast is valid\",\n-                );\n                 if unknown_cast_to {\n-                    err.span_suggestion_short(\n-                        self.cast_span,\n-                        \"consider giving more type information\",\n-                        String::new(),\n-                        Applicability::Unspecified,\n+                    err.span_label(self.cast_span, \"needs more type information\");\n+                    err.note(\n+                        \"the type information given here is insufficient to check whether \\\n+                        the pointer cast is valid\",\n+                    );\n+                } else {\n+                    err.span_label(\n+                        self.span,\n+                        \"the type information given here is insufficient to check whether \\\n+                        the pointer cast is valid\",\n                     );\n                 }\n                 err.emit();\n@@ -438,13 +504,16 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     Ok(s) => {\n                         err.span_suggestion(\n                             self.cast_span,\n-                            \"try casting to a `Box` instead\",\n+                            \"you can cast to a `Box` instead\",\n                             format!(\"Box<{}>\", s),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                     Err(_) => {\n-                        err.span_help(self.cast_span, &format!(\"did you mean `Box<{}>`?\", tstr));\n+                        err.span_help(\n+                            self.cast_span,\n+                            &format!(\"you might have meant `Box<{}>`\", tstr),\n+                        );\n                     }\n                 }\n             }"}, {"sha": "6d09ddc925ffe1f22ec44e5cf5f10326a4899cee", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -700,7 +700,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them.\n             astconv.ast_ty_to_ty(a);\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         });\n \n         if let hir::FnRetTy::Return(ref output) = decl.output {\n@@ -709,7 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n             supplied_arguments,\n-            self.tcx.types.err,\n+            self.tcx.ty_error(),\n             decl.c_variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,"}, {"sha": "dd3f292fb56846efc60dc75ac9d8c043e1ba51db", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -162,7 +162,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return success(vec![], self.fcx.tcx.types.err, vec![]);\n+            return success(vec![], self.fcx.tcx.ty_error(), vec![]);\n         }\n \n         if a.is_never() {\n@@ -864,7 +864,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n         self.apply_adjustments(expr, adjustments);\n-        Ok(if expr_ty.references_error() { self.tcx.types.err } else { target })\n+        Ok(if expr_ty.references_error() { self.tcx.ty_error() } else { target })\n     }\n \n     /// Same as `try_coerce()`, but without side-effects.\n@@ -1239,7 +1239,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         // If we see any error types, just propagate that error\n         // upwards.\n         if expression_ty.references_error() || self.merged_ty().references_error() {\n-            self.final_ty = Some(fcx.tcx.types.err);\n+            self.final_ty = Some(fcx.tcx.ty_error());\n             return;\n         }\n \n@@ -1396,7 +1396,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n                 err.emit_unless(assign_to_bool || unsized_return);\n \n-                self.final_ty = Some(fcx.tcx.types.err);\n+                self.final_ty = Some(fcx.tcx.ty_error());\n             }\n         }\n     }"}, {"sha": "69cfafc21648f114541db00c36f37b32fb0c2aea", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     tcx.types.never\n                 } else {\n                     // There was an error; make type-check fail.\n-                    tcx.types.err\n+                    tcx.ty_error()\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n@@ -284,7 +284,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Field(ref base, field) => self.check_field(expr, needs, &base, field),\n             ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, needs, expr),\n             ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n-            hir::ExprKind::Err => tcx.types.err,\n+            hir::ExprKind::Err => tcx.ty_error(),\n         }\n     }\n \n@@ -360,7 +360,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             tcx.sess.parse_sess.expr_parentheses_needed(&mut err, *sp, None);\n                         }\n                         err.emit();\n-                        oprnd_t = tcx.types.err;\n+                        oprnd_t = tcx.ty_error();\n                     }\n                 }\n                 hir::UnOp::UnNot => {\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tm = ty::TypeAndMut { ty, mutbl };\n         match kind {\n-            _ if tm.ty.references_error() => self.tcx.types.err,\n+            _ if tm.ty.references_error() => self.tcx.ty_error(),\n             hir::BorrowKind::Raw => {\n                 self.check_named_place_expr(oprnd);\n                 self.tcx.mk_ptr(tm)\n@@ -476,11 +476,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                tcx.types.err\n+                tcx.ty_error()\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n                 report_unexpected_variant_res(tcx, res, expr.span);\n-                tcx.types.err\n+                tcx.ty_error()\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n@@ -560,19 +560,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Some(ctxt) => ctxt.coerce.as_ref().map(|coerce| coerce.expected_ty()),\n                         None => {\n                             // Avoid ICE when `break` is inside a closure (#65383).\n-                            self.tcx.sess.delay_span_bug(\n+                            return tcx.ty_error_with_message(\n                                 expr.span,\n                                 \"break was outside loop, but no error was emitted\",\n                             );\n-                            return tcx.types.err;\n                         }\n                     }\n                 };\n \n                 // If the loop context is not a `loop { }`, then break with\n                 // a value is illegal, and `opt_coerce_to` will be `None`.\n                 // Just set expectation to error in that case.\n-                let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+                let coerce_to = opt_coerce_to.unwrap_or_else(|| tcx.ty_error());\n \n                 // Recurse without `enclosing_breakables` borrowed.\n                 e_ty = self.check_expr_with_hint(e, coerce_to);\n@@ -592,11 +591,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(ctxt) => ctxt,\n                 None => {\n                     // Avoid ICE when `break` is inside a closure (#65383).\n-                    self.tcx.sess.delay_span_bug(\n+                    return tcx.ty_error_with_message(\n                         expr.span,\n                         \"break was outside loop, but no error was emitted\",\n                     );\n-                    return tcx.types.err;\n                 }\n             };\n \n@@ -649,14 +647,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // this can only happen if the `break` was not\n             // inside a loop at all, which is caught by the\n             // loop-checking pass.\n-            self.tcx\n-                .sess\n-                .delay_span_bug(expr.span, \"break was outside loop, but no error was emitted\");\n+            let err = self.tcx.ty_error_with_message(\n+                expr.span,\n+                \"break was outside loop, but no error was emitted\",\n+            );\n \n             // We still need to assign a type to the inner expression to\n             // prevent the ICE in #43162.\n             if let Some(ref e) = expr_opt {\n-                self.check_expr_with_hint(e, tcx.types.err);\n+                self.check_expr_with_hint(e, err);\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n@@ -666,8 +665,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n+\n             // There was an error; make type-check fail.\n-            tcx.types.err\n+            err\n         }\n     }\n \n@@ -803,7 +803,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n         if lhs_ty.references_error() || rhs_ty.references_error() {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         } else {\n             self.tcx.mk_unit()\n         }\n@@ -957,7 +957,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -966,7 +966,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }\n-                Err(ErrorReported) => self.tcx.types.err,\n+                Err(ErrorReported) => self.tcx.ty_error(),\n             }\n         }\n     }\n@@ -1041,7 +1041,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if element_ty.references_error() {\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n \n         tcx.mk_ty(ty::Array(t, count))\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n         let tuple = self.tcx.mk_tup(elt_ts_iter);\n         if tuple.references_error() {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         } else {\n             self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n             tuple\n@@ -1092,7 +1092,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             variant_ty\n         } else {\n             self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         };\n \n         let path_span = match *qpath {\n@@ -1233,7 +1233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name, span);\n                 }\n \n-                tcx.types.err\n+                tcx.ty_error()\n             };\n \n             // Make sure to give a type to the field even if there's\n@@ -1519,7 +1519,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .emit();\n         }\n \n-        self.tcx().types.err\n+        self.tcx().ty_error()\n     }\n \n     fn ban_nonexisting_field(\n@@ -1775,7 +1775,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     err.emit();\n-                    self.tcx.types.err\n+                    self.tcx.ty_error()\n                 }\n             }\n         }\n@@ -1887,7 +1887,7 @@ pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n         ty::Char => \"'a'\",\n         ty::Int(_) | ty::Uint(_) => \"42\",\n         ty::Float(_) => \"3.14159\",\n-        ty::Error | ty::Never => return None,\n+        ty::Error(_) | ty::Never => return None,\n         _ => \"value\",\n     })\n }"}, {"sha": "8651c643cee879dbcbd44acbf51b0d6763207032", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -141,11 +141,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let (_, n) = match autoderef.nth(pick.autoderefs) {\n             Some(n) => n,\n             None => {\n-                self.tcx.sess.delay_span_bug(\n+                return self.tcx.ty_error_with_message(\n                     rustc_span::DUMMY_SP,\n                     &format!(\"failed autoderef {}\", pick.autoderefs),\n                 );\n-                return self.tcx.types.err;\n             }\n         };\n         assert_eq!(n, pick.autoderefs);"}, {"sha": "93bcd5cf29149d0138259f2b924fbb7365b90d33", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -400,7 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .probe_instantiate_query_response(span, &orig_values, ty)\n                     .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n                 let ty = self.structurally_resolved_type(span, ty.value);\n-                assert_eq!(ty, self.tcx.types.err);\n+                assert!(matches!(ty.kind, ty::Error(_)));\n                 return Err(MethodError::NoMatch(NoMatchData::new(\n                     Vec::new(),\n                     Vec::new(),\n@@ -478,7 +478,7 @@ fn method_autoderef_steps<'tcx>(\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n         let opt_bad_ty = match final_ty.kind {\n-            ty::Infer(ty::TyVar(_)) | ty::Error => Some(MethodAutoderefBadTy {\n+            ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n                 reached_raw_pointer,\n                 ty: infcx\n                     .make_query_response_ignoring_pending_obligations(inference_vars, final_ty),"}, {"sha": "b60b06567d6fa1c9e6ddfc1145808b5ea366993c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 187, "deletions": 28, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -138,6 +138,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::{InferCtxtExt as _, OpaqueTypeDecl};\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n+use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -967,8 +968,7 @@ fn diagnostic_only_typeck_tables_of<'tcx>(\n ) -> &ty::TypeckTables<'tcx> {\n     let fallback = move || {\n         let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id));\n-        tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n-        tcx.types.err\n+        tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n     };\n     typeck_tables_of_with_fallback(tcx, def_id, fallback)\n }\n@@ -1711,6 +1711,173 @@ fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId,\n     }\n }\n \n+/// Given a `DefId` for an opaque type in return position, find its parent item's return\n+/// expressions.\n+fn get_owner_return_paths(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Option<(hir::HirId, ReturnsVisitor<'tcx>)> {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let id = tcx.hir().get_parent_item(hir_id);\n+    tcx.hir()\n+        .find(id)\n+        .map(|n| (id, n))\n+        .and_then(|(hir_id, node)| node.body_id().map(|b| (hir_id, b)))\n+        .map(|(hir_id, body_id)| {\n+            let body = tcx.hir().body(body_id);\n+            let mut visitor = ReturnsVisitor::default();\n+            visitor.visit_body(body);\n+            (hir_id, visitor)\n+        })\n+}\n+\n+/// Emit an error for recursive opaque types.\n+///\n+/// If this is a return `impl Trait`, find the item's return expressions and point at them. For\n+/// direct recursion this is enough, but for indirect recursion also point at the last intermediary\n+/// `impl Trait`.\n+///\n+/// If all the return expressions evaluate to `!`, then we explain that the error will go away\n+/// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n+fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+\n+    let mut label = false;\n+    if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+        let tables = tcx.typeck_tables_of(tcx.hir().local_def_id(hir_id));\n+        if visitor\n+            .returns\n+            .iter()\n+            .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n+            .all(|ty| matches!(ty.kind, ty::Never))\n+        {\n+            let spans = visitor\n+                .returns\n+                .iter()\n+                .filter(|expr| tables.node_type_opt(expr.hir_id).is_some())\n+                .map(|expr| expr.span)\n+                .collect::<Vec<Span>>();\n+            let span_len = spans.len();\n+            if span_len == 1 {\n+                err.span_label(spans[0], \"this returned value is of `!` type\");\n+            } else {\n+                let mut multispan: MultiSpan = spans.clone().into();\n+                for span in spans {\n+                    multispan\n+                        .push_span_label(span, \"this returned value is of `!` type\".to_string());\n+                }\n+                err.span_note(multispan, \"these returned values have a concrete \\\"never\\\" type\");\n+            }\n+            err.help(\"this error will resolve once the item's body returns a concrete type\");\n+        } else {\n+            let mut seen = FxHashSet::default();\n+            seen.insert(span);\n+            err.span_label(span, \"recursive opaque type\");\n+            label = true;\n+            for (sp, ty) in visitor\n+                .returns\n+                .iter()\n+                .filter_map(|e| tables.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n+                .filter(|(_, ty)| !matches!(ty.kind, ty::Never))\n+            {\n+                struct VisitTypes(Vec<DefId>);\n+                impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                        match t.kind {\n+                            ty::Opaque(def, _) => {\n+                                self.0.push(def);\n+                                false\n+                            }\n+                            _ => t.super_visit_with(self),\n+                        }\n+                    }\n+                }\n+                let mut visitor = VisitTypes(vec![]);\n+                ty.visit_with(&mut visitor);\n+                for def_id in visitor.0 {\n+                    let ty_span = tcx.def_span(def_id);\n+                    if !seen.contains(&ty_span) {\n+                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n+                        seen.insert(ty_span);\n+                    }\n+                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+    if !label {\n+        err.span_label(span, \"cannot resolve opaque type\");\n+    }\n+    err.emit();\n+}\n+\n+/// Emit an error for recursive opaque types in a `let` binding.\n+fn binding_opaque_type_cycle_error(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    span: Span,\n+    partially_expanded_type: Ty<'tcx>,\n+) {\n+    let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n+    err.span_label(span, \"cannot resolve opaque type\");\n+    // Find the the owner that declared this `impl Trait` type.\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let mut prev_hir_id = hir_id;\n+    let mut hir_id = tcx.hir().get_parent_node(hir_id);\n+    while let Some(node) = tcx.hir().find(hir_id) {\n+        match node {\n+            hir::Node::Local(hir::Local {\n+                pat,\n+                init: None,\n+                ty: Some(ty),\n+                source: hir::LocalSource::Normal,\n+                ..\n+            }) => {\n+                err.span_label(pat.span, \"this binding might not have a concrete type\");\n+                err.span_suggestion_verbose(\n+                    ty.span.shrink_to_hi(),\n+                    \"set the binding to a value for a concrete type to be resolved\",\n+                    \" = /* value */\".to_string(),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+            hir::Node::Local(hir::Local {\n+                init: Some(expr),\n+                source: hir::LocalSource::Normal,\n+                ..\n+            }) => {\n+                let hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let tables =\n+                    tcx.typeck_tables_of(tcx.hir().local_def_id(tcx.hir().get_parent_item(hir_id)));\n+                if let Some(ty) = tables.node_type_opt(expr.hir_id) {\n+                    err.span_label(\n+                        expr.span,\n+                        &format!(\n+                            \"this is of type `{}`, which doesn't constrain \\\n+                             `{}` enough to arrive to a concrete type\",\n+                            ty, partially_expanded_type\n+                        ),\n+                    );\n+                }\n+            }\n+            _ => {}\n+        }\n+        if prev_hir_id == hir_id {\n+            break;\n+        }\n+        prev_hir_id = hir_id;\n+        hir_id = tcx.hir().get_parent_node(hir_id);\n+    }\n+    err.emit();\n+}\n+\n+fn async_opaque_type_cycle_error(tcx: TyCtxt<'tcx>, span: Span) {\n+    struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\")\n+        .span_label(span, \"recursive `async fn`\")\n+        .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n+        .emit();\n+}\n+\n /// Checks that an opaque type does not contain cycles.\n fn check_opaque_for_cycles<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -1721,21 +1888,12 @@ fn check_opaque_for_cycles<'tcx>(\n ) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n     {\n-        if let hir::OpaqueTyOrigin::AsyncFn = origin {\n-            struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\",)\n-                .span_label(span, \"recursive `async fn`\")\n-                .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n-                .emit();\n-        } else {\n-            let mut err =\n-                struct_span_err!(tcx.sess, span, E0720, \"opaque type expands to a recursive type\",);\n-            err.span_label(span, \"expands to a recursive type\");\n-            if let ty::Opaque(..) = partially_expanded_type.kind {\n-                err.note(\"type resolves to itself\");\n-            } else {\n-                err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n+        match origin {\n+            hir::OpaqueTyOrigin::AsyncFn => async_opaque_type_cycle_error(tcx, span),\n+            hir::OpaqueTyOrigin::Binding => {\n+                binding_opaque_type_cycle_error(tcx, def_id, span, partially_expanded_type)\n             }\n-            err.emit();\n+            _ => opaque_type_cycle_error(tcx, def_id, span),\n         }\n     }\n }\n@@ -3387,7 +3545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if self.is_tainted_by_errors() => self.tcx.types.err,\n+            None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n             None => {\n                 bug!(\n                     \"no type for node {}: {} in fcx {}\",\n@@ -3501,7 +3659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         assert!(ty.is_ty_infer());\n         let fallback = match self.type_is_unconstrained_numeric(ty) {\n-            _ if self.is_tainted_by_errors() => self.tcx().types.err,\n+            _ if self.is_tainted_by_errors() => self.tcx().ty_error(),\n             UnconstrainedInt => self.tcx.types.i32,\n             UnconstrainedFloat => self.tcx.types.f64,\n             Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n@@ -3774,7 +3932,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tuple_arguments,\n                 None,\n             );\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         }\n \n         let method = method.unwrap();\n@@ -4161,7 +4319,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        vec![self.tcx.types.err; len]\n+        vec![self.tcx.ty_error(); len]\n     }\n \n     /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n@@ -4305,7 +4463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n-            ast::LitKind::Err(_) => tcx.types.err,\n+            ast::LitKind::Err(_) => tcx.ty_error(),\n         }\n     }\n \n@@ -4442,7 +4600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 let result =\n                     AstConv::associated_path_to_ty(self, hir_id, path_span, ty, res, segment, true);\n-                let ty = result.map(|(ty, _, _)| ty).unwrap_or(self.tcx().types.err);\n+                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n@@ -4570,7 +4728,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n-            // Override the types everywhere with `types.err` to avoid knock on errors.\n+            // Override the types everywhere with `err()` to avoid knock on errors.\n             self.write_ty(local.hir_id, ty);\n             self.write_ty(local.pat.hir_id, ty);\n             let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n@@ -4790,7 +4948,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut ty = ctxt.coerce.unwrap().complete(self);\n \n         if self.has_errors.get() || ty.references_error() {\n-            ty = self.tcx.types.err\n+            ty = self.tcx.ty_error()\n         }\n \n         self.write_ty(blk.hir_id, ty);\n@@ -5378,7 +5536,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        if matches!(last_expr_ty.kind, ty::Error)\n+        if matches!(last_expr_ty.kind, ty::Error(_))\n             || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err()\n         {\n             return None;\n@@ -5538,7 +5696,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     err.emit();\n \n-                    return (tcx.types.err, res);\n+                    return (tcx.ty_error(), res);\n                 }\n             }\n         } else {\n@@ -5731,8 +5889,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .note(\"type must be known at this point\")\n                     .emit();\n             }\n-            self.demand_suptype(sp, self.tcx.types.err, ty);\n-            self.tcx.types.err\n+            let err = self.tcx.ty_error();\n+            self.demand_suptype(sp, err, ty);\n+            err\n         }\n     }\n "}, {"sha": "fe508709116473a35fd75db9b72d589482d82fc6", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                self.tcx.types.err\n+                self.tcx.ty_error()\n             }\n         };\n \n@@ -709,7 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     err.emit();\n                 }\n-                self.tcx.types.err\n+                self.tcx.ty_error()\n             }\n         }\n     }"}, {"sha": "7965c9c9ce12aed4d391d9359a26eac35abf46c0", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -442,7 +442,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // There exists a side that didn't meet our criteria that the end-point\n             // be of a numeric or char type, as checked in `calc_side` above.\n             self.emit_err_pat_range(span, lhs, rhs);\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         }\n \n         // Now that we know the types can be unified we find the unified type\n@@ -673,11 +673,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             variant_ty\n         } else {\n+            let err = self.tcx.ty_error();\n             for field in fields {\n                 let ti = TopInfo { parent_pat: Some(&pat), ..ti };\n-                self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n+                self.check_pat(&field.pat, err, def_bm, ti);\n             }\n-            return self.tcx.types.err;\n+            return err;\n         };\n \n         // Type-check the path.\n@@ -687,7 +688,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, etc, def_bm, ti) {\n             pat_ty\n         } else {\n-            self.tcx.types.err\n+            self.tcx.ty_error()\n         }\n     }\n \n@@ -705,11 +706,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n                 report_unexpected_variant_res(tcx, res, pat.span);\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::SelfCtor(..)\n             | Res::Def(\n@@ -788,7 +789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let on_error = || {\n             let parent_pat = Some(pat);\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, TopInfo { parent_pat, ..ti });\n+                self.check_pat(&pat, tcx.ty_error(), def_bm, TopInfo { parent_pat, ..ti });\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -824,26 +825,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if res == Res::Err {\n             self.set_tainted_by_errors();\n             on_error();\n-            return self.tcx.types.err;\n+            return self.tcx.ty_error();\n         }\n \n         // Type-check the path.\n         let (pat_ty, res) =\n             self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n         if !pat_ty.is_fn() {\n             report_unexpected_res(res);\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n \n         let variant = match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n                 on_error();\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n                 report_unexpected_res(res);\n-                return tcx.types.err;\n+                return tcx.ty_error();\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => tcx.expect_variant_res(res),\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n@@ -880,7 +881,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pattern has wrong number of fields.\n             self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n             on_error();\n-            return tcx.types.err;\n+            return tcx.ty_error();\n         }\n         pat_ty\n     }\n@@ -1001,9 +1002,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n-            let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error());\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &tcx.types.err, def_bm, ti);\n+                self.check_pat(elem, &tcx.ty_error(), def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n@@ -1052,7 +1053,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Occupied(occupied) => {\n                     self.error_field_already_bound(span, field.ident, *occupied.get());\n                     no_field_errors = false;\n-                    tcx.types.err\n+                    tcx.ty_error()\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n@@ -1066,7 +1067,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .unwrap_or_else(|| {\n                             inexistent_fields.push(field.ident);\n                             no_field_errors = false;\n-                            tcx.types.err\n+                            tcx.ty_error()\n                         })\n                 }\n             };\n@@ -1281,7 +1282,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype_pat(span, expected, box_ty, ti);\n             (box_ty, inner_ty)\n         } else {\n-            (tcx.types.err, tcx.types.err)\n+            let err = tcx.ty_error();\n+            (err, err)\n         };\n         self.check_pat(&inner, inner_ty, def_bm, ti);\n         box_ty\n@@ -1327,7 +1329,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            (tcx.types.err, tcx.types.err)\n+            let err = tcx.ty_error();\n+            (err, err)\n         };\n         self.check_pat(&inner, inner_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         rptr_ty\n@@ -1378,7 +1381,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if !expected.references_error() {\n                     self.error_expected_array_or_slice(span, expected);\n                 }\n-                let err = self.tcx.types.err;\n+                let err = self.tcx.ty_error();\n                 (err, Some(err), err)\n             }\n         };\n@@ -1445,7 +1448,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // If we get here, we must have emitted an error.\n-        (Some(self.tcx.types.err), arr_ty)\n+        (Some(self.tcx.ty_error()), arr_ty)\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}, {"sha": "8403c99f01bb57d549fe104e9a9ceedd7af29efb", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (closure_def_id, substs) = match ty.kind {\n             ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-            ty::Error => {\n+            ty::Error(_) => {\n                 // #51714: skip analysis when we have already encountered type errors\n                 return;\n             }"}, {"sha": "ba806430f17fda879afc75f85fcdadd7f87d7ad1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -208,11 +208,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     // to access an unexistend index. We assume that more relevant errors will\n                     // already have been emitted, so we only gate on this with an ICE if no\n                     // error has been emitted. (#64638)\n-                    self.tcx().sess.delay_span_bug(\n+                    self.fcx.tcx.ty_error_with_message(\n                         e.span,\n                         &format!(\"bad index {:?} for base: `{:?}`\", index, base),\n-                    );\n-                    self.fcx.tcx.types.err\n+                    )\n                 });\n                 let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n \n@@ -681,7 +680,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_type_error(t);\n                 self.replaced_with_error = true;\n-                self.tcx().types.err\n+                self.tcx().ty_error()\n             }\n         }\n     }\n@@ -698,7 +697,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);\n                 self.replaced_with_error = true;\n-                self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty: ct.ty })\n+                self.tcx().const_error(ct.ty)\n             }\n         }\n     }"}, {"sha": "8c6161a62647346b780450776524de5e5228a51d", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> Checker<'tcx> {\n \n fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     // Destructors only work on nominal types.\n-    if let ty::Adt(..) | ty::Error = tcx.type_of(impl_did).kind {\n+    if let ty::Adt(..) | ty::Error(_) = tcx.type_of(impl_did).kind {\n         return;\n     }\n "}, {"sha": "93ee87f6c572ee5bd164247dcb11fefcabfe8789", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -296,7 +296,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     item.span,\n                 );\n             }\n-            ty::Error => {}\n+            ty::Error(_) => {}\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "3bd75095bb6021db986c5bd682a2dec7d93dd3eb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -307,8 +307,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn ty_infer(&self, _: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n-        self.tcx().sess.delay_span_bug(span, \"bad placeholder type\");\n-        self.tcx().types.err\n+        self.tcx().ty_error_with_message(span, \"bad_placeholder_type\")\n     }\n \n     fn ct_infer(\n@@ -318,8 +317,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         span: Span,\n     ) -> &'tcx Const<'tcx> {\n         bad_placeholder_type(self.tcx(), vec![span]).emit();\n-\n-        self.tcx().mk_const(ty::Const { val: ty::ConstKind::Error, ty })\n+        self.tcx().const_error(ty)\n     }\n \n     fn projected_ty_from_poly_trait_ref(\n@@ -419,7 +417,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n                 _ => {}\n             }\n             err.emit();\n-            self.tcx().types.err\n+            self.tcx().ty_error()\n         }\n     }\n \n@@ -1465,7 +1463,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     visitor.visit_ty(ty);\n                     let mut diag = bad_placeholder_type(tcx, visitor.0);\n                     let ret_ty = fn_sig.output();\n-                    if ret_ty != tcx.types.err {\n+                    if ret_ty != tcx.ty_error() {\n                         diag.span_suggestion(\n                             ty.span,\n                             \"replace with the correct return type\",\n@@ -2004,12 +2002,11 @@ fn associated_item_predicates(\n             // once they are handled by the trait system.\n             ty::GenericParamDefKind::Type { .. } => {\n                 unimplemented_error(\"type\");\n-                tcx.types.err.into()\n+                tcx.ty_error().into()\n             }\n             ty::GenericParamDefKind::Const => {\n                 unimplemented_error(\"const\");\n-                tcx.mk_const(ty::Const { val: ty::ConstKind::Error, ty: tcx.type_of(param.def_id) })\n-                    .into()\n+                tcx.const_error(tcx.type_of(param.def_id)).into()\n             }\n         }\n     };"}, {"sha": "cf5f2ec69d8d85ee3e0b93d5545d6595338d60b0", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -127,7 +127,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n                                 // the `concrete_opaque_types` table.\n-                                tcx.types.err\n+                                tcx.ty_error()\n                             } else {\n                                 // We failed to resolve the opaque type or it\n                                 // resolves to itself. Return the non-revealed\n@@ -217,11 +217,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         })\n                         | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n                         _ => {\n-                            tcx.sess.delay_span_bug(\n+                            return tcx.ty_error_with_message(\n                                 DUMMY_SP,\n                                 &format!(\"unexpected const parent path {:?}\", parent_node),\n                             );\n-                            return tcx.types.err;\n                         }\n                     };\n \n@@ -254,14 +253,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         }\n                         Res::Def(_, def_id) => tcx.generics_of(def_id),\n                         res => {\n-                            tcx.sess.delay_span_bug(\n+                            return tcx.ty_error_with_message(\n                                 DUMMY_SP,\n                                 &format!(\n                                     \"unexpected anon const res {:?} in path: {:?}\",\n                                     res, path,\n                                 ),\n-                            );\n-                            return tcx.types.err;\n+                                );\n                         }\n                     };\n \n@@ -283,24 +281,21 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     } else {\n                         // This is no generic parameter associated with the arg. This is\n                         // probably from an extra arg where one is not needed.\n-                        tcx.sess.delay_span_bug(\n+                        tcx.ty_error_with_message(\n                             DUMMY_SP,\n                             &format!(\n-                                \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n+                                \"missing generic parameter for `AnonConst`, \\\n+                                 parent: {:?}, res: {:?}\",\n                                 parent_node, res\n                             ),\n-                        );\n-                        tcx.types.err\n+                        )\n                     }\n                 }\n \n-                x => {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n-                    );\n-                    tcx.types.err\n-                }\n+                x => tcx.ty_error_with_message(\n+                    DUMMY_SP,\n+                    &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n+                ),\n             }\n         }\n \n@@ -568,7 +563,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         None => {\n             let span = tcx.def_span(def_id);\n             tcx.sess.span_err(span, \"could not find defining uses\");\n-            tcx.types.err\n+            tcx.ty_error()\n         }\n     }\n }\n@@ -605,7 +600,7 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n             if let Some(ErrorReported) = owner_tables.tainted_by_errors {\n                 // Some error in the owner fn prevented us from populating the\n                 // `concrete_opaque_types` table.\n-                tcx.types.err\n+                tcx.ty_error()\n             } else {\n                 // We failed to resolve the opaque type or it resolves to\n                 // itself. Return the non-revealed type, which should result in\n@@ -655,7 +650,7 @@ fn infer_placeholder_type(\n         }\n         None => {\n             let mut diag = bad_placeholder_type(tcx, vec![span]);\n-            if ty != tcx.types.err {\n+            if !matches!(ty.kind, ty::Error(_)) {\n                 diag.span_suggestion(\n                     span,\n                     \"replace `_` with the correct type\","}, {"sha": "cae09267994e3fe94af54dc80e41d95cedb4c0a1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }\n \n-            ty::Error => {\n+            ty::Error(_) => {\n                 // we encounter this when walking the trait references for object\n                 // types, where we use Error as the Self type\n             }"}, {"sha": "73fe87b05d477e6f3d25ed64e24c7252b03a976e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1717,7 +1717,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Placeholder(..) => panic!(\"Placeholder\"),\n             ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n             ty::Infer(..) => panic!(\"Infer\"),\n-            ty::Error => panic!(\"Error\"),\n+            ty::Error(_) => panic!(\"Error\"),\n         }\n     }\n }"}, {"sha": "7a6626766d38830c27283ad336f69ee03aae2435", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -192,6 +192,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n     fn next(&mut self) -> Option<Self::Item> {\n         let event = self.inner.next();\n         let compile_fail;\n+        let should_panic;\n         let ignore;\n         let edition;\n         if let Some(Event::Start(Tag::CodeBlock(kind))) = event {\n@@ -205,6 +206,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 return Some(Event::Start(Tag::CodeBlock(kind)));\n             }\n             compile_fail = parse_result.compile_fail;\n+            should_panic = parse_result.should_panic;\n             ignore = parse_result.ignore;\n             edition = parse_result.edition;\n         } else {\n@@ -280,6 +282,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             Some((\"This example is not tested\".to_owned(), \"ignore\"))\n         } else if compile_fail {\n             Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n+        } else if should_panic {\n+            Some((\"This example panics\".to_owned(), \"should_panic\"))\n         } else if explicit_edition {\n             Some((format!(\"This code runs with edition {}\", edition), \"edition\"))\n         } else {\n@@ -295,6 +299,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                         \" ignore\"\n                     } else if compile_fail {\n                         \" compile_fail\"\n+                    } else if should_panic {\n+                        \" should_panic\"\n                     } else if explicit_edition {\n                         \" edition \"\n                     } else {\n@@ -314,6 +320,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                         \" ignore\"\n                     } else if compile_fail {\n                         \" compile_fail\"\n+                    } else if should_panic {\n+                        \" should_panic\"\n                     } else if explicit_edition {\n                         \" edition \"\n                     } else {"}, {"sha": "8d53b0579537407c8abbf5c66c2566baacb58b71", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -100,6 +100,8 @@ function defocusSearchBar() {\n     // 2 for \"In Return Types\"\n     var currentTab = 0;\n \n+    var mouseMovedAfterSearch = true;\n+\n     var titleBeforeSearch = document.title;\n \n     function clearInputTimeout() {\n@@ -162,6 +164,7 @@ function defocusSearchBar() {\n         }\n         addClass(main, \"hidden\");\n         removeClass(search, \"hidden\");\n+        mouseMovedAfterSearch = false;\n     }\n \n     function hideSearchResults(search) {\n@@ -424,6 +427,12 @@ function defocusSearchBar() {\n     document.addEventListener(\"keypress\", handleShortcut);\n     document.addEventListener(\"keydown\", handleShortcut);\n \n+    function resetMouseMoved(ev) {\n+        mouseMovedAfterSearch = true;\n+    }\n+\n+    document.addEventListener(\"mousemove\", resetMouseMoved);\n+\n     var handleSourceHighlight = (function() {\n         var prev_line_id = 0;\n \n@@ -1353,20 +1362,22 @@ function defocusSearchBar() {\n                 }\n             };\n             var mouseover_func = function(e) {\n-                var el = e.target;\n-                // to retrieve the real \"owner\" of the event.\n-                while (el.tagName !== \"TR\") {\n-                    el = el.parentNode;\n-                }\n-                clearTimeout(hoverTimeout);\n-                hoverTimeout = setTimeout(function() {\n-                    onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n-                        onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n-                            removeClass(i_e, \"highlighted\");\n+                if (mouseMovedAfterSearch) {\n+                    var el = e.target;\n+                    // to retrieve the real \"owner\" of the event.\n+                    while (el.tagName !== \"TR\") {\n+                        el = el.parentNode;\n+                    }\n+                    clearTimeout(hoverTimeout);\n+                    hoverTimeout = setTimeout(function() {\n+                        onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n+                            onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {\n+                                removeClass(i_e, \"highlighted\");\n+                            });\n                         });\n-                    });\n-                    addClass(el, \"highlighted\");\n-                }, 20);\n+                        addClass(el, \"highlighted\");\n+                    }, 20);\n+                }\n             };\n             onEachLazy(document.getElementsByClassName(\"search-results\"), function(e) {\n                 onEachLazy(e.getElementsByClassName(\"result\"), function(i_e) {"}, {"sha": "9c6dd25394db0e8ed4d1c1c0beffbf9cd36eaa3e", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1089,7 +1089,7 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \tborder-style: solid;\n }\n \n-.tooltip.compile_fail, .tooltip.ignore {\n+.tooltip.compile_fail, .tooltip.should_panic, .tooltip.ignore {\n \tfont-weight: bold;\n \tfont-size: 20px;\n }"}, {"sha": "41dcb5c24507c6c38dfe99a66bd3f84ac20cde81", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -283,6 +283,14 @@ pre.compile_fail:hover, .information:hover + pre.compile_fail {\n \tborder-left: 2px solid #f00;\n }\n \n+pre.should_panic {\n+\tborder-left: 2px solid rgba(255,0,0,.8);\n+}\n+\n+pre.should_panic:hover, .information:hover + pre.should_panic {\n+\tborder-left: 2px solid #f00;\n+}\n+\n pre.ignore {\n \tborder-left: 2px solid rgba(255,142,0,.6);\n }\n@@ -299,6 +307,14 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tcolor: #f00;\n }\n \n+.tooltip.should_panic {\n+\tcolor: rgba(255,0,0,.8);\n+}\n+\n+.information > .should_panic:hover {\n+\tcolor: #f00;\n+}\n+\n .tooltip.ignore {\n \tcolor: rgba(255,142,0,.6);\n }"}, {"sha": "386fe2398e63aec931bb665ea82dea7db5c0f0ef", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -278,6 +278,14 @@ pre.compile_fail:hover, .information:hover + pre.compile_fail {\n \tborder-left: 2px solid #f00;\n }\n \n+pre.should_panic {\n+\tborder-left: 2px solid rgba(255,0,0,.5);\n+}\n+\n+pre.should_panic:hover, .information:hover + pre.should_panic {\n+\tborder-left: 2px solid #f00;\n+}\n+\n pre.ignore {\n \tborder-left: 2px solid rgba(255,142,0,.6);\n }\n@@ -294,6 +302,14 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tcolor: #f00;\n }\n \n+.tooltip.should_panic {\n+\tcolor: rgba(255,0,0,.5);\n+}\n+\n+.information > .should_panic:hover {\n+\tcolor: #f00;\n+}\n+\n .tooltip.ignore {\n \tcolor: rgba(255,142,0,.6);\n }"}, {"sha": "95d113166e00119edb3ef19d6917a81053524c98", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -165,9 +165,8 @@ fn opts() -> Vec<RustcOptGroup> {\n             o.optmulti(\n                 \"\",\n                 \"passes\",\n-                \"list of passes to also run, you might want \\\n-                        to pass it multiple times; a value of `list` \\\n-                        will print available passes\",\n+                \"list of passes to also run, you might want to pass it multiple times; a value of \\\n+                        `list` will print available passes\",\n                 \"PASSES\",\n             )\n         }),\n@@ -248,8 +247,8 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"e\",\n                 \"extend-css\",\n                 \"To add some CSS rules with a given file to generate doc with your \\\n-                      own theme. However, your theme might break if the rustdoc's generated HTML \\\n-                      changes, so be careful!\",\n+                        own theme. However, your theme might break if the rustdoc's generated HTML \\\n+                        changes, so be careful!\",\n                 \"PATH\",\n             )\n         }),\n@@ -262,7 +261,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"\",\n                 \"playground-url\",\n                 \"URL to send code snippets to, may be reset by --markdown-playground-url \\\n-                      or `#![doc(html_playground_url=...)]`\",\n+                        or `#![doc(html_playground_url=...)]`\",\n                 \"URL\",\n             )\n         }),\n@@ -276,8 +275,7 @@ fn opts() -> Vec<RustcOptGroup> {\n             o.optflag(\n                 \"\",\n                 \"sort-modules-by-appearance\",\n-                \"sort modules by where they appear in the \\\n-                                                         program, rather than alphabetically\",\n+                \"sort modules by where they appear in the program, rather than alphabetically\",\n             )\n         }),\n         stable(\"theme\", |o| {\n@@ -358,7 +356,7 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"\",\n                 \"static-root-path\",\n                 \"Path string to force loading static files from in output pages. \\\n-                      If not set, uses combinations of '../' to reach the documentation root.\",\n+                        If not set, uses combinations of '../' to reach the documentation root.\",\n                 \"PATH\",\n             )\n         }),"}, {"sha": "ef699ede2a140bc50a85d8a0d0aac2e73c39c571", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -298,6 +298,7 @@\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n+#![feature(raw_ref_macros)]\n #![feature(renamed_spin_loop)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]"}, {"sha": "295ebcbb7293970ecea26835a407a13a64eeb217", "filename": "src/libstd/time.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -60,6 +60,21 @@ pub use core::time::Duration;\n /// }\n /// ```\n ///\n+/// # OS-specific behaviors\n+///\n+/// An `Instant` is a wrapper around system-specific types and it may behave\n+/// differently depending on the underlying operating system. For example,\n+/// the following snippet is fine on Linux but panics on macOS:\n+///\n+/// ```no_run\n+/// use std::time::{Instant, Duration};\n+///\n+/// let now = Instant::now();\n+/// let max_nanoseconds = u64::MAX / 1_000_000_000;\n+/// let duration = Duration::new(max_nanoseconds, 0);\n+/// println!(\"{:?}\", now + duration);\n+/// ```\n+///\n /// # Underlying System calls\n /// Currently, the following system calls are being used to get the current time using `now()`:\n ///"}, {"sha": "519be6b6a99a43d2d870ee6dfcad1117f264a753", "filename": "src/test/codegen/cdylib-external-inline-fns.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fcdylib-external-inline-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fcdylib-external-inline-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcdylib-external-inline-fns.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"cdylib\"]\n+\n+// CHECK: define void @a()\n+#[no_mangle]\n+#[inline]\n+pub extern \"C\" fn a() {}\n+\n+// CHECK: define void @b()\n+#[export_name = \"b\"]\n+#[inline]\n+pub extern \"C\" fn b() {}\n+\n+// CHECK: define void @c()\n+#[no_mangle]\n+#[inline]\n+extern \"C\" fn c() {}\n+\n+// CHECK: define void @d()\n+#[export_name = \"d\"]\n+#[inline]\n+extern \"C\" fn d() {}\n+\n+// CHECK: define void @e()\n+#[no_mangle]\n+#[inline(always)]\n+pub extern \"C\" fn e() {}\n+\n+// CHECK: define void @f()\n+#[export_name = \"f\"]\n+#[inline(always)]\n+pub extern \"C\" fn f() {}\n+\n+// CHECK: define void @g()\n+#[no_mangle]\n+#[inline(always)]\n+extern \"C\" fn g() {}\n+\n+// CHECK: define void @h()\n+#[export_name = \"h\"]\n+#[inline(always)]\n+extern \"C\" fn h() {}"}, {"sha": "59e97601c838d6427d6e741e1a91aa97aa64b8cc", "filename": "src/test/codegen/export-no-mangle.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fexport-no-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fexport-no-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexport-no-mangle.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -11,11 +11,21 @@ mod private {\n     #[export_name = \"BAR\"]\n     static BAR: u32 = 3;\n \n-    // CHECK: void @foo()\n+    // CHECK: void @a()\n     #[no_mangle]\n-    pub extern fn foo() {}\n+    pub extern fn a() {}\n \n-    // CHECK: void @bar()\n-    #[export_name = \"bar\"]\n-    extern fn bar() {}\n+    // CHECK: void @b()\n+    #[export_name = \"b\"]\n+    extern fn b() {}\n+\n+    // CHECK: void @c()\n+    #[export_name = \"c\"]\n+    #[inline]\n+    extern fn c() {}\n+\n+    // CHECK: void @d()\n+    #[export_name = \"d\"]\n+    #[inline(always)]\n+    extern fn d() {}\n }"}, {"sha": "41820b057f1ef27710bf098403d3829daee3dac8", "filename": "src/test/codegen/external-no-mangle-fns.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -53,3 +53,23 @@ fn x() {\n         core::ptr::read_volatile(&42);\n     }\n }\n+\n+// CHECK: define void @i()\n+#[no_mangle]\n+#[inline]\n+fn i() {}\n+\n+// CHECK: define void @j()\n+#[no_mangle]\n+#[inline]\n+pub fn j() {}\n+\n+// CHECK: define void @k()\n+#[no_mangle]\n+#[inline(always)]\n+fn k() {}\n+\n+// CHECK: define void @l()\n+#[no_mangle]\n+#[inline(always)]\n+pub fn l() {}"}, {"sha": "48231d6f7208d7d9e9d398e7da4e20c35edc0667", "filename": "src/test/codegen/sanitizer-no-sanitize-inlining.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -13,7 +13,7 @@\n #![feature(no_sanitize)]\n \n // ASAN-LABEL: define void @test\n-// ASAN:         tail call fastcc void @random_inline\n+// ASAN:         call {{.*}} @random_inline\n // ASAN:       }\n //\n // LSAN-LABEL: define void @test"}, {"sha": "8876ab7376afe3ce5ca7b7c400c86251efae375e", "filename": "src/test/codegen/staticlib-external-inline-fns.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fstaticlib-external-inline-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fcodegen%2Fstaticlib-external-inline-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstaticlib-external-inline-fns.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"staticlib\"]\n+\n+// CHECK: define void @a()\n+#[no_mangle]\n+#[inline]\n+pub extern \"C\" fn a() {}\n+\n+// CHECK: define void @b()\n+#[export_name = \"b\"]\n+#[inline]\n+pub extern \"C\" fn b() {}\n+\n+// CHECK: define void @c()\n+#[no_mangle]\n+#[inline]\n+extern \"C\" fn c() {}\n+\n+// CHECK: define void @d()\n+#[export_name = \"d\"]\n+#[inline]\n+extern \"C\" fn d() {}\n+\n+// CHECK: define void @e()\n+#[no_mangle]\n+#[inline(always)]\n+pub extern \"C\" fn e() {}\n+\n+// CHECK: define void @f()\n+#[export_name = \"f\"]\n+#[inline(always)]\n+pub extern \"C\" fn f() {}\n+\n+// CHECK: define void @g()\n+#[no_mangle]\n+#[inline(always)]\n+extern \"C\" fn g() {}\n+\n+// CHECK: define void @h()\n+#[export_name = \"h\"]\n+#[inline(always)]\n+extern \"C\" fn h() {}"}, {"sha": "b59b21111b009740350b5f5db4a6a1d941a3a231", "filename": "src/test/rustdoc/codeblock-title.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Frustdoc%2Fcodeblock-title.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Frustdoc%2Fcodeblock-title.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcodeblock-title.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -4,6 +4,7 @@\n \n // @has foo/fn.bar.html '//*[@class=\"tooltip compile_fail\"]/span' \"This example deliberately fails to compile\"\n // @has foo/fn.bar.html '//*[@class=\"tooltip ignore\"]/span' \"This example is not tested\"\n+// @has foo/fn.bar.html '//*[@class=\"tooltip should_panic\"]/span' \"This example panics\"\n \n /// foo\n ///\n@@ -15,6 +16,10 @@\n /// goo();\n /// ```\n ///\n+/// ```should_panic\n+/// hoo();\n+/// ```\n+///\n /// ```\n /// let x = 0;\n /// ```"}, {"sha": "973294e985f7a45a65e4c99e946bf31df508dd52", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -37,7 +37,7 @@ fn main() {\n         TyKind::Bound(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Placeholder(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Infer(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Error => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Error(_) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n     }\n \n     if let ty::Int(int_ty) = kind {}"}, {"sha": "d6e4c85c190d5af36da784f4a5ddcb52b7a87394", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -169,7 +169,7 @@ LL |         TyKind::Infer(..) => (),\n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:40:9\n    |\n-LL |         TyKind::Error => (),\n+LL |         TyKind::Error(_) => (),\n    |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`"}, {"sha": "53a45cf4e4f4db2763635182c1f60372cdfa9bab", "filename": "src/test/ui/associated-types/associated-types-eq-1.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-1.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -4,7 +4,16 @@ error[E0412]: cannot find type `A` in this scope\n LL | fn foo2<I: Foo>(x: I) {\n    |         - similarly named type parameter `I` defined here\n LL |     let _: A = x.boo();\n-   |            ^ help: a type parameter with a similar name exists: `I`\n+   |            ^\n+   |\n+help: a type parameter with a similar name exists\n+   |\n+LL |     let _: I = x.boo();\n+   |            ^\n+help: you might be missing a type parameter\n+   |\n+LL | fn foo2<I: Foo, A>(x: I) {\n+   |               ^^^\n \n error: aborting due to previous error\n "}, {"sha": "0f58b158904db0a2fb3aa8fdb2e5c935c07e2707", "filename": "src/test/ui/async-await/issues/issue-62097.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,13 +1,14 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/issue-62097.rs:12:31\n    |\n LL |     pub async fn run_dummy_fn(&self) {\n    |                               ^^^^^\n    |                               |\n-   |                               data with this lifetime...\n+   |                               this data with an anonymous lifetime `'_`...\n    |                               ...is captured here...\n LL |         foo(|| self.bar()).await;\n-   |         --- ...and required to be `'static` by this\n+   |         --- ...and is required to live as long as `'static` here\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "dab133cfb4b673f06c91352c9dc5cfdba9f72992", "filename": "src/test/ui/cast/cast-from-nil.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-from-nil.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-from-nil.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-from-nil.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `()` as `u32`\n   --> $DIR/cast-from-nil.rs:2:21\n    |\n LL | fn main() { let u = (assert!(true) as u32); }\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "d97b0c5f8aadc736c3fdc1c114e1c3c98b34f814", "filename": "src/test/ui/cast/cast-to-bare-fn.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-to-bare-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-to-bare-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-to-bare-fn.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,17 +2,13 @@ error[E0605]: non-primitive cast: `fn(isize) {foo}` as `extern \"C\" fn() -> isize\n   --> $DIR/cast-to-bare-fn.rs:5:13\n    |\n LL |     let x = foo as extern \"C\" fn() -> isize;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n \n error[E0605]: non-primitive cast: `u64` as `fn(isize) -> (isize, isize)`\n   --> $DIR/cast-to-bare-fn.rs:7:13\n    |\n LL |     let y = v as extern \"Rust\" fn(isize) -> (isize, isize);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n \n error: aborting due to 2 previous errors\n "}, {"sha": "29a9baffd71d7592268a801d2fcfd26d730aa78b", "filename": "src/test/ui/cast/cast-to-nil.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-to-nil.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-to-nil.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-to-nil.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `u32` as `()`\n   --> $DIR/cast-to-nil.rs:2:21\n    |\n LL | fn main() { let u = 0u32 as (); }\n-   |                     ^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                     ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "9b86f8d4def86bd04fcb118e7fcfaeac652f21cf", "filename": "src/test/ui/cast/cast-to-unsized-trait-object-suggestion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-to-unsized-trait-object-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcast%2Fcast-to-unsized-trait-object-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-to-unsized-trait-object-suggestion.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -12,7 +12,7 @@ error[E0620]: cast to unsized type: `std::boxed::Box<{integer}>` as `dyn std::ma\n LL |     Box::new(1) as dyn Send;\n    |     ^^^^^^^^^^^^^^^--------\n    |                    |\n-   |                    help: try casting to a `Box` instead: `Box<dyn Send>`\n+   |                    help: you can cast to a `Box` instead: `Box<dyn Send>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4b3b4be798fc1e541a2f7b98df22ef6c737b8db3", "filename": "src/test/ui/closures/closure-no-fn-3.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fclosures%2Fclosure-no-fn-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fclosures%2Fclosure-no-fn-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-no-fn-3.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `[closure@$DIR/closure-no-fn-3.rs:6:27: 6:37 b\n   --> $DIR/closure-no-fn-3.rs:6:27\n    |\n LL |     let baz: fn() -> u8 = (|| { b }) as fn() -> u8;\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n \n error: aborting due to previous error\n "}, {"sha": "d3adbd5158dbbbffc6f0a72484039f9c5819c9c0", "filename": "src/test/ui/coercion/coerce-to-bang-cast.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang-cast.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,17 +2,13 @@ error[E0605]: non-primitive cast: `i32` as `!`\n   --> $DIR/coerce-to-bang-cast.rs:6:13\n    |\n LL |     let y = {return; 22} as !;\n-   |             ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `i32` as `!`\n   --> $DIR/coerce-to-bang-cast.rs:11:13\n    |\n LL |     let y = 22 as !;\n-   |             ^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e4d256c0ad19201b93438af57daec0badf1fb1d3", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-4b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -16,7 +16,7 @@ error[E0604]: only `u8` can be cast as `char`, not `i8`\n   --> $DIR/const-eval-overflow-4b.rs:25:13\n    |\n LL |     : [u32; 5i8 as char as usize]\n-   |             ^^^^^^^^^^^\n+   |             ^^^^^^^^^^^ invalid cast\n \n error: aborting due to 3 previous errors\n "}, {"sha": "18835310bd5e87ec6541fa49df36540a60be1c64", "filename": "src/test/ui/error-codes/E0604.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ferror-codes%2FE0604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ferror-codes%2FE0604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0604.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,7 +2,7 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/E0604.rs:2:5\n    |\n LL |     1u32 as char;\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^ invalid cast\n \n error: aborting due to previous error\n "}, {"sha": "f23d2008e0b5f2c4cd38904b074ac9c48bc5747c", "filename": "src/test/ui/error-codes/E0605.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ferror-codes%2FE0605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ferror-codes%2FE0605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0605.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,17 +2,13 @@ error[E0605]: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n   --> $DIR/E0605.rs:3:5\n    |\n LL |     x as Vec<u8>;\n-   |     ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `*const u8` as `&u8`\n   --> $DIR/E0605.rs:6:5\n    |\n LL |     v as &u8;\n-   |     ^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "905195d4ad963fe4b963a1dc31e03a1b9a115a27", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -42,15 +42,13 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/error-festival.rs:25:5\n    |\n LL |     0u32 as char;\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^ invalid cast\n \n error[E0605]: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n   --> $DIR/error-festival.rs:29:5\n    |\n LL |     x as Vec<u8>;\n-   |     ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0054]: cannot cast as `bool`\n   --> $DIR/error-festival.rs:33:24"}, {"sha": "56d5a26beb04ee0d37e823799155373569c068a4", "filename": "src/test/ui/fat-ptr-cast.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ffat-ptr-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ffat-ptr-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffat-ptr-cast.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -34,9 +34,7 @@ error[E0605]: non-primitive cast: `std::boxed::Box<[i32]>` as `usize`\n   --> $DIR/fat-ptr-cast.rs:14:5\n    |\n LL |     b as usize;\n-   |     ^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |     ^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0606]: casting `*const [i32]` as `usize` is invalid\n   --> $DIR/fat-ptr-cast.rs:15:5"}, {"sha": "6a97f28ff552b3a76c5f4743b8d980dcddaf97b1", "filename": "src/test/ui/impl-trait/binding-without-value.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,9 @@\n+#![allow(incomplete_features)]\n+#![feature(impl_trait_in_bindings)]\n+\n+fn foo() {\n+    let _ : impl Copy;\n+    //~^ ERROR cannot resolve opaque type\n+}\n+\n+fn main() {}"}, {"sha": "0d2faeaf85d10be60785746009a2de1eed8ac1ce", "filename": "src/test/ui/impl-trait/binding-without-value.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbinding-without-value.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,16 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/binding-without-value.rs:5:13\n+   |\n+LL |     let _ : impl Copy;\n+   |         -   ^^^^^^^^^ cannot resolve opaque type\n+   |         |\n+   |         this binding might not have a concrete type\n+   |\n+help: set the binding to a value for a concrete type to be resolved\n+   |\n+LL |     let _ : impl Copy = /* value */;\n+   |                       ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "451ddb3cce0e01c1bd9bc6d6034f055c5901f2d1", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -5,13 +5,13 @@\n \n trait Quux {}\n \n-fn foo() -> impl Quux { //~ opaque type expands to a recursive type\n+fn foo() -> impl Quux { //~ ERROR cannot resolve opaque type\n     struct Foo<T>(T);\n     impl<T> Quux for Foo<T> {}\n     Foo(bar())\n }\n \n-fn bar() -> impl Quux { //~ opaque type expands to a recursive type\n+fn bar() -> impl Quux { //~ ERROR cannot resolve opaque type\n     struct Bar<T>(T);\n     impl<T> Quux for Bar<T> {}\n     Bar(foo())"}, {"sha": "c538b77098a2d23a133667a96d30897926a1c4f5", "filename": "src/test/ui/impl-trait/issues/infinite-impl-trait-issue-38064.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Finfinite-impl-trait-issue-38064.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,18 +1,26 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/infinite-impl-trait-issue-38064.rs:8:13\n    |\n LL | fn foo() -> impl Quux {\n-   |             ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `foo::Foo<bar::Bar<impl Quux>>`\n+   |             ^^^^^^^^^ recursive opaque type\n+...\n+LL |     Foo(bar())\n+   |     ---------- returning here with type `foo::Foo<impl Quux>`\n+...\n+LL | fn bar() -> impl Quux {\n+   |             --------- returning this opaque type `foo::Foo<impl Quux>`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/infinite-impl-trait-issue-38064.rs:14:13\n    |\n+LL | fn foo() -> impl Quux {\n+   |             --------- returning this opaque type `bar::Bar<impl Quux>`\n+...\n LL | fn bar() -> impl Quux {\n-   |             ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `bar::Bar<foo::Foo<impl Quux>>`\n+   |             ^^^^^^^^^ recursive opaque type\n+...\n+LL |     Bar(foo())\n+   |     ---------- returning here with type `bar::Bar<impl Quux>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ca9ca8a9debe2a62dfee8a8b31a77f81506bb096", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -26,7 +26,34 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                ^^^^^^^^^^^^^^\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |               -                              ^ returning this value requires that `'1` must outlive `'static`\n+   |               |\n+   |               let's call the lifetime of this reference `'1`\n+   |\n+   = help: consider replacing `'1` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:15:41\n+   |\n+LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+   |               ----                      ^ lifetime `'a` required\n+   |               |\n+   |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n@@ -35,7 +62,7 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n@@ -45,13 +72,14 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0310`.\n+Some errors have detailed explanations: E0310, E0621.\n+For more information about an error, try `rustc --explain E0310`."}, {"sha": "837244b022721c266bd9353b960e2e2b961daf7e", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -6,6 +6,27 @@ fn elided(x: &i32) -> impl Copy { x }\n fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n //~^ ERROR cannot infer an appropriate lifetime\n \n+fn elided2(x: &i32) -> impl Copy + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+//~^ ERROR explicit lifetime required in the type of `x`\n+\n+fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n+fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n "}, {"sha": "e1fa4f02b6fcf770f2585118eae9c58c507983f4", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 149, "deletions": 25, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,47 +1,113 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ---------   ^ ...and is captured here\n-   |              |        |\n-   |              |        ...is required to be `'static` by this...\n-   |              data with this lifetime...\n+   |              ----                 ^ ...is captured here...\n+   |              |\n+   |              this data with an anonymous lifetime `'_`...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+   |\n+LL | fn elided(x: &i32) -> impl Copy { x }\n+   |                       ^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ^^^^\n \n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |                    -------     ---------   ^ ...and is captured here\n-   |                    |           |\n-   |                    |           ...is required to be `'static` by this...\n-   |                    data with this lifetime...\n+   |                    -------                 ^ ...is captured here...\n+   |                    |\n+   |                    this data with lifetime `'a`...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 6:13\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+   |\n+LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n+   |                                ^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'a` lifetime bound\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ^^^^\n \n-error: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |               ----                           ^ ...is captured here...\n+   |               |\n+   |               this data with an anonymous lifetime `'_`...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n+   |                                    ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn elided2(x: &'static i32) -> impl Copy + 'static { x }\n+   |               ^^^^^^^^^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:55\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |                     -------                           ^ ...is captured here...\n+   |                     |\n+   |                     this data with lifetime `'a`...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:12:33\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n+   |                                 ^^^^^^^^^^^^^^^^^^^\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n+   |                                             ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n+   |                     ^^^^^^^^^^^^\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/must_outlive_least_region_or_bound.rs:15:24\n+   |\n+LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n+   |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n+   |               |\n+   |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                      -------     --------------------------------   ^ ...and is captured here\n-   |                      |           |\n-   |                      |           ...is required to be `'static` by this...\n-   |                      data with this lifetime...\n+   |                      ------- this data with lifetime `'a`...        ^ ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 12:15\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:33:34\n+   |\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static + 'a { x }\n-   |                                                                   ^^^^\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n+   |                                                           ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                      ^^^^^^^^^^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                                                 -------     ^^^^^^^^^^^^^^^^\n@@ -50,14 +116,72 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    |                                                 this parameter and the return type are declared with different lifetimes...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n-error: aborting due to 5 previous errors\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+   |\n+LL | fn elided3(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+   |               ----                               ^ ...is captured here, requiring it to live as long as `'static`\n+   |               |\n+   |               this data with an anonymous lifetime `'_`...\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided3(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n+   |                                      ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:21:59\n+   |\n+LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug> { Box::new(x) }\n+   |                     -------                               ^ ...is captured here, requiring it to live as long as `'static`\n+   |                     |\n+   |                     this data with lifetime `'a`...\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'a` lifetime bound\n+   |\n+LL | fn explicit3<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n+   |                                               ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:24:60\n+   |\n+LL | fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |               ----                                         ^ ...is captured here, requiring it to live as long as `'static`\n+   |               |\n+   |               this data with an anonymous lifetime `'_`...\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn elided4(x: &i32) -> Box<dyn Debug + '_> { Box::new(x) }\n+   |                                        ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn elided4(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |               ^^^^^^^^^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:27:69\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                     ------- this data with lifetime `'a`...         ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'a> { Box::new(x) }\n+   |                                                 ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn explicit4<'a>(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n+   |                     ^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n \n-Some errors have detailed explanations: E0310, E0623.\n+Some errors have detailed explanations: E0310, E0621, E0623, E0759.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,10 +1,11 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n    |\n LL | fn test() -> impl Sized {\n-   |              ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |              ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     test()\n+   |     ------ returning here with type `impl Sized`\n \n error: aborting due to previous error\n "}, {"sha": "75ff9e078cc2ca7fe96b51e61d66bb1c25d8ad22", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "modified", "additions": 93, "deletions": 60, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,114 +1,147 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:7:22\n    |\n LL | fn option(i: i32) -> impl Sized {\n-   |                      ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `std::option::Option<(impl Sized, i32)>`\n+   |                      ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     if i < 0 { None } else { Some((option(i - 1), i)) }\n+   |                ----          ------------------------ returning here with type `std::option::Option<(impl Sized, i32)>`\n+   |                |\n+   |                returning here with type `std::option::Option<(impl Sized, i32)>`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:12:15\n    |\n LL | fn tuple() -> impl Sized {\n-   |               ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `(impl Sized,)`\n+   |               ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     (tuple(),)\n+   |     ---------- returning here with type `(impl Sized,)`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:17:15\n    |\n LL | fn array() -> impl Sized {\n-   |               ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[impl Sized; 1]`\n+   |               ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     [array()]\n+   |     --------- returning here with type `[impl Sized; 1]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:22:13\n    |\n LL | fn ptr() -> impl Sized {\n-   |             ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `*const impl Sized`\n+   |             ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     &ptr() as *const _\n+   |     ------------------ returning here with type `*const impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:27:16\n    |\n LL | fn fn_ptr() -> impl Sized {\n-   |                ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `fn() -> impl Sized`\n+   |                ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     fn_ptr as fn() -> _\n+   |     ------------------- returning here with type `fn() -> impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:32:25\n    |\n-LL | fn closure_capture() -> impl Sized {\n-   |                         ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n+LL |   fn closure_capture() -> impl Sized {\n+   |                           ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:40:29\n    |\n-LL | fn closure_ref_capture() -> impl Sized {\n-   |                             ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n+LL |   fn closure_ref_capture() -> impl Sized {\n+   |                               ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         &x;\n+LL | |     }\n+   | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:48:21\n    |\n LL | fn closure_sig() -> impl Sized {\n-   |                     ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n+   |                     ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     || closure_sig()\n+   |     ---------------- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:53:23\n    |\n LL | fn generator_sig() -> impl Sized {\n-   |                       ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n+   |                       ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     || generator_sig()\n+   |     ------------------ returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:58:27\n    |\n-LL | fn generator_capture() -> impl Sized {\n-   |                           ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n+LL |   fn generator_capture() -> impl Sized {\n+   |                             ^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     move || {\n+LL | |         yield;\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:67:35\n    |\n LL | fn substs_change<T: 'static>() -> impl Sized {\n-   |                                   ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `(impl Sized,)`\n+   |                                   ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     (substs_change::<&T>(),)\n+   |     ------------------------ returning here with type `(impl Sized,)`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:72:24\n    |\n-LL | fn generator_hold() -> impl Sized {\n-   |                        ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n+LL |   fn generator_hold() -> impl Sized {\n+   |                          ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL | /     move || {\n+LL | |         let x = generator_hold();\n+LL | |         yield;\n+LL | |         x;\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:86:26\n    |\n LL | fn mutual_recursion() -> impl Sync {\n-   |                          ^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                          ^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     mutual_recursion_b()\n+   |     -------------------- returning here with type `impl Sized`\n+...\n+LL | fn mutual_recursion_b() -> impl Sized {\n+   |                            ---------- returning this opaque type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-indirect.rs:91:28\n    |\n+LL | fn mutual_recursion() -> impl Sync {\n+   |                          --------- returning this opaque type `impl std::marker::Sync`\n+...\n LL | fn mutual_recursion_b() -> impl Sized {\n-   |                            ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                            ^^^^^^^^^^ recursive opaque type\n+LL |\n+LL |     mutual_recursion()\n+   |     ------------------ returning here with type `impl std::marker::Sync`\n \n error: aborting due to 14 previous errors\n "}, {"sha": "818e40365394dea65b44fe652d41be64aae4071e", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -4,21 +4,21 @@\n \n fn id<T>(t: T) -> impl Sized { t }\n \n-fn recursive_id() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_id() -> impl Sized { //~ ERROR cannot resolve opaque type\n     id(recursive_id2())\n }\n \n-fn recursive_id2() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_id2() -> impl Sized { //~ ERROR cannot resolve opaque type\n     id(recursive_id())\n }\n \n fn wrap<T>(t: T) -> impl Sized { (t,) }\n \n-fn recursive_wrap() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_wrap() -> impl Sized { //~ ERROR cannot resolve opaque type\n     wrap(recursive_wrap2())\n }\n \n-fn recursive_wrap2() -> impl Sized { //~ ERROR opaque type expands to a recursive type\n+fn recursive_wrap2() -> impl Sized { //~ ERROR cannot resolve opaque type\n     wrap(recursive_wrap())\n }\n "}, {"sha": "fbc58837a8e946dc45cd62490a2dc6442c83f4ae", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-through-non-recursive.stderr", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-through-non-recursive.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,34 +1,46 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:7:22\n    |\n+LL | fn id<T>(t: T) -> impl Sized { t }\n+   |                   ---------- returning this opaque type `impl Sized`\n+LL | \n LL | fn recursive_id() -> impl Sized {\n-   |                      ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                      ^^^^^^^^^^ recursive opaque type\n+LL |     id(recursive_id2())\n+   |     ------------------- returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:11:23\n    |\n+LL | fn id<T>(t: T) -> impl Sized { t }\n+   |                   ---------- returning this opaque type `impl Sized`\n+...\n LL | fn recursive_id2() -> impl Sized {\n-   |                       ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: type resolves to itself\n+   |                       ^^^^^^^^^^ recursive opaque type\n+LL |     id(recursive_id())\n+   |     ------------------ returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:17:24\n    |\n+LL | fn wrap<T>(t: T) -> impl Sized { (t,) }\n+   |                     ---------- returning this opaque type `impl Sized`\n+LL | \n LL | fn recursive_wrap() -> impl Sized {\n-   |                        ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `((impl Sized,),)`\n+   |                        ^^^^^^^^^^ recursive opaque type\n+LL |     wrap(recursive_wrap2())\n+   |     ----------------------- returning here with type `impl Sized`\n \n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/recursive-impl-trait-type-through-non-recursive.rs:21:25\n    |\n+LL | fn wrap<T>(t: T) -> impl Sized { (t,) }\n+   |                     ---------- returning this opaque type `impl Sized`\n+...\n LL | fn recursive_wrap2() -> impl Sized {\n-   |                         ^^^^^^^^^^ expands to a recursive type\n-   |\n-   = note: expanded type is `((impl Sized,),)`\n+   |                         ^^^^^^^^^^ recursive opaque type\n+LL |     wrap(recursive_wrap())\n+   |     ---------------------- returning here with type `impl Sized`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "df0db6e4fc6df927297d9793d271390de5bc21dd", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,36 +1,43 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:7:16\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ----------------------- ...is required to be `'static` by this...\n-   |                         |\n-   |                         data with this lifetime...\n+   |                         ----- this data with an anonymous lifetime `'_`...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...and is captured here\n+   |         ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/static-return-lifetime-infered.rs:6:35\n+   |\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ^^^^\n \n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:11:16\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                        --------     ----------------------- ...is required to be `'static` by this...\n-   |                        |\n-   |                        data with this lifetime...\n+   |                        -------- this data with lifetime `'a`...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...and is captured here\n+   |         ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the method body at 10:20\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/static-return-lifetime-infered.rs:10:37\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "462508f306ef34f4b1f3de692f996a79a3d894e8", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -3,7 +3,6 @@\n use std::fmt::Debug;\n \n // Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-//~^ ERROR opaque type expands to a recursive type\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,10 +1,12 @@\n-error[E0720]: opaque type expands to a recursive type\n+error[E0720]: cannot resolve opaque type\n   --> $DIR/where-allowed-2.rs:6:30\n    |\n LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^ expands to a recursive type\n+   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n+   |                              |\n+   |                              cannot resolve opaque type\n    |\n-   = note: type resolves to itself\n+   = help: this error will resolve once the item's body returns a concrete type\n \n error: aborting due to previous error\n "}, {"sha": "5b8a1823386936929c5200ea19a420515be3608e", "filename": "src/test/ui/issues/issue-10991.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-10991.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-10991.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10991.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `()` as `usize`\n   --> $DIR/issue-10991.rs:3:14\n    |\n LL |     let _t = nil as usize;\n-   |              ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |              ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "eaf6acff26bf35cf92b704ebca96c4c0bdaaebb0", "filename": "src/test/ui/issues/issue-16048.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-16048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-16048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16048.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -18,12 +18,12 @@ impl<'a> Test<'a> for Foo<'a> {\n }\n \n impl<'a> NoLifetime for Foo<'a> {\n-    fn get<'p, T : Test<'a>>(&self) -> T {\n+    fn get<'p, T: Test<'a> + From<Foo<'a>>>(&self) -> T {\n     //~^ ERROR E0195\n     //~| NOTE lifetimes do not match method in trait\n         return *self as T;\n         //~^ ERROR non-primitive cast: `Foo<'a>` as `T`\n-        //~| NOTE an `as` expression can only be used to convert between primitive types.\n+        //~| NOTE an `as` expression can only be used to convert between primitive types\n     }\n }\n "}, {"sha": "73610942d7a7ed358ded73169f73004ff5bfac24", "filename": "src/test/ui/issues/issue-16048.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-16048.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-16048.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16048.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -4,16 +4,16 @@ error[E0195]: lifetime parameters or bounds on method `get` do not match the tra\n LL |     fn get<'p, T : Test<'p>>(&self) -> T;\n    |           ------------------ lifetimes in impl do not match this method in trait\n ...\n-LL |     fn get<'p, T : Test<'a>>(&self) -> T {\n-   |           ^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait\n+LL |     fn get<'p, T: Test<'a> + From<Foo<'a>>>(&self) -> T {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait\n \n error[E0605]: non-primitive cast: `Foo<'a>` as `T`\n   --> $DIR/issue-16048.rs:24:16\n    |\n LL |         return *self as T;\n-   |                ^^^^^^^^^^\n+   |                ^^^^^^^^^^ help: consider using the `From` trait instead: `T::from(*self)`\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   = note: an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "919594fc9af4b434967d1975e1a23b41346c5f6e", "filename": "src/test/ui/issues/issue-16922.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,18 +1,16 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/issue-16922.rs:4:14\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n-   |                       -- data with this lifetime...\n+   |                       -- this data with an anonymous lifetime `'_`...\n LL |     Box::new(value) as Box<dyn Any>\n-   |     ---------^^^^^-\n-   |     |        |\n-   |     |        ...and is captured here\n-   |     ...is required to be `'static` by this...\n+   |              ^^^^^ ...is captured here, requiring it to live as long as `'static`\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n+help: to declare that the trait object captures data from argument `value`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any + '_> {\n    |                                          ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "b63a3995d255dd523a3518f7e891845f57bd5069", "filename": "src/test/ui/issues/issue-17441.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-17441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-17441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17441.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -16,7 +16,7 @@ error[E0620]: cast to unsized type: `std::boxed::Box<usize>` as `dyn std::fmt::D\n LL |     let _bar = Box::new(1_usize) as dyn std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^^-------------------\n    |                                     |\n-   |                                     help: try casting to a `Box` instead: `Box<dyn std::fmt::Debug>`\n+   |                                     help: you can cast to a `Box` instead: `Box<dyn std::fmt::Debug>`\n \n error[E0620]: cast to unsized type: `usize` as `dyn std::fmt::Debug`\n   --> $DIR/issue-17441.rs:8:16"}, {"sha": "4c35deb1fbe4e0b566c14fc9026d09f5883cfff3", "filename": "src/test/ui/issues/issue-22289.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-22289.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-22289.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22289.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,12 @@ error[E0605]: non-primitive cast: `i32` as `&(dyn std::any::Any + 'static)`\n   --> $DIR/issue-22289.rs:2:5\n    |\n LL |     0 as &dyn std::any::Any;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+help: borrow the value for the cast to be valid\n+   |\n+LL |     &0 as &dyn std::any::Any;\n+   |     ^\n \n error: aborting due to previous error\n "}, {"sha": "4e359b3412a71e8400aca880fea2c4cadf9f93f6", "filename": "src/test/ui/issues/issue-22312.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-22312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-22312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22312.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,6 +1,6 @@\n use std::ops::Index;\n \n-pub trait Array2D: Index<usize> {\n+pub trait Array2D: Index<usize> + Sized {\n     fn rows(&self) -> usize;\n     fn columns(&self) -> usize;\n     fn get<'a>(&'a self, y: usize, x: usize) -> Option<&'a <Self as Index<usize>>::Output> {"}, {"sha": "28564b074633bf2fd402729008e8f39644b90f7d", "filename": "src/test/ui/issues/issue-22312.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22312.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,12 @@ error[E0605]: non-primitive cast: `Self` as `&dyn std::ops::Index<usize, Output\n   --> $DIR/issue-22312.rs:11:24\n    |\n LL |         let indexer = &(*self as &dyn Index<usize, Output = <Self as Index<usize>>::Output>);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+help: borrow the value for the cast to be valid\n+   |\n+LL |         let indexer = &(&*self as &dyn Index<usize, Output = <Self as Index<usize>>::Output>);\n+   |                         ^\n \n error: aborting due to previous error\n "}, {"sha": "9f5968399a37d8a730bced19a959071fba7e0bf9", "filename": "src/test/ui/issues/issue-2995.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-2995.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-2995.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2995.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `*const isize` as `&isize`\n   --> $DIR/issue-2995.rs:2:22\n    |\n LL |     let _q: &isize = p as &isize;\n-   |                      ^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                      ^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "d00f3d91b49da640f3a063a9c071155fc7e663ae", "filename": "src/test/ui/issues/issue-45730.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-45730.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fissues%2Fissue-45730.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45730.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,30 +1,24 @@\n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/issue-45730.rs:3:23\n+  --> $DIR/issue-45730.rs:3:28\n    |\n LL |     let x: *const _ = 0 as _;\n-   |                       ^^^^^-\n-   |                            |\n-   |                            help: consider giving more type information\n+   |                            ^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n \n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/issue-45730.rs:5:23\n+  --> $DIR/issue-45730.rs:5:28\n    |\n LL |     let x: *const _ = 0 as *const _;\n-   |                       ^^^^^--------\n-   |                            |\n-   |                            help: consider giving more type information\n+   |                            ^^^^^^^^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n \n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/issue-45730.rs:8:13\n+  --> $DIR/issue-45730.rs:8:44\n    |\n LL |     let x = 0 as *const i32 as *const _ as *mut _;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------\n-   |                                            |\n-   |                                            help: consider giving more type information\n+   |                                            ^^^^^^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n "}, {"sha": "95936de218b8fe5d25de453501655ddde3c5ba76", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -24,41 +24,31 @@ error[E0605]: non-primitive cast: `*const u8` as `&u8`\n   --> $DIR/cast-rfc0401.rs:29:13\n    |\n LL |     let _ = v as &u8;\n-   |             ^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `*const u8` as `E`\n   --> $DIR/cast-rfc0401.rs:30:13\n    |\n LL |     let _ = v as E;\n-   |             ^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `*const u8` as `fn()`\n   --> $DIR/cast-rfc0401.rs:31:13\n    |\n LL |     let _ = v as fn();\n-   |             ^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^ invalid cast\n \n error[E0605]: non-primitive cast: `*const u8` as `(u32,)`\n   --> $DIR/cast-rfc0401.rs:32:13\n    |\n LL |     let _ = v as (u32,);\n-   |             ^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0605]: non-primitive cast: `std::option::Option<&*const u8>` as `*const u8`\n   --> $DIR/cast-rfc0401.rs:33:13\n    |\n LL |     let _ = Some(&v) as *const u8;\n-   |             ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error[E0606]: casting `*const u8` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:35:13\n@@ -102,7 +92,7 @@ error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/cast-rfc0401.rs:41:13\n    |\n LL |     let _ = 0x61u32 as char;\n-   |             ^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^^^ invalid cast\n \n error[E0606]: casting `bool` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:43:13"}, {"sha": "d39b0a3207763a37eb1f89165afd06be0bd5dcca", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -17,12 +17,11 @@ error[E0605]: non-primitive cast: `{integer}` as `()`\n   --> $DIR/issue-26480.rs:22:19\n    |\n LL |     ($x:expr) => ($x as ())\n-   |                   ^^^^^^^^\n+   |                   ^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n ...\n LL |     cast!(2);\n    |     --------- in this macro invocation\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "0a4b98469b2b6c356b60af5f9aac6dc47a03f464", "filename": "src/test/ui/nonscalar-cast.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fnonscalar-cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fnonscalar-cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnonscalar-cast.fixed?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    x: isize\n+}\n+\n+impl From<Foo> for isize {\n+    fn from(val: Foo) -> isize {\n+        val.x\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{}\", isize::from(Foo { x: 1 })); //~ non-primitive cast: `Foo` as `isize` [E0605]\n+}"}, {"sha": "59fcf09666b24f32aa36a63b8029b8acd1064dba", "filename": "src/test/ui/nonscalar-cast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnonscalar-cast.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,8 +1,16 @@\n+// run-rustfix\n+\n #[derive(Debug)]\n struct Foo {\n     x: isize\n }\n \n+impl From<Foo> for isize {\n+    fn from(val: Foo) -> isize {\n+        val.x\n+    }\n+}\n+\n fn main() {\n     println!(\"{}\", Foo { x: 1 } as isize); //~ non-primitive cast: `Foo` as `isize` [E0605]\n }"}, {"sha": "2a7037121876d8725202c24c4131c23e8b811df4", "filename": "src/test/ui/nonscalar-cast.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fnonscalar-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fnonscalar-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnonscalar-cast.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,10 +1,10 @@\n error[E0605]: non-primitive cast: `Foo` as `isize`\n-  --> $DIR/nonscalar-cast.rs:7:20\n+  --> $DIR/nonscalar-cast.rs:15:20\n    |\n LL |     println!(\"{}\", Foo { x: 1 } as isize);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^^^^^^^^^^ help: consider using the `From` trait instead: `isize::from(Foo { x: 1 })`\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   = note: an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "1b1e0d9610724b6e83c1a48c19e2a0ff427fb158", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,13 +1,13 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n-   |             --------------- data with this lifetime...\n+   |             --------------- this data with an anonymous lifetime `'_`...\n ...\n LL |     ss.r\n-   |     ^^^^ ...is captured and required to be `'static` here\n+   |     ^^^^ ...is captured and required to live as long as `'static` here\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #2 defined on the function body at 14:1\n+help: to declare that the trait object captures data from argument `ss`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait + '_> {\n    |                                                   ^^^^\n@@ -23,4 +23,5 @@ LL |     ss.r = b;\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0621`.\n+Some errors have detailed explanations: E0621, E0759.\n+For more information about an error, try `rustc --explain E0621`."}, {"sha": "9f4ac0fea36ef03ba41bb048a197ad87627bb0af", "filename": "src/test/ui/order-dependent-cast-inference.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Forder-dependent-cast-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Forder-dependent-cast-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Forder-dependent-cast-inference.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,10 +1,8 @@\n error[E0641]: cannot cast to a pointer of an unknown kind\n-  --> $DIR/order-dependent-cast-inference.rs:5:17\n+  --> $DIR/order-dependent-cast-inference.rs:5:22\n    |\n LL |     let mut y = 0 as *const _;\n-   |                 ^^^^^--------\n-   |                      |\n-   |                      help: consider giving more type information\n+   |                      ^^^^^^^^ needs more type information\n    |\n    = note: the type information given here is insufficient to check whether the pointer cast is valid\n "}, {"sha": "7f58f5df2d4125786ff200cc557cd910d1338554", "filename": "src/test/ui/parser/let-binop.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fparser%2Flet-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fparser%2Flet-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flet-binop.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let a: i8 *= 1; //~ ERROR can't reassign to an uninitialized variable\n+    let _ = a;\n+    let b += 1; //~ ERROR can't reassign to an uninitialized variable\n+    let _ = b;\n+    let c *= 1; //~ ERROR can't reassign to an uninitialized variable\n+    let _ = c;\n+}"}, {"sha": "71431499ac70b8c0ea43c7e8db333fac646da5e4", "filename": "src/test/ui/parser/let-binop.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fparser%2Flet-binop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fparser%2Flet-binop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flet-binop.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,20 @@\n+error: can't reassign to an uninitialized variable\n+  --> $DIR/let-binop.rs:2:15\n+   |\n+LL |     let a: i8 *= 1;\n+   |               ^^ help: initialize the variable\n+\n+error: can't reassign to an uninitialized variable\n+  --> $DIR/let-binop.rs:4:11\n+   |\n+LL |     let b += 1;\n+   |           ^^ help: initialize the variable\n+\n+error: can't reassign to an uninitialized variable\n+  --> $DIR/let-binop.rs:6:11\n+   |\n+LL |     let c *= 1;\n+   |           ^^ help: initialize the variable\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7e8f78067e08af9d8d699016cb12f2e4026488e3", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,21 +1,21 @@\n-error[E0621]: explicit lifetime required in the type of `v`\n+error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:8:12\n    |\n LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         - let's call the lifetime of this reference `'1`\n LL |     let x: Box<dyn Foo + 'static> = Box::new(v);\n-   |            ^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required\n+   |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'1` must outlive `'static`\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:14:5\n+error: lifetime may not live long enough\n+  --> $DIR/region-object-lifetime-in-coercion.rs:13:5\n    |\n LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         - let's call the lifetime of this reference `'1`\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/region-object-lifetime-in-coercion.rs:20:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:19:5\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n    |         - let's call the lifetime of this reference `'1`\n@@ -24,7 +24,7 @@ LL |     Box::new(v)\n    |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:5\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      -- -- lifetime `'b` defined here\n@@ -37,4 +37,3 @@ LL |     Box::new(v)\n \n error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0621`."}, {"sha": "5d199149c39b860d029bc80728988afe33c76b25", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -5,13 +5,12 @@ trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    let x: Box<dyn Foo + 'static> = Box::new(v);\n-    //~^ ERROR explicit lifetime required in the type of `v` [E0621]\n+    let x: Box<dyn Foo + 'static> = Box::new(v); //~ ERROR cannot infer an appropriate lifetime\n     x\n }\n \n fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    Box::new(v) //~ ERROR explicit lifetime required in the type of `v` [E0621]\n+    Box::new(v) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn c(v: &[u8]) -> Box<dyn Foo> {"}, {"sha": "7f5a3a47976c7d38f812fa9fb9a1232657dd2a1c", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,61 +1,76 @@\n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:8:37\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:8:46\n    |\n LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         ----- this data with an anonymous lifetime `'_`...\n LL |     let x: Box<dyn Foo + 'static> = Box::new(v);\n-   |                                     ^^^^^^^^^^^ lifetime `'static` required\n+   |                                              ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn a(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn a(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ^^^^^^^^^^^^^\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:14:5\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:13:14\n    |\n LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         ----- this data with an anonymous lifetime `'_`...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |              ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn b(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn b(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ^^^^^^^^^^^^^\n \n-error: cannot infer an appropriate lifetime\n-  --> $DIR/region-object-lifetime-in-coercion.rs:20:14\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:19:14\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n-   |         ----- data with this lifetime...\n+   |         ----- this data with an anonymous lifetime `'_`...\n ...\n LL |     Box::new(v)\n-   |     ---------^-\n-   |     |        |\n-   |     |        ...and is captured here\n-   |     ...is required to be `'static` by this...\n+   |              ^ ...is captured here, requiring it to live as long as `'static`\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 17:1\n+help: to declare that the trait object captures data from argument `v`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo + '_> {\n    |                               ^^^^\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:14\n    |\n LL |     Box::new(v)\n    |              ^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 23:6...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:23:6\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:6...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:22:6\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:14\n    |\n LL |     Box::new(v)\n    |              ^\n    = note: expected `&[u8]`\n               found `&'a [u8]`\n-note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 23:9...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:23:9\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 22:9...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:22:9\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |         ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:5\n    |\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^\n@@ -64,5 +79,5 @@ LL |     Box::new(v)\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0495, E0621.\n+Some errors have detailed explanations: E0495, E0759.\n For more information about an error, try `rustc --explain E0495`."}, {"sha": "114e4052aae09b63159cc61e3899af7c0e982403", "filename": "src/test/ui/regions/regions-close-object-into-object-2.stderr", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,28 +1,20 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/regions-close-object-into-object-2.rs:10:11\n    |\n+LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n+   |                         ------------------ this data with lifetime `'a`...\n LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:6...\n-  --> $DIR/regions-close-object-into-object-2.rs:9:6\n+   |           ^^^ ...is captured here, requiring it to live as long as `'static`\n    |\n-LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n-   |      ^^\n-note: ...so that the type `(dyn A<T> + 'a)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-2.rs:10:11\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/regions-close-object-into-object-2.rs:10:5\n+LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'a> {\n+   |                                                            ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `std::boxed::Box<(dyn X + 'static)>`\n-              found `std::boxed::Box<dyn X>`\n+LL | fn g<'a, T: 'static>(v: std::boxed::Box<(dyn A<T> + 'static)>) -> Box<dyn X + 'static> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "850d81940791fd168afbe9224765cf642bbaaf61", "filename": "src/test/ui/regions/regions-close-object-into-object-4.stderr", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,28 +1,20 @@\n-error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/regions-close-object-into-object-4.rs:10:11\n    |\n+LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n+   |                   ---------------- this data with lifetime `'a`...\n LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 9:6...\n-  --> $DIR/regions-close-object-into-object-4.rs:9:6\n+   |           ^^^ ...is captured here, requiring it to live as long as `'static`\n    |\n-LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n-   |      ^^\n-note: ...so that the type `(dyn A<U> + 'a)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-4.rs:10:11\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |           ^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/regions-close-object-into-object-4.rs:10:5\n+LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'a> {\n+   |                                                    ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n    |\n-LL |     box B(&*v) as Box<dyn X>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `std::boxed::Box<(dyn X + 'static)>`\n-              found `std::boxed::Box<dyn X>`\n+LL | fn i<'a, T, U>(v: std::boxed::Box<(dyn A<U> + 'static)>) -> Box<dyn X + 'static> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "75890b8581537fc7b6ef6d36a42c00cdc94a232f", "filename": "src/test/ui/regions/regions-proc-bound-capture.nll.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regions-proc-bound-capture.rs:9:5\n+   |\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   - let's call the lifetime of this reference `'1`\n+LL |     // This is illegal, because the region bound on `proc` is 'static.\n+LL |     Box::new(move || { *x })\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8617c0e9da8f76f51a6319847965b265e8aff148", "filename": "src/test/ui/regions/regions-proc-bound-capture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -4,9 +4,9 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<dyn FnMut()->(isize) + 'a> {\n     Box::new(move|| { *x })\n }\n \n-fn static_proc(x: &isize) -> Box<dyn FnMut()->(isize) + 'static> {\n+fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move|| { *x }) //~ ERROR explicit lifetime required in the type of `x` [E0621]\n+    Box::new(move || { *x }) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "67eee3bb6e28127bbd8db3417d40386340b6a38f", "filename": "src/test/ui/regions/regions-proc-bound-capture.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,12 +1,21 @@\n-error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/regions-proc-bound-capture.rs:9:5\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/regions-proc-bound-capture.rs:9:14\n    |\n-LL | fn static_proc(x: &isize) -> Box<dyn FnMut()->(isize) + 'static> {\n-   |                   ------ help: add explicit lifetime `'static` to the type of `x`: `&'static isize`\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   ------ this data with an anonymous lifetime `'_`...\n LL |     // This is illegal, because the region bound on `proc` is 'static.\n-LL |     Box::new(move|| { *x })\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'static` required\n+LL |     Box::new(move || { *x })\n+   |              ^^^^^^^^^^^^^^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + '_> {\n+   |                                                           ^^\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn static_proc(x: &'static isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   ^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0621`.\n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "88bd990b1e81b095e1c01ce8da9f0802b787ff90", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,11 +1,12 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:16\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ^^^^  ----------     ---------- ...and required to be `'static` by this\n+   |                ^^^^  ----------     ---------- ...and is required to live as long as `'static` here\n    |                |     |\n-   |                |     data with this lifetime...\n+   |                |     this data with an anonymous lifetime `'_`...\n    |                ...is captured here...\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "2e10ab3d3f9b84a8c1802524008ab8020e311bd2", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,16 +1,21 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ----------     ----------   ^^^^ ...and is captured here\n-   |                |              |\n-   |                |              ...is required to be `'static` by this...\n-   |                data with this lifetime...\n+   |                ----------                  ^^^^ ...is captured here...\n+   |                |\n+   |                this data with an anonymous lifetime `'_`...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n+   |\n+LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n+   |                               ^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                          ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "9ab060328537b56b08f0f3dcf6b023edfcd3fea5", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -6,20 +6,23 @@ LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |        |\n    |        help: consider introducing lifetime `'a` here: `'a,`\n \n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/missing-lifetimes-in-signature.rs:19:5\n    |\n LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n-   |                            ------     ------------- ...is required to be `'static` by this...\n-   |                            |\n-   |                            data with this lifetime...\n+   |                            ------ this data with an anonymous lifetime `'_`...\n ...\n LL | /     move || {\n LL | |         *dest = g.get();\n LL | |     }\n-   | |_____^ ...and is captured here\n+   | |_____^ ...is captured here...\n    |\n-help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 15:1\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/missing-lifetimes-in-signature.rs:15:37\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                                     ^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `dest`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |                                                   ^^^^\n@@ -122,5 +125,5 @@ LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n \n error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0261, E0309, E0621.\n+Some errors have detailed explanations: E0261, E0309, E0621, E0759.\n For more information about an error, try `rustc --explain E0261`."}, {"sha": "4cbfe58d357038ac3e4d6157ea6d60c1cb41df2b", "filename": "src/test/ui/suggestions/type-not-found-in-adt-field.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,9 @@\n+struct Struct {\n+    m: Vec<Someunknownname<String, ()>>, //~ ERROR cannot find type `Someunknownname` in this scope\n+    //~^ NOTE not found in this scope\n+}\n+struct OtherStruct { //~ HELP you might be missing a type parameter\n+    m: K, //~ ERROR cannot find type `K` in this scope\n+    //~^ NOTE not found in this scope\n+}\n+fn main() {}"}, {"sha": "e990fb5ba12107c67dbe22e3abdc2259a99cddb5", "filename": "src/test/ui/suggestions/type-not-found-in-adt-field.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-not-found-in-adt-field.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,17 @@\n+error[E0412]: cannot find type `Someunknownname` in this scope\n+  --> $DIR/type-not-found-in-adt-field.rs:2:12\n+   |\n+LL |     m: Vec<Someunknownname<String, ()>>,\n+   |            ^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `K` in this scope\n+  --> $DIR/type-not-found-in-adt-field.rs:6:8\n+   |\n+LL | struct OtherStruct {\n+   |                   - help: you might be missing a type parameter: `<K>`\n+LL |     m: K,\n+   |        ^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "53e68c2ac6af64dc9ec6f6c1c7c59c10fe9726c7", "filename": "src/test/ui/tag-variant-cast-non-nullary.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.fixed?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n+enum NonNullary {\n+    Nullary,\n+    Other(isize),\n+}\n+\n+impl From<NonNullary> for isize {\n+    fn from(val: NonNullary) -> isize {\n+        match val {\n+            NonNullary::Nullary => 0,\n+            NonNullary::Other(i) => i,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let v = NonNullary::Nullary;\n+    let val = isize::from(v); //~ ERROR non-primitive cast: `NonNullary` as `isize` [E0605]\n+}"}, {"sha": "0d0c6188ad114f2d3cb5c8efd121092f228ab320", "filename": "src/test/ui/tag-variant-cast-non-nullary.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.rs?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,8 +1,19 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n enum NonNullary {\n     Nullary,\n     Other(isize),\n }\n \n+impl From<NonNullary> for isize {\n+    fn from(val: NonNullary) -> isize {\n+        match val {\n+            NonNullary::Nullary => 0,\n+            NonNullary::Other(i) => i,\n+        }\n+    }\n+}\n+\n fn main() {\n     let v = NonNullary::Nullary;\n     let val = v as isize; //~ ERROR non-primitive cast: `NonNullary` as `isize` [E0605]"}, {"sha": "ae2f5a7aead552f9346eb0a231865d2d2690ce62", "filename": "src/test/ui/tag-variant-cast-non-nullary.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-cast-non-nullary.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,10 +1,10 @@\n error[E0605]: non-primitive cast: `NonNullary` as `isize`\n-  --> $DIR/tag-variant-cast-non-nullary.rs:8:15\n+  --> $DIR/tag-variant-cast-non-nullary.rs:19:15\n    |\n LL |     let val = v as isize;\n-   |               ^^^^^^^^^^\n+   |               ^^^^^^^^^^ help: consider using the `From` trait instead: `isize::from(v)`\n    |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   = note: an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}, {"sha": "a6b7e35b488b17388d9fc2502c64001a8d0c9aa6", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -16,9 +16,7 @@ error[E0605]: non-primitive cast: `impl std::fmt::Debug` as `&'static str`\n   --> $DIR/never_reveal_concrete_type.rs:14:13\n    |\n LL |     let _ = x as &'static str;\n-   |             ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to 2 previous errors\n "}, {"sha": "dda5de431d30944e4e0f9a1f4f6c5c221773c609", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -1,16 +1,17 @@\n-error: cannot infer an appropriate lifetime\n+error[E0759]: cannot infer an appropriate lifetime\n   --> $DIR/dyn-trait-underscore.rs:8:20\n    |\n LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-   |                ---- data with this lifetime...\n+   |                ---- this data with an anonymous lifetime `'_`...\n LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter())\n-   |     ---------------^^^^--- ...is captured and required to be `'static` here\n+   |     ---------------^^^^--- ...is captured and required to live as long as `'static` here\n    |\n-help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 6:1\n+help: to declare that the trait object captures data from argument `items`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n    |                                                   ^^^^\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0759`."}, {"sha": "a9f10dfec994a9e4c7a71ca776e2fca44abb058f", "filename": "src/test/ui/uninhabited/uninhabited-enum-cast.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a39c7787ba246353178e099373b9240be0d9e603/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-enum-cast.stderr?ref=a39c7787ba246353178e099373b9240be0d9e603", "patch": "@@ -2,9 +2,7 @@ error[E0605]: non-primitive cast: `E` as `isize`\n   --> $DIR/uninhabited-enum-cast.rs:4:20\n    |\n LL |     println!(\"{}\", (e as isize).to_string());\n-   |                    ^^^^^^^^^^^^\n-   |\n-   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n+   |                    ^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n \n error: aborting due to previous error\n "}]}