{"sha": "3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYTVkNGE4N2U0ZmQzYTk2Y2Y3ZTk2MjIxMWM4NzVmZTUwNjUwZDQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-04-30T05:52:16Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-01T00:33:08Z"}, "message": "Inline and remove `link_binary_output`.\n\nThis change simplifies things for the subsequent commit.", "tree": {"sha": "725af0cb707ed0252a3d986f75f08e79b148e5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/725af0cb707ed0252a3d986f75f08e79b148e5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "html_url": "https://github.com/rust-lang/rust/commit/3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3da5d4a87e4fd3a96cf7e962211c875fe50650d4/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf5eac854f9099b54854145f2307cae3f3aa768", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf5eac854f9099b54854145f2307cae3f3aa768", "html_url": "https://github.com/rust-lang/rust/commit/faf5eac854f9099b54854145f2307cae3f3aa768"}], "stats": {"total": 135, "additions": 61, "deletions": 74}, "files": [{"sha": "f80618441054af2be9bbeaa7c1f294ff7bdafb07", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 61, "deletions": 74, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3da5d4a87e4fd3a96cf7e962211c875fe50650d4/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da5d4a87e4fd3a96cf7e962211c875fe50650d4/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=3da5d4a87e4fd3a96cf7e962211c875fe50650d4", "patch": "@@ -63,12 +63,66 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        link_binary_output::<B>(sess,\n-                                codegen_results,\n-                                crate_type,\n-                                outputs,\n-                                crate_name,\n-                                target_cpu);\n+\n+        for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+            check_file_is_writeable(obj, sess);\n+        }\n+\n+        if outputs.outputs.contains_key(&OutputType::Metadata) {\n+            let out_filename = filename_for_metadata(sess, crate_name, outputs);\n+            // To avoid races with another rustc process scanning the output directory,\n+            // we need to write the file somewhere else and atomically move it to its\n+            // final destination, with a `fs::rename` call. In order for the rename to\n+            // always succeed, the temporary file needs to be on the same filesystem,\n+            // which is why we create it inside the output directory specifically.\n+            let metadata_tmpdir = TempFileBuilder::new()\n+                .prefix(\"rmeta\")\n+                .tempdir_in(out_filename.parent().unwrap())\n+                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+            let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n+            match fs::rename(&metadata, &out_filename) {\n+                Ok(_) => {\n+                    if sess.opts.debugging_opts.emit_directives {\n+                        sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n+                            format!(\"metadata file written: {}\", out_filename.display()));\n+                    }\n+                }\n+                Err(e) => sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n+            }\n+        }\n+\n+        let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+            sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+\n+        if outputs.outputs.should_codegen() {\n+            let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n+            match crate_type {\n+                config::CrateType::Rlib => {\n+                    link_rlib::<B>(sess,\n+                              codegen_results,\n+                              RlibFlavor::Normal,\n+                              &out_filename,\n+                              &tmpdir).build();\n+                }\n+                config::CrateType::Staticlib => {\n+                    link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+                }\n+                _ => {\n+                    link_natively::<B>(\n+                        sess,\n+                        crate_type,\n+                        &out_filename,\n+                        codegen_results,\n+                        tmpdir.path(),\n+                        target_cpu,\n+                    );\n+                }\n+            }\n+        }\n+\n+        if sess.opts.cg.save_temps {\n+            let _ = tmpdir.into_path();\n+        }\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n@@ -85,7 +139,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             if let Some(ref obj) = metadata_module.object {\n                 remove(sess, obj);\n             }\n-         }\n+        }\n         if let Some(ref allocator_module) = codegen_results.allocator_module {\n             if let Some(ref obj) = allocator_module.object {\n                 remove(sess, obj);\n@@ -97,73 +151,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n     }\n }\n \n-fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                                                 codegen_results: &CodegenResults,\n-                                                 crate_type: config::CrateType,\n-                                                 outputs: &OutputFilenames,\n-                                                 crate_name: &str,\n-                                                 target_cpu: &str) {\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        check_file_is_writeable(obj, sess);\n-    }\n-\n-    if outputs.outputs.contains_key(&OutputType::Metadata) {\n-        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with a `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n-        match fs::rename(&metadata, &out_filename) {\n-            Ok(_) => {\n-                if sess.opts.debugging_opts.emit_directives {\n-                    sess.parse_sess.span_diagnostic.maybe_emit_json_directive(\n-                        format!(\"metadata file written: {}\", out_filename.display()));\n-                }\n-            }\n-            Err(e) => sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e)),\n-        }\n-    }\n-\n-    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n-        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n-    if outputs.outputs.should_codegen() {\n-        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n-        match crate_type {\n-            config::CrateType::Rlib => {\n-                link_rlib::<B>(sess,\n-                          codegen_results,\n-                          RlibFlavor::Normal,\n-                          &out_filename,\n-                          &tmpdir).build();\n-            }\n-            config::CrateType::Staticlib => {\n-                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n-            }\n-            _ => {\n-                link_natively::<B>(\n-                    sess,\n-                    crate_type,\n-                    &out_filename,\n-                    codegen_results,\n-                    tmpdir.path(),\n-                    target_cpu,\n-                );\n-            }\n-        }\n-    }\n-\n-    if sess.opts.cg.save_temps {\n-        let _ = tmpdir.into_path();\n-    }\n-}\n-\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain"}]}