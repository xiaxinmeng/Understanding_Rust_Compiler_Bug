{"sha": "9946b54823473bae055f1d7833f9f903e9738326", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NDZiNTQ4MjM0NzNiYWUwNTVmMWQ3ODMzZjlmOTAzZTk3MzgzMjY=", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-01-28T17:26:31Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-01-30T22:19:41Z"}, "message": "add suggestion for nested fields", "tree": {"sha": "ef014a6bbafe7ccb7cae29646e9771c1a8078c3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef014a6bbafe7ccb7cae29646e9771c1a8078c3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9946b54823473bae055f1d7833f9f903e9738326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9946b54823473bae055f1d7833f9f903e9738326", "html_url": "https://github.com/rust-lang/rust/commit/9946b54823473bae055f1d7833f9f903e9738326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9946b54823473bae055f1d7833f9f903e9738326/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2de221b0063261140a336c448bf1421170c9a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2de221b0063261140a336c448bf1421170c9a74", "html_url": "https://github.com/rust-lang/rust/commit/f2de221b0063261140a336c448bf1421170c9a74"}], "stats": {"total": 285, "additions": 275, "deletions": 10}, "files": [{"sha": "f489d6c64ea57253e610d690877082e50f387fe2", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9946b54823473bae055f1d7833f9f903e9738326/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9946b54823473bae055f1d7833f9f903e9738326/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=9946b54823473bae055f1d7833f9f903e9738326", "patch": "@@ -36,6 +36,7 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -46,8 +47,6 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n-use std::fmt::Display;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_eq_type(&self, expr: &'tcx hir::Expr<'tcx>, expected: Ty<'tcx>) {\n         let ty = self.check_expr_with_hint(expr, expected);\n@@ -1585,11 +1584,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n     ) -> Ty<'tcx> {\n+        debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n         let expr_t = self.check_expr(base);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {\n+            debug!(\"base_t: {:?}\", base_t);\n             match base_t.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\", base_t);\n@@ -1706,7 +1707,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n             field, base, expr, expr_t\n         );\n-        let mut err = self.no_such_field_err(field.span, field, expr_t);\n+        let mut err = self.no_such_field_err(field, expr_t);\n \n         match *expr_t.peel_refs().kind() {\n             ty::Array(_, len) => {\n@@ -1880,21 +1881,120 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn no_such_field_err<T: Display>(\n+    fn no_such_field_err(\n         &self,\n-        span: Span,\n-        field: T,\n-        expr_t: &ty::TyS<'_>,\n+        field: Ident,\n+        expr_t: &'tcx ty::TyS<'tcx>,\n     ) -> DiagnosticBuilder<'_> {\n-        type_error_struct!(\n+        let span = field.span;\n+        debug!(\"no_such_field_err(span: {:?}, field: {:?}, expr_t: {:?})\", span, field, expr_t);\n+\n+        let mut err = type_error_struct!(\n             self.tcx().sess,\n-            span,\n+            field.span,\n             expr_t,\n             E0609,\n             \"no field `{}` on type `{}`\",\n             field,\n             expr_t\n-        )\n+        );\n+\n+        // try to add a suggestion in case the field is a nested field of a field of the Adt\n+        if let Some((fields, substs)) = self.get_field_candidates(span, &expr_t) {\n+            for candidate_field in fields.iter() {\n+                if let Some(field_path) =\n+                    self.check_for_nested_field(span, field, candidate_field, substs, vec![])\n+                {\n+                    let field_path_str = field_path\n+                        .iter()\n+                        .map(|id| id.name.to_ident_string())\n+                        .collect::<Vec<String>>()\n+                        .join(\".\");\n+                    debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                    err.span_suggestion_verbose(\n+                        field.span.shrink_to_lo(),\n+                        \"one of the expressions' fields has a field of the same name\",\n+                        format!(\"{}.\", field_path_str),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+        err\n+    }\n+\n+    fn get_field_candidates(\n+        &self,\n+        span: Span,\n+        base_t: Ty<'tcx>,\n+    ) -> Option<(&Vec<ty::FieldDef>, SubstsRef<'tcx>)> {\n+        debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_t);\n+\n+        let mut autoderef = self.autoderef(span, base_t);\n+        while let Some((base_t, _)) = autoderef.next() {\n+            match base_t.kind() {\n+                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n+                    let fields = &base_def.non_enum_variant().fields;\n+                    // For compile-time reasons put a limit on number of fields we search\n+                    if fields.len() > 100 {\n+                        return None;\n+                    }\n+                    return Some((fields, substs));\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    /// This method is called after we have encountered a missing field error to recursively\n+    /// search for the field\n+    fn check_for_nested_field(\n+        &self,\n+        span: Span,\n+        target_field: Ident,\n+        candidate_field: &ty::FieldDef,\n+        subst: SubstsRef<'tcx>,\n+        mut field_path: Vec<Ident>,\n+    ) -> Option<Vec<Ident>> {\n+        debug!(\n+            \"check_for_nested_field(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n+            span, candidate_field, field_path\n+        );\n+\n+        if candidate_field.ident == target_field {\n+            Some(field_path)\n+        } else if field_path.len() > 3 {\n+            // For compile-time reasons and to avoid infinite recursion we only check for fields\n+            // up to a depth of three\n+            None\n+        } else {\n+            // recursively search fields of `candidate_field` if it's a ty::Adt\n+\n+            field_path.push(candidate_field.ident.normalize_to_macros_2_0());\n+            let field_ty = candidate_field.ty(self.tcx, subst);\n+            if let Some((nested_fields, _)) = self.get_field_candidates(span, &field_ty) {\n+                for field in nested_fields.iter() {\n+                    let ident = field.ident.normalize_to_macros_2_0();\n+                    if ident == target_field {\n+                        return Some(field_path);\n+                    } else {\n+                        let field_path = field_path.clone();\n+                        if let Some(path) = self.check_for_nested_field(\n+                            span,\n+                            target_field,\n+                            field,\n+                            subst,\n+                            field_path,\n+                        ) {\n+                            return Some(path);\n+                        }\n+                    }\n+                }\n+            }\n+            None\n+        }\n     }\n \n     fn check_expr_index("}, {"sha": "98b408daa022de8351b14b01ee1f730e4cf36f40", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield-recursion-limit.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.rs?ref=9946b54823473bae055f1d7833f9f903e9738326", "patch": "@@ -0,0 +1,43 @@\n+// In rustc_typeck::check::expr::no_such_field_err we recursively\n+// look in subfields for the field. This recursive search is limited\n+// in depth for compile-time reasons and to avoid infinite recursion\n+// in case of cycles. This file tests that the limit in the recursion\n+// depth is enforced.\n+\n+struct Foo {\n+    first: Bar,\n+    second: u32,\n+    third: u32,\n+}\n+\n+struct Bar {\n+    bar: C,\n+}\n+\n+struct C {\n+    c: D,\n+}\n+\n+struct D {\n+    test: E,\n+}\n+\n+struct E {\n+    e: F,\n+}\n+\n+struct F {\n+    f: u32,\n+}\n+\n+fn main() {\n+    let f = F { f: 6 };\n+    let e = E { e: f };\n+    let d = D { test: e };\n+    let c = C { c: d };\n+    let bar = Bar { bar: c };\n+    let fooer = Foo { first: bar, second: 4, third: 5 };\n+\n+    let test = fooer.f;\n+    //~^ ERROR no field\n+}"}, {"sha": "b294f4da7db33394e61631e6bfbfb214bd71505d", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield-recursion-limit.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.stderr?ref=9946b54823473bae055f1d7833f9f903e9738326", "patch": "@@ -0,0 +1,11 @@\n+error[E0609]: no field `f` on type `Foo`\n+  --> $DIR/non-existent-field-present-in-subfield-recursion-limit.rs:41:22\n+   |\n+LL |     let test = fooer.f;\n+   |                      ^ unknown field\n+   |\n+   = note: available fields are: `first`, `second`, `third`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "167548a89defa0d74a2af619e70e2f81d68f7e74", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield.fixed", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.fixed?ref=9946b54823473bae055f1d7833f9f903e9738326", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+\n+struct Foo {\n+    first: Bar,\n+    _second: u32,\n+    _third: u32,\n+}\n+\n+struct Bar {\n+    bar: C,\n+}\n+\n+struct C {\n+    c: D,\n+}\n+\n+struct D {\n+    test: E,\n+}\n+\n+struct E {\n+    _e: F,\n+}\n+\n+struct F {\n+    _f: u32,\n+}\n+\n+fn main() {\n+    let f = F { _f: 6 };\n+    let e = E { _e: f };\n+    let d = D { test: e };\n+    let c = C { c: d };\n+    let bar = Bar { bar: c };\n+    let fooer = Foo { first: bar, _second: 4, _third: 5 };\n+\n+    let _test = &fooer.first.bar.c;\n+    //~^ ERROR no field\n+\n+    let _test2 = fooer.first.bar.c.test;\n+    //~^ ERROR no field\n+}"}, {"sha": "81cc1af4dff52f40f9b34d2e2559547128a03f5f", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.rs?ref=9946b54823473bae055f1d7833f9f903e9738326", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+\n+struct Foo {\n+    first: Bar,\n+    _second: u32,\n+    _third: u32,\n+}\n+\n+struct Bar {\n+    bar: C,\n+}\n+\n+struct C {\n+    c: D,\n+}\n+\n+struct D {\n+    test: E,\n+}\n+\n+struct E {\n+    _e: F,\n+}\n+\n+struct F {\n+    _f: u32,\n+}\n+\n+fn main() {\n+    let f = F { _f: 6 };\n+    let e = E { _e: f };\n+    let d = D { test: e };\n+    let c = C { c: d };\n+    let bar = Bar { bar: c };\n+    let fooer = Foo { first: bar, _second: 4, _third: 5 };\n+\n+    let _test = &fooer.c;\n+    //~^ ERROR no field\n+\n+    let _test2 = fooer.test;\n+    //~^ ERROR no field\n+}"}, {"sha": "ddb7476ec6e34b4a355ea11003cc0e1e215bff08", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9946b54823473bae055f1d7833f9f903e9738326/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.stderr?ref=9946b54823473bae055f1d7833f9f903e9738326", "patch": "@@ -0,0 +1,27 @@\n+error[E0609]: no field `c` on type `Foo`\n+  --> $DIR/non-existent-field-present-in-subfield.rs:37:24\n+   |\n+LL |     let _test = &fooer.c;\n+   |                        ^ unknown field\n+   |\n+   = note: available fields are: `first`, `_second`, `_third`\n+help: one of the expressions' fields has a field of the same name\n+   |\n+LL |     let _test = &fooer.first.bar.c;\n+   |                        ^^^^^^^^^^\n+\n+error[E0609]: no field `test` on type `Foo`\n+  --> $DIR/non-existent-field-present-in-subfield.rs:40:24\n+   |\n+LL |     let _test2 = fooer.test;\n+   |                        ^^^^ unknown field\n+   |\n+   = note: available fields are: `first`, `_second`, `_third`\n+help: one of the expressions' fields has a field of the same name\n+   |\n+LL |     let _test2 = fooer.first.bar.c.test;\n+   |                        ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0609`."}]}