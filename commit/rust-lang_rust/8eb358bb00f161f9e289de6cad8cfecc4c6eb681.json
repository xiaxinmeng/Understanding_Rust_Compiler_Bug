{"sha": "8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYjM1OGJiMDBmMTYxZjllMjg5ZGU2Y2FkOGNmZWNjNGM2ZWI2ODE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T05:38:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T07:18:07Z"}, "message": "core::rt: Begin recording scheduler metrics", "tree": {"sha": "9c884ef810bc30c2b70b319669a7f450bb98e5ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c884ef810bc30c2b70b319669a7f450bb98e5ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "html_url": "https://github.com/rust-lang/rust/commit/8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b", "html_url": "https://github.com/rust-lang/rust/commit/ca2eebd5dd8ceea1da77b6a6f4fb8c68462a400b"}], "stats": {"total": 131, "additions": 123, "deletions": 8}, "files": [{"sha": "19fb809d4378e12ad06ce387485e9e83fa725932", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "patch": "@@ -119,16 +119,26 @@ impl<T> ChanOne<T> {\n             match oldstate {\n                 STATE_BOTH => {\n                     // Port is not waiting yet. Nothing to do\n+                    do Local::borrow::<Scheduler> |sched| {\n+                        rtdebug!(\"non-rendezvous send\");\n+                        sched.metrics.non_rendezvous_sends += 1;\n+                    }\n                 }\n                 STATE_ONE => {\n+                    do Local::borrow::<Scheduler> |sched| {\n+                        rtdebug!(\"rendezvous send\");\n+                        sched.metrics.rendezvous_sends += 1;\n+                    }\n                     // Port has closed. Need to clean up.\n                     let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n                     recvr_active = false;\n                 }\n                 task_as_state => {\n                     // Port is blocked. Wake it up.\n                     let recvr: ~Coroutine = cast::transmute(task_as_state);\n-                    let sched = Local::take::<Scheduler>();\n+                    let mut sched = Local::take::<Scheduler>();\n+                    rtdebug!(\"rendezvous send\");\n+                    sched.metrics.rendezvous_sends += 1;\n                     sched.schedule_task(recvr);\n                 }\n             }\n@@ -170,18 +180,19 @@ impl<T> PortOne<T> {\n                 match oldstate {\n                     STATE_BOTH => {\n                         // Data has not been sent. Now we're blocked.\n+                        rtdebug!(\"non-rendezvous recv\");\n+                        sched.metrics.non_rendezvous_recvs += 1;\n                     }\n                     STATE_ONE => {\n+                        rtdebug!(\"rendezvous recv\");\n+                        sched.metrics.rendezvous_recvs += 1;\n+\n                         // Channel is closed. Switch back and check the data.\n                         // NB: We have to drop back into the scheduler event loop here\n                         // instead of switching immediately back or we could end up\n                         // triggering infinite recursion on the scheduler's stack.\n                         let task: ~Coroutine = cast::transmute(task_as_state);\n-                        let task = Cell(task);\n-                        do sched.event_loop.callback {\n-                            let sched = Local::take::<Scheduler>();\n-                            sched.resume_task_immediately(task.take());\n-                        }\n+                        sched.enqueue_task(task);\n                     }\n                     _ => util::unreachable()\n                 }"}, {"sha": "70e347fdfb6ac6476cb107d12c32b903b5ebb161", "filename": "src/libstd/rt/metrics.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmetrics.rs?ref=8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use to_str::ToStr;\n+\n+pub struct SchedMetrics {\n+    // The number of times executing `run_sched_once`.\n+    turns: uint,\n+    // The number of turns that received a message.\n+    messages_received: uint,\n+    // The number of turns that ran a task from the queue.\n+    tasks_resumed_from_queue: uint,\n+    // The number of turns that found no work to perform.\n+    wasted_turns: uint,\n+    // The number of times the scheduler went to sleep.\n+    sleepy_times: uint,\n+    // Context switches from the scheduler into a task.\n+    context_switches_sched_to_task: uint,\n+    // Context switches from a task into the scheduler.\n+    context_switches_task_to_sched: uint,\n+    // Context switches from a task to a task.\n+    context_switches_task_to_task: uint,\n+    // Message sends that unblock the receiver\n+    rendezvous_sends: uint,\n+    // Message sends that do not unblock the receiver\n+    non_rendezvous_sends: uint,\n+    // Message receives that do not block the receiver\n+    rendezvous_recvs: uint,\n+    // Message receives that block the receiver\n+    non_rendezvous_recvs: uint\n+}\n+\n+impl SchedMetrics {\n+    pub fn new() -> SchedMetrics {\n+        SchedMetrics {\n+            turns: 0,\n+            messages_received: 0,\n+            tasks_resumed_from_queue: 0,\n+            wasted_turns: 0,\n+            sleepy_times: 0,\n+            context_switches_sched_to_task: 0,\n+            context_switches_task_to_sched: 0,\n+            context_switches_task_to_task: 0,\n+            rendezvous_sends: 0,\n+            non_rendezvous_sends: 0,\n+            rendezvous_recvs: 0,\n+            non_rendezvous_recvs: 0\n+        }\n+    }\n+}\n+\n+impl ToStr for SchedMetrics {\n+    fn to_str(&self) -> ~str {\n+        fmt!(\"turns: %u\\n\\\n+              messages_received: %u\\n\\\n+              tasks_resumed_from_queue: %u\\n\\\n+              wasted_turns: %u\\n\\\n+              sleepy_times: %u\\n\\\n+              context_switches_sched_to_task: %u\\n\\\n+              context_switches_task_to_sched: %u\\n\\\n+              context_switches_task_to_task: %u\\n\\\n+              rendezvous_sends: %u\\n\\\n+              non_rendezvous_sends: %u\\n\\\n+              rendezvous_recvs: %u\\n\\\n+              non_rendezvous_recvs: %u\\n\\\n+              \",\n+             self.turns,\n+             self.messages_received,\n+             self.tasks_resumed_from_queue,\n+             self.wasted_turns,\n+             self.sleepy_times,\n+             self.context_switches_sched_to_task,\n+             self.context_switches_task_to_sched,\n+             self.context_switches_task_to_task,\n+             self.rendezvous_sends,\n+             self.non_rendezvous_sends,\n+             self.rendezvous_recvs,\n+             self.non_rendezvous_recvs\n+        )\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "23dc7578002223e5d145a59c76f2a569fffaf058", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "patch": "@@ -130,6 +130,8 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n+pub mod metrics;\n+\n \n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///"}, {"sha": "b5b8bb732e7fdadd458dc0ad0c1985d76a0c0b09", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb358bb00f161f9e289de6cad8cfecc4c6eb681/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=8eb358bb00f161f9e289de6cad8cfecc4c6eb681", "patch": "@@ -13,6 +13,7 @@ use sys;\n use cast::transmute;\n use cell::Cell;\n use clone::Clone;\n+use to_str::ToStr;\n \n use super::sleeper_list::SleeperList;\n use super::work_queue::WorkQueue;\n@@ -24,6 +25,7 @@ use super::message_queue::MessageQueue;\n use rt::local_ptr;\n use rt::local::Local;\n use rt::rtio::{IoFactoryObject, RemoteCallback};\n+use rt::metrics::SchedMetrics;\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -63,7 +65,8 @@ pub struct Scheduler {\n     current_task: Option<~Coroutine>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n-    priv cleanup_job: Option<CleanupJob>\n+    priv cleanup_job: Option<CleanupJob>,\n+    metrics: SchedMetrics\n }\n \n pub struct SchedHandle {\n@@ -115,6 +118,7 @@ pub impl Scheduler {\n             saved_context: Context::empty(),\n             current_task: None,\n             cleanup_job: None,\n+            metrics: SchedMetrics::new()\n         }\n     }\n \n@@ -141,20 +145,24 @@ pub impl Scheduler {\n \n         let sched = Local::take::<Scheduler>();\n         assert!(sched.work_queue.is_empty());\n+        rtdebug!(\"scheduler metrics: %s\\n\", sched.metrics.to_str());\n         return sched;\n     }\n \n     fn run_sched_once() {\n \n+        let mut sched = Local::take::<Scheduler>();\n+        sched.metrics.turns += 1;\n+\n         // First, check the message queue for instructions.\n         // XXX: perf. Check for messages without atomics.\n         // It's ok if we miss messages occasionally, as long as\n         // we sync and check again before sleeping.\n-        let sched = Local::take::<Scheduler>();\n         if sched.interpret_message_queue() {\n             // We performed a scheduling action. There may be other work\n             // to do yet, so let's try again later.\n             let mut sched = Local::take::<Scheduler>();\n+            sched.metrics.messages_received += 1;\n             sched.event_loop.callback(Scheduler::run_sched_once);\n             Local::put(sched);\n             return;\n@@ -166,6 +174,7 @@ pub impl Scheduler {\n             // We performed a scheduling action. There may be other work\n             // to do yet, so let's try again later.\n             let mut sched = Local::take::<Scheduler>();\n+            sched.metrics.tasks_resumed_from_queue += 1;\n             sched.event_loop.callback(Scheduler::run_sched_once);\n             Local::put(sched);\n             return;\n@@ -176,8 +185,10 @@ pub impl Scheduler {\n         // somebody can wake us up later.\n         rtdebug!(\"no work to do\");\n         let mut sched = Local::take::<Scheduler>();\n+        sched.metrics.wasted_turns += 1;\n         if !sched.sleepy && !sched.no_sleep {\n             rtdebug!(\"sleeping\");\n+            sched.metrics.sleepy_times += 1;\n             sched.sleepy = true;\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n@@ -327,6 +338,7 @@ pub impl Scheduler {\n         assert!(!this.in_task_context());\n \n         rtdebug!(\"scheduling a task\");\n+        this.metrics.context_switches_sched_to_task += 1;\n \n         // Store the task in the scheduler so it can be grabbed later\n         this.current_task = Some(task);\n@@ -369,6 +381,7 @@ pub impl Scheduler {\n         assert!(this.in_task_context());\n \n         rtdebug!(\"blocking task\");\n+        this.metrics.context_switches_task_to_sched += 1;\n \n         unsafe {\n             let blocked_task = this.current_task.swap_unwrap();\n@@ -401,6 +414,7 @@ pub impl Scheduler {\n         assert!(this.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n+        this.metrics.context_switches_task_to_task += 1;\n \n         let old_running_task = this.current_task.swap_unwrap();\n         let f_fake_region = unsafe {"}]}