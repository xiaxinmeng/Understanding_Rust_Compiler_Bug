{"sha": "5cf5f5024d5efcbb0b399433fa2117e1146292c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZjVmNTAyNGQ1ZWZjYmIwYjM5OTQzM2ZhMjExN2UxMTQ2MjkyYzI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-02T03:55:04Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-02T03:58:16Z"}, "message": "Handle bang functions correctly in typestate\n\nThe logic for how the \"returns\" constraint was handled was always\ndodgy, for reasons explained in the comments I added to\nauxiliary::fn_info in this commit. Fixed it by adding distinct\n\"returns\" and \"diverges\" constraints for each function, which\nare both handled positively (that is: for a ! function, the\n\"diverges\" constraint must be true on every exit path; for\nany other function, the \"returns\" constraint must be true\non every exit path).\n\nCloses #779", "tree": {"sha": "0e3d8a5834748c401ab5d7f67eb76f3ca52e5c0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e3d8a5834748c401ab5d7f67eb76f3ca52e5c0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cf5f5024d5efcbb0b399433fa2117e1146292c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf5f5024d5efcbb0b399433fa2117e1146292c2", "html_url": "https://github.com/rust-lang/rust/commit/5cf5f5024d5efcbb0b399433fa2117e1146292c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cf5f5024d5efcbb0b399433fa2117e1146292c2/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b16ac4c28ab5696d318dc7e414c73e27f9d631", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b16ac4c28ab5696d318dc7e414c73e27f9d631", "html_url": "https://github.com/rust-lang/rust/commit/c9b16ac4c28ab5696d318dc7e414c73e27f9d631"}], "stats": {"total": 176, "additions": 117, "deletions": 59}, "files": [{"sha": "e1a01731ea1a7d7be43d70940fa9ca32f2da636c", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5cf5f5024d5efcbb0b399433fa2117e1146292c2", "patch": "@@ -238,21 +238,58 @@ type norm_constraint = {bit_num: uint, c: sp_constr};\n \n type constr_map = @std::map::hashmap[def_id, constraint];\n \n+/* Contains stuff that has to be computed up front */\n type fn_info =\n-    /* list, accumulated during pre/postcondition\n-     computation, of all local variables that may be\n-     used*/\n-    // Doesn't seem to work without the @ --\n-    // bug?\n     {constrs: constr_map,\n      num_constraints: uint,\n      cf: controlflow,\n+/* For easy access, the fn_info stores two special constraints for each\n+   function.  i_return holds if all control paths in this function terminate\n+   in either a return expression, or an appropriate tail expression.\n+   i_diverge holds if all control paths in this function terminate in a fail\n+   or diverging call.\n+\n+   It might be tempting to use a single constraint C for both properties,\n+   where C represents i_return and !C represents i_diverge. This is\n+   inadvisable, because then the sense of the bit depends on context. If we're\n+   inside a ! function, that reverses the sense of the bit: C would be\n+   i_diverge and !C would be i_return.  That's awkward, because we have to\n+   pass extra context around to functions that shouldn't care.\n+\n+   Okay, suppose C represents i_return and !C represents i_diverge, regardless\n+   of context. Consider this code:\n+\n+     if (foo) { ret; } else { fail; }\n+\n+   C is true in the consequent and false in the alternative. What's T `join`\n+   F, then?  ? doesn't work, because this code should definitely-return if the\n+   context is a returning function (and be definitely-rejected if the context\n+   is a ! function).  F doesn't work, because then the code gets incorrectly\n+   rejected if the context is a returning function. T would work, but it\n+   doesn't make sense for T `join` F to be T (consider init constraints, for\n+   example).;\n+\n+   So we need context. And so it seems clearer to just have separate\n+   constraints.\n+*/\n+     i_return: tsconstr,\n+     i_diverge: tsconstr,\n+    /* list, accumulated during pre/postcondition\n+     computation, of all local variables that may be\n+     used */\n+// Doesn't seem to work without the @ -- bug\n      used_vars: @mutable node_id[]};\n \n fn tsconstr_to_def_id(t: &tsconstr) -> def_id {\n     alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n }\n \n+fn tsconstr_to_node_id(t: &tsconstr) -> node_id {\n+    alt t { ninit(id, _) { id }\n+            npred(_, id, _) {\n+              fail \"tsconstr_to_node_id called on pred constraint\" } }\n+}\n+\n /* mapping from node ID to typestate annotation */\n type node_ann_table = @mutable ts_ann[mutable ];\n \n@@ -261,7 +298,10 @@ type node_ann_table = @mutable ts_ann[mutable ];\n type fn_info_map = @std::map::hashmap[node_id, fn_info];\n \n type fn_ctxt =\n-    {enclosing: fn_info, id: node_id, name: ident, ccx: crate_ctxt};\n+    {enclosing: fn_info,\n+     id: node_id,\n+     name: ident,\n+     ccx: crate_ctxt};\n \n type crate_ctxt = {tcx: ty::ctxt, node_anns: node_ann_table, fm: fn_info_map};\n "}, {"sha": "73b845ac3bfb100ea5efc9a3dd4aefbfcf503661", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=5cf5f5024d5efcbb0b399433fa2117e1146292c2", "patch": "@@ -40,7 +40,7 @@ import std::option::none;\n import aux::*;\n import syntax::print::pprust::ty_to_str;\n import util::common::log_stmt_err;\n-import bitvectors::promises;\n+import bitvectors::*;\n import annotate::annotate_crate;\n import collect_locals::mk_f_to_fn_info;\n import pre_post_conditions::fn_pre_post;\n@@ -141,24 +141,23 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n \n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f.body);\n-    let ret_c: tsconstr = ninit(fcx.id, fcx.name);\n-    if f.proto == ast::proto_fn && !promises(fcx, post, ret_c) &&\n-           !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n-           f.decl.cf == return {\n-        fcx.ccx.tcx.sess.span_note(f.body.span,\n+    if f.proto == ast::proto_fn &&\n+        !promises(fcx, post, fcx.enclosing.i_return) &&\n+        !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n+        f.decl.cf == return {\n+        fcx.ccx.tcx.sess.span_err(f.body.span,\n                                    \"In function \" + fcx.name +\n                                        \", not all control paths \\\n                                         return a value\");\n         fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n                                     \"see declared return type of '\" +\n                                         ty_to_str(*f.decl.output) + \"'\");\n     } else if (f.decl.cf == noreturn) {\n-\n-\n         // check that this really always fails\n-        // the fcx.id bit means \"returns\" for a returning fn,\n-        // \"diverges\" for a non-returning fn\n-        if !promises(fcx, post, ret_c) {\n+        // Note that it's ok for i_diverge and i_return to both be true.\n+        // In fact, i_diverge implies i_return. (But not vice versa!)\n+\n+        if !promises(fcx, post, fcx.enclosing.i_diverge) {\n             fcx.ccx.tcx.sess.span_fatal(f.body.span,\n                                         \"In non-returning function \" +\n                                             fcx.name +"}, {"sha": "3f85007d0cb025b8fb50deaafa50799ea4e57390", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=5cf5f5024d5efcbb0b399433fa2117e1146292c2", "patch": "@@ -109,16 +109,28 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &ty_param[], f_sp: &span,\n         next = add_constraint(cx.tcx, sc, next, res_map);\n     }\n \n-    /* add a pseudo-entry for the function's return value\n-       we can safely use the function's name itself for this purpose */\n+    /* add the special i_diverge and i_return constraints\n+    (see the type definition for auxiliary::fn_info for an explanation) */\n+\n+    // use the name of the function for the \"return\" constraint\n+    next = add_constraint(cx.tcx, respan(f_sp, ninit(id, name)), next,\n+                          res_map);\n+    // and the name of the function, with a '!' appended to it, for the\n+    // \"diverges\" constraint\n+    let diverges_id = ccx.tcx.sess.next_node_id();\n+    let diverges_name = name + \"!\";\n+    add_constraint(cx.tcx, respan(f_sp, ninit(diverges_id, diverges_name)),\n+                   next, res_map);\n \n-    add_constraint(cx.tcx, respan(f_sp, ninit(id, name)), next, res_map);\n     let v: @mutable node_id[] = @mutable ~[];\n     let rslt =\n         {constrs: res_map,\n          num_constraints:\n-             ivec::len(*cx.cs) + ivec::len(f.decl.constraints) + 1u,\n+         // add 2 to account for the i_return and i_diverge constraints\n+             ivec::len(*cx.cs) + ivec::len(f.decl.constraints) + 2u,\n          cf: f.decl.cf,\n+         i_return: ninit(id, name),\n+         i_diverge: ninit(diverges_id, diverges_name),\n          used_vars: v};\n     ccx.fm.insert(id, rslt);\n     log name + \" has \" + std::uint::str(num_constraints(rslt)) +"}, {"sha": "54e53af0ff39a5cc4ec1f11a74a54815a65d73dc", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=5cf5f5024d5efcbb0b399433fa2117e1146292c2", "patch": "@@ -79,6 +79,9 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n                  {constrs: @new_def_hash[constraint](),\n                   num_constraints: 0u,\n                   cf: return,\n+                  // just bogus\n+                  i_return: ninit(0, \"\"),\n+                  i_diverge: ninit(0, \"\"),\n                   used_vars: v},\n              id: 0,\n              name: \"\",\n@@ -692,7 +695,8 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n \n fn find_pre_post_fn(fcx: &fn_ctxt, f: &_fn) {\n     // hack\n-    use_var(fcx, fcx.id);\n+    use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_return));\n+    use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_diverge));\n \n     find_pre_post_block(fcx, f.body);\n "}, {"sha": "66c2b4324ab062404395d66082a62989ae58c8f2", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=5cf5f5024d5efcbb0b399433fa2117e1146292c2", "patch": "@@ -1,26 +1,13 @@\n import syntax::print::pprust::path_to_str;\n+import util::ppaux::ty_to_str;\n import std::ivec;\n import std::option;\n import std::option::get;\n import std::option::is_none;\n import std::option::none;\n import std::option::some;\n import std::option::maybe;\n-import tstate::ann::set_in_poststate_;\n-import tstate::ann::pre_and_post;\n-import tstate::ann::get_post;\n-import tstate::ann::postcond;\n-import tstate::ann::empty_pre_post;\n-import tstate::ann::empty_poststate;\n-import tstate::ann::clear_in_poststate;\n-import tstate::ann::intersect;\n-import tstate::ann::empty_prestate;\n-import tstate::ann::prestate;\n-import tstate::ann::poststate;\n-import tstate::ann::false_postcond;\n-import tstate::ann::ts_ann;\n-import tstate::ann::set_prestate;\n-import tstate::ann::set_poststate;\n+import ann::*;\n import aux::*;\n import tritv::tritv_clone;\n import tritv::tritv_set;\n@@ -189,9 +176,8 @@ fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n     /* if this is a failing call, it sets everything as initialized */\n     alt cf {\n       noreturn. {\n-        changed |=\n-            set_poststate_ann(fcx.ccx, id,\n-                              false_postcond(num_constraints(fcx.enclosing)));\n+        let post = false_postcond(num_constraints(fcx.enclosing));\n+        changed |= set_poststate_ann(fcx.ccx, id, post);\n       }\n       _ { changed |= set_poststate_ann(fcx.ccx, id, rs.post); }\n     }\n@@ -403,15 +389,14 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         /* normally, everything is true if execution continues after\n            a ret expression (since execution never continues locally\n            after a ret expression */\n+// FIXME should factor this out\n+        let post = false_postcond(num_constrs);\n+        // except for the \"diverges\" bit...\n+        kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n \n-        set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n-        /* return from an always-failing function clears the return bit */\n+        set_poststate_ann(fcx.ccx, e.id, post);\n \n-        alt fcx.enclosing.cf {\n-          noreturn. { kill_poststate(fcx, e.id, ninit(fcx.id, fcx.name)); }\n-          _ { }\n-        }\n-        alt maybe_ret_val {\n+       alt maybe_ret_val {\n           none. {/* do nothing */ }\n           some(ret_val) {\n             changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n@@ -421,7 +406,10 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       }\n       expr_be(val) {\n         let changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-        set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs));\n+        let post = false_postcond(num_constrs);\n+        // except for the \"diverges\" bit...\n+        kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n+        set_poststate_ann(fcx.ccx, e.id, post);\n         ret changed | find_pre_post_state_expr(fcx, pres, val);\n       }\n       expr_if(antec, conseq, maybe_alt) {\n@@ -558,12 +546,20 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n       }\n       expr_fail(maybe_fail_val) {\n+        // FIXME Should factor out this code,\n+        // which also appears in find_pre_post_state_exprs\n+        /* if execution continues after fail, then everything is true!\n+        woo! */\n+        let post = false_postcond(num_constrs);\n+        alt fcx.enclosing.cf {\n+          noreturn. {\n+            kill_poststate_(fcx, ninit(fcx.id, fcx.name), post);\n+          }\n+          _ {}\n+        }\n         ret set_prestate_ann(fcx.ccx, e.id, pres) |\n-                /* if execution continues after fail, then everything is true!\n-                   woo! */\n-                set_poststate_ann(fcx.ccx, e.id, false_postcond(num_constrs))\n-                |\n-                alt maybe_fail_val {\n+            set_poststate_ann(fcx.ccx, e.id, post)\n+                | alt maybe_fail_val {\n                   none. { false }\n                   some(fail_val) {\n                     find_pre_post_state_expr(fcx, pres, fail_val)\n@@ -710,9 +706,11 @@ fn find_pre_post_state_block(fcx: &fn_ctxt, pres0: &prestate, b: &blk) ->\n \n fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n \n-    let num_local_vars = num_constraints(fcx.enclosing);\n-    // make sure the return bit starts out False\n-    clear_in_prestate_ident(fcx, fcx.id, fcx.name, f.body.node.id);\n+    let num_constrs = num_constraints(fcx.enclosing);\n+    // make sure the return and diverge bits start out False\n+    kill_prestate(fcx, f.body.node.id, fcx.enclosing.i_return);\n+    kill_prestate(fcx, f.body.node.id, fcx.enclosing.i_diverge);\n+\n     // Instantiate any constraints on the arguments so we can use them\n     let block_pre = block_prestate(fcx.ccx, f.body);\n     let tsc;\n@@ -728,15 +726,16 @@ fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n       some(tailexpr) {\n         let tailty = expr_ty(fcx.ccx.tcx, tailexpr);\n \n-\n         // Since blocks and alts and ifs that don't have results\n         // implicitly result in nil, we have to be careful to not\n         // interpret nil-typed block results as the result of a\n         // function with some other return type\n         if !type_is_nil(fcx.ccx.tcx, tailty) &&\n                !type_is_bot(fcx.ccx.tcx, tailty) {\n-            let p = false_postcond(num_local_vars);\n-            set_poststate_ann(fcx.ccx, f.body.node.id, p);\n+            let post = false_postcond(num_constrs);\n+            // except for the \"diverges\" bit...\n+            kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n+            set_poststate_ann(fcx.ccx, f.body.node.id, post);\n         }\n       }\n       none. {/* fallthrough */ }"}, {"sha": "946a39b680256818cf0941ea2e7340855cb29854", "filename": "src/test/compile-fail/bang-tailexpr.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cf5f5024d5efcbb0b399433fa2117e1146292c2/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs?ref=5cf5f5024d5efcbb0b399433fa2117e1146292c2", "patch": "@@ -0,0 +1,4 @@\n+// xfail-stage0\n+// error-pattern: some control paths may return\n+fn f() -> ! { 3 }\n+fn main(){}"}]}