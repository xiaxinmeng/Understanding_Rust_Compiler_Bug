{"sha": "d4268f944714dc01fe98c6353d7a23bd9631e4c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MjY4Zjk0NDcxNGRjMDFmZTk4YzYzNTNkN2EyM2JkOTYzMWU0YzI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T05:09:44Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T05:09:44Z"}, "message": "shard out and clean up unwinding", "tree": {"sha": "c6abdb8f0de3bf6a052e6784239abe5fa9617d33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6abdb8f0de3bf6a052e6784239abe5fa9617d33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4268f944714dc01fe98c6353d7a23bd9631e4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4268f944714dc01fe98c6353d7a23bd9631e4c2", "html_url": "https://github.com/rust-lang/rust/commit/d4268f944714dc01fe98c6353d7a23bd9631e4c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4268f944714dc01fe98c6353d7a23bd9631e4c2/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdc62e009cc5b62fcf356e7977c6397296b2077d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdc62e009cc5b62fcf356e7977c6397296b2077d", "html_url": "https://github.com/rust-lang/rust/commit/bdc62e009cc5b62fcf356e7977c6397296b2077d"}], "stats": {"total": 520, "additions": 264, "deletions": 256}, "files": [{"sha": "8a8ea6dfab7994b6acde6dcf0726ca217acec147", "filename": "SUMMARY.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4268f944714dc01fe98c6353d7a23bd9631e4c2/SUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4268f944714dc01fe98c6353d7a23bd9631e4c2/SUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SUMMARY.md?ref=d4268f944714dc01fe98c6353d7a23bd9631e4c2", "patch": "@@ -30,6 +30,8 @@\n \t* [Destructors](destructors.md)\n \t* [Leaking](leaking.md)\n * [Unwinding](unwinding.md)\n+\t* [Exception Safety](exception-safety.md)\n+\t* [Poisoning](poisoning.md)\n * [Concurrency](concurrency.md)\n \t* [Races](races.md)\n \t* [Send and Sync](send-and-sync.md)"}, {"sha": "12e000b5ef6e4b099653cd157123a80afdbb7935", "filename": "exception-safety.md", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d4268f944714dc01fe98c6353d7a23bd9631e4c2/exception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4268f944714dc01fe98c6353d7a23bd9631e4c2/exception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/exception-safety.md?ref=d4268f944714dc01fe98c6353d7a23bd9631e4c2", "patch": "@@ -0,0 +1,217 @@\n+% Exception Safety\n+\n+Although programs should use unwinding sparingly, there's *a lot* of code that\n+*can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\n+program *will* panic. On debug builds, *every* arithmetic operation can panic\n+if it overflows. Unless you are very careful and tightly control what code runs,\n+pretty much everything can unwind, and you need to be ready for it.\n+\n+Being ready for unwinding is often referred to as *exception safety*\n+in the broader programming world. In Rust, their are two levels of exception\n+safety that one may concern themselves with:\n+\n+* In unsafe code, we *must* be exception safe to the point of not violating\n+  memory safety. We'll call this *minimal* exception safety.\n+\n+* In safe code, it is *good* to be exception safe to the point of your program\n+  doing the right thing. We'll call this *maximal* exception safety.\n+\n+As is the case in many places in Rust, Unsafe code must be ready to deal with\n+bad Safe code when it comes to unwinding. Code that transiently creates\n+unsound states must be careful that a panic does not cause that state to be\n+used. Generally this means ensuring that only non-panicking code is run while\n+these states exist, or making a guard that cleans up the state in the case of\n+a panic. This does not necessarily mean that the state a panic witnesses is a\n+fully *coherent* state. We need only guarantee that it's a *safe* state.\n+\n+Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n+It controls all the code that runs, and most of that code can't panic. However\n+it is not uncommon for Unsafe code to work with arrays of temporarily\n+uninitialized data while repeatedly invoking caller-provided code. Such code\n+needs to be careful and consider exception safety.\n+\n+\n+\n+\n+\n+## Vec::push_all\n+\n+`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\n+effecient without specialization. Here's a simple implementation:\n+\n+```rust,ignore\n+impl<T: Clone> Vec<T> {\n+    fn push_all(&mut self, to_push: &[T]) {\n+        self.reserve(to_push.len());\n+        unsafe {\n+            // can't overflow because we just reserved this\n+            self.set_len(self.len() + to_push.len());\n+\n+            for (i, x) in to_push.iter().enumerate() {\n+                self.ptr().offset(i as isize).write(x.clone());\n+            }\n+        }\n+    }\n+}\n+```\n+\n+We bypass `push` in order to avoid redundant capacity and `len` checks on the\n+Vec that we definitely know has capacity. The logic is totally correct, except\n+there's a subtle problem with our code: it's not exception-safe! `set_len`,\n+`offset`, and `write` are all fine, but *clone* is the panic bomb we over-looked.\n+\n+Clone is completely out of our control, and is totally free to panic. If it does,\n+our function will exit early with the length of the Vec set too large. If\n+the Vec is looked at or dropped, uninitialized memory will be read!\n+\n+The fix in this case is fairly simple. If we want to guarantee that the values\n+we *did* clone are dropped we can set the len *in* the loop. If we just want to\n+guarantee that uninitialized memory can't be observed, we can set the len *after*\n+the loop.\n+\n+\n+\n+\n+\n+## BinaryHeap::sift_up\n+\n+Bubbling an element up a heap is a bit more complicated than extending a Vec.\n+The pseudocode is as follows:\n+\n+```text\n+bubble_up(heap, index):\n+    while index != 0 && heap[index] < heap[parent(index)]:\n+        heap.swap(index, parent(index))\n+        index = parent(index)\n+\n+```\n+\n+A literal transcription of this code to Rust is totally fine, but has an annoying\n+performance characteristic: the `self` element is swapped over and over again\n+uselessly. We would *rather* have the following:\n+\n+```text\n+bubble_up(heap, index):\n+    let elem = heap[index]\n+    while index != 0 && element < heap[parent(index)]:\n+        heap[index] = heap[parent(index)]\n+        index = parent(index)\n+    heap[index] = elem\n+```\n+\n+This code ensures that each element is copied as little as possible (it is in\n+fact necessary that elem be copied twice in general). However it now exposes\n+some exception safety trouble! At all times, there exists two copies of one\n+value. If we panic in this function something will be double-dropped.\n+Unfortunately, we also don't have full control of the code: that comparison is\n+user-defined!\n+\n+Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\n+code and the unsafe code into two separate phases:\n+\n+```text\n+bubble_up(heap, index):\n+    let end_index = index;\n+    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:\n+        end_index = parent(end_index)\n+\n+    let elem = heap[index]\n+    while index != end_index:\n+        heap[index] = heap[parent(index)]\n+        index = parent(index)\n+    heap[index] = elem\n+```\n+\n+If the user-defined code blows up, that's no problem anymore, because we haven't\n+actually touched the state of the heap yet. Once we do start messing with the\n+heap, we're working with only data and functions that we trust, so there's no\n+concern of panics.\n+\n+Perhaps you're not happy with this design. Surely, it's cheating! And we have\n+to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n+intermix untrusted and unsafe code *for reals*.\n+\n+If Rust had `try` and `finally` like in Java, we could do the following:\n+\n+```text\n+bubble_up(heap, index):\n+    let elem = heap[index]\n+    try:\n+        while index != 0 && element < heap[parent(index)]:\n+            heap[index] = heap[parent(index)]\n+            index = parent(index)\n+    finally:\n+        heap[index] = elem\n+```\n+\n+The basic idea is simple: if the comparison panics, we just toss the loose\n+element in the logically uninitialized index and bail out. Anyone who observes\n+the heap will see a potentially *inconsistent* heap, but at least it won't\n+cause any double-drops! If the algorithm terminates normally, then this\n+operation happens to coincide precisely with the how we finish up regardless.\n+\n+Sadly, Rust has no such construct, so we're going to need to roll our own! The\n+way to do this is to store the algorithm's state in a separate struct with a\n+destructor for the \"finally\" logic. Whether we panic or not, that destructor\n+will run and clean up after us.\n+\n+```rust\n+struct Hole<'a, T: 'a> {\n+    data: &'a mut [T],\n+    /// `elt` is always `Some` from new until drop.\n+    elt: Option<T>,\n+    pos: usize,\n+}\n+\n+impl<'a, T> Hole<'a, T> {\n+    fn new(data: &'a mut [T], pos: usize) -> Self {\n+        unsafe {\n+            let elt = ptr::read(&data[pos]);\n+            Hole {\n+                data: data,\n+                elt: Some(elt),\n+                pos: pos,\n+            }\n+        }\n+    }\n+\n+    fn pos(&self) -> usize { self.pos }\n+\n+    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n+\n+    unsafe fn get(&self, index: usize) -> &T { &self.data[index] }\n+\n+    unsafe fn move_to(&mut self, index: usize) {\n+        let index_ptr: *const _ = &self.data[index];\n+        let hole_ptr = &mut self.data[self.pos];\n+        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        self.pos = index;\n+    }\n+}\n+\n+impl<'a, T> Drop for Hole<'a, T> {\n+    fn drop(&mut self) {\n+        // fill the hole again\n+        unsafe {\n+            let pos = self.pos;\n+            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+        }\n+    }\n+}\n+\n+impl<T: Ord> BinaryHeap<T> {\n+    fn sift_up(&mut self, pos: usize) {\n+        unsafe {\n+            // Take out the value at `pos` and create a hole.\n+            let mut hole = Hole::new(&mut self.data, pos);\n+\n+            while hole.pos() != 0 {\n+                let parent = parent(hole.pos());\n+                if hole.removed() <= hole.get(parent) { break }\n+                hole.move_to(parent);\n+            }\n+            // Hole will be unconditionally filled here; panic or not!\n+        }\n+    }\n+}\n+```"}, {"sha": "6fb16f28e343501828e78067a21859bc1d83edee", "filename": "poisoning.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d4268f944714dc01fe98c6353d7a23bd9631e4c2/poisoning.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4268f944714dc01fe98c6353d7a23bd9631e4c2/poisoning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/poisoning.md?ref=d4268f944714dc01fe98c6353d7a23bd9631e4c2", "patch": "@@ -0,0 +1,35 @@\n+% Poisoning\n+\n+Although all unsafe code *must* ensure it has minimal exception safety, not all\n+types ensure *maximal* exception safety. Even if the type does, your code may\n+ascribe additional meaning to it. For instance, an integer is certainly\n+exception-safe, but has no semantics on its own. It's possible that code that\n+panics could fail to correctly update the integer, producing an inconsistent\n+program state.\n+\n+This is *usually* fine, because anything that witnesses an exception is about\n+to get destroyed. For instance, if you send a Vec to another thread and that\n+thread panics, it doesn't matter if the Vec is in a weird state. It will be\n+dropped and go away forever. However some types are especially good at smuggling\n+values across the panic boundary.\n+\n+These types may choose to explicitly *poison* themselves if they witness a panic.\n+Poisoning doesn't entail anything in particular. Generally it just means\n+preventing normal usage from proceeding. The most notable example of this is the\n+standard library's Mutex type. A Mutex will poison itself if one of its\n+MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n+panic. Any future attempts to lock the Mutex will return an `Err` or panic.\n+\n+Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n+poisons as a safety-guard against blindly using the data that comes out of a Mutex\n+that has witnessed a panic while locked. The data in such a Mutex was likely in the\n+middle of being modified, and as such may be in an inconsistent or incomplete state.\n+It is important to note that one cannot violate memory safety with such a type\n+if it is correctly written. After all, it must be minimally exception-safe!\n+\n+However if the Mutex contained, say, a BinaryHeap that does not actually have the\n+heap property, it's unlikely that any code that uses it will do\n+what the author intended. As such, the program should not proceed normally.\n+Still, if you're double-plus-sure that you can do *something* with the value,\n+the Mutex exposes a method to get the lock anyway. It *is* safe, after all.\n+Just maybe nonsense."}, {"sha": "59494d8647467921b74c33ce81f6a65ab0b42e8a", "filename": "unwinding.md", "status": "modified", "additions": 10, "deletions": 256, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/d4268f944714dc01fe98c6353d7a23bd9631e4c2/unwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4268f944714dc01fe98c6353d7a23bd9631e4c2/unwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/unwinding.md?ref=d4268f944714dc01fe98c6353d7a23bd9631e4c2", "patch": "@@ -2,14 +2,13 @@\n \n Rust has a *tiered* error-handling scheme:\n \n-* If something might reasonably be absent, Option is used\n-* If something goes wrong and can reasonably be handled, Result is used\n-* If something goes wrong and cannot reasonably be handled, the thread panics\n-* If something catastrophic happens, the program aborts\n+* If something might reasonably be absent, Option is used.\n+* If something goes wrong and can reasonably be handled, Result is used.\n+* If something goes wrong and cannot reasonably be handled, the thread panics.\n+* If something catastrophic happens, the program aborts.\n \n Option and Result are overwhelmingly preferred in most situations, especially\n since they can be promoted into a panic or abort at the API user's discretion.\n-However, anything and everything *can* panic, and you need to be ready for this.\n Panics cause the thread to halt normal execution and unwind its stack, calling\n destructors as if every function instantly returned.\n \n@@ -27,265 +26,20 @@ Rust very poor for long-running systems!\n \n As the Rust we know today came to be, this style of programming grew out of\n fashion in the push for less-and-less abstraction. Light-weight tasks were\n-killed in the name of heavy-weight OS threads. Still, panics could only be\n-caught by the parent thread. This means catching a panic requires spinning up\n-an entire OS thread! This unfortunately stands in conflict to Rust's philosophy\n-of zero-cost abstractions.\n+killed in the name of heavy-weight OS threads. Still, on stable Rust as of 1.0\n+panics can only be caught by the parent thread. This means catching a panic\n+requires spinning up an entire OS thread! This unfortunately stands in conflict\n+to Rust's philosophy of zero-cost abstractions.\n \n-In the near future there will be a stable interface for catching panics in an\n-arbitrary location, though we would encourage you to still only do this\n+There is an *unstable* API called `catch_panic` that enables catching a panic\n+without spawning a thread. Still, we would encourage you to only do this\n sparingly. In particular, Rust's current unwinding implementation is heavily\n optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n should be no runtime cost for the program being *ready* to unwind. As a\n consequence, *actually* unwinding will be more expensive than in e.g. Java.\n Don't build your programs to unwind under normal circumstances. Ideally, you\n should only panic for programming errors or *extreme* problems.\n \n-\n-\n-\n-# Exception Safety\n-\n-Being ready for unwinding is often referred to as *exception safety*\n-in the broader programming world. In Rust, their are two levels of exception\n-safety that one may concern themselves with:\n-\n-* In unsafe code, we *must* be exception safe to the point of not violating\n-  memory safety.\n-\n-* In safe code, it is *good* to be exception safe to the point of your program\n-  doing the right thing.\n-\n-As is the case in many places in Rust, unsafe code must be ready to deal with\n-bad safe code, and that includes code that panics. Code that transiently creates\n-unsound states must be careful that a panic does not cause that state to be\n-used. Generally this means ensuring that only non-panicking code is run while\n-these states exist, or making a guard that cleans up the state in the case of\n-a panic. This does not necessarily mean that the state a panic witnesses is a\n-fully *coherent* state. We need only guarantee that it's a *safe* state.\n-\n-Most unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n-It controls all the code that runs, and most of that code can't panic. However\n-it is often the case that code that works with arrays works with temporarily\n-uninitialized data while repeatedly invoking caller-provided code. Such code\n-needs to be careful, and consider exception-safety.\n-\n-\n-\n-\n-\n-## Vec::push_all\n-\n-`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\n-effecient without specialization. Here's a simple implementation:\n-\n-```rust,ignore\n-impl<T: Clone> Vec<T> {\n-    fn push_all(&mut self, to_push: &[T]) {\n-        self.reserve(to_push.len());\n-        unsafe {\n-            // can't overflow because we just reserved this\n-            self.set_len(self.len() + to_push.len());\n-\n-            for (i, x) in to_push.iter().enumerate() {\n-                self.ptr().offset(i as isize).write(x.clone());\n-            }\n-        }\n-    }\n-}\n-```\n-\n-We bypass `push` in order to avoid redundant capacity and `len` checks on the\n-Vec that we definitely know has capacity. The logic is totally correct, except\n-there's a subtle problem with our code: it's not exception-safe! `set_len`,\n-`offset`, and `write` are all fine, but *clone* is the panic bomb we over-looked.\n-\n-Clone is completely out of our control, and is totally free to panic. If it does,\n-our function will exit early with the length of the Vec set too large. If\n-the Vec is looked at or dropped, uninitialized memory will be read!\n-\n-The fix in this case is fairly simple. If we want to guarantee that the values\n-we *did* clone are dropped we can set the len *in* the loop. If we just want to\n-guarantee that uninitialized memory can't be observed, we can set the len *after*\n-the loop.\n-\n-\n-\n-\n-\n-## BinaryHeap::sift_up\n-\n-Bubbling an element up a heap is a bit more complicated than extending a Vec.\n-The pseudocode is as follows:\n-\n-```text\n-bubble_up(heap, index):\n-    while index != 0 && heap[index] < heap[parent(index)]:\n-        heap.swap(index, parent(index))\n-        index = parent(index)\n-\n-```\n-\n-A literal transcription of this code to Rust is totally fine, but has an annoying\n-performance characteristic: the `self` element is swapped over and over again\n-uselessly. We would *rather* have the following:\n-\n-```text\n-bubble_up(heap, index):\n-    let elem = heap[index]\n-    while index != 0 && element < heap[parent(index)]:\n-        heap[index] = heap[parent(index)]\n-        index = parent(index)\n-    heap[index] = elem\n-```\n-\n-This code ensures that each element is copied as little as possible (it is in\n-fact necessary that elem be copied twice in general). However it now exposes\n-some exception-safety trouble! At all times, there exists two copies of one\n-value. If we panic in this function something will be double-dropped.\n-Unfortunately, we also don't have full control of the code: that comparison is\n-user-defined!\n-\n-Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\n-code and the unsafe code into two separate phases:\n-\n-```text\n-bubble_up(heap, index):\n-    let end_index = index;\n-    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:\n-        end_index = parent(end_index)\n-\n-    let elem = heap[index]\n-    while index != end_index:\n-        heap[index] = heap[parent(index)]\n-        index = parent(index)\n-    heap[index] = elem\n-```\n-\n-If the user-defined code blows up, that's no problem anymore, because we haven't\n-actually touched the state of the heap yet. Once we do start messing with the\n-heap, we're working with only data and functions that we trust, so there's no\n-concern of panics.\n-\n-Perhaps you're not happy with this design. Surely, it's cheating! And we have\n-to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n-intermix untrusted and unsafe code *for reals*.\n-\n-If Rust had `try` and `finally` like in Java, we could do the following:\n-\n-```text\n-bubble_up(heap, index):\n-    let elem = heap[index]\n-    try:\n-        while index != 0 && element < heap[parent(index)]:\n-            heap[index] = heap[parent(index)]\n-            index = parent(index)\n-    finally:\n-        heap[index] = elem\n-```\n-\n-The basic idea is simple: if the comparison panics, we just toss the loose\n-element in the logically uninitialized index and bail out. Anyone who observes\n-the heap will see a potentially *inconsistent* heap, but at least it won't\n-cause any double-drops! If the algorithm terminates normally, then this\n-operation happens to coincide precisely with the how we finish up regardless.\n-\n-Sadly, Rust has no such construct, so we're going to need to roll our own! The\n-way to do this is to store the algorithm's state in a separate struct with a\n-destructor for the \"finally\" logic. Whether we panic or not, that destructor\n-will run and clean up after us.\n-\n-```rust\n-struct Hole<'a, T: 'a> {\n-    data: &'a mut [T],\n-    /// `elt` is always `Some` from new until drop.\n-    elt: Option<T>,\n-    pos: usize,\n-}\n-\n-impl<'a, T> Hole<'a, T> {\n-    fn new(data: &'a mut [T], pos: usize) -> Self {\n-        unsafe {\n-            let elt = ptr::read(&data[pos]);\n-            Hole {\n-                data: data,\n-                elt: Some(elt),\n-                pos: pos,\n-            }\n-        }\n-    }\n-\n-    fn pos(&self) -> usize { self.pos }\n-\n-    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n-\n-    unsafe fn get(&self, index: usize) -> &T { &self.data[index] }\n-\n-    unsafe fn move_to(&mut self, index: usize) {\n-        let index_ptr: *const _ = &self.data[index];\n-        let hole_ptr = &mut self.data[self.pos];\n-        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n-        self.pos = index;\n-    }\n-}\n-\n-impl<'a, T> Drop for Hole<'a, T> {\n-    fn drop(&mut self) {\n-        // fill the hole again\n-        unsafe {\n-            let pos = self.pos;\n-            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n-        }\n-    }\n-}\n-\n-impl<T: Ord> BinaryHeap<T> {\n-    fn sift_up(&mut self, pos: usize) {\n-        unsafe {\n-            // Take out the value at `pos` and create a hole.\n-            let mut hole = Hole::new(&mut self.data, pos);\n-\n-            while hole.pos() != 0 {\n-                let parent = parent(hole.pos());\n-                if hole.removed() <= hole.get(parent) { break }\n-                hole.move_to(parent);\n-            }\n-            // Hole will be unconditionally filled here; panic or not!\n-        }\n-    }\n-}\n-```\n-\n-\n-\n-\n-## Poisoning\n-\n-Although all unsafe code *must* ensure some minimal level of exception safety,\n-some types may choose to explicitly *poison* themselves if they witness a panic.\n-Poisoning doesn't entail anything in particular. Generally it just means\n-preventing normal usage from proceeding. The most notable example of this is the\n-standard library's Mutex type. A Mutex will poison itself if one of its\n-MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n-panic. Any future attempts to lock the Mutex will return an `Err`.\n-\n-Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n-poisons as a safety-guard against blindly using the data that comes out of a Mutex\n-that has witnessed a panic while locked. The data in such a Mutex was likely in the\n-middle of being modified, and as such may be in an inconsistent or incomplete state.\n-It is important to note that one cannot violate memory safety with such a type\n-if it is correctly written. After all, it must be minimally exception safe!\n-\n-However if the Mutex contained, say, a BinaryHeap that does not actually have the\n-heap property, it's unlikely that any code that uses it will do\n-what the author intended. As such, the program should not proceed normally.\n-Still, if you're double-plus-sure that you can do *something* with the value,\n-the Err exposes a method to get the lock anyway. It *is* safe, after all.\n-\n-\n-\n-# FFI\n-\n Rust's unwinding strategy is not specified to be fundamentally compatible\n with any other language's unwinding. As such, unwinding into Rust from another\n language, or unwinding into another language from Rust is Undefined Behaviour."}]}