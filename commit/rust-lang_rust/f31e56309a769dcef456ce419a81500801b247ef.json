{"sha": "f31e56309a769dcef456ce419a81500801b247ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMWU1NjMwOWE3NjlkY2VmNDU2Y2U0MTlhODE1MDA4MDFiMjQ3ZWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-29T09:50:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-29T09:50:13Z"}, "message": "Rollup merge of #70506 - ssomers:btreemap_testing_consts, r=RalfJung\n\nBTreeMap testing: introduce symbolic constants and use height consistently\n\nDoesn't change what or how much is tested, except for some exact integer types, just for convenience and because `node::CAPACITY` is a usize.\n\nr? @RalfJung", "tree": {"sha": "5ffd5002cb637fdb542bd9efbfc7135a1cdb4354", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ffd5002cb637fdb542bd9efbfc7135a1cdb4354"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f31e56309a769dcef456ce419a81500801b247ef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJegG9VCRBK7hj4Ov3rIwAAdHIIAB4eoxcwKU+wfHJDGsXM8SVF\n0tlS1AFng8C5WzwmmHO1SlOhFps0y6l+rgAnroZ4vaWN6iQ4p5mehvgeyCOT3t1E\ndKUYNOgqA4aI6MPNfXoBttv6OkFj6y8KfJqzD2FrzvjDQR5EFNiYxnicb1M680tc\ny5EEsFSTo6QV5j02x08pGrnmkTtWNb0D4RZUnyiGhmXTvrdSisKQU1mgXuETIM6c\nepcoI+nIHBfZfWcETRkcKWxkv+MDQJv7ooK3D+cCb0mn+lW/G+9UV3pA1/xXs3MI\nHxndrv/GwAI8hAb7iYb121XqIxbWsO5P1+4cs8nMkukau06x6juEUO0dJXCIlkE=\n=jlDy\n-----END PGP SIGNATURE-----\n", "payload": "tree 5ffd5002cb637fdb542bd9efbfc7135a1cdb4354\nparent 873bf46dc1677f24724cf2009703cf5c2a69a07a\nparent e92d740b3586de0d0b476257b3539847f2db21e3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585475413 +0200\ncommitter GitHub <noreply@github.com> 1585475413 +0200\n\nRollup merge of #70506 - ssomers:btreemap_testing_consts, r=RalfJung\n\nBTreeMap testing: introduce symbolic constants and use height consistently\n\nDoesn't change what or how much is tested, except for some exact integer types, just for convenience and because `node::CAPACITY` is a usize.\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f31e56309a769dcef456ce419a81500801b247ef", "html_url": "https://github.com/rust-lang/rust/commit/f31e56309a769dcef456ce419a81500801b247ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f31e56309a769dcef456ce419a81500801b247ef/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "873bf46dc1677f24724cf2009703cf5c2a69a07a", "url": "https://api.github.com/repos/rust-lang/rust/commits/873bf46dc1677f24724cf2009703cf5c2a69a07a", "html_url": "https://github.com/rust-lang/rust/commit/873bf46dc1677f24724cf2009703cf5c2a69a07a"}, {"sha": "e92d740b3586de0d0b476257b3539847f2db21e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e92d740b3586de0d0b476257b3539847f2db21e3", "html_url": "https://github.com/rust-lang/rust/commit/e92d740b3586de0d0b476257b3539847f2db21e3"}], "stats": {"total": 90, "additions": 49, "deletions": 41}, "files": [{"sha": "535b6a9c31451c9fd69f22ff4ec82e5f0bac4ed6", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f31e56309a769dcef456ce419a81500801b247ef/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f31e56309a769dcef456ce419a81500801b247ef/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=f31e56309a769dcef456ce419a81500801b247ef", "patch": "@@ -7,17 +7,31 @@ use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::catch_unwind;\n use std::rc::Rc;\n-use std::sync::atomic::{AtomicU32, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n use super::DeterministicRng;\n \n+// Value of node::CAPACITY, thus capacity of a tree with a single level,\n+// i.e. a tree who's root is a leaf node at height 0.\n+const NODE_CAPACITY: usize = 11;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 2 levels,\n+// i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 3 levels,\n+// i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n     #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    let size = MIN_INSERTS_HEIGHT_2;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -237,30 +251,26 @@ impl TryFrom<usize> for Align32 {\n \n #[test]\n fn test_iter_mut_mutation() {\n-    // Check many alignments because various fields precede array in NodeHeader.\n-    // Check with size 0 which should not iterate at all.\n-    // Check with size 1 for a tree with one kind of node (root = leaf).\n-    // Check with size 12 for a tree with two kinds of nodes (root and leaves).\n-    // Check with size 144 for a tree with all kinds of nodes (root, internals and leaves).\n+    // Check many alignments and trees with roots at various heights.\n     do_test_iter_mut_mutation::<u8>(0);\n     do_test_iter_mut_mutation::<u8>(1);\n-    do_test_iter_mut_mutation::<u8>(12);\n-    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test 144\n+    do_test_iter_mut_mutation::<u8>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test MIN_INSERTS_HEIGHT_2\n     do_test_iter_mut_mutation::<u16>(1);\n-    do_test_iter_mut_mutation::<u16>(12);\n-    do_test_iter_mut_mutation::<u16>(144);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u32>(1);\n-    do_test_iter_mut_mutation::<u32>(12);\n-    do_test_iter_mut_mutation::<u32>(144);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u64>(1);\n-    do_test_iter_mut_mutation::<u64>(12);\n-    do_test_iter_mut_mutation::<u64>(144);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u128>(1);\n-    do_test_iter_mut_mutation::<u128>(12);\n-    do_test_iter_mut_mutation::<u128>(144);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<Align32>(1);\n-    do_test_iter_mut_mutation::<Align32>(12);\n-    do_test_iter_mut_mutation::<Align32>(144);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_2);\n }\n \n #[test]\n@@ -376,12 +386,11 @@ fn test_range_small() {\n }\n \n #[test]\n-fn test_range_height_2() {\n-    // Assuming that node.CAPACITY is 11, having 12 pairs implies a height 2 tree\n-    // with 2 leaves. Depending on details we don't want or need to rely upon,\n-    // the single key at the root will be 6 or 7.\n+fn test_range_height_1() {\n+    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n+    // to rely upon, the single key at the root will be 6 or 7.\n \n-    let map: BTreeMap<_, _> = (1..=12).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n     for &root in &[6, 7] {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n@@ -519,7 +528,7 @@ fn test_range_1000() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n     #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    let size = MIN_INSERTS_HEIGHT_2;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -755,7 +764,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n-    let size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let size = MIN_INSERTS_HEIGHT_1;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -783,20 +792,19 @@ fn test_clone() {\n         assert_eq!(map, map.clone());\n     }\n \n-    // Full 2-level and minimal 3-level tree (sizes 143, 144 -- the only ones we clone for).\n-    for i in 1..=144 {\n-        assert_eq!(map.insert(i, i), None);\n-        assert_eq!(map.len(), i);\n-        if i >= 143 {\n-            assert_eq!(map, map.clone());\n-        }\n-    }\n+    // Test a tree with 2 chock-full levels and a tree with 3 levels.\n+    map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(map, map.clone());\n+    map.insert(0, 0);\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2);\n+    assert_eq!(map, map.clone());\n }\n \n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n-    let max_size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let max_size = MIN_INSERTS_HEIGHT_1;\n \n     // Range to max_size inclusive, because i is the size of map1 being tested.\n     for i in 0..=max_size {\n@@ -1014,8 +1022,8 @@ fn test_split_off_large_random_sorted() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_1() {\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_0() {\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n \n@@ -1040,10 +1048,10 @@ fn test_into_iter_drop_leak_1() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_2() {\n-    let size = 12; // to obtain tree with 2 levels (having edges to leaf nodes)\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-    static PANIC_POINT: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_1() {\n+    let size = MIN_INSERTS_HEIGHT_1;\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n+    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n     impl Drop for D {"}]}