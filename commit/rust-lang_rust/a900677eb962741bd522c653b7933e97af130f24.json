{"sha": "a900677eb962741bd522c653b7933e97af130f24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MDA2NzdlYjk2Mjc0MWJkNTIyYzY1M2I3OTMzZTk3YWYxMzBmMjQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-27T19:37:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-27T19:37:05Z"}, "message": "Rollup merge of #82525 - RalfJung:unaligned-ref-warn, r=petrochenkov\n\nmake unaligned_references future-incompat lint warn-by-default\n\nand also remove the safe_packed_borrows lint that it replaces.\n\n`std::ptr::addr_of!` has hit beta now and will hit stable in a month, so I propose we start fixing https://github.com/rust-lang/rust/issues/27060 for real: creating a reference to a field of a packed struct needs to eventually become a hard error; this PR makes it a warn-by-default future-incompat lint. (The lint already existed, this just raises its default level.) At the same time I removed the corresponding code from unsafety checking; really there's no reason an `unsafe` block should make any difference here.\n\nFor references to packed fields outside `unsafe` blocks, this means `unaligned_refereces` replaces the previous `safe_packed_borrows` warning with a link to https://github.com/rust-lang/rust/issues/82523 (and no more talk about unsafe blocks making any difference). So behavior barely changes, the warning is just worded differently. For references to packed fields inside `unsafe` blocks, this PR shows a new future-incompat warning.\n\nCloses https://github.com/rust-lang/rust/issues/46043 because that lint no longer exists.", "tree": {"sha": "32bf7154e3babb53249eb97de41d12dca1561d95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32bf7154e3babb53249eb97de41d12dca1561d95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a900677eb962741bd522c653b7933e97af130f24", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgX4lhCRBK7hj4Ov3rIwAAdHIIAKvkX84GjsqihS6v1EsU6Oxo\nd4Sdn9Gl3Mo0oV5Fq636LAfryI4XSi+oCBUhkpPrhIhXAzN0aDbVozlUser3rCUB\noiP9yzykDO0nBXOn37yH4hMGVOS3yAHHTSr4svRhViHs30XcbaR5QNCqBcXNfmaP\n9z9txt7RtyMtkRu+LXF+J80NnPkoEkpVuQFTemycf31FwpbQDBKzOHuohB6lbVof\nL0yiEhPy9ww1dbuUun2wdORhB8GcsI9x8XMmh1wDKnIFjFoml20KGX8H8fI2NrVa\nRCg6+kd1YynkfVcEkBtQbrUFwV7pqwneII/1AgxR2Fr7cEVn56OcNKnLhRuDpMM=\n=UBTs\n-----END PGP SIGNATURE-----\n", "payload": "tree 32bf7154e3babb53249eb97de41d12dca1561d95\nparent 520c9a25dfc78ca1e1d198e55bb4bcb844b0791e\nparent fb4f48e0321fcc6b57e823434674ce41ceb23176\nauthor Dylan DPC <dylan.dpc@gmail.com> 1616873825 +0100\ncommitter GitHub <noreply@github.com> 1616873825 +0100\n\nRollup merge of #82525 - RalfJung:unaligned-ref-warn, r=petrochenkov\n\nmake unaligned_references future-incompat lint warn-by-default\n\nand also remove the safe_packed_borrows lint that it replaces.\n\n`std::ptr::addr_of!` has hit beta now and will hit stable in a month, so I propose we start fixing https://github.com/rust-lang/rust/issues/27060 for real: creating a reference to a field of a packed struct needs to eventually become a hard error; this PR makes it a warn-by-default future-incompat lint. (The lint already existed, this just raises its default level.) At the same time I removed the corresponding code from unsafety checking; really there's no reason an `unsafe` block should make any difference here.\n\nFor references to packed fields outside `unsafe` blocks, this means `unaligned_refereces` replaces the previous `safe_packed_borrows` warning with a link to https://github.com/rust-lang/rust/issues/82523 (and no more talk about unsafe blocks making any difference). So behavior barely changes, the warning is just worded differently. For references to packed fields inside `unsafe` blocks, this PR shows a new future-incompat warning.\n\nCloses https://github.com/rust-lang/rust/issues/46043 because that lint no longer exists.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a900677eb962741bd522c653b7933e97af130f24", "html_url": "https://github.com/rust-lang/rust/commit/a900677eb962741bd522c653b7933e97af130f24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a900677eb962741bd522c653b7933e97af130f24/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "520c9a25dfc78ca1e1d198e55bb4bcb844b0791e", "url": "https://api.github.com/repos/rust-lang/rust/commits/520c9a25dfc78ca1e1d198e55bb4bcb844b0791e", "html_url": "https://github.com/rust-lang/rust/commit/520c9a25dfc78ca1e1d198e55bb4bcb844b0791e"}, {"sha": "fb4f48e0321fcc6b57e823434674ce41ceb23176", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4f48e0321fcc6b57e823434674ce41ceb23176", "html_url": "https://github.com/rust-lang/rust/commit/fb4f48e0321fcc6b57e823434674ce41ceb23176"}], "stats": {"total": 666, "additions": 251, "deletions": 415}, "files": [{"sha": "b547ee89387555b40a775948d584c97c4c83c015", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -325,6 +325,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     store.register_renamed(\"exceeding_bitshifts\", \"arithmetic_overflow\");\n     store.register_renamed(\"redundant_semicolon\", \"redundant_semicolons\");\n     store.register_renamed(\"overlapping_patterns\", \"overlapping_range_endpoints\");\n+    store.register_renamed(\"safe_packed_borrows\", \"unaligned_references\");\n \n     // These were moved to tool lints, but rustc still sees them when compiling normally, before\n     // tool lints are registered, so `check_tool_name_for_backwards_compat` doesn't work. Use"}, {"sha": "3baafee46125de3bcd02b67d3cfac52202f2c204", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1057,6 +1057,7 @@ declare_lint! {\n     ///     unsafe {\n     ///         let foo = Foo { field1: 0, field2: 0 };\n     ///         let _ = &foo.field1;\n+    ///         println!(\"{}\", foo.field1); // An implicit `&` is added here, triggering the lint.\n     ///     }\n     /// }\n     /// ```\n@@ -1065,20 +1066,20 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// Creating a reference to an insufficiently aligned packed field is\n-    /// [undefined behavior] and should be disallowed.\n-    ///\n-    /// This lint is \"allow\" by default because there is no stable\n-    /// alternative, and it is not yet certain how widespread existing code\n-    /// will trigger this lint.\n-    ///\n-    /// See [issue #27060] for more discussion.\n+    /// Creating a reference to an insufficiently aligned packed field is [undefined behavior] and\n+    /// should be disallowed. Using an `unsafe` block does not change anything about this. Instead,\n+    /// the code should do a copy of the data in the packed field or use raw pointers and unaligned\n+    /// accesses. See [issue #82523] for more information.\n     ///\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n-    /// [issue #27060]: https://github.com/rust-lang/rust/issues/27060\n+    /// [issue #82523]: https://github.com/rust-lang/rust/issues/82523\n     pub UNALIGNED_REFERENCES,\n-    Allow,\n+    Warn,\n     \"detects unaligned references to fields of packed structs\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #82523 <https://github.com/rust-lang/rust/issues/82523>\",\n+        edition: None,\n+    };\n     report_in_external_macro\n }\n \n@@ -1150,49 +1151,6 @@ declare_lint! {\n     \"detects attempts to mutate a `const` item\",\n }\n \n-declare_lint! {\n-    /// The `safe_packed_borrows` lint detects borrowing a field in the\n-    /// interior of a packed structure with alignment other than 1.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust\n-    /// #[repr(packed)]\n-    /// pub struct Unaligned<T>(pub T);\n-    ///\n-    /// pub struct Foo {\n-    ///     start: u8,\n-    ///     data: Unaligned<u32>,\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let x = Foo { start: 0, data: Unaligned(1) };\n-    ///     let y = &x.data.0;\n-    /// }\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// This type of borrow is unsafe and can cause errors on some platforms\n-    /// and violates some assumptions made by the compiler. This was\n-    /// previously allowed unintentionally. This is a [future-incompatible]\n-    /// lint to transition this to a hard error in the future. See [issue\n-    /// #46043] for more details, including guidance on how to solve the\n-    /// problem.\n-    ///\n-    /// [issue #46043]: https://github.com/rust-lang/rust/issues/46043\n-    /// [future-incompatible]: ../index.md#future-incompatible-lints\n-    pub SAFE_PACKED_BORROWS,\n-    Warn,\n-    \"safe borrows of fields of packed structs were erroneously allowed\",\n-    @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n-        edition: None,\n-    };\n-}\n-\n declare_lint! {\n     /// The `patterns_in_fns_without_body` lint detects `mut` identifier\n     /// patterns as a parameter in functions without a body.\n@@ -2953,7 +2911,6 @@ declare_lint_pass! {\n         RENAMED_AND_REMOVED_LINTS,\n         UNALIGNED_REFERENCES,\n         CONST_ITEM_MUTATION,\n-        SAFE_PACKED_BORROWS,\n         PATTERNS_IN_FNS_WITHOUT_BODY,\n         MISSING_FRAGMENT_SPECIFIER,\n         LATE_BOUND_LIFETIME_ARGUMENTS,"}, {"sha": "ad3baccf1549616b5ebd694f4728de2255dfb9cb", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -23,15 +23,9 @@ pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n-    /// Borrow of packed field.\n-    /// Has to be handled as a lint for backwards compatibility.\n-    BorrowPacked,\n     /// Unsafe operation in an `unsafe fn` but outside an `unsafe` block.\n     /// Has to be handled as a lint for backwards compatibility.\n     UnsafeFn,\n-    /// Borrow of packed field in an `unsafe fn` but outside an `unsafe` block.\n-    /// Has to be handled as a lint for backwards compatibility.\n-    UnsafeFnBorrowPacked,\n }\n \n #[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable, Debug)]"}, {"sha": "13b7221046bda4deb87d7eddd1b0f3f7d9480984", "filename": "compiler/rustc_mir/src/transform/check_packed_ref.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_packed_ref.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,11 +1,18 @@\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n+use rustc_span::symbol::sym;\n \n use crate::transform::MirPass;\n use crate::util;\n \n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers { unsafe_derive_on_repr_packed, ..*providers };\n+}\n+\n pub struct CheckPackedRef;\n \n impl<'tcx> MirPass<'tcx> for CheckPackedRef {\n@@ -24,6 +31,41 @@ struct PackedRefChecker<'a, 'tcx> {\n     source_info: SourceInfo,\n }\n \n+fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+    tcx.struct_span_lint_hir(UNALIGNED_REFERENCES, lint_hir_id, tcx.def_span(def_id), |lint| {\n+        // FIXME: when we make this a hard error, this should have its\n+        // own error code.\n+        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n+             type or const parameters (error E0133)\"\n+                .to_string()\n+        } else {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n+             does not derive Copy (error E0133)\"\n+                .to_string()\n+        };\n+        lint.build(&message).emit()\n+    });\n+}\n+\n+fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    debug!(\"builtin_derive_def_id({:?})\", def_id);\n+    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n+            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n+            Some(impl_def_id)\n+        } else {\n+            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n+            None\n+        }\n+    } else {\n+        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n+        None\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         // Make sure we know where in the MIR we are.\n@@ -40,26 +82,33 @@ impl<'a, 'tcx> Visitor<'tcx> for PackedRefChecker<'a, 'tcx> {\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                let source_info = self.source_info;\n-                let lint_root = self.body.source_scopes[source_info.scope]\n-                    .local_data\n-                    .as_ref()\n-                    .assert_crate_local()\n-                    .lint_root;\n-                self.tcx.struct_span_lint_hir(\n-                    UNALIGNED_REFERENCES,\n-                    lint_root,\n-                    source_info.span,\n-                    |lint| {\n-                        lint.build(\"reference to packed field is unaligned\")\n-                            .note(\n-                                \"fields of packed structs are not properly aligned, and creating \\\n-                                a misaligned reference is undefined behavior (even if that \\\n-                                reference is never dereferenced)\",\n-                            )\n-                            .emit()\n-                    },\n-                );\n+                let def_id = self.body.source.instance.def_id();\n+                if let Some(impl_def_id) = builtin_derive_def_id(self.tcx, def_id) {\n+                    // If a method is defined in the local crate,\n+                    // the impl containing that method should also be.\n+                    self.tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n+                } else {\n+                    let source_info = self.source_info;\n+                    let lint_root = self.body.source_scopes[source_info.scope]\n+                        .local_data\n+                        .as_ref()\n+                        .assert_crate_local()\n+                        .lint_root;\n+                    self.tcx.struct_span_lint_hir(\n+                        UNALIGNED_REFERENCES,\n+                        lint_root,\n+                        source_info.span,\n+                        |lint| {\n+                            lint.build(\"reference to packed field is unaligned\")\n+                                .note(\n+                                    \"fields of packed structs are not properly aligned, and creating \\\n+                                    a misaligned reference is undefined behavior (even if that \\\n+                                    reference is never dereferenced)\",\n+                                )\n+                                .emit()\n+                        },\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "09da9b2e4d6ffd29a9cd470b06094f8069da3952", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 123, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -10,14 +10,12 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n+use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n-use rustc_span::symbol::sym;\n \n use std::ops::Bound;\n \n use crate::const_eval::is_min_const_fn;\n-use crate::util;\n \n pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n@@ -182,18 +180,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n-        // Check for borrows to packed fields.\n-        // `is_disaligned` already traverses the place to consider all projections after the last\n-        // `Deref`, so this only needs to be called once at the top level.\n-        if context.is_borrow() {\n-            if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                self.require_unsafe(\n-                    UnsafetyViolationKind::BorrowPacked,\n-                    UnsafetyViolationDetails::BorrowOfPackedField,\n-                );\n-            }\n-        }\n-\n         // Some checks below need the extra metainfo of the local declaration.\n         let decl = &self.body.local_decls[place.local];\n \n@@ -317,25 +303,15 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             // `unsafe` blocks are required in safe code\n             Safety::Safe => {\n                 for violation in violations {\n-                    let mut violation = *violation;\n                     match violation.kind {\n                         UnsafetyViolationKind::GeneralAndConstFn\n                         | UnsafetyViolationKind::General => {}\n-                        UnsafetyViolationKind::BorrowPacked => {\n-                            if self.min_const_fn {\n-                                // const fns don't need to be backwards compatible and can\n-                                // emit these violations as a hard error instead of a backwards\n-                                // compat lint\n-                                violation.kind = UnsafetyViolationKind::General;\n-                            }\n-                        }\n-                        UnsafetyViolationKind::UnsafeFn\n-                        | UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n+                        UnsafetyViolationKind::UnsafeFn => {\n                             bug!(\"`UnsafetyViolationKind::UnsafeFn` in an `Safe` context\")\n                         }\n                     }\n-                    if !self.violations.contains(&violation) {\n-                        self.violations.push(violation)\n+                    if !self.violations.contains(violation) {\n+                        self.violations.push(*violation)\n                     }\n                 }\n                 false\n@@ -345,11 +321,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 for violation in violations {\n                     let mut violation = *violation;\n \n-                    if violation.kind == UnsafetyViolationKind::BorrowPacked {\n-                        violation.kind = UnsafetyViolationKind::UnsafeFnBorrowPacked;\n-                    } else {\n-                        violation.kind = UnsafetyViolationKind::UnsafeFn;\n-                    }\n+                    violation.kind = UnsafetyViolationKind::UnsafeFn;\n                     if !self.violations.contains(&violation) {\n                         self.violations.push(violation)\n                     }\n@@ -369,8 +341,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                             // these unsafe things are stable in const fn\n                             UnsafetyViolationKind::GeneralAndConstFn => {}\n                             // these things are forbidden in const fns\n-                            UnsafetyViolationKind::General\n-                            | UnsafetyViolationKind::BorrowPacked => {\n+                            UnsafetyViolationKind::General => {\n                                 let mut violation = *violation;\n                                 // const fns don't need to be backwards compatible and can\n                                 // emit these violations as a hard error instead of a backwards\n@@ -380,8 +351,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                     self.violations.push(violation)\n                                 }\n                             }\n-                            UnsafetyViolationKind::UnsafeFn\n-                            | UnsafetyViolationKind::UnsafeFnBorrowPacked => bug!(\n+                            UnsafetyViolationKind::UnsafeFn => bug!(\n                                 \"`UnsafetyViolationKind::UnsafeFn` in an `ExplicitUnsafe` context\"\n                             ),\n                         }\n@@ -464,7 +434,6 @@ pub(crate) fn provide(providers: &mut Providers) {\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )\n         },\n-        unsafe_derive_on_repr_packed,\n         ..*providers\n     };\n }\n@@ -544,25 +513,6 @@ fn unsafety_check_result<'tcx>(\n     })\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n-        // FIXME: when we make this a hard error, this should have its\n-        // own error code.\n-        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n-             type or const parameters (error E0133)\"\n-                .to_string()\n-        } else {\n-            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n-             does not derive Copy (error E0133)\"\n-                .to_string()\n-        };\n-        lint.build(&message).emit()\n-    });\n-}\n-\n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(\n     tcx: TyCtxt<'_>,\n@@ -609,22 +559,6 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id\n     });\n }\n \n-fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    debug!(\"builtin_derive_def_id({:?})\", def_id);\n-    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n-            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n-            Some(impl_def_id)\n-        } else {\n-            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n-            None\n-        }\n-    } else {\n-        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n-        None\n-    }\n-}\n-\n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n@@ -657,27 +591,6 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .note(note)\n                 .emit();\n             }\n-            UnsafetyViolationKind::BorrowPacked => {\n-                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id.to_def_id()) {\n-                    // If a method is defined in the local crate,\n-                    // the impl containing that method should also be.\n-                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n-                } else {\n-                    tcx.struct_span_lint_hir(\n-                        SAFE_PACKED_BORROWS,\n-                        lint_root,\n-                        source_info.span,\n-                        |lint| {\n-                            lint.build(&format!(\n-                                \"{} is unsafe and requires unsafe{} block (error E0133)\",\n-                                description, unsafe_fn_msg,\n-                            ))\n-                            .note(note)\n-                            .emit()\n-                        },\n-                    )\n-                }\n-            }\n             UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n@@ -692,35 +605,6 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     .emit();\n                 },\n             ),\n-            UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n-                // When `unsafe_op_in_unsafe_fn` is disallowed, the behavior of safe and unsafe functions\n-                // should be the same in terms of warnings and errors. Therefore, with `#[warn(safe_packed_borrows)]`,\n-                // a safe packed borrow should emit a warning *but not an error* in an unsafe function,\n-                // just like in a safe function, even if `unsafe_op_in_unsafe_fn` is `deny`.\n-                //\n-                // Also, `#[warn(unsafe_op_in_unsafe_fn)]` can't cause any new errors. Therefore, with\n-                // `#[deny(safe_packed_borrows)]` and `#[warn(unsafe_op_in_unsafe_fn)]`, a packed borrow\n-                // should only issue a warning for the sake of backwards compatibility.\n-                //\n-                // The solution those 2 expectations is to always take the minimum of both lints.\n-                // This prevent any new errors (unless both lints are explicitly set to `deny`).\n-                let lint = if tcx.lint_level_at_node(SAFE_PACKED_BORROWS, lint_root).0\n-                    <= tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, lint_root).0\n-                {\n-                    SAFE_PACKED_BORROWS\n-                } else {\n-                    UNSAFE_OP_IN_UNSAFE_FN\n-                };\n-                tcx.struct_span_lint_hir(&lint, lint_root, source_info.span, |lint| {\n-                    lint.build(&format!(\n-                        \"{} is unsafe and requires unsafe block (error E0133)\",\n-                        description,\n-                    ))\n-                    .span_label(source_info.span, description)\n-                    .note(note)\n-                    .emit();\n-                })\n-            }\n         }\n     }\n "}, {"sha": "5c49ee69edc51622a24aec74be2f1bf6733e583e", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -59,6 +59,7 @@ pub use rustc_middle::mir::MirSource;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::check_unsafety::provide(providers);\n+    self::check_packed_ref::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_const,"}, {"sha": "2392f0174b6f0e175681b2515b7f30666ea156cc", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -767,6 +767,7 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///     unaligned: 0x01020304,\n /// };\n ///\n+/// #[allow(unaligned_references)]\n /// let v = unsafe {\n ///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n ///     let unaligned =\n@@ -960,6 +961,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n /// let v = 0x01020304;\n /// let mut packed: Packed = unsafe { std::mem::zeroed() };\n ///\n+/// #[allow(unaligned_references)]\n /// let v = unsafe {\n ///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n ///     let unaligned ="}, {"sha": "ca4f0efd2392b3c20517eb9f3fb739aa4e092a5d", "filename": "src/test/ui/binding/issue-53114-safety-checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -20,13 +20,13 @@ fn let_wild_gets_unsafe_field() {\n     let u1 = U { a: I(0) };\n     let u2 = U { a: I(1) };\n     let p = P { a: &2, b: &3 };\n-    let _ = &p.b;  //~ WARN    E0133\n+    let _ = &p.b;  //~ WARN    reference to packed field\n     //~^  WARN will become a hard error\n     let _ = u1.a;  // #53114: should eventually signal error as well\n     let _ = &u2.a; //~ ERROR  [E0133]\n \n     // variation on above with `_` in substructure\n-    let (_,) = (&p.b,);  //~ WARN     E0133\n+    let (_,) = (&p.b,);  //~ WARN     reference to packed field\n     //~^  WARN will become a hard error\n     let (_,) = (u1.a,);  //~ ERROR   [E0133]\n     let (_,) = (&u2.a,); //~ ERROR   [E0133]\n@@ -36,13 +36,13 @@ fn match_unsafe_field_to_wild() {\n     let u1 = U { a: I(0) };\n     let u2 = U { a: I(1) };\n     let p = P { a: &2, b: &3 };\n-    match &p.b  { _ => { } } //~ WARN     E0133\n+    match &p.b  { _ => { } } //~ WARN     reference to packed field\n     //~^  WARN will become a hard error\n     match u1.a  { _ => { } } //~ ERROR   [E0133]\n     match &u2.a { _ => { } } //~ ERROR   [E0133]\n \n     // variation on above with `_` in substructure\n-    match (&p.b,)  { (_,) => { } } //~ WARN     E0133\n+    match (&p.b,)  { (_,) => { } } //~ WARN     reference to packed field\n     //~^  WARN will become a hard error\n     match (u1.a,)  { (_,) => { } } //~ ERROR   [E0133]\n     match (&u2.a,) { (_,) => { } } //~ ERROR   [E0133]"}, {"sha": "9e7deea4524cbeadb6d9fc51b7e999fbd80df301", "filename": "src/test/ui/binding/issue-53114-safety-checks.stderr", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fissue-53114-safety-checks.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,13 +1,43 @@\n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+warning: reference to packed field is unaligned\n   --> $DIR/issue-53114-safety-checks.rs:23:13\n    |\n LL |     let _ = &p.b;\n    |             ^^^^\n    |\n-   = note: `#[warn(safe_packed_borrows)]` on by default\n+   = note: `#[warn(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:29:17\n+   |\n+LL |     let (_,) = (&p.b,);\n+   |                 ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:39:11\n+   |\n+LL |     match &p.b  { _ => { } }\n+   |           ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/issue-53114-safety-checks.rs:45:12\n+   |\n+LL |     match (&p.b,)  { (_,) => { } }\n+   |            ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:26:13\n@@ -17,16 +47,6 @@ LL |     let _ = &u2.a;\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-53114-safety-checks.rs:29:17\n-   |\n-LL |     let (_,) = (&p.b,);\n-   |                 ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:31:17\n    |\n@@ -43,16 +63,6 @@ LL |     let (_,) = (&u2.a,);\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-53114-safety-checks.rs:39:11\n-   |\n-LL |     match &p.b  { _ => { } }\n-   |           ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:41:11\n    |\n@@ -69,16 +79,6 @@ LL |     match &u2.a { _ => { } }\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-53114-safety-checks.rs:45:12\n-   |\n-LL |     match (&p.b,)  { (_,) => { } }\n-   |            ^^^^\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n error[E0133]: access to union field is unsafe and requires unsafe function or block\n   --> $DIR/issue-53114-safety-checks.rs:47:12\n    |"}, {"sha": "82ec60a2e790af65ac7ce2103c59d50e73ab5ddd", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -23,7 +23,7 @@ fn test_missing_unsafe_warning_on_repr_packed() {\n \n     let c = || {\n         println!(\"{}\", foo.x);\n-        //~^ WARNING: borrow of packed field is unsafe and requires unsafe function or block\n+        //~^ WARNING: reference to packed field is unaligned\n         //~| WARNING: this was previously accepted by the compiler but is being phased out\n         let _z = foo.x;\n     };"}, {"sha": "e8cc164be8754fabbbec6c7dc47e07e998426186", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -7,16 +7,16 @@ LL | #![feature(capture_disjoint_fields)]\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n-warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+warning: reference to packed field is unaligned\n   --> $DIR/repr_packed.rs:25:24\n    |\n LL |         println!(\"{}\", foo.x);\n    |                        ^^^^^\n    |\n-   = note: `#[warn(safe_packed_borrows)]` on by default\n+   = note: `#[warn(unaligned_references)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n warning: 2 warnings emitted\n "}, {"sha": "b78eeaa90551b067b35d85500e61c68ff2b0effe", "filename": "src/test/ui/derives/deriving-with-repr-packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,4 +1,4 @@\n-#![deny(safe_packed_borrows)]\n+#![deny(unaligned_references)]\n \n // check that derive on a packed struct with non-Copy fields\n // correctly. This can't be made to work perfectly because"}, {"sha": "3caa563a08560c8ec8bd4126da7fe8a2d1df2116", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -7,10 +7,10 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n note: the lint level is defined here\n   --> $DIR/deriving-with-repr-packed.rs:1:9\n    |\n-LL | #![deny(safe_packed_borrows)]\n-   |         ^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(unaligned_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n@@ -20,7 +20,7 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n    |                       ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n@@ -30,7 +30,7 @@ LL | #[derive(PartialEq, Eq)]\n    |          ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n@@ -40,7 +40,7 @@ LL | #[derive(PartialEq)]\n    |          ^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors"}, {"sha": "d9159f6669d60881355049da9582a0901a2e058d", "filename": "src/test/ui/issues/issue-27060-rpass.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fissues%2Fissue-27060-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fissues%2Fissue-27060-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060-rpass.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -8,14 +8,12 @@ pub struct Good {\n }\n \n // kill this test when that turns to a hard error\n-#[allow(safe_packed_borrows)]\n+#[allow(unaligned_references)]\n fn main() {\n     let good = Good { data: &0, data2: [&0, &0], aligned: [0; 32] };\n \n-    unsafe {\n-        let _ = &good.data; // ok\n-        let _ = &good.data2[0]; // ok\n-    }\n+    let _ = &good.data; // ok\n+    let _ = &good.data2[0]; // ok\n \n     let _ = &good.data;\n     let _ = &good.data2[0];"}, {"sha": "5317a61671945b8ebffac9abb0cd73512b068cd9", "filename": "src/test/ui/issues/issue-27060.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fissues%2Fissue-27060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fissues%2Fissue-27060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -5,22 +5,22 @@ pub struct Good {\n     aligned: [u8; 32],\n }\n \n-#[deny(safe_packed_borrows)]\n+#[deny(unaligned_references)]\n fn main() {\n     let good = Good {\n         data: &0,\n         data2: [&0, &0],\n         aligned: [0; 32]\n     };\n \n-    unsafe {\n-        let _ = &good.data; // ok\n-        let _ = &good.data2[0]; // ok\n-    }\n+    let _ = &good.data; //~ ERROR reference to packed field\n+    //~| hard error\n+    let _ = &good.data2[0]; //~ ERROR reference to packed field\n+    //~| hard error\n \n-    let _ = &good.data; //~ ERROR borrow of packed field is unsafe\n+    let _ = &good.data; //~ ERROR reference to packed field\n                         //~| hard error\n-    let _ = &good.data2[0]; //~ ERROR borrow of packed field is unsafe\n+    let _ = &good.data2[0]; //~ ERROR reference to packed field\n                             //~| hard error\n     let _ = &*good.data; // ok, behind a pointer\n     let _ = &good.aligned; // ok, has align 1"}, {"sha": "09297884ed377bd6ce994dbfcf0c242476979986", "filename": "src/test/ui/issues/issue-27060.stderr", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fissues%2Fissue-27060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fissues%2Fissue-27060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,27 +1,47 @@\n-error: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n-  --> $DIR/issue-27060.rs:21:13\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:16:13\n    |\n LL |     let _ = &good.data;\n    |             ^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/issue-27060.rs:8:8\n    |\n-LL | #[deny(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n+LL | #[deny(unaligned_references)]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:18:13\n+   |\n+LL |     let _ = &good.data2[0];\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+error: reference to packed field is unaligned\n+  --> $DIR/issue-27060.rs:21:13\n+   |\n+LL |     let _ = &good.data;\n+   |             ^^^^^^^^^^\n+   |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n-error: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+error: reference to packed field is unaligned\n   --> $DIR/issue-27060.rs:23:13\n    |\n LL |     let _ = &good.data2[0];\n    |             ^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "ad38c21d96cf93c25131e092ab93240ceb2d80bd", "filename": "src/test/ui/lint/unaligned_references.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -13,14 +13,20 @@ fn main() {\n         let good = Good { data: 0, ptr: &0, data2: [0, 0], aligned: [0; 32] };\n \n         let _ = &good.ptr; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         let _ = &good.data; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         // Error even when turned into raw pointer immediately.\n         let _ = &good.data as *const _; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         let _: *const _ = &good.data; //~ ERROR reference to packed field\n+        //~^ previously accepted\n         // Error on method call.\n         let _ = good.data.clone(); //~ ERROR reference to packed field\n+        //~^ previously accepted\n         // Error for nested fields.\n         let _ = &good.data2[0]; //~ ERROR reference to packed field\n+        //~^ previously accepted\n \n         let _ = &*good.ptr; // ok, behind a pointer\n         let _ = &good.aligned; // ok, has align 1"}, {"sha": "9ae25f5b59ed102485ad30d404cd00d7b853e79a", "filename": "src/test/ui/lint/unaligned_references.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -9,46 +9,58 @@ note: the lint level is defined here\n    |\n LL | #![deny(unaligned_references)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:16:17\n+  --> $DIR/unaligned_references.rs:17:17\n    |\n LL |         let _ = &good.data;\n    |                 ^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:18:17\n+  --> $DIR/unaligned_references.rs:20:17\n    |\n LL |         let _ = &good.data as *const _;\n    |                 ^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:19:27\n+  --> $DIR/unaligned_references.rs:22:27\n    |\n LL |         let _: *const _ = &good.data;\n    |                           ^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:21:17\n+  --> $DIR/unaligned_references.rs:25:17\n    |\n LL |         let _ = good.data.clone();\n    |                 ^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references.rs:23:17\n+  --> $DIR/unaligned_references.rs:28:17\n    |\n LL |         let _ = &good.data2[0];\n    |                 ^^^^^^^^^^^^^^\n    |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n \n error: aborting due to 6 previous errors"}, {"sha": "cb597c38e779283a8ce6cf996ef18644f56bb2ae", "filename": "src/test/ui/lint/unaligned_references_external_macro.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,10 +1,9 @@\n // aux-build:unaligned_references_external_crate.rs\n \n-#![allow(safe_packed_borrows)]\n-\n extern crate unaligned_references_external_crate;\n \n unaligned_references_external_crate::mac! { //~ERROR reference to packed field is unaligned\n+    //~^ previously accepted\n     #[repr(packed)]\n     pub struct X {\n         pub field: u16"}, {"sha": "4e7c6bfc98d9d2c68fcfc7bcf8e45aabe50d5865", "filename": "src/test/ui/lint/unaligned_references_external_macro.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funaligned_references_external_macro.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,7 +1,8 @@\n error: reference to packed field is unaligned\n-  --> $DIR/unaligned_references_external_macro.rs:7:1\n+  --> $DIR/unaligned_references_external_macro.rs:5:1\n    |\n LL | / unaligned_references_external_crate::mac! {\n+LL | |\n LL | |     #[repr(packed)]\n LL | |     pub struct X {\n LL | |         pub field: u16\n@@ -10,15 +11,18 @@ LL | | }\n    | |_^\n    |\n note: the lint level is defined here\n-  --> $DIR/unaligned_references_external_macro.rs:7:1\n+  --> $DIR/unaligned_references_external_macro.rs:5:1\n    |\n LL | / unaligned_references_external_crate::mac! {\n+LL | |\n LL | |     #[repr(packed)]\n LL | |     pub struct X {\n LL | |         pub field: u16\n LL | |     }\n LL | | }\n    | |_^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n    = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "fb3875e680496f9fb4adaf3d18a8cd97c961e6cf", "filename": "src/test/ui/packed/packed-struct-address-of-element.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-address-of-element.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n-#![deny(safe_packed_borrows)]\n+#![deny(unaligned_references)]\n #![feature(raw_ref_op)]\n // ignore-emscripten weird assertion?\n "}, {"sha": "5dad084eecf6dd33cbbe6f08ced62730b6253544", "filename": "src/test/ui/packed/packed-struct-borrow-element.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.rs?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -22,14 +22,17 @@ struct Foo4C {\n \n pub fn main() {\n     let foo = Foo1 { bar: 1, baz: 2 };\n-    let brw = unsafe { &foo.baz };\n+    let brw = &foo.baz; //~WARN reference to packed field is unaligned\n+    //~^ previously accepted\n     assert_eq!(*brw, 2);\n \n     let foo = Foo2 { bar: 1, baz: 2 };\n-    let brw = unsafe { &foo.baz };\n+    let brw = &foo.baz; //~WARN reference to packed field is unaligned\n+    //~^ previously accepted\n     assert_eq!(*brw, 2);\n \n     let foo = Foo4C { bar: 1, baz: 2 };\n-    let brw = unsafe { &foo.baz };\n+    let brw = &foo.baz; //~WARN reference to packed field is unaligned\n+    //~^ previously accepted\n     assert_eq!(*brw, 2);\n }"}, {"sha": "d9d9a71ff58e93ce359b0ed0dd517ff3d5e81788", "filename": "src/test/ui/packed/packed-struct-borrow-element.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a900677eb962741bd522c653b7933e97af130f24/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpacked%2Fpacked-struct-borrow-element.stderr?ref=a900677eb962741bd522c653b7933e97af130f24", "patch": "@@ -0,0 +1,33 @@\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:25:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+   = note: `#[warn(unaligned_references)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:30:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: reference to packed field is unaligned\n+  --> $DIR/packed-struct-borrow-element.rs:35:15\n+   |\n+LL |     let brw = &foo.baz;\n+   |               ^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\n+   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "540612a7dce0576777c6ae080928f2a3fc9c4778", "filename": "src/test/ui/unsafe/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/520c9a25dfc78ca1e1d198e55bb4bcb844b0791e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520c9a25dfc78ca1e1d198e55bb4bcb844b0791e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs?ref=520c9a25dfc78ca1e1d198e55bb4bcb844b0791e", "patch": "@@ -1,67 +0,0 @@\n-#![feature(unsafe_block_in_unsafe_fn)]\n-\n-#[repr(packed)]\n-pub struct Packed {\n-    data: &'static u32,\n-}\n-\n-const PACKED: Packed = Packed { data: &0 };\n-\n-#[allow(safe_packed_borrows)]\n-#[allow(unsafe_op_in_unsafe_fn)]\n-unsafe fn allow_allow() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[allow(safe_packed_borrows)]\n-#[warn(unsafe_op_in_unsafe_fn)]\n-unsafe fn allow_warn() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[allow(safe_packed_borrows)]\n-#[deny(unsafe_op_in_unsafe_fn)]\n-unsafe fn allow_deny() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[warn(safe_packed_borrows)]\n-#[allow(unsafe_op_in_unsafe_fn)]\n-unsafe fn warn_allow() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[warn(safe_packed_borrows)]\n-#[warn(unsafe_op_in_unsafe_fn)]\n-unsafe fn warn_warn() {\n-    &PACKED.data; //~ WARN\n-    //~| WARNING this was previously accepted by the compiler but is being phased out\n-}\n-\n-#[warn(safe_packed_borrows)]\n-#[deny(unsafe_op_in_unsafe_fn)]\n-unsafe fn warn_deny() {\n-    &PACKED.data; //~ WARN\n-    //~| WARNING this was previously accepted by the compiler but is being phased out\n-}\n-\n-#[deny(safe_packed_borrows)]\n-#[allow(unsafe_op_in_unsafe_fn)]\n-unsafe fn deny_allow() {\n-    &PACKED.data; // allowed\n-}\n-\n-#[deny(safe_packed_borrows)]\n-#[warn(unsafe_op_in_unsafe_fn)]\n-unsafe fn deny_warn() {\n-    &PACKED.data; //~ WARN\n-}\n-\n-#[deny(safe_packed_borrows)]\n-#[deny(unsafe_op_in_unsafe_fn)]\n-unsafe fn deny_deny() {\n-    &PACKED.data; //~ ERROR\n-    //~| WARNING this was previously accepted by the compiler but is being phased out\n-}\n-\n-fn main() {}"}, {"sha": "fda15159643b6ec2526a547a8d25ba49e244c882", "filename": "src/test/ui/unsafe/rfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/520c9a25dfc78ca1e1d198e55bb4bcb844b0791e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/520c9a25dfc78ca1e1d198e55bb4bcb844b0791e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr?ref=520c9a25dfc78ca1e1d198e55bb4bcb844b0791e", "patch": "@@ -1,60 +0,0 @@\n-warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:37:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:34:8\n-   |\n-LL | #[warn(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:44:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:41:8\n-   |\n-LL | #[warn(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:57:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:55:8\n-   |\n-LL | #[warn(unsafe_op_in_unsafe_fn)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-error: borrow of packed field is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:63:5\n-   |\n-LL |     &PACKED.data;\n-   |     ^^^^^^^^^^^^ borrow of packed field\n-   |\n-note: the lint level is defined here\n-  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:60:8\n-   |\n-LL | #[deny(safe_packed_borrows)]\n-   |        ^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n-\n-error: aborting due to previous error; 3 warnings emitted\n-"}]}