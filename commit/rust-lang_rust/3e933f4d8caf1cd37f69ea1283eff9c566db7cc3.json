{"sha": "3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOTMzZjRkOGNhZjFjZDM3ZjY5ZWExMjgzZWZmOWM1NjZkYjdjYzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-05-17T14:14:30Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-19T12:24:24Z"}, "message": "Keep statics' constant as ByRef", "tree": {"sha": "7c20a0c41e70a521458c87e8d80b71e6e0668dc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c20a0c41e70a521458c87e8d80b71e6e0668dc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "html_url": "https://github.com/rust-lang/rust/commit/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6630678428ee7857da4880dfbab519286e436adc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6630678428ee7857da4880dfbab519286e436adc", "html_url": "https://github.com/rust-lang/rust/commit/6630678428ee7857da4880dfbab519286e436adc"}], "stats": {"total": 64, "additions": 44, "deletions": 20}, "files": [{"sha": "ec696ec82b9d76684ca8529281ae466dc4d08316", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "patch": "@@ -95,42 +95,35 @@ pub fn eval_body<'a, 'tcx>(\n \n pub fn value_to_const_value<'tcx>(\n     ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n-    mut val: Value,\n+    val: Value,\n     ty: Ty<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    let layout = tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n+    let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n     match (val, &layout.abi) {\n+        (Value::ByVal(PrimVal::Undef), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n         (Value::ByVal(_), &layout::Abi::Scalar(_)) |\n         (Value::ByValPair(..), &layout::Abi::ScalarPair(..)) => {},\n         _ => bug!(\"bad value/layout combo: {:#?}, {:#?}\", val, layout),\n     }\n     let val = (|| {\n-        // Convert to ByVal or ByValPair if possible\n-        if let Value::ByRef(ptr, align) = val {\n-            if let Some(read_val) = ecx.try_read_value(ptr, align, ty)? {\n-                val = read_val;\n-            }\n-        }\n         match val {\n             Value::ByVal(val) => Ok(ConstValue::ByVal(val)),\n             Value::ByValPair(a, b) => Ok(ConstValue::ByValPair(a, b)),\n             Value::ByRef(ptr, align) => {\n                 let ptr = ptr.primval.to_ptr().unwrap();\n-                assert_eq!(ptr.offset, 0);\n                 let alloc = ecx.memory.get(ptr.alloc_id)?;\n-                assert!(alloc.align.abi() >= layout.align.abi());\n-                assert!(alloc.bytes.len() as u64 == layout.size.bytes());\n+                assert!(alloc.align.abi() >= align.abi());\n+                assert!(alloc.bytes.len() as u64 - ptr.offset >= layout.size.bytes());\n                 let mut alloc = alloc.clone();\n-                // The align field is meaningless for values, so just use the layout's align\n-                alloc.align = layout.align;\n+                alloc.align = align;\n                 let alloc = ecx.tcx.intern_const_alloc(alloc);\n-                Ok(ConstValue::ByRef(alloc))\n+                Ok(ConstValue::ByRef(alloc, ptr.offset))\n             }\n         }\n     })();\n-    match result {\n-        Ok(v) => ty::Const::from_const_value(tcx, val, ty),\n+    match val {\n+        Ok(val) => ty::Const::from_const_value(ecx.tcx.tcx, val, ty),\n         Err(mut err) => {\n             ecx.report(&mut err, true, None);\n             bug!(\"miri error occured when converting Value to ConstValue\")\n@@ -427,7 +420,7 @@ pub fn const_val_field<'a, 'tcx>(\n             Value::ByRef(ptr, align) => (ptr, align),\n             Value::ByValPair(..) | Value::ByVal(_) => {\n                 let ptr = ecx.alloc_ptr(ty)?.into();\n-                ecx.write_value_to_ptr(value, ptr, ty)?;\n+                ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n                 (ptr, layout.align)\n             },\n         };\n@@ -438,7 +431,21 @@ pub fn const_val_field<'a, 'tcx>(\n         };\n         let (place, layout) = ecx.place_field(place, field, layout)?;\n         let (ptr, align) = place.to_ptr_align();\n-        Ok((Value::ByRef(ptr, align), layout.ty))\n+        let mut new_value = Value::ByRef(ptr, align);\n+        new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n+        use rustc_data_structures::indexed_vec::Idx;\n+        match (value, new_value) {\n+            (Value::ByVal(_), Value::ByRef(..)) |\n+            (Value::ByValPair(..), Value::ByRef(..)) |\n+            (Value::ByVal(_), Value::ByValPair(..)) => bug!(\n+                \"field {} of {:?} yielded {:?}\",\n+                field.index(),\n+                value,\n+                new_value,\n+            ),\n+            _ => {},\n+        }\n+        Ok(value_to_const_value(&ecx, new_value, layout.ty))\n     })();\n     result.map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n@@ -535,8 +542,11 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.map(|(val, _, miri_ty)| {\n-        value_to_const_value(&ecx, val, miri_ty)\n+    res.and_then(|(mut val, _, miri_ty)| {\n+        if tcx.is_static(def_id).is_none() {\n+            val = ecx.try_read_by_ref(val, miri_ty)?;\n+        }\n+        Ok(value_to_const_value(&ecx, val, miri_ty))\n     }).map_err(|mut err| {\n         if tcx.is_static(def_id).is_some() {\n             ecx.report(&mut err, true, None);"}, {"sha": "7ad507331fa741c18336be21298ae4b448c9a0f2", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e933f4d8caf1cd37f69ea1283eff9c566db7cc3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=3e933f4d8caf1cd37f69ea1283eff9c566db7cc3", "patch": "@@ -1412,10 +1412,24 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n+    pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        // Convert to ByVal or ByValPair if possible\n+        if let Value::ByRef(ptr, align) = val {\n+            if let Some(read_val) = self.try_read_value(ptr, align, ty)? {\n+                val = read_val;\n+            }\n+        }\n+        Ok(val)\n+    }\n+\n     pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         let layout = self.layout_of(ty)?;\n         self.memory.check_align(ptr, ptr_align)?;\n \n+        if layout.size.bytes() == 0 {\n+            return Ok(Some(Value::ByVal(PrimVal::Undef)));\n+        }\n+\n         let ptr = ptr.to_ptr()?;\n \n         // Not the right place to do this"}]}