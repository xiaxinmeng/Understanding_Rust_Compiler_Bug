{"sha": "5e04f513cdb173ed808b4c770d146dd9927df3a0", "node_id": "C_kwDOAAsO6NoAKDVlMDRmNTEzY2RiMTczZWQ4MDhiNGM3NzBkMTQ2ZGQ5OTI3ZGYzYTA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-13T07:11:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-13T07:11:20Z"}, "message": "Rollup merge of #92142 - wesleywiser:fix_codecoverage_partitioning, r=tmandry\n\n[code coverage] Fix missing dead code in modules that are never called\n\nThe issue here is that the logic used to determine which CGU to put the dead function stubs in doesn't handle cases where a module is never assigned to a CGU (which is what happens when all of the code in the module is dead).\n\nThe partitioning logic also caused issues in #85461 where inline functions were duplicated into multiple CGUs resulting in duplicate symbols.\n\nThis commit fixes the issue by removing the complex logic used to assign dead code stubs to CGUs and replaces it with a much simpler model: we pick one CGU to hold all the dead code stubs. We pick a CGU which has exported items which increases the likelihood the linker won't throw away our dead functions and we pick the smallest to minimize the impact on compilation times for crates with very large CGUs.\n\nFixes #91661\nFixes #86177\nFixes #85718\nFixes #79622\n\nr? ```@tmandry```\ncc ```@richkadel```\n\nThis PR is not urgent so please don't let it interrupt your holidays! \ud83c\udf84 \ud83c\udf81", "tree": {"sha": "2218fc71524cacb96a93ecd8ffc47810b18ece3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2218fc71524cacb96a93ecd8ffc47810b18ece3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e04f513cdb173ed808b4c770d146dd9927df3a0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh39CYCRBK7hj4Ov3rIwAAdCAIAJw1adk+CaAJRMQL4l5WAUgB\nthxnV1aRxRTaB7AWuzI/ZOG5mf6FzPiHMhPTTKVlt0ukfJPElcQUIkMzBVDJA/xb\nvNEy0XF97Dv6H7icvqRYjJ0XvNxfNDpWLY08lgLcma0y5KvA3VOhLUSioVy+e0Bi\nBPBnHDiFQp8P2hK/GLV2sMe7aJprUCj+p6hBYKG93i6OMAIW8MDCpdx3RpMD/06H\nvFx2VYdku6EQl01opapWBOdJgxPnzxuCYqZZnauibUWSY0wK9b3U5pJRBsXkBLxt\niQvCaABxe+OK7ZEZr2cEAb2fw8tN/DbvZOk+/Kzfs53rgDMQ1mSvQ11l2dDVj+w=\n=tZph\n-----END PGP SIGNATURE-----\n", "payload": "tree 2218fc71524cacb96a93ecd8ffc47810b18ece3d\nparent b45a819bef7208192886584c6ef52654bcd26299\nparent e9cac4ca627a4da45d24ca7341bb7c66aa59cbe2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642057880 +0100\ncommitter GitHub <noreply@github.com> 1642057880 +0100\n\nRollup merge of #92142 - wesleywiser:fix_codecoverage_partitioning, r=tmandry\n\n[code coverage] Fix missing dead code in modules that are never called\n\nThe issue here is that the logic used to determine which CGU to put the dead function stubs in doesn't handle cases where a module is never assigned to a CGU (which is what happens when all of the code in the module is dead).\n\nThe partitioning logic also caused issues in #85461 where inline functions were duplicated into multiple CGUs resulting in duplicate symbols.\n\nThis commit fixes the issue by removing the complex logic used to assign dead code stubs to CGUs and replaces it with a much simpler model: we pick one CGU to hold all the dead code stubs. We pick a CGU which has exported items which increases the likelihood the linker won't throw away our dead functions and we pick the smallest to minimize the impact on compilation times for crates with very large CGUs.\n\nFixes #91661\nFixes #86177\nFixes #85718\nFixes #79622\n\nr? ```@tmandry```\ncc ```@richkadel```\n\nThis PR is not urgent so please don't let it interrupt your holidays! \ud83c\udf84 \ud83c\udf81\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e04f513cdb173ed808b4c770d146dd9927df3a0", "html_url": "https://github.com/rust-lang/rust/commit/5e04f513cdb173ed808b4c770d146dd9927df3a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e04f513cdb173ed808b4c770d146dd9927df3a0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b45a819bef7208192886584c6ef52654bcd26299", "url": "https://api.github.com/repos/rust-lang/rust/commits/b45a819bef7208192886584c6ef52654bcd26299", "html_url": "https://github.com/rust-lang/rust/commit/b45a819bef7208192886584c6ef52654bcd26299"}, {"sha": "e9cac4ca627a4da45d24ca7341bb7c66aa59cbe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9cac4ca627a4da45d24ca7341bb7c66aa59cbe2", "html_url": "https://github.com/rust-lang/rust/commit/e9cac4ca627a4da45d24ca7341bb7c66aa59cbe2"}], "stats": {"total": 221, "additions": 103, "deletions": 118}, "files": [{"sha": "32f18419753e9827fb02ab6966c4ad2b246e163f", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 34, "deletions": 86, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -5,12 +5,13 @@ use crate::llvm;\n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_llvm::RustString;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Symbol;\n \n use std::ffi::CString;\n \n@@ -46,7 +47,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // functions exist. Generate synthetic functions with a (required) single counter, and add the\n     // MIR `Coverage` code regions to the `function_coverage_map`, before calling\n     // `ctx.take_function_coverage_map()`.\n-    if !tcx.sess.instrument_coverage_except_unused_functions() {\n+    if cx.codegen_unit.is_code_coverage_dead_code_cgu() {\n         add_unused_functions(cx);\n     }\n \n@@ -271,26 +272,35 @@ fn save_function_record(\n /// `DefId`s (`tcx` query `mir_keys`) minus the codegenned `DefId`s (`tcx` query\n /// `codegened_and_inlined_items`).\n ///\n-/// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and\n-/// this function is processing a `function_coverage_map` for the functions (`Instance`/`DefId`)\n-/// allocated to only one of those CGUs. We must NOT inject any unused functions's `CodeRegion`s\n-/// more than once, so we have to pick a CGUs `function_coverage_map` into which the unused\n-/// function will be inserted.\n+/// These unused functions are then codegen'd in one of the CGUs which is marked as the\n+/// \"code coverage dead code cgu\" during the partitioning process. This prevents us from generating\n+/// code regions for the same function more than once which can lead to linker errors regarding\n+/// duplicate symbols.\n fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let tcx = cx.tcx;\n+    assert!(cx.codegen_unit.is_code_coverage_dead_code_cgu());\n \n-    // FIXME(#79622): Can this solution be simplified and/or improved? Are there other sources\n-    // of compiler state data that might help (or better sources that could be exposed, but\n-    // aren't yet)?\n+    let tcx = cx.tcx;\n \n     let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n-    let all_def_ids: DefIdSet = tcx\n+    let eligible_def_ids: DefIdSet = tcx\n         .mir_keys(())\n         .iter()\n         .filter_map(|local_def_id| {\n             let def_id = local_def_id.to_def_id();\n-            if ignore_unused_generics && tcx.generics_of(def_id).requires_monomorphization(tcx) {\n+            let kind = tcx.def_kind(def_id);\n+            // `mir_keys` will give us `DefId`s for all kinds of things, not\n+            // just \"functions\", like consts, statics, etc. Filter those out.\n+            // If `ignore_unused_generics` was specified, filter out any\n+            // generic functions from consideration as well.\n+            if !matches!(\n+                kind,\n+                DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator\n+            ) {\n+                return None;\n+            } else if ignore_unused_generics\n+                && tcx.generics_of(def_id).requires_monomorphization(tcx)\n+            {\n                 return None;\n             }\n             Some(local_def_id.to_def_id())\n@@ -299,79 +309,17 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     let codegenned_def_ids = tcx.codegened_and_inlined_items(());\n \n-    let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n-    for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        // Make sure the non-codegenned (unused) function has at least one MIR\n-        // `Coverage` statement with a code region, and return its file name.\n-        if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n-            let def_ids =\n-                unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);\n-            def_ids.push(non_codegenned_def_id);\n-        }\n-    }\n+    for &non_codegenned_def_id in eligible_def_ids.difference(codegenned_def_ids) {\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n \n-    if unused_def_ids_by_file.is_empty() {\n-        // There are no unused functions with file names to add (in any CGU)\n-        return;\n-    }\n-\n-    // Each `CodegenUnit` (CGU) has its own function_coverage_map, and generates a specific binary\n-    // with its own coverage map.\n-    //\n-    // Each covered function `Instance` can be included in only one coverage map, produced from a\n-    // specific function_coverage_map, from a specific CGU.\n-    //\n-    // Since unused functions did not generate code, they are not associated with any CGU yet.\n-    //\n-    // To avoid injecting the unused functions in multiple coverage maps (for multiple CGUs)\n-    // determine which function_coverage_map has the responsibility for publishing unreachable\n-    // coverage, based on file name: For each unused function, find the CGU that generates the\n-    // first function (based on sorted `DefId`) from the same file.\n-    //\n-    // Add a new `FunctionCoverage` to the `function_coverage_map`, with unreachable code regions\n-    // for each region in it's MIR.\n-\n-    // Convert the `HashSet` of `codegenned_def_ids` to a sortable vector, and sort them.\n-    let mut sorted_codegenned_def_ids: Vec<DefId> = codegenned_def_ids.iter().copied().collect();\n-    sorted_codegenned_def_ids.sort_unstable();\n-\n-    let mut first_covered_def_id_by_file: FxHashMap<Symbol, DefId> = FxHashMap::default();\n-    for &def_id in sorted_codegenned_def_ids.iter() {\n-        if let Some(covered_file_name) = tcx.covered_file_name(def_id) {\n-            // Only add files known to have unused functions\n-            if unused_def_ids_by_file.contains_key(covered_file_name) {\n-                first_covered_def_id_by_file.entry(*covered_file_name).or_insert(def_id);\n-            }\n+        // If a function is marked `#[no_coverage]`, then skip generating a\n+        // dead code stub for it.\n+        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_COVERAGE) {\n+            debug!(\"skipping unused fn marked #[no_coverage]: {:?}\", non_codegenned_def_id);\n+            continue;\n         }\n-    }\n-\n-    // Get the set of def_ids with coverage regions, known by *this* CoverageContext.\n-    let cgu_covered_def_ids: DefIdSet = match cx.coverage_context() {\n-        Some(ctx) => ctx\n-            .function_coverage_map\n-            .borrow()\n-            .keys()\n-            .map(|&instance| instance.def.def_id())\n-            .collect(),\n-        None => return,\n-    };\n \n-    let cgu_covered_files: FxHashSet<Symbol> = first_covered_def_id_by_file\n-        .iter()\n-        .filter_map(\n-            |(&file_name, def_id)| {\n-                if cgu_covered_def_ids.contains(def_id) { Some(file_name) } else { None }\n-            },\n-        )\n-        .collect();\n-\n-    // For each file for which this CGU is responsible for adding unused function coverage,\n-    // get the `def_id`s for each unused function (if any), define a synthetic function with a\n-    // single LLVM coverage counter, and add the function's coverage `CodeRegion`s. to the\n-    // function_coverage_map.\n-    for covered_file_name in cgu_covered_files {\n-        for def_id in unused_def_ids_by_file.remove(&covered_file_name).into_iter().flatten() {\n-            cx.define_unused_fn(def_id);\n-        }\n+        debug!(\"generating unused fn: {:?}\", non_codegenned_def_id);\n+        cx.define_unused_fn(non_codegenned_def_id);\n     }\n }"}, {"sha": "3a6c091b3313d33a7a8d79fde56cc4da97e6c63b", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -247,6 +247,9 @@ pub struct CodegenUnit<'tcx> {\n     items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n     size_estimate: Option<usize>,\n     primary: bool,\n+    /// True if this is CGU is used to hold code coverage information for dead code,\n+    /// false otherwise.\n+    is_code_coverage_dead_code_cgu: bool,\n }\n \n /// Specifies the linkage type for a `MonoItem`.\n@@ -277,7 +280,13 @@ pub enum Visibility {\n impl<'tcx> CodegenUnit<'tcx> {\n     #[inline]\n     pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n-        CodegenUnit { name, items: Default::default(), size_estimate: None, primary: false }\n+        CodegenUnit {\n+            name,\n+            items: Default::default(),\n+            size_estimate: None,\n+            primary: false,\n+            is_code_coverage_dead_code_cgu: false,\n+        }\n     }\n \n     pub fn name(&self) -> Symbol {\n@@ -304,6 +313,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n         &mut self.items\n     }\n \n+    pub fn is_code_coverage_dead_code_cgu(&self) -> bool {\n+        self.is_code_coverage_dead_code_cgu\n+    }\n+\n+    /// Marks this CGU as the one used to contain code coverage information for dead code.\n+    pub fn make_code_coverage_dead_code_cgu(&mut self) {\n+        self.is_code_coverage_dead_code_cgu = true;\n+    }\n+\n     pub fn mangle_name(human_readable_name: &str) -> String {\n         // We generate a 80 bit hash from the name. This should be enough to\n         // avoid collisions and is still reasonably short for filenames.\n@@ -404,9 +422,11 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n             // The size estimate is not relevant to the hash\n             size_estimate: _,\n             primary: _,\n+            is_code_coverage_dead_code_cgu,\n         } = *self;\n \n         name.hash_stable(hcx, hasher);\n+        is_code_coverage_dead_code_cgu.hash_stable(hcx, hasher);\n \n         let mut items: Vec<(Fingerprint, _)> = items\n             .iter()"}, {"sha": "3772f1c9feab0812d3c4d48affdd2ee9fbc01370", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -386,16 +386,6 @@ rustc_queries! {\n         storage(ArenaCacheSelector<'tcx>)\n     }\n \n-    /// Returns the name of the file that contains the function body, if instrumented for coverage.\n-    query covered_file_name(key: DefId) -> Option<Symbol> {\n-        desc {\n-            |tcx| \"retrieving the covered file name, if instrumented, for `{}`\",\n-            tcx.def_path_str(key)\n-        }\n-        storage(ArenaCacheSelector<'tcx>)\n-        cache_on_disk_if { key.is_local() }\n-    }\n-\n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n     /// function was optimized out before codegen, and before being added to the Coverage Map.\n     query covered_code_regions(key: DefId) -> Vec<&'tcx mir::coverage::CodeRegion> {"}, {"sha": "46de6d939a1df69fbc48754e4c02d94fb3b6225d", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -9,7 +9,6 @@ use rustc_span::def_id::DefId;\n /// A `query` provider for retrieving coverage information injected into MIR.\n pub(crate) fn provide(providers: &mut Providers) {\n     providers.coverageinfo = |tcx, def_id| coverageinfo(tcx, def_id);\n-    providers.covered_file_name = |tcx, def_id| covered_file_name(tcx, def_id);\n     providers.covered_code_regions = |tcx, def_id| covered_code_regions(tcx, def_id);\n }\n \n@@ -137,25 +136,6 @@ fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) ->\n     coverage_visitor.info\n }\n \n-fn covered_file_name(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n-    if tcx.is_mir_available(def_id) {\n-        let body = mir_body(tcx, def_id);\n-        for bb_data in body.basic_blocks().iter() {\n-            for statement in bb_data.statements.iter() {\n-                if let StatementKind::Coverage(box ref coverage) = statement.kind {\n-                    if let Some(code_region) = coverage.code_region.as_ref() {\n-                        if is_inlined(body, statement) {\n-                            continue;\n-                        }\n-                        return Some(code_region.file_name);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n fn covered_code_regions<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<&'tcx CodeRegion> {\n     let body = mir_body(tcx, def_id);\n     body.basic_blocks()"}, {"sha": "67597a0d7b46b5dea8d40f9bce3480e6ebb68146", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -201,6 +201,40 @@ pub fn partition<'tcx>(\n         partitioner.internalize_symbols(cx, &mut post_inlining);\n     }\n \n+    let instrument_dead_code =\n+        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n+\n+    if instrument_dead_code {\n+        assert!(\n+            post_inlining.codegen_units.len() > 0,\n+            \"There must be at least one CGU that code coverage data can be generated in.\"\n+        );\n+\n+        // Find the smallest CGU that has exported symbols and put the dead\n+        // function stubs in that CGU. We look for exported symbols to increase\n+        // the likelihood the linker won't throw away the dead functions.\n+        // FIXME(#92165): In order to truly resolve this, we need to make sure\n+        // the object file (CGU) containing the dead function stubs is included\n+        // in the final binary. This will probably require forcing these\n+        // function symbols to be included via `-u` or `/include` linker args.\n+        let mut cgus: Vec<_> = post_inlining.codegen_units.iter_mut().collect();\n+        cgus.sort_by_key(|cgu| cgu.size_estimate());\n+\n+        let dead_code_cgu = if let Some(cgu) = cgus\n+            .into_iter()\n+            .rev()\n+            .filter(|cgu| cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External))\n+            .next()\n+        {\n+            cgu\n+        } else {\n+            // If there are no CGUs that have externally linked items,\n+            // then we just pick the first CGU as a fallback.\n+            &mut post_inlining.codegen_units[0]\n+        };\n+        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+    }\n+\n     // Finally, sort by codegen unit name, so that we get deterministic results.\n     let PostInliningPartitioning {\n         codegen_units: mut result,"}, {"sha": "094d6b3ebf5f8f6a41c32b343ebba175c85afcf2", "filename": "src/test/run-make-fulldeps/coverage-reports/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -64,7 +64,7 @@ endif\n # if and when we allow `llvm-cov` to produce results for multiple files. Note, the path separators\n # appear to be normalized to `/` in those files, thankfully.)\n LLVM_COV_IGNORE_FILES=\\\n-\t--ignore-filename-regex='(uses_crate.rs|uses_inline_crate.rs)'\n+\t--ignore-filename-regex='(uses_crate.rs|uses_inline_crate.rs|unused_mod.rs)'\n \n all: $(patsubst $(SOURCEDIR)/lib/%.rs,%,$(wildcard $(SOURCEDIR)/lib/*.rs)) $(patsubst $(SOURCEDIR)/%.rs,%,$(wildcard $(SOURCEDIR)/*.rs))\n "}, {"sha": "82d6fccc2714a53c3e8775c7ba7f45d7f2e76eb5", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.unused_mod.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.unused_mod.txt?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -0,0 +1,4 @@\n+    1|      0|pub fn never_called_function() {\n+    2|      0|    println!(\"I am never called\");\n+    3|      0|}\n+"}, {"sha": "ae1cc1531ed759ec3c41d264a9f81b54f13b30a2", "filename": "src/test/run-make-fulldeps/coverage/lib/unused_mod_helper.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Flib%2Funused_mod_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Flib%2Funused_mod_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Flib%2Funused_mod_helper.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -0,0 +1,3 @@\n+pub fn never_called_function() {\n+    println!(\"I am never called\");\n+}"}, {"sha": "679b4e5318803a30d3fd5ad2af28bb8bb5dd2b49", "filename": "src/test/run-make-fulldeps/coverage/unused_mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Funused_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e04f513cdb173ed808b4c770d146dd9927df3a0/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Funused_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Funused_mod.rs?ref=5e04f513cdb173ed808b4c770d146dd9927df3a0", "patch": "@@ -0,0 +1,6 @@\n+#[path = \"lib/unused_mod_helper.rs\"]\n+mod unused_module;\n+\n+fn main() {\n+    println!(\"hello world!\");\n+}"}]}