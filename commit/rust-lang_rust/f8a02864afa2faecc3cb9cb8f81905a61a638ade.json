{"sha": "f8a02864afa2faecc3cb9cb8f81905a61a638ade", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YTAyODY0YWZhMmZhZWNjM2NiOWNiOGY4MTkwNWE2MWE2MzhhZGU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-06T02:04:51Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-10T04:54:14Z"}, "message": "Speed up `SipHasher128`.\n\nThe current code in `SipHasher128::short_write` is inefficient. It uses\n`u8to64_le` (which is complex and slow) to extract just the right number of\nbytes of the input into a u64 and pad the result with zeroes. It then\nleft-shifts that value in order to bitwise-OR it with `self.tail`.\n\nFor example, imagine we have a u32 input 0xIIHH_GGFF and only need three bytes\nto fill up `self.tail`. The current code uses `u8to64_le` to construct\n0x0000_0000_00HH_GGFF, which is just 0xIIHH_GGFF with the 0xII removed and\nzero-extended to a u64. The code then left-shifts that value by five bytes --\ndiscarding the 0x00 byte that replaced the 0xII byte! -- to give\n0xHHGG_FF00_0000_0000. It then then ORs that value with self.tail.\n\nThere's a much simpler way to do it: zero-extend to u64 first, then left shift.\nE.g. 0xIIHH_GGFF is zero-extended to 0x0000_0000_IIHH_GGFF, and then\nleft-shifted to 0xHHGG_FF00_0000_0000. We don't have to take time to exclude\nthe unneeded 0xII byte, because it just gets shifted out anyway! It also avoids\nmultiple occurrences of `unsafe`.\n\nThere's a similar story with the setting of `self.tail` at the method's end.\nThe current code uses `u8to64_le` to extract the remaining part of the input,\nbut the same effect can be achieved more quickly with a right shift on the\nzero-extended input.\n\nAll that works on little-endian. It doesn't work for big-endian, but we\ncan just do a `to_le` before calling `short_write` and then it works.\n\nThis commit changes `SipHasher128` to use the simpler shift-based approach. The\ncode is also smaller, which means that `short_write` is now inlined where\npreviously it wasn't, which makes things faster again. This gives big\nspeed-ups for all incremental builds, especially \"baseline\" incremental\nbuilds.", "tree": {"sha": "eb4321a0f7bce563043b4ddfde8553b88f94d895", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb4321a0f7bce563043b4ddfde8553b88f94d895"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8a02864afa2faecc3cb9cb8f81905a61a638ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a02864afa2faecc3cb9cb8f81905a61a638ade", "html_url": "https://github.com/rust-lang/rust/commit/f8a02864afa2faecc3cb9cb8f81905a61a638ade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8a02864afa2faecc3cb9cb8f81905a61a638ade/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "html_url": "https://github.com/rust-lang/rust/commit/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a"}], "stats": {"total": 111, "additions": 72, "deletions": 39}, "files": [{"sha": "cc653dca60c700996f30c6646b41a4f82aa90313", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 72, "deletions": 39, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f8a02864afa2faecc3cb9cb8f81905a61a638ade/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8a02864afa2faecc3cb9cb8f81905a61a638ade/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=f8a02864afa2faecc3cb9cb8f81905a61a638ade", "patch": "@@ -4,7 +4,6 @@ use std::cmp;\n use std::hash::Hasher;\n use std::mem;\n use std::ptr;\n-use std::slice;\n \n #[cfg(test)]\n mod tests;\n@@ -122,42 +121,76 @@ impl SipHasher128 {\n         self.state.v1 ^= 0xee;\n     }\n \n-    // Specialized write function that is only valid for buffers with len <= 8.\n-    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n-    // except for composite types (that includes slices and str hashing because of delimiter).\n-    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n-    // degrading performance substantially for the most common use cases.\n+    // A specialized write function for values with size <= 8.\n+    //\n+    // The hashing of multi-byte integers depends on endianness. E.g.:\n+    // - little-endian: `write_u32(0xDDCCBBAA)` == `write([0xAA, 0xBB, 0xCC, 0xDD])`\n+    // - big-endian:    `write_u32(0xDDCCBBAA)` == `write([0xDD, 0xCC, 0xBB, 0xAA])`\n+    //\n+    // This function does the right thing for little-endian hardware. On\n+    // big-endian hardware `x` must be byte-swapped first to give the right\n+    // behaviour. After any byte-swapping, the input must be zero-extended to\n+    // 64-bits. The caller is responsible for the byte-swapping and\n+    // zero-extension.\n     #[inline]\n-    fn short_write(&mut self, msg: &[u8]) {\n-        debug_assert!(msg.len() <= 8);\n-        let length = msg.len();\n-        self.length += length;\n+    fn short_write<T>(&mut self, _x: T, x: u64) {\n+        let size = mem::size_of::<T>();\n+        self.length += size;\n+\n+        // The original number must be zero-extended, not sign-extended.\n+        debug_assert!(if size < 8 { x >> (8 * size) == 0 } else { true });\n \n+        // The number of bytes needed to fill `self.tail`.\n         let needed = 8 - self.ntail;\n-        let fill = cmp::min(length, needed);\n-        if fill == 8 {\n-            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n-        } else {\n-            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n-            if length < needed {\n-                self.ntail += length;\n-                return;\n-            }\n+\n+        // SipHash parses the input stream as 8-byte little-endian integers.\n+        // Inputs are put into `self.tail` until 8 bytes of data have been\n+        // collected, and then that word is processed.\n+        //\n+        // For example, imagine that `self.tail` is 0x0000_00EE_DDCC_BBAA,\n+        // `self.ntail` is 5 (because 5 bytes have been put into `self.tail`),\n+        // and `needed` is therefore 3.\n+        //\n+        // - Scenario 1, `self.write_u8(0xFF)`: we have already zero-extended\n+        //   the input to 0x0000_0000_0000_00FF. We now left-shift it five\n+        //   bytes, giving 0x0000_FF00_0000_0000. We then bitwise-OR that value\n+        //   into `self.tail`, resulting in 0x0000_FFEE_DDCC_BBAA.\n+        //   (Zero-extension of the original input is critical in this scenario\n+        //   because we don't want the high two bytes of `self.tail` to be\n+        //   touched by the bitwise-OR.) `self.tail` is not yet full, so we\n+        //   return early, after updating `self.ntail` to 6.\n+        //\n+        // - Scenario 2, `self.write_u32(0xIIHH_GGFF)`: we have already\n+        //   zero-extended the input to 0x0000_0000_IIHH_GGFF. We now\n+        //   left-shift it five bytes, giving 0xHHGG_FF00_0000_0000. We then\n+        //   bitwise-OR that value into `self.tail`, resulting in\n+        //   0xHHGG_FFEE_DDCC_BBAA. `self.tail` is now full, and we can use it\n+        //   to update `self.state`. (As mentioned above, this assumes a\n+        //   little-endian machine; on a big-endian machine we would have\n+        //   byte-swapped 0xIIHH_GGFF in the caller, giving 0xFFGG_HHII, and we\n+        //   would then end up bitwise-ORing 0xGGHH_II00_0000_0000 into\n+        //   `self.tail`).\n+        //\n+        self.tail |= x << (8 * self.ntail);\n+        if size < needed {\n+            self.ntail += size;\n+            return;\n         }\n+\n+        // `self.tail` is full, process it.\n         self.state.v3 ^= self.tail;\n         Sip24Rounds::c_rounds(&mut self.state);\n         self.state.v0 ^= self.tail;\n \n-        // Buffered tail is now flushed, process new input.\n-        self.ntail = length - needed;\n-        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n-    }\n-\n-    #[inline(always)]\n-    fn short_write_gen<T>(&mut self, x: T) {\n-        let bytes =\n-            unsafe { slice::from_raw_parts(&x as *const T as *const u8, mem::size_of::<T>()) };\n-        self.short_write(bytes);\n+        // Continuing scenario 2: we have one byte left over from the input. We\n+        // set `self.ntail` to 1 and `self.tail` to `0x0000_0000_IIHH_GGFF >>\n+        // 8*3`, which is 0x0000_0000_0000_00II. (Or on a big-endian machine\n+        // the prior byte-swapping would leave us with 0x0000_0000_0000_00FF.)\n+        //\n+        // The `if` is needed to avoid shifting by 64 bits, which Rust\n+        // complains about.\n+        self.ntail = size - needed;\n+        self.tail = if needed < 8 { x >> (8 * needed) } else { 0 };\n     }\n \n     #[inline]\n@@ -182,52 +215,52 @@ impl SipHasher128 {\n impl Hasher for SipHasher128 {\n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i as u64);\n     }\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i.to_le() as u64);\n     }\n \n     #[inline]\n     fn write_i8(&mut self, i: i8) {\n-        self.short_write_gen(i);\n+        self.short_write(i, i as u8 as u64);\n     }\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as u16).to_le() as u64);\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as u32).to_le() as u64);\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as u64).to_le() as u64);\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.short_write_gen(i);\n+        self.short_write(i, (i as usize).to_le() as u64);\n     }\n \n     #[inline]"}]}