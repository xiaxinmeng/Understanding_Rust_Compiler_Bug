{"sha": "5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMmYzN2ZjYTlhNzkyYTg3ODBlNmY0MjdlNzdjYTBmZTcwN2JkNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-12T00:22:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-12T00:22:30Z"}, "message": "Auto merge of #38057 - KiChjang:display-formal-type-param, r=nikomatsakis\n\nDisplay better error messages for E0282\n\nFixes #36554.", "tree": {"sha": "b3043e095e7f7ab6398ab00c467f996a9df60fbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3043e095e7f7ab6398ab00c467f996a9df60fbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "html_url": "https://github.com/rust-lang/rust/commit/5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3db197aa9d343c7974b06a9b18ae5f78d5c64637", "url": "https://api.github.com/repos/rust-lang/rust/commits/3db197aa9d343c7974b06a9b18ae5f78d5c64637", "html_url": "https://github.com/rust-lang/rust/commit/3db197aa9d343c7974b06a9b18ae5f78d5c64637"}, {"sha": "d24028b5a83f9bbad6eca2d276ad7c0f625f6f01", "url": "https://api.github.com/repos/rust-lang/rust/commits/d24028b5a83f9bbad6eca2d276ad7c0f625f6f01", "html_url": "https://github.com/rust-lang/rust/commit/d24028b5a83f9bbad6eca2d276ad7c0f625f6f01"}], "stats": {"total": 267, "additions": 191, "deletions": 76}, "files": [{"sha": "8ccadc6b2af044819d5c7a2f4586d4ef6cf5b8f8", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -13,6 +13,7 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n+use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -83,6 +84,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n         self.fields.infcx\n     }\n \n+    fn cause(&self) -> &ObligationCause<'tcx> {\n+        &self.fields.trace.cause\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&v, &a)?;"}, {"sha": "f7b26a918b3a200d182c5651aab55e7ea562cac1", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -30,14 +30,18 @@\n //! a lattice.\n \n use super::InferCtxt;\n+use super::type_variable::TypeVariableOrigin;\n \n+use traits::ObligationCause;\n use ty::TyVar;\n use ty::{self, Ty};\n use ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n+    fn cause(&self) -> &ObligationCause<'tcx>;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n@@ -64,14 +68,15 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n     match (&a.sty, &b.sty) {\n         (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n-            let v = infcx.next_diverging_ty_var();\n+            let v = infcx.next_diverging_ty_var(\n+                TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }\n \n         (&ty::TyInfer(TyVar(..)), _) |\n         (_, &ty::TyInfer(TyVar(..))) => {\n-            let v = infcx.next_ty_var();\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "89571dea10c3425b56c3cdefadcc0d59f0994a96", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -13,6 +13,7 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n+use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -83,6 +84,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n         self.fields.infcx\n     }\n \n+    fn cause(&self) -> &ObligationCause<'tcx> {\n+        &self.fields.trace.cause\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&a, &v)?;"}, {"sha": "9b58334e65805a6822fa4446bf9271ff81dd037b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -45,6 +45,7 @@ use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n+use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n mod bivariate;\n@@ -114,7 +115,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n+    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n@@ -1054,18 +1055,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, None)\n+            .new_var(diverging, origin, None)\n     }\n \n-    pub fn next_ty_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false))\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true))\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1118,7 +1119,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false, default);\n+                            .new_var(false,\n+                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name),\n+                                     default);\n \n         self.tcx.mk_var(ty_var_id)\n     }"}, {"sha": "9c8419d9546d24b4f03745e4738a9f179f54f3ff", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -13,6 +13,7 @@ use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n use hir::def_id::{DefId};\n use syntax::util::small_vector::SmallVector;\n+use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n@@ -28,8 +29,24 @@ pub struct TypeVariableTable<'tcx> {\n     eq_relations: ut::UnificationTable<ty::TyVid>,\n }\n \n+/// Reasons to create a type inference variable\n+pub enum TypeVariableOrigin {\n+    MiscVariable(Span),\n+    NormalizeProjectionType(Span),\n+    TypeInference(Span),\n+    TypeParameterDefinition(Span, ast::Name),\n+    TransformedUpvar(Span),\n+    SubstitutionPlaceholder(Span),\n+    AutoDeref(Span),\n+    AdjustmentType(Span),\n+    DivergingStmt(Span),\n+    DivergingBlockExpr(Span),\n+    LatticeVariable(Span),\n+}\n+\n struct TypeVariableData<'tcx> {\n     value: TypeVariableValue<'tcx>,\n+    origin: TypeVariableOrigin,\n     diverging: bool\n }\n \n@@ -107,6 +124,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.values.get(vid.index as usize).diverging\n     }\n \n+    pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n+        &self.values.get(vid.index as usize).origin\n+    }\n+\n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n@@ -173,10 +194,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     pub fn new_var(&mut self,\n                    diverging: bool,\n-                   default: Option<Default<'tcx>>) -> ty::TyVid {\n+                   origin: TypeVariableOrigin,\n+                   default: Option<Default<'tcx>>,) -> ty::TyVid {\n         self.eq_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n             value: Bounded { relations: vec![], default: default },\n+            origin: origin,\n             diverging: diverging\n         });\n         let v = ty::TyVid { index: index as u32 };"}, {"sha": "0c0d0c010e2e279dd58ee2750d36abda07688796", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -27,6 +27,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n+use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n@@ -38,7 +39,7 @@ use util::nodemap::{FxHashMap, FxHashSet};\n use std::cmp;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n use errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n@@ -790,9 +791,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::TyParam(..) = ty.sty {\n+                if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n+                    self.var_map.entry(ty).or_insert_with(||\n+                        infcx.next_ty_var(\n+                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -824,12 +827,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n \n     fn need_type_info(&self, span: Span, ty: Ty<'tcx>) {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let name = if let ty::TyInfer(ty::TyVar(ty_vid)) = ty.sty {\n+            let ty_vars = self.type_variables.borrow();\n+            if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n+                    *ty_vars.var_origin(ty_vid)\n+            {\n+                name.to_string()\n+            } else {\n+                ty.to_string()\n+            }\n+        } else {\n+            ty.to_string()\n+        };\n+\n         let mut err = struct_span_err!(self.tcx.sess, span, E0282,\n                                        \"unable to infer enough type information about `{}`\",\n-                                       ty);\n+                                       name);\n         err.note(\"type annotations or generic parameter binding required\");\n-        err.span_label(span, &format!(\"cannot infer type for `{}`\", ty));\n-        err.emit()\n+        err.span_label(span, &format!(\"cannot infer type for `{}`\", name));\n+        err.emit();\n     }\n \n     fn note_obligation_cause<T>(&self,"}, {"sha": "6f645b5f94d0084fe305f4e0ee69fe365733c91a", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -25,6 +25,7 @@ use super::util;\n \n use hir::def_id::DefId;\n use infer::InferOk;\n+use infer::type_variable::TypeVariableOrigin;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -382,7 +383,12 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // and a deferred predicate to resolve this when more type\n             // information is available.\n \n-            let ty_var = selcx.infcx().next_ty_var();\n+            let tcx = selcx.infcx().tcx;\n+            let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n+                i.name == projection_ty.item_name && i.kind == ty::AssociatedKind::Type\n+            ).map(|i| i.def_id).unwrap();\n+            let ty_var = selcx.infcx().next_ty_var(\n+                TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty: projection_ty,\n                 ty: ty_var\n@@ -596,7 +602,12 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let trait_obligation = Obligation { cause: cause,\n                                         recursion_depth: depth,\n                                         predicate: trait_ref.to_predicate() };\n-    let new_value = selcx.infcx().next_ty_var();\n+    let tcx = selcx.infcx().tcx;\n+    let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n+        i.name == projection_ty.item_name && i.kind == ty::AssociatedKind::Type\n+    ).map(|i| i.def_id).unwrap();\n+    let new_value = selcx.infcx().next_ty_var(\n+        TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,\n         obligations: vec![trait_obligation]"}, {"sha": "2f8550e5acda70dcca033d3dbdd07de56cd18fc2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -24,6 +24,7 @@ use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n@@ -36,6 +37,7 @@ use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n+use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n@@ -489,7 +491,7 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -508,7 +510,7 @@ fn lub_free_bound_infer() {\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         env.create_simple_region_hierarchy();\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n@@ -628,7 +630,7 @@ fn glb_bound_free() {\n fn glb_bound_free_infer() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n \n         // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n         // which should yield for<'b> fn(&'b isize) -> isize"}, {"sha": "624201eaab69660218509dcd676f949d34bb6f75", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -12,6 +12,7 @@ use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n@@ -162,7 +163,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 let max_len = cmp::max(expected_len, elements.len());\n \n-                let element_tys_iter = (0..max_len).map(|_| self.next_ty_var());\n+                let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n+                    // FIXME: MiscVariable for now, obtaining the span and name information\n+                    //       from all tuple elements isn't trivial.\n+                    TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n@@ -172,7 +176,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 pat_ty\n             }\n             PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var();\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));\n                 let uniq_ty = tcx.mk_box(inner_ty);\n \n                 if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -203,7 +207,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             (expected, mt.ty)\n                         }\n                         _ => {\n-                            let inner_ty = self.next_ty_var();\n+                            let inner_ty = self.next_ty_var(\n+                                TypeVariableOrigin::TypeInference(inner.span));\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n                             let rptr_ty = tcx.mk_ref(region, mt);\n@@ -379,7 +384,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var();\n+            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n         let discrim_diverges = self.diverges.get();\n@@ -407,7 +412,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // of execution reach it, we will panic, so bottom is an appropriate\n         // type in that case)\n         let expected = expected.adjust_for_branches(self);\n-        let mut result_ty = self.next_diverging_ty_var();\n+        let mut result_ty = self.next_diverging_ty_var(\n+            TypeVariableOrigin::DivergingBlockExpr(expr.span));\n         let mut all_arms_diverge = Diverges::WarnedAlways;\n         let coerce_first = match expected {\n             // We don't coerce to `()` so that if the match expression is a"}, {"sha": "1d81ed7d35956145de42a0d8d23ab3fb2bb67006", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -13,6 +13,7 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n use std::iter;\n@@ -66,7 +67,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_type = self.tcx.mk_closure(expr_def_id,\n             self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n-                |_, _| self.infcx.next_ty_var()\n+                |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n             )\n         );\n "}, {"sha": "5cb0804b1bca19e1972fb953237cd821ac296b0b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -20,6 +20,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -1225,7 +1226,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self.tcx,\n                                       impl_def_id,\n                                       |_, _| self.tcx.mk_region(ty::ReErased),\n-                                      |_, _| self.next_ty_var());\n+                                      |_, _| self.next_ty_var(\n+                                        TypeVariableOrigin::SubstitutionPlaceholder(\n+                                            self.tcx.def_span(impl_def_id))));\n \n         (impl_ty, substs)\n     }"}, {"sha": "86bfede87b333c6d6e7a7897c8d95d991fdf905c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -28,6 +28,7 @@ use syntax_pos::Span;\n \n use rustc::hir::print as pprust;\n use rustc::hir;\n+use rustc::infer::type_variable::TypeVariableOrigin;\n \n use std::cell;\n use std::cmp::Ordering;\n@@ -53,7 +54,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     self.probe(|_| {\n-                        let fn_once_substs = tcx.mk_substs_trait(ty, &[self.next_ty_var()]);\n+                        let fn_once_substs = tcx.mk_substs_trait(ty,\n+                            &[self.next_ty_var(TypeVariableOrigin::MiscVariable(span))]);\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation ="}, {"sha": "58dff935a16b88388e3dce04cfca168b346058ba", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -85,8 +85,8 @@ use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n-                   TypeTrace, type_variable};\n+use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin, TypeTrace};\n+use rustc::infer::type_variable::{self, TypeVariableOrigin};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n@@ -117,7 +117,7 @@ use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{self, BytePos, Span};\n+use syntax_pos::{self, BytePos, Span, DUMMY_SP};\n \n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -683,11 +683,11 @@ struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n-    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n+    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.next_ty_var();\n+                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -1444,8 +1444,8 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n-        self.next_ty_var()\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n+        self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n \n     fn ty_infer_for_def(&self,\n@@ -1751,13 +1751,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(ty_var) = self.anon_types.borrow().get(&def_id) {\n                     return ty_var;\n                 }\n-                let ty_var = self.next_ty_var();\n+                let span = self.tcx.def_span(def_id);\n+                let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.anon_types.borrow_mut().insert(def_id, ty_var);\n \n                 let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n-                let span = self.tcx.def_span(def_id);\n                 for predicate in bounds.predicates {\n                     // Change the predicate to refer to the type variable,\n                     // which will be the concrete type, instead of the TyAnon.\n@@ -2204,7 +2204,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let conflicting_default =\n                         self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n                             .unwrap_or(type_variable::Default {\n-                                ty: self.next_ty_var(),\n+                                ty: self.next_ty_var(\n+                                    TypeVariableOrigin::MiscVariable(syntax_pos::DUMMY_SP)),\n                                 origin_span: syntax_pos::DUMMY_SP,\n                                 // what do I put here?\n                                 def_id: self.tcx.map.local_def_id(ast::CRATE_NODE_ID)\n@@ -2398,7 +2399,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                unsize,\n                index_ty);\n \n-        let input_ty = self.next_ty_var();\n+        let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n \n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n@@ -3486,8 +3487,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Add adjustments to !-expressions\n         if ty.is_never() {\n-            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(expr.id) {\n-                let adj_ty = self.next_diverging_ty_var();\n+            if let Some(hir::map::NodeExpr(node_expr)) = self.tcx.map.find(expr.id) {\n+                let adj_ty = self.next_diverging_ty_var(\n+                    TypeVariableOrigin::AdjustmentType(node_expr.span));\n                 self.write_adjustment(expr.id, adjustment::Adjustment {\n                     kind: adjustment::Adjust::NeverToAny,\n                     target: adj_ty\n@@ -3781,7 +3783,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprLoop(ref body, _, _) => {\n-            let unified = self.next_ty_var();\n+            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(body.span));\n             let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n             let ctxt = LoopCtxt {\n                 unified: unified,\n@@ -3860,7 +3862,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n \n-            let mut unified = self.next_ty_var();\n+            let mut unified = self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span));\n             let coerce_to = uty.unwrap_or(unified);\n \n             for (i, e) in args.iter().enumerate() {\n@@ -3905,7 +3907,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (uty, uty)\n                 }\n                 None => {\n-                    let t: Ty = self.next_ty_var();\n+                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n                     let element_ty = self.check_expr_has_type(&element, t);\n                     (element_ty, t)\n                 }\n@@ -4154,31 +4156,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        let node_id = match stmt.node {\n+        let (node_id, span) = match stmt.node {\n             hir::StmtDecl(ref decl, id) => {\n-                match decl.node {\n+                let span = match decl.node {\n                     hir::DeclLocal(ref l) => {\n                         self.check_decl_local(&l);\n+                        l.span\n                     }\n-                    hir::DeclItem(_) => {/* ignore for now */ }\n-                }\n-                id\n+                    hir::DeclItem(_) => {/* ignore for now */\n+                        DUMMY_SP\n+                    }\n+                };\n+                (id, span)\n             }\n             hir::StmtExpr(ref expr, id) => {\n                 // Check with expected type of ()\n                 self.check_expr_has_type(&expr, self.tcx.mk_nil());\n-                id\n+                (id, expr.span)\n             }\n             hir::StmtSemi(ref expr, id) => {\n                 self.check_expr(&expr);\n-                id\n+                (id, expr.span)\n             }\n         };\n \n         if self.has_errors.get() {\n             self.write_error(node_id);\n         } else if self.diverges.get().always() {\n-            self.write_ty(node_id, self.next_diverging_ty_var());\n+            self.write_ty(node_id, self.next_diverging_ty_var(\n+                TypeVariableOrigin::DivergingStmt(span)));\n         } else {\n             self.write_nil(node_id);\n         }\n@@ -4224,7 +4230,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty = self.next_diverging_ty_var();\n+            ty = self.next_diverging_ty_var(TypeVariableOrigin::DivergingBlockExpr(blk.span));\n         } else if let ExpectHasType(ety) = expected {\n             if let Some(ref e) = blk.expr {\n                 // Coerce the tail expression to the right type."}, {"sha": "d1a9b8ef85ae48e5c990b55cec9d9825dc4c57ac", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -13,6 +13,7 @@\n use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::hir;\n@@ -179,7 +180,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // using this variable as the expected type, which sometimes lets\n         // us do better coercions than we would be able to do otherwise,\n         // particularly for things like `String + &String`.\n-        let rhs_ty_var = self.next_ty_var();\n+        let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n                                                     Symbol::intern(name), trait_def_id,"}, {"sha": "c274665530fdb67f28b8108f4353b6adfe1265be", "filename": "src/test/compile-fail/issue-23046.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23046.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -25,6 +25,6 @@ pub fn let_<'var, VAR, F: for<'v: 'var> Fn(Expr<'v, VAR>) -> Expr<'v, VAR>>\n \n fn main() {\n     let ex = |x| {\n-        let_(add(x,x), |y| { //~ ERROR unable to infer enough type information about `_`\n+        let_(add(x,x), |y| { //~ ERROR unable to infer enough type information about `VAR`\n             let_(add(x, x), |x|x)})};\n }"}, {"sha": "cf78d6d8c0ad4715686519707a9b3e8050962318", "filename": "src/test/compile-fail/issue-5062.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n fn main() { format!(\"{:?}\", None); }\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n+    //~^ ERROR unable to infer enough type information about `T` [E0282]"}, {"sha": "3816896d43d1f47533d3bad1366161d95f3b1472", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     // Unconstrained type:\n     format!(\"{:?}\", None);\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n+    //~^ ERROR unable to infer enough type information about `T` [E0282]\n }"}, {"sha": "8029522f5d3cc9cdb3bb696c769c50032dc4e6ce", "filename": "src/test/compile-fail/issue-6458-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -12,7 +12,7 @@ use std::mem;\n \n fn main() {\n     mem::transmute(0);\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n-    //~| NOTE cannot infer type for `_`\n+    //~^ ERROR unable to infer enough type information about `U` [E0282]\n+    //~| NOTE cannot infer type for `U`\n     //~| NOTE type annotations or generic parameter binding\n }"}, {"sha": "f8354ddbf12a58df5563eb80639a3dfb1cfab696", "filename": "src/test/compile-fail/issue-6458.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -17,8 +17,8 @@ pub fn foo<State>(_: TypeWithState<State>) {}\n \n pub fn bar() {\n    foo(TypeWithState(marker::PhantomData));\n-   //~^ ERROR unable to infer enough type information about `_` [E0282]\n-   //~| NOTE cannot infer type for `_`\n+   //~^ ERROR unable to infer enough type information about `State` [E0282]\n+   //~| NOTE cannot infer type for `State`\n    //~| NOTE type annotations or generic parameter binding\n }\n "}, {"sha": "e37a881642393fd9400a7f2fe0d2ea24c6521171", "filename": "src/test/compile-fail/issue-7813.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let v = &[];\n-    let it = v.iter(); //~ ERROR unable to infer enough type information about `_` [E0282]\n-                       //~| NOTE cannot infer type for `_`\n+    let it = v.iter(); //~ ERROR unable to infer enough type information about `T` [E0282]\n+                       //~| NOTE cannot infer type for `T`\n                        //~| NOTE type annotations or generic parameter binding\n }"}, {"sha": "1cf41f95a2d6d8bc977ad375defe266ed85c20cb", "filename": "src/test/compile-fail/method-ambig-one-trait-unknown-int-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-unknown-int-type.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -32,7 +32,7 @@ impl foo for Vec<isize> {\n fn m1() {\n     // we couldn't infer the type of the vector just based on calling foo()...\n     let mut x = Vec::new();\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n+    //~^ ERROR unable to infer enough type information about `T` [E0282]\n     x.foo();\n }\n "}, {"sha": "ed2ffa995e521ce188e83b8c5de832f6868a196c", "filename": "src/test/compile-fail/traits-multidispatch-convert-ambig-dest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-convert-ambig-dest.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -34,8 +34,8 @@ where T : Convert<U>\n \n fn a() {\n     test(22, std::default::Default::default());\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n-    //~| NOTE cannot infer type for `_`\n+    //~^ ERROR unable to infer enough type information about `U` [E0282]\n+    //~| NOTE cannot infer type for `U`\n     //~| NOTE type annotations or generic parameter binding\n }\n "}, {"sha": "88080bc70cab4e404a65c97108b7889ba42ff7b1", "filename": "src/test/compile-fail/unconstrained-none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -11,7 +11,7 @@\n // Issue #5062\n \n fn main() {\n-    None; //~ ERROR unable to infer enough type information about `_` [E0282]\n-          //~| NOTE cannot infer type for `_`\n+    None; //~ ERROR unable to infer enough type information about `T` [E0282]\n+          //~| NOTE cannot infer type for `T`\n           //~| NOTE type annotations or generic parameter binding\n }"}, {"sha": "12278549215ed132deca9b9cb4584dc78d74fbbc", "filename": "src/test/compile-fail/unconstrained-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -13,7 +13,7 @@ struct S<'a, T:'a> {\n }\n \n fn main() {\n-    S { o: &None }; //~ ERROR unable to infer enough type information about `_` [E0282]\n-                    //~| NOTE cannot infer type for `_`\n+    S { o: &None }; //~ ERROR unable to infer enough type information about `T` [E0282]\n+                    //~| NOTE cannot infer type for `T`\n                     //~| NOTE type annotations or generic parameter binding\n }"}, {"sha": "d559caf77a1a37944dedf9d43f7bb6cdf1acd583", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -11,7 +11,7 @@\n \n fn main() {\n     let _foo = Vec::new();\n-    //~^ ERROR unable to infer enough type information about `_` [E0282]\n-    //~| NOTE cannot infer type for `_`\n+    //~^ ERROR unable to infer enough type information about `T` [E0282]\n+    //~| NOTE cannot infer type for `T`\n     //~| NOTE type annotations or generic parameter binding\n }"}, {"sha": "7e0d778a3b205e431bd5ee8b58d7f692292e4867", "filename": "src/test/ui/codemap_tests/repair_span_std_macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Frepair_span_std_macros.stderr?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -1,8 +1,8 @@\n-error[E0282]: unable to infer enough type information about `_`\n+error[E0282]: unable to infer enough type information about `T`\n   --> $DIR/repair_span_std_macros.rs:12:13\n    |\n 12 |     let x = vec![];\n-   |             ^^^^^^ cannot infer type for `_`\n+   |             ^^^^^^ cannot infer type for `T`\n    |\n    = note: type annotations or generic parameter binding required\n    = note: this error originates in a macro outside of the current crate"}, {"sha": "3671abd66246d864d6f38574adbc6ffce0ea48f5", "filename": "src/test/ui/missing-items/missing-type-parameter.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fui%2Fmissing-items%2Fmissing-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fui%2Fmissing-items%2Fmissing-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing-items%2Fmissing-type-parameter.rs?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<X>() { }\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "2d007af4980b208aad23781e8478e5d385ae2bdf", "filename": "src/test/ui/missing-items/missing-type-parameter.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fui%2Fmissing-items%2Fmissing-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e2f37fca9a792a8780e6f427e77ca0fe707bd47/src%2Ftest%2Fui%2Fmissing-items%2Fmissing-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing-items%2Fmissing-type-parameter.stderr?ref=5e2f37fca9a792a8780e6f427e77ca0fe707bd47", "patch": "@@ -0,0 +1,10 @@\n+error[E0282]: unable to infer enough type information about `X`\n+  --> $DIR/missing-type-parameter.rs:14:5\n+   |\n+14 |     foo();\n+   |     ^^^ cannot infer type for `X`\n+   |\n+   = note: type annotations or generic parameter binding required\n+\n+error: aborting due to previous error\n+"}]}