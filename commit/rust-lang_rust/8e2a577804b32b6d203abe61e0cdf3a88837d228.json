{"sha": "8e2a577804b32b6d203abe61e0cdf3a88837d228", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMmE1Nzc4MDRiMzJiNmQyMDNhYmU2MWUwY2RmM2E4ODgzN2QyMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-18T13:28:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-18T13:28:27Z"}, "message": "Auto merge of #31394 - nikomatsakis:incr-comp-variance, r=pnkfelix\n\nMake the dep. graph edges created by variance just mirror the constraint graph.\n\nNote that this extends <https://github.com/rust-lang/rust/pull/31304>, so the first few commits are on a different topic.\n\nr? @pnkfelix", "tree": {"sha": "92b90f533882b871e2ffa6019a589026b0a1fefe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92b90f533882b871e2ffa6019a589026b0a1fefe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e2a577804b32b6d203abe61e0cdf3a88837d228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e2a577804b32b6d203abe61e0cdf3a88837d228", "html_url": "https://github.com/rust-lang/rust/commit/8e2a577804b32b6d203abe61e0cdf3a88837d228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e2a577804b32b6d203abe61e0cdf3a88837d228/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f075698ea59794f3ece46c365b8071d844adb6c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f075698ea59794f3ece46c365b8071d844adb6c0", "html_url": "https://github.com/rust-lang/rust/commit/f075698ea59794f3ece46c365b8071d844adb6c0"}, {"sha": "01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f", "html_url": "https://github.com/rust-lang/rust/commit/01ebc37fa160328c2dc580cf62cf6b2194dc6f2f"}], "stats": {"total": 2683, "additions": 1422, "deletions": 1261}, "files": [{"sha": "adf14d0d89c19cc989ccb436be1100e5bcff0929", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -325,7 +325,17 @@ impl<'ast> Map<'ast> {\n                     return DepNode::Krate,\n \n                 NotPresent =>\n-                    panic!(\"Walking parents from `{}` led to `NotPresent` at `{}`\", id0, id),\n+                    // Some nodes, notably struct fields, are not\n+                    // present in the map for whatever reason, but\n+                    // they *do* have def-ids. So if we encounter an\n+                    // empty hole, check for that case.\n+                    return self.opt_local_def_id(id)\n+                               .map(|def_id| DepNode::Hir(def_id))\n+                               .unwrap_or_else(|| {\n+                                   panic!(\"Walking parents from `{}` \\\n+                                           led to `NotPresent` at `{}`\",\n+                                          id0, id)\n+                               }),\n             }\n         }\n     }"}, {"sha": "ce0e9e14035f51073965dccb22157995648eb48c", "filename": "src/librustc_typeck/variance.rs", "status": "removed", "additions": 0, "deletions": 1250, "changes": 1250, "blob_url": "https://github.com/rust-lang/rust/blob/f075698ea59794f3ece46c365b8071d844adb6c0/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f075698ea59794f3ece46c365b8071d844adb6c0/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=f075698ea59794f3ece46c365b8071d844adb6c0", "patch": "@@ -1,1250 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This file infers the variance of type and lifetime parameters. The\n-//! algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n-//! Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n-//! written by Altidor et al., and hereafter referred to as The Paper.\n-//!\n-//! This inference is explicitly designed *not* to consider the uses of\n-//! types within code. To determine the variance of type parameters\n-//! defined on type `X`, we only consider the definition of the type `X`\n-//! and the definitions of any types it references.\n-//!\n-//! We only infer variance for type parameters found on *data types*\n-//! like structs and enums. In these cases, there is fairly straightforward\n-//! explanation for what variance means. The variance of the type\n-//! or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n-//! (resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n-//! (resp. `'a` and `'b`).\n-//!\n-//! We do not infer variance for type parameters found on traits, fns,\n-//! or impls. Variance on trait parameters can make indeed make sense\n-//! (and we used to compute it) but it is actually rather subtle in\n-//! meaning and not that useful in practice, so we removed it. See the\n-//! addendum for some details. Variances on fn/impl parameters, otoh,\n-//! doesn't make sense because these parameters are instantiated and\n-//! then forgotten, they don't persist in types or compiled\n-//! byproducts.\n-//!\n-//! ### The algorithm\n-//!\n-//! The basic idea is quite straightforward. We iterate over the types\n-//! defined and, for each use of a type parameter X, accumulate a\n-//! constraint indicating that the variance of X must be valid for the\n-//! variance of that use site. We then iteratively refine the variance of\n-//! X until all constraints are met. There is *always* a sol'n, because at\n-//! the limit we can declare all type parameters to be invariant and all\n-//! constraints will be satisfied.\n-//!\n-//! As a simple example, consider:\n-//!\n-//!     enum Option<A> { Some(A), None }\n-//!     enum OptionalFn<B> { Some(|B|), None }\n-//!     enum OptionalMap<C> { Some(|C| -> C), None }\n-//!\n-//! Here, we will generate the constraints:\n-//!\n-//!     1. V(A) <= +\n-//!     2. V(B) <= -\n-//!     3. V(C) <= +\n-//!     4. V(C) <= -\n-//!\n-//! These indicate that (1) the variance of A must be at most covariant;\n-//! (2) the variance of B must be at most contravariant; and (3, 4) the\n-//! variance of C must be at most covariant *and* contravariant. All of these\n-//! results are based on a variance lattice defined as follows:\n-//!\n-//!       *      Top (bivariant)\n-//!    -     +\n-//!       o      Bottom (invariant)\n-//!\n-//! Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n-//! optimal solution. Note that there is always a naive solution which\n-//! just declares all variables to be invariant.\n-//!\n-//! You may be wondering why fixed-point iteration is required. The reason\n-//! is that the variance of a use site may itself be a function of the\n-//! variance of other type parameters. In full generality, our constraints\n-//! take the form:\n-//!\n-//!     V(X) <= Term\n-//!     Term := + | - | * | o | V(X) | Term x Term\n-//!\n-//! Here the notation V(X) indicates the variance of a type/region\n-//! parameter `X` with respect to its defining class. `Term x Term`\n-//! represents the \"variance transform\" as defined in the paper:\n-//!\n-//!   If the variance of a type variable `X` in type expression `E` is `V2`\n-//!   and the definition-site variance of the [corresponding] type parameter\n-//!   of a class `C` is `V1`, then the variance of `X` in the type expression\n-//!   `C<E>` is `V3 = V1.xform(V2)`.\n-//!\n-//! ### Constraints\n-//!\n-//! If I have a struct or enum with where clauses:\n-//!\n-//!     struct Foo<T:Bar> { ... }\n-//!\n-//! you might wonder whether the variance of `T` with respect to `Bar`\n-//! affects the variance `T` with respect to `Foo`. I claim no.  The\n-//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n-//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n-//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n-//! case, the upcast will be illegal, but not because of a variance\n-//! failure, but rather because the target type `Foo<Y>` is itself just\n-//! not well-formed. Basically we get to assume well-formedness of all\n-//! types involved before considering variance.\n-//!\n-//! ### Addendum: Variance on traits\n-//!\n-//! As mentioned above, we used to permit variance on traits. This was\n-//! computed based on the appearance of trait type parameters in\n-//! method signatures and was used to represent the compatibility of\n-//! vtables in trait objects (and also \"virtual\" vtables or dictionary\n-//! in trait bounds). One complication was that variance for\n-//! associated types is less obvious, since they can be projected out\n-//! and put to myriad uses, so it's not clear when it is safe to allow\n-//! `X<A>::Bar` to vary (or indeed just what that means). Moreover (as\n-//! covered below) all inputs on any trait with an associated type had\n-//! to be invariant, limiting the applicability. Finally, the\n-//! annotations (`MarkerTrait`, `PhantomFn`) needed to ensure that all\n-//! trait type parameters had a variance were confusing and annoying\n-//! for little benefit.\n-//!\n-//! Just for historical reference,I am going to preserve some text indicating\n-//! how one could interpret variance and trait matching.\n-//!\n-//! #### Variance and object types\n-//!\n-//! Just as with structs and enums, we can decide the subtyping\n-//! relationship between two object types `&Trait<A>` and `&Trait<B>`\n-//! based on the relationship of `A` and `B`. Note that for object\n-//! types we ignore the `Self` type parameter -- it is unknown, and\n-//! the nature of dynamic dispatch ensures that we will always call a\n-//! function that is expected the appropriate `Self` type. However, we\n-//! must be careful with the other type parameters, or else we could\n-//! end up calling a function that is expecting one type but provided\n-//! another.\n-//!\n-//! To see what I mean, consider a trait like so:\n-//!\n-//!     trait ConvertTo<A> {\n-//!         fn convertTo(&self) -> A;\n-//!     }\n-//!\n-//! Intuitively, If we had one object `O=&ConvertTo<Object>` and another\n-//! `S=&ConvertTo<String>`, then `S <: O` because `String <: Object`\n-//! (presuming Java-like \"string\" and \"object\" types, my go to examples\n-//! for subtyping). The actual algorithm would be to compare the\n-//! (explicit) type parameters pairwise respecting their variance: here,\n-//! the type parameter A is covariant (it appears only in a return\n-//! position), and hence we require that `String <: Object`.\n-//!\n-//! You'll note though that we did not consider the binding for the\n-//! (implicit) `Self` type parameter: in fact, it is unknown, so that's\n-//! good. The reason we can ignore that parameter is precisely because we\n-//! don't need to know its value until a call occurs, and at that time (as\n-//! you said) the dynamic nature of virtual dispatch means the code we run\n-//! will be correct for whatever value `Self` happens to be bound to for\n-//! the particular object whose method we called. `Self` is thus different\n-//! from `A`, because the caller requires that `A` be known in order to\n-//! know the return type of the method `convertTo()`. (As an aside, we\n-//! have rules preventing methods where `Self` appears outside of the\n-//! receiver position from being called via an object.)\n-//!\n-//! #### Trait variance and vtable resolution\n-//!\n-//! But traits aren't only used with objects. They're also used when\n-//! deciding whether a given impl satisfies a given trait bound. To set the\n-//! scene here, imagine I had a function:\n-//!\n-//!     fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n-//!         ...\n-//!     }\n-//!\n-//! Now imagine that I have an implementation of `ConvertTo` for `Object`:\n-//!\n-//!     impl ConvertTo<i32> for Object { ... }\n-//!\n-//! And I want to call `convertAll` on an array of strings. Suppose\n-//! further that for whatever reason I specifically supply the value of\n-//! `String` for the type parameter `T`:\n-//!\n-//!     let mut vector = vec![\"string\", ...];\n-//!     convertAll::<i32, String>(vector);\n-//!\n-//! Is this legal? To put another way, can we apply the `impl` for\n-//! `Object` to the type `String`? The answer is yes, but to see why\n-//! we have to expand out what will happen:\n-//!\n-//! - `convertAll` will create a pointer to one of the entries in the\n-//!   vector, which will have type `&String`\n-//! - It will then call the impl of `convertTo()` that is intended\n-//!   for use with objects. This has the type:\n-//!\n-//!       fn(self: &Object) -> i32\n-//!\n-//!   It is ok to provide a value for `self` of type `&String` because\n-//!   `&String <: &Object`.\n-//!\n-//! OK, so intuitively we want this to be legal, so let's bring this back\n-//! to variance and see whether we are computing the correct result. We\n-//! must first figure out how to phrase the question \"is an impl for\n-//! `Object,i32` usable where an impl for `String,i32` is expected?\"\n-//!\n-//! Maybe it's helpful to think of a dictionary-passing implementation of\n-//! type classes. In that case, `convertAll()` takes an implicit parameter\n-//! representing the impl. In short, we *have* an impl of type:\n-//!\n-//!     V_O = ConvertTo<i32> for Object\n-//!\n-//! and the function prototype expects an impl of type:\n-//!\n-//!     V_S = ConvertTo<i32> for String\n-//!\n-//! As with any argument, this is legal if the type of the value given\n-//! (`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n-//! The answer will depend on the variance of the various parameters. In\n-//! this case, because the `Self` parameter is contravariant and `A` is\n-//! covariant, it means that:\n-//!\n-//!     V_O <: V_S iff\n-//!         i32 <: i32\n-//!         String <: Object\n-//!\n-//! These conditions are satisfied and so we are happy.\n-//!\n-//! #### Variance and associated types\n-//!\n-//! Traits with associated types -- or at minimum projection\n-//! expressions -- must be invariant with respect to all of their\n-//! inputs. To see why this makes sense, consider what subtyping for a\n-//! trait reference means:\n-//!\n-//!    <T as Trait> <: <U as Trait>\n-//!\n-//! means that if I know that `T as Trait`, I also know that `U as\n-//! Trait`. Moreover, if you think of it as dictionary passing style,\n-//! it means that a dictionary for `<T as Trait>` is safe to use where\n-//! a dictionary for `<U as Trait>` is expected.\n-//!\n-//! The problem is that when you can project types out from `<T as\n-//! Trait>`, the relationship to types projected out of `<U as Trait>`\n-//! is completely unknown unless `T==U` (see #21726 for more\n-//! details). Making `Trait` invariant ensures that this is true.\n-//!\n-//! Another related reason is that if we didn't make traits with\n-//! associated types invariant, then projection is no longer a\n-//! function with a single result. Consider:\n-//!\n-//! ```\n-//! trait Identity { type Out; fn foo(&self); }\n-//! impl<T> Identity for T { type Out = T; ... }\n-//! ```\n-//!\n-//! Now if I have `<&'static () as Identity>::Out`, this can be\n-//! validly derived as `&'a ()` for any `'a`:\n-//!\n-//!    <&'a () as Identity> <: <&'static () as Identity>\n-//!    if &'static () < : &'a ()   -- Identity is contravariant in Self\n-//!    if 'static : 'a             -- Subtyping rules for relations\n-//!\n-//! This change otoh means that `<'static () as Identity>::Out` is\n-//! always `&'static ()` (which might then be upcast to `'a ()`,\n-//! separately). This was helpful in solving #21750.\n-\n-use self::VarianceTerm::*;\n-use self::ParamKind::*;\n-\n-use arena;\n-use arena::TypedArena;\n-use dep_graph::DepNode;\n-use middle::def_id::DefId;\n-use middle::resolve_lifetime as rl;\n-use middle::subst;\n-use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n-use middle::ty::{self, Ty};\n-use rustc::front::map as hir_map;\n-use std::fmt;\n-use std::rc::Rc;\n-use syntax::ast;\n-use rustc_front::hir;\n-use rustc_front::intravisit::Visitor;\n-use util::nodemap::NodeMap;\n-\n-pub fn infer_variance(tcx: &ty::ctxt) {\n-    let _task = tcx.dep_graph.in_task(DepNode::Variance);\n-    let krate = tcx.map.krate();\n-    let mut arena = arena::TypedArena::new();\n-    let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n-    let constraints_cx = add_constraints_from_crate(terms_cx, krate);\n-    solve_constraints(constraints_cx);\n-    tcx.variance_computed.set(true);\n-}\n-\n-// Representing terms\n-//\n-// Terms are structured as a straightforward tree. Rather than rely on\n-// GC, we allocate terms out of a bounded arena (the lifetime of this\n-// arena is the lifetime 'a that is threaded around).\n-//\n-// We assign a unique index to each type/region parameter whose variance\n-// is to be inferred. We refer to such variables as \"inferreds\". An\n-// `InferredIndex` is a newtype'd int representing the index of such\n-// a variable.\n-\n-type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n-\n-#[derive(Copy, Clone, Debug)]\n-struct InferredIndex(usize);\n-\n-#[derive(Copy, Clone)]\n-enum VarianceTerm<'a> {\n-    ConstantTerm(ty::Variance),\n-    TransformTerm(VarianceTermPtr<'a>, VarianceTermPtr<'a>),\n-    InferredTerm(InferredIndex),\n-}\n-\n-impl<'a> fmt::Debug for VarianceTerm<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n-            TransformTerm(v1, v2) => write!(f, \"({:?} \\u{00D7} {:?})\", v1, v2),\n-            InferredTerm(id) => write!(f, \"[{}]\", { let InferredIndex(i) = id; i })\n-        }\n-    }\n-}\n-\n-// The first pass over the crate simply builds up the set of inferreds.\n-\n-struct TermsContext<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    arena: &'a TypedArena<VarianceTerm<'a>>,\n-\n-    empty_variances: Rc<ty::ItemVariances>,\n-\n-    // For marker types, UnsafeCell, and other lang items where\n-    // variance is hardcoded, records the item-id and the hardcoded\n-    // variance.\n-    lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n-\n-    // Maps from the node id of a type/generic parameter to the\n-    // corresponding inferred index.\n-    inferred_map: NodeMap<InferredIndex>,\n-\n-    // Maps from an InferredIndex to the info for that variable.\n-    inferred_infos: Vec<InferredInfo<'a>> ,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-enum ParamKind {\n-    TypeParam,\n-    RegionParam,\n-}\n-\n-struct InferredInfo<'a> {\n-    item_id: ast::NodeId,\n-    kind: ParamKind,\n-    space: ParamSpace,\n-    index: usize,\n-    param_id: ast::NodeId,\n-    term: VarianceTermPtr<'a>,\n-\n-    // Initial value to use for this parameter when inferring\n-    // variance. For most parameters, this is Bivariant. But for lang\n-    // items and input type parameters on traits, it is different.\n-    initial_variance: ty::Variance,\n-}\n-\n-fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n-                                                 arena: &'a mut TypedArena<VarianceTerm<'a>>,\n-                                                 krate: &hir::Crate)\n-                                                 -> TermsContext<'a, 'tcx> {\n-    let mut terms_cx = TermsContext {\n-        tcx: tcx,\n-        arena: arena,\n-        inferred_map: NodeMap(),\n-        inferred_infos: Vec::new(),\n-\n-        lang_items: lang_items(tcx),\n-\n-        // cache and share the variance struct used for items with\n-        // no type/region parameters\n-        empty_variances: Rc::new(ty::ItemVariances {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty()\n-        })\n-    };\n-\n-    krate.visit_all_items(&mut terms_cx);\n-\n-    terms_cx\n-}\n-\n-fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n-    let all = vec![\n-        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n-        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n-\n-        // Deprecated:\n-        (tcx.lang_items.covariant_type(), vec![ty::Covariant]),\n-        (tcx.lang_items.contravariant_type(), vec![ty::Contravariant]),\n-        (tcx.lang_items.invariant_type(), vec![ty::Invariant]),\n-        (tcx.lang_items.covariant_lifetime(), vec![ty::Covariant]),\n-        (tcx.lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n-        (tcx.lang_items.invariant_lifetime(), vec![ty::Invariant]),\n-\n-        ];\n-\n-    all.into_iter() // iterating over (Option<DefId>, Variance)\n-       .filter(|&(ref d,_)| d.is_some())\n-       .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-       .filter_map(|(d, v)| tcx.map.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n-       .collect()\n-}\n-\n-impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n-    fn add_inferreds_for_item(&mut self,\n-                              item_id: ast::NodeId,\n-                              has_self: bool,\n-                              generics: &hir::Generics)\n-    {\n-        /*!\n-         * Add \"inferreds\" for the generic parameters declared on this\n-         * item. This has a lot of annoying parameters because we are\n-         * trying to drive this from the AST, rather than the\n-         * ty::Generics, so that we can get span info -- but this\n-         * means we must accommodate syntactic distinctions.\n-         */\n-\n-        // NB: In the code below for writing the results back into the\n-        // tcx, we rely on the fact that all inferreds for a particular\n-        // item are assigned continuous indices.\n-\n-        let inferreds_on_entry = self.num_inferred();\n-\n-        if has_self {\n-            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n-        }\n-\n-        for (i, p) in generics.lifetimes.iter().enumerate() {\n-            let id = p.lifetime.id;\n-            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n-        }\n-\n-        for (i, p) in generics.ty_params.iter().enumerate() {\n-            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n-        }\n-\n-        // If this item has no type or lifetime parameters,\n-        // then there are no variances to infer, so just\n-        // insert an empty entry into the variance map.\n-        // Arguably we could just leave the map empty in this\n-        // case but it seems cleaner to be able to distinguish\n-        // \"invalid item id\" from \"item id with no\n-        // parameters\".\n-        if self.num_inferred() == inferreds_on_entry {\n-            let item_def_id = self.tcx.map.local_def_id(item_id);\n-            let newly_added =\n-                self.tcx.item_variance_map.borrow_mut().insert(\n-                    item_def_id,\n-                    self.empty_variances.clone()).is_none();\n-            assert!(newly_added);\n-        }\n-    }\n-\n-    fn add_inferred(&mut self,\n-                    item_id: ast::NodeId,\n-                    kind: ParamKind,\n-                    space: ParamSpace,\n-                    index: usize,\n-                    param_id: ast::NodeId) {\n-        let inf_index = InferredIndex(self.inferred_infos.len());\n-        let term = self.arena.alloc(InferredTerm(inf_index));\n-        let initial_variance = self.pick_initial_variance(item_id, space, index);\n-        self.inferred_infos.push(InferredInfo { item_id: item_id,\n-                                                kind: kind,\n-                                                space: space,\n-                                                index: index,\n-                                                param_id: param_id,\n-                                                term: term,\n-                                                initial_variance: initial_variance });\n-        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n-        assert!(newly_added);\n-\n-        debug!(\"add_inferred(item_path={}, \\\n-                item_id={}, \\\n-                kind={:?}, \\\n-                space={:?}, \\\n-                index={}, \\\n-                param_id={}, \\\n-                inf_index={:?}, \\\n-                initial_variance={:?})\",\n-               self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n-               item_id, kind, space, index, param_id, inf_index,\n-               initial_variance);\n-    }\n-\n-    fn pick_initial_variance(&self,\n-                             item_id: ast::NodeId,\n-                             space: ParamSpace,\n-                             index: usize)\n-                             -> ty::Variance\n-    {\n-        match space {\n-            SelfSpace | FnSpace => {\n-                ty::Bivariant\n-            }\n-\n-            TypeSpace => {\n-                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n-                    Some(&(_, ref variances)) => variances[index],\n-                    None => ty::Bivariant\n-                }\n-            }\n-        }\n-    }\n-\n-    fn num_inferred(&self) -> usize {\n-        self.inferred_infos.len()\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        debug!(\"add_inferreds for item {}\", self.tcx.map.node_to_string(item.id));\n-\n-        match item.node {\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, false, generics);\n-            }\n-            hir::ItemTrait(_, ref generics, _, _) => {\n-                // Note: all inputs for traits are ultimately\n-                // constrained to be invariant. See `visit_item` in\n-                // the impl for `ConstraintContext` below.\n-                self.add_inferreds_for_item(item.id, true, generics);\n-            }\n-\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(_) |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemTy(..) => {\n-            }\n-        }\n-    }\n-}\n-\n-// Constraint construction and representation\n-//\n-// The second pass over the AST determines the set of constraints.\n-// We walk the set of items and, for each member, generate new constraints.\n-\n-struct ConstraintContext<'a, 'tcx: 'a> {\n-    terms_cx: TermsContext<'a, 'tcx>,\n-\n-    // These are pointers to common `ConstantTerm` instances\n-    covariant: VarianceTermPtr<'a>,\n-    contravariant: VarianceTermPtr<'a>,\n-    invariant: VarianceTermPtr<'a>,\n-    bivariant: VarianceTermPtr<'a>,\n-\n-    constraints: Vec<Constraint<'a>> ,\n-}\n-\n-/// Declares that the variable `decl_id` appears in a location with\n-/// variance `variance`.\n-#[derive(Copy, Clone)]\n-struct Constraint<'a> {\n-    inferred: InferredIndex,\n-    variance: &'a VarianceTerm<'a>,\n-}\n-\n-fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n-                                        krate: &hir::Crate)\n-                                        -> ConstraintContext<'a, 'tcx>\n-{\n-    let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n-    let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n-    let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n-    let bivariant = terms_cx.arena.alloc(ConstantTerm(ty::Bivariant));\n-    let mut constraint_cx = ConstraintContext {\n-        terms_cx: terms_cx,\n-        covariant: covariant,\n-        contravariant: contravariant,\n-        invariant: invariant,\n-        bivariant: bivariant,\n-        constraints: Vec::new(),\n-    };\n-    krate.visit_all_items(&mut constraint_cx);\n-    constraint_cx\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        let tcx = self.terms_cx.tcx;\n-        let did = tcx.map.local_def_id(item.id);\n-\n-        debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n-\n-        match item.node {\n-            hir::ItemEnum(..) | hir::ItemStruct(..) => {\n-                let scheme = tcx.lookup_item_type(did);\n-\n-                // Not entirely obvious: constraints on structs/enums do not\n-                // affect the variance of their type parameters. See discussion\n-                // in comment at top of module.\n-                //\n-                // self.add_constraints_from_generics(&scheme.generics);\n-\n-                for field in tcx.lookup_adt_def(did).all_fields() {\n-                    self.add_constraints_from_ty(&scheme.generics,\n-                                                 field.unsubst_ty(),\n-                                                 self.covariant);\n-                }\n-            }\n-            hir::ItemTrait(..) => {\n-                let trait_def = tcx.lookup_trait_def(did);\n-                self.add_constraints_from_trait_ref(&trait_def.generics,\n-                                                    trait_def.trait_ref,\n-                                                    self.invariant);\n-            }\n-\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(_) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {\n-            }\n-        }\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true, _ => false\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.terms_cx.tcx\n-    }\n-\n-    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.get(&param_id) {\n-            Some(&index) => index,\n-            None => {\n-                self.tcx().sess.bug(&format!(\n-                        \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id)));\n-            }\n-        }\n-    }\n-\n-    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n-        let tcx = self.terms_cx.tcx;\n-        assert!(is_lifetime(&tcx.map, param_id));\n-        match tcx.named_region_map.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n-                => lifetime_decl_id,\n-            Some(_) => panic!(\"should not encounter non early-bound cases\"),\n-\n-            // The lookup should only fail when `param_id` is\n-            // itself a lifetime binding: use it as the decl_id.\n-            None    => param_id,\n-        }\n-\n-    }\n-\n-    /// Is `param_id` a type parameter for which we infer variance?\n-    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool {\n-        let result = self.terms_cx.inferred_map.contains_key(&param_id);\n-\n-        // To safe-guard against invalid inferred_map constructions,\n-        // double-check if variance is inferred at some use of a type\n-        // parameter (by inspecting parent of its binding declaration\n-        // to see if it is introduced by a type or by a fn/impl).\n-\n-        let check_result = |this:&ConstraintContext| -> bool {\n-            let tcx = this.terms_cx.tcx;\n-            let decl_id = this.find_binding_for_lifetime(param_id);\n-            // Currently only called on lifetimes; double-checking that.\n-            assert!(is_lifetime(&tcx.map, param_id));\n-            let parent_id = tcx.map.get_parent(decl_id);\n-            let parent = tcx.map.find(parent_id).unwrap_or_else(\n-                || panic!(\"tcx.map missing entry for id: {}\", parent_id));\n-\n-            let is_inferred;\n-            macro_rules! cannot_happen { () => { {\n-                panic!(\"invalid parent: {} for {}\",\n-                      tcx.map.node_to_string(parent_id),\n-                      tcx.map.node_to_string(param_id));\n-            } } }\n-\n-            match parent {\n-                hir_map::NodeItem(p) => {\n-                    match p.node {\n-                        hir::ItemTy(..) |\n-                        hir::ItemEnum(..) |\n-                        hir::ItemStruct(..) |\n-                        hir::ItemTrait(..)   => is_inferred = true,\n-                        hir::ItemFn(..)      => is_inferred = false,\n-                        _                    => cannot_happen!(),\n-                    }\n-                }\n-                hir_map::NodeTraitItem(..)   => is_inferred = false,\n-                hir_map::NodeImplItem(..)    => is_inferred = false,\n-                _                            => cannot_happen!(),\n-            }\n-\n-            return is_inferred;\n-        };\n-\n-        assert_eq!(result, check_result(self));\n-\n-        return result;\n-    }\n-\n-    /// Returns a variance term representing the declared variance of the type/region parameter\n-    /// with the given id.\n-    fn declared_variance(&self,\n-                         param_def_id: DefId,\n-                         item_def_id: DefId,\n-                         kind: ParamKind,\n-                         space: ParamSpace,\n-                         index: usize)\n-                         -> VarianceTermPtr<'a> {\n-        assert_eq!(param_def_id.krate, item_def_id.krate);\n-\n-        if let Some(param_node_id) = self.tcx().map.as_local_node_id(param_def_id) {\n-            // Parameter on an item defined within current crate:\n-            // variance not yet inferred, so return a symbolic\n-            // variance.\n-            let InferredIndex(index) = self.inferred_index(param_node_id);\n-            self.terms_cx.inferred_infos[index].term\n-        } else {\n-            // Parameter on an item defined within another crate:\n-            // variance already inferred, just look it up.\n-            let variances = self.tcx().item_variances(item_def_id);\n-            let variance = match kind {\n-                TypeParam => *variances.types.get(space, index),\n-                RegionParam => *variances.regions.get(space, index),\n-            };\n-            self.constant_term(variance)\n-        }\n-    }\n-\n-    fn add_constraint(&mut self,\n-                      InferredIndex(index): InferredIndex,\n-                      variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraint(index={}, variance={:?})\",\n-                index, variance);\n-        self.constraints.push(Constraint { inferred: InferredIndex(index),\n-                                           variance: variance });\n-    }\n-\n-    fn contravariant(&mut self,\n-                     variance: VarianceTermPtr<'a>)\n-                     -> VarianceTermPtr<'a> {\n-        self.xform(variance, self.contravariant)\n-    }\n-\n-    fn invariant(&mut self,\n-                 variance: VarianceTermPtr<'a>)\n-                 -> VarianceTermPtr<'a> {\n-        self.xform(variance, self.invariant)\n-    }\n-\n-    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'a> {\n-        match v {\n-            ty::Covariant => self.covariant,\n-            ty::Invariant => self.invariant,\n-            ty::Contravariant => self.contravariant,\n-            ty::Bivariant => self.bivariant,\n-        }\n-    }\n-\n-    fn xform(&mut self,\n-             v1: VarianceTermPtr<'a>,\n-             v2: VarianceTermPtr<'a>)\n-             -> VarianceTermPtr<'a> {\n-        match (*v1, *v2) {\n-            (_, ConstantTerm(ty::Covariant)) => {\n-                // Applying a \"covariant\" transform is always a no-op\n-                v1\n-            }\n-\n-            (ConstantTerm(c1), ConstantTerm(c2)) => {\n-                self.constant_term(c1.xform(c2))\n-            }\n-\n-            _ => {\n-                &*self.terms_cx.arena.alloc(TransformTerm(v1, v2))\n-            }\n-        }\n-    }\n-\n-    fn add_constraints_from_trait_ref(&mut self,\n-                                      generics: &ty::Generics<'tcx>,\n-                                      trait_ref: ty::TraitRef<'tcx>,\n-                                      variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n-               trait_ref,\n-               variance);\n-\n-        let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n-\n-        self.add_constraints_from_substs(\n-            generics,\n-            trait_ref.def_id,\n-            trait_def.generics.types.as_slice(),\n-            trait_def.generics.regions.as_slice(),\n-            trait_ref.substs,\n-            variance);\n-    }\n-\n-    /// Adds constraints appropriate for an instance of `ty` appearing\n-    /// in a context with the generics defined in `generics` and\n-    /// ambient variance `variance`\n-    fn add_constraints_from_ty(&mut self,\n-                               generics: &ty::Generics<'tcx>,\n-                               ty: Ty<'tcx>,\n-                               variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n-               ty,\n-               variance);\n-\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-            ty::TyFloat(_) | ty::TyStr => {\n-                /* leaf type -- noop */\n-            }\n-\n-            ty::TyClosure(..) => {\n-                self.tcx().sess.bug(\"Unexpected closure type in variance computation\");\n-            }\n-\n-            ty::TyRef(region, ref mt) => {\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, *region, contra);\n-                self.add_constraints_from_mt(generics, mt, variance);\n-            }\n-\n-            ty::TyBox(typ) | ty::TyArray(typ, _) | ty::TySlice(typ) => {\n-                self.add_constraints_from_ty(generics, typ, variance);\n-            }\n-\n-\n-            ty::TyRawPtr(ref mt) => {\n-                self.add_constraints_from_mt(generics, mt, variance);\n-            }\n-\n-            ty::TyTuple(ref subtys) => {\n-                for &subty in subtys {\n-                    self.add_constraints_from_ty(generics, subty, variance);\n-                }\n-            }\n-\n-            ty::TyEnum(def, substs) |\n-            ty::TyStruct(def, substs) => {\n-                let item_type = self.tcx().lookup_item_type(def.did);\n-\n-                // All type parameters on enums and structs should be\n-                // in the TypeSpace.\n-                assert!(item_type.generics.types.is_empty_in(subst::SelfSpace));\n-                assert!(item_type.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(item_type.generics.regions.is_empty_in(subst::SelfSpace));\n-                assert!(item_type.generics.regions.is_empty_in(subst::FnSpace));\n-\n-                self.add_constraints_from_substs(\n-                    generics,\n-                    def.did,\n-                    item_type.generics.types.get_slice(subst::TypeSpace),\n-                    item_type.generics.regions.get_slice(subst::TypeSpace),\n-                    substs,\n-                    variance);\n-            }\n-\n-            ty::TyProjection(ref data) => {\n-                let trait_ref = &data.trait_ref;\n-                let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n-                self.add_constraints_from_substs(\n-                    generics,\n-                    trait_ref.def_id,\n-                    trait_def.generics.types.as_slice(),\n-                    trait_def.generics.regions.as_slice(),\n-                    trait_ref.substs,\n-                    variance);\n-            }\n-\n-            ty::TyTrait(ref data) => {\n-                let poly_trait_ref =\n-                    data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                          self.tcx().types.err);\n-\n-                // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n-\n-                // Ignore the SelfSpace, it is erased.\n-                self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n-\n-                let projections = data.projection_bounds_with_self_ty(self.tcx(),\n-                                                                      self.tcx().types.err);\n-                for projection in &projections {\n-                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n-                }\n-            }\n-\n-            ty::TyParam(ref data) => {\n-                let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n-                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n-                match self.terms_cx.inferred_map.get(&node_id) {\n-                    Some(&index) => {\n-                        self.add_constraint(index, variance);\n-                    }\n-                    None => {\n-                        // We do not infer variance for type parameters\n-                        // declared on methods. They will not be present\n-                        // in the inferred_map.\n-                    }\n-                }\n-            }\n-\n-            ty::TyBareFn(_, &ty::BareFnTy { ref sig, .. }) => {\n-                self.add_constraints_from_sig(generics, sig, variance);\n-            }\n-\n-            ty::TyError => {\n-                // we encounter this when walking the trait references for object\n-                // types, where we use TyError as the Self type\n-            }\n-\n-            ty::TyInfer(..) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"unexpected type encountered in \\\n-                              variance inference: {}\", ty));\n-            }\n-        }\n-    }\n-\n-\n-    /// Adds constraints appropriate for a nominal type (enum, struct,\n-    /// object, etc) appearing in a context with ambient variance `variance`\n-    fn add_constraints_from_substs(&mut self,\n-                                   generics: &ty::Generics<'tcx>,\n-                                   def_id: DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef<'tcx>],\n-                                   region_param_defs: &[ty::RegionParameterDef],\n-                                   substs: &subst::Substs<'tcx>,\n-                                   variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n-               def_id,\n-               substs,\n-               variance);\n-\n-        for p in type_param_defs {\n-            let variance_decl =\n-                self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index as usize);\n-            let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index as usize);\n-            debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n-                   variance_decl, variance_i);\n-            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n-        }\n-\n-        for p in region_param_defs {\n-            let variance_decl =\n-                self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index as usize);\n-            let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions().get(p.space, p.index as usize);\n-            self.add_constraints_from_region(generics, substs_r, variance_i);\n-        }\n-    }\n-\n-    /// Adds constraints appropriate for a function with signature\n-    /// `sig` appearing in a context with ambient variance `variance`\n-    fn add_constraints_from_sig(&mut self,\n-                                generics: &ty::Generics<'tcx>,\n-                                sig: &ty::PolyFnSig<'tcx>,\n-                                variance: VarianceTermPtr<'a>) {\n-        let contra = self.contravariant(variance);\n-        for &input in &sig.0.inputs {\n-            self.add_constraints_from_ty(generics, input, contra);\n-        }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            self.add_constraints_from_ty(generics, result_type, variance);\n-        }\n-    }\n-\n-    /// Adds constraints appropriate for a region appearing in a\n-    /// context with ambient variance `variance`\n-    fn add_constraints_from_region(&mut self,\n-                                   generics: &ty::Generics<'tcx>,\n-                                   region: ty::Region,\n-                                   variance: VarianceTermPtr<'a>) {\n-        match region {\n-            ty::ReEarlyBound(ref data) => {\n-                let def_id =\n-                    generics.regions.get(data.space, data.index as usize).def_id;\n-                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n-                if self.is_to_be_inferred(node_id) {\n-                    let index = self.inferred_index(node_id);\n-                    self.add_constraint(index, variance);\n-                }\n-            }\n-\n-            ty::ReStatic => { }\n-\n-            ty::ReLateBound(..) => {\n-                // We do not infer variance for region parameters on\n-                // methods or in fn types.\n-            }\n-\n-            ty::ReFree(..) | ty::ReScope(..) | ty::ReVar(..) |\n-            ty::ReSkolemized(..) | ty::ReEmpty => {\n-                // We don't expect to see anything but 'static or bound\n-                // regions when visiting member types or method types.\n-                self.tcx()\n-                    .sess\n-                    .bug(&format!(\"unexpected region encountered in variance \\\n-                                  inference: {:?}\",\n-                                 region));\n-            }\n-        }\n-    }\n-\n-    /// Adds constraints appropriate for a mutability-type pair\n-    /// appearing in a context with ambient variance `variance`\n-    fn add_constraints_from_mt(&mut self,\n-                               generics: &ty::Generics<'tcx>,\n-                               mt: &ty::TypeAndMut<'tcx>,\n-                               variance: VarianceTermPtr<'a>) {\n-        match mt.mutbl {\n-            hir::MutMutable => {\n-                let invar = self.invariant(variance);\n-                self.add_constraints_from_ty(generics, mt.ty, invar);\n-            }\n-\n-            hir::MutImmutable => {\n-                self.add_constraints_from_ty(generics, mt.ty, variance);\n-            }\n-        }\n-    }\n-}\n-\n-// Constraint solving\n-//\n-// The final phase iterates over the constraints, refining the variance\n-// for each inferred until a fixed point is reached. This will be the\n-// optimal solution to the constraints. The final variance for each\n-// inferred is then written into the `variance_map` in the tcx.\n-\n-struct SolveContext<'a, 'tcx: 'a> {\n-    terms_cx: TermsContext<'a, 'tcx>,\n-    constraints: Vec<Constraint<'a>> ,\n-\n-    // Maps from an InferredIndex to the inferred value for that variable.\n-    solutions: Vec<ty::Variance> }\n-\n-fn solve_constraints(constraints_cx: ConstraintContext) {\n-    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-\n-    let solutions =\n-        terms_cx.inferred_infos.iter()\n-                               .map(|ii| ii.initial_variance)\n-                               .collect();\n-\n-    let mut solutions_cx = SolveContext {\n-        terms_cx: terms_cx,\n-        constraints: constraints,\n-        solutions: solutions\n-    };\n-    solutions_cx.solve();\n-    solutions_cx.write();\n-}\n-\n-impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n-    fn solve(&mut self) {\n-        // Propagate constraints until a fixed point is reached.  Note\n-        // that the maximum number of iterations is 2C where C is the\n-        // number of constraints (each variable can change values at most\n-        // twice). Since number of constraints is linear in size of the\n-        // input, so is the inference process.\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-\n-            for constraint in &self.constraints {\n-                let Constraint { inferred, variance: term } = *constraint;\n-                let InferredIndex(inferred) = inferred;\n-                let variance = self.evaluate(term);\n-                let old_value = self.solutions[inferred];\n-                let new_value = glb(variance, old_value);\n-                if old_value != new_value {\n-                    debug!(\"Updating inferred {} (node {}) \\\n-                            from {:?} to {:?} due to {:?}\",\n-                            inferred,\n-                            self.terms_cx\n-                                .inferred_infos[inferred]\n-                                .param_id,\n-                            old_value,\n-                            new_value,\n-                            term);\n-\n-                    self.solutions[inferred] = new_value;\n-                    changed = true;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn write(&self) {\n-        // Collect all the variances for a particular item and stick\n-        // them into the variance map. We rely on the fact that we\n-        // generate all the inferreds for a particular item\n-        // consecutively (that is, we collect solutions for an item\n-        // until we see a new item id, and we assume (1) the solutions\n-        // are in the same order as the type parameters were declared\n-        // and (2) all solutions or a given item appear before a new\n-        // item id).\n-\n-        let tcx = self.terms_cx.tcx;\n-        let solutions = &self.solutions;\n-        let inferred_infos = &self.terms_cx.inferred_infos;\n-        let mut index = 0;\n-        let num_inferred = self.terms_cx.num_inferred();\n-        while index < num_inferred {\n-            let item_id = inferred_infos[index].item_id;\n-            let mut types = VecPerParamSpace::empty();\n-            let mut regions = VecPerParamSpace::empty();\n-\n-            while index < num_inferred && inferred_infos[index].item_id == item_id {\n-                let info = &inferred_infos[index];\n-                let variance = solutions[index];\n-                debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n-                       index, info.index, info.kind, info.space, variance);\n-                match info.kind {\n-                    TypeParam => { types.push(info.space, variance); }\n-                    RegionParam => { regions.push(info.space, variance); }\n-                }\n-\n-                index += 1;\n-            }\n-\n-            let item_variances = ty::ItemVariances {\n-                types: types,\n-                regions: regions\n-            };\n-            debug!(\"item_id={} item_variances={:?}\",\n-                    item_id,\n-                    item_variances);\n-\n-            let item_def_id = tcx.map.local_def_id(item_id);\n-\n-            // For unit testing: check for a special \"rustc_variance\"\n-            // attribute and report an error with various results if found.\n-            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n-                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n-            }\n-\n-            let newly_added = tcx.item_variance_map.borrow_mut()\n-                                 .insert(item_def_id, Rc::new(item_variances)).is_none();\n-            assert!(newly_added);\n-        }\n-    }\n-\n-    fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {\n-        match *term {\n-            ConstantTerm(v) => {\n-                v\n-            }\n-\n-            TransformTerm(t1, t2) => {\n-                let v1 = self.evaluate(t1);\n-                let v2 = self.evaluate(t2);\n-                v1.xform(v2)\n-            }\n-\n-            InferredTerm(InferredIndex(index)) => {\n-                self.solutions[index]\n-            }\n-        }\n-    }\n-}\n-\n-// Miscellany transformations on variance\n-\n-trait Xform {\n-    fn xform(self, v: Self) -> Self;\n-}\n-\n-impl Xform for ty::Variance {\n-    fn xform(self, v: ty::Variance) -> ty::Variance {\n-        // \"Variance transformation\", Figure 1 of The Paper\n-        match (self, v) {\n-            // Figure 1, column 1.\n-            (ty::Covariant, ty::Covariant) => ty::Covariant,\n-            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n-            (ty::Covariant, ty::Invariant) => ty::Invariant,\n-            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 2.\n-            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n-            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n-            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n-            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 3.\n-            (ty::Invariant, _) => ty::Invariant,\n-\n-            // Figure 1, column 4.\n-            (ty::Bivariant, _) => ty::Bivariant,\n-        }\n-    }\n-}\n-\n-fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n-    // Greatest lower bound of the variance lattice as\n-    // defined in The Paper:\n-    //\n-    //       *\n-    //    -     +\n-    //       o\n-    match (v1, v2) {\n-        (ty::Invariant, _) | (_, ty::Invariant) => ty::Invariant,\n-\n-        (ty::Covariant, ty::Contravariant) => ty::Invariant,\n-        (ty::Contravariant, ty::Covariant) => ty::Invariant,\n-\n-        (ty::Covariant, ty::Covariant) => ty::Covariant,\n-\n-        (ty::Contravariant, ty::Contravariant) => ty::Contravariant,\n-\n-        (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n-    }\n-}"}, {"sha": "94d1ff91c37b5973810b0938ff8590cfec6013d2", "filename": "src/librustc_typeck/variance/README.md", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -0,0 +1,302 @@\n+This file infers the variance of type and lifetime parameters. The\n+algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n+Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n+written by Altidor et al., and hereafter referred to as The Paper.\n+\n+This inference is explicitly designed *not* to consider the uses of\n+types within code. To determine the variance of type parameters\n+defined on type `X`, we only consider the definition of the type `X`\n+and the definitions of any types it references.\n+\n+We only infer variance for type parameters found on *data types*\n+like structs and enums. In these cases, there is fairly straightforward\n+explanation for what variance means. The variance of the type\n+or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n+(resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n+(resp. `'a` and `'b`).\n+\n+We do not infer variance for type parameters found on traits, fns,\n+or impls. Variance on trait parameters can make indeed make sense\n+(and we used to compute it) but it is actually rather subtle in\n+meaning and not that useful in practice, so we removed it. See the\n+addendum for some details. Variances on fn/impl parameters, otoh,\n+doesn't make sense because these parameters are instantiated and\n+then forgotten, they don't persist in types or compiled\n+byproducts.\n+\n+### The algorithm\n+\n+The basic idea is quite straightforward. We iterate over the types\n+defined and, for each use of a type parameter X, accumulate a\n+constraint indicating that the variance of X must be valid for the\n+variance of that use site. We then iteratively refine the variance of\n+X until all constraints are met. There is *always* a sol'n, because at\n+the limit we can declare all type parameters to be invariant and all\n+constraints will be satisfied.\n+\n+As a simple example, consider:\n+\n+    enum Option<A> { Some(A), None }\n+    enum OptionalFn<B> { Some(|B|), None }\n+    enum OptionalMap<C> { Some(|C| -> C), None }\n+\n+Here, we will generate the constraints:\n+\n+    1. V(A) <= +\n+    2. V(B) <= -\n+    3. V(C) <= +\n+    4. V(C) <= -\n+\n+These indicate that (1) the variance of A must be at most covariant;\n+(2) the variance of B must be at most contravariant; and (3, 4) the\n+variance of C must be at most covariant *and* contravariant. All of these\n+results are based on a variance lattice defined as follows:\n+\n+      *      Top (bivariant)\n+   -     +\n+      o      Bottom (invariant)\n+\n+Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n+optimal solution. Note that there is always a naive solution which\n+just declares all variables to be invariant.\n+\n+You may be wondering why fixed-point iteration is required. The reason\n+is that the variance of a use site may itself be a function of the\n+variance of other type parameters. In full generality, our constraints\n+take the form:\n+\n+    V(X) <= Term\n+    Term := + | - | * | o | V(X) | Term x Term\n+\n+Here the notation V(X) indicates the variance of a type/region\n+parameter `X` with respect to its defining class. `Term x Term`\n+represents the \"variance transform\" as defined in the paper:\n+\n+  If the variance of a type variable `X` in type expression `E` is `V2`\n+  and the definition-site variance of the [corresponding] type parameter\n+  of a class `C` is `V1`, then the variance of `X` in the type expression\n+  `C<E>` is `V3 = V1.xform(V2)`.\n+\n+### Constraints\n+\n+If I have a struct or enum with where clauses:\n+\n+    struct Foo<T:Bar> { ... }\n+\n+you might wonder whether the variance of `T` with respect to `Bar`\n+affects the variance `T` with respect to `Foo`. I claim no.  The\n+reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n+`Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n+`X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n+case, the upcast will be illegal, but not because of a variance\n+failure, but rather because the target type `Foo<Y>` is itself just\n+not well-formed. Basically we get to assume well-formedness of all\n+types involved before considering variance.\n+\n+#### Dependency graph management\n+\n+Because variance works in two phases, if we are not careful, we wind\n+up with a muddled mess of a dep-graph. Basically, when gathering up\n+the constraints, things are fairly well-structured, but then we do a\n+fixed-point iteration and write the results back where they\n+belong. You can't give this fixed-point iteration a single task\n+because it reads from (and writes to) the variance of all types in the\n+crate. In principle, we *could* switch the \"current task\" in a very\n+fine-grained way while propagating constraints in the fixed-point\n+iteration and everything would be automatically tracked, but that\n+would add some overhead and isn't really necessary anyway.\n+\n+Instead what we do is to add edges into the dependency graph as we\n+construct the constraint set: so, if computing the constraints for\n+node `X` requires loading the inference variables from node `Y`, then\n+we can add an edge `Y -> X`, since the variance we ultimately infer\n+for `Y` will affect the variance we ultimately infer for `X`.\n+\n+At this point, we've basically mirrored the inference graph in the\n+dependency graph. This means we can just completely ignore the\n+fixed-point iteration, since it is just shuffling values along this\n+graph. In other words, if we added the fine-grained switching of tasks\n+I described earlier, all it would show is that we repeatedly read the\n+values described by the constraints, but those edges were already\n+added when building the constraints in the first place.\n+\n+Here is how this is implemented (at least as of the time of this\n+writing). The associated `DepNode` for the variance map is (at least\n+presently) `Signature(DefId)`. This means that, in `constraints.rs`,\n+when we visit an item to load up its constraints, we set\n+`Signature(DefId)` as the current task (the \"memoization\" pattern\n+described in the `dep-graph` README). Then whenever we find an\n+embedded type or trait, we add a synthetic read of `Signature(DefId)`,\n+which covers the variances we will compute for all of its\n+parameters. This read is synthetic (i.e., we call\n+`variance_map.read()`) because, in fact, the final variance is not yet\n+computed -- the read *will* occur (repeatedly) during the fixed-point\n+iteration phase.\n+\n+In fact, we don't really *need* this synthetic read. That's because we\n+do wind up looking up the `TypeScheme` or `TraitDef` for all\n+references types/traits, and those reads add an edge from\n+`Signature(DefId)` (that is, they share the same dep node as\n+variance). However, I've kept the synthetic reads in place anyway,\n+just for future-proofing (in case we change the dep-nodes in the\n+future), and because it makes the intention a bit clearer I think.\n+\n+### Addendum: Variance on traits\n+\n+As mentioned above, we used to permit variance on traits. This was\n+computed based on the appearance of trait type parameters in\n+method signatures and was used to represent the compatibility of\n+vtables in trait objects (and also \"virtual\" vtables or dictionary\n+in trait bounds). One complication was that variance for\n+associated types is less obvious, since they can be projected out\n+and put to myriad uses, so it's not clear when it is safe to allow\n+`X<A>::Bar` to vary (or indeed just what that means). Moreover (as\n+covered below) all inputs on any trait with an associated type had\n+to be invariant, limiting the applicability. Finally, the\n+annotations (`MarkerTrait`, `PhantomFn`) needed to ensure that all\n+trait type parameters had a variance were confusing and annoying\n+for little benefit.\n+\n+Just for historical reference,I am going to preserve some text indicating\n+how one could interpret variance and trait matching.\n+\n+#### Variance and object types\n+\n+Just as with structs and enums, we can decide the subtyping\n+relationship between two object types `&Trait<A>` and `&Trait<B>`\n+based on the relationship of `A` and `B`. Note that for object\n+types we ignore the `Self` type parameter -- it is unknown, and\n+the nature of dynamic dispatch ensures that we will always call a\n+function that is expected the appropriate `Self` type. However, we\n+must be careful with the other type parameters, or else we could\n+end up calling a function that is expecting one type but provided\n+another.\n+\n+To see what I mean, consider a trait like so:\n+\n+    trait ConvertTo<A> {\n+        fn convertTo(&self) -> A;\n+    }\n+\n+Intuitively, If we had one object `O=&ConvertTo<Object>` and another\n+`S=&ConvertTo<String>`, then `S <: O` because `String <: Object`\n+(presuming Java-like \"string\" and \"object\" types, my go to examples\n+for subtyping). The actual algorithm would be to compare the\n+(explicit) type parameters pairwise respecting their variance: here,\n+the type parameter A is covariant (it appears only in a return\n+position), and hence we require that `String <: Object`.\n+\n+You'll note though that we did not consider the binding for the\n+(implicit) `Self` type parameter: in fact, it is unknown, so that's\n+good. The reason we can ignore that parameter is precisely because we\n+don't need to know its value until a call occurs, and at that time (as\n+you said) the dynamic nature of virtual dispatch means the code we run\n+will be correct for whatever value `Self` happens to be bound to for\n+the particular object whose method we called. `Self` is thus different\n+from `A`, because the caller requires that `A` be known in order to\n+know the return type of the method `convertTo()`. (As an aside, we\n+have rules preventing methods where `Self` appears outside of the\n+receiver position from being called via an object.)\n+\n+#### Trait variance and vtable resolution\n+\n+But traits aren't only used with objects. They're also used when\n+deciding whether a given impl satisfies a given trait bound. To set the\n+scene here, imagine I had a function:\n+\n+    fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n+        ...\n+    }\n+\n+Now imagine that I have an implementation of `ConvertTo` for `Object`:\n+\n+    impl ConvertTo<i32> for Object { ... }\n+\n+And I want to call `convertAll` on an array of strings. Suppose\n+further that for whatever reason I specifically supply the value of\n+`String` for the type parameter `T`:\n+\n+    let mut vector = vec![\"string\", ...];\n+    convertAll::<i32, String>(vector);\n+\n+Is this legal? To put another way, can we apply the `impl` for\n+`Object` to the type `String`? The answer is yes, but to see why\n+we have to expand out what will happen:\n+\n+- `convertAll` will create a pointer to one of the entries in the\n+  vector, which will have type `&String`\n+- It will then call the impl of `convertTo()` that is intended\n+  for use with objects. This has the type:\n+\n+      fn(self: &Object) -> i32\n+\n+  It is ok to provide a value for `self` of type `&String` because\n+  `&String <: &Object`.\n+\n+OK, so intuitively we want this to be legal, so let's bring this back\n+to variance and see whether we are computing the correct result. We\n+must first figure out how to phrase the question \"is an impl for\n+`Object,i32` usable where an impl for `String,i32` is expected?\"\n+\n+Maybe it's helpful to think of a dictionary-passing implementation of\n+type classes. In that case, `convertAll()` takes an implicit parameter\n+representing the impl. In short, we *have* an impl of type:\n+\n+    V_O = ConvertTo<i32> for Object\n+\n+and the function prototype expects an impl of type:\n+\n+    V_S = ConvertTo<i32> for String\n+\n+As with any argument, this is legal if the type of the value given\n+(`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n+The answer will depend on the variance of the various parameters. In\n+this case, because the `Self` parameter is contravariant and `A` is\n+covariant, it means that:\n+\n+    V_O <: V_S iff\n+        i32 <: i32\n+        String <: Object\n+\n+These conditions are satisfied and so we are happy.\n+\n+#### Variance and associated types\n+\n+Traits with associated types -- or at minimum projection\n+expressions -- must be invariant with respect to all of their\n+inputs. To see why this makes sense, consider what subtyping for a\n+trait reference means:\n+\n+   <T as Trait> <: <U as Trait>\n+\n+means that if I know that `T as Trait`, I also know that `U as\n+Trait`. Moreover, if you think of it as dictionary passing style,\n+it means that a dictionary for `<T as Trait>` is safe to use where\n+a dictionary for `<U as Trait>` is expected.\n+\n+The problem is that when you can project types out from `<T as\n+Trait>`, the relationship to types projected out of `<U as Trait>`\n+is completely unknown unless `T==U` (see #21726 for more\n+details). Making `Trait` invariant ensures that this is true.\n+\n+Another related reason is that if we didn't make traits with\n+associated types invariant, then projection is no longer a\n+function with a single result. Consider:\n+\n+```\n+trait Identity { type Out; fn foo(&self); }\n+impl<T> Identity for T { type Out = T; ... }\n+```\n+\n+Now if I have `<&'static () as Identity>::Out`, this can be\n+validly derived as `&'a ()` for any `'a`:\n+\n+   <&'a () as Identity> <: <&'static () as Identity>\n+   if &'static () < : &'a ()   -- Identity is contravariant in Self\n+   if 'static : 'a             -- Subtyping rules for relations\n+\n+This change otoh means that `<'static () as Identity>::Out` is\n+always `&'static ()` (which might then be upcast to `'a ()`,\n+separately). This was helpful in solving #21750.\n+\n+"}, {"sha": "2f243d0fd0f80cb7c2ffe7acfd3c7c87237461e7", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -0,0 +1,553 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Constraint construction and representation\n+//!\n+//! The second pass over the AST determines the set of constraints.\n+//! We walk the set of items and, for each member, generate new constraints.\n+\n+use dep_graph::DepTrackingMapConfig;\n+use middle::def_id::DefId;\n+use middle::resolve_lifetime as rl;\n+use middle::subst;\n+use middle::subst::ParamSpace;\n+use middle::ty::{self, Ty};\n+use middle::ty::maps::ItemVariances;\n+use rustc::front::map as hir_map;\n+use syntax::ast;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+\n+use super::terms::*;\n+use super::terms::VarianceTerm::*;\n+use super::terms::ParamKind::*;\n+use super::xform::*;\n+\n+pub struct ConstraintContext<'a, 'tcx: 'a> {\n+    pub terms_cx: TermsContext<'a, 'tcx>,\n+\n+    // These are pointers to common `ConstantTerm` instances\n+    covariant: VarianceTermPtr<'a>,\n+    contravariant: VarianceTermPtr<'a>,\n+    invariant: VarianceTermPtr<'a>,\n+    bivariant: VarianceTermPtr<'a>,\n+\n+    pub constraints: Vec<Constraint<'a>> ,\n+}\n+\n+/// Declares that the variable `decl_id` appears in a location with\n+/// variance `variance`.\n+#[derive(Copy, Clone)]\n+pub struct Constraint<'a> {\n+    pub inferred: InferredIndex,\n+    pub variance: &'a VarianceTerm<'a>,\n+}\n+\n+pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n+                                            -> ConstraintContext<'a, 'tcx>\n+{\n+    let tcx = terms_cx.tcx;\n+    let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n+    let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n+    let invariant = terms_cx.arena.alloc(ConstantTerm(ty::Invariant));\n+    let bivariant = terms_cx.arena.alloc(ConstantTerm(ty::Bivariant));\n+    let mut constraint_cx = ConstraintContext {\n+        terms_cx: terms_cx,\n+        covariant: covariant,\n+        contravariant: contravariant,\n+        invariant: invariant,\n+        bivariant: bivariant,\n+        constraints: Vec::new(),\n+    };\n+\n+    // See README.md for a discussion on dep-graph management.\n+    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n+                                 &mut constraint_cx);\n+\n+    constraint_cx\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let tcx = self.terms_cx.tcx;\n+        let did = tcx.map.local_def_id(item.id);\n+\n+        debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n+\n+        match item.node {\n+            hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+                let scheme = tcx.lookup_item_type(did);\n+\n+                // Not entirely obvious: constraints on structs/enums do not\n+                // affect the variance of their type parameters. See discussion\n+                // in comment at top of module.\n+                //\n+                // self.add_constraints_from_generics(&scheme.generics);\n+\n+                for field in tcx.lookup_adt_def(did).all_fields() {\n+                    self.add_constraints_from_ty(&scheme.generics,\n+                                                 field.unsubst_ty(),\n+                                                 self.covariant);\n+                }\n+            }\n+            hir::ItemTrait(..) => {\n+                let trait_def = tcx.lookup_trait_def(did);\n+                self.add_constraints_from_trait_ref(&trait_def.generics,\n+                                                    trait_def.trait_ref,\n+                                                    self.invariant);\n+            }\n+\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(_) |\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) |\n+            hir::ItemFn(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemTy(..) |\n+            hir::ItemImpl(..) |\n+            hir::ItemDefaultImpl(..) => {\n+            }\n+        }\n+    }\n+}\n+\n+/// Is `param_id` a lifetime according to `map`?\n+fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n+    match map.find(param_id) {\n+        Some(hir_map::NodeLifetime(..)) => true, _ => false\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.terms_cx.tcx\n+    }\n+\n+    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n+        match self.terms_cx.inferred_map.get(&param_id) {\n+            Some(&index) => index,\n+            None => {\n+                self.tcx().sess.bug(&format!(\n+                        \"no inferred index entry for {}\",\n+                        self.tcx().map.node_to_string(param_id)));\n+            }\n+        }\n+    }\n+\n+    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n+        let tcx = self.terms_cx.tcx;\n+        assert!(is_lifetime(&tcx.map, param_id));\n+        match tcx.named_region_map.get(&param_id) {\n+            Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n+                => lifetime_decl_id,\n+            Some(_) => panic!(\"should not encounter non early-bound cases\"),\n+\n+            // The lookup should only fail when `param_id` is\n+            // itself a lifetime binding: use it as the decl_id.\n+            None    => param_id,\n+        }\n+\n+    }\n+\n+    /// Is `param_id` a type parameter for which we infer variance?\n+    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool {\n+        let result = self.terms_cx.inferred_map.contains_key(&param_id);\n+\n+        // To safe-guard against invalid inferred_map constructions,\n+        // double-check if variance is inferred at some use of a type\n+        // parameter (by inspecting parent of its binding declaration\n+        // to see if it is introduced by a type or by a fn/impl).\n+\n+        let check_result = |this:&ConstraintContext| -> bool {\n+            let tcx = this.terms_cx.tcx;\n+            let decl_id = this.find_binding_for_lifetime(param_id);\n+            // Currently only called on lifetimes; double-checking that.\n+            assert!(is_lifetime(&tcx.map, param_id));\n+            let parent_id = tcx.map.get_parent(decl_id);\n+            let parent = tcx.map.find(parent_id).unwrap_or_else(\n+                || panic!(\"tcx.map missing entry for id: {}\", parent_id));\n+\n+            let is_inferred;\n+            macro_rules! cannot_happen { () => { {\n+                panic!(\"invalid parent: {} for {}\",\n+                      tcx.map.node_to_string(parent_id),\n+                      tcx.map.node_to_string(param_id));\n+            } } }\n+\n+            match parent {\n+                hir_map::NodeItem(p) => {\n+                    match p.node {\n+                        hir::ItemTy(..) |\n+                        hir::ItemEnum(..) |\n+                        hir::ItemStruct(..) |\n+                        hir::ItemTrait(..)   => is_inferred = true,\n+                        hir::ItemFn(..)      => is_inferred = false,\n+                        _                    => cannot_happen!(),\n+                    }\n+                }\n+                hir_map::NodeTraitItem(..)   => is_inferred = false,\n+                hir_map::NodeImplItem(..)    => is_inferred = false,\n+                _                            => cannot_happen!(),\n+            }\n+\n+            return is_inferred;\n+        };\n+\n+        assert_eq!(result, check_result(self));\n+\n+        return result;\n+    }\n+\n+    /// Returns a variance term representing the declared variance of the type/region parameter\n+    /// with the given id.\n+    fn declared_variance(&self,\n+                         param_def_id: DefId,\n+                         item_def_id: DefId,\n+                         kind: ParamKind,\n+                         space: ParamSpace,\n+                         index: usize)\n+                         -> VarianceTermPtr<'a> {\n+        assert_eq!(param_def_id.krate, item_def_id.krate);\n+\n+        if let Some(param_node_id) = self.tcx().map.as_local_node_id(param_def_id) {\n+            // Parameter on an item defined within current crate:\n+            // variance not yet inferred, so return a symbolic\n+            // variance.\n+            let InferredIndex(index) = self.inferred_index(param_node_id);\n+            self.terms_cx.inferred_infos[index].term\n+        } else {\n+            // Parameter on an item defined within another crate:\n+            // variance already inferred, just look it up.\n+            let variances = self.tcx().item_variances(item_def_id);\n+            let variance = match kind {\n+                TypeParam => *variances.types.get(space, index),\n+                RegionParam => *variances.regions.get(space, index),\n+            };\n+            self.constant_term(variance)\n+        }\n+    }\n+\n+    fn add_constraint(&mut self,\n+                      InferredIndex(index): InferredIndex,\n+                      variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraint(index={}, variance={:?})\",\n+                index, variance);\n+        self.constraints.push(Constraint { inferred: InferredIndex(index),\n+                                           variance: variance });\n+    }\n+\n+    fn contravariant(&mut self,\n+                     variance: VarianceTermPtr<'a>)\n+                     -> VarianceTermPtr<'a> {\n+        self.xform(variance, self.contravariant)\n+    }\n+\n+    fn invariant(&mut self,\n+                 variance: VarianceTermPtr<'a>)\n+                 -> VarianceTermPtr<'a> {\n+        self.xform(variance, self.invariant)\n+    }\n+\n+    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'a> {\n+        match v {\n+            ty::Covariant => self.covariant,\n+            ty::Invariant => self.invariant,\n+            ty::Contravariant => self.contravariant,\n+            ty::Bivariant => self.bivariant,\n+        }\n+    }\n+\n+    fn xform(&mut self,\n+             v1: VarianceTermPtr<'a>,\n+             v2: VarianceTermPtr<'a>)\n+             -> VarianceTermPtr<'a> {\n+        match (*v1, *v2) {\n+            (_, ConstantTerm(ty::Covariant)) => {\n+                // Applying a \"covariant\" transform is always a no-op\n+                v1\n+            }\n+\n+            (ConstantTerm(c1), ConstantTerm(c2)) => {\n+                self.constant_term(c1.xform(c2))\n+            }\n+\n+            _ => {\n+                &*self.terms_cx.arena.alloc(TransformTerm(v1, v2))\n+            }\n+        }\n+    }\n+\n+    fn add_constraints_from_trait_ref(&mut self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      trait_ref: ty::TraitRef<'tcx>,\n+                                      variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n+               trait_ref,\n+               variance);\n+\n+        let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+\n+        // This edge is actually implied by the call to\n+        // `lookup_trait_def`, but I'm trying to be future-proof. See\n+        // README.md for a discussion on dep-graph management.\n+        self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+\n+        self.add_constraints_from_substs(\n+            generics,\n+            trait_ref.def_id,\n+            trait_def.generics.types.as_slice(),\n+            trait_def.generics.regions.as_slice(),\n+            trait_ref.substs,\n+            variance);\n+    }\n+\n+    /// Adds constraints appropriate for an instance of `ty` appearing\n+    /// in a context with the generics defined in `generics` and\n+    /// ambient variance `variance`\n+    fn add_constraints_from_ty(&mut self,\n+                               generics: &ty::Generics<'tcx>,\n+                               ty: Ty<'tcx>,\n+                               variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\",\n+               ty,\n+               variance);\n+\n+        match ty.sty {\n+            ty::TyBool |\n+            ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n+            ty::TyFloat(_) | ty::TyStr => {\n+                /* leaf type -- noop */\n+            }\n+\n+            ty::TyClosure(..) => {\n+                self.tcx().sess.bug(\"Unexpected closure type in variance computation\");\n+            }\n+\n+            ty::TyRef(region, ref mt) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(generics, *region, contra);\n+                self.add_constraints_from_mt(generics, mt, variance);\n+            }\n+\n+            ty::TyBox(typ) | ty::TyArray(typ, _) | ty::TySlice(typ) => {\n+                self.add_constraints_from_ty(generics, typ, variance);\n+            }\n+\n+\n+            ty::TyRawPtr(ref mt) => {\n+                self.add_constraints_from_mt(generics, mt, variance);\n+            }\n+\n+            ty::TyTuple(ref subtys) => {\n+                for &subty in subtys {\n+                    self.add_constraints_from_ty(generics, subty, variance);\n+                }\n+            }\n+\n+            ty::TyEnum(def, substs) |\n+            ty::TyStruct(def, substs) => {\n+                let item_type = self.tcx().lookup_item_type(def.did);\n+\n+                // This edge is actually implied by the call to\n+                // `lookup_trait_def`, but I'm trying to be future-proof. See\n+                // README.md for a discussion on dep-graph management.\n+                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n+\n+                // All type parameters on enums and structs should be\n+                // in the TypeSpace.\n+                assert!(item_type.generics.types.is_empty_in(subst::SelfSpace));\n+                assert!(item_type.generics.types.is_empty_in(subst::FnSpace));\n+                assert!(item_type.generics.regions.is_empty_in(subst::SelfSpace));\n+                assert!(item_type.generics.regions.is_empty_in(subst::FnSpace));\n+\n+                self.add_constraints_from_substs(\n+                    generics,\n+                    def.did,\n+                    item_type.generics.types.get_slice(subst::TypeSpace),\n+                    item_type.generics.regions.get_slice(subst::TypeSpace),\n+                    substs,\n+                    variance);\n+            }\n+\n+            ty::TyProjection(ref data) => {\n+                let trait_ref = &data.trait_ref;\n+                let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+\n+                // This edge is actually implied by the call to\n+                // `lookup_trait_def`, but I'm trying to be future-proof. See\n+                // README.md for a discussion on dep-graph management.\n+                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+\n+                self.add_constraints_from_substs(\n+                    generics,\n+                    trait_ref.def_id,\n+                    trait_def.generics.types.as_slice(),\n+                    trait_def.generics.regions.as_slice(),\n+                    trait_ref.substs,\n+                    variance);\n+            }\n+\n+            ty::TyTrait(ref data) => {\n+                let poly_trait_ref =\n+                    data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                          self.tcx().types.err);\n+\n+                // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n+\n+                // Ignore the SelfSpace, it is erased.\n+                self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+\n+                let projections = data.projection_bounds_with_self_ty(self.tcx(),\n+                                                                      self.tcx().types.err);\n+                for projection in &projections {\n+                    self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n+                }\n+            }\n+\n+            ty::TyParam(ref data) => {\n+                let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n+                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                match self.terms_cx.inferred_map.get(&node_id) {\n+                    Some(&index) => {\n+                        self.add_constraint(index, variance);\n+                    }\n+                    None => {\n+                        // We do not infer variance for type parameters\n+                        // declared on methods. They will not be present\n+                        // in the inferred_map.\n+                    }\n+                }\n+            }\n+\n+            ty::TyBareFn(_, &ty::BareFnTy { ref sig, .. }) => {\n+                self.add_constraints_from_sig(generics, sig, variance);\n+            }\n+\n+            ty::TyError => {\n+                // we encounter this when walking the trait references for object\n+                // types, where we use TyError as the Self type\n+            }\n+\n+            ty::TyInfer(..) => {\n+                self.tcx().sess.bug(\n+                    &format!(\"unexpected type encountered in \\\n+                              variance inference: {}\", ty));\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a nominal type (enum, struct,\n+    /// object, etc) appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_substs(&mut self,\n+                                   generics: &ty::Generics<'tcx>,\n+                                   def_id: DefId,\n+                                   type_param_defs: &[ty::TypeParameterDef<'tcx>],\n+                                   region_param_defs: &[ty::RegionParameterDef],\n+                                   substs: &subst::Substs<'tcx>,\n+                                   variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n+               def_id,\n+               substs,\n+               variance);\n+\n+        for p in type_param_defs {\n+            let variance_decl =\n+                self.declared_variance(p.def_id, def_id, TypeParam,\n+                                       p.space, p.index as usize);\n+            let variance_i = self.xform(variance, variance_decl);\n+            let substs_ty = *substs.types.get(p.space, p.index as usize);\n+            debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n+                   variance_decl, variance_i);\n+            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n+        }\n+\n+        for p in region_param_defs {\n+            let variance_decl =\n+                self.declared_variance(p.def_id, def_id,\n+                                       RegionParam, p.space, p.index as usize);\n+            let variance_i = self.xform(variance, variance_decl);\n+            let substs_r = *substs.regions().get(p.space, p.index as usize);\n+            self.add_constraints_from_region(generics, substs_r, variance_i);\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a function with signature\n+    /// `sig` appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_sig(&mut self,\n+                                generics: &ty::Generics<'tcx>,\n+                                sig: &ty::PolyFnSig<'tcx>,\n+                                variance: VarianceTermPtr<'a>) {\n+        let contra = self.contravariant(variance);\n+        for &input in &sig.0.inputs {\n+            self.add_constraints_from_ty(generics, input, contra);\n+        }\n+        if let ty::FnConverging(result_type) = sig.0.output {\n+            self.add_constraints_from_ty(generics, result_type, variance);\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a region appearing in a\n+    /// context with ambient variance `variance`\n+    fn add_constraints_from_region(&mut self,\n+                                   generics: &ty::Generics<'tcx>,\n+                                   region: ty::Region,\n+                                   variance: VarianceTermPtr<'a>) {\n+        match region {\n+            ty::ReEarlyBound(ref data) => {\n+                let def_id =\n+                    generics.regions.get(data.space, data.index as usize).def_id;\n+                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                if self.is_to_be_inferred(node_id) {\n+                    let index = self.inferred_index(node_id);\n+                    self.add_constraint(index, variance);\n+                }\n+            }\n+\n+            ty::ReStatic => { }\n+\n+            ty::ReLateBound(..) => {\n+                // We do not infer variance for region parameters on\n+                // methods or in fn types.\n+            }\n+\n+            ty::ReFree(..) | ty::ReScope(..) | ty::ReVar(..) |\n+            ty::ReSkolemized(..) | ty::ReEmpty => {\n+                // We don't expect to see anything but 'static or bound\n+                // regions when visiting member types or method types.\n+                self.tcx()\n+                    .sess\n+                    .bug(&format!(\"unexpected region encountered in variance \\\n+                                  inference: {:?}\",\n+                                 region));\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a mutability-type pair\n+    /// appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_mt(&mut self,\n+                               generics: &ty::Generics<'tcx>,\n+                               mt: &ty::TypeAndMut<'tcx>,\n+                               variance: VarianceTermPtr<'a>) {\n+        match mt.mutbl {\n+            hir::MutMutable => {\n+                let invar = self.invariant(variance);\n+                self.add_constraints_from_ty(generics, mt.ty, invar);\n+            }\n+\n+            hir::MutImmutable => {\n+                self.add_constraints_from_ty(generics, mt.ty, variance);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3ce3a868f047723c8c16c20e39a399b8829e225e", "filename": "src/librustc_typeck/variance/mod.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Module for inferring the variance of type and lifetime\n+//! parameters. See README.md for details.\n+\n+use arena;\n+use middle::ty;\n+\n+/// Defines the `TermsContext` basically houses an arena where we can\n+/// allocate terms.\n+mod terms;\n+\n+/// Code to gather up constraints.\n+mod constraints;\n+\n+/// Code to solve constraints and write out the results.\n+mod solve;\n+\n+/// Code for transforming variances.\n+mod xform;\n+\n+pub fn infer_variance(tcx: &ty::ctxt) {\n+    let mut arena = arena::TypedArena::new();\n+    let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n+    let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n+    solve::solve_constraints(constraints_cx);\n+    tcx.variance_computed.set(true);\n+}\n+"}, {"sha": "fd442a4547cf92a360e5d5fce0622c30a7591bd2", "filename": "src/librustc_typeck/variance/solve.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Constraint solving\n+//!\n+//! The final phase iterates over the constraints, refining the variance\n+//! for each inferred until a fixed point is reached. This will be the\n+//! optimal solution to the constraints. The final variance for each\n+//! inferred is then written into the `variance_map` in the tcx.\n+\n+use middle::subst::VecPerParamSpace;\n+use middle::ty;\n+use std::rc::Rc;\n+\n+use super::constraints::*;\n+use super::terms::*;\n+use super::terms::VarianceTerm::*;\n+use super::terms::ParamKind::*;\n+use super::xform::*;\n+\n+struct SolveContext<'a, 'tcx: 'a> {\n+    terms_cx: TermsContext<'a, 'tcx>,\n+    constraints: Vec<Constraint<'a>> ,\n+\n+    // Maps from an InferredIndex to the inferred value for that variable.\n+    solutions: Vec<ty::Variance>\n+}\n+\n+pub fn solve_constraints(constraints_cx: ConstraintContext) {\n+    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n+\n+    let solutions =\n+        terms_cx.inferred_infos.iter()\n+                               .map(|ii| ii.initial_variance)\n+                               .collect();\n+\n+    let mut solutions_cx = SolveContext {\n+        terms_cx: terms_cx,\n+        constraints: constraints,\n+        solutions: solutions\n+    };\n+    solutions_cx.solve();\n+    solutions_cx.write();\n+}\n+\n+impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n+    fn solve(&mut self) {\n+        // Propagate constraints until a fixed point is reached.  Note\n+        // that the maximum number of iterations is 2C where C is the\n+        // number of constraints (each variable can change values at most\n+        // twice). Since number of constraints is linear in size of the\n+        // input, so is the inference process.\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+\n+            for constraint in &self.constraints {\n+                let Constraint { inferred, variance: term } = *constraint;\n+                let InferredIndex(inferred) = inferred;\n+                let variance = self.evaluate(term);\n+                let old_value = self.solutions[inferred];\n+                let new_value = glb(variance, old_value);\n+                if old_value != new_value {\n+                    debug!(\"Updating inferred {} (node {}) \\\n+                            from {:?} to {:?} due to {:?}\",\n+                            inferred,\n+                            self.terms_cx\n+                                .inferred_infos[inferred]\n+                                .param_id,\n+                            old_value,\n+                            new_value,\n+                            term);\n+\n+                    self.solutions[inferred] = new_value;\n+                    changed = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn write(&self) {\n+        // Collect all the variances for a particular item and stick\n+        // them into the variance map. We rely on the fact that we\n+        // generate all the inferreds for a particular item\n+        // consecutively (that is, we collect solutions for an item\n+        // until we see a new item id, and we assume (1) the solutions\n+        // are in the same order as the type parameters were declared\n+        // and (2) all solutions or a given item appear before a new\n+        // item id).\n+\n+        let tcx = self.terms_cx.tcx;\n+\n+        // Ignore the writes here because the relevant edges were\n+        // already accounted for in `constraints.rs`. See the section\n+        // on dependency graph management in README.md for more\n+        // information.\n+        let _ignore = tcx.dep_graph.in_ignore();\n+\n+        let solutions = &self.solutions;\n+        let inferred_infos = &self.terms_cx.inferred_infos;\n+        let mut index = 0;\n+        let num_inferred = self.terms_cx.num_inferred();\n+        while index < num_inferred {\n+            let item_id = inferred_infos[index].item_id;\n+            let mut types = VecPerParamSpace::empty();\n+            let mut regions = VecPerParamSpace::empty();\n+\n+            while index < num_inferred && inferred_infos[index].item_id == item_id {\n+                let info = &inferred_infos[index];\n+                let variance = solutions[index];\n+                debug!(\"Index {} Info {} / {:?} / {:?} Variance {:?}\",\n+                       index, info.index, info.kind, info.space, variance);\n+                match info.kind {\n+                    TypeParam => { types.push(info.space, variance); }\n+                    RegionParam => { regions.push(info.space, variance); }\n+                }\n+\n+                index += 1;\n+            }\n+\n+            let item_variances = ty::ItemVariances {\n+                types: types,\n+                regions: regions\n+            };\n+            debug!(\"item_id={} item_variances={:?}\",\n+                    item_id,\n+                    item_variances);\n+\n+            let item_def_id = tcx.map.local_def_id(item_id);\n+\n+            // For unit testing: check for a special \"rustc_variance\"\n+            // attribute and report an error with various results if found.\n+            if tcx.has_attr(item_def_id, \"rustc_variance\") {\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n+            }\n+\n+            let newly_added = tcx.item_variance_map.borrow_mut()\n+                                 .insert(item_def_id, Rc::new(item_variances)).is_none();\n+            assert!(newly_added);\n+        }\n+    }\n+\n+    fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {\n+        match *term {\n+            ConstantTerm(v) => {\n+                v\n+            }\n+\n+            TransformTerm(t1, t2) => {\n+                let v1 = self.evaluate(t1);\n+                let v2 = self.evaluate(t2);\n+                v1.xform(v2)\n+            }\n+\n+            InferredTerm(InferredIndex(index)) => {\n+                self.solutions[index]\n+            }\n+        }\n+    }\n+}"}, {"sha": "aa1e93c3d6b7d678c230478d858638fe0475a6f5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -0,0 +1,287 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Representing terms\n+//\n+// Terms are structured as a straightforward tree. Rather than rely on\n+// GC, we allocate terms out of a bounded arena (the lifetime of this\n+// arena is the lifetime 'a that is threaded around).\n+//\n+// We assign a unique index to each type/region parameter whose variance\n+// is to be inferred. We refer to such variables as \"inferreds\". An\n+// `InferredIndex` is a newtype'd int representing the index of such\n+// a variable.\n+\n+use arena::TypedArena;\n+use dep_graph::DepTrackingMapConfig;\n+use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n+use middle::ty;\n+use middle::ty::maps::ItemVariances;\n+use std::fmt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use util::nodemap::NodeMap;\n+\n+use self::VarianceTerm::*;\n+use self::ParamKind::*;\n+\n+pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct InferredIndex(pub usize);\n+\n+#[derive(Copy, Clone)]\n+pub enum VarianceTerm<'a> {\n+    ConstantTerm(ty::Variance),\n+    TransformTerm(VarianceTermPtr<'a>, VarianceTermPtr<'a>),\n+    InferredTerm(InferredIndex),\n+}\n+\n+impl<'a> fmt::Debug for VarianceTerm<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n+            TransformTerm(v1, v2) => write!(f, \"({:?} \\u{00D7} {:?})\", v1, v2),\n+            InferredTerm(id) => write!(f, \"[{}]\", { let InferredIndex(i) = id; i })\n+        }\n+    }\n+}\n+\n+// The first pass over the crate simply builds up the set of inferreds.\n+\n+pub struct TermsContext<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n+    pub arena: &'a TypedArena<VarianceTerm<'a>>,\n+\n+    pub empty_variances: Rc<ty::ItemVariances>,\n+\n+    // For marker types, UnsafeCell, and other lang items where\n+    // variance is hardcoded, records the item-id and the hardcoded\n+    // variance.\n+    pub lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n+\n+    // Maps from the node id of a type/generic parameter to the\n+    // corresponding inferred index.\n+    pub inferred_map: NodeMap<InferredIndex>,\n+\n+    // Maps from an InferredIndex to the info for that variable.\n+    pub inferred_infos: Vec<InferredInfo<'a>> ,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum ParamKind {\n+    TypeParam,\n+    RegionParam,\n+}\n+\n+pub struct InferredInfo<'a> {\n+    pub item_id: ast::NodeId,\n+    pub kind: ParamKind,\n+    pub space: ParamSpace,\n+    pub index: usize,\n+    pub param_id: ast::NodeId,\n+    pub term: VarianceTermPtr<'a>,\n+\n+    // Initial value to use for this parameter when inferring\n+    // variance. For most parameters, this is Bivariant. But for lang\n+    // items and input type parameters on traits, it is different.\n+    pub initial_variance: ty::Variance,\n+}\n+\n+pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n+    tcx: &'a ty::ctxt<'tcx>,\n+    arena: &'a mut TypedArena<VarianceTerm<'a>>)\n+    -> TermsContext<'a, 'tcx>\n+{\n+    let mut terms_cx = TermsContext {\n+        tcx: tcx,\n+        arena: arena,\n+        inferred_map: NodeMap(),\n+        inferred_infos: Vec::new(),\n+\n+        lang_items: lang_items(tcx),\n+\n+        // cache and share the variance struct used for items with\n+        // no type/region parameters\n+        empty_variances: Rc::new(ty::ItemVariances {\n+            types: VecPerParamSpace::empty(),\n+            regions: VecPerParamSpace::empty()\n+        })\n+    };\n+\n+    // See README.md for a discussion on dep-graph management.\n+    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n+                                 &mut terms_cx);\n+\n+    terms_cx\n+}\n+\n+fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n+    let all = vec![\n+        (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n+        (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n+\n+        // Deprecated:\n+        (tcx.lang_items.covariant_type(), vec![ty::Covariant]),\n+        (tcx.lang_items.contravariant_type(), vec![ty::Contravariant]),\n+        (tcx.lang_items.invariant_type(), vec![ty::Invariant]),\n+        (tcx.lang_items.covariant_lifetime(), vec![ty::Covariant]),\n+        (tcx.lang_items.contravariant_lifetime(), vec![ty::Contravariant]),\n+        (tcx.lang_items.invariant_lifetime(), vec![ty::Invariant]),\n+\n+        ];\n+\n+    all.into_iter() // iterating over (Option<DefId>, Variance)\n+       .filter(|&(ref d,_)| d.is_some())\n+       .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n+       .filter_map(|(d, v)| tcx.map.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n+       .collect()\n+}\n+\n+impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n+    fn add_inferreds_for_item(&mut self,\n+                              item_id: ast::NodeId,\n+                              has_self: bool,\n+                              generics: &hir::Generics)\n+    {\n+        /*!\n+         * Add \"inferreds\" for the generic parameters declared on this\n+         * item. This has a lot of annoying parameters because we are\n+         * trying to drive this from the AST, rather than the\n+         * ty::Generics, so that we can get span info -- but this\n+         * means we must accommodate syntactic distinctions.\n+         */\n+\n+        // NB: In the code below for writing the results back into the\n+        // tcx, we rely on the fact that all inferreds for a particular\n+        // item are assigned continuous indices.\n+\n+        let inferreds_on_entry = self.num_inferred();\n+\n+        if has_self {\n+            self.add_inferred(item_id, TypeParam, SelfSpace, 0, item_id);\n+        }\n+\n+        for (i, p) in generics.lifetimes.iter().enumerate() {\n+            let id = p.lifetime.id;\n+            self.add_inferred(item_id, RegionParam, TypeSpace, i, id);\n+        }\n+\n+        for (i, p) in generics.ty_params.iter().enumerate() {\n+            self.add_inferred(item_id, TypeParam, TypeSpace, i, p.id);\n+        }\n+\n+        // If this item has no type or lifetime parameters,\n+        // then there are no variances to infer, so just\n+        // insert an empty entry into the variance map.\n+        // Arguably we could just leave the map empty in this\n+        // case but it seems cleaner to be able to distinguish\n+        // \"invalid item id\" from \"item id with no\n+        // parameters\".\n+        if self.num_inferred() == inferreds_on_entry {\n+            let item_def_id = self.tcx.map.local_def_id(item_id);\n+            let newly_added =\n+                self.tcx.item_variance_map.borrow_mut().insert(\n+                    item_def_id,\n+                    self.empty_variances.clone()).is_none();\n+            assert!(newly_added);\n+        }\n+    }\n+\n+    fn add_inferred(&mut self,\n+                    item_id: ast::NodeId,\n+                    kind: ParamKind,\n+                    space: ParamSpace,\n+                    index: usize,\n+                    param_id: ast::NodeId) {\n+        let inf_index = InferredIndex(self.inferred_infos.len());\n+        let term = self.arena.alloc(InferredTerm(inf_index));\n+        let initial_variance = self.pick_initial_variance(item_id, space, index);\n+        self.inferred_infos.push(InferredInfo { item_id: item_id,\n+                                                kind: kind,\n+                                                space: space,\n+                                                index: index,\n+                                                param_id: param_id,\n+                                                term: term,\n+                                                initial_variance: initial_variance });\n+        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n+        assert!(newly_added);\n+\n+        debug!(\"add_inferred(item_path={}, \\\n+                item_id={}, \\\n+                kind={:?}, \\\n+                space={:?}, \\\n+                index={}, \\\n+                param_id={}, \\\n+                inf_index={:?}, \\\n+                initial_variance={:?})\",\n+               self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n+               item_id, kind, space, index, param_id, inf_index,\n+               initial_variance);\n+    }\n+\n+    fn pick_initial_variance(&self,\n+                             item_id: ast::NodeId,\n+                             space: ParamSpace,\n+                             index: usize)\n+                             -> ty::Variance\n+    {\n+        match space {\n+            SelfSpace | FnSpace => {\n+                ty::Bivariant\n+            }\n+\n+            TypeSpace => {\n+                match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n+                    Some(&(_, ref variances)) => variances[index],\n+                    None => ty::Bivariant\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn num_inferred(&self) -> usize {\n+        self.inferred_infos.len()\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        debug!(\"add_inferreds for item {}\", self.tcx.map.node_to_string(item.id));\n+\n+        match item.node {\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemStruct(_, ref generics) => {\n+                self.add_inferreds_for_item(item.id, false, generics);\n+            }\n+            hir::ItemTrait(_, ref generics, _, _) => {\n+                // Note: all inputs for traits are ultimately\n+                // constrained to be invariant. See `visit_item` in\n+                // the impl for `ConstraintContext` in `constraints.rs`.\n+                self.add_inferreds_for_item(item.id, true, generics);\n+            }\n+\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(_) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemImpl(..) |\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) |\n+            hir::ItemFn(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemTy(..) => {\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "2749dce5c73f44ab9f373c2c90953061106dc218", "filename": "src/librustc_typeck/variance/xform.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+\n+pub trait Xform {\n+    fn xform(self, v: Self) -> Self;\n+}\n+\n+impl Xform for ty::Variance {\n+    fn xform(self, v: ty::Variance) -> ty::Variance {\n+        // \"Variance transformation\", Figure 1 of The Paper\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (ty::Covariant, ty::Covariant) => ty::Covariant,\n+            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n+            (ty::Covariant, ty::Invariant) => ty::Invariant,\n+            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n+            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n+            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n+            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (ty::Invariant, _) => ty::Invariant,\n+\n+            // Figure 1, column 4.\n+            (ty::Bivariant, _) => ty::Bivariant,\n+        }\n+    }\n+}\n+\n+pub fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n+    // Greatest lower bound of the variance lattice as\n+    // defined in The Paper:\n+    //\n+    //       *\n+    //    -     +\n+    //       o\n+    match (v1, v2) {\n+        (ty::Invariant, _) | (_, ty::Invariant) => ty::Invariant,\n+\n+        (ty::Covariant, ty::Contravariant) => ty::Invariant,\n+        (ty::Contravariant, ty::Covariant) => ty::Invariant,\n+\n+        (ty::Covariant, ty::Covariant) => ty::Covariant,\n+\n+        (ty::Contravariant, ty::Contravariant) => ty::Contravariant,\n+\n+        (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n+    }\n+}"}, {"sha": "c16998cd33c644cfdc15d4eaef027359eb5ef2d7", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e2a577804b32b6d203abe61e0cdf3a88837d228/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=8e2a577804b32b6d203abe61e0cdf3a88837d228", "patch": "@@ -74,23 +74,17 @@ mod signatures {\n     fn indirect(x: WillChanges) { }\n }\n \n-// these are invalid dependencies, though sometimes we create edges\n-// anyway.\n mod invalid_signatures {\n     use WontChange;\n \n-    // FIXME due to the variance pass having overly conservative edges,\n-    // we incorrectly think changes are needed here\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path\n     trait A {\n         fn do_something_else_twice(x: WontChange);\n     }\n \n-    // FIXME due to the variance pass having overly conservative edges,\n-    // we incorrectly think changes are needed here\n-    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n-    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path\n     fn b(x: WontChange) { }\n \n     #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path from `WillChange`"}]}