{"sha": "a51a20531d7ff532486ff73abb9ad548618481ab", "node_id": "C_kwDOAAsO6NoAKGE1MWEyMDUzMWQ3ZmY1MzI0ODZmZjczYWJiOWFkNTQ4NjE4NDgxYWI", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-02-08T18:53:48Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-02-16T13:54:53Z"}, "message": "Factor query arena allocation out from query caches", "tree": {"sha": "1b6f6aded903dc2e8cfdd6905efbc60ea9d8e7c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b6f6aded903dc2e8cfdd6905efbc60ea9d8e7c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a51a20531d7ff532486ff73abb9ad548618481ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a51a20531d7ff532486ff73abb9ad548618481ab", "html_url": "https://github.com/rust-lang/rust/commit/a51a20531d7ff532486ff73abb9ad548618481ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a51a20531d7ff532486ff73abb9ad548618481ab/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "html_url": "https://github.com/rust-lang/rust/commit/4b34c7b766a3d64d3f2a9bff06d0e53648a11013"}], "stats": {"total": 412, "additions": 159, "deletions": 253}, "files": [{"sha": "0eff576c926404b42bbc0f52fe5066e5b1f9c338", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -676,9 +676,7 @@ pub fn create_global_ctxt<'tcx>(\n         callback(sess, &mut local_providers, &mut extern_providers);\n     }\n \n-    let queries = queries.get_or_init(|| {\n-        TcxQueries::new(local_providers, extern_providers, query_result_on_disk_cache)\n-    });\n+    let queries = queries.get_or_init(|| TcxQueries::new(query_result_on_disk_cache));\n \n     sess.time(\"setup_global_ctxt\", || {\n         gcx_cell.get_or_init(move || {\n@@ -690,6 +688,8 @@ pub fn create_global_ctxt<'tcx>(\n                 untracked,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n+                local_providers,\n+                extern_providers,\n                 queries.as_dyn(),\n                 rustc_query_impl::query_callbacks(arena),\n             )"}, {"sha": "0bacf51e9119a9daa449faeaf5a34146b7a591db", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -114,7 +114,7 @@ macro_rules! provide_one {\n         fn $name<'tcx>(\n             $tcx: TyCtxt<'tcx>,\n             def_id_arg: ty::query::query_keys::$name<'tcx>,\n-        ) -> ty::query::query_values::$name<'tcx> {\n+        ) -> ty::query::query_provided::$name<'tcx> {\n             let _prof_timer =\n                 $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n "}, {"sha": "e334d3395f5acbbc248c50e37c24fda89776757f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -18,6 +18,8 @@ use crate::mir::{\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use crate::ty::query::ExternProviders;\n+use crate::ty::query::Providers;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, DefIdTree, FloatTy, FloatVar,\n@@ -479,7 +481,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n-    pub query_caches: query::QueryCaches<'tcx>,\n+    pub query_system: query::QuerySystem<'tcx>,\n     pub(crate) query_kinds: &'tcx [DepKindStruct<'tcx>],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n@@ -639,6 +641,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         untracked: Untracked,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n+        local_providers: Providers,\n+        extern_providers: ExternProviders,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n         query_kinds: &'tcx [DepKindStruct<'tcx>],\n     ) -> GlobalCtxt<'tcx> {\n@@ -664,7 +668,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             untracked,\n             on_disk_cache,\n             queries,\n-            query_caches: query::QueryCaches::default(),\n+            query_system: query::QuerySystem::new(local_providers, extern_providers),\n             query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),"}, {"sha": "73e4a39681e7f7840e0a1660f8aafbb543c6a794", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 76, "deletions": 20, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -1,3 +1,5 @@\n+#![allow(unused_parens)]\n+\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintExpectation;\n@@ -34,13 +36,15 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, UnusedGenericParams};\n+use rustc_arena::TypedArena;\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::WorkerLocal;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -66,6 +70,24 @@ use std::sync::Arc;\n pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n \n+pub struct QuerySystem<'tcx> {\n+    pub local_providers: Box<Providers>,\n+    pub extern_providers: Box<ExternProviders>,\n+    pub arenas: QueryArenas<'tcx>,\n+    pub caches: QueryCaches<'tcx>,\n+}\n+\n+impl<'tcx> QuerySystem<'tcx> {\n+    pub fn new(local_providers: Providers, extern_providers: ExternProviders) -> Self {\n+        QuerySystem {\n+            local_providers: Box::new(local_providers),\n+            extern_providers: Box::new(extern_providers),\n+            arenas: Default::default(),\n+            caches: Default::default(),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TyCtxtAt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n@@ -112,10 +134,10 @@ macro_rules! query_helper_param_ty {\n }\n \n macro_rules! query_if_arena {\n-    ([] $arena:ty, $no_arena:ty) => {\n+    ([] $arena:tt $no_arena:tt) => {\n         $no_arena\n     };\n-    ([(arena_cache) $($rest:tt)*] $arena:ty, $no_arena:ty) => {\n+    ([(arena_cache) $($rest:tt)*] $arena:tt $no_arena:tt) => {\n         $arena\n     };\n     ([$other:tt $($modifiers:tt)*]$($args:tt)*) => {\n@@ -131,7 +153,7 @@ macro_rules! separate_provide_extern_decl {\n         for<'tcx> fn(\n             TyCtxt<'tcx>,\n             query_keys::$name<'tcx>,\n-        ) -> query_values::$name<'tcx>\n+        ) -> query_provided::$name<'tcx>\n     };\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n         separate_provide_extern_decl!([$($modifiers)*][$($args)*])\n@@ -183,30 +205,62 @@ macro_rules! define_callbacks {\n \n             $(pub type $name<'tcx> = $($K)*;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n+        #[allow(nonstandard_style, unused_lifetimes)]\n         pub mod query_values {\n             use super::*;\n \n-            $(pub type $name<'tcx> = query_if_arena!([$($modifiers)*] <$V as Deref>::Target, $V);)*\n+            $(pub type $name<'tcx> = $V;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n-        pub mod query_storage {\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_provided {\n             use super::*;\n \n             $(\n-                pub type $name<'tcx> = query_if_arena!([$($modifiers)*]\n-                    <<$($K)* as Key>::CacheSelector\n-                        as CacheSelector<'tcx, <$V as Deref>::Target>>::ArenaCache,\n-                    <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n-                );\n+                pub type $name<'tcx> = query_if_arena!([$($modifiers)*] (<$V as Deref>::Target) ($V));\n             )*\n         }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_provided_to_value {\n+            use super::*;\n \n+            $(\n+                #[inline]\n+                pub fn $name<'tcx>(\n+                    _tcx: TyCtxt<'tcx>,\n+                    value: query_provided::$name<'tcx>,\n+                ) -> query_values::$name<'tcx> {\n+                    query_if_arena!([$($modifiers)*]\n+                        (&*_tcx.query_system.arenas.$name.alloc(value))\n+                        (value)\n+                    )\n+                }\n+            )*\n+        }\n         #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_stored {\n+        pub mod query_storage {\n             use super::*;\n \n-            $(pub type $name<'tcx> = $V;)*\n+            $(\n+                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache;\n+            )*\n+        }\n+\n+        pub struct QueryArenas<'tcx> {\n+            $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]\n+                (WorkerLocal<TypedArena<<$V as Deref>::Target>>)\n+                ()\n+            ),)*\n+        }\n+\n+        impl Default for QueryArenas<'_> {\n+            fn default() -> Self {\n+                Self {\n+                    $($name: query_if_arena!([$($modifiers)*]\n+                        (WorkerLocal::new(|_| Default::default()))\n+                        ()\n+                    ),)*\n+                }\n+            }\n         }\n \n         #[derive(Default)]\n@@ -221,7 +275,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n                     None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n                 };\n@@ -246,7 +300,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(value) => value,\n                     None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n                 }\n@@ -257,7 +311,7 @@ macro_rules! define_callbacks {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n                 query_keys::$name<'tcx>,\n-            ) -> query_values::$name<'tcx>,)*\n+            ) -> query_provided::$name<'tcx>,)*\n         }\n \n         pub struct ExternProviders {\n@@ -334,12 +388,13 @@ macro_rules! define_feedable {\n         $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n             $(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, value: query_values::$name<'tcx>) -> $V {\n+            pub fn $name(self, value: query_provided::$name<'tcx>) -> $V {\n                 let key = self.key().into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n                 let tcx = self.tcx;\n-                let cache = &tcx.query_caches.$name;\n+                let value = query_provided_to_value::$name(tcx, value);\n+                let cache = &tcx.query_system.caches.$name;\n \n                 match try_get_cached(tcx, cache, &key) {\n                     Some(old) => {\n@@ -357,7 +412,8 @@ macro_rules! define_feedable {\n                             &value,\n                             hash_result!([$($modifiers)*]),\n                         );\n-                        cache.complete(key, value, dep_node_index)\n+                        cache.complete(key, value, dep_node_index);\n+                        value\n                     }\n                 }\n             }"}, {"sha": "372f2c69c7813bc133ed6c7d09f890221a50a348", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -21,8 +21,10 @@ use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::query::Key;\n-use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n-use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n+use rustc_middle::ty::query::QueryEngine;\n+use rustc_middle::ty::query::{\n+    query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n+};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n "}, {"sha": "318077e75c4fa5bb2d10ac7d7eae8e6b091a6019", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -278,13 +278,13 @@ macro_rules! hash_result {\n \n macro_rules! get_provider {\n     ([][$tcx:expr, $name:ident, $key:expr]) => {{\n-        $tcx.queries.local_providers.$name\n+        $tcx.query_system.local_providers.$name\n     }};\n     ([(separate_provide_extern) $($rest:tt)*][$tcx:expr, $name:ident, $key:expr]) => {{\n         if $key.query_crate_is_local() {\n-            $tcx.queries.local_providers.$name\n+            $tcx.query_system.local_providers.$name\n         } else {\n-            $tcx.queries.extern_providers.$name\n+            $tcx.query_system.extern_providers.$name\n         }\n     }};\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n@@ -293,14 +293,14 @@ macro_rules! get_provider {\n }\n \n macro_rules! should_ever_cache_on_disk {\n-    ([]) => {{\n-        None\n+    ([]$yes:tt $no:tt) => {{\n+        $no\n     }};\n-    ([(cache) $($rest:tt)*]) => {{\n-        Some($crate::plumbing::try_load_from_disk::<Self::Value>)\n+    ([(cache) $($rest:tt)*]$yes:tt $no:tt) => {{\n+        $yes\n     }};\n-    ([$other:tt $($modifiers:tt)*]) => {\n-        should_ever_cache_on_disk!([$($modifiers)*])\n+    ([$other:tt $($modifiers:tt)*]$yes:tt $no:tt) => {\n+        should_ever_cache_on_disk!([$($modifiers)*]$yes $no)\n     };\n }\n \n@@ -472,7 +472,6 @@ macro_rules! define_queries {\n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n             type Value = query_values::$name<'tcx>;\n-            type Stored = query_stored::$name<'tcx>;\n             const NAME: &'static str = stringify!($name);\n \n             #[inline]\n@@ -493,24 +492,40 @@ macro_rules! define_queries {\n             fn query_cache<'a>(tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n                 where 'tcx:'a\n             {\n-                &tcx.query_caches.$name\n+                &tcx.query_system.caches.$name\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Stored {\n+            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 tcx.$name(key)\n             }\n \n             #[inline]\n             // key is only sometimes used\n             #[allow(unused_variables)]\n-            fn compute(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> fn(TyCtxt<'tcx>, Self::Key) -> Self::Value {\n-                get_provider!([$($modifiers)*][qcx, $name, key])\n+            fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+                query_provided_to_value::$name(\n+                    tcx,\n+                    get_provider!([$($modifiers)*][tcx, $name, key])(tcx, key)\n+                )\n             }\n \n             #[inline]\n-            fn try_load_from_disk(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n-                let cache_on_disk = Self::cache_on_disk(qcx.tcx, key);\n-                if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None }\n+            fn try_load_from_disk(_qcx: QueryCtxt<'tcx>, _key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+                should_ever_cache_on_disk!([$($modifiers)*] {\n+                    if Self::cache_on_disk(_qcx.tcx, _key) {\n+                        Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n+                            let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n+                                qcx,\n+                                dep_node\n+                            );\n+                            value.map(|value| query_provided_to_value::$name(qcx.tcx, value))\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                } {\n+                    None\n+                })\n             }\n \n             const ANON: bool = is_anon!([$($modifiers)*]);\n@@ -633,7 +648,7 @@ macro_rules! define_queries {\n                     $crate::profiling_support::alloc_self_profile_query_strings_for_query_cache(\n                         tcx,\n                         stringify!($name),\n-                        &tcx.query_caches.$name,\n+                        &tcx.query_system.caches.$name,\n                         string_cache,\n                     )\n                 },\n@@ -649,18 +664,12 @@ macro_rules! define_queries {\n     }\n }\n \n-use crate::{ExternProviders, OnDiskCache, Providers};\n+use crate::OnDiskCache;\n \n impl<'tcx> Queries<'tcx> {\n-    pub fn new(\n-        local_providers: Providers,\n-        extern_providers: ExternProviders,\n-        on_disk_cache: Option<OnDiskCache<'tcx>>,\n-    ) -> Self {\n+    pub fn new(on_disk_cache: Option<OnDiskCache<'tcx>>) -> Self {\n         use crate::query_structs;\n         Queries {\n-            local_providers: Box::new(local_providers),\n-            extern_providers: Box::new(extern_providers),\n             query_structs: make_dep_kind_array!(query_structs).to_vec(),\n             on_disk_cache,\n             jobs: AtomicU64::new(1),\n@@ -674,8 +683,6 @@ macro_rules! define_queries_struct {\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         #[derive(Default)]\n         pub struct Queries<'tcx> {\n-            local_providers: Box<Providers>,\n-            extern_providers: Box<ExternProviders>,\n             query_structs: Vec<$crate::plumbing::QueryStruct<'tcx>>,\n             pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n             jobs: AtomicU64,\n@@ -725,7 +732,7 @@ macro_rules! define_queries_struct {\n                 span: Span,\n                 key: <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n                 mode: QueryMode,\n-            ) -> Option<query_stored::$name<'tcx>> {\n+            ) -> Option<query_values::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n             })*"}, {"sha": "e840108bdd86925979115f3a2a11a098dd4a9ef4", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 6, "deletions": 165, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -1,12 +1,10 @@\n use crate::dep_graph::DepNodeIndex;\n \n-use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::vec::{Idx, IndexVec};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -16,12 +14,10 @@ pub trait CacheSelector<'tcx, V> {\n     type Cache\n     where\n         V: Copy;\n-    type ArenaCache;\n }\n \n pub trait QueryStorage {\n-    type Value: Debug;\n-    type Stored: Copy;\n+    type Value: Copy;\n }\n \n pub trait QueryCache: QueryStorage + Sized {\n@@ -31,9 +27,9 @@ pub trait QueryCache: QueryStorage + Sized {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup(&self, key: &Self::Key) -> Option<(Self::Stored, DepNodeIndex)>;\n+    fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n \n-    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex) -> Self::Stored;\n+    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex);\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex));\n }\n@@ -44,7 +40,6 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<'tcx, V> for DefaultCacheSelecto\n     type Cache = DefaultCache<K, V>\n     where\n         V: Copy;\n-    type ArenaCache = ArenaCache<'tcx, K, V>;\n }\n \n pub struct DefaultCache<K, V> {\n@@ -62,7 +57,6 @@ impl<K, V> Default for DefaultCache<K, V> {\n \n impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<K, V> QueryCache for DefaultCache<K, V>\n@@ -85,15 +79,14 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) {\n         #[cfg(parallel_compiler)]\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n         // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, (value, index));\n-        value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n@@ -122,7 +115,6 @@ impl<'tcx, V: 'tcx> CacheSelector<'tcx, V> for SingleCacheSelector {\n     type Cache = SingleCache<V>\n     where\n         V: Copy;\n-    type ArenaCache = ArenaCache<'tcx, (), V>;\n }\n \n pub struct SingleCache<V> {\n@@ -137,7 +129,6 @@ impl<V> Default for SingleCache<V> {\n \n impl<V: Copy + Debug> QueryStorage for SingleCache<V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<V> QueryCache for SingleCache<V>\n@@ -152,95 +143,21 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, _key: (), value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, _key: (), value: V, index: DepNodeIndex) {\n         *self.cache.lock() = Some((value, index));\n-        value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n         self.cache.lock().as_ref().map(|value| f(&(), &value.0, value.1));\n     }\n }\n \n-pub struct ArenaCache<'tcx, K, V> {\n-    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    #[cfg(parallel_compiler)]\n-    cache: Sharded<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n-    #[cfg(not(parallel_compiler))]\n-    cache: Lock<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n-}\n-\n-impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n-    fn default() -> Self {\n-        ArenaCache { arena: WorkerLocal::new(|_| TypedArena::default()), cache: Default::default() }\n-    }\n-}\n-\n-impl<'tcx, K: Eq + Hash, V: Debug + 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n-    type Value = V;\n-    type Stored = &'tcx V;\n-}\n-\n-impl<'tcx, K, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V>\n-where\n-    K: Eq + Hash + Clone + Debug,\n-    V: Debug,\n-{\n-    type Key = K;\n-\n-    #[inline(always)]\n-    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n-        let key_hash = sharded::make_hash(key);\n-        #[cfg(parallel_compiler)]\n-        let lock = self.cache.get_shard_by_hash(key_hash).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let lock = self.cache.lock();\n-        let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n-\n-        if let Some((_, value)) = result { Some((&value.0, value.1)) } else { None }\n-    }\n-\n-    #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        let value = self.arena.alloc((value, index));\n-        let value = unsafe { &*(value as *const _) };\n-        #[cfg(parallel_compiler)]\n-        let mut lock = self.cache.get_shard_by_value(&key).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut lock = self.cache.lock();\n-        // We may be overwriting another value. This is all right, since the dep-graph\n-        // will check that the fingerprint matches.\n-        lock.insert(key, value);\n-        &value.0\n-    }\n-\n-    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        #[cfg(parallel_compiler)]\n-        {\n-            let shards = self.cache.lock_shards();\n-            for shard in shards.iter() {\n-                for (k, v) in shard.iter() {\n-                    f(k, &v.0, v.1);\n-                }\n-            }\n-        }\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let map = self.cache.lock();\n-            for (k, v) in map.iter() {\n-                f(k, &v.0, v.1);\n-            }\n-        }\n-    }\n-}\n-\n pub struct VecCacheSelector<K>(PhantomData<K>);\n \n impl<'tcx, K: Idx, V: 'tcx> CacheSelector<'tcx, V> for VecCacheSelector<K> {\n     type Cache = VecCache<K, V>\n     where\n         V: Copy;\n-    type ArenaCache = VecArenaCache<'tcx, K, V>;\n }\n \n pub struct VecCache<K: Idx, V> {\n@@ -258,7 +175,6 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n \n impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<K, V> QueryCache for VecCache<K, V>\n@@ -278,87 +194,12 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) {\n         #[cfg(parallel_compiler)]\n         let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n         lock.insert(key, (value, index));\n-        value\n-    }\n-\n-    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        #[cfg(parallel_compiler)]\n-        {\n-            let shards = self.cache.lock_shards();\n-            for shard in shards.iter() {\n-                for (k, v) in shard.iter_enumerated() {\n-                    if let Some(v) = v {\n-                        f(&k, &v.0, v.1);\n-                    }\n-                }\n-            }\n-        }\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let map = self.cache.lock();\n-            for (k, v) in map.iter_enumerated() {\n-                if let Some(v) = v {\n-                    f(&k, &v.0, v.1);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub struct VecArenaCache<'tcx, K: Idx, V> {\n-    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    #[cfg(parallel_compiler)]\n-    cache: Sharded<IndexVec<K, Option<&'tcx (V, DepNodeIndex)>>>,\n-    #[cfg(not(parallel_compiler))]\n-    cache: Lock<IndexVec<K, Option<&'tcx (V, DepNodeIndex)>>>,\n-}\n-\n-impl<'tcx, K: Idx, V> Default for VecArenaCache<'tcx, K, V> {\n-    fn default() -> Self {\n-        VecArenaCache {\n-            arena: WorkerLocal::new(|_| TypedArena::default()),\n-            cache: Default::default(),\n-        }\n-    }\n-}\n-\n-impl<'tcx, K: Eq + Idx, V: Debug + 'tcx> QueryStorage for VecArenaCache<'tcx, K, V> {\n-    type Value = V;\n-    type Stored = &'tcx V;\n-}\n-\n-impl<'tcx, K, V: 'tcx> QueryCache for VecArenaCache<'tcx, K, V>\n-where\n-    K: Eq + Idx + Clone + Debug,\n-    V: Debug,\n-{\n-    type Key = K;\n-\n-    #[inline(always)]\n-    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n-        #[cfg(parallel_compiler)]\n-        let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) { Some((&value.0, value.1)) } else { None }\n-    }\n-\n-    #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        let value = self.arena.alloc((value, index));\n-        let value = unsafe { &*(value as *const _) };\n-        #[cfg(parallel_compiler)]\n-        let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut lock = self.cache.lock();\n-        lock.insert(key, value);\n-        &value.0\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {"}, {"sha": "925102d4b1eadb81c399abe53a9305d1fdcae80a", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -20,10 +20,9 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n-    type Value: Debug;\n-    type Stored: Debug + Copy + std::borrow::Borrow<Self::Value>;\n+    type Value: Debug + Copy;\n \n-    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n+    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n@@ -38,9 +37,9 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n+    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n \n-    fn compute(tcx: Qcx, key: &Self::Key) -> fn(Qcx::DepContext, Self::Key) -> Self::Value;\n+    fn compute(tcx: Qcx::DepContext, key: Self::Key) -> Self::Value;\n \n     fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n "}, {"sha": "44e74844fde90184a719f2bad391e46e2df8ec33", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51a20531d7ff532486ff73abb9ad548618481ab/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=a51a20531d7ff532486ff73abb9ad548618481ab", "patch": "@@ -246,7 +246,7 @@ where\n \n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n-    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored\n+    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex)\n     where\n         C: QueryCache<Key = K>,\n     {\n@@ -257,23 +257,22 @@ where\n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let (job, result) = {\n-            let job = {\n-                #[cfg(parallel_compiler)]\n-                let mut lock = state.active.get_shard_by_value(&key).lock();\n-                #[cfg(not(parallel_compiler))]\n-                let mut lock = state.active.lock();\n-                match lock.remove(&key).unwrap() {\n-                    QueryResult::Started(job) => job,\n-                    QueryResult::Poisoned => panic!(),\n-                }\n-            };\n-            let result = cache.complete(key, result, dep_node_index);\n-            (job, result)\n+        // Mark as complete before we remove the job from the active state\n+        // so no other thread can re-execute this query.\n+        cache.complete(key.clone(), result, dep_node_index);\n+\n+        let job = {\n+            #[cfg(parallel_compiler)]\n+            let mut lock = state.active.get_shard_by_value(&key).lock();\n+            #[cfg(not(parallel_compiler))]\n+            let mut lock = state.active.lock();\n+            match lock.remove(&key).unwrap() {\n+                QueryResult::Started(job) => job,\n+                QueryResult::Poisoned => panic!(),\n+            }\n         };\n \n         job.signal_complete();\n-        result\n     }\n }\n \n@@ -336,7 +335,7 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Stored>\n+pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Value>\n where\n     C: QueryCache,\n     Tcx: DepContext,\n@@ -358,7 +357,7 @@ fn try_execute_query<Q, Qcx>(\n     span: Span,\n     key: Q::Key,\n     dep_node: Option<DepNode<Qcx::DepKind>>,\n-) -> (Q::Stored, Option<DepNodeIndex>)\n+) -> (Q::Value, Option<DepNodeIndex>)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n@@ -390,7 +389,7 @@ where\n                     );\n                 }\n             }\n-            let result = job.complete(cache, result, dep_node_index);\n+            job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n@@ -426,9 +425,8 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || {\n-            Q::compute(qcx, &key)(*qcx.dep_context(), key)\n-        });\n+        let result =\n+            qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || Q::compute(*qcx.dep_context(), key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n@@ -455,16 +453,15 @@ where\n         qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n             if Q::ANON {\n                 return dep_graph.with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || {\n-                    Q::compute(qcx, &key)(*qcx.dep_context(), key)\n+                    Q::compute(*qcx.dep_context(), key)\n                 });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n                 dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n-            let task = Q::compute(qcx, &key);\n-            dep_graph.with_task(dep_node, *qcx.dep_context(), key, task, Q::HASH_RESULT)\n+            dep_graph.with_task(dep_node, *qcx.dep_context(), key, Q::compute, Q::HASH_RESULT)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -555,7 +552,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| Q::compute(qcx, key)(*qcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| Q::compute(*qcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -727,7 +724,7 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Value>\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,"}]}