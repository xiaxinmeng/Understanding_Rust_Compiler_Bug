{"sha": "3b4589a30914fbaf9bc0f1115dc7437523b1465b", "node_id": "C_kwDOAAsO6NoAKDNiNDU4OWEzMDkxNGZiYWY5YmMwZjExMTVkYzc0Mzc1MjNiMTQ2NWI", "commit": {"author": {"name": "Oliver Downard", "email": "odownard.trade@gmail.com", "date": "2022-04-08T18:10:07Z"}, "committer": {"name": "Oliver Downard", "email": "odownard.trade@gmail.com", "date": "2022-04-11T20:01:18Z"}, "message": "simplify const params diagnostic on stable", "tree": {"sha": "504e67d93fb15995b7074d7e86576876aa88cb32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/504e67d93fb15995b7074d7e86576876aa88cb32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b4589a30914fbaf9bc0f1115dc7437523b1465b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4589a30914fbaf9bc0f1115dc7437523b1465b", "html_url": "https://github.com/rust-lang/rust/commit/3b4589a30914fbaf9bc0f1115dc7437523b1465b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b4589a30914fbaf9bc0f1115dc7437523b1465b/comments", "author": {"login": "OliverMD", "id": 4549075, "node_id": "MDQ6VXNlcjQ1NDkwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4549075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/OliverMD", "html_url": "https://github.com/OliverMD", "followers_url": "https://api.github.com/users/OliverMD/followers", "following_url": "https://api.github.com/users/OliverMD/following{/other_user}", "gists_url": "https://api.github.com/users/OliverMD/gists{/gist_id}", "starred_url": "https://api.github.com/users/OliverMD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/OliverMD/subscriptions", "organizations_url": "https://api.github.com/users/OliverMD/orgs", "repos_url": "https://api.github.com/users/OliverMD/repos", "events_url": "https://api.github.com/users/OliverMD/events{/privacy}", "received_events_url": "https://api.github.com/users/OliverMD/received_events", "type": "User", "site_admin": false}, "committer": {"login": "OliverMD", "id": 4549075, "node_id": "MDQ6VXNlcjQ1NDkwNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4549075?v=4", "gravatar_id": "", "url": "https://api.github.com/users/OliverMD", "html_url": "https://github.com/OliverMD", "followers_url": "https://api.github.com/users/OliverMD/followers", "following_url": "https://api.github.com/users/OliverMD/following{/other_user}", "gists_url": "https://api.github.com/users/OliverMD/gists{/gist_id}", "starred_url": "https://api.github.com/users/OliverMD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/OliverMD/subscriptions", "organizations_url": "https://api.github.com/users/OliverMD/orgs", "repos_url": "https://api.github.com/users/OliverMD/repos", "events_url": "https://api.github.com/users/OliverMD/events{/privacy}", "received_events_url": "https://api.github.com/users/OliverMD/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd38eea722c1f6f970a314435533e91cc2c14ffb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd38eea722c1f6f970a314435533e91cc2c14ffb", "html_url": "https://github.com/rust-lang/rust/commit/dd38eea722c1f6f970a314435533e91cc2c14ffb"}], "stats": {"total": 176, "additions": 86, "deletions": 90}, "files": [{"sha": "f9664a9b99155b4802a3cc67e6f5dcb9e4e2c73e", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 82, "deletions": 70, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/3b4589a30914fbaf9bc0f1115dc7437523b1465b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4589a30914fbaf9bc0f1115dc7437523b1465b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3b4589a30914fbaf9bc0f1115dc7437523b1465b", "patch": "@@ -816,16 +816,69 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n         hir::GenericParamKind::Const { ty: hir_ty, default: _ } => {\n             let ty = tcx.type_of(tcx.hir().local_def_id(param.hir_id));\n \n-            let err_ty_str;\n-            let mut is_ptr = true;\n-            let err = if tcx.features().adt_const_params {\n-                match ty.peel_refs().kind() {\n+            if tcx.features().adt_const_params {\n+                let err = match ty.peel_refs().kind() {\n                     ty::FnPtr(_) => Some(\"function pointers\"),\n                     ty::RawPtr(_) => Some(\"raw pointers\"),\n                     _ => None,\n+                };\n+\n+                if let Some(unsupported_type) = err {\n+                    tcx.sess.span_err(\n+                        hir_ty.span,\n+                        &format!(\n+                            \"using {} as const generic parameters is forbidden\",\n+                            unsupported_type\n+                        ),\n+                    );\n+                }\n+\n+                if traits::search_for_structural_match_violation(param.span, tcx, ty).is_some() {\n+                    // We use the same error code in both branches, because this is really the same\n+                    // issue: we just special-case the message for type parameters to make it\n+                    // clearer.\n+                    if let ty::Param(_) = ty.peel_refs().kind() {\n+                        // Const parameters may not have type parameters as their types,\n+                        // because we cannot be sure that the type parameter derives `PartialEq`\n+                        // and `Eq` (just implementing them is not enough for `structural_match`).\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            hir_ty.span,\n+                            E0741,\n+                            \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n+                            used as the type of a const parameter\",\n+                            ty,\n+                        )\n+                        .span_label(\n+                            hir_ty.span,\n+                            format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n+                        )\n+                        .note(\n+                            \"it is not currently possible to use a type parameter as the type of a \\\n+                            const parameter\",\n+                        )\n+                        .emit();\n+                    } else {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            hir_ty.span,\n+                            E0741,\n+                            \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n+                            the type of a const parameter\",\n+                            ty,\n+                        )\n+                        .span_label(\n+                            hir_ty.span,\n+                            format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                        )\n+                        .emit();\n+                    }\n                 }\n             } else {\n-                match ty.kind() {\n+                let err_ty_str;\n+                let mut is_ptr = true;\n+\n+                let err = match ty.kind() {\n                     ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n                     ty::FnPtr(_) => Some(\"function pointers\"),\n                     ty::RawPtr(_) => Some(\"raw pointers\"),\n@@ -834,74 +887,33 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                         err_ty_str = format!(\"`{}`\", ty);\n                         Some(err_ty_str.as_str())\n                     }\n-                }\n-            };\n-            if let Some(unsupported_type) = err {\n-                if is_ptr {\n-                    tcx.sess.span_err(\n-                        hir_ty.span,\n-                        &format!(\n-                            \"using {} as const generic parameters is forbidden\",\n-                            unsupported_type\n-                        ),\n-                    );\n-                } else {\n-                    let mut err = tcx.sess.struct_span_err(\n-                        hir_ty.span,\n-                        &format!(\n-                            \"{} is forbidden as the type of a const generic parameter\",\n-                            unsupported_type\n-                        ),\n-                    );\n-                    err.note(\"the only supported types are integers, `bool` and `char`\");\n-                    if tcx.sess.is_nightly_build() {\n-                        err.help(\n+                };\n+\n+                if let Some(unsupported_type) = err {\n+                    if is_ptr {\n+                        tcx.sess.span_err(\n+                            hir_ty.span,\n+                            &format!(\n+                                \"using {} as const generic parameters is forbidden\",\n+                                unsupported_type\n+                            ),\n+                        );\n+                    } else {\n+                        let mut err = tcx.sess.struct_span_err(\n+                            hir_ty.span,\n+                            &format!(\n+                                \"{} is forbidden as the type of a const generic parameter\",\n+                                unsupported_type\n+                            ),\n+                        );\n+                        err.note(\"the only supported types are integers, `bool` and `char`\");\n+                        if tcx.sess.is_nightly_build() {\n+                            err.help(\n                             \"more complex types are supported with `#![feature(adt_const_params)]`\",\n                         );\n+                        }\n+                        err.emit();\n                     }\n-                    err.emit();\n-                }\n-            };\n-\n-            if traits::search_for_structural_match_violation(param.span, tcx, ty).is_some() {\n-                // We use the same error code in both branches, because this is really the same\n-                // issue: we just special-case the message for type parameters to make it\n-                // clearer.\n-                if let ty::Param(_) = ty.peel_refs().kind() {\n-                    // Const parameters may not have type parameters as their types,\n-                    // because we cannot be sure that the type parameter derives `PartialEq`\n-                    // and `Eq` (just implementing them is not enough for `structural_match`).\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        hir_ty.span,\n-                        E0741,\n-                        \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n-                            used as the type of a const parameter\",\n-                        ty,\n-                    )\n-                    .span_label(\n-                        hir_ty.span,\n-                        format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n-                    )\n-                    .note(\n-                        \"it is not currently possible to use a type parameter as the type of a \\\n-                            const parameter\",\n-                    )\n-                    .emit();\n-                } else {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        hir_ty.span,\n-                        E0741,\n-                        \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n-                            the type of a const parameter\",\n-                        ty,\n-                    )\n-                    .span_label(\n-                        hir_ty.span,\n-                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n-                    )\n-                    .emit();\n                 }\n             }\n         }"}, {"sha": "9f6c7ccf3fe746195c82ecc4ed743fb0a725d1c7", "filename": "src/test/ui/const-generics/issues/issue-63322-forbid-dyn.min.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.min.stderr?ref=3b4589a30914fbaf9bc0f1115dc7437523b1465b", "patch": "@@ -7,12 +7,5 @@ LL | fn test<const T: &'static dyn A>() {\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(adt_const_params)]`\n \n-error[E0741]: `&'static (dyn A + 'static)` must be annotated with `#[derive(PartialEq, Eq)]` to be used as the type of a const parameter\n-  --> $DIR/issue-63322-forbid-dyn.rs:9:18\n-   |\n-LL | fn test<const T: &'static dyn A>() {\n-   |                  ^^^^^^^^^^^^^^ `&'static (dyn A + 'static)` doesn't derive both `PartialEq` and `Eq`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0741`."}, {"sha": "116c3fcfb2170626b739db135aed4b094bd4d7d3", "filename": "src/test/ui/const-generics/issues/issue-63322-forbid-dyn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.rs?ref=3b4589a30914fbaf9bc0f1115dc7437523b1465b", "patch": "@@ -7,7 +7,7 @@ struct B;\n impl A for B {}\n \n fn test<const T: &'static dyn A>() {\n-    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]` to be used\n+    //[full]~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]` to be used\n     //[min]~^^ ERROR `&'static (dyn A + 'static)` is forbidden\n     unimplemented!()\n }"}, {"sha": "276ebf31ff8b88012faa61c24f8554150c0efbce", "filename": "src/test/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=3b4589a30914fbaf9bc0f1115dc7437523b1465b", "patch": "@@ -14,14 +14,5 @@ LL | | }]>;\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(adt_const_params)]`\n \n-error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17_usize>::value` in constants\n-  --> $DIR/nested-type.rs:15:5\n-   |\n-LL |     Foo::<17>::value()\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0015`."}, {"sha": "742340f430e2b74f8f4714921a04e5610d7d7fee", "filename": "src/test/ui/const-generics/nested-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4589a30914fbaf9bc0f1115dc7437523b1465b/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs?ref=3b4589a30914fbaf9bc0f1115dc7437523b1465b", "patch": "@@ -13,7 +13,7 @@ struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n     }\n \n     Foo::<17>::value()\n-    //~^ ERROR cannot call non-const fn\n+    //[full]~^ ERROR cannot call non-const fn\n }]>;\n \n fn main() {}"}]}