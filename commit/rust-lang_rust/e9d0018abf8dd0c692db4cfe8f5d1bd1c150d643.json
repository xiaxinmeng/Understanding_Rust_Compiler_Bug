{"sha": "e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZDAwMThhYmY4ZGQwYzY5MmRiNGNmZThmNWQxYmQxYzE1MGQ2NDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-10T08:55:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-10T08:55:54Z"}, "message": "auto merge of #6356 : dotdash/rust/strinterner, r=pcwalton\n\n&str can be turned into @~str on demand, using to_owned(), so for\r\nstrings, we can create a specialized interner that accepts &str for\r\nintern() and find() but stores and returns @~str.", "tree": {"sha": "f52065d76f022ca0afe150daaa63c9ddc9157060", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52065d76f022ca0afe150daaa63c9ddc9157060"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "html_url": "https://github.com/rust-lang/rust/commit/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f04eb37c7ea19bbd2cff12d15816873e0a46fc86", "url": "https://api.github.com/repos/rust-lang/rust/commits/f04eb37c7ea19bbd2cff12d15816873e0a46fc86", "html_url": "https://github.com/rust-lang/rust/commit/f04eb37c7ea19bbd2cff12d15816873e0a46fc86"}, {"sha": "1393c3a3f438c896083405dca501c8cf05767c65", "url": "https://api.github.com/repos/rust-lang/rust/commits/1393c3a3f438c896083405dca501c8cf05767c65", "html_url": "https://github.com/rust-lang/rust/commit/1393c3a3f438c896083405dca501c8cf05767c65"}], "stats": {"total": 987, "additions": 521, "deletions": 466}, "files": [{"sha": "7342ebec8a0f2a4ed761f47161519f1772cb7452", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -698,8 +698,8 @@ pub fn exported_name(sess: Session,\n                      vers: &str) -> ~str {\n     return mangle(sess,\n             vec::append_one(\n-            vec::append_one(path, path_name(sess.ident_of(hash.to_owned()))),\n-            path_name(sess.ident_of(vers.to_owned()))));\n+            vec::append_one(path, path_name(sess.ident_of(hash))),\n+            path_name(sess.ident_of(vers))));\n }\n \n pub fn mangle_exported_name(ccx: @CrateContext,\n@@ -717,14 +717,14 @@ pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-        ~[path_name(ccx.sess.ident_of(name.to_owned())),\n+        ~[path_name(ccx.sess.ident_of(name)),\n           path_name(ccx.sess.ident_of(s)),\n-          path_name(ccx.sess.ident_of(hash.to_owned()))]);\n+          path_name(ccx.sess.ident_of(hash))]);\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: @CrateContext,\n                                             path: path,\n-                                            flav: ~str) -> ~str {\n+                                            flav: &str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n@@ -733,7 +733,7 @@ pub fn mangle_internal_name_by_path(ccx: @CrateContext, path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: ~str) -> ~str {\n+pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: &str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n "}, {"sha": "92cdcff65d572a7ea2f0678caca25b08c1cba331", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -285,8 +285,8 @@ pub impl Session_ {\n     fn str_of(@self, id: ast::ident) -> @~str {\n         self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(@self, st: ~str) -> ast::ident {\n-        self.parse_sess.interner.intern(@st)\n+    fn ident_of(@self, st: &str) -> ast::ident {\n+        self.parse_sess.interner.intern(st)\n     }\n     fn intr(@self) -> @syntax::parse::token::ident_interner {\n         self.parse_sess.interner"}, {"sha": "5862dd00b3ce59d5bc902bb9affc1a52df62b77c", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -42,7 +42,7 @@ fn inject_libcore_ref(sess: Session,\n             let n1 = sess.next_node_id();\n             let vi1 = @ast::view_item {\n                 node: ast::view_item_extern_mod(\n-                        sess.ident_of(~\"core\"), ~[], n1),\n+                        sess.ident_of(\"core\"), ~[], n1),\n                 attrs: ~[\n                     spanned(ast::attribute_ {\n                         style: ast::attr_inner,\n@@ -78,8 +78,8 @@ fn inject_libcore_ref(sess: Session,\n                 span: dummy_sp(),\n                 global: false,\n                 idents: ~[\n-                    sess.ident_of(~\"core\"),\n-                    sess.ident_of(~\"prelude\")\n+                    sess.ident_of(\"core\"),\n+                    sess.ident_of(\"prelude\")\n                 ],\n                 rp: None,\n                 types: ~[]"}, {"sha": "f556baee918f22be06a7fa8b2443714e1cb7fed3", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -274,7 +274,7 @@ fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n     let vers = nospan(vers);\n     let mi = ast::meta_name_value(@~\"vers\", vers);\n     let mi = nospan(mi);\n-    let id_std = cx.sess.ident_of(~\"std\");\n+    let id_std = cx.sess.ident_of(\"std\");\n     let vi = if is_std(cx) {\n         ast::view_item_use(\n             ~[@nospan(ast::view_path_simple(id_std,\n@@ -322,7 +322,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n         attr::mk_attr(attr::mk_word_item(@~\"!resolve_unexported\"));\n \n     let item = ast::item {\n-        ident: cx.sess.ident_of(~\"__test\"),\n+        ident: cx.sess.ident_of(\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n         id: cx.sess.next_node_id(),\n         node: item_,"}, {"sha": "d9feb2f44dd2e361c7641ae6fadccb30cf7a1782", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -70,7 +70,7 @@ pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n     vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n-        /*bad*/copy *cdata.name))], path)\n+        *cdata.name))], path)\n }\n \n pub enum found_ast {"}, {"sha": "3d37b93801a787ea190d7678a2636360899d7e5b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -294,10 +294,10 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     for reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_mod(intr.intern(@str)));\n+            result.push(ast_map::path_mod(intr.intern(str)));\n         } else if tag == tag_path_elt_name {\n             let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_name(intr.intern(@str)));\n+            result.push(ast_map::path_name(intr.intern(str)));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -311,7 +311,7 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     do reader::with_doc_data(name) |data| {\n         let string = str::from_bytes_slice(data);\n         match intr.find_equiv(&StringRef(string)) {\n-            None => intr.intern(@(string.to_owned())),\n+            None => intr.intern(string),\n             Some(val) => val,\n         }\n     }\n@@ -828,7 +828,7 @@ pub fn get_type_name_if_impl(intr: @ident_interner,\n     }\n \n     for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(intr.intern(@str::from_bytes(reader::doc_data(doc))));\n+        return Some(intr.intern(str::from_bytes(reader::doc_data(doc))));\n     }\n \n     return None;\n@@ -1080,7 +1080,7 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n-                  name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n+                  name: intr.intern(docstr(depdoc, tag_crate_dep_name)),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n                   hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;"}, {"sha": "0afabd53ba95a88d8ff8ad900ac3d8f50fa7b048", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -1163,7 +1163,7 @@ trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::crate_cfg;\n     fn parse_sess(&self) -> @mut parse::ParseSess;\n     fn call_site(&self) -> span;\n-    fn ident_of(&self, st: ~str) -> ast::ident;\n+    fn ident_of(&self, st: &str) -> ast::ident;\n }\n \n #[cfg(test)]\n@@ -1180,8 +1180,8 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(&self, st: ~str) -> ast::ident {\n-        self.interner.intern(@st)\n+    fn ident_of(&self, st: &str) -> ast::ident {\n+        self.interner.intern(st)\n     }\n }\n "}, {"sha": "9802e1172afbf639542c15ba96092d40fa370b86", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -708,7 +708,7 @@ pub struct PrimitiveTypeTable {\n }\n \n pub impl PrimitiveTypeTable {\n-    fn intern(&mut self, intr: @ident_interner, string: @~str,\n+    fn intern(&mut self, intr: @ident_interner, string: &str,\n               primitive_type: prim_ty) {\n         let ident = intr.intern(string);\n         self.primitive_types.insert(ident, primitive_type);\n@@ -720,22 +720,22 @@ pub fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n         primitive_types: HashMap::new()\n     };\n \n-    table.intern(intr, @~\"bool\",    ty_bool);\n-    table.intern(intr, @~\"char\",    ty_int(ty_char));\n-    table.intern(intr, @~\"float\",   ty_float(ty_f));\n-    table.intern(intr, @~\"f32\",     ty_float(ty_f32));\n-    table.intern(intr, @~\"f64\",     ty_float(ty_f64));\n-    table.intern(intr, @~\"int\",     ty_int(ty_i));\n-    table.intern(intr, @~\"i8\",      ty_int(ty_i8));\n-    table.intern(intr, @~\"i16\",     ty_int(ty_i16));\n-    table.intern(intr, @~\"i32\",     ty_int(ty_i32));\n-    table.intern(intr, @~\"i64\",     ty_int(ty_i64));\n-    table.intern(intr, @~\"str\",     ty_str);\n-    table.intern(intr, @~\"uint\",    ty_uint(ty_u));\n-    table.intern(intr, @~\"u8\",      ty_uint(ty_u8));\n-    table.intern(intr, @~\"u16\",     ty_uint(ty_u16));\n-    table.intern(intr, @~\"u32\",     ty_uint(ty_u32));\n-    table.intern(intr, @~\"u64\",     ty_uint(ty_u64));\n+    table.intern(intr, \"bool\",    ty_bool);\n+    table.intern(intr, \"char\",    ty_int(ty_char));\n+    table.intern(intr, \"float\",   ty_float(ty_f));\n+    table.intern(intr, \"f32\",     ty_float(ty_f32));\n+    table.intern(intr, \"f64\",     ty_float(ty_f64));\n+    table.intern(intr, \"int\",     ty_int(ty_i));\n+    table.intern(intr, \"i8\",      ty_int(ty_i8));\n+    table.intern(intr, \"i16\",     ty_int(ty_i16));\n+    table.intern(intr, \"i32\",     ty_int(ty_i32));\n+    table.intern(intr, \"i64\",     ty_int(ty_i64));\n+    table.intern(intr, \"str\",     ty_str);\n+    table.intern(intr, \"uint\",    ty_uint(ty_u));\n+    table.intern(intr, \"u8\",      ty_uint(ty_u8));\n+    table.intern(intr, \"u16\",     ty_uint(ty_u16));\n+    table.intern(intr, \"u32\",     ty_uint(ty_u32));\n+    table.intern(intr, \"u64\",     ty_uint(ty_u64));\n \n     return table;\n }\n@@ -1675,7 +1675,7 @@ pub impl Resolver {\n \n             let mut current_module = root;\n             for pieces.each |ident_str| {\n-                let ident = self.session.ident_of(/*bad*/copy *ident_str);\n+                let ident = self.session.ident_of(*ident_str);\n                 // Create or reuse a graph node for the child.\n                 let (child_name_bindings, new_parent) =\n                     self.add_child(ident,"}, {"sha": "0f78f7bb90dd3cead87b0ad11440f5bf1cc413bd", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -709,7 +709,7 @@ pub struct PrimitiveTypeTable {\n }\n \n pub impl PrimitiveTypeTable {\n-    fn intern(&mut self, intr: @ident_interner, string: @~str,\n+    fn intern(&mut self, intr: @ident_interner, string: &str,\n               primitive_type: prim_ty) {\n         let ident = intr.intern(string);\n         self.primitive_types.insert(ident, primitive_type);\n@@ -721,22 +721,22 @@ pub fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n         primitive_types: HashMap::new()\n     };\n \n-    table.intern(intr, @~\"bool\",    ty_bool);\n-    table.intern(intr, @~\"char\",    ty_int(ty_char));\n-    table.intern(intr, @~\"float\",   ty_float(ty_f));\n-    table.intern(intr, @~\"f32\",     ty_float(ty_f32));\n-    table.intern(intr, @~\"f64\",     ty_float(ty_f64));\n-    table.intern(intr, @~\"int\",     ty_int(ty_i));\n-    table.intern(intr, @~\"i8\",      ty_int(ty_i8));\n-    table.intern(intr, @~\"i16\",     ty_int(ty_i16));\n-    table.intern(intr, @~\"i32\",     ty_int(ty_i32));\n-    table.intern(intr, @~\"i64\",     ty_int(ty_i64));\n-    table.intern(intr, @~\"str\",     ty_str);\n-    table.intern(intr, @~\"uint\",    ty_uint(ty_u));\n-    table.intern(intr, @~\"u8\",      ty_uint(ty_u8));\n-    table.intern(intr, @~\"u16\",     ty_uint(ty_u16));\n-    table.intern(intr, @~\"u32\",     ty_uint(ty_u32));\n-    table.intern(intr, @~\"u64\",     ty_uint(ty_u64));\n+    table.intern(intr, \"bool\",    ty_bool);\n+    table.intern(intr, \"char\",    ty_int(ty_char));\n+    table.intern(intr, \"float\",   ty_float(ty_f));\n+    table.intern(intr, \"f32\",     ty_float(ty_f32));\n+    table.intern(intr, \"f64\",     ty_float(ty_f64));\n+    table.intern(intr, \"int\",     ty_int(ty_i));\n+    table.intern(intr, \"i8\",      ty_int(ty_i8));\n+    table.intern(intr, \"i16\",     ty_int(ty_i16));\n+    table.intern(intr, \"i32\",     ty_int(ty_i32));\n+    table.intern(intr, \"i64\",     ty_int(ty_i64));\n+    table.intern(intr, \"str\",     ty_str);\n+    table.intern(intr, \"uint\",    ty_uint(ty_u));\n+    table.intern(intr, \"u8\",      ty_uint(ty_u8));\n+    table.intern(intr, \"u16\",     ty_uint(ty_u16));\n+    table.intern(intr, \"u32\",     ty_uint(ty_u32));\n+    table.intern(intr, \"u64\",     ty_uint(ty_u64));\n \n     return table;\n }"}, {"sha": "e05f9d5f290b873ca1935f07f9ba0351e0852142", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -1223,7 +1223,7 @@ pub fn compile_guard(bcx: block,\n \n     let val = unpack_result!(bcx, {\n         do with_scope_result(bcx, guard_expr.info(),\n-                             ~\"guard\") |bcx| {\n+                             \"guard\") |bcx| {\n             expr::trans_to_datum(bcx, guard_expr).to_result()\n         }\n     });\n@@ -1447,7 +1447,7 @@ pub fn compile_submatch(bcx: block,\n     }\n     let else_cx = match kind {\n         no_branch | single => bcx,\n-        _ => sub_block(bcx, ~\"match_else\")\n+        _ => sub_block(bcx, \"match_else\")\n     };\n     let sw = if kind == switch {\n         Switch(bcx, test_val, else_cx.llbb, opts.len())\n@@ -1465,7 +1465,7 @@ pub fn compile_submatch(bcx: block,\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n-            opt_cx = sub_block(bcx, ~\"match_case\");\n+            opt_cx = sub_block(bcx, \"match_case\");\n             match kind {\n               single => Br(bcx, opt_cx.llbb),\n               switch => {\n@@ -1487,7 +1487,7 @@ pub fn compile_submatch(bcx: block,\n                   let t = node_id_type(bcx, pat_id);\n                   let Result {bcx: after_cx, val: matches} = {\n                       do with_scope_result(bcx, None,\n-                                           ~\"compare_scope\") |bcx| {\n+                                           \"compare_scope\") |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {\n@@ -1515,13 +1515,13 @@ pub fn compile_submatch(bcx: block,\n                           }\n                       }\n                   };\n-                  bcx = sub_block(after_cx, ~\"compare_next\");\n+                  bcx = sub_block(after_cx, \"compare_next\");\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               compare_vec_len => {\n                   let Result {bcx: after_cx, val: matches} = {\n                       do with_scope_result(bcx, None,\n-                                           ~\"compare_vec_len_scope\") |bcx| {\n+                                           \"compare_vec_len_scope\") |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {\n@@ -1553,7 +1553,7 @@ pub fn compile_submatch(bcx: block,\n                           }\n                       }\n                   };\n-                  bcx = sub_block(after_cx, ~\"compare_vec_len_next\");\n+                  bcx = sub_block(after_cx, \"compare_vec_len_next\");\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1611,7 +1611,7 @@ pub fn trans_match(bcx: block,\n                    arms: ~[ast::arm],\n                    dest: Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"match::trans_match\");\n-    do with_scope(bcx, match_expr.info(), ~\"match\") |bcx| {\n+    do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n }\n@@ -1633,7 +1633,7 @@ pub fn trans_match_inner(scope_cx: block,\n \n     let mut arm_datas = ~[], matches = ~[];\n     for arms.each |arm| {\n-        let body = scope_block(bcx, arm.body.info(), ~\"case_body\");\n+        let body = scope_block(bcx, arm.body.info(), \"case_body\");\n \n         // Create the bindings map, which is a mapping from each binding name\n         // to an alloca() that will be the value for that local variable.\n@@ -1717,7 +1717,7 @@ pub fn trans_match_inner(scope_cx: block,\n     fn mk_fail(bcx: block, sp: span, msg: @~str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n-        let fail_cx = sub_block(bcx, ~\"case_fallthrough\");\n+        let fail_cx = sub_block(bcx, \"case_fallthrough\");\n         controlflow::trans_fail(fail_cx, Some(sp), msg);\n         *finished = Some(fail_cx.llbb);\n         return fail_cx.llbb;"}, {"sha": "c2f1f52ddce36986a1ce48799cab755f8fe25788", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -703,11 +703,11 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, ty::mk_int());\n-                  let unr_cx = sub_block(cx, ~\"enum-iter-unr\");\n+                  let unr_cx = sub_block(cx, \"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n                                         n_variants);\n-                  let next_cx = sub_block(cx, ~\"enum-iter-next\");\n+                  let next_cx = sub_block(cx, \"enum-iter-next\");\n \n                   for (*variants).each |variant| {\n                       let variant_cx =\n@@ -847,7 +847,7 @@ pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n                 debug!(\"arg: %x\", ::core::cast::transmute(llarg));\n             }\n         }\n-        let normal_bcx = sub_block(bcx, ~\"normal return\");\n+        let normal_bcx = sub_block(bcx, \"normal return\");\n         let llresult = Invoke(bcx,\n                               llfn,\n                               llargs,\n@@ -949,7 +949,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n         match inf.landing_pad {\n           Some(target) => cached = Some(target),\n           None => {\n-            pad_bcx = lpad_block(bcx, ~\"unwind\");\n+            pad_bcx = lpad_block(bcx, \"unwind\");\n             inf.landing_pad = Some(pad_bcx.llbb);\n           }\n         }\n@@ -1168,7 +1168,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n // You probably don't want to use this one. See the\n // next three functions instead.\n pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n-                 is_lpad: bool, name: ~str, opt_node_info: Option<NodeInfo>)\n+                 is_lpad: bool, name: &str, opt_node_info: Option<NodeInfo>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -1207,20 +1207,20 @@ pub fn simple_block_scope() -> block_kind {\n pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n                     -> block {\n     return new_block(fcx, None, simple_block_scope(), false,\n-                  ~\"function top level\", opt_node_info);\n+                  \"function top level\", opt_node_info);\n }\n \n pub fn scope_block(bcx: block,\n                    opt_node_info: Option<NodeInfo>,\n-                   n: ~str) -> block {\n+                   n: &str) -> block {\n     return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n pub fn loop_scope_block(bcx: block,\n                         loop_break: block,\n                         loop_label: Option<ident>,\n-                        n: ~str,\n+                        n: &str,\n                         opt_node_info: Option<NodeInfo>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope(@mut scope_info {\n         loop_break: Some(loop_break),\n@@ -1232,12 +1232,12 @@ pub fn loop_scope_block(bcx: block,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: block, n: ~str) -> block {\n+pub fn lpad_block(bcx: block, n: &str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: block, n: ~str) -> block {\n+pub fn sub_block(bcx: block, n: &str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n }\n \n@@ -1309,7 +1309,7 @@ pub fn cleanup_and_leave(bcx: block,\n                         Br(bcx, cp.dest);\n                         return;\n                     }\n-                    let sub_cx = sub_block(bcx, ~\"cleanup\");\n+                    let sub_cx = sub_block(bcx, \"cleanup\");\n                     Br(bcx, sub_cx.llbb);\n                     inf.cleanup_paths.push(cleanup_path {\n                         target: leave,\n@@ -1346,15 +1346,15 @@ pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n \n pub fn leave_block(bcx: block, out_of: block) -> block {\n     let _icx = bcx.insn_ctxt(\"leave_block\");\n-    let next_cx = sub_block(block_parent(out_of), ~\"next\");\n+    let next_cx = sub_block(block_parent(out_of), \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n     next_cx\n }\n \n pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n-                  name: ~str,\n+                  name: &str,\n                   f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n@@ -1369,7 +1369,7 @@ pub fn with_scope(bcx: block,\n \n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n-                         name: ~str,\n+                         name: &str,\n                          f: &fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n@@ -1379,7 +1379,7 @@ pub fn with_scope_result(bcx: block,\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n-                             name: ~str, f: &fn(block) -> datum::DatumBlock)\n+                             name: &str, f: &fn(block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1432,8 +1432,8 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n \n pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_cond\");\n-    let next_cx = base::sub_block(bcx, ~\"next\");\n-    let cond_cx = base::sub_block(bcx, ~\"cond\");\n+    let next_cx = base::sub_block(bcx, \"next\");\n+    let cond_cx = base::sub_block(bcx, \"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n     if !after_cx.terminated { Br(after_cx, next_cx.llbb); }\n@@ -2542,7 +2542,7 @@ pub fn register_method(ccx: @CrateContext,\n                        pth: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n-    let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(~\"meth\")),\n+    let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(\"meth\")),\n                                   path_name(m.ident)]);\n     let llfn = register_fn_full(ccx, m.span, pth, id, m.attrs, mty);\n     set_inline_hint_if_appr(m.attrs, llfn);"}, {"sha": "aab35ce59b998b966a97d4704039207ad423b9c0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -454,7 +454,7 @@ pub fn trans_call_inner(in_cx: block,\n                         dest: expr::Dest,\n                         autoref_arg: AutorefArg)\n                         -> block {\n-    do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n+    do base::with_scope(in_cx, call_info, \"call\") |cx| {\n         let ret_in_loop = match args {\n           ArgExprs(args) => {\n             args.len() > 0u && match vec::last(args).node {"}, {"sha": "0651d3443b56a7ad9788eb6986de57728ac14b0f", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -400,7 +400,7 @@ pub fn trans_expr_fn(bcx: block,\n     // XXX: Bad copy.\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  copy sub_path,\n-                                                 ~\"expr_fn\");\n+                                                 \"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n     // Always mark inline if this is a loop body. This is important for"}, {"sha": "14a8bfe161f342ed29f66d6fc95b801a21f5291a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -54,12 +54,12 @@ use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n-pub type namegen = @fn(s: ~str) -> ident;\n+pub type namegen = @fn(s: &str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n-    let f: @fn(s: ~str) -> ident = |prefix| {\n-        intr.gensym(@fmt!(\"%s_%u\",\n+    let f: @fn(s: &str) -> ident = |prefix| {\n+        intr.gensym(fmt!(\"%s_%u\",\n                           prefix,\n-                          intr.gensym(@prefix).repr))\n+                          intr.gensym(prefix).repr))\n     };\n     f\n }\n@@ -1177,7 +1177,7 @@ pub fn C_cstr(cx: @CrateContext, s: @~str) -> ValueRef {\n             llvm::LLVMConstString(buf, s.len() as c_uint, False)\n         };\n         let g =\n-            str::as_c_str(fmt!(\"str%u\", (cx.names)(~\"str\").repr),\n+            str::as_c_str(fmt!(\"str%u\", (cx.names)(\"str\").repr),\n                         |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -1269,7 +1269,7 @@ pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n pub fn C_shape(ccx: @CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n-        let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n+        let name = fmt!(\"shape%u\", (ccx.names)(\"shape\").repr);\n         let llglobal = str::as_c_str(name, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n         });"}, {"sha": "ac512bc4bf95d810df207fe5d1d99e47761190aa", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -65,8 +65,8 @@ pub fn trans_if(bcx: block,\n     let Result {bcx, val: cond_val} =\n         expr::trans_to_datum(bcx, cond).to_result();\n \n-    let then_bcx_in = scope_block(bcx, thn.info(), ~\"then\");\n-    let else_bcx_in = scope_block(bcx, els.info(), ~\"else\");\n+    let then_bcx_in = scope_block(bcx, thn.info(), \"then\");\n+    let else_bcx_in = scope_block(bcx, els.info(), \"else\");\n \n     let cond_val = bool_to_i1(bcx, cond_val);\n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n@@ -105,7 +105,7 @@ pub fn trans_if(bcx: block,\n }\n \n pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n-    let out = sub_block(parent_bcx, ~\"join\");\n+    let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n     for in_cxs.each |bcx| {\n         if !bcx.unreachable {\n@@ -121,7 +121,7 @@ pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n \n pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::blk) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_while\");\n-    let next_bcx = sub_block(bcx, ~\"while next\");\n+    let next_bcx = sub_block(bcx, \"while next\");\n \n     //            bcx\n     //             |\n@@ -136,10 +136,10 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::blk) -> block {\n     //    |           body_bcx_out --+\n     // next_bcx\n \n-    let loop_bcx = loop_scope_block(bcx, next_bcx, None, ~\"`while`\",\n+    let loop_bcx = loop_scope_block(bcx, next_bcx, None, \"`while`\",\n                                     body.info());\n-    let cond_bcx_in = scope_block(loop_bcx, cond.info(), ~\"while loop cond\");\n-    let body_bcx_in = scope_block(loop_bcx, body.info(), ~\"while loop body\");\n+    let cond_bcx_in = scope_block(loop_bcx, cond.info(), \"while loop cond\");\n+    let body_bcx_in = scope_block(loop_bcx, body.info(), \"while loop body\");\n     Br(bcx, loop_bcx.llbb);\n     Br(loop_bcx, cond_bcx_in.llbb);\n \n@@ -163,8 +163,8 @@ pub fn trans_loop(bcx:block,\n                   opt_label: Option<ident>)\n                -> block {\n     let _icx = bcx.insn_ctxt(\"trans_loop\");\n-    let next_bcx = sub_block(bcx, ~\"next\");\n-    let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, ~\"`loop`\",\n+    let next_bcx = sub_block(bcx, \"next\");\n+    let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n                                        body.info());\n     Br(bcx, body_bcx_in.llbb);\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n@@ -186,7 +186,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     let (modpath, modname) = {\n         let path = &mut bcx.fcx.path;\n         let modpath = vec::append(\n-            ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name.to_owned()))],\n+            ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n             path.filtered(|e| match *e { path_mod(_) => true, _ => false }));\n         let modname = path_str(ccx.sess, modpath);\n         (modpath, modname)\n@@ -196,7 +196,7 @@ pub fn trans_log(log_ex: @ast::expr,\n         ccx.module_data.get_copy(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n-            ccx, modpath, ~\"loglevel\");\n+            ccx, modpath, \"loglevel\");\n         let global;\n         unsafe {\n             global = str::as_c_str(s, |buf| {\n@@ -211,14 +211,14 @@ pub fn trans_log(log_ex: @ast::expr,\n     };\n     let current_level = Load(bcx, global);\n     let level = unpack_result!(bcx, {\n-        do with_scope_result(bcx, lvl.info(), ~\"level\") |bcx| {\n+        do with_scope_result(bcx, lvl.info(), \"level\") |bcx| {\n             expr::trans_to_datum(bcx, lvl).to_result()\n         }\n     });\n \n     let llenabled = ICmp(bcx, lib::llvm::IntUGE, current_level, level);\n     do with_cond(bcx, llenabled) |bcx| {\n-        do with_scope(bcx, log_ex.info(), ~\"log\") |bcx| {\n+        do with_scope(bcx, log_ex.info(), \"log\") |bcx| {\n             let mut bcx = bcx;\n \n             // Translate the value to be logged"}, {"sha": "f0fb33136ffbfb77cce8617c049b399ab853db2e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -517,7 +517,7 @@ fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span)\n     let scx = create_structure(file_node,\n                                cx.sess.str_of(\n                                    ((/*bad*/copy cx.dbg_cx).get().names)\n-                                   (~\"tuple\")),\n+                                   (\"tuple\")),\n                                line_from_span(cx.sess.codemap, span) as int);\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n@@ -973,7 +973,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n-            ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n+            ((dbg_cx.names)(\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")"}, {"sha": "e7d47561950b5d168e913612d14c00c60a7a965e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -540,8 +540,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n                            src_datum_ref,\n                            dst_datum_ref);\n \n-            let swap_cx = base::sub_block(bcx, ~\"swap\");\n-            let next_cx = base::sub_block(bcx, ~\"next\");\n+            let swap_cx = base::sub_block(bcx, \"swap\");\n+            let next_cx = base::sub_block(bcx, \"next\");\n \n             CondBr(bcx, cmp, next_cx.llbb, swap_cx.llbb);\n \n@@ -598,7 +598,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_block(ref blk) => {\n             return do base::with_scope(bcx, blk.info(),\n-                                       ~\"block-expr body\") |bcx| {\n+                                       \"block-expr body\") |bcx| {\n                 controlflow::trans_block(bcx, blk, dest)\n             };\n         }\n@@ -1478,7 +1478,7 @@ fn trans_lazy_binop(bcx: block,\n     let bcx = bcx;\n \n     let Result {bcx: past_lhs, val: lhs} = {\n-        do base::with_scope_result(bcx, a.info(), ~\"lhs\") |bcx| {\n+        do base::with_scope_result(bcx, a.info(), \"lhs\") |bcx| {\n             trans_to_datum(bcx, a).to_result()\n         }\n     };\n@@ -1487,8 +1487,8 @@ fn trans_lazy_binop(bcx: block,\n         return immediate_rvalue_bcx(past_lhs, lhs, binop_ty);\n     }\n \n-    let join = base::sub_block(bcx, ~\"join\");\n-    let before_rhs = base::sub_block(bcx, ~\"rhs\");\n+    let join = base::sub_block(bcx, \"join\");\n+    let before_rhs = base::sub_block(bcx, \"rhs\");\n \n     let lhs_i1 = bool_to_i1(past_lhs, lhs);\n     match op {\n@@ -1497,7 +1497,7 @@ fn trans_lazy_binop(bcx: block,\n     }\n \n     let Result {bcx: past_rhs, val: rhs} = {\n-        do base::with_scope_result(before_rhs, b.info(), ~\"rhs\") |bcx| {\n+        do base::with_scope_result(before_rhs, b.info(), \"rhs\") |bcx| {\n             trans_to_datum(bcx, b).to_result()\n         }\n     };"}, {"sha": "585d9d8420cd79abbfc4a4a475d47426c133460c", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -671,9 +671,9 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let addrspace = declare_tydesc_addrspace(ccx, t);\n     //XXX this triggers duplicate LLVM symbols\n     let name = @(if false /*ccx.sess.opts.debuginfo*/ {\n-        mangle_internal_name_by_type_only(ccx, t, ~\"tydesc\")\n+        mangle_internal_name_by_type_only(ccx, t, \"tydesc\")\n     } else {\n-        mangle_internal_name_by_seq(ccx, ~\"tydesc\")\n+        mangle_internal_name_by_seq(ccx, \"tydesc\")\n     });\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), *name);"}, {"sha": "ffe414ab5b5d2df9d293af758897ceb229a95e35", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -775,7 +775,7 @@ pub fn make_vtable(ccx: @CrateContext, ptrs: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n         let tbl = C_struct(ptrs);\n-        let vtable = ccx.sess.str_of((ccx.names)(~\"vtable\"));\n+        let vtable = ccx.sess.str_of((ccx.names)(\"vtable\"));\n         let vt_gvar = do str::as_c_str(*vtable) |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n         };"}, {"sha": "3b0c03cdc991a15f87396f25d644bf3286284a5c", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -171,7 +171,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     let pt = vec::append(/*bad*/copy *pt,\n                          ~[path_name((ccx.names)(\n-                             copy *ccx.sess.str_of(name)))]);\n+                             *ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n     let mk_lldecl = || {"}, {"sha": "2183472d5915402f8d5658f90193ae55abc0f7b4", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -114,7 +114,7 @@ pub impl Reflector {\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n         let result = bool_to_i1(bcx, result);\n-        let next_bcx = sub_block(bcx, ~\"next\");\n+        let next_bcx = sub_block(bcx, \"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx\n     }\n@@ -275,15 +275,15 @@ pub impl Reflector {\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n             let llptrty = T_ptr(type_of(ccx, t));\n             let (_, opaquety) =\n-                ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(~\"Opaque\"))\n+                ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(\"Opaque\"))\n                 .expect(\"Failed to resolve intrinsic::Opaque\");\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n                 let sub_path = bcx.fcx.path + ~[path_name(special_idents::anon)];\n                 let sym = mangle_internal_name_by_path_and_seq(ccx,\n                                                                sub_path,\n-                                                               ~\"get_disr\");\n+                                                               \"get_disr\");\n                 let args = [\n                     ty::arg {\n                         ty: opaqueptrty\n@@ -373,7 +373,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                     visitor_trait_id: def_id)\n                                  -> block {\n     use syntax::parse::token::special_idents::tydesc;\n-    let final = sub_block(bcx, ~\"final\");\n+    let final = sub_block(bcx, \"final\");\n     assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n     let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get_copy(&tydesc);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);"}, {"sha": "7a85e93584e25f3337edaba6c6590068f3e23459", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -421,11 +421,11 @@ pub fn write_content(bcx: block,\n                         expr::trans_to_datum(bcx, element)\n                     });\n \n-                    let next_bcx = sub_block(bcx, ~\"expr_repeat: while next\");\n-                    let loop_bcx = loop_scope_block(bcx, next_bcx, None, ~\"expr_repeat\", None);\n-                    let cond_bcx = scope_block(loop_bcx, None, ~\"expr_repeat: loop cond\");\n-                    let set_bcx = scope_block(loop_bcx, None, ~\"expr_repeat: body: set\");\n-                    let inc_bcx = scope_block(loop_bcx, None, ~\"expr_repeat: body: inc\");\n+                    let next_bcx = sub_block(bcx, \"expr_repeat: while next\");\n+                    let loop_bcx = loop_scope_block(bcx, next_bcx, None, \"expr_repeat\", None);\n+                    let cond_bcx = scope_block(loop_bcx, None, \"expr_repeat: loop cond\");\n+                    let set_bcx = scope_block(loop_bcx, None, \"expr_repeat: body: set\");\n+                    let inc_bcx = scope_block(loop_bcx, None, \"expr_repeat: body: inc\");\n                     Br(bcx, loop_bcx.llbb);\n \n                     let loop_counter = {\n@@ -561,14 +561,14 @@ pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n \n     // Now perform the iteration.\n-    let header_bcx = base::sub_block(bcx, ~\"iter_vec_loop_header\");\n+    let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");\n     Br(bcx, header_bcx.llbb);\n     let data_ptr =\n         Phi(header_bcx, val_ty(data_ptr), ~[data_ptr], ~[bcx.llbb]);\n     let not_yet_at_end =\n         ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n-    let body_bcx = base::sub_block(header_bcx, ~\"iter_vec_loop_body\");\n-    let next_bcx = base::sub_block(header_bcx, ~\"iter_vec_next\");\n+    let body_bcx = base::sub_block(header_bcx, \"iter_vec_loop_body\");\n+    let next_bcx = base::sub_block(header_bcx, \"iter_vec_next\");\n     CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n     let body_bcx = f(body_bcx, data_ptr, unit_ty);\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,"}, {"sha": "299b4a98ade53a47804e513056f26faea71b8691", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -1550,7 +1550,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             lhs_resolved_t, None)\n                 };\n                 return lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n-                                       fcx.tcx().sess.ident_of(copy *name),\n+                                       fcx.tcx().sess.ident_of(*name),\n                                        ~[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n                                        expected_result);\n             }\n@@ -1574,8 +1574,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n-                       op_str: ~str,\n-                       mname: ~str,\n+                       op_str: &str,\n+                       mname: &str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr,\n                        rhs_t: ty::t,\n@@ -2308,7 +2308,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx,\n-                            ~\"!\", ~\"not\", expr, oprnd, oprnd_t,\n+                            \"!\", \"not\", expr, oprnd, oprnd_t,\n                                                   expected);\n                     }\n                 }\n@@ -2318,7 +2318,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::type_is_fp(oprnd_t)) {\n                         oprnd_t = check_user_unop(fcx,\n-                            ~\"-\", ~\"neg\", expr, oprnd, oprnd_t, expected);\n+                            \"-\", \"neg\", expr, oprnd, oprnd_t, expected);\n                     }\n                 }\n             }\n@@ -2783,7 +2783,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       let resolved = structurally_resolved_type(fcx,\n                                                                 expr.span,\n                                                                 raw_base_t);\n-                      let index_ident = tcx.sess.ident_of(~\"index\");\n+                      let index_ident = tcx.sess.ident_of(\"index\");\n                       let error_message = || {\n                         fcx.type_error_message(expr.span,\n                                                |actual| {"}, {"sha": "a8cd7f5f41c66466fce21c3d660d76a7a9395a2d", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -156,7 +156,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n     for crate.node.module.items.each |item| {\n         match item.node {\n             ast::item_fn(_, _, _, _, blk) => {\n-                if item.ident == sess.ident_of(~\"main\") {\n+                if item.ident == sess.ident_of(\"main\") {\n                     opt = blk.node.expr;\n                 }\n             }"}, {"sha": "5908d0c56f41862837c8238dab07b311c73232e1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -93,7 +93,7 @@ impl<D:Decoder> Decodable<D> for ident {\n             Some(intr) => intr\n         };\n \n-        (*intr).intern(@d.read_str())\n+        (*intr).intern(d.read_str())\n     }\n }\n "}, {"sha": "1d3af61be7036b0c6733879ca44e71a0aeb866a7", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -244,7 +244,7 @@ trait ExtCtxtMethods {\n     fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n     fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n     fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_var(&self, span: span, var: ~str) -> @ast::expr;\n+    fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n     fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n                   -> @ast::expr;\n     fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n@@ -446,7 +446,7 @@ impl ExtCtxtMethods for @ext_ctxt {\n         self.expr(span, ast::expr_path(self.path_global(span, strs)))\n     }\n \n-    fn expr_var(&self, span: span, var: ~str) -> @ast::expr {\n+    fn expr_var(&self, span: span, var: &str) -> @ast::expr {\n         self.expr_path(span, ~[self.ident_of(var)])\n     }\n \n@@ -583,13 +583,13 @@ fn mk_ser_impl(\n     // Make a path to the std::serialize::Encodable typaram.\n     let ty_param = cx.bind_path(\n         span,\n-        cx.ident_of(~\"__S\"),\n+        cx.ident_of(\"__S\"),\n         cx.path_global(\n             span,\n             ~[\n-                cx.ident_of(~\"std\"),\n-                cx.ident_of(~\"serialize\"),\n-                cx.ident_of(~\"Encoder\"),\n+                cx.ident_of(\"std\"),\n+                cx.ident_of(\"serialize\"),\n+                cx.ident_of(\"Encoder\"),\n             ]\n         ),\n         @opt_vec::Empty\n@@ -599,11 +599,11 @@ fn mk_ser_impl(\n     let path = cx.path_tps_global(\n         span,\n         ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialize\"),\n-            cx.ident_of(~\"Encodable\"),\n+            cx.ident_of(\"std\"),\n+            cx.ident_of(\"serialize\"),\n+            cx.ident_of(\"Encodable\"),\n         ],\n-        ~[cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[])]\n+        ~[cx.ty_path(span, ~[cx.ident_of(\"__S\")], ~[])]\n     );\n \n     mk_impl(\n@@ -627,13 +627,13 @@ fn mk_deser_impl(\n     // Make a path to the std::serialize::Decodable typaram.\n     let ty_param = cx.bind_path(\n         span,\n-        cx.ident_of(~\"__D\"),\n+        cx.ident_of(\"__D\"),\n         cx.path_global(\n             span,\n             ~[\n-                cx.ident_of(~\"std\"),\n-                cx.ident_of(~\"serialize\"),\n-                cx.ident_of(~\"Decoder\"),\n+                cx.ident_of(\"std\"),\n+                cx.ident_of(\"serialize\"),\n+                cx.ident_of(\"Decoder\"),\n             ]\n         ),\n         @opt_vec::Empty\n@@ -643,11 +643,11 @@ fn mk_deser_impl(\n     let path = cx.path_tps_global(\n         span,\n         ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialize\"),\n-            cx.ident_of(~\"Decodable\"),\n+            cx.ident_of(\"std\"),\n+            cx.ident_of(\"serialize\"),\n+            cx.ident_of(\"Decodable\"),\n         ],\n-        ~[cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[])]\n+        ~[cx.ty_path(span, ~[cx.ident_of(\"__D\")], ~[])]\n     );\n \n     mk_impl(\n@@ -671,7 +671,7 @@ fn mk_ser_method(\n         node: ast::ty_rptr(\n             None,\n             ast::mt {\n-                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+                ty: cx.ty_path(span, ~[cx.ident_of(\"__S\")], ~[]),\n                 mutbl: ast::m_mutbl\n             }\n         ),\n@@ -685,7 +685,7 @@ fn mk_ser_method(\n             id: cx.next_id(),\n             node: ast::pat_ident(\n                 ast::bind_by_copy,\n-                ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n+                ast_util::ident_to_path(span, cx.ident_of(\"__s\")),\n                 None),\n             span: span,\n         },\n@@ -705,7 +705,7 @@ fn mk_ser_method(\n     };\n \n     @ast::method {\n-        ident: cx.ident_of(~\"encode\"),\n+        ident: cx.ident_of(\"encode\"),\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n         self_ty: codemap::spanned {\n@@ -733,7 +733,7 @@ fn mk_deser_method(\n         node: ast::ty_rptr(\n             None,\n             ast::mt {\n-                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+                ty: cx.ty_path(span, ~[cx.ident_of(\"__D\")], ~[]),\n                 mutbl: ast::m_mutbl\n             }\n         ),\n@@ -749,7 +749,7 @@ fn mk_deser_method(\n                 node: ast::pat_ident(ast::bind_by_copy,\n                                      ast_util::ident_to_path(span,\n                                                              cx.ident_of(\n-                                                                ~\"__d\")),\n+                                                                \"__d\")),\n                                      None),\n                 span: span,\n             },\n@@ -764,7 +764,7 @@ fn mk_deser_method(\n     };\n \n     @ast::method {\n-        ident: cx.ident_of(~\"decode\"),\n+        ident: cx.ident_of(\"decode\"),\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n         self_ty: codemap::spanned { node: ast::sty_static, span: span },\n@@ -792,21 +792,21 @@ fn mk_struct_ser_impl(\n                 span,\n                 cx.expr_field(\n                     span,\n-                    cx.expr_var(span, ~\"self\"),\n+                    cx.expr_var(span, \"self\"),\n                     field.ident\n                 ),\n-                cx.ident_of(~\"encode\"),\n-                ~[cx.expr_var(span, ~\"__s\")]\n+                cx.ident_of(\"encode\"),\n+                ~[cx.expr_var(span, \"__s\")]\n             ),\n-            cx.ident_of(~\"__s\")\n+            cx.ident_of(\"__s\")\n         );\n \n         // ast for `__s.emit_struct_field($(name), $(idx), $(expr_lambda))`\n         cx.stmt(\n             cx.expr_method_call(\n                 span,\n-                cx.expr_var(span, ~\"__s\"),\n-                cx.ident_of(~\"emit_struct_field\"),\n+                cx.expr_var(span, \"__s\"),\n+                cx.ident_of(\"emit_struct_field\"),\n                 ~[\n                     cx.lit_str(span, @cx.str_of(field.ident)),\n                     cx.lit_uint(span, idx),\n@@ -819,12 +819,12 @@ fn mk_struct_ser_impl(\n     // ast for `__s.emit_struct($(name), |__s| $(fields))`\n     let ser_body = cx.expr_method_call(\n         span,\n-        cx.expr_var(span, ~\"__s\"),\n-        cx.ident_of(~\"emit_struct\"),\n+        cx.expr_var(span, \"__s\"),\n+        cx.ident_of(\"emit_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n-            cx.lambda_stmts_1(span, fields, cx.ident_of(~\"__s\")),\n+            cx.lambda_stmts_1(span, fields, cx.ident_of(\"__s\")),\n         ]\n     );\n \n@@ -845,22 +845,22 @@ fn mk_struct_deser_impl(\n                 cx.expr_call(\n                     span,\n                     cx.expr_path_global(span, ~[\n-                        cx.ident_of(~\"std\"),\n-                        cx.ident_of(~\"serialize\"),\n-                        cx.ident_of(~\"Decodable\"),\n-                        cx.ident_of(~\"decode\"),\n+                        cx.ident_of(\"std\"),\n+                        cx.ident_of(\"serialize\"),\n+                        cx.ident_of(\"Decodable\"),\n+                        cx.ident_of(\"decode\"),\n                     ]),\n-                    ~[cx.expr_var(span, ~\"__d\")]\n+                    ~[cx.expr_var(span, \"__d\")]\n                 )\n             ),\n-            cx.ident_of(~\"__d\")\n+            cx.ident_of(\"__d\")\n         );\n \n         // ast for `__d.read_struct_field($(name), $(idx), $(expr_lambda))`\n         let expr: @ast::expr = cx.expr_method_call(\n             span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_struct_field\"),\n+            cx.expr_var(span, \"__d\"),\n+            cx.ident_of(\"read_struct_field\"),\n             ~[\n                 cx.lit_str(span, @cx.str_of(field.ident)),\n                 cx.lit_uint(span, idx),\n@@ -881,8 +881,8 @@ fn mk_struct_deser_impl(\n     // ast for `read_struct($(name), |__d| $(fields))`\n     let body = cx.expr_method_call(\n         span,\n-        cx.expr_var(span, ~\"__d\"),\n-        cx.ident_of(~\"read_struct\"),\n+        cx.expr_var(span, \"__d\"),\n+        cx.ident_of(\"read_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n             cx.lit_uint(span, vec::len(fields)),\n@@ -895,7 +895,7 @@ fn mk_struct_deser_impl(\n                         None\n                     )\n                 ),\n-                cx.ident_of(~\"__d\")\n+                cx.ident_of(\"__d\")\n             ),\n         ]\n     );\n@@ -997,19 +997,19 @@ fn ser_variant(\n         // ast for `__s.emit_enum_variant_arg`\n         let expr_emit = cx.expr_field(\n             span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant_arg\")\n+            cx.expr_var(span, \"__s\"),\n+            cx.ident_of(\"emit_enum_variant_arg\")\n         );\n \n         // ast for `|__s| $(v).encode(__s)`\n         let expr_encode = cx.lambda_expr_1(\n             cx.expr_method_call(\n                 span,\n                  cx.expr_path(span, ~[names[a_idx]]),\n-                 cx.ident_of(~\"encode\"),\n-                ~[cx.expr_var(span, ~\"__s\")]\n+                 cx.ident_of(\"encode\"),\n+                ~[cx.expr_var(span, \"__s\")]\n             ),\n-            cx.ident_of(~\"__s\")\n+            cx.ident_of(\"__s\")\n         );\n \n         // ast for `$(expr_emit)($(a_idx), $(expr_encode))`\n@@ -1025,13 +1025,13 @@ fn ser_variant(\n     // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n     let body = cx.expr_method_call(\n         span,\n-        cx.expr_var(span, ~\"__s\"),\n-        cx.ident_of(~\"emit_enum_variant\"),\n+        cx.expr_var(span, \"__s\"),\n+        cx.ident_of(\"emit_enum_variant\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(v_name)),\n             cx.lit_uint(span, v_idx),\n             cx.lit_uint(span, stmts.len()),\n-            cx.lambda_stmts_1(span, stmts, cx.ident_of(~\"__s\")),\n+            cx.lambda_stmts_1(span, stmts, cx.ident_of(\"__s\")),\n         ]\n     );\n \n@@ -1065,7 +1065,7 @@ fn mk_enum_ser_body(\n         ast::expr_match(\n             cx.expr(\n                 span,\n-                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n+                ast::expr_unary(ast::deref, cx.expr_var(span, \"self\"))\n             ),\n             arms\n         )\n@@ -1074,11 +1074,11 @@ fn mk_enum_ser_body(\n     // ast for `__s.emit_enum($(name), || $(match_expr))`\n     cx.expr_method_call(\n         span,\n-        cx.expr_var(span, ~\"__s\"),\n-        cx.ident_of(~\"emit_enum\"),\n+        cx.expr_var(span, \"__s\"),\n+        cx.ident_of(\"emit_enum\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(name)),\n-            cx.lambda_expr_1(match_expr, cx.ident_of(~\"__s\")),\n+            cx.lambda_expr_1(match_expr, cx.ident_of(\"__s\")),\n         ]\n     )\n }\n@@ -1095,21 +1095,21 @@ fn mk_enum_deser_variant_nary(\n             cx.expr_call(\n                 span,\n                 cx.expr_path_global(span, ~[\n-                    cx.ident_of(~\"std\"),\n-                    cx.ident_of(~\"serialize\"),\n-                    cx.ident_of(~\"Decodable\"),\n-                    cx.ident_of(~\"decode\"),\n+                    cx.ident_of(\"std\"),\n+                    cx.ident_of(\"serialize\"),\n+                    cx.ident_of(\"Decodable\"),\n+                    cx.ident_of(\"decode\"),\n                 ]),\n-                ~[cx.expr_var(span, ~\"__d\")]\n+                ~[cx.expr_var(span, \"__d\")]\n             ),\n-            cx.ident_of(~\"__d\")\n+            cx.ident_of(\"__d\")\n         );\n \n         // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n         cx.expr_method_call(\n             span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_enum_variant_arg\"),\n+            cx.expr_var(span, \"__d\"),\n+            cx.ident_of(\"read_enum_variant_arg\"),\n             ~[cx.lit_uint(span, idx), expr_lambda]\n         )\n     };\n@@ -1205,7 +1205,7 @@ fn mk_enum_deser_body(\n                             node: ast::pat_ident(\n                                 ast::bind_by_copy,\n                                 ast_util::ident_to_path(span,\n-                                    ext_cx.ident_of(~\"__d\")),\n+                                    ext_cx.ident_of(\"__d\")),\n                                 None),\n                             span: span,\n                         },\n@@ -1223,7 +1223,7 @@ fn mk_enum_deser_body(\n                             node: ast::pat_ident(\n                                 ast::bind_by_copy,\n                                 ast_util::ident_to_path(span,\n-                                    ext_cx.ident_of(~\"i\")),\n+                                    ext_cx.ident_of(\"i\")),\n                                 None),\n                             span: span,\n                         },\n@@ -1240,7 +1240,7 @@ fn mk_enum_deser_body(\n             ext_cx.expr_blk(\n                 ext_cx.expr(\n                     span,\n-                    ast::expr_match(ext_cx.expr_var(span, ~\"i\"), arms)\n+                    ast::expr_match(ext_cx.expr_var(span, \"i\"), arms)\n                 )\n             )\n         )\n@@ -1250,18 +1250,18 @@ fn mk_enum_deser_body(\n     let expr_lambda = ext_cx.lambda_expr_1(\n         ext_cx.expr_method_call(\n             span,\n-            ext_cx.expr_var(span, ~\"__d\"),\n-            ext_cx.ident_of(~\"read_enum_variant\"),\n+            ext_cx.expr_var(span, \"__d\"),\n+            ext_cx.ident_of(\"read_enum_variant\"),\n             ~[expr_arm_names, expr_lambda]\n         ),\n-        ext_cx.ident_of(~\"__d\")\n+        ext_cx.ident_of(\"__d\")\n     );\n \n     // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n     ext_cx.expr_method_call(\n         span,\n-        ext_cx.expr_var(span, ~\"__d\"),\n-        ext_cx.ident_of(~\"read_enum\"),\n+        ext_cx.expr_var(span, \"__d\"),\n+        ext_cx.ident_of(\"read_enum\"),\n         ~[\n             ext_cx.lit_str(span, @ext_cx.str_of(name)),\n             expr_lambda"}, {"sha": "ac825e9436a98d4a2ba0f2cac3f70d8114c40dcc", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -232,7 +232,7 @@ pub trait ext_ctxt {\n     fn set_trace_macros(&self, x: bool);\n     /* for unhygienic identifier transformation */\n     fn str_of(&self, id: ast::ident) -> ~str;\n-    fn ident_of(&self, st: ~str) -> ast::ident;\n+    fn ident_of(&self, st: &str) -> ast::ident;\n }\n \n pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n@@ -322,8 +322,8 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n         fn str_of(&self, id: ast::ident) -> ~str {\n             copy *self.parse_sess.interner.get(id)\n         }\n-        fn ident_of(&self, st: ~str) -> ast::ident {\n-            self.parse_sess.interner.intern(@/*bad*/ copy st)\n+        fn ident_of(&self, st: &str) -> ast::ident {\n+            self.parse_sess.interner.intern(st)\n         }\n     }\n     let imp: @CtxtRepr = @CtxtRepr {"}, {"sha": "3bfb93b34b3a5278bd326107528b37037e60a78c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -502,10 +502,10 @@ pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n         cx,\n         span,\n         ~[\n-            cx.ident_of(~\"core\"),\n-            cx.ident_of(~\"sys\"),\n-            cx.ident_of(~\"FailWithCause\"),\n-            cx.ident_of(~\"fail_with\"),\n+            cx.ident_of(\"core\"),\n+            cx.ident_of(\"sys\"),\n+            cx.ident_of(\"FailWithCause\"),\n+            cx.ident_of(\"fail_with\"),\n         ],\n         ~[\n             mk_base_str(cx, span, ~\"internal error: entered unreachable code\"),"}, {"sha": "96e5e4143226c159461007b3ee72b1fce5b37541", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -33,7 +33,7 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n             }\n         }\n     }\n-    let res = cx.parse_sess().interner.intern(@res_str);\n+    let res = cx.parse_sess().interner.intern(res_str);\n \n     let e = @ast::expr {\n         id: cx.next_id(),"}, {"sha": "a9234c858f418b7c7df201e57101c630d5233f0f", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -58,9 +58,9 @@ fn cs_ord(less: bool, equal: bool,\n           cx: @ext_ctxt, span: span,\n           substr: &Substructure) -> @expr {\n     let binop = if less {\n-        cx.ident_of(~\"lt\")\n+        cx.ident_of(\"lt\")\n     } else {\n-        cx.ident_of(~\"gt\")\n+        cx.ident_of(\"gt\")\n     };\n     let false_blk_expr = build::mk_block(cx, span,\n                                          ~[], ~[],\n@@ -101,7 +101,7 @@ fn cs_ord(less: bool, equal: bool,\n             }\n \n             let cmp = build::mk_method_call(cx, span,\n-                                            self_f, cx.ident_of(~\"eq\"), other_fs.to_owned());\n+                                            self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n             let subexpr = build::mk_simple_block(cx, span, subexpr);\n             let elseif = expr_if(cmp, subexpr, Some(false_blk_expr));\n             let elseif = build::mk_expr(cx, span, elseif);"}, {"sha": "7d560a197d08b2ff6155b06ab194128f1a583bde", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -43,21 +43,21 @@ pub fn expand_deriving_totalord(cx: @ext_ctxt,\n \n pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n     let cnst = match cnst {\n-        Less => ~\"Less\",\n-        Equal => ~\"Equal\",\n-        Greater => ~\"Greater\"\n+        Less => \"Less\",\n+        Equal => \"Equal\",\n+        Greater => \"Greater\"\n     };\n     build::mk_path_global(cx, span,\n-                          ~[cx.ident_of(~\"core\"),\n-                            cx.ident_of(~\"cmp\"),\n+                          ~[cx.ident_of(\"core\"),\n+                            cx.ident_of(\"cmp\"),\n                             cx.ident_of(cnst)])\n }\n \n pub fn cs_cmp(cx: @ext_ctxt, span: span,\n               substr: &Substructure) -> @expr {\n-    let lexical_ord = ~[cx.ident_of(~\"core\"),\n-                        cx.ident_of(~\"cmp\"),\n-                        cx.ident_of(~\"lexical_ordering\")];\n+    let lexical_ord = ~[cx.ident_of(\"core\"),\n+                        cx.ident_of(\"cmp\"),\n+                        cx.ident_of(\"lexical_ordering\")];\n \n     cs_same_method_fold(\n         // foldr (possibly) nests the matches in lexical_ordering better"}, {"sha": "fd5d26a17870740593f7fb262196f6a7a152029c", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -41,15 +41,15 @@ fn create_derived_decodable_impl(\n ) -> @item {\n     let decoder_ty_param = build::mk_ty_param(\n         cx,\n-        cx.ident_of(~\"__D\"),\n+        cx.ident_of(\"__D\"),\n         @opt_vec::with(\n             build::mk_trait_ty_param_bound_global(\n                 cx,\n                 span,\n                 ~[\n-                    cx.ident_of(~\"std\"),\n-                    cx.ident_of(~\"serialize\"),\n-                    cx.ident_of(~\"Decoder\"),\n+                    cx.ident_of(\"std\"),\n+                    cx.ident_of(\"serialize\"),\n+                    cx.ident_of(\"Decoder\"),\n                 ]\n             )\n         )\n@@ -62,13 +62,13 @@ fn create_derived_decodable_impl(\n     let trait_path = build::mk_raw_path_global_(\n         span,\n         ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialize\"),\n-            cx.ident_of(~\"Decodable\")\n+            cx.ident_of(\"std\"),\n+            cx.ident_of(\"serialize\"),\n+            cx.ident_of(\"Decodable\")\n         ],\n         None,\n         ~[\n-            build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\"))\n+            build::mk_simple_ty_path(cx, span, cx.ident_of(\"__D\"))\n         ]\n     );\n     create_derived_impl(\n@@ -96,11 +96,11 @@ fn create_decode_method(\n     let d_arg_type = build::mk_ty_rptr(\n         cx,\n         span,\n-        build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\")),\n+        build::mk_simple_ty_path(cx, span, cx.ident_of(\"__D\")),\n         None,\n         ast::m_mutbl\n     );\n-    let d_ident = cx.ident_of(~\"__d\");\n+    let d_ident = cx.ident_of(\"__d\");\n     let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n \n     // Create the type of the return value.\n@@ -120,7 +120,7 @@ fn create_decode_method(\n \n     // Create the method.\n     let self_ty = spanned { node: sty_static, span: span };\n-    let method_ident = cx.ident_of(~\"decode\");\n+    let method_ident = cx.ident_of(\"decode\");\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n@@ -148,14 +148,14 @@ fn call_substructure_decode_method(\n             cx,\n             span,\n             ~[\n-                cx.ident_of(~\"std\"),\n-                cx.ident_of(~\"serialize\"),\n-                cx.ident_of(~\"Decodable\"),\n-                cx.ident_of(~\"decode\"),\n+                cx.ident_of(\"std\"),\n+                cx.ident_of(\"serialize\"),\n+                cx.ident_of(\"Decodable\"),\n+                cx.ident_of(\"decode\"),\n             ]\n         ),\n         ~[\n-            build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")])\n+            build::mk_path(cx, span, ~[cx.ident_of(\"__d\")])\n         ]\n     )\n }\n@@ -223,14 +223,14 @@ fn create_read_struct_field(\n \n     let d_arg = build::mk_arg(cx,\n                               span,\n-                              cx.ident_of(~\"__d\"),\n+                              cx.ident_of(\"__d\"),\n                               build::mk_ty_infer(cx, span));\n \n     let call_expr = build::mk_method_call(\n         cx,\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n-        cx.ident_of(~\"read_struct_field\"),\n+        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.ident_of(\"read_struct_field\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(ident)),\n             build::mk_uint(cx, span, idx),\n@@ -257,8 +257,8 @@ fn create_read_struct_arg(\n     let call_expr = build::mk_method_call(\n         cx,\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n-        cx.ident_of(~\"read_struct_arg\"),\n+        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.ident_of(\"read_struct_arg\"),\n         ~[\n             build::mk_uint(cx, span, idx),\n             build::mk_lambda_no_args(cx, span, decode_expr),\n@@ -295,7 +295,7 @@ fn expand_deriving_decodable_struct_method(\n \n     let d_arg = build::mk_arg(cx,\n                               span,\n-                              cx.ident_of(~\"__d\"),\n+                              cx.ident_of(\"__d\"),\n                               build::mk_ty_infer(cx, span));\n \n     let read_struct_expr = build::mk_method_call(\n@@ -304,9 +304,9 @@ fn expand_deriving_decodable_struct_method(\n         build::mk_path(\n             cx,\n             span,\n-            ~[cx.ident_of(~\"__d\")]\n+            ~[cx.ident_of(\"__d\")]\n         ),\n-        cx.ident_of(~\"read_struct\"),\n+        cx.ident_of(\"read_struct\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n             build::mk_uint(cx, span, fields.len()),\n@@ -353,15 +353,15 @@ fn create_read_variant_arg(\n \n             let d_arg = build::mk_arg(cx,\n                                       span,\n-                                      cx.ident_of(~\"__d\"),\n+                                      cx.ident_of(\"__d\"),\n                                       build::mk_ty_infer(cx, span));\n             let t_infer = build::mk_ty_infer(cx, span);\n \n             let call_expr = build::mk_method_call(\n                 cx,\n                 span,\n-                build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n-                cx.ident_of(~\"read_enum_variant_arg\"),\n+                build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+                cx.ident_of(\"read_enum_variant_arg\"),\n                 ~[\n                     build::mk_uint(cx, span, j),\n                     build::mk_lambda(cx,\n@@ -416,8 +416,8 @@ fn create_read_enum_variant(\n     build::mk_method_call(\n         cx,\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n-        cx.ident_of(~\"read_enum_variant\"),\n+        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.ident_of(\"read_enum_variant\"),\n         ~[\n             expr_arm_names,\n             build::mk_lambda(\n@@ -428,13 +428,13 @@ fn create_read_enum_variant(\n                         build::mk_arg(\n                             cx,\n                             span,\n-                            cx.ident_of(~\"__d\"),\n+                            cx.ident_of(\"__d\"),\n                             build::mk_ty_infer(cx, span)\n                         ),\n                         build::mk_arg(\n                             cx,\n                             span,\n-                            cx.ident_of(~\"__i\"),\n+                            cx.ident_of(\"__i\"),\n                             build::mk_ty_infer(cx, span)\n                         )\n                     ],\n@@ -444,7 +444,7 @@ fn create_read_enum_variant(\n                     cx,\n                     span,\n                     ast::expr_match(\n-                        build::mk_path(cx, span, ~[cx.ident_of(~\"__i\")]),\n+                        build::mk_path(cx, span, ~[cx.ident_of(\"__i\")]),\n                         arms\n                     )\n                 )\n@@ -468,15 +468,15 @@ fn expand_deriving_decodable_enum_method(\n \n     let d_arg = build::mk_arg(cx,\n                               span,\n-                              cx.ident_of(~\"__d\"),\n+                              cx.ident_of(\"__d\"),\n                               build::mk_ty_infer(cx, span));\n \n     // Create the read_enum expression\n     let read_enum_expr = build::mk_method_call(\n         cx,\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n-        cx.ident_of(~\"read_enum\"),\n+        build::mk_path(cx, span, ~[cx.ident_of(\"__d\")]),\n+        cx.ident_of(\"read_enum\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n             build::mk_lambda(cx,"}, {"sha": "2786c9c6eb5fc1e3663aa42d15765224cdd993bb", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -41,15 +41,15 @@ fn create_derived_encodable_impl(\n ) -> @item {\n     let encoder_ty_param = build::mk_ty_param(\n         cx,\n-        cx.ident_of(~\"__E\"),\n+        cx.ident_of(\"__E\"),\n         @opt_vec::with(\n             build::mk_trait_ty_param_bound_global(\n                 cx,\n                 span,\n                 ~[\n-                    cx.ident_of(~\"std\"),\n-                    cx.ident_of(~\"serialize\"),\n-                    cx.ident_of(~\"Encoder\"),\n+                    cx.ident_of(\"std\"),\n+                    cx.ident_of(\"serialize\"),\n+                    cx.ident_of(\"Encoder\"),\n                 ]\n             )\n         )\n@@ -62,13 +62,13 @@ fn create_derived_encodable_impl(\n     let trait_path = build::mk_raw_path_global_(\n         span,\n         ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialize\"),\n-            cx.ident_of(~\"Encodable\")\n+            cx.ident_of(\"std\"),\n+            cx.ident_of(\"serialize\"),\n+            cx.ident_of(\"Encodable\")\n         ],\n         None,\n         ~[\n-            build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\"))\n+            build::mk_simple_ty_path(cx, span, cx.ident_of(\"__E\"))\n         ]\n     );\n     create_derived_impl(\n@@ -94,11 +94,11 @@ fn create_encode_method(\n     let e_arg_type = build::mk_ty_rptr(\n         cx,\n         span,\n-        build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\")),\n+        build::mk_simple_ty_path(cx, span, cx.ident_of(\"__E\")),\n         None,\n         ast::m_mutbl\n     );\n-    let e_arg = build::mk_arg(cx, span, cx.ident_of(~\"__e\"), e_arg_type);\n+    let e_arg = build::mk_arg(cx, span, cx.ident_of(\"__e\"), e_arg_type);\n \n     // Create the type of the return value.\n     let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n@@ -112,7 +112,7 @@ fn create_encode_method(\n \n     // Create the method.\n     let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"encode\");\n+    let method_ident = cx.ident_of(\"encode\");\n     @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n@@ -134,11 +134,11 @@ fn call_substructure_encode_method(\n     self_field: @expr\n ) -> @ast::expr {\n     // Gather up the parameters we want to chain along.\n-    let e_ident = cx.ident_of(~\"__e\");\n+    let e_ident = cx.ident_of(\"__e\");\n     let e_expr = build::mk_path(cx, span, ~[e_ident]);\n \n     // Call the substructure method.\n-    let encode_ident = cx.ident_of(~\"encode\");\n+    let encode_ident = cx.ident_of(\"encode\");\n     build::mk_method_call(\n         cx,\n         span,\n@@ -204,7 +204,7 @@ fn expand_deriving_encodable_struct_method(\n     type_ident: ident,\n     struct_def: &struct_def\n ) -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n+    let self_ident = cx.ident_of(\"self\");\n \n     // Create the body of the method.\n     let mut idx = 0;\n@@ -227,7 +227,7 @@ fn expand_deriving_encodable_struct_method(\n                     self_field\n                 );\n \n-                let e_ident = cx.ident_of(~\"__e\");\n+                let e_ident = cx.ident_of(\"__e\");\n                 let e_arg = build::mk_arg(cx,\n                                           span,\n                                           e_ident,\n@@ -243,8 +243,8 @@ fn expand_deriving_encodable_struct_method(\n                 let call_expr = build::mk_method_call(\n                     cx,\n                     span,\n-                    build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n-                    cx.ident_of(~\"emit_struct_field\"),\n+                    build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+                    cx.ident_of(\"emit_struct_field\"),\n                     ~[\n                         build::mk_base_str(cx, span, cx.str_of(ident)),\n                         build::mk_uint(cx, span, idx),\n@@ -266,7 +266,7 @@ fn expand_deriving_encodable_struct_method(\n \n     let e_arg = build::mk_arg(cx,\n                               span,\n-                              cx.ident_of(~\"__e\"),\n+                              cx.ident_of(\"__e\"),\n                               build::mk_ty_infer(cx, span));\n \n     let emit_struct_stmt = build::mk_method_call(\n@@ -275,9 +275,9 @@ fn expand_deriving_encodable_struct_method(\n         build::mk_path(\n             cx,\n             span,\n-            ~[cx.ident_of(~\"__e\")]\n+            ~[cx.ident_of(\"__e\")]\n         ),\n-        cx.ident_of(~\"emit_struct\"),\n+        cx.ident_of(\"emit_struct\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n             build::mk_uint(cx, span, statements.len()),\n@@ -305,7 +305,7 @@ fn expand_deriving_encodable_enum_method(\n     // Create the arms of the match in the method body.\n     let arms = do enum_definition.variants.mapi |i, variant| {\n         // Create the matching pattern.\n-        let (pat, fields) = create_enum_variant_pattern(cx, span, variant, ~\"__self\", ast::m_imm);\n+        let (pat, fields) = create_enum_variant_pattern(cx, span, variant, \"__self\", ast::m_imm);\n \n         // Feed the discriminant to the encode function.\n         let mut stmts = ~[];\n@@ -317,7 +317,7 @@ fn expand_deriving_encodable_enum_method(\n             // Call the substructure method.\n             let expr = call_substructure_encode_method(cx, span, field);\n \n-            let e_ident = cx.ident_of(~\"__e\");\n+            let e_ident = cx.ident_of(\"__e\");\n             let e_arg = build::mk_arg(cx,\n                                       span,\n                                       e_ident,\n@@ -333,8 +333,8 @@ fn expand_deriving_encodable_enum_method(\n             let call_expr = build::mk_method_call(\n                 cx,\n                 span,\n-                build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n-                cx.ident_of(~\"emit_enum_variant_arg\"),\n+                build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+                cx.ident_of(\"emit_enum_variant_arg\"),\n                 ~[\n                     build::mk_uint(cx, span, j),\n                     blk_expr,\n@@ -347,13 +347,13 @@ fn expand_deriving_encodable_enum_method(\n         // Create the pattern body.\n         let e_arg = build::mk_arg(cx,\n                                   span,\n-                                  cx.ident_of(~\"__e\"),\n+                                  cx.ident_of(\"__e\"),\n                                   build::mk_ty_infer(cx, span));\n         let call_expr = build::mk_method_call(\n             cx,\n             span,\n-            build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n-            cx.ident_of(~\"emit_enum_variant\"),\n+            build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+            cx.ident_of(\"emit_enum_variant\"),\n             ~[\n                 build::mk_base_str(cx, span, cx.str_of(variant.node.name)),\n                 build::mk_uint(cx, span, i),\n@@ -377,7 +377,7 @@ fn expand_deriving_encodable_enum_method(\n         }\n     };\n \n-    let e_ident = cx.ident_of(~\"__e\");\n+    let e_ident = cx.ident_of(\"__e\");\n     let e_arg = build::mk_arg(cx,\n                               span,\n                               e_ident,\n@@ -394,8 +394,8 @@ fn expand_deriving_encodable_enum_method(\n     let call_expr = build::mk_method_call(\n         cx,\n         span,\n-        build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n-        cx.ident_of(~\"emit_enum\"),\n+        build::mk_path(cx, span, ~[cx.ident_of(\"__e\")]),\n+        cx.ident_of(\"emit_enum\"),\n         ~[\n             build::mk_base_str(cx, span, cx.str_of(type_ident)),\n             lambda_expr,"}, {"sha": "78eacafe3d75cc3b211770c1a9515afb2381c90c", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -263,7 +263,7 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n                              span: span,\n                              struct_ident: ident,\n                              struct_def: &struct_def,\n-                             prefix: ~str,\n+                             prefix: &str,\n                              mutbl: ast::mutability)\n     -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n     if struct_def.fields.is_empty() {\n@@ -323,7 +323,7 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n                                    span: span,\n                                    variant: &ast::variant,\n-                                   prefix: ~str,\n+                                   prefix: &str,\n                                    mutbl: ast::mutability)\n     -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n \n@@ -371,7 +371,7 @@ pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n-    let self_ident = cx.ident_of(~\"self\");\n+    let self_ident = cx.ident_of(\"self\");\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, ast::deref, self_expr);\n     let self_match_expr = ast::expr_match(self_expr, arms);"}, {"sha": "9030be86f39d01199fd9a1fd870330285cbc6c0d", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -53,10 +53,10 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n     };\n     let rand_ident = ~[\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"rand\"),\n-        cx.ident_of(~\"Rand\"),\n-        cx.ident_of(~\"rand\")\n+        cx.ident_of(\"core\"),\n+        cx.ident_of(\"rand\"),\n+        cx.ident_of(\"Rand\"),\n+        cx.ident_of(\"rand\")\n     ];\n     let rand_call = || {\n         build::mk_call_global(cx,\n@@ -77,8 +77,8 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n             let variant_count = build::mk_uint(cx, span, variants.len());\n \n             // need to specify the uint-ness of the random number\n-            let u32_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(~\"uint\")]);\n-            let r_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(~\"R\")]);\n+            let u32_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(\"uint\")]);\n+            let r_ty = build::mk_ty_path(cx, span, ~[cx.ident_of(\"R\")]);\n             let rand_name = build::mk_raw_path_(span, copy rand_ident, None, ~[ u32_ty, r_ty ]);\n             let rand_name = build::mk_path_raw(cx, span, rand_name);\n "}, {"sha": "6010354349e64b1bb56144259f0308e00479c437", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -44,11 +44,11 @@ fn to_str_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @exp\n         [self_obj] => {\n             let self_addr = build::mk_addr_of(cx, span, self_obj);\n             build::mk_call_global(cx, span,\n-                                  ~[cx.ident_of(~\"core\"),\n-                                    cx.ident_of(~\"sys\"),\n-                                    cx.ident_of(~\"log_str\")],\n+                                  ~[cx.ident_of(\"core\"),\n+                                    cx.ident_of(\"sys\"),\n+                                    cx.ident_of(\"log_str\")],\n                                   ~[self_addr])\n         }\n         _ => cx.span_bug(span, ~\"Invalid number of arguments in `deriving(ToStr)`\")\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "08947efa7b78b20dbbaa99f2e8e0012e82ee642f", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -218,7 +218,7 @@ pub impl LifetimeBounds {\n \n pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: Option<PtrTy>)\n     -> (@expr, ast::self_ty) {\n-    let self_path = build::mk_path(cx, span, ~[cx.ident_of(~\"self\")]);\n+    let self_path = build::mk_path(cx, span, ~[cx.ident_of(\"self\")]);\n     match self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))"}, {"sha": "1a8edec37145cc9c4a5e5e7ab14c35b54f98117b", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -49,12 +49,12 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(cx: @ext_ctxt, ident: @~str) -> ~[ast::ident] {\n+    fn make_path_vec(cx: @ext_ctxt, ident: &str) -> ~[ast::ident] {\n         let intr = cx.parse_sess().interner;\n-        return ~[intr.intern(@~\"unstable\"), intr.intern(@~\"extfmt\"),\n-                 intr.intern(@~\"rt\"), intr.intern(ident)];\n+        return ~[intr.intern(\"unstable\"), intr.intern(\"extfmt\"),\n+                 intr.intern(\"rt\"), intr.intern(ident)];\n     }\n-    fn make_rt_path_expr(cx: @ext_ctxt, sp: span, nm: @~str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: @ext_ctxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n         return mk_path_global(cx, sp, path);\n     }\n@@ -63,46 +63,45 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n \n     fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n         fn make_flags(cx: @ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n-            let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n+            let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for flags.each |f| {\n                 let fstr = match *f {\n-                  FlagLeftJustify => ~\"flag_left_justify\",\n-                  FlagLeftZeroPad => ~\"flag_left_zero_pad\",\n-                  FlagSpaceForSign => ~\"flag_space_for_sign\",\n-                  FlagSignAlways => ~\"flag_sign_always\",\n-                  FlagAlternate => ~\"flag_alternate\"\n+                  FlagLeftJustify => \"flag_left_justify\",\n+                  FlagLeftZeroPad => \"flag_left_zero_pad\",\n+                  FlagSpaceForSign => \"flag_space_for_sign\",\n+                  FlagSignAlways => \"flag_sign_always\",\n+                  FlagAlternate => \"flag_alternate\"\n                 };\n                 tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n-                                     make_rt_path_expr(cx, sp, @fstr));\n+                                     make_rt_path_expr(cx, sp, fstr));\n             }\n             return tmp_expr;\n         }\n         fn make_count(cx: @ext_ctxt, sp: span, cnt: Count) -> @ast::expr {\n             match cnt {\n               CountImplied => {\n-                return make_rt_path_expr(cx, sp, @~\"CountImplied\");\n+                return make_rt_path_expr(cx, sp, \"CountImplied\");\n               }\n               CountIs(c) => {\n                 let count_lit = mk_uint(cx, sp, c as uint);\n-                let count_is_path = make_path_vec(cx, @~\"CountIs\");\n+                let count_is_path = make_path_vec(cx, \"CountIs\");\n                 let count_is_args = ~[count_lit];\n                 return mk_call_global(cx, sp, count_is_path, count_is_args);\n               }\n               _ => cx.span_unimpl(sp, ~\"unimplemented fmt! conversion\")\n             }\n         }\n         fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n-            let rt_type;\n-            match t {\n+            let rt_type = match t {\n               TyHex(c) => match c {\n-                CaseUpper => rt_type = ~\"TyHexUpper\",\n-                CaseLower => rt_type = ~\"TyHexLower\"\n+                CaseUpper =>  \"TyHexUpper\",\n+                CaseLower =>  \"TyHexLower\"\n               },\n-              TyBits => rt_type = ~\"TyBits\",\n-              TyOctal => rt_type = ~\"TyOctal\",\n-              _ => rt_type = ~\"TyDefault\"\n-            }\n-            return make_rt_path_expr(cx, sp, @rt_type);\n+              TyBits =>  \"TyBits\",\n+              TyOctal =>  \"TyOctal\",\n+              _ =>  \"TyDefault\"\n+            };\n+            return make_rt_path_expr(cx, sp, rt_type);\n         }\n         fn make_conv_struct(cx: @ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n@@ -111,19 +110,19 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             mk_global_struct_e(\n                 cx,\n                 sp,\n-                make_path_vec(cx, @~\"Conv\"),\n+                make_path_vec(cx, \"Conv\"),\n                 ~[\n                     build::Field {\n-                        ident: intr.intern(@~\"flags\"), ex: flags_expr\n+                        ident: intr.intern(\"flags\"), ex: flags_expr\n                     },\n                     build::Field {\n-                        ident: intr.intern(@~\"width\"), ex: width_expr\n+                        ident: intr.intern(\"width\"), ex: width_expr\n                     },\n                     build::Field {\n-                        ident: intr.intern(@~\"precision\"), ex: precision_expr\n+                        ident: intr.intern(\"precision\"), ex: precision_expr\n                     },\n                     build::Field {\n-                        ident: intr.intern(@~\"ty\"), ex: ty_expr\n+                        ident: intr.intern(\"ty\"), ex: ty_expr\n                     },\n                 ]\n             )\n@@ -138,7 +137,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: &str, cnv: &Conv,\n                       arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n-        let path = make_path_vec(cx, @fname);\n+        let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg, buf];\n         return mk_call_global(cx, arg.span, path, args);\n@@ -259,10 +258,10 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     let nargs = args.len();\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n-    let ident = cx.parse_sess().interner.intern(@~\"__fmtbuf\");\n+    let ident = cx.parse_sess().interner.intern(\"__fmtbuf\");\n     let buf = || mk_path(cx, fmt_sp, ~[ident]);\n-    let str_ident = cx.parse_sess().interner.intern(@~\"str\");\n-    let push_ident = cx.parse_sess().interner.intern(@~\"push_str\");\n+    let str_ident = cx.parse_sess().interner.intern(\"str\");\n+    let push_ident = cx.parse_sess().interner.intern(\"push_str\");\n     let mut stms = ~[];\n \n     /* Translate each piece (portion of the fmt expression) by invoking the"}, {"sha": "a5148287258668e31630538f4c1c526ede8e37da", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -138,9 +138,9 @@ pub trait ext_ctxt_ast_builder {\n impl ext_ctxt_ast_builder for @ext_ctxt {\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n-            self.ident_of(~\"core\"),\n-            self.ident_of(~\"option\"),\n-            self.ident_of(~\"Option\")\n+            self.ident_of(\"core\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"Option\")\n         ], dummy_sp()).add_ty(ty))\n     }\n \n@@ -360,12 +360,12 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         let vi = ast::view_item_use(~[\n             @codemap::spanned {\n                 node: ast::view_path_simple(\n-                    self.ident_of(~\"Owned\"),\n+                    self.ident_of(\"Owned\"),\n                     path(\n                         ~[\n-                            self.ident_of(~\"core\"),\n-                            self.ident_of(~\"kinds\"),\n-                            self.ident_of(~\"Owned\")\n+                            self.ident_of(\"core\"),\n+                            self.ident_of(\"kinds\"),\n+                            self.ident_of(\"Owned\")\n                         ],\n                         codemap::dummy_sp()\n                     ),"}, {"sha": "b537ef87d543f025ba3a46b7e4184270605ff62d", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -58,7 +58,7 @@ impl gen_send for message {\n                 path(~[this.data_name()], span)\n                 .add_tys(cx.ty_vars_global(&this.generics.ty_params)));\n             let args_ast = vec::append(\n-                ~[cx.arg(cx.ident_of(~\"pipe\"),\n+                ~[cx.arg(cx.ident_of(\"pipe\"),\n                               pipe_ty)],\n                 args_ast);\n \n@@ -136,7 +136,7 @@ impl gen_send for message {\n                 };\n \n                 let args_ast = vec::append(\n-                    ~[cx.arg(cx.ident_of(~\"pipe\"),\n+                    ~[cx.arg(cx.ident_of(\"pipe\"),\n                              cx.ty_path_ast_builder(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars_global(\n@@ -212,8 +212,8 @@ impl to_type_decls for state {\n                 let next_name = cx.str_of(next.data_name());\n \n                 let dir = match this.dir {\n-                  send => ~\"server\",\n-                  recv => ~\"client\"\n+                  send => \"server\",\n+                  recv => \"client\"\n                 };\n \n                 vec::append_one(tys,\n@@ -265,12 +265,12 @@ impl to_type_decls for state {\n                     self.data_name(),\n                     self.span,\n                     cx.ty_path_ast_builder(\n-                        path_global(~[cx.ident_of(~\"core\"),\n-                                      cx.ident_of(~\"pipes\"),\n-                                      cx.ident_of(dir.to_str() + ~\"Packet\")],\n+                        path_global(~[cx.ident_of(\"core\"),\n+                                      cx.ident_of(\"pipes\"),\n+                                      cx.ident_of(dir.to_str() + \"Packet\")],\n                              dummy_sp())\n                         .add_ty(cx.ty_path_ast_builder(\n-                            path(~[cx.ident_of(~\"super\"),\n+                            path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                  dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n@@ -283,13 +283,13 @@ impl to_type_decls for state {\n                     self.data_name(),\n                     self.span,\n                     cx.ty_path_ast_builder(\n-                        path_global(~[cx.ident_of(~\"core\"),\n-                                      cx.ident_of(~\"pipes\"),\n+                        path_global(~[cx.ident_of(\"core\"),\n+                                      cx.ident_of(\"pipes\"),\n                                       cx.ident_of(dir.to_str()\n-                                                  + ~\"PacketBuffered\")],\n+                                                  + \"PacketBuffered\")],\n                              dummy_sp())\n                         .add_tys(~[cx.ty_path_ast_builder(\n-                            path(~[cx.ident_of(~\"super\"),\n+                            path(~[cx.ident_of(\"super\"),\n                                    self.data_name()],\n                                         dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n@@ -341,7 +341,7 @@ impl gen_init for protocol {\n     }\n \n     fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n-        ext_cx.struct_expr(path(~[ext_cx.ident_of(~\"__Buffer\")],\n+        ext_cx.struct_expr(path(~[ext_cx.ident_of(\"__Buffer\")],\n                                 dummy_sp()),\n                       self.states.map_to_vec(|s| {\n             let fty = s.to_ty(ext_cx);\n@@ -389,8 +389,8 @@ impl gen_init for protocol {\n             }\n         }\n \n-        cx.ty_path_ast_builder(path(~[cx.ident_of(~\"super\"),\n-                                      cx.ident_of(~\"__Buffer\")],\n+        cx.ty_path_ast_builder(path(~[cx.ident_of(\"super\"),\n+                                      cx.ident_of(\"__Buffer\")],\n                                     copy self.span)\n                                .add_tys(cx.ty_vars_global(&params)))\n     }\n@@ -427,7 +427,7 @@ impl gen_init for protocol {\n         };\n \n         cx.item_struct_poly(\n-            cx.ident_of(~\"__Buffer\"),\n+            cx.ident_of(\"__Buffer\"),\n             dummy_sp(),\n             ast::struct_def {\n                 fields: fields,\n@@ -452,13 +452,13 @@ impl gen_init for protocol {\n             items.push(self.gen_buffer_type(cx))\n         }\n \n-        items.push(cx.item_mod(cx.ident_of(~\"client\"),\n+        items.push(cx.item_mod(cx.ident_of(\"client\"),\n                                copy self.span,\n                                client_states));\n-        items.push(cx.item_mod(cx.ident_of(~\"server\"),\n+        items.push(cx.item_mod(cx.ident_of(\"server\"),\n                                copy self.span,\n                                server_states));\n \n-        cx.item_mod(cx.ident_of(self.name), copy self.span, items)\n+        cx.item_mod(cx.ident_of(copy self.name), copy self.span, items)\n     }\n }"}, {"sha": "f133347d948f888c5d69fc3a991021f5610464a5", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -377,55 +377,55 @@ pub fn expand_quote_tokens(cx: @ext_ctxt,\n pub fn expand_quote_expr(cx: @ext_ctxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    base::MRExpr(expand_parse_call(cx, sp, ~\"parse_expr\", ~[], tts))\n+    base::MRExpr(expand_parse_call(cx, sp, \"parse_expr\", ~[], tts))\n }\n \n pub fn expand_quote_item(cx: @ext_ctxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n-    base::MRExpr(expand_parse_call(cx, sp, ~\"parse_item\",\n+    base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n pub fn expand_quote_pat(cx: @ext_ctxt,\n                         sp: span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n-    base::MRExpr(expand_parse_call(cx, sp, ~\"parse_pat\",\n+    base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n pub fn expand_quote_ty(cx: @ext_ctxt,\n                        sp: span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n-    base::MRExpr(expand_parse_call(cx, sp, ~\"parse_ty\",\n+    base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n pub fn expand_quote_stmt(cx: @ext_ctxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n-    base::MRExpr(expand_parse_call(cx, sp, ~\"parse_stmt\",\n+    base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n \n fn ids_ext(cx: @ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(@copy *str))\n+    strs.map(|str| cx.parse_sess().interner.intern(*str))\n }\n \n-fn id_ext(cx: @ext_ctxt, str: ~str) -> ast::ident {\n-    cx.parse_sess().interner.intern(@str)\n+fn id_ext(cx: @ext_ctxt, str: &str) -> ast::ident {\n+    cx.parse_sess().interner.intern(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n     let e_str = build::mk_uniq_str(cx, sp, cx.str_of(ident));\n     build::mk_method_call(cx, sp,\n                           build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                          id_ext(cx, ~\"ident_of\"),\n+                          id_ext(cx, \"ident_of\"),\n                           ~[e_str])\n }\n \n@@ -616,7 +616,7 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             let e_push =\n                 build::mk_method_call(cx, sp,\n                                       build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n-                                      id_ext(cx, ~\"push\"),\n+                                      id_ext(cx, \"push\"),\n                                       ~[e_tok]);\n             ~[build::mk_stmt(cx, sp, e_push)]\n \n@@ -632,14 +632,14 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             let e_to_toks =\n                 build::mk_method_call(cx, sp,\n                                       build::mk_path(cx, sp, ~[ident]),\n-                                      id_ext(cx, ~\"to_tokens\"),\n+                                      id_ext(cx, \"to_tokens\"),\n                                       ~[build::mk_path(cx, sp,\n                                                        ids_ext(cx, ~[~\"ext_cx\"]))]);\n \n             let e_push =\n                 build::mk_method_call(cx, sp,\n                                       build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),\n-                                      id_ext(cx, ~\"push_all_move\"),\n+                                      id_ext(cx, \"push_all_move\"),\n                                       ~[e_to_toks]);\n \n             ~[build::mk_stmt(cx, sp, e_push)]\n@@ -711,15 +711,15 @@ fn expand_tts(cx: @ext_ctxt,\n \n     let e_sp = build::mk_method_call(cx, sp,\n                                      build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-                                     id_ext(cx, ~\"call_site\"),\n+                                     id_ext(cx, \"call_site\"),\n                                      ~[]);\n \n     let stmt_let_sp = build::mk_local(cx, sp, false,\n-                                      id_ext(cx, ~\"sp\"),\n+                                      id_ext(cx, \"sp\"),\n                                       e_sp);\n \n     let stmt_let_tt = build::mk_local(cx, sp, true,\n-                                      id_ext(cx, ~\"tt\"),\n+                                      id_ext(cx, \"tt\"),\n                                       build::mk_uniq_vec_e(cx, sp, ~[]));\n \n     build::mk_block(cx, sp, uses,\n@@ -731,18 +731,18 @@ fn expand_tts(cx: @ext_ctxt,\n \n fn expand_parse_call(cx: @ext_ctxt,\n                      sp: span,\n-                     parse_method: ~str,\n+                     parse_method: &str,\n                      arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n \n     let cfg_call = || build::mk_method_call(\n         cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-        id_ext(cx, ~\"cfg\"), ~[]);\n+        id_ext(cx, \"cfg\"), ~[]);\n \n     let parse_sess_call = || build::mk_method_call(\n         cx, sp, build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n-        id_ext(cx, ~\"parse_sess\"), ~[]);\n+        id_ext(cx, \"parse_sess\"), ~[]);\n \n     let new_parser_call =\n         build::mk_call_global(cx, sp,"}, {"sha": "fc00fd12848183426c82d6ecd487ef5f5a4213e3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -36,8 +36,8 @@ pub fn add_new_extension(cx: @ext_ctxt,\n         spanned { node: copy m, span: dummy_sp() }\n     }\n \n-    let lhs_nm =  cx.parse_sess().interner.gensym(@~\"lhs\");\n-    let rhs_nm =  cx.parse_sess().interner.gensym(@~\"rhs\");\n+    let lhs_nm =  cx.parse_sess().interner.gensym(\"lhs\");\n+    let rhs_nm =  cx.parse_sess().interner.gensym(\"rhs\");\n \n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+"}, {"sha": "764dec0eeb391775ef5901fa0a310f36dc042125", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -271,7 +271,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                 // but comments with only \"/\"s are not\n                 if !is_line_non_doc_comment(acc) {\n                     return Some(TokenAndSpan{\n-                        tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n+                        tok: token::DOC_COMMENT(rdr.interner.intern(acc)),\n                         sp: codemap::mk_sp(start_bpos, rdr.pos)\n                     });\n                 }\n@@ -325,7 +325,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             // but comments with only \"*\"s between two \"/\"s are not\n             if !is_block_non_doc_comment(acc) {\n                 return Some(TokenAndSpan{\n-                    tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n+                    tok: token::DOC_COMMENT(rdr.interner.intern(acc)),\n                     sp: codemap::mk_sp(start_bpos, rdr.pos)\n                 });\n             }\n@@ -467,12 +467,12 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(rdr.interner.intern(@num_str),\n+            return token::LIT_FLOAT(rdr.interner.intern(num_str),\n                                  ast::ty_f32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(rdr.interner.intern(@num_str),\n+            return token::LIT_FLOAT(rdr.interner.intern(num_str),\n                                  ast::ty_f64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n@@ -484,9 +484,9 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         if is_machine_float {\n-            return token::LIT_FLOAT(rdr.interner.intern(@num_str), ast::ty_f);\n+            return token::LIT_FLOAT(rdr.interner.intern(num_str), ast::ty_f);\n         }\n-        return token::LIT_FLOAT_UNSUFFIXED(rdr.interner.intern(@num_str));\n+        return token::LIT_FLOAT_UNSUFFIXED(rdr.interner.intern(num_str));\n     } else {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n@@ -548,7 +548,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n-        return token::IDENT(rdr.interner.intern(@accum_str), is_mod_name);\n+        return token::IDENT(rdr.interner.intern(accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n@@ -658,7 +658,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 lifetime_name.push_char(rdr.curr);\n                 bump(rdr);\n             }\n-            return token::LIFETIME(rdr.interner.intern(@lifetime_name));\n+            return token::LIFETIME(rdr.interner.intern(lifetime_name));\n         }\n \n         // Otherwise it is a character constant:\n@@ -731,7 +731,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             }\n         }\n         bump(rdr);\n-        return token::LIT_STR(rdr.interner.intern(@accum_str));\n+        return token::LIT_STR(rdr.interner.intern(accum_str));\n       }\n       '-' => {\n         if nextch(rdr) == '>' {\n@@ -799,7 +799,7 @@ mod test {\n         let Env {interner: ident_interner, string_reader} =\n             setup(~\"/* my source file */ \\\n                     fn main() { io::println(~\\\"zebra\\\"); }\\n\");\n-        let id = ident_interner.intern(@~\"fn\");\n+        let id = ident_interner.intern(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n@@ -810,7 +810,7 @@ mod test {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n-            tok:token::IDENT(ident_interner.intern (@~\"main\"), false),\n+            tok:token::IDENT(ident_interner.intern(\"main\"), false),\n             sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n@@ -828,39 +828,39 @@ mod test {\n     }\n \n     // make the identifier by looking up the string in the interner\n-    fn mk_ident (env: Env, id: ~str, is_mod_name: bool) -> token::Token {\n-        token::IDENT (env.interner.intern(@id),is_mod_name)\n+    fn mk_ident (env: Env, id: &str, is_mod_name: bool) -> token::Token {\n+        token::IDENT (env.interner.intern(id),is_mod_name)\n     }\n \n     #[test] fn doublecolonparsing () {\n         let env = setup (~\"a b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,~\"a\",false),\n-                             mk_ident (env,~\"b\",false)]);\n+                           ~[mk_ident (env,\"a\",false),\n+                             mk_ident (env,\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n         let env = setup (~\"a::b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,~\"a\",true),\n+                           ~[mk_ident (env,\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident (env,~\"b\",false)]);\n+                             mk_ident (env,\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n         let env = setup (~\"a ::b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,~\"a\",false),\n+                           ~[mk_ident (env,\"a\",false),\n                              token::MOD_SEP,\n-                             mk_ident (env,~\"b\",false)]);\n+                             mk_ident (env,\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n         let env = setup (~\"a:: b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,~\"a\",true),\n+                           ~[mk_ident (env,\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident (env,~\"b\",false)]);\n+                             mk_ident (env,\"b\",false)]);\n     }\n \n     #[test] fn character_a() {\n@@ -888,7 +888,7 @@ mod test {\n         let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        let id = env.interner.intern(@~\"abc\");\n+        let id = env.interner.intern(\"abc\");\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n }"}, {"sha": "ce41d377346cc341ad6780cddc39721ad24d5fcf", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -375,13 +375,13 @@ mod test {\n \n         assert!(i.len() < 100);\n         for int::range(0,100-((i.len()).to_int())) |_dc| {\n-            i.gensym(@~\"dontcare\");\n+            i.gensym(\"dontcare\");\n         }\n-        i.intern(@~\"a\");\n-        i.intern(@~\"b\");\n-        i.intern(@~\"c\");\n-        i.intern(@~\"d\");\n-        i.intern(@~\"return\");\n+        i.intern(\"a\");\n+        i.intern(\"b\");\n+        i.intern(\"c\");\n+        i.intern(\"d\");\n+        i.intern(\"return\");\n         assert!(i.get(ast::ident{repr:101,ctxt:0}) == @~\"b\");\n         i\n     }"}, {"sha": "4483cc42361cce09fca0fc12308e7576b7f1c1e9", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use ast_util;\n use parse::token;\n-use util::interner::Interner;\n+use util::interner::StrInterner;\n use util::interner;\n \n use core::cmp::Equiv;\n@@ -390,14 +390,14 @@ pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n }\n \n pub struct ident_interner {\n-    priv interner: Interner<@~str>,\n+    priv interner: StrInterner,\n }\n \n pub impl ident_interner {\n-    fn intern(&self, val: @~str) -> ast::ident {\n+    fn intern(&self, val: &str) -> ast::ident {\n         ast::ident { repr: self.interner.intern(val), ctxt: 0 }\n     }\n-    fn gensym(&self, val: @~str) -> ast::ident {\n+    fn gensym(&self, val: &str) -> ast::ident {\n         ast::ident { repr: self.interner.gensym(val), ctxt: 0 }\n     }\n     fn get(&self, idx: ast::ident) -> @~str {\n@@ -421,45 +421,45 @@ pub fn mk_fresh_ident_interner() -> @ident_interner {\n     // the indices here must correspond to the numbers in\n     // special_idents.\n     let init_vec = ~[\n-        @~\"_\",                  // 0\n-        @~\"anon\",               // 1\n-        @~\"\",                   // 2\n-        @~\"unary\",              // 3\n-        @~\"!\",                  // 4\n-        @~\"[]\",                 // 5\n-        @~\"unary-\",             // 6\n-        @~\"__extensions__\",     // 7\n-        @~\"self\",               // 8\n-        @~\"item\",               // 9\n-        @~\"block\",              // 10\n-        @~\"stmt\",               // 11\n-        @~\"pat\",                // 12\n-        @~\"expr\",               // 13\n-        @~\"ty\",                 // 14\n-        @~\"ident\",              // 15\n-        @~\"path\",               // 16\n-        @~\"tt\",                 // 17\n-        @~\"matchers\",           // 18\n-        @~\"str\",                // 19\n-        @~\"TyVisitor\",          // 20\n-        @~\"arg\",                // 21\n-        @~\"descrim\",            // 22\n-        @~\"__rust_abi\",         // 23\n-        @~\"__rust_stack_shim\",  // 24\n-        @~\"TyDesc\",             // 25\n-        @~\"main\",               // 26\n-        @~\"<opaque>\",           // 27\n-        @~\"blk\",                // 28\n-        @~\"static\",             // 29\n-        @~\"intrinsic\",          // 30\n-        @~\"__foreign_mod__\",    // 31\n-        @~\"__field__\",          // 32\n-        @~\"C\",                  // 33\n-        @~\"Self\",               // 34\n+        \"_\",                  // 0\n+        \"anon\",               // 1\n+        \"\",                   // 2\n+        \"unary\",              // 3\n+        \"!\",                  // 4\n+        \"[]\",                 // 5\n+        \"unary-\",             // 6\n+        \"__extensions__\",     // 7\n+        \"self\",               // 8\n+        \"item\",               // 9\n+        \"block\",              // 10\n+        \"stmt\",               // 11\n+        \"pat\",                // 12\n+        \"expr\",               // 13\n+        \"ty\",                 // 14\n+        \"ident\",              // 15\n+        \"path\",               // 16\n+        \"tt\",                 // 17\n+        \"matchers\",           // 18\n+        \"str\",                // 19\n+        \"TyVisitor\",          // 20\n+        \"arg\",                // 21\n+        \"descrim\",            // 22\n+        \"__rust_abi\",         // 23\n+        \"__rust_stack_shim\",  // 24\n+        \"TyDesc\",             // 25\n+        \"main\",               // 26\n+        \"<opaque>\",           // 27\n+        \"blk\",                // 28\n+        \"static\",             // 29\n+        \"intrinsic\",          // 30\n+        \"__foreign_mod__\",    // 31\n+        \"__field__\",          // 32\n+        \"C\",                  // 33\n+        \"Self\",               // 34\n     ];\n \n     let rv = @ident_interner {\n-        interner: interner::Interner::prefill(init_vec)\n+        interner: interner::StrInterner::prefill(init_vec)\n     };\n     unsafe {\n         task::local_data::local_data_set(interner_key!(), @rv);\n@@ -483,7 +483,7 @@ pub fn mk_ident_interner() -> @ident_interner {\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @ident_interner {\n-    @ident_interner { interner: interner::Interner::new() }\n+    @ident_interner { interner: interner::StrInterner::new() }\n }\n \n /**"}, {"sha": "81652f9c1a100e260b9070304c5d11f95e7cb822", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -2249,7 +2249,7 @@ mod test {\n     #[test]\n     fn test_fun_to_str() {\n         let mock_interner = parse::token::mk_fake_ident_interner();\n-        let abba_ident = mock_interner.intern(@~\"abba\");\n+        let abba_ident = mock_interner.intern(\"abba\");\n \n         let decl = ast::fn_decl {\n             inputs: ~[],\n@@ -2267,7 +2267,7 @@ mod test {\n     #[test]\n     fn test_variant_to_str() {\n         let mock_interner = parse::token::mk_fake_ident_interner();\n-        let ident = mock_interner.intern(@~\"principal_skinner\");\n+        let ident = mock_interner.intern(\"principal_skinner\");\n \n         let var = codemap::respan(codemap::dummy_sp(), ast::variant_ {\n             name: ident,"}, {"sha": "cca2ec89fd421e5d373162f06df14359740fee4b", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -17,6 +17,7 @@\n \n use core::cmp::Equiv;\n use core::hashmap::HashMap;\n+use syntax::parse::token::StringRef;\n \n pub struct Interner<T> {\n     priv map: @mut HashMap<T, uint>,\n@@ -77,6 +78,61 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     }\n }\n \n+pub struct StrInterner {\n+    priv map: @mut HashMap<@~str, uint>,\n+    priv vect: @mut ~[@~str],\n+}\n+\n+// when traits can extend traits, we should extend index<uint,T> to get []\n+pub impl StrInterner {\n+    fn new() -> StrInterner {\n+        StrInterner {\n+            map: @mut HashMap::new(),\n+            vect: @mut ~[],\n+        }\n+    }\n+\n+    fn prefill(init: &[&str]) -> StrInterner {\n+        let rv = StrInterner::new();\n+        for init.each() |v| { rv.intern(*v); }\n+        rv\n+    }\n+\n+    fn intern(&self, val: &str) -> uint {\n+        match self.map.find_equiv(&StringRef(val)) {\n+            Some(&idx) => return idx,\n+            None => (),\n+        }\n+\n+        let new_idx = self.len();\n+        self.map.insert(@val.to_owned(), new_idx);\n+        self.vect.push(@val.to_owned());\n+        new_idx\n+    }\n+\n+    fn gensym(&self, val: &str) -> uint {\n+        let new_idx = self.len();\n+        // leave out of .map to avoid colliding\n+        self.vect.push(@val.to_owned());\n+        new_idx\n+    }\n+\n+    // this isn't \"pure\" in the traditional sense, because it can go from\n+    // failing to returning a value as items are interned. But for typestate,\n+    // where we first check a pred and then rely on it, ceasing to fail is ok.\n+    fn get(&self, idx: uint) -> @~str { self.vect[idx] }\n+\n+    fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n+\n+    fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+                                              -> Option<uint> {\n+        match self.map.find_equiv(val) {\n+            Some(v) => Some(*v),\n+            None => None,\n+        }\n+    }\n+}\n+\n /* Key for thread-local data for sneaking interner information to the\n * encoder/decoder. It sounds like a hack because it is one.\n * Bonus ultra-hack: functions as keys don't work across crates,"}, {"sha": "1241190b5371f632e6f141f42b03b15bcd04c5c8", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -26,7 +26,7 @@ trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n     fn call_site() -> span;\n-    fn ident_of(st: ~str) -> ast::ident;\n+    fn ident_of(st: &str) -> ast::ident;\n }\n \n type fake_session = parse::parse_sess;\n@@ -41,8 +41,8 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(st: ~str) -> ast::ident {\n-        self.interner.intern(@st)\n+    fn ident_of(st: &str) -> ast::ident {\n+        self.interner.intern(st)\n     }\n }\n "}, {"sha": "07500825a952b505fefbff40ed582cc57a221b85", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -25,7 +25,7 @@ trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n     fn call_site() -> span;\n-    fn ident_of(st: ~str) -> ast::ident;\n+    fn ident_of(st: &str) -> ast::ident;\n }\n \n type fake_session = parse::parse_sess;\n@@ -40,8 +40,8 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(st: ~str) -> ast::ident {\n-        self.interner.intern(@st)\n+    fn ident_of(st: &str) -> ast::ident {\n+        self.interner.intern(st)\n     }\n }\n "}, {"sha": "84edb990a7598c04cdaaf6c577b484ff29be27ae", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=e9d0018abf8dd0c692db4cfe8f5d1bd1c150d643", "patch": "@@ -27,7 +27,7 @@ trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n     fn call_site() -> span;\n-    fn ident_of(st: ~str) -> ast::ident;\n+    fn ident_of(st: &str) -> ast::ident;\n }\n \n type fake_session = parse::parse_sess;\n@@ -42,8 +42,8 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(st: ~str) -> ast::ident {\n-        self.interner.intern(@copy st)\n+    fn ident_of(st: &str) -> ast::ident {\n+        self.interner.intern(st)\n     }\n }\n "}]}