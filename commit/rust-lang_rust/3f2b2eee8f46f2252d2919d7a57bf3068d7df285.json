{"sha": "3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "node_id": "C_kwDOAAsO6NoAKDNmMmIyZWVlOGY0NmYyMjUyZDI5MTlkN2E1N2JmMzA2OGQ3ZGYyODU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-23T06:48:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-23T06:48:56Z"}, "message": "Auto merge of #104758 - Manishearth:rollup-rh1tfum, r=Manishearth\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #103488 (Allow opaque types in trait impl headers and rely on coherence to reject unsound cases)\n - #104359 (Refactor must_use lint into two parts)\n - #104612 (Lower return type outside async block creation)\n - #104621 (Fix --extern library finding errors)\n - #104647 (enable fuzzy_provenance_casts lint in liballoc and libstd)\n - #104750 (Bump `fd-lock` in `bootstrap` again)\n\nFailed merges:\n\n - #104732 (Refactor `ty::ClosureKind` related stuff)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "67b05ad47483eb61c39a6f4b5b12862f9991462c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b05ad47483eb61c39a6f4b5b12862f9991462c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "html_url": "https://github.com/rust-lang/rust/commit/3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "008bc1d587b4f9d7197eb159922dd2080eea9284", "url": "https://api.github.com/repos/rust-lang/rust/commits/008bc1d587b4f9d7197eb159922dd2080eea9284", "html_url": "https://github.com/rust-lang/rust/commit/008bc1d587b4f9d7197eb159922dd2080eea9284"}, {"sha": "42afb70f2fc28c52656f49abf4566d17c09123ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/42afb70f2fc28c52656f49abf4566d17c09123ef", "html_url": "https://github.com/rust-lang/rust/commit/42afb70f2fc28c52656f49abf4566d17c09123ef"}], "stats": {"total": 1442, "additions": 902, "deletions": 540}, "files": [{"sha": "6855344356a1ff5651769ac4e219b539ff66a945", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -588,17 +588,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         capture_clause: CaptureBy,\n         closure_node_id: NodeId,\n-        ret_ty: Option<AstP<Ty>>,\n+        ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n-        let output = match ret_ty {\n-            Some(ty) => hir::FnRetTy::Return(\n-                self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock)),\n-            ),\n-            None => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n-        };\n+        let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n         // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n         // fully constrained by `future::from_generator`.\n@@ -1003,8 +998,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // Transform `async |x: u8| -> X { ... }` into\n             // `|x: u8| future_from_generator(|| -> X { ... })`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n-                let async_ret_ty =\n-                    if let FnRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n+                let async_ret_ty = if let FnRetTy::Ty(ty) = &decl.output {\n+                    let itctx = ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock);\n+                    Some(hir::FnRetTy::Return(this.lower_ty(&ty, &itctx)))\n+                } else {\n+                    None\n+                };\n+\n                 let async_body = this.make_async_expr(\n                     capture_clause,\n                     inner_closure_id,"}, {"sha": "b2702eafd33bd8cec66eca5c29241d2ea8417acd", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -2,9 +2,8 @@ use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRe\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Const, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n@@ -141,13 +140,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         );\n     }\n \n-    // We don't have to worry about the equality of consts during borrow checking\n-    // as consts always have a static lifetime.\n-    // FIXME(oli-obk): is this really true? We can at least have HKL and with\n-    // inline consts we may have further lifetimes that may be unsound to treat as\n-    // 'static.\n-    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {}\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }\n@@ -156,10 +148,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         true\n     }\n \n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: PredicateObligations<'tcx>,\n-    ) -> Result<(), TypeError<'tcx>> {\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.type_checker\n             .fully_perform_op(\n                 self.locations,\n@@ -172,6 +161,5 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 },\n             )\n             .unwrap();\n-        Ok(())\n     }\n }"}, {"sha": "d1e1fd54db9bf22bcacc11f105c8b56be3dc5c36", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -275,7 +275,7 @@ metadata_crate_location_unknown_type =\n     extern location for {$crate_name} is of an unknown type: {$path}\n \n metadata_lib_filename_form =\n-    file name should be lib*.rlib or {dll_prefix}*.{dll_suffix}\n+    file name should be lib*.rlib or {$dll_prefix}*{$dll_suffix}\n \n metadata_multiple_import_name_type =\n     multiple `import_name_type` arguments in a single `#[link]` attribute"}, {"sha": "e0b465bab16d9bb0f8790ab2c414a3a95f3d5fcc", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -244,6 +244,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         self.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -256,6 +260,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "d66b6585fb6f7c10d27304bc5741a88818145bef", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, DelayDm};\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n@@ -47,58 +46,6 @@ fn do_orphan_check_impl<'tcx>(\n     let sp = tcx.def_span(def_id);\n     let tr = impl_.of_trait.as_ref().unwrap();\n \n-    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n-    // and #84660 where it would otherwise allow unsoundness.\n-    if trait_ref.has_opaque_types() {\n-        trace!(\"{:#?}\", item);\n-        // First we find the opaque type in question.\n-        for ty in trait_ref.substs {\n-            for ty in ty.walk() {\n-                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n-                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n-                trace!(?def_id);\n-\n-                // Then we search for mentions of the opaque type's type alias in the HIR\n-                struct SpanFinder<'tcx> {\n-                    sp: Span,\n-                    def_id: DefId,\n-                    tcx: TyCtxt<'tcx>,\n-                }\n-                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n-                    #[instrument(level = \"trace\", skip(self, _id))]\n-                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n-                        // You can't mention an opaque type directly, so we look for type aliases\n-                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n-                            // And check if that type alias's type contains the opaque type we're looking for\n-                            for arg in self.tcx.type_of(def_id).walk() {\n-                                if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n-                                        if def_id == self.def_id {\n-                                            // Finally we update the span to the mention of the type alias\n-                                            self.sp = path.span;\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        hir::intravisit::walk_path(self, path)\n-                    }\n-                }\n-\n-                let mut visitor = SpanFinder { sp, def_id, tcx };\n-                hir::intravisit::walk_item(&mut visitor, item);\n-                let reported = tcx\n-                    .sess\n-                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n-                return Err(reported);\n-            }\n-        }\n-        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n-    }\n-\n     match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error("}, {"sha": "bae43138b4d520ef56765809865e6def7565f589", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -517,6 +517,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "f0381353551c2b1a0ed5c0b58db47048a85631ed", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -59,6 +59,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::Ambiguous\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }"}, {"sha": "c7bfe99aa9a8a0ab03025901e7d947f1bb9cb4d8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -702,6 +702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // code is looking for a self type of an unresolved\n                 // inference variable.\n                 | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             },\n         )"}, {"sha": "44c3edf06a8837a492959696d9beb06aebd15dbe", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -803,6 +803,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::TypeOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });"}, {"sha": "2483ab724a4e32142a0e7078f1a277d22ba38131", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -81,6 +81,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate: self.intercrate,\n         }\n     }\n }"}, {"sha": "b4a427a5d419a9519c127d76947841b303b70cd0", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -23,11 +23,10 @@ use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, ToPredicate, Ty, TyCtxt};\n use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n@@ -729,10 +728,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         });\n     }\n \n-    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {\n-        span_bug!(self.cause.span(), \"generic_const_exprs: unreachable `const_equate`\");\n-    }\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }\n@@ -741,11 +736,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         true\n     }\n \n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: PredicateObligations<'tcx>,\n-    ) -> Result<(), TypeError<'tcx>> {\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.obligations.extend(obligations);\n-        Ok(())\n     }\n }"}, {"sha": "eec938cefbb70a0494b1e0f000c3a3338c174236", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -450,6 +450,15 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             ty::Binder::dummy(predicate),\n         ));\n     }\n+\n+    pub fn mark_ambiguous(&mut self) {\n+        self.obligations.push(Obligation::new(\n+            self.tcx(),\n+            self.trace.cause.clone(),\n+            self.param_env,\n+            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n+        ));\n+    }\n }\n \n struct Generalizer<'cx, 'tcx> {\n@@ -521,6 +530,11 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -533,6 +547,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        span_bug!(self.cause.span, \"opaque types are handled in `tys`\");\n+    }\n+\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,\n@@ -657,6 +675,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 // relatable.\n                 Ok(t)\n             }\n+            ty::Opaque(def_id, substs) => {\n+                let s = self.relate(substs, substs)?;\n+                Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n+            }\n             _ => relate::super_relate_tys(self, t, t),\n         }?;\n \n@@ -799,6 +821,11 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.infcx.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -811,6 +838,10 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "8682f4d3b7aed970783395d50e8ca09a8b648d64", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -32,6 +32,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.fields.tcx()\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.fields.param_env\n     }\n@@ -40,6 +44,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        self.fields.mark_ambiguous();\n+    }\n+\n     fn relate_item_substs(\n         &mut self,\n         _item_def_id: DefId,"}, {"sha": "0dee3be705474ac01ae178b18d05c28fef924e72", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -2937,6 +2937,11 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         self.0.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.0.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         // Unused, only for consts which we treat as always equal\n         ty::ParamEnv::empty()\n@@ -2950,6 +2955,10 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: relate::Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "7f27b35a54e4f8808c0350a30677abd61d77bed8", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -30,6 +30,11 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         \"Glb\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.fields.infcx.intercrate);\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -42,6 +47,10 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!(\"mark_ambiguous used outside of coherence\");\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "97ed4729bd0d9e67af8250645909cc3ba567950a", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -30,6 +30,11 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         \"Lub\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.fields.infcx.intercrate);\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -42,6 +47,10 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!(\"mark_ambiguous used outside of coherence\");\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "2798477d1815d81f70d2fc7e741e4e6e1dffa722", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -337,6 +337,26 @@ pub struct InferCtxt<'tcx> {\n \n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+\n+    /// During coherence we have to assume that other crates may add\n+    /// additional impls which we currently don't know about.\n+    ///\n+    /// To deal with this evaluation should be conservative\n+    /// and consider the possibility of impls from outside this crate.\n+    /// This comes up primarily when resolving ambiguity. Imagine\n+    /// there is some trait reference `$0: Bar` where `$0` is an\n+    /// inference variable. If `intercrate` is true, then we can never\n+    /// say for sure that this reference is not implemented, even if\n+    /// there are *no impls at all for `Bar`*, because `$0` could be\n+    /// bound to some type that in a downstream crate that implements\n+    /// `Bar`.\n+    ///\n+    /// Outside of coherence we set this to false because we are only\n+    /// interested in types that the user could actually have written.\n+    /// In other words, we consider `$0: Bar` to be unimplemented if\n+    /// there is no type that the user could *actually name* that\n+    /// would satisfy it. This avoids crippling inference, basically.\n+    pub intercrate: bool,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -552,6 +572,8 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n+    /// Whether we are in coherence mode.\n+    intercrate: bool,\n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n@@ -567,6 +589,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n             normalize_fn_sig_for_diagnostic: None,\n+            intercrate: false,\n         }\n     }\n }\n@@ -583,6 +606,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn intercrate(mut self) -> Self {\n+        self.intercrate = true;\n+        self\n+    }\n+\n     pub fn ignoring_regions(mut self) -> Self {\n         self.considering_regions = false;\n         self\n@@ -622,6 +650,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             defining_use_anchor,\n             considering_regions,\n             ref normalize_fn_sig_for_diagnostic,\n+            intercrate,\n         } = *self;\n         InferCtxt {\n             tcx,\n@@ -641,6 +670,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate,\n         }\n     }\n }"}, {"sha": "4f8460955c3de0d4098673c597666ecc09d52dbf", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -25,7 +25,7 @@ use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::traits::PredicateObligation;\n+use crate::traits::{Obligation, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n@@ -92,11 +92,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n-    fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: Vec<PredicateObligation<'tcx>>,\n-    ) -> Result<(), TypeError<'tcx>>;\n+    fn register_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n@@ -419,7 +415,7 @@ where\n             .infcx\n             .handle_opaque_type(a, b, true, &cause, self.delegate.param_env())?\n             .obligations;\n-        self.delegate.register_opaque_type_obligations(obligations)?;\n+        self.delegate.register_obligations(obligations);\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n@@ -531,6 +527,10 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -543,6 +543,17 @@ where\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        let cause = ObligationCause::dummy_with_span(self.delegate.span());\n+        let param_env = self.delegate.param_env();\n+        self.delegate.register_obligations(vec![Obligation::new(\n+            self.tcx(),\n+            cause,\n+            param_env,\n+            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n+        )]);\n+    }\n+\n     #[instrument(skip(self, info), level = \"trace\", ret)]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n@@ -800,8 +811,12 @@ impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.delegate.const_equate(a, b);\n+    fn const_equate_obligation(&mut self, _a: ty::Const<'tcx>, _b: ty::Const<'tcx>) {\n+        // We don't have to worry about the equality of consts during borrow checking\n+        // as consts always have a static lifetime.\n+        // FIXME(oli-obk): is this really true? We can at least have HKL and with\n+        // inline consts we may have further lifetimes that may be unsound to treat as\n+        // 'static.\n     }\n }\n \n@@ -898,6 +913,11 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.infcx.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -910,6 +930,10 @@ where\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "8f7805794513d7cd0056c29c1a5f4ca709cb0ae8", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -29,6 +29,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))"}, {"sha": "5d204dd70ed0cb2c838aba7b53971cdd83d313ad", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -136,6 +136,11 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Match\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -146,6 +151,10 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         true\n     } // irrelevant\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "2c6987cc3f45670d5290b6ba8d04ecc9d3d0aae2", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -35,6 +35,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Sub\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.infcx.tcx\n     }\n@@ -47,6 +52,10 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        self.fields.mark_ambiguous()\n+    }\n+\n     fn with_cause<F, R>(&mut self, cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "b2a31ac7e6f1af2dda0c165198532f377c834a6d", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -285,6 +285,7 @@ impl<'tcx> Elaborator<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 // Nothing to elaborate\n             }\n+            ty::PredicateKind::Ambiguous => {}\n         }\n     }\n }"}, {"sha": "ada3c3b67fb051f2d0e058083666c030ba308db7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1659,6 +1659,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n+                    Ambiguous |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {"}, {"sha": "0471890230aa6a4d6256ce9a570ea4caeb4f4598", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 203, "deletions": 113, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span};\n+use std::iter;\n \n declare_lint! {\n     /// The `unused_must_use` lint detects unused result of a type flagged as\n@@ -113,30 +114,19 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         }\n \n         let ty = cx.typeck_results().expr_ty(&expr);\n-        let type_permits_lack_of_use = check_must_use_ty(cx, ty, &expr, expr.span, \"\", \"\", 1);\n \n-        let mut fn_warned = false;\n-        let mut op_warned = false;\n-        let maybe_def_id = match expr.kind {\n-            hir::ExprKind::Call(ref callee, _) => {\n-                match callee.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        match cx.qpath_res(qpath, callee.hir_id) {\n-                            Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n-                            // `Res::Local` if it was a closure, for which we\n-                            // do not currently support must-use linting\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n+        let must_use_result = is_ty_must_use(cx, ty, &expr, expr.span);\n+        let type_lint_emitted_or_suppressed = match must_use_result {\n+            Some(path) => {\n+                emit_must_use_untranslated(cx, &path, \"\", \"\", 1);\n+                true\n             }\n-            hir::ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-            _ => None,\n+            None => false,\n         };\n-        if let Some(def_id) = maybe_def_id {\n-            fn_warned = check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\");\n-        } else if type_permits_lack_of_use {\n+\n+        let fn_warned = check_fn_must_use(cx, expr);\n+\n+        if !fn_warned && type_lint_emitted_or_suppressed {\n             // We don't warn about unused unit or uninhabited types.\n             // (See https://github.com/rust-lang/rust/issues/43806 for details.)\n             return;\n@@ -170,6 +160,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             _ => None,\n         };\n \n+        let mut op_warned = false;\n+\n         if let Some(must_use_op) = must_use_op {\n             cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n                 lint.set_arg(\"op\", must_use_op)\n@@ -184,110 +176,229 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             op_warned = true;\n         }\n \n-        if !(type_permits_lack_of_use || fn_warned || op_warned) {\n+        if !(type_lint_emitted_or_suppressed || fn_warned || op_warned) {\n             cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n                 lint.set_arg(\"ty\", ty)\n             });\n         }\n \n-        // Returns whether an error has been emitted (and thus another does not need to be later).\n-        fn check_must_use_ty<'tcx>(\n+        fn check_fn_must_use(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+            let maybe_def_id = match expr.kind {\n+                hir::ExprKind::Call(ref callee, _) => {\n+                    match callee.kind {\n+                        hir::ExprKind::Path(ref qpath) => {\n+                            match cx.qpath_res(qpath, callee.hir_id) {\n+                                Res::Def(DefKind::Fn | DefKind::AssocFn, def_id) => Some(def_id),\n+                                // `Res::Local` if it was a closure, for which we\n+                                // do not currently support must-use linting\n+                                _ => None,\n+                            }\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+                hir::ExprKind::MethodCall(..) => {\n+                    cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+                }\n+                _ => None,\n+            };\n+            if let Some(def_id) = maybe_def_id {\n+                check_must_use_def(cx, def_id, expr.span, \"return value of \", \"\")\n+            } else {\n+                false\n+            }\n+        }\n+\n+        /// A path through a type to a must_use source. Contains useful info for the lint.\n+        #[derive(Debug)]\n+        enum MustUsePath {\n+            /// Suppress must_use checking.\n+            Suppressed,\n+            /// The root of the normal must_use lint with an optional message.\n+            Def(Span, DefId, Option<Symbol>),\n+            Boxed(Box<Self>),\n+            Opaque(Box<Self>),\n+            TraitObject(Box<Self>),\n+            TupleElement(Vec<(usize, Self)>),\n+            Array(Box<Self>, u64),\n+            /// The root of the unused_closures lint.\n+            Closure(Span),\n+            /// The root of the unused_generators lint.\n+            Generator(Span),\n+        }\n+\n+        #[instrument(skip(cx, expr), level = \"debug\", ret)]\n+        fn is_ty_must_use<'tcx>(\n             cx: &LateContext<'tcx>,\n             ty: Ty<'tcx>,\n             expr: &hir::Expr<'_>,\n             span: Span,\n-            descr_pre: &str,\n-            descr_post: &str,\n-            plural_len: usize,\n-        ) -> bool {\n+        ) -> Option<MustUsePath> {\n             if ty.is_unit()\n                 || !ty.is_inhabited_from(\n                     cx.tcx,\n                     cx.tcx.parent_module(expr.hir_id).to_def_id(),\n                     cx.param_env,\n                 )\n             {\n-                return true;\n+                return Some(MustUsePath::Suppressed);\n             }\n \n-            let plural_suffix = pluralize!(plural_len);\n-\n             match *ty.kind() {\n                 ty::Adt(..) if ty.is_box() => {\n                     let boxed_ty = ty.boxed_ty();\n-                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n-                    check_must_use_ty(cx, boxed_ty, expr, span, descr_pre, descr_post, plural_len)\n+                    is_ty_must_use(cx, boxed_ty, expr, span)\n+                        .map(|inner| MustUsePath::Boxed(Box::new(inner)))\n                 }\n-                ty::Adt(def, _) => check_must_use_def(cx, def.did(), span, descr_pre, descr_post),\n+                ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Opaque(def, _) => {\n-                    let mut has_emitted = false;\n-                    for obligation in elaborate_predicates_with_span(\n+                    elaborate_predicates_with_span(\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n-                    ) {\n+                    )\n+                    .filter_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n                             obligation.predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n-                            let descr_pre =\n-                                &format!(\"{}implementer{} of \", descr_pre, plural_suffix,);\n-                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n-                                has_emitted = true;\n-                                break;\n-                            }\n+\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n                         }\n-                    }\n-                    has_emitted\n+                    })\n+                    .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n+                    .next()\n                 }\n-                ty::Dynamic(binder, _, _) => {\n-                    let mut has_emitted = false;\n-                    for predicate in binder.iter() {\n+                ty::Dynamic(binders, _, _) => binders\n+                    .iter()\n+                    .filter_map(|predicate| {\n                         if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n                             predicate.skip_binder()\n                         {\n                             let def_id = trait_ref.def_id;\n-                            let descr_post =\n-                                &format!(\" trait object{}{}\", plural_suffix, descr_post,);\n-                            if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {\n-                                has_emitted = true;\n-                                break;\n-                            }\n+                            is_def_must_use(cx, def_id, span)\n+                        } else {\n+                            None\n                         }\n-                    }\n-                    has_emitted\n-                }\n-                ty::Tuple(ref tys) => {\n-                    let mut has_emitted = false;\n-                    let comps = if let hir::ExprKind::Tup(comps) = expr.kind {\n-                        debug_assert_eq!(comps.len(), tys.len());\n-                        comps\n+                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                    })\n+                    .next(),\n+                ty::Tuple(tys) => {\n+                    let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n+                        debug_assert_eq!(elem_exprs.len(), tys.len());\n+                        elem_exprs\n                     } else {\n                         &[]\n                     };\n-                    for (i, ty) in tys.iter().enumerate() {\n-                        let descr_post = &format!(\" in tuple element {}\", i);\n-                        let e = comps.get(i).unwrap_or(expr);\n-                        let span = e.span;\n-                        if check_must_use_ty(cx, ty, e, span, descr_pre, descr_post, plural_len) {\n-                            has_emitted = true;\n-                        }\n+\n+                    // Default to `expr`.\n+                    let elem_exprs = elem_exprs.iter().chain(iter::repeat(expr));\n+\n+                    let nested_must_use = tys\n+                        .iter()\n+                        .zip(elem_exprs)\n+                        .enumerate()\n+                        .filter_map(|(i, (ty, expr))| {\n+                            is_ty_must_use(cx, ty, expr, expr.span).map(|path| (i, path))\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    if !nested_must_use.is_empty() {\n+                        Some(MustUsePath::TupleElement(nested_must_use))\n+                    } else {\n+                        None\n                     }\n-                    has_emitted\n                 }\n                 ty::Array(ty, len) => match len.try_eval_usize(cx.tcx, cx.param_env) {\n                     // If the array is empty we don't lint, to avoid false positives\n-                    Some(0) | None => false,\n+                    Some(0) | None => None,\n                     // If the array is definitely non-empty, we can do `#[must_use]` checking.\n-                    Some(n) => {\n-                        let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix,);\n-                        check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, n as usize + 1)\n-                    }\n+                    Some(len) => is_ty_must_use(cx, ty, expr, span)\n+                        .map(|inner| MustUsePath::Array(Box::new(inner), len)),\n                 },\n-                ty::Closure(..) => {\n+                ty::Closure(..) => Some(MustUsePath::Closure(span)),\n+                ty::Generator(..) => Some(MustUsePath::Generator(span)),\n+                _ => None,\n+            }\n+        }\n+\n+        fn is_def_must_use(cx: &LateContext<'_>, def_id: DefId, span: Span) -> Option<MustUsePath> {\n+            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n+                // check for #[must_use = \"...\"]\n+                let reason = attr.value_str();\n+                Some(MustUsePath::Def(span, def_id, reason))\n+            } else {\n+                None\n+            }\n+        }\n+\n+        // Returns whether further errors should be suppressed because either a lint has been emitted or the type should be ignored.\n+        fn check_must_use_def(\n+            cx: &LateContext<'_>,\n+            def_id: DefId,\n+            span: Span,\n+            descr_pre_path: &str,\n+            descr_post_path: &str,\n+        ) -> bool {\n+            is_def_must_use(cx, def_id, span)\n+                .map(|must_use_path| {\n+                    emit_must_use_untranslated(\n+                        cx,\n+                        &must_use_path,\n+                        descr_pre_path,\n+                        descr_post_path,\n+                        1,\n+                    )\n+                })\n+                .is_some()\n+        }\n+\n+        #[instrument(skip(cx), level = \"debug\")]\n+        fn emit_must_use_untranslated(\n+            cx: &LateContext<'_>,\n+            path: &MustUsePath,\n+            descr_pre: &str,\n+            descr_post: &str,\n+            plural_len: usize,\n+        ) {\n+            let plural_suffix = pluralize!(plural_len);\n+\n+            match path {\n+                MustUsePath::Suppressed => {}\n+                MustUsePath::Boxed(path) => {\n+                    let descr_pre = &format!(\"{}boxed \", descr_pre);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::Opaque(path) => {\n+                    let descr_pre = &format!(\"{}implementer{} of \", descr_pre, plural_suffix);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::TraitObject(path) => {\n+                    let descr_post = &format!(\" trait object{}{}\", plural_suffix, descr_post);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                }\n+                MustUsePath::TupleElement(elems) => {\n+                    for (index, path) in elems {\n+                        let descr_post = &format!(\" in tuple element {}\", index);\n+                        emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    }\n+                }\n+                MustUsePath::Array(path, len) => {\n+                    let descr_pre = &format!(\"{}array{} of \", descr_pre, plural_suffix);\n+                    emit_must_use_untranslated(\n+                        cx,\n+                        path,\n+                        descr_pre,\n+                        descr_post,\n+                        plural_len.saturating_add(usize::try_from(*len).unwrap_or(usize::MAX)),\n+                    );\n+                }\n+                MustUsePath::Closure(span) => {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n-                        span,\n+                        *span,\n                         fluent::lint_unused_closure,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n@@ -298,12 +409,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                                 .note(fluent::note)\n                         },\n                     );\n-                    true\n                 }\n-                ty::Generator(..) => {\n+                MustUsePath::Generator(span) => {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n-                        span,\n+                        *span,\n                         fluent::lint_unused_generator,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n@@ -314,40 +424,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                                 .note(fluent::note)\n                         },\n                     );\n-                    true\n                 }\n-                _ => false,\n-            }\n-        }\n-\n-        // Returns whether an error has been emitted (and thus another does not need to be later).\n-        // FIXME: Args desc_{pre,post}_path could be made lazy by taking Fn() -> &str, but this\n-        // would make calling it a big awkward. Could also take String (so args are moved), but\n-        // this would still require a copy into the format string, which would only be executed\n-        // when needed.\n-        fn check_must_use_def(\n-            cx: &LateContext<'_>,\n-            def_id: DefId,\n-            span: Span,\n-            descr_pre_path: &str,\n-            descr_post_path: &str,\n-        ) -> bool {\n-            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n-                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint_unused_def, |lint| {\n-                    // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n-                    // strings\n-                    lint.set_arg(\"pre\", descr_pre_path);\n-                    lint.set_arg(\"post\", descr_post_path);\n-                    lint.set_arg(\"def\", cx.tcx.def_path_str(def_id));\n-                    // check for #[must_use = \"...\"]\n-                    if let Some(note) = attr.value_str() {\n-                        lint.note(note.as_str());\n-                    }\n-                    lint\n-                });\n-                true\n-            } else {\n-                false\n+                MustUsePath::Def(span, def_id, reason) => {\n+                    cx.struct_span_lint(UNUSED_MUST_USE, *span, fluent::lint_unused_def, |lint| {\n+                        // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n+                        // strings\n+                        lint.set_arg(\"pre\", descr_pre);\n+                        lint.set_arg(\"post\", descr_post);\n+                        lint.set_arg(\"def\", cx.tcx.def_path_str(*def_id));\n+                        if let Some(note) = reason {\n+                            lint.note(note.as_str());\n+                        }\n+                        lint\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "6f7e6e09ca5eddfabcf7ff0c908c7ce2a9de72d9", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -692,6 +692,7 @@ pub struct CrateLocationUnknownType<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub path: &'a Path,\n+    pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "15546092e41a2bb37a80663b2b222963252bcb3a", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -707,6 +707,12 @@ impl<'a> CrateLocator<'a> {\n                     loc.original().clone(),\n                 ));\n             }\n+            if !loc.original().is_file() {\n+                return Err(CrateError::ExternLocationNotFile(\n+                    self.crate_name,\n+                    loc.original().clone(),\n+                ));\n+            }\n             let Some(file) = loc.original().file_name().and_then(|s| s.to_str()) else {\n                 return Err(CrateError::ExternLocationNotFile(\n                     self.crate_name,\n@@ -1020,11 +1026,10 @@ impl CrateError {\n                     None => String::new(),\n                     Some(r) => format!(\" which `{}` depends on\", r.name),\n                 };\n-                // FIXME: There are no tests for CrateLocationUnknownType or LibFilenameForm\n                 if !locator.crate_rejections.via_filename.is_empty() {\n                     let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        sess.emit_err(CrateLocationUnknownType { span, path: &path });\n+                        sess.emit_err(CrateLocationUnknownType { span, path: &path, crate_name });\n                         sess.emit_err(LibFilenameForm {\n                             span,\n                             dll_prefix: &locator.dll_prefix,"}, {"sha": "cd147d7e55813d5b4aaec1ab09461a4fd6405abd", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -36,13 +36,22 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n     fn a_is_expected(&self) -> bool {\n         true\n     } // irrelevant\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "1ee4985cf8de044ae3c69696403b3999455d51d4", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -42,7 +42,6 @@ where\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n     GeneratorWitnessSimplifiedType(usize),\n-    OpaqueSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     PlaceholderSimplifiedType,\n }\n@@ -127,7 +126,7 @@ pub fn simplify_type<'tcx>(\n             TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n             TreatParams::AsInfer => None,\n         },\n-        ty::Projection(_) => match treat_params {\n+        ty::Opaque(..) | ty::Projection(_) => match treat_params {\n             // When treating `ty::Param` as a placeholder, projections also\n             // don't unify with anything else as long as they are fully normalized.\n             //\n@@ -138,7 +137,6 @@ pub fn simplify_type<'tcx>(\n             }\n             TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n         },\n-        ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n     }\n@@ -151,8 +149,7 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             | ForeignSimplifiedType(d)\n             | TraitSimplifiedType(d)\n             | ClosureSimplifiedType(d)\n-            | GeneratorSimplifiedType(d)\n-            | OpaqueSimplifiedType(d) => Some(d),\n+            | GeneratorSimplifiedType(d) => Some(d),\n             _ => None,\n         }\n     }\n@@ -182,7 +179,6 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n-            OpaqueSimplifiedType(d) => OpaqueSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n             PlaceholderSimplifiedType => PlaceholderSimplifiedType,\n         }\n@@ -229,7 +225,7 @@ impl DeepRejectCtxt {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case.\n-            ty::Param(_) | ty::Projection(_) | ty::Error(_) => return true,\n+            ty::Param(_) | ty::Projection(_) | ty::Error(_) | ty::Opaque(..) => return true,\n             // These types only unify with inference variables or their own\n             // variant.\n             ty::Bool\n@@ -247,8 +243,7 @@ impl DeepRejectCtxt {\n             | ty::Never\n             | ty::Tuple(..)\n             | ty::FnPtr(..)\n-            | ty::Foreign(..)\n-            | ty::Opaque(..) => {}\n+            | ty::Foreign(..) => {}\n             ty::FnDef(..)\n             | ty::Closure(..)\n             | ty::Generator(..)\n@@ -328,10 +323,7 @@ impl DeepRejectCtxt {\n                 _ => false,\n             },\n \n-            // Opaque types in impls should be forbidden, but that doesn't\n-            // stop compilation. So this match arm should never return true\n-            // if compilation succeeds.\n-            ty::Opaque(..) => matches!(k, ty::Opaque(..)),\n+            ty::Opaque(..) => true,\n \n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,"}, {"sha": "ee4b8f91c54873a075d1ed9712359e231b02fa86", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -259,6 +259,7 @@ impl FlagComputation {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n+            ty::PredicateKind::Ambiguous => {}\n         }\n     }\n "}, {"sha": "0458c4abd3d4cbe9ca9f3fa4367ea58e165f3297", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -620,6 +620,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Coerce(_)\n             | PredicateKind::ConstEvaluatable(_)\n             | PredicateKind::ConstEquate(_, _)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(_) => true,\n         }\n     }\n@@ -702,6 +703,10 @@ pub enum PredicateKind<'tcx> {\n     ///\n     /// Only used for Chalk.\n     TypeWellFormedFromEnv(Ty<'tcx>),\n+\n+    /// A marker predicate that is always ambiguous.\n+    /// Used for coherence to mark opaque types as possibly equal to each other but ambiguous.\n+    Ambiguous,\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1186,6 +1191,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1204,6 +1210,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1222,6 +1229,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }"}, {"sha": "bddcdd0b693caf367e739a5482b1f68e1ddecc34", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -2704,6 +2704,7 @@ define_print_and_forward_display! {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n+            ty::PredicateKind::Ambiguous => p!(\"ambiguous\"),\n         }\n     }\n "}, {"sha": "3d47b71b7ce62ea8df8754ae1502699df4679f1b", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -23,6 +23,8 @@ pub enum Cause {\n pub trait TypeRelation<'tcx>: Sized {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n+    fn intercrate(&self) -> bool;\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     /// Returns a static string we can use for printouts.\n@@ -32,6 +34,9 @@ pub trait TypeRelation<'tcx>: Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n+    /// Used during coherence. If called, must emit an always-ambiguous obligation.\n+    fn mark_ambiguous(&mut self);\n+\n     fn with_cause<F, R>(&mut self, _cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -562,16 +567,23 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let opt_variances = tcx.variances_of(a_def_id);\n-            let substs = relate_substs_with_variances(\n-                relation,\n-                a_def_id,\n-                opt_variances,\n-                a_substs,\n-                b_substs,\n-                false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n-            )?;\n-            Ok(tcx.mk_opaque(a_def_id, substs))\n+            if relation.intercrate() {\n+                // During coherence, opaque types should be treated as equal to each other, even if their generic params\n+                // differ, as they could resolve to the same hidden type, even for different generic params.\n+                relation.mark_ambiguous();\n+                Ok(a)\n+            } else {\n+                let opt_variances = tcx.variances_of(a_def_id);\n+                let substs = relate_substs_with_variances(\n+                    relation,\n+                    a_def_id,\n+                    opt_variances,\n+                    a_substs,\n+                    b_substs,\n+                    false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n+                )?;\n+                Ok(tcx.mk_opaque(a_def_id, substs))\n+            }\n         }\n \n         _ => Err(TypeError::Sorts(expected_found(relation, a, b))),"}, {"sha": "64b4fd11762522159beb29ec3368466be0c3c10a", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -173,6 +173,7 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n+            ty::PredicateKind::Ambiguous => write!(f, \"Ambiguous\"),\n         }\n     }\n }"}, {"sha": "78af187cd8f80216661c35c502bcc5633ae70788", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -841,6 +841,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+                ty::PredicateKind::Ambiguous => return false,\n             };\n         }\n         true"}, {"sha": "741bf206d037e20a15693f5a51af3386c584472a", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -94,8 +94,9 @@ pub fn overlapping_impls<'tcx>(\n         return None;\n     }\n \n-    let infcx = tcx.infer_ctxt().build();\n-    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n     let overlaps =\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n     if !overlaps {\n@@ -105,8 +106,9 @@ pub fn overlapping_impls<'tcx>(\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx = tcx.infer_ctxt().build();\n-    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n     selcx.enable_tracking_intercrate_ambiguity_causes();\n     Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n }"}, {"sha": "ef3d300020a39086edaa7cb0f0a2ee80c20f83ba", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1168,6 +1168,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         )\n                     }\n \n+                    ty::PredicateKind::Ambiguous => span_bug!(span, \"ambiguous\"),\n+\n                     ty::PredicateKind::TypeWellFormedFromEnv(..) => span_bug!(\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\""}, {"sha": "d238e7556aea33a45c5a27a947db829e89594ad3", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -336,6 +336,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         ty::Binder::dummy(infcx.replace_bound_vars_with_placeholders(binder));\n                     ProcessResult::Changed(mk_pending(vec![obligation.with(infcx.tcx, pred)]))\n                 }\n+                ty::PredicateKind::Ambiguous => ProcessResult::Unchanged,\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n@@ -569,6 +570,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         }\n                     }\n                 }\n+                ty::PredicateKind::Ambiguous => ProcessResult::Unchanged,\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }"}, {"sha": "7c4c58ba361670f6429abd50bbf636876cdcc441", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -319,6 +319,7 @@ fn predicate_references_self<'tcx>(\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }\n@@ -350,6 +351,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }\n     })"}, {"sha": "2803a2d38c807b97143273d8b24f59d5acbe138f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -110,25 +110,6 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// require themselves.\n     freshener: TypeFreshener<'cx, 'tcx>,\n \n-    /// During coherence we have to assume that other crates may add\n-    /// additional impls which we currently don't know about.\n-    ///\n-    /// To deal with this evaluation should be conservative\n-    /// and consider the possibility of impls from outside this crate.\n-    /// This comes up primarily when resolving ambiguity. Imagine\n-    /// there is some trait reference `$0: Bar` where `$0` is an\n-    /// inference variable. If `intercrate` is true, then we can never\n-    /// say for sure that this reference is not implemented, even if\n-    /// there are *no impls at all for `Bar`*, because `$0` could be\n-    /// bound to some type that in a downstream crate that implements\n-    /// `Bar`.\n-    ///\n-    /// Outside of coherence we set this to false because we are only\n-    /// interested in types that the user could actually have written.\n-    /// In other words, we consider `$0: Bar` to be unimplemented if\n-    /// there is no type that the user could *actually name* that\n-    /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: bool,\n     /// If `intercrate` is set, we remember predicates which were\n     /// considered ambiguous because of impls potentially added in other crates.\n     /// This is used in coherence to give improved diagnostics.\n@@ -226,16 +207,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener_keep_static(),\n-            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n-        SelectionContext { intercrate: true, ..SelectionContext::new(infcx) }\n-    }\n-\n     pub fn with_query_mode(\n         infcx: &'cx InferCtxt<'tcx>,\n         query_mode: TraitQueryMode,\n@@ -247,7 +223,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Enables tracking of intercrate ambiguity causes. See\n     /// the documentation of [`Self::intercrate_ambiguity_causes`] for more.\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n-        assert!(self.intercrate);\n+        assert!(self.is_intercrate());\n         assert!(self.intercrate_ambiguity_causes.is_none());\n         self.intercrate_ambiguity_causes = Some(FxIndexSet::default());\n         debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n@@ -257,7 +233,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// was enabled and disables tracking at the same time. If\n     /// tracking is not enabled, just returns an empty vector.\n     pub fn take_intercrate_ambiguity_causes(&mut self) -> FxIndexSet<IntercrateAmbiguityCause> {\n-        assert!(self.intercrate);\n+        assert!(self.is_intercrate());\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n@@ -270,7 +246,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn is_intercrate(&self) -> bool {\n-        self.intercrate\n+        self.infcx.intercrate\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -741,6 +717,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n+                ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n             }\n         })\n     }\n@@ -751,7 +728,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         mut obligation: TraitObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        if !self.intercrate\n+        if !self.is_intercrate()\n             && obligation.is_global()\n             && obligation.param_env.caller_bounds().iter().all(|bound| bound.needs_subst())\n         {\n@@ -1014,7 +991,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return None;\n         }\n \n@@ -1044,7 +1021,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return;\n         }\n \n@@ -1225,9 +1202,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Result<(), Conflict> {\n-        debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n+        debug!(\"is_knowable(intercrate={:?})\", self.is_intercrate());\n \n-        if !self.intercrate || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n+        if !self.is_intercrate() || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n             return Ok(());\n         }\n \n@@ -1258,7 +1235,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate, I don't think.\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return false;\n         }\n \n@@ -1275,7 +1252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return None;\n         }\n         let tcx = self.tcx();\n@@ -1314,7 +1291,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return false;\n         }\n         match result {\n@@ -2191,7 +2168,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{e}`\"))?;\n         nested_obligations.extend(obligations);\n \n-        if !self.intercrate\n+        if !self.is_intercrate()\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {\n             debug!(\"reservation impls only apply in intercrate mode\");"}, {"sha": "5e506a23f383f353cdbdd035f95b07660efbf397", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -155,6 +155,7 @@ pub fn predicate_obligations<'tcx>(\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n+        ty::PredicateKind::Ambiguous => {}\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }\n@@ -875,6 +876,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty"}, {"sha": "ee013515e86c410b9a4f19597e8bc0921ee73a52", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -121,6 +121,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n             let value = chalk_ir::ProgramClauseImplication {\n@@ -212,6 +213,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n@@ -625,6 +627,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n@@ -754,6 +757,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }"}, {"sha": "2d1a386992617260d52a5313dba1f60dad4d2b54", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -97,6 +97,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::Ambiguous\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);"}, {"sha": "5200908527a1610f9d072b4cd8a041bc4d1c41e8", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -66,6 +66,7 @@ fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,\n     }\n }"}, {"sha": "b25d63d835b54c762c5a7c7d160d583d7bf14e70", "filename": "library/alloc/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Flib.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -5,7 +5,9 @@\n #![feature(iter_next_chunk)]\n #![feature(repr_simd)]\n #![feature(slice_partition_dedup)]\n+#![feature(strict_provenance)]\n #![feature(test)]\n+#![deny(fuzzy_provenance_casts)]\n \n extern crate test;\n "}, {"sha": "96960d43f5820a26121f26bb8fb1236116fccd0c", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -82,6 +82,7 @@\n //\n // Lints:\n #![deny(unsafe_op_in_unsafe_fn)]\n+#![deny(fuzzy_provenance_casts)]\n #![warn(deprecated_in_future)]\n #![warn(missing_debug_implementations)]\n #![warn(missing_docs)]"}, {"sha": "04da95bbb83eda668ad94d2d5b24f577ab5cda17", "filename": "library/alloc/tests/fmt.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Ffmt.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -2,6 +2,7 @@\n \n use std::cell::RefCell;\n use std::fmt::{self, Write};\n+use std::ptr;\n \n #[test]\n fn test_format() {\n@@ -76,14 +77,14 @@ fn test_format_macro_interface() {\n     t!(format!(\"{}\", \"foo\"), \"foo\");\n     t!(format!(\"{}\", \"foo\".to_string()), \"foo\");\n     if cfg!(target_pointer_width = \"32\") {\n-        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x00001234\");\n-        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x00001234\");\n+        t!(format!(\"{:#p}\", ptr::invalid::<isize>(0x1234)), \"0x00001234\");\n+        t!(format!(\"{:#p}\", ptr::invalid_mut::<isize>(0x1234)), \"0x00001234\");\n     } else {\n-        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x0000000000001234\");\n-        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x0000000000001234\");\n+        t!(format!(\"{:#p}\", ptr::invalid::<isize>(0x1234)), \"0x0000000000001234\");\n+        t!(format!(\"{:#p}\", ptr::invalid_mut::<isize>(0x1234)), \"0x0000000000001234\");\n     }\n-    t!(format!(\"{:p}\", 0x1234 as *const isize), \"0x1234\");\n-    t!(format!(\"{:p}\", 0x1234 as *mut isize), \"0x1234\");\n+    t!(format!(\"{:p}\", ptr::invalid::<isize>(0x1234)), \"0x1234\");\n+    t!(format!(\"{:p}\", ptr::invalid_mut::<isize>(0x1234)), \"0x1234\");\n     t!(format!(\"{A:x}\"), \"aloha\");\n     t!(format!(\"{B:X}\"), \"adios\");\n     t!(format!(\"foo {} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");"}, {"sha": "d066ec03ee57e861b17b640d4afb33ac1929f713", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -47,6 +47,7 @@\n #![feature(strict_provenance)]\n #![feature(once_cell)]\n #![feature(drain_keep_rest)]\n+#![deny(fuzzy_provenance_casts)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "65d4c3c891ea689c2ec4c9267caa248141382d6a", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -220,6 +220,7 @@\n #![allow(explicit_outlives_requirements)]\n #![allow(unused_lifetimes)]\n #![deny(rustc::existing_doc_keyword)]\n+#![deny(fuzzy_provenance_casts)]\n // Ensure that std can be linked against panic_abort despite compiled with `-C panic=unwind`\n #![deny(ffi_unwind_calls)]\n // std may use features in a platform-specific way\n@@ -598,7 +599,7 @@ mod panicking;\n mod personality;\n \n #[path = \"../../backtrace/src/lib.rs\"]\n-#[allow(dead_code, unused_attributes)]\n+#[allow(dead_code, unused_attributes, fuzzy_provenance_casts)]\n mod backtrace_rs;\n \n // Re-export macros defined in libcore."}, {"sha": "5c1634084a055b31381849b8fc5085d47da89330", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -90,6 +90,7 @@ impl OwnedSocket {\n     }\n \n     // FIXME(strict_provenance_magic): we defined RawSocket to be a u64 ;-;\n+    #[allow(fuzzy_provenance_casts)]\n     #[cfg(not(target_vendor = \"uwp\"))]\n     pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n         cvt(unsafe {"}, {"sha": "a783e187004fcb92cf709cd0e12cf7c487b19595", "filename": "library/std/src/personality/dwarf/eh.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -13,6 +13,7 @@\n \n use super::DwarfReader;\n use core::mem;\n+use core::ptr;\n \n pub const DW_EH_PE_omit: u8 = 0xFF;\n pub const DW_EH_PE_absptr: u8 = 0x00;\n@@ -151,7 +152,7 @@ unsafe fn read_encoded_pointer(\n \n     // DW_EH_PE_aligned implies it's an absolute pointer value\n     if encoding == DW_EH_PE_aligned {\n-        reader.ptr = round_up(reader.ptr as usize, mem::size_of::<usize>())? as *const u8;\n+        reader.ptr = reader.ptr.with_addr(round_up(reader.ptr.addr(), mem::size_of::<usize>())?);\n         return Ok(reader.read::<usize>());\n     }\n \n@@ -171,7 +172,7 @@ unsafe fn read_encoded_pointer(\n     result += match encoding & 0x70 {\n         DW_EH_PE_absptr => 0,\n         // relative to address of the encoded value, despite the name\n-        DW_EH_PE_pcrel => reader.ptr as usize,\n+        DW_EH_PE_pcrel => reader.ptr.expose_addr(),\n         DW_EH_PE_funcrel => {\n             if context.func_start == 0 {\n                 return Err(());\n@@ -184,7 +185,7 @@ unsafe fn read_encoded_pointer(\n     };\n \n     if encoding & DW_EH_PE_indirect != 0 {\n-        result = *(result as *const usize);\n+        result = *ptr::from_exposed_addr::<usize>(result);\n     }\n \n     Ok(result)"}, {"sha": "01e4ffe3dfc8a04394145b67726b934d780b58d8", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -3,6 +3,7 @@\n //! This module contains the facade (aka platform-specific) implementations of\n //! OS level functionality for Fortanix SGX.\n #![deny(unsafe_op_in_unsafe_fn)]\n+#![allow(fuzzy_provenance_casts)] // FIXME: this entire module systematically confuses pointers and integers\n \n use crate::io::ErrorKind;\n use crate::sync::atomic::{AtomicBool, Ordering};"}, {"sha": "fe8a028dfd3ade5cab2a1c5e0510fadcba88fae6", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 21, "deletions": 60, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -225,13 +225,13 @@ dependencies = [\n \n [[package]]\n name = \"fd-lock\"\n-version = \"3.0.7\"\n+version = \"3.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0c93a581058d957dc4176875aad04f82f81613e6611d64aa1a9c755bdfb16711\"\n+checksum = \"bb21c69b9fea5e15dbc1049e4b77145dd0ba1c84019c488102de0dc4ea4b0a27\"\n dependencies = [\n  \"cfg-if\",\n  \"rustix\",\n- \"windows-sys 0.42.0\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -319,9 +319,13 @@ dependencies = [\n \n [[package]]\n name = \"io-lifetimes\"\n-version = \"0.7.2\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"24c3f4eff5495aee4c0399d7b6a0dc2b6e81be84242ffbfcf253ebacccc1d0cb\"\n+checksum = \"a7d367024b3f3414d8e01f437f704f41a9f64ab36f9067fa73e526ad4c763c87\"\n+dependencies = [\n+ \"libc\",\n+ \"windows-sys\",\n+]\n \n [[package]]\n name = \"itoa\"\n@@ -337,15 +341,15 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.137\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"fc7fcc620a3bff7cdd7a365be3376c97191aeaccc2a603e600951e452615bf89\"\n \n [[package]]\n name = \"linux-raw-sys\"\n-version = \"0.0.46\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d4d2456c373231a208ad294c33dc5bff30051eafd954cd4caae83a712b12854d\"\n+checksum = \"8f9f08d8963a6c613f4b1a78f4f4a4dbfadf8e6545b2d72861731e4858b8b47f\"\n \n [[package]]\n name = \"log\"\n@@ -529,16 +533,16 @@ checksum = \"49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64\"\n \n [[package]]\n name = \"rustix\"\n-version = \"0.35.6\"\n+version = \"0.36.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef258c11e17f5c01979a10543a30a4e12faef6aab217a74266e747eefa3aed88\"\n+checksum = \"0b1fbb4dfc4eb1d390c02df47760bb19a84bb80b301ecc947ab5406394d8223e\"\n dependencies = [\n  \"bitflags\",\n  \"errno\",\n  \"io-lifetimes\",\n  \"libc\",\n  \"linux-raw-sys\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -725,32 +729,19 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"windows-sys\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n-dependencies = [\n- \"windows_aarch64_msvc 0.36.1\",\n- \"windows_i686_gnu 0.36.1\",\n- \"windows_i686_msvc 0.36.1\",\n- \"windows_x86_64_gnu 0.36.1\",\n- \"windows_x86_64_msvc 0.36.1\",\n-]\n-\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n  \"windows_aarch64_gnullvm\",\n- \"windows_aarch64_msvc 0.42.0\",\n- \"windows_i686_gnu 0.42.0\",\n- \"windows_i686_msvc 0.42.0\",\n- \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n  \"windows_x86_64_gnullvm\",\n- \"windows_x86_64_msvc 0.42.0\",\n+ \"windows_x86_64_msvc\",\n ]\n \n [[package]]\n@@ -759,48 +750,24 @@ version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n \n-[[package]]\n-name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n-\n [[package]]\n name = \"windows_aarch64_msvc\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n-[[package]]\n-name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n-\n [[package]]\n name = \"windows_i686_gnu\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n-[[package]]\n-name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n-\n [[package]]\n name = \"windows_i686_msvc\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n-[[package]]\n-name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n-\n [[package]]\n name = \"windows_x86_64_gnu\"\n version = \"0.42.0\"\n@@ -813,12 +780,6 @@ version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n-[[package]]\n-name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n-\n [[package]]\n name = \"windows_x86_64_msvc\"\n version = \"0.42.0\""}, {"sha": "8751a71caf1b4957fc5688afdc259f14befb7576", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -36,7 +36,7 @@ test = false\n \n [dependencies]\n cmake = \"0.1.38\"\n-fd-lock = \"3.0.7\"\n+fd-lock = \"3.0.8\"\n filetime = \"0.2\"\n getopts = \"0.2.19\"\n cc = \"1.0.69\""}, {"sha": "b5d4ab55b4a8363f16f8f4700ec2914a780ea2dd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -318,6 +318,7 @@ pub(crate) fn clean_predicate<'tcx>(\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n     }\n }"}, {"sha": "5b6a62b24d4b32281173d42358401d8fc2788ebc", "filename": "src/test/ui/coherence/coherence-with-closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -8,7 +8,6 @@ fn defining_use() -> OpaqueClosure {\n struct Wrapper<T>(T);\n trait Trait {}\n impl Trait for Wrapper<OpaqueClosure> {}\n-//~^ ERROR cannot implement trait on type alias impl trait\n impl<T: Sync> Trait for Wrapper<T> {}\n //~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueClosure>`\n "}, {"sha": "431108e14d7d85949809482b045d2d3fb433f35d", "filename": "src/test/ui/coherence/coherence-with-closure.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,24 +1,11 @@\n error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueClosure>`\n-  --> $DIR/coherence-with-closure.rs:12:1\n+  --> $DIR/coherence-with-closure.rs:11:1\n    |\n LL | impl Trait for Wrapper<OpaqueClosure> {}\n    | ------------------------------------- first implementation here\n-LL |\n LL | impl<T: Sync> Trait for Wrapper<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Wrapper<OpaqueClosure>`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/coherence-with-closure.rs:10:24\n-   |\n-LL | impl Trait for Wrapper<OpaqueClosure> {}\n-   |                        ^^^^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/coherence-with-closure.rs:3:22\n-   |\n-LL | type OpaqueClosure = impl Sized;\n-   |                      ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "70665ba06f95435b138f5c608ae0d2dfed43153f", "filename": "src/test/ui/coherence/coherence-with-generator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -12,7 +12,6 @@ fn defining_use() -> OpaqueGenerator {\n struct Wrapper<T>(T);\n trait Trait {}\n impl Trait for Wrapper<OpaqueGenerator> {}\n-//~^ ERROR cannot implement trait on type alias impl trait\n impl<T: Sync> Trait for Wrapper<T> {}\n //~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n "}, {"sha": "6d3be2e16c6578b37746a5bd5cc5f5b2ac39c229", "filename": "src/test/ui/coherence/coherence-with-generator.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,24 +1,11 @@\n error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n-  --> $DIR/coherence-with-generator.rs:16:1\n+  --> $DIR/coherence-with-generator.rs:15:1\n    |\n LL | impl Trait for Wrapper<OpaqueGenerator> {}\n    | --------------------------------------- first implementation here\n-LL |\n LL | impl<T: Sync> Trait for Wrapper<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Wrapper<OpaqueGenerator>`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/coherence-with-generator.rs:14:24\n-   |\n-LL | impl Trait for Wrapper<OpaqueGenerator> {}\n-   |                        ^^^^^^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/coherence-with-generator.rs:3:24\n-   |\n-LL | type OpaqueGenerator = impl Sized;\n-   |                        ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "3f13d605232036ace6a2a913c5e27212c0fc27dc", "filename": "src/test/ui/errors/issue-104621-extern-bad-file.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-bad-file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-bad-file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-bad-file.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: --extern foo={{src-base}}/errors/issue-104621-extern-bad-file.rs\n+// only-linux\n+\n+extern crate foo;\n+//~^ ERROR extern location for foo is of an unknown type\n+//~| ERROR file name should be lib*.rlib or lib*.so\n+//~| ERROR can't find crate for `foo` [E0463]\n+fn main() {}"}, {"sha": "b8500ad0e045b8f154042a8c0c4ff2e28eeb240e", "filename": "src/test/ui/errors/issue-104621-extern-bad-file.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-bad-file.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-bad-file.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-bad-file.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,21 @@\n+error: extern location for foo is of an unknown type: $DIR/issue-104621-extern-bad-file.rs\n+  --> $DIR/issue-104621-extern-bad-file.rs:4:1\n+   |\n+LL | extern crate foo;\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: file name should be lib*.rlib or lib*.so\n+  --> $DIR/issue-104621-extern-bad-file.rs:4:1\n+   |\n+LL | extern crate foo;\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error[E0463]: can't find crate for `foo`\n+  --> $DIR/issue-104621-extern-bad-file.rs:4:1\n+   |\n+LL | extern crate foo;\n+   | ^^^^^^^^^^^^^^^^^ can't find crate\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0463`."}, {"sha": "899e45a306b052be90ff11c698705cf2d3555a50", "filename": "src/test/ui/errors/issue-104621-extern-not-file.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-not-file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-not-file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-not-file.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: --extern foo=.\n+\n+extern crate foo; //~ ERROR extern location for foo is not a file: .\n+fn main() {}"}, {"sha": "5aaf9741360ef85bb52f03b5f3b6c3a76d931e5a", "filename": "src/test/ui/errors/issue-104621-extern-not-file.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-not-file.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-not-file.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferrors%2Fissue-104621-extern-not-file.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,8 @@\n+error: extern location for foo is not a file: .\n+  --> $DIR/issue-104621-extern-not-file.rs:3:1\n+   |\n+LL | extern crate foo;\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "35994e4a5ba3f5b7556ef82e9cbb6c0def9e12e6", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -20,7 +20,6 @@ impl<T: Send> AnotherTrait for T {}\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n     //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n-    //~| ERROR cannot implement trait on type alias impl trait\n }\n \n fn main() {}"}, {"sha": "81009413c9a268f550e356fe32381bf0e3526a88", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -7,18 +7,6 @@ LL | impl<T: Send> AnotherTrait for T {}\n LL | impl AnotherTrait for D<OpaqueType> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/auto-trait.rs:21:25\n-   |\n-LL | impl AnotherTrait for D<OpaqueType> {\n-   |                         ^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/auto-trait.rs:7:19\n-   |\n-LL | type OpaqueType = impl OpaqueTrait;\n-   |                   ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "70e24a3a9d029b946073b198b4d1cbf7583381a1", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -18,7 +18,6 @@ impl<T: std::fmt::Debug> AnotherTrait for T {}\n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n     //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n-    //~| ERROR cannot implement trait on type alias impl trait\n }\n \n fn main() {}"}, {"sha": "6b8cc9e7374239c2c14036bf2ce6bfd6628323ad", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -9,18 +9,6 @@ LL | impl AnotherTrait for D<OpaqueType> {\n    |\n    = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/negative-reasoning.rs:19:25\n-   |\n-LL | impl AnotherTrait for D<OpaqueType> {\n-   |                         ^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/negative-reasoning.rs:7:19\n-   |\n-LL | type OpaqueType = impl OpaqueTrait;\n-   |                   ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "af9dfe25bb4ce0b4ecaeb198800be7c6e81bd25b", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -5,13 +5,13 @@ type Foo = impl PartialEq<(Foo, i32)>;\n struct Bar;\n \n impl PartialEq<(Foo, i32)> for Bar {\n-//~^ ERROR cannot implement trait on type alias impl trait\n     fn eq(&self, _other: &(Foo, i32)) -> bool {\n         true\n     }\n }\n \n fn foo() -> Foo {\n+    //~^ ERROR can't compare `Bar` with `(Bar, i32)`\n     Bar\n }\n "}, {"sha": "7b63a3d0b9f104fbbe52c964cd4eef44293594ca", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,14 +1,15 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:7:17\n+error[E0277]: can't compare `Bar` with `(Bar, i32)`\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:13:13\n    |\n-LL | impl PartialEq<(Foo, i32)> for Bar {\n-   |                 ^^^\n+LL | fn foo() -> Foo {\n+   |             ^^^ no implementation for `Bar == (Bar, i32)`\n+LL |\n+LL |     Bar\n+   |     --- return type was inferred to be `Bar` here\n    |\n-note: type alias impl trait defined here\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:3:12\n-   |\n-LL | type Foo = impl PartialEq<(Foo, i32)>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: the trait `PartialEq<(Bar, i32)>` is not implemented for `Bar`\n+   = help: the trait `PartialEq<(Foo, i32)>` is implemented for `Bar`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "91f1ed48133f574014eecf8a0fffc31e896bd014", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -2,24 +2,27 @@\n \n mod a {\n     type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR: unconstrained opaque type\n \n     struct Bar;\n \n     impl PartialEq<(Bar, i32)> for Bar {\n         fn eq(&self, _other: &(Foo, i32)) -> bool {\n+            //~^ ERROR: `eq` has an incompatible type for trait\n             true\n         }\n     }\n }\n \n mod b {\n     type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR: unconstrained opaque type\n \n     struct Bar;\n \n     impl PartialEq<(Foo, i32)> for Bar {\n-        //~^ ERROR cannot implement trait on type alias impl trait\n         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+            //~^ ERROR: `eq` has an incompatible type for trait\n             true\n         }\n     }"}, {"sha": "3dda5761ada6b34a97ef22bab914c84611f369cf", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,14 +1,49 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:20:21\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:4:16\n    |\n-LL |     impl PartialEq<(Foo, i32)> for Bar {\n-   |                     ^^^\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error[E0053]: method `eq` has an incompatible type for trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:10:30\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                -------------------------- the found opaque type\n+...\n+LL |         fn eq(&self, _other: &(Foo, i32)) -> bool {\n+   |                              ^^^^^^^^^^^\n+   |                              |\n+   |                              expected struct `a::Bar`, found opaque type\n+   |                              help: change the parameter type to match the trait: `&(a::Bar, i32)`\n    |\n-note: type alias impl trait defined here\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:16:16\n+   = note: expected fn pointer `fn(&a::Bar, &(a::Bar, i32)) -> _`\n+              found fn pointer `fn(&a::Bar, &(a::Foo, i32)) -> _`\n+\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:18:16\n    |\n LL |     type Foo = impl PartialEq<(Foo, i32)>;\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error[E0053]: method `eq` has an incompatible type for trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:24:30\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                -------------------------- the expected opaque type\n+...\n+LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+   |                              ^^^^^^^^^^^\n+   |                              |\n+   |                              expected opaque type, found struct `b::Bar`\n+   |                              help: change the parameter type to match the trait: `&(b::Foo, i32)`\n+   |\n+   = note: expected fn pointer `fn(&b::Bar, &(b::Foo, i32)) -> _`\n+              found fn pointer `fn(&b::Bar, &(b::Bar, i32)) -> _`\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "60f877aa8b30327ad6f60fe740ae995cf02d7716", "filename": "src/test/ui/lint/unused/must-use-ops.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -3,39 +3,49 @@\n // check-pass\n \n #![warn(unused_must_use)]\n+#![feature(never_type)]\n+\n+fn deref_never(x: &!) {\n+    // Don't lint for uninhabited typess\n+    *x;\n+}\n \n fn main() {\n     let val = 1;\n     let val_pointer = &val;\n \n-// Comparison Operators\n+    // Comparison Operators\n     val == 1; //~ WARNING unused comparison\n     val < 1; //~ WARNING unused comparison\n     val <= 1; //~ WARNING unused comparison\n     val != 1; //~ WARNING unused comparison\n     val >= 1; //~ WARNING unused comparison\n     val > 1; //~ WARNING unused comparison\n \n-// Arithmetic Operators\n+    // Arithmetic Operators\n     val + 2; //~ WARNING unused arithmetic operation\n     val - 2; //~ WARNING unused arithmetic operation\n     val / 2; //~ WARNING unused arithmetic operation\n     val * 2; //~ WARNING unused arithmetic operation\n     val % 2; //~ WARNING unused arithmetic operation\n \n-// Logical Operators\n+    // Logical Operators\n     true && true; //~ WARNING unused logical operation\n     false || true; //~ WARNING unused logical operation\n \n-// Bitwise Operators\n+    // Bitwise Operators\n     5 ^ val; //~ WARNING unused bitwise operation\n     5 & val; //~ WARNING unused bitwise operation\n     5 | val; //~ WARNING unused bitwise operation\n     5 << val; //~ WARNING unused bitwise operation\n     5 >> val; //~ WARNING unused bitwise operation\n \n-// Unary Operators\n+    // Unary Operators\n     !val; //~ WARNING unused unary operation\n     -val; //~ WARNING unused unary operation\n     *val_pointer; //~ WARNING unused unary operation\n+\n+    if false {\n+        deref_never(&panic!());\n+    }\n }"}, {"sha": "79a53d39cbf1023f086879f747f4c62575b579a7", "filename": "src/test/ui/lint/unused/must-use-ops.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust-use-ops.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,5 +1,5 @@\n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:12:5\n+  --> $DIR/must-use-ops.rs:18:5\n    |\n LL |     val == 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -15,7 +15,7 @@ LL |     let _ = val == 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:13:5\n+  --> $DIR/must-use-ops.rs:19:5\n    |\n LL |     val < 1;\n    |     ^^^^^^^ the comparison produces a value\n@@ -26,7 +26,7 @@ LL |     let _ = val < 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:14:5\n+  --> $DIR/must-use-ops.rs:20:5\n    |\n LL |     val <= 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -37,7 +37,7 @@ LL |     let _ = val <= 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:15:5\n+  --> $DIR/must-use-ops.rs:21:5\n    |\n LL |     val != 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -48,7 +48,7 @@ LL |     let _ = val != 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:16:5\n+  --> $DIR/must-use-ops.rs:22:5\n    |\n LL |     val >= 1;\n    |     ^^^^^^^^ the comparison produces a value\n@@ -59,7 +59,7 @@ LL |     let _ = val >= 1;\n    |     +++++++\n \n warning: unused comparison that must be used\n-  --> $DIR/must-use-ops.rs:17:5\n+  --> $DIR/must-use-ops.rs:23:5\n    |\n LL |     val > 1;\n    |     ^^^^^^^ the comparison produces a value\n@@ -70,7 +70,7 @@ LL |     let _ = val > 1;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:20:5\n+  --> $DIR/must-use-ops.rs:26:5\n    |\n LL |     val + 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -81,7 +81,7 @@ LL |     let _ = val + 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:21:5\n+  --> $DIR/must-use-ops.rs:27:5\n    |\n LL |     val - 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -92,7 +92,7 @@ LL |     let _ = val - 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:22:5\n+  --> $DIR/must-use-ops.rs:28:5\n    |\n LL |     val / 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -103,7 +103,7 @@ LL |     let _ = val / 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:23:5\n+  --> $DIR/must-use-ops.rs:29:5\n    |\n LL |     val * 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -114,7 +114,7 @@ LL |     let _ = val * 2;\n    |     +++++++\n \n warning: unused arithmetic operation that must be used\n-  --> $DIR/must-use-ops.rs:24:5\n+  --> $DIR/must-use-ops.rs:30:5\n    |\n LL |     val % 2;\n    |     ^^^^^^^ the arithmetic operation produces a value\n@@ -125,7 +125,7 @@ LL |     let _ = val % 2;\n    |     +++++++\n \n warning: unused logical operation that must be used\n-  --> $DIR/must-use-ops.rs:27:5\n+  --> $DIR/must-use-ops.rs:33:5\n    |\n LL |     true && true;\n    |     ^^^^^^^^^^^^ the logical operation produces a value\n@@ -136,7 +136,7 @@ LL |     let _ = true && true;\n    |     +++++++\n \n warning: unused logical operation that must be used\n-  --> $DIR/must-use-ops.rs:28:5\n+  --> $DIR/must-use-ops.rs:34:5\n    |\n LL |     false || true;\n    |     ^^^^^^^^^^^^^ the logical operation produces a value\n@@ -147,7 +147,7 @@ LL |     let _ = false || true;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:31:5\n+  --> $DIR/must-use-ops.rs:37:5\n    |\n LL |     5 ^ val;\n    |     ^^^^^^^ the bitwise operation produces a value\n@@ -158,7 +158,7 @@ LL |     let _ = 5 ^ val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:32:5\n+  --> $DIR/must-use-ops.rs:38:5\n    |\n LL |     5 & val;\n    |     ^^^^^^^ the bitwise operation produces a value\n@@ -169,7 +169,7 @@ LL |     let _ = 5 & val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:33:5\n+  --> $DIR/must-use-ops.rs:39:5\n    |\n LL |     5 | val;\n    |     ^^^^^^^ the bitwise operation produces a value\n@@ -180,7 +180,7 @@ LL |     let _ = 5 | val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:34:5\n+  --> $DIR/must-use-ops.rs:40:5\n    |\n LL |     5 << val;\n    |     ^^^^^^^^ the bitwise operation produces a value\n@@ -191,7 +191,7 @@ LL |     let _ = 5 << val;\n    |     +++++++\n \n warning: unused bitwise operation that must be used\n-  --> $DIR/must-use-ops.rs:35:5\n+  --> $DIR/must-use-ops.rs:41:5\n    |\n LL |     5 >> val;\n    |     ^^^^^^^^ the bitwise operation produces a value\n@@ -202,7 +202,7 @@ LL |     let _ = 5 >> val;\n    |     +++++++\n \n warning: unused unary operation that must be used\n-  --> $DIR/must-use-ops.rs:38:5\n+  --> $DIR/must-use-ops.rs:44:5\n    |\n LL |     !val;\n    |     ^^^^ the unary operation produces a value\n@@ -213,7 +213,7 @@ LL |     let _ = !val;\n    |     +++++++\n \n warning: unused unary operation that must be used\n-  --> $DIR/must-use-ops.rs:39:5\n+  --> $DIR/must-use-ops.rs:45:5\n    |\n LL |     -val;\n    |     ^^^^ the unary operation produces a value\n@@ -224,7 +224,7 @@ LL |     let _ = -val;\n    |     +++++++\n \n warning: unused unary operation that must be used\n-  --> $DIR/must-use-ops.rs:40:5\n+  --> $DIR/must-use-ops.rs:46:5\n    |\n LL |     *val_pointer;\n    |     ^^^^^^^^^^^^ the unary operation produces a value"}, {"sha": "b7bae4b0acf1223df7534d2833f90c6abd77cc31", "filename": "src/test/ui/lint/unused/must_use-array.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,6 +1,7 @@\n #![deny(unused_must_use)]\n \n #[must_use]\n+#[derive(Clone, Copy)]\n struct S;\n \n struct A;\n@@ -34,6 +35,10 @@ fn array_of_arrays_of_arrays() -> [[[S; 1]; 2]; 1] {\n     [[[S], [S]]]\n }\n \n+fn usize_max() -> [S; usize::MAX] {\n+    [S; usize::MAX]\n+}\n+\n fn main() {\n     empty(); // ok\n     singleton(); //~ ERROR unused array of `S` that must be used\n@@ -44,4 +49,6 @@ fn main() {\n     //~^ ERROR unused array of boxed `T` trait objects in tuple element 1 that must be used\n     array_of_arrays_of_arrays();\n     //~^ ERROR unused array of arrays of arrays of `S` that must be used\n+    usize_max();\n+    //~^ ERROR unused array of `S` that must be used\n }"}, {"sha": "61ef2088d30e555354af5d2bf1161117a46345d7", "filename": "src/test/ui/lint/unused/must_use-array.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fmust_use-array.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,5 +1,5 @@\n error: unused array of `S` that must be used\n-  --> $DIR/must_use-array.rs:39:5\n+  --> $DIR/must_use-array.rs:44:5\n    |\n LL |     singleton();\n    |     ^^^^^^^^^^^\n@@ -11,34 +11,40 @@ LL | #![deny(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n \n error: unused array of `S` that must be used\n-  --> $DIR/must_use-array.rs:40:5\n+  --> $DIR/must_use-array.rs:45:5\n    |\n LL |     many();\n    |     ^^^^^^\n \n error: unused array of `S` in tuple element 0 that must be used\n-  --> $DIR/must_use-array.rs:41:6\n+  --> $DIR/must_use-array.rs:46:6\n    |\n LL |     ([S], 0, ());\n    |      ^^^\n \n error: unused array of implementers of `T` that must be used\n-  --> $DIR/must_use-array.rs:42:5\n+  --> $DIR/must_use-array.rs:47:5\n    |\n LL |     array_of_impl_trait();\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: unused array of boxed `T` trait objects in tuple element 1 that must be used\n-  --> $DIR/must_use-array.rs:43:5\n+  --> $DIR/must_use-array.rs:48:5\n    |\n LL |     impl_array();\n    |     ^^^^^^^^^^^^\n \n error: unused array of arrays of arrays of `S` that must be used\n-  --> $DIR/must_use-array.rs:45:5\n+  --> $DIR/must_use-array.rs:50:5\n    |\n LL |     array_of_arrays_of_arrays();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: unused array of `S` that must be used\n+  --> $DIR/must_use-array.rs:52:5\n+   |\n+LL |     usize_max();\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "2462e703a71656053f59d5df6fbfefd3cadfc1eb", "filename": "src/test/ui/traits/alias/issue-83613.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -9,5 +9,4 @@ trait AnotherTrait {}\n impl<T: Send> AnotherTrait for T {}\n impl AnotherTrait for OpaqueType {}\n //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n-//~| ERROR cannot implement trait on type alias impl trait\n fn main() {}"}, {"sha": "a78294da6c140766c4650b8a9aabe8bf3fc2c0cf", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -6,18 +6,6 @@ LL | impl<T: Send> AnotherTrait for T {}\n LL | impl AnotherTrait for OpaqueType {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-83613.rs:10:23\n-   |\n-LL | impl AnotherTrait for OpaqueType {}\n-   |                       ^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-83613.rs:4:19\n-   |\n-LL | type OpaqueType = impl OpaqueTrait;\n-   |                   ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "077a31494a972fe4517a0cb9cae4a54774538f4e", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -12,6 +12,6 @@ fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n }\n \n impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-//~^ ERROR cannot implement trait on type alias impl trait\n+//~^ ERROR only traits defined in the current crate can be implemented for arbitrary types\n \n fn main() {}"}, {"sha": "c923eb08ab312fa5d5cb112b834d1b0dee596624", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,14 +1,14 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/coherence.rs:14:41\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/coherence.rs:14:1\n    |\n LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---------------------\n+   | |                                       |\n+   | |                                       `AliasOfForeignType<T>` is not defined in the current crate\n+   | impl doesn't use only types from inside the current crate\n    |\n-note: type alias impl trait defined here\n-  --> $DIR/coherence.rs:9:30\n-   |\n-LL | type AliasOfForeignType<T> = impl LocalTrait;\n-   |                              ^^^^^^^^^^^^^^^\n+   = note: define and implement a trait or new type instead\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "5c9ad9498b6de056920e30dad9fc782d5cfb2de9", "filename": "src/test/ui/type-alias-impl-trait/coherence_generalization.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence_generalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence_generalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence_generalization.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+trait Trait {}\n+type Opaque<T> = impl Sized;\n+fn foo<T>() -> Opaque<T> {\n+    ()\n+}\n+\n+impl<T, V> Trait for (T, V, V, u32) {}\n+impl<U, V> Trait for (Opaque<U>, V, i32, V) {}\n+\n+fn main() {}"}, {"sha": "0efbd1c2bd5fd4cb4700a04957722f6d82bab782", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_generic_tait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_generic_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_generic_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_generic_tait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for i32 {\n+    type Assoc = u32;\n+}\n+type ImplTrait = impl Sized;\n+fn constrain() -> ImplTrait {\n+    1u64\n+}\n+impl Foo for i64 {\n+    type Assoc = ImplTrait;\n+}\n+\n+trait Bar<T> {}\n+\n+impl<T: Foo> Bar<<T as Foo>::Assoc> for T {}\n+\n+fn main() {}"}, {"sha": "3f1a9d12b44f91f1a5f8fdf41aafbd64f5f1da5b", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_same_tait.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,33 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Foo {}\n+impl Foo for () {}\n+impl Foo for i32 {}\n+\n+type Bar<T: Foo> = impl std::fmt::Debug;\n+fn defining_use<T: Foo>() -> Bar<T> {\n+    42\n+}\n+\n+trait Bop {}\n+\n+impl Bop for Bar<()> {}\n+\n+// If the hidden type is the same, this is effectively a second impl for the same type.\n+impl Bop for Bar<i32> {}\n+//~^ ERROR conflicting implementations\n+\n+type Barr = impl std::fmt::Debug;\n+fn defining_use2() -> Barr {\n+    42\n+}\n+\n+// Even completely different opaque types must conflict.\n+impl Bop for Barr {}\n+//~^ ERROR conflicting implementations\n+\n+// And obviously the hidden type must conflict, too.\n+impl Bop for i32 {}\n+//~^ ERROR conflicting implementations\n+\n+fn main() {}"}, {"sha": "aaf75cc3db97c48316aff9408b4ad11a53214318", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_same_tait.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,30 @@\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:17:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for Bar<i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:26:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for Barr {}\n+   | ^^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:30:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for i32 {}\n+   | ^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "9f32c5d888b5f40efa983dc4ed6f7fde064f27c5", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: --crate-type=lib\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+type Alias = impl Sized;\n+\n+fn constrain() -> Alias {\n+    1i32\n+}\n+\n+trait HideIt {\n+    type Assoc;\n+}\n+\n+impl HideIt for () {\n+    type Assoc = Alias;\n+}\n+\n+pub trait Yay {}\n+\n+impl Yay for <() as HideIt>::Assoc {}"}, {"sha": "8ec20acef4de6df8d6dd4d34e7d089c58b341d5f", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+type Foo = impl Debug;\n+pub trait Yay { }\n+impl Yay for Foo { }\n+\n+fn foo() {\n+    is_yay::<u32>();   //~ ERROR: the trait bound `u32: Yay` is not satisfied\n+    is_debug::<u32>(); // OK\n+    is_yay::<Foo>();   // OK\n+    is_debug::<Foo>(); // OK\n+}\n+\n+fn is_yay<T: Yay>() { }\n+fn is_debug<T: Debug>() { }\n+\n+fn main() {}"}, {"sha": "1c83105a18affe735ab0032e4488304f04848119", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `u32: Yay` is not satisfied\n+  --> $DIR/impl_trait_for_tait_bound.rs:10:14\n+   |\n+LL |     is_yay::<u32>();\n+   |              ^^^ the trait `Yay` is not implemented for `u32`\n+   |\n+   = help: the trait `Yay` is implemented for `Foo`\n+note: required by a bound in `is_yay`\n+  --> $DIR/impl_trait_for_tait_bound.rs:16:14\n+   |\n+LL | fn is_yay<T: Yay>() { }\n+   |              ^^^ required by this bound in `is_yay`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a4b8c2d190db93c9d5c67f48a94f059b818c0797", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,16 @@\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+type Foo = impl Debug;\n+\n+pub trait Yay { }\n+impl Yay for u32 { }\n+\n+fn foo() {\n+    is_yay::<Foo>(); //~ ERROR: the trait bound `Foo: Yay` is not satisfied\n+}\n+\n+fn is_yay<T: Yay>() { }\n+\n+fn main() {}"}, {"sha": "a6440f02c27d856b6e022de13ca933b15f9c0071", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `Foo: Yay` is not satisfied\n+  --> $DIR/impl_trait_for_tait_bound2.rs:11:14\n+   |\n+LL |     is_yay::<Foo>();\n+   |              ^^^ the trait `Yay` is not implemented for `Foo`\n+   |\n+   = help: the trait `Yay` is implemented for `u32`\n+note: required by a bound in `is_yay`\n+  --> $DIR/impl_trait_for_tait_bound2.rs:14:14\n+   |\n+LL | fn is_yay<T: Yay>() { }\n+   |              ^^^ required by this bound in `is_yay`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9a9b2269f802eebf488667a03a464fcbc032ec23", "filename": "src/test/ui/type-alias-impl-trait/issue-65384.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -8,7 +8,7 @@ impl MyTrait for () {}\n type Bar = impl MyTrait;\n \n impl MyTrait for Bar {}\n-//~^ ERROR: cannot implement trait on type alias impl trait\n+//~^ ERROR: conflicting implementations of trait `MyTrait` for type `()`\n \n fn bazr() -> Bar { }\n "}, {"sha": "f6692ae320733d679e5562c84c1efc0827de7813", "filename": "src/test/ui/type-alias-impl-trait/issue-65384.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,14 +1,12 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-65384.rs:10:18\n+error[E0119]: conflicting implementations of trait `MyTrait` for type `()`\n+  --> $DIR/issue-65384.rs:10:1\n    |\n+LL | impl MyTrait for () {}\n+   | ------------------- first implementation here\n+...\n LL | impl MyTrait for Bar {}\n-   |                  ^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-65384.rs:8:12\n-   |\n-LL | type Bar = impl MyTrait;\n-   |            ^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "b97e444c6d0e0d0824f38998a9ff9bdc107418fb", "filename": "src/test/ui/type-alias-impl-trait/issue-76202-trait-impl-for-tait.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,6 +1,8 @@\n // Regression test for issue #76202\n // Tests that we don't ICE when we have a trait impl on a TAIT.\n \n+// check-pass\n+\n #![feature(type_alias_impl_trait)]\n \n trait Dummy {}\n@@ -14,7 +16,12 @@ trait Test {\n }\n \n impl Test for F {\n-    //~^ ERROR cannot implement trait\n+    fn test(self) {}\n+}\n+\n+// Ok because `i32` does not implement `Dummy`,\n+// so it can't possibly be the hidden type of `F`.\n+impl Test for i32 {\n     fn test(self) {}\n }\n "}, {"sha": "2d4a6854a920be74ffc2add35ade869546709f08", "filename": "src/test/ui/type-alias-impl-trait/issue-76202-trait-impl-for-tait.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/008bc1d587b4f9d7197eb159922dd2080eea9284/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/008bc1d587b4f9d7197eb159922dd2080eea9284/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr?ref=008bc1d587b4f9d7197eb159922dd2080eea9284", "patch": "@@ -1,14 +0,0 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-76202-trait-impl-for-tait.rs:16:15\n-   |\n-LL | impl Test for F {\n-   |               ^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-76202-trait-impl-for-tait.rs:9:10\n-   |\n-LL | type F = impl Dummy;\n-   |          ^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "2ba4befea2a3930fc4b37fa3141e364c2a363c25", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-trait-impl-for-tait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,6 +1,8 @@\n // Regression test for issues #84660 and #86411: both are variations on #76202.\n // Tests that we don't ICE when we have an opaque type appearing anywhere in an impl header.\n \n+// check-pass\n+\n #![feature(type_alias_impl_trait)]\n \n trait Foo {}\n@@ -12,7 +14,7 @@ trait TraitArg<T> {\n     fn f();\n }\n \n-impl TraitArg<Bar> for () { //~ ERROR cannot implement trait\n+impl TraitArg<Bar> for () {\n     fn f() {\n         println!(\"ho\");\n     }"}, {"sha": "bb70d07be59bb0da395cd94836186ebc06d5e379", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-trait-impl-for-tait.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/008bc1d587b4f9d7197eb159922dd2080eea9284/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/008bc1d587b4f9d7197eb159922dd2080eea9284/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr?ref=008bc1d587b4f9d7197eb159922dd2080eea9284", "patch": "@@ -1,14 +0,0 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-84660-trait-impl-for-tait.rs:15:15\n-   |\n-LL | impl TraitArg<Bar> for () {\n-   |               ^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-84660-trait-impl-for-tait.rs:8:12\n-   |\n-LL | type Bar = impl Foo;\n-   |            ^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "48d4b0c96ff0a0602e97efe2a622c44d741caa0d", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-unsoundness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -13,14 +13,14 @@ trait Trait<T, In> {\n     fn convert(i: In) -> Self::Out;\n }\n \n-impl<In, Out> Trait<Bar, In> for Out { //~ ERROR cannot implement trait\n+impl<In, Out> Trait<Bar, In> for Out {\n     type Out = Out;\n     fn convert(_i: In) -> Self::Out {\n         unreachable!();\n     }\n }\n \n-impl<In, Out> Trait<(), In> for Out {\n+impl<In, Out> Trait<(), In> for Out { //~ ERROR conflicting implementations of trait `Trait<Bar, _>`\n     type Out = In;\n     fn convert(i: In) -> Self::Out {\n         i"}, {"sha": "6a75e1bd2c0fa879eed9bbed7a2079d6c961acf3", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-unsoundness.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,14 +1,12 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-84660-unsoundness.rs:16:21\n+error[E0119]: conflicting implementations of trait `Trait<Bar, _>`\n+  --> $DIR/issue-84660-unsoundness.rs:23:1\n    |\n LL | impl<In, Out> Trait<Bar, In> for Out {\n-   |                     ^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-84660-unsoundness.rs:8:12\n-   |\n-LL | type Bar = impl Foo;\n-   |            ^^^^^^^^\n+   | ------------------------------------ first implementation here\n+...\n+LL | impl<In, Out> Trait<(), In> for Out {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "b0ebdd1bfab7d9e4108579346fe821c5d8758056", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -4,11 +4,11 @@\n use std::fmt::Debug;\n \n type FooX = impl Debug;\n+//~^ ERROR unconstrained opaque type\n \n trait Foo<A> { }\n \n impl Foo<FooX> for () { }\n-//~^ cannot implement trait on type alias impl trait\n \n fn foo() -> impl Foo<FooX> {\n     ()"}, {"sha": "b1d947a9ccf4ec62423b7119c21b4cd7ee1f120f", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -1,14 +1,10 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/nested-tait-inference3.rs:10:10\n-   |\n-LL | impl Foo<FooX> for () { }\n-   |          ^^^^\n-   |\n-note: type alias impl trait defined here\n+error: unconstrained opaque type\n   --> $DIR/nested-tait-inference3.rs:6:13\n    |\n LL | type FooX = impl Debug;\n    |             ^^^^^^^^^^\n+   |\n+   = note: `FooX` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "d183e28f667c01178d9f156deb173ea80f13d9fe", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2b2eee8f46f2252d2919d7a57bf3068d7df285/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=3f2b2eee8f46f2252d2919d7a57bf3068d7df285", "patch": "@@ -37,6 +37,7 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: Option<\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {predicate:#?}\"),\n+                ty::PredicateKind::Ambiguous => panic!(\"ambiguous predicate on function: {predicate:#?}\"),\n             }\n         }\n         match predicates.parent {"}]}