{"sha": "483f71c8b1dceb684af7c9006d39e8fd56c41c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4M2Y3MWM4YjFkY2ViNjg0YWY3YzkwMDZkMzllOGZkNTZjNDFjODA=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-02T07:34:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-02T07:34:16Z"}, "message": "Merge pull request #2218 from pietroalbini/fix-ast-for-use_nested_groups\n\nFix broken build after use_nested_groups lands on nightly", "tree": {"sha": "c8241d6a0a4faaaff50ed92e95bb3bbd8a72f03c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8241d6a0a4faaaff50ed92e95bb3bbd8a72f03c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/483f71c8b1dceb684af7c9006d39e8fd56c41c80", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaIld4CRBK7hj4Ov3rIwAAdHIIAAjidcKwrWWZHqfp0AgFKhyP\nQkeBkFHwz7lxnqjN7BnlWwHGHsyN+sbk7etYXmHnygHcYOVrR8XHwaJBvuJZFpVG\nYxHUj5fZ2UnIUwI+joR9MTUzJJUtQ2SIUs5QmvcsLImpcJt5p1e4nDjjMfXGVz5X\nypGAQHN2N1JtxDHBvpukxqA2azZBP3Uf/u0Rhz+QiaWSIYFchpKC4nBVKj470gcm\njWEsdTwgJkcpj9hxW9DpxqGS/Gy5yA224MB2d02y+tmU5ghg7FK5Je3ejqIPiKGa\n+ECaCCvfiQWz/1i0dITUmxmKp5TuvwUm6fBMNtK1cDgNU5ZckX08QxXXUG1CMj0=\n=Mhsg\n-----END PGP SIGNATURE-----\n", "payload": "tree c8241d6a0a4faaaff50ed92e95bb3bbd8a72f03c\nparent 8f6b6c28f703a492dbdf7f118d82ad2782ef795a\nparent 9d8cfbcd93209aaa56f9576324a2d7e5784390da\nauthor Seiichi Uchida <seuchida@gmail.com> 1512200056 +0900\ncommitter GitHub <noreply@github.com> 1512200056 +0900\n\nMerge pull request #2218 from pietroalbini/fix-ast-for-use_nested_groups\n\nFix broken build after use_nested_groups lands on nightly"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/483f71c8b1dceb684af7c9006d39e8fd56c41c80", "html_url": "https://github.com/rust-lang/rust/commit/483f71c8b1dceb684af7c9006d39e8fd56c41c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/483f71c8b1dceb684af7c9006d39e8fd56c41c80/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f6b6c28f703a492dbdf7f118d82ad2782ef795a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6b6c28f703a492dbdf7f118d82ad2782ef795a", "html_url": "https://github.com/rust-lang/rust/commit/8f6b6c28f703a492dbdf7f118d82ad2782ef795a"}, {"sha": "9d8cfbcd93209aaa56f9576324a2d7e5784390da", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d8cfbcd93209aaa56f9576324a2d7e5784390da", "html_url": "https://github.com/rust-lang/rust/commit/9d8cfbcd93209aaa56f9576324a2d7e5784390da"}], "stats": {"total": 262, "additions": 135, "deletions": 127}, "files": [{"sha": "24ca36851a1047977e7a61ef0fe8c68a17c00ef6", "filename": "src/imports.rs", "status": "modified", "additions": 134, "deletions": 126, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/483f71c8b1dceb684af7c9006d39e8fd56c41c80/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483f71c8b1dceb684af7c9006d39e8fd56c41c80/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=483f71c8b1dceb684af7c9006d39e8fd56c41c80", "patch": "@@ -13,6 +13,7 @@ use std::cmp::Ordering;\n use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n \n+\n use spanned::Spanned;\n use codemap::SpanUtils;\n use comment::combine_strs_with_missing_comments;\n@@ -25,14 +26,6 @@ use types::{rewrite_path, PathContext};\n use utils::{format_visibility, mk_sp};\n use visitor::{rewrite_extern_crate, FmtVisitor};\n \n-fn path_of(a: &ast::ViewPath_) -> &ast::Path {\n-    match *a {\n-        ast::ViewPath_::ViewPathSimple(_, ref p)\n-        | ast::ViewPath_::ViewPathGlob(ref p)\n-        | ast::ViewPath_::ViewPathList(ref p, _) => p,\n-    }\n-}\n-\n fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n     a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n }\n@@ -47,75 +40,76 @@ fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n     a.segments.len().cmp(&b.segments.len())\n }\n \n-fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Ordering {\n-    let a_name_str = &*a.node.name.name.as_str();\n-    let b_name_str = &*b.node.name.name.as_str();\n-    let name_ordering = if a_name_str == \"self\" {\n-        if b_name_str == \"self\" {\n-            Ordering::Equal\n-        } else {\n-            Ordering::Less\n-        }\n-    } else if b_name_str == \"self\" {\n-        Ordering::Greater\n-    } else {\n-        a_name_str.cmp(b_name_str)\n-    };\n-    if name_ordering == Ordering::Equal {\n-        match a.node.rename {\n-            Some(a_rename) => match b.node.rename {\n-                Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n-                None => Ordering::Greater,\n-            },\n-            None => Ordering::Less,\n-        }\n-    } else {\n-        name_ordering\n-    }\n-}\n+fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n+    use ast::UseTreeKind::*;\n \n-fn compare_path_list_item_lists(\n-    a_items: &[ast::PathListItem],\n-    b_items: &[ast::PathListItem],\n-) -> Ordering {\n-    let mut a = a_items.to_owned();\n-    let mut b = b_items.to_owned();\n-    a.sort_by(|a, b| compare_path_list_items(a, b));\n-    b.sort_by(|a, b| compare_path_list_items(a, b));\n-    for comparison_pair in a.iter().zip(b.iter()) {\n-        let ord = compare_path_list_items(comparison_pair.0, comparison_pair.1);\n-        if ord != Ordering::Equal {\n-            return ord;\n+    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n+    // fully added\n+    if !nested {\n+        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n+        if paths_cmp != Ordering::Equal {\n+            return paths_cmp;\n         }\n     }\n-    a.len().cmp(&b.len())\n-}\n \n-fn compare_view_path_types(a: &ast::ViewPath_, b: &ast::ViewPath_) -> Ordering {\n-    use syntax::ast::ViewPath_::*;\n-    match (a, b) {\n-        (&ViewPathSimple(..), &ViewPathSimple(..)) | (&ViewPathGlob(_), &ViewPathGlob(_)) => {\n-            Ordering::Equal\n+    match (&a.kind, &b.kind) {\n+        (&Simple(ident_a), &Simple(ident_b)) => {\n+            let name_a = &*a.prefix.segments.last().unwrap().identifier.name.as_str();\n+            let name_b = &*b.prefix.segments.last().unwrap().identifier.name.as_str();\n+            let name_ordering = if name_a == \"self\" {\n+                if name_b == \"self\" {\n+                    Ordering::Equal\n+                } else {\n+                    Ordering::Less\n+                }\n+            } else if name_b == \"self\" {\n+                Ordering::Greater\n+            } else {\n+                name_a.cmp(name_b)\n+            };\n+            if name_ordering == Ordering::Equal {\n+                if ident_a.name.as_str() != name_a {\n+                    if ident_b.name.as_str() != name_b {\n+                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n+                    } else {\n+                        Ordering::Greater\n+                    }\n+                } else {\n+                    Ordering::Less\n+                }\n+            } else {\n+                name_ordering\n+            }\n         }\n-        (&ViewPathSimple(..), _) | (&ViewPathGlob(_), &ViewPathList(..)) => Ordering::Less,\n-        (&ViewPathList(_, ref a_items), &ViewPathList(_, ref b_items)) => {\n-            compare_path_list_item_lists(a_items, b_items)\n+        (&Glob, &Glob) => Ordering::Equal,\n+        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n+        (&Nested(ref a_items), &Nested(ref b_items)) => {\n+            let mut a = a_items\n+                .iter()\n+                .map(|&(ref tree, _)| tree.clone())\n+                .collect::<Vec<_>>();\n+            let mut b = b_items\n+                .iter()\n+                .map(|&(ref tree, _)| tree.clone())\n+                .collect::<Vec<_>>();\n+            a.sort_by(|a, b| compare_use_trees(a, b, true));\n+            b.sort_by(|a, b| compare_use_trees(a, b, true));\n+            for comparison_pair in a.iter().zip(b.iter()) {\n+                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n+                if ord != Ordering::Equal {\n+                    return ord;\n+                }\n+            }\n+            a.len().cmp(&b.len())\n         }\n-        (&ViewPathGlob(_), &ViewPathSimple(..)) | (&ViewPathList(..), _) => Ordering::Greater,\n-    }\n-}\n-\n-fn compare_view_paths(a: &ast::ViewPath_, b: &ast::ViewPath_) -> Ordering {\n-    match compare_paths(path_of(a), path_of(b)) {\n-        Ordering::Equal => compare_view_path_types(a, b),\n-        cmp => cmp,\n+        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n     }\n }\n \n fn compare_use_items(context: &RewriteContext, a: &ast::Item, b: &ast::Item) -> Option<Ordering> {\n     match (&a.node, &b.node) {\n-        (&ast::ItemKind::Use(ref a_vp), &ast::ItemKind::Use(ref b_vp)) => {\n-            Some(compare_view_paths(&a_vp.node, &b_vp.node))\n+        (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n+            Some(compare_use_trees(&a_tree, &b_tree, false))\n         }\n         (&ast::ItemKind::ExternCrate(..), &ast::ItemKind::ExternCrate(..)) => {\n             Some(context.snippet(a.span).cmp(&context.snippet(b.span)))\n@@ -127,11 +121,7 @@ fn compare_use_items(context: &RewriteContext, a: &ast::Item, b: &ast::Item) ->\n // TODO (some day) remove unused imports, expand globs, compress many single\n // imports into a list import.\n \n-fn rewrite_view_path_prefix(\n-    path: &ast::Path,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n+fn rewrite_prefix(path: &ast::Path, context: &RewriteContext, shape: Shape) -> Option<String> {\n     let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\"\n         && path.segments.len() > 1\n     {\n@@ -146,29 +136,34 @@ fn rewrite_view_path_prefix(\n     Some(path_str)\n }\n \n-impl Rewrite for ast::ViewPath {\n+impl Rewrite for ast::UseTree {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match self.node {\n-            ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n-                rewrite_use_list(shape, path, path_list, self.span, context)\n+        match self.kind {\n+            ast::UseTreeKind::Nested(ref items) => {\n+                rewrite_nested_use_tree(shape, &self.prefix, items, self.span, context)\n             }\n-            ast::ViewPath_::ViewPathGlob(ref path) => {\n-                // 4 = \"::*\".len()\n+            ast::UseTreeKind::Glob => {\n                 let prefix_shape = shape.sub_width(3)?;\n-                let path_str = rewrite_view_path_prefix(path, context, prefix_shape)?;\n-                Some(format!(\"{}::*\", path_str))\n+\n+                if self.prefix.segments.len() > 0 {\n+                    let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)?;\n+                    Some(format!(\"{}::*\", path_str))\n+                } else {\n+                    Some(\"*\".into())\n+                }\n             }\n-            ast::ViewPath_::ViewPathSimple(ident, ref path) => {\n+            ast::UseTreeKind::Simple(ident) => {\n                 let ident_str = ident.to_string();\n+\n                 // 4 = \" as \".len()\n                 let prefix_shape = shape.sub_width(ident_str.len() + 4)?;\n-                let path_str = rewrite_view_path_prefix(path, context, prefix_shape)?;\n+                let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)?;\n \n-                Some(if path.segments.last().unwrap().identifier == ident {\n-                    path_str\n+                if self.prefix.segments.last().unwrap().identifier == ident {\n+                    Some(path_str)\n                 } else {\n-                    format!(\"{} as {}\", path_str, ident_str)\n-                })\n+                    Some(format!(\"{} as {}\", path_str, ident_str))\n+                }\n             }\n         }\n     }\n@@ -178,7 +173,7 @@ impl Rewrite for ast::ViewPath {\n fn rewrite_import(\n     context: &RewriteContext,\n     vis: &ast::Visibility,\n-    vp: &ast::ViewPath,\n+    tree: &ast::UseTree,\n     attrs: &[ast::Attribute],\n     shape: Shape,\n ) -> Option<String> {\n@@ -187,14 +182,12 @@ fn rewrite_import(\n     let rw = shape\n         .offset_left(vis.len() + 4)\n         .and_then(|shape| shape.sub_width(1))\n-        .and_then(|shape| match vp.node {\n-            // If we have an empty path list with no attributes, we erase it\n-            ast::ViewPath_::ViewPathList(_, ref path_list)\n-                if path_list.is_empty() && attrs.is_empty() =>\n-            {\n+        .and_then(|shape| match tree.kind {\n+            // If we have an empty nested group with no attributes, we erase it\n+            ast::UseTreeKind::Nested(ref items) if items.is_empty() && attrs.is_empty() => {\n                 Some(\"\".into())\n             }\n-            _ => vp.rewrite(context, shape),\n+            _ => tree.rewrite(context, shape),\n         });\n     match rw {\n         Some(ref s) if !s.is_empty() => Some(format!(\"{}use {};\", vis, s)),\n@@ -225,8 +218,8 @@ fn rewrite_imports(\n             };\n \n             let item_str = match item.node {\n-                ast::ItemKind::Use(ref vp) => {\n-                    rewrite_import(context, &item.vis, vp, &item.attrs, shape)?\n+                ast::ItemKind::Use(ref tree) => {\n+                    rewrite_import(context, &item.vis, tree, &item.attrs, shape)?\n                 }\n                 ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n                 _ => return None,\n@@ -276,10 +269,10 @@ impl<'a> FmtVisitor<'a> {\n         self.push_rewrite(span, rw);\n     }\n \n-    pub fn format_import(&mut self, item: &ast::Item, vp: &ast::ViewPath) {\n+    pub fn format_import(&mut self, item: &ast::Item, tree: &ast::UseTree) {\n         let span = item.span;\n         let shape = self.shape();\n-        let rw = rewrite_import(&self.get_context(), &item.vis, vp, &item.attrs, shape);\n+        let rw = rewrite_import(&self.get_context(), &item.vis, tree, &item.attrs, shape);\n         match rw {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n@@ -304,34 +297,48 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String {\n-    let mut item_str = vpi.node.name.to_string();\n-    if item_str == \"self\" {\n-        item_str = \"\".to_owned();\n-    }\n-    let path_item_str = if path_str.is_empty() {\n-        if item_str.is_empty() {\n-            \"self\".to_owned()\n+fn rewrite_nested_use_tree_single(path_str: String, tree: &ast::UseTree) -> String {\n+    if let ast::UseTreeKind::Simple(rename) = tree.kind {\n+        let ident = tree.prefix.segments.last().unwrap().identifier;\n+        let mut item_str = ident.name.to_string();\n+        if item_str == \"self\" {\n+            item_str = \"\".to_owned();\n+        }\n+\n+        let path_item_str = if path_str.is_empty() {\n+            if item_str.is_empty() {\n+                \"self\".to_owned()\n+            } else {\n+                item_str\n+            }\n+        } else if item_str.is_empty() {\n+            path_str\n         } else {\n-            item_str\n+            format!(\"{}::{}\", path_str, item_str)\n+        };\n+\n+        if ident == rename {\n+            path_item_str\n+        } else {\n+            format!(\"{} as {}\", path_item_str, rename)\n         }\n-    } else if item_str.is_empty() {\n-        path_str\n     } else {\n-        format!(\"{}::{}\", path_str, item_str)\n-    };\n-    append_alias(path_item_str, vpi)\n+        unimplemented!(\"`use_nested_groups` is not yet fully supported\");\n+    }\n }\n \n-fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n-    Some(append_alias(vpi.node.name.to_string(), vpi))\n-}\n+fn rewrite_nested_use_tree_item(tree: &&ast::UseTree) -> Option<String> {\n+    Some(if let ast::UseTreeKind::Simple(rename) = tree.kind {\n+        let ident = tree.prefix.segments.last().unwrap().identifier;\n \n-fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n-    match vpi.node.rename {\n-        Some(rename) => format!(\"{} as {}\", path_item_str, rename),\n-        None => path_item_str,\n-    }\n+        if ident == rename {\n+            ident.name.to_string()\n+        } else {\n+            format!(\"{} as {}\", ident.name.to_string(), rename)\n+        }\n+    } else {\n+        unimplemented!(\"`use_nested_groups` is not yet fully supported\");\n+    })\n }\n \n #[derive(Eq, PartialEq)]\n@@ -408,22 +415,23 @@ impl<'a> Ord for ImportItem<'a> {\n \n // Pretty prints a multi-item import.\n // If the path list is empty, it leaves the braces empty.\n-fn rewrite_use_list(\n+fn rewrite_nested_use_tree(\n     shape: Shape,\n     path: &ast::Path,\n-    path_list: &[ast::PathListItem],\n+    trees: &[(ast::UseTree, ast::NodeId)],\n     span: Span,\n     context: &RewriteContext,\n ) -> Option<String> {\n     // Returns a different option to distinguish `::foo` and `foo`\n     let path_str = rewrite_path(context, PathContext::Import, None, path, shape)?;\n \n-    match path_list.len() {\n+    match trees.len() {\n         0 => {\n             return rewrite_path(context, PathContext::Import, None, path, shape)\n                 .map(|path_str| format!(\"{}::{{}}\", path_str));\n         }\n-        1 => return Some(rewrite_single_use_list(path_str, &path_list[0])),\n+        // TODO: fix this\n+        1 => return Some(rewrite_nested_use_tree_single(path_str, &trees[0].0)),\n         _ => (),\n     }\n \n@@ -441,12 +449,12 @@ fn rewrite_use_list(\n         let mut items = vec![ListItem::from_str(\"\")];\n         let iter = itemize_list(\n             context.codemap,\n-            path_list.iter(),\n+            trees.iter().map(|ref tree| &tree.0),\n             \"}\",\n             \",\",\n-            |vpi| vpi.span.lo(),\n-            |vpi| vpi.span.hi(),\n-            rewrite_path_item,\n+            |tree| tree.span.lo(),\n+            |tree| tree.span.hi(),\n+            rewrite_nested_use_tree_item,\n             context.codemap.span_after(span, \"{\"),\n             span.hi(),\n             false,"}, {"sha": "f278ec35d47dc8c312210cd97873ad84f07f7167", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/483f71c8b1dceb684af7c9006d39e8fd56c41c80/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/483f71c8b1dceb684af7c9006d39e8fd56c41c80/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=483f71c8b1dceb684af7c9006d39e8fd56c41c80", "patch": "@@ -330,7 +330,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match item.node {\n-            ast::ItemKind::Use(ref vp) => self.format_import(item, vp),\n+            ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n             ast::ItemKind::Impl(..) => {\n                 let snippet = self.snippet(item.span);\n                 let where_span_end = snippet"}]}