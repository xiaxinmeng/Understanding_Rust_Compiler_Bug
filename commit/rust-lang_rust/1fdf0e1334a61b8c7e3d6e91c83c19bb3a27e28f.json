{"sha": "1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "node_id": "C_kwDOAAsO6NoAKDFmZGYwZTEzMzRhNjFiOGM3ZTNkNmU5MWM4M2MxOWJiM2EyN2UyOGY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-15T20:30:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-15T20:30:55Z"}, "message": "Rollup merge of #107034 - IntQuant:issue-100717-infer-5, r=oli-obk\n\nMigrating rustc_infer to session diagnostics (part 4)\n\n`@rustbot` label +A-translation\nr? rust-lang/diagnostics\ncc https://github.com/rust-lang/rust/issues/100717", "tree": {"sha": "1f226f714e5ec5047354f454ef98215da2e67d9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f226f714e5ec5047354f454ef98215da2e67d9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7UD/CRBK7hj4Ov3rIwAA90QIAETyh4jnmUbfBv1TkPpaWM5O\nTQoWrkor438wRYi2o4Vk5hmBpth26pEJktRYcvyv75e5SGEq7EgNPazot1aEFaqg\niPzoPhymoPpwz7L9Fx8ZAGoxohSGfl8Y/Jwv94QWSLUJaPMyUnZQSGCKso+/XsiK\n0viu3wgkVK0nyCzDoG7RGGk/CWkoBwAv2EPxPNdv/PKGOHQZaY4V5PjvMRF6US8C\nriQzTV3tZQqGuREqdVDIPJ4tjTFdhkCmisynOBkgxt0GUzcWUhkSCIXR8i7HvUbk\n4VigH8CTgwfifQOj4e3UcJyVmfgjTUbSXau0u5lpLsFw339WizAvyIUlyT+tURc=\n=kAL2\n-----END PGP SIGNATURE-----\n", "payload": "tree 1f226f714e5ec5047354f454ef98215da2e67d9e\nparent 2d14db321b043ffc579a7461464c88d7e3f54f83\nparent 58939b9520e71b6caa2ccc5ca28071e6379d39c0\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676493055 +0100\ncommitter GitHub <noreply@github.com> 1676493055 +0100\n\nRollup merge of #107034 - IntQuant:issue-100717-infer-5, r=oli-obk\n\nMigrating rustc_infer to session diagnostics (part 4)\n\n`@rustbot` label +A-translation\nr? rust-lang/diagnostics\ncc https://github.com/rust-lang/rust/issues/100717\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "html_url": "https://github.com/rust-lang/rust/commit/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d14db321b043ffc579a7461464c88d7e3f54f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d14db321b043ffc579a7461464c88d7e3f54f83", "html_url": "https://github.com/rust-lang/rust/commit/2d14db321b043ffc579a7461464c88d7e3f54f83"}, {"sha": "58939b9520e71b6caa2ccc5ca28071e6379d39c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/58939b9520e71b6caa2ccc5ca28071e6379d39c0", "html_url": "https://github.com/rust-lang/rust/commit/58939b9520e71b6caa2ccc5ca28071e6379d39c0"}], "stats": {"total": 717, "additions": 486, "deletions": 231}, "files": [{"sha": "c5b2b6c2d735758dddf390e189091c1e96ba6306", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -140,6 +140,18 @@ infer_lifetime_param_suggestion_elided = each elided lifetime in input position\n \n infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$pref_kind}]\n+    [ref_valid_for] ...the reference is valid for\n+    [content_valid_for] ...but the borrowed content is only valid for\n+    [type_obj_valid_for] object type is valid for\n+    [source_pointer_valid_for] source pointer is only valid for\n+    [type_satisfy] type must satisfy\n+    [type_outlive] type must outlive\n+    [lf_param_instantiated_with] lifetime parameter instantiated with\n+    [lf_param_must_outlive] but lifetime parameter must outlive\n+    [lf_instantiated_with] lifetime instantiated with\n+    [lf_must_outlive] but lifetime must outlive\n+    [pointer_valid_for] the pointer is valid for\n+    [data_valid_for] but the referenced data is only valid for\n     [empty] {\"\"}\n }{$pref_kind ->\n     [empty] {\"\"}\n@@ -148,7 +160,6 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$desc_kind}]\n     [restatic] the static lifetime\n     [revar] lifetime {$desc_arg}\n-\n     [as_defined] the lifetime `{$desc_arg}` as defined here\n     [as_defined_anon] the anonymous lifetime as defined here\n     [defined_here] the anonymous lifetime defined here\n@@ -158,8 +169,16 @@ infer_region_explanation = {$pref_kind ->\n     *[should_not_happen] [{$suff_kind}]\n     [empty]{\"\"}\n     [continues] ...\n+    [req_by_binding] {\" \"}as required by this binding\n }\n \n+infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n+infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n+infer_fullfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_lf_bound_not_satisfied = lifetime bound not satisfied\n+infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n+infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n+\n infer_mismatched_static_lifetime = incompatible lifetime on type\n infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n@@ -308,3 +327,21 @@ infer_ril_introduced_here = `'static` requirement introduced here\n infer_ril_introduced_by = requirement introduced by this return type\n infer_ril_because_of = because of this returned expression\n infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n+\n+infer_where_remove = remove the `where` clause\n+infer_where_copy_predicates = copy the `where` clause predicates from the trait\n+\n+infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n+infer_srs_remove = consider removing this semicolon\n+infer_srs_add = consider returning the local binding `{$ident}`\n+infer_srs_add_one = consider returning one of these bindings\n+\n+infer_await_both_futures = consider `await`ing on both `Future`s\n+infer_await_future = consider `await`ing on the `Future`\n+infer_await_note = calling an async function returns a future\n+\n+infer_prlf_defined_with_sub = the lifetime `{$sub_symbol}` defined here...\n+infer_prlf_defined_without_sub = the lifetime defined here...\n+infer_prlf_must_oultive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n+infer_prlf_must_oultive_without_sup = ...must outlive the lifetime defined here\n+infer_prlf_known_limitation = this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)"}, {"sha": "0c2713fb1a7c80d61620f700017799b5c5ea0b5d", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -933,3 +933,216 @@ pub struct ButNeedsToSatisfy {\n     pub has_lifetime: bool,\n     pub lifetime: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_content, code = \"E0312\")]\n+pub struct OutlivesContent<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_outlives_bound, code = \"E0476\")]\n+pub struct OutlivesBound<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_fullfill_req_lifetime, code = \"E0477\")]\n+pub struct FullfillReqLifetime<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub note: Option<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_lf_bound_not_satisfied, code = \"E0478\")]\n+pub struct LfBoundNotSatisfied<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_ref_longer_than_data, code = \"E0491\")]\n+pub struct RefLongerThanData<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    #[subdiagnostic]\n+    pub notes: Vec<note_and_explain::RegionExplanation<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum WhereClauseSuggestions {\n+    #[suggestion(\n+        infer_where_remove,\n+        code = \"\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        infer_where_copy_predicates,\n+        code = \"{space}where {trait_predicates}\",\n+        applicability = \"machine-applicable\",\n+        style = \"verbose\"\n+    )]\n+    CopyPredicates {\n+        #[primary_span]\n+        span: Span,\n+        space: &'static str,\n+        trait_predicates: String,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestRemoveSemiOrReturnBinding {\n+    #[multipart_suggestion(infer_srs_remove_and_box, applicability = \"machine-applicable\")]\n+    RemoveAndBox {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        first_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        first_hi: Span,\n+        #[suggestion_part(code = \"Box::new(\")]\n+        second_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        second_hi: Span,\n+        #[suggestion_part(code = \"\")]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_remove,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_add,\n+        style = \"verbose\",\n+        code = \"{code}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        sp: Span,\n+        code: String,\n+        ident: Ident,\n+    },\n+    #[note(infer_srs_add_one)]\n+    AddOne {\n+        #[primary_span]\n+        spans: MultiSpan,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ConsiderAddingAwait {\n+    #[help(infer_await_both_futures)]\n+    BothFuturesHelp,\n+    #[multipart_suggestion(infer_await_both_futures, applicability = \"maybe-incorrect\")]\n+    BothFuturesSugg {\n+        #[suggestion_part(code = \".await\")]\n+        first: Span,\n+        #[suggestion_part(code = \".await\")]\n+        second: Span,\n+    },\n+    #[suggestion(\n+        infer_await_future,\n+        code = \".await\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSugg {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(infer_await_note)]\n+    FutureSuggNote {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(\n+        infer_await_future,\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    FutureSuggMultiple {\n+        #[suggestion_part(code = \".await\")]\n+        spans: Vec<Span>,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum PlaceholderRelationLfNotSatisfied {\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasBoth {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_with_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_with_sup)]\n+        sup_span: Span,\n+        sub_symbol: Symbol,\n+        sup_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasSub {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_with_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_without_sup)]\n+        sup_span: Span,\n+        sub_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasSup {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_without_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_with_sup)]\n+        sup_span: Span,\n+        sup_symbol: Symbol,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    HasNone {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_defined_without_sub)]\n+        sub_span: Span,\n+        #[note(infer_prlf_must_oultive_without_sup)]\n+        sup_span: Span,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+    #[diag(infer_lf_bound_not_satisfied)]\n+    OnlyPrimarySpan {\n+        #[primary_span]\n+        span: Span,\n+        #[note(infer_prlf_known_limitation)]\n+        note: (),\n+    },\n+}"}, {"sha": "cb96aeec5f34f4c11d83ad3feb83d74d98e9d920", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -121,16 +121,42 @@ impl<'a> DescriptionCtx<'a> {\n \n pub enum PrefixKind {\n     Empty,\n+    RefValidFor,\n+    ContentValidFor,\n+    TypeObjValidFor,\n+    SourcePointerValidFor,\n+    TypeSatisfy,\n+    TypeOutlive,\n+    LfParamInstantiatedWith,\n+    LfParamMustOutlive,\n+    LfInstantiatedWith,\n+    LfMustOutlive,\n+    PointerValidFor,\n+    DataValidFor,\n }\n \n pub enum SuffixKind {\n+    Empty,\n     Continues,\n+    ReqByBinding,\n }\n \n impl IntoDiagnosticArg for PrefixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n             Self::Empty => \"empty\",\n+            Self::RefValidFor => \"ref_valid_for\",\n+            Self::ContentValidFor => \"content_valid_for\",\n+            Self::TypeObjValidFor => \"type_obj_valid_for\",\n+            Self::SourcePointerValidFor => \"source_pointer_valid_for\",\n+            Self::TypeSatisfy => \"type_satisfy\",\n+            Self::TypeOutlive => \"type_outlive\",\n+            Self::LfParamInstantiatedWith => \"lf_param_instantiated_with\",\n+            Self::LfParamMustOutlive => \"lf_param_must_outlive\",\n+            Self::LfInstantiatedWith => \"lf_instantiated_with\",\n+            Self::LfMustOutlive => \"lf_must_outlive\",\n+            Self::PointerValidFor => \"pointer_valid_for\",\n+            Self::DataValidFor => \"data_valid_for\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -140,7 +166,9 @@ impl IntoDiagnosticArg for PrefixKind {\n impl IntoDiagnosticArg for SuffixKind {\n     fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n         let kind = match self {\n+            Self::Empty => \"empty\",\n             Self::Continues => \"continues\",\n+            Self::ReqByBinding => \"req_by_binding\",\n         }\n         .into();\n         rustc_errors::DiagnosticArgValue::Str(kind)\n@@ -166,17 +194,19 @@ impl RegionExplanation<'_> {\n }\n \n impl AddToDiagnostic for RegionExplanation<'_> {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n     where\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n-        if let Some(span) = self.desc.span {\n-            diag.span_note(span, fluent::infer_region_explanation);\n-        } else {\n-            diag.note(fluent::infer_region_explanation);\n-        }\n-        self.desc.add_to(diag);\n         diag.set_arg(\"pref_kind\", self.prefix);\n         diag.set_arg(\"suff_kind\", self.suffix);\n+        let desc_span = self.desc.span;\n+        self.desc.add_to(diag);\n+        let msg = f(diag, fluent::infer_region_explanation.into());\n+        if let Some(span) = desc_span {\n+            diag.span_note(span, msg);\n+        } else {\n+            diag.note(msg);\n+        }\n     }\n }"}, {"sha": "bb7947e3141ba7bde55a53a9620201737d644671", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -751,15 +751,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n+                    if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                         prior_arm_block_id,\n                         prior_arm_ty,\n                         prior_arm_span,\n                         arm_block_id,\n                         arm_ty,\n                         arm_span,\n-                    );\n+                    ) {\n+                        err.subdiagnostic(subdiag);\n+                    }\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -784,15 +785,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n+                if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                     Some(then_id),\n                     then_ty,\n                     then_span,\n                     Some(else_id),\n                     else_ty,\n                     else_span,\n-                );\n+                ) {\n+                    err.subdiagnostic(subdiag);\n+                }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,"}, {"sha": "e8d94f0c04eaaa69db8eddaa0f8d3fca09f241bc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -1,5 +1,8 @@\n-use crate::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+use crate::{\n+    errors::PlaceholderRelationLfNotSatisfied,\n+    infer::{\n+        error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+    },\n };\n use rustc_data_structures::intern::Interned;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n@@ -16,8 +19,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 Region(Interned(RePlaceholder(ty::Placeholder { name: sub_name, .. }), _)),\n                 Region(Interned(RePlaceholder(ty::Placeholder { name: sup_name, .. }), _)),\n             )) => {\n-                let msg = \"lifetime bound not satisfied\";\n-                let mut err = self.tcx().sess.struct_span_err(*span, msg);\n+                let span = *span;\n                 let (sub_span, sub_symbol) = match sub_name {\n                     ty::BrNamed(def_id, symbol) => {\n                         (Some(self.tcx().def_span(def_id)), Some(symbol))\n@@ -32,41 +34,47 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                     ty::BrAnon(_, span) => (*span, None),\n                     ty::BrEnv => (None, None),\n                 };\n-                match (sub_span, sup_span, sub_symbol, sup_symbol) {\n-                    (Some(sub_span), Some(sup_span), Some(sub_symbol), Some(sup_symbol)) => {\n-                        err.span_note(\n+                let diag = match (sub_span, sup_span, sub_symbol, sup_symbol) {\n+                    (Some(sub_span), Some(sup_span), Some(&sub_symbol), Some(&sup_symbol)) => {\n+                        PlaceholderRelationLfNotSatisfied::HasBoth {\n+                            span,\n                             sub_span,\n-                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n-                        );\n-                        err.span_note(\n                             sup_span,\n-                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n-                        );\n+                            sub_symbol,\n+                            sup_symbol,\n+                            note: (),\n+                        }\n                     }\n-                    (Some(sub_span), Some(sup_span), _, Some(sup_symbol)) => {\n-                        err.span_note(sub_span, \"the lifetime defined here...\");\n-                        err.span_note(\n+                    (Some(sub_span), Some(sup_span), _, Some(&sup_symbol)) => {\n+                        PlaceholderRelationLfNotSatisfied::HasSup {\n+                            span,\n+                            sub_span,\n                             sup_span,\n-                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n-                        );\n+                            sup_symbol,\n+                            note: (),\n+                        }\n                     }\n-                    (Some(sub_span), Some(sup_span), Some(sub_symbol), _) => {\n-                        err.span_note(\n+                    (Some(sub_span), Some(sup_span), Some(&sub_symbol), _) => {\n+                        PlaceholderRelationLfNotSatisfied::HasSub {\n+                            span,\n                             sub_span,\n-                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n-                        );\n-                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n+                            sup_span,\n+                            sub_symbol,\n+                            note: (),\n+                        }\n                     }\n                     (Some(sub_span), Some(sup_span), _, _) => {\n-                        err.span_note(sub_span, \"the lifetime defined here...\");\n-                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n+                        PlaceholderRelationLfNotSatisfied::HasNone {\n+                            span,\n+                            sub_span,\n+                            sup_span,\n+                            note: (),\n+                        }\n                     }\n-                    _ => {}\n-                }\n-                err.note(\"this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\");\n-                Some(err)\n+                    _ => PlaceholderRelationLfNotSatisfied::OnlyPrimarySpan { span, note: () },\n+                };\n+                Some(self.tcx().sess.create_err(diag))\n             }\n-\n             _ => None,\n         }\n     }"}, {"sha": "e0e89158a58386ec0e7eb4dd944dfef060e089c7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 83, "deletions": 111, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -1,9 +1,11 @@\n-use crate::errors::RegionOriginNote;\n+use crate::errors::{\n+    note_and_explain, FullfillReqLifetime, LfBoundNotSatisfied, OutlivesBound, OutlivesContent,\n+    RefLongerThanData, RegionOriginNote, WhereClauseSuggestions,\n+};\n use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n use crate::infer::{self, SubregionOrigin};\n use rustc_errors::{\n-    fluent, struct_span_err, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed,\n+    fluent, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic,\n };\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::traits::ObligationCauseCode;\n@@ -119,130 +121,105 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0312,\n-                    \"lifetime of reference outlives lifetime of borrowed content...\"\n-                );\n-                note_and_explain_region(\n+                let reference_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...the reference is valid for \",\n                     sub,\n-                    \"...\",\n                     None,\n+                    note_and_explain::PrefixKind::RefValidFor,\n+                    note_and_explain::SuffixKind::Continues,\n                 );\n-                note_and_explain_region(\n+                let content_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"...but the borrowed content is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::ContentValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesContent {\n+                    span,\n+                    notes: reference_valid.into_iter().chain(content_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0476,\n-                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n-                     object type\"\n-                );\n-                note_and_explain_region(\n+                let object_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"object type is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::TypeObjValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"source pointer is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::SourcePointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                OutlivesBound {\n+                    span,\n+                    notes: object_valid.into_iter().chain(pointer_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateParamBound(span, ty, opt_span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0477,\n-                    \"the type `{}` does not fulfill the required lifetime\",\n-                    self.ty_to_string(ty)\n+                let prefix = match *sub {\n+                    ty::ReStatic => note_and_explain::PrefixKind::TypeSatisfy,\n+                    _ => note_and_explain::PrefixKind::TypeOutlive,\n+                };\n+                let suffix = if opt_span.is_some() {\n+                    note_and_explain::SuffixKind::ReqByBinding\n+                } else {\n+                    note_and_explain::SuffixKind::Empty\n+                };\n+                let note = note_and_explain::RegionExplanation::new(\n+                    self.tcx, sub, opt_span, prefix, suffix,\n                 );\n-                match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n-                        opt_span,\n-                    ),\n-                }\n-                err\n+                FullfillReqLifetime { span, ty: self.resolve_vars_if_possible(ty), note }\n+                    .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::RelateRegionParamBound(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let param_instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime parameter instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfParamInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let param_must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime parameter must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfParamMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: param_instantiated.into_iter().chain(param_must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0491,\n-                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n+                let pointer_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::PointerValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let data_valid = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but the referenced data is only valid for \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::DataValidFor,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                RefLongerThanData {\n+                    span,\n+                    ty: self.resolve_vars_if_possible(ty),\n+                    notes: pointer_valid.into_iter().chain(data_valid).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n             infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => {\n                 let mut err = self.report_extra_impl_obligation(\n@@ -279,25 +256,25 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n             infer::AscribeUserTypeProvePredicate(span) => {\n-                let mut err =\n-                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n+                let instantiated = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"lifetime instantiated with \",\n                     sup,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfInstantiatedWith,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                note_and_explain_region(\n+                let must_outlive = note_and_explain::RegionExplanation::new(\n                     self.tcx,\n-                    &mut err,\n-                    \"but lifetime must outlive \",\n                     sub,\n-                    \"\",\n                     None,\n+                    note_and_explain::PrefixKind::LfMustOutlive,\n+                    note_and_explain::SuffixKind::Empty,\n                 );\n-                err\n+                LfBoundNotSatisfied {\n+                    span,\n+                    notes: instantiated.into_iter().chain(must_outlive).collect(),\n+                }\n+                .into_diagnostic(&self.tcx.sess.parse_sess.span_diagnostic)\n             }\n         };\n         if sub.is_error() || sup.is_error() {\n@@ -347,22 +324,17 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n         let Some(generics) = self.tcx.hir().get_generics(impl_item_def_id) else { return; };\n \n-        if trait_predicates.is_empty() {\n-            err.span_suggestion_verbose(\n-                generics.where_clause_span,\n-                \"remove the `where` clause\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n+        let suggestion = if trait_predicates.is_empty() {\n+            WhereClauseSuggestions::Remove { span: generics.where_clause_span }\n         } else {\n             let space = if generics.where_clause_span.is_empty() { \" \" } else { \"\" };\n-            err.span_suggestion_verbose(\n-                generics.where_clause_span,\n-                \"copy the `where` clause predicates from the trait\",\n-                format!(\"{space}where {}\", trait_predicates.join(\", \")),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+            WhereClauseSuggestions::CopyPredicates {\n+                span: generics.where_clause_span,\n+                space,\n+                trait_predicates: trait_predicates.join(\", \"),\n+            }\n+        };\n+        err.subdiagnostic(suggestion);\n     }\n \n     pub(super) fn report_placeholder_failure("}, {"sha": "18c5097a26289d5530f9a2600768808e522cfe62", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 70, "deletions": 77, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=1fdf0e1334a61b8c7e3d6e91c83c19bb3a27e28f", "patch": "@@ -11,21 +11,22 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n-use crate::errors::SuggAddLetForLetChains;\n+use crate::errors::{\n+    ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n+};\n \n use super::TypeErrCtxt;\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n-        err: &mut Diagnostic,\n         first_id: Option<hir::HirId>,\n         first_ty: Ty<'tcx>,\n         first_span: Span,\n         second_id: Option<hir::HirId>,\n         second_ty: Ty<'tcx>,\n         second_span: Span,\n-    ) {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let remove_semicolon = [\n             (first_id, self.resolve_vars_if_possible(second_ty)),\n             (second_id, self.resolve_vars_if_possible(first_ty)),\n@@ -37,35 +38,29 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         });\n         match remove_semicolon {\n             Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::RemoveAndBox {\n+                    first_lo: first_span.shrink_to_lo(),\n+                    first_hi: first_span.shrink_to_hi(),\n+                    second_lo: second_span.shrink_to_lo(),\n+                    second_hi: second_span.shrink_to_hi(),\n+                    sp,\n+                })\n             }\n             Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::Remove { sp })\n             }\n             None => {\n+                let mut ret = None;\n                 for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n                     if let Some(id) = id\n                         && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n+                        && let Some(diag) = self.consider_returning_binding_diag(blk, ty)\n                     {\n+                        ret = Some(diag);\n                         break;\n                     }\n                 }\n+                ret\n             }\n         }\n     }\n@@ -198,7 +193,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             return;\n         }\n \n-        match (\n+        let subdiag = match (\n             self.get_impl_future_output_ty(exp_found.expected),\n             self.get_impl_future_output_ty(exp_found.found),\n         ) {\n@@ -207,65 +202,56 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    Some(ConsiderAddingAwait::BothFuturesSugg {\n+                        first: then_span.shrink_to_hi(),\n+                        second: exp_span.shrink_to_hi(),\n+                    })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     prior_arms,\n                     ..\n                 }) => {\n                     if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        Some(ConsiderAddingAwait::BothFuturesSugg {\n+                            first: arm_span.shrink_to_hi(),\n+                            second: exp_span.shrink_to_hi(),\n+                        })\n                     } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n+                        Some(ConsiderAddingAwait::BothFuturesHelp)\n                     }\n                 }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n+                _ => Some(ConsiderAddingAwait::BothFuturesHelp),\n             },\n             (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                self.suggest_await_on_future(diag, exp_span);\n-                diag.span_note(exp_span, \"calling an async function returns a future\");\n+                // FIXME: Seems like we can't have a suggestion and a note with different spans in a single subdiagnostic\n+                diag.subdiagnostic(ConsiderAddingAwait::FutureSugg {\n+                    span: exp_span.shrink_to_hi(),\n+                });\n+                Some(ConsiderAddingAwait::FutureSuggNote { span: exp_span })\n             }\n             (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n             {\n                 ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n                     let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    self.suggest_await_on_future(diag, then_span.shrink_to_hi());\n+                    Some(ConsiderAddingAwait::FutureSugg { span: then_span.shrink_to_hi() })\n                 }\n                 ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                     ref prior_arms,\n                     ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n+                }) => Some({\n+                    ConsiderAddingAwait::FutureSuggMultiple {\n+                        spans: prior_arms.iter().map(|arm| arm.shrink_to_hi()).collect(),\n+                    }\n+                }),\n+                _ => None,\n             },\n-            _ => {}\n+            _ => None,\n+        };\n+        if let Some(subdiag) = subdiag {\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n \n@@ -655,16 +641,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n     /// Suggest returning a local binding with a compatible type if the block\n     /// has no return expression.\n-    pub fn consider_returning_binding(\n+    pub fn consider_returning_binding_diag(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let blk = blk.innermost_block();\n         // Do not suggest if we have a tail expr.\n         if blk.expr.is_some() {\n-            return false;\n+            return None;\n         }\n         let mut shadowed = FxIndexSet::default();\n         let mut candidate_idents = vec![];\n@@ -733,7 +718,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         match &candidate_idents[..] {\n             [(ident, _ty)] => {\n                 let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n+                let (span, sugg) = if let Some(stmt) = blk.stmts.last() {\n                     let stmt_span = sm.stmt_span(stmt.span, blk.span);\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(stmt_span)\n@@ -742,12 +727,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         format!(\" {ident}\")\n                     };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    (stmt_span.shrink_to_hi(), sugg)\n                 } else {\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n@@ -757,21 +737,34 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         format!(\" {ident} \")\n                     };\n                     let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n+                    (\n                         sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n                         sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n+                    )\n+                };\n+                Some(SuggestRemoveSemiOrReturnBinding::Add { sp: span, code: sugg, ident: *ident })\n             }\n             values if (1..3).contains(&values.len()) => {\n                 let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n+                Some(SuggestRemoveSemiOrReturnBinding::AddOne { spans: spans.into() })\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let diag = self.consider_returning_binding_diag(blk, expected_ty);\n+        match diag {\n+            Some(diag) => {\n+                err.subdiagnostic(diag);\n                 true\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n }"}]}