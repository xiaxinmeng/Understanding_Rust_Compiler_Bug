{"sha": "1c07096a45a15de64216f12ec726333870e372b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMDcwOTZhNDVhMTVkZTY0MjE2ZjEyZWM3MjYzMzM4NzBlMzcyYjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2021-06-08T18:23:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2021-08-03T14:06:19Z"}, "message": "rustc: Fill out remaining parts of C-unwind ABI\n\nThis commit intends to fill out some of the remaining pieces of the\nC-unwind ABI. This has a number of other changes with it though to move\nthis design space forward a bit. Notably contained within here is:\n\n* On `panic=unwind`, the `extern \"C\"` ABI is now considered as \"may\n  unwind\". This fixes a longstanding soundness issue where if you\n  `panic!()` in an `extern \"C\"` function defined in Rust that's actually\n  UB because the LLVM representation for the function has the `nounwind`\n  attribute, but then you unwind.\n\n* Whether or not a function unwinds now mainly considers the ABI of the\n  function instead of first checking the panic strategy. This fixes a\n  miscompile of `extern \"C-unwind\"` with `panic=abort` because that ABI\n  can still unwind.\n\n* The aborting stub for non-unwinding ABIs with `panic=unwind` has been\n  reimplemented. Previously this was done as a small tweak during MIR\n  generation, but this has been moved to a separate and dedicated MIR\n  pass. This new pass will, for appropriate functions and function\n  calls, insert a `cleanup` landing pad for any function call that may\n  unwind within a function that is itself not allowed to unwind. Note\n  that this subtly changes some behavior from before where previously on\n  an unwind which was caught-to-abort it would run active destructors in\n  the function, and now it simply immediately aborts the process.\n\n* The `#[unwind]` attribute has been removed and all users in tests and\n  such are now using `C-unwind` and `#![feature(c_unwind)]`.\n\nI think this is largely the last piece of the RFC to implement.\nUnfortunately I believe this is still not stabilizable as-is because\nactivating the feature gate changes the behavior of the existing `extern\n\"C\"` ABI in a way that has no replacement. My thinking for how to enable\nthis is that we add support for the `C-unwind` ABI on stable Rust first,\nand then after it hits stable we change the behavior of the `C` ABI.\nThat way anyone straddling stable/beta/nightly can switch to `C-unwind`\nsafely.", "tree": {"sha": "c92cdabe88b42ced4641416d4eb6b368135d9d4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c92cdabe88b42ced4641416d4eb6b368135d9d4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c07096a45a15de64216f12ec726333870e372b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c07096a45a15de64216f12ec726333870e372b1", "html_url": "https://github.com/rust-lang/rust/commit/1c07096a45a15de64216f12ec726333870e372b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c07096a45a15de64216f12ec726333870e372b1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "html_url": "https://github.com/rust-lang/rust/commit/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c"}], "stats": {"total": 909, "additions": 431, "deletions": 478}, "files": [{"sha": "a50fc698850c688eb53df7c1561c676662f153af", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -87,50 +87,6 @@ pub enum OptimizeAttr {\n     Size,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-pub enum UnwindAttr {\n-    Allowed,\n-    Aborts,\n-}\n-\n-/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n-pub fn find_unwind_attr(sess: &Session, attrs: &[Attribute]) -> Option<UnwindAttr> {\n-    attrs.iter().fold(None, |ia, attr| {\n-        if sess.check_name(attr, sym::unwind) {\n-            if let Some(meta) = attr.meta() {\n-                if let MetaItemKind::List(items) = meta.kind {\n-                    if items.len() == 1 {\n-                        if items[0].has_name(sym::allowed) {\n-                            return Some(UnwindAttr::Allowed);\n-                        } else if items[0].has_name(sym::aborts) {\n-                            return Some(UnwindAttr::Aborts);\n-                        }\n-                    }\n-\n-                    struct_span_err!(\n-                        sess.diagnostic(),\n-                        attr.span,\n-                        E0633,\n-                        \"malformed `unwind` attribute input\"\n-                    )\n-                    .span_label(attr.span, \"invalid argument\")\n-                    .span_suggestions(\n-                        attr.span,\n-                        \"the allowed arguments are `allowed` and `aborts`\",\n-                        (vec![\"allowed\", \"aborts\"])\n-                            .into_iter()\n-                            .map(|s| format!(\"#[unwind({})]\", s)),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-                }\n-            }\n-        }\n-\n-        ia\n-    })\n-}\n-\n /// Represents the following attributes:\n ///\n /// - `#[stable]`"}, {"sha": "5b6c15c82eb637f51843205430d3256ae6034202", "filename": "compiler/rustc_error_codes/src/error_codes/E0633.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0633.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0633.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0633.md?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,8 +1,10 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n The `unwind` attribute was malformed.\n \n Erroneous code example:\n \n-```compile_fail,E0633\n+```compile_fail\n #![feature(unwind_attributes)]\n \n #[unwind()] // error: expected one argument"}, {"sha": "128b51c206162d5fe0fcc5b6fb1be3b25ab564af", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -311,11 +311,6 @@ declare_features! (\n     /// Allows `extern \"platform-intrinsic\" { ... }`.\n     (active, platform_intrinsics, \"1.4.0\", Some(27731), None),\n \n-    /// Allows `#[unwind(..)]`.\n-    ///\n-    /// Permits specifying whether a function should permit unwinding or abort on unwind.\n-    (active, unwind_attributes, \"1.4.0\", Some(58760), None),\n-\n     /// Allows attributes on expressions and non-item statements.\n     (active, stmt_expr_attributes, \"1.6.0\", Some(15701), None),\n "}, {"sha": "49cca3fbc3985211ed7526ec9340342615170dae", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -419,10 +419,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     gated!(panic_runtime, AssumedUsed, template!(Word), experimental!(panic_runtime)),\n     gated!(needs_panic_runtime, AssumedUsed, template!(Word), experimental!(needs_panic_runtime)),\n-    gated!(\n-        unwind, AssumedUsed, template!(List: \"allowed|aborts\"), unwind_attributes,\n-        experimental!(unwind),\n-    ),\n     gated!(\n         compiler_builtins, AssumedUsed, template!(Word),\n         \"the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate \\"}, {"sha": "46b36f2b7040f6f28163dbd6ef81f72c44aaa076", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -156,6 +156,11 @@ declare_features! (\n     (removed, min_type_alias_impl_trait, \"1.56.0\", Some(63063), None,\n      Some(\"removed in favor of full type_alias_impl_trait\")),\n \n+    /// Allows `#[unwind(..)]`.\n+    ///\n+    /// Permits specifying whether a function should permit unwinding or abort on unwind.\n+    (removed, unwind_attributes, \"1.56.0\", Some(58760), None, Some(\"use the C-unwind ABI instead\")),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: removed features\n     // -------------------------------------------------------------------------"}, {"sha": "b2705c7693914919901344d957cb4a92f73eeb15", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -52,13 +52,9 @@ bitflags! {\n         /// `#[rustc_allocator]`: a hint to LLVM that the pointer returned from this\n         /// function is never null.\n         const ALLOCATOR                 = 1 << 1;\n-        /// `#[unwind]`: an indicator that this function may unwind despite what\n-        /// its ABI signature may otherwise imply.\n-        const UNWIND                    = 1 << 2;\n-        /// `#[rust_allocator_nounwind]`, an indicator that an imported FFI\n-        /// function will never unwind. Probably obsolete by recent changes with\n-        /// #[unwind], but hasn't been removed/migrated yet\n-        const RUSTC_ALLOCATOR_NOUNWIND  = 1 << 3;\n+        /// An indicator that function will never unwind. Will become obsolete\n+        /// once C-unwind is fully stabilized.\n+        const NEVER_UNWIND              = 1 << 3;\n         /// `#[naked]`: an indicator to LLVM that no function prologue/epilogue\n         /// should be generated.\n         const NAKED                     = 1 << 4;"}, {"sha": "e78b6fd092de2695b71d6ce9a762275237d55168", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -237,7 +237,7 @@ pub enum TerminatorKind<'tcx> {\n         /// consider it in borrowck. We don't want to accept programs which\n         /// pass borrowck only when `panic=abort` or some assertions are disabled\n         /// due to release vs. debug mode builds. This needs to be an `Option` because\n-        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n+        /// of the `remove_noop_landing_pads` and `abort_unwinding_calls` passes.\n         unwind: Option<BasicBlock>,\n     },\n "}, {"sha": "2e4395cfca8c15e0c246e59c9a231fb118da156c", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 115, "deletions": 66, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -2601,65 +2601,124 @@ where\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n \n+/// Calculates whether a function's ABI can unwind or not.\n+///\n+/// This takes two primary parameters:\n+///\n+/// * `codegen_fn_attr_flags` - these are flags calculated as part of the\n+///   codegen attrs for a defined function. For function pointers this set of\n+///   flags is the empty set. This is only applicable for Rust-defined\n+///   functions, and generally isn't needed except for small optimizations where\n+///   we try to say a function which otherwise might look like it could unwind\n+///   doesn't actually unwind (such as for intrinsics and such).\n+///\n+/// * `abi` - this is the ABI that the function is defined with. This is the\n+///   primary factor for determining whether a function can unwind or not.\n+///\n+/// Note that in this case unwinding is not necessarily panicking in Rust. Rust\n+/// panics are implemented with unwinds on most platform (when\n+/// `-Cpanic=unwind`), but this also accounts for `-Cpanic=abort` build modes.\n+/// Notably unwinding is disallowed for more non-Rust ABIs unless it's\n+/// specifically in the name (e.g. `\"C-unwind\"`). Unwinding within each ABI is\n+/// defined for each ABI individually, but it always corresponds to some form of\n+/// stack-based unwinding (the exact mechanism of which varies\n+/// platform-by-platform).\n+///\n+/// Rust functions are classfied whether or not they can unwind based on the\n+/// active \"panic strategy\". In other words Rust functions are considered to\n+/// unwind in `-Cpanic=unwind` mode and cannot unwind in `-Cpanic=abort` mode.\n+/// Note that Rust supports intermingling panic=abort and panic=unwind code, but\n+/// only if the final panic mode is panic=abort. In this scenario any code\n+/// previously compiled assuming that a function can unwind is still correct, it\n+/// just never happens to actually unwind at runtime.\n+///\n+/// This function's answer to whether or not a function can unwind is quite\n+/// impactful throughout the compiler. This affects things like:\n+///\n+/// * Calling a function which can't unwind means codegen simply ignores any\n+///   associated unwinding cleanup.\n+/// * Calling a function which can unwind from a function which can't unwind\n+///   causes the `abort_unwinding_calls` MIR pass to insert a landing pad that\n+///   aborts the process.\n+/// * This affects whether functions have the LLVM `nounwind` attribute, which\n+///   affects various optimizations and codegen.\n+///\n+/// FIXME: this is actually buggy with respect to Rust functions. Rust functions\n+/// compiled with `-Cpanic=unwind` and referenced from another crate compiled\n+/// with `-Cpanic=abort` will look like they can't unwind when in fact they\n+/// might (from a foreign exception or similar).\n pub fn fn_can_unwind(\n-    panic_strategy: PanicStrategy,\n+    tcx: TyCtxt<'tcx>,\n     codegen_fn_attr_flags: CodegenFnAttrFlags,\n-    call_conv: Conv,\n     abi: SpecAbi,\n ) -> bool {\n-    if panic_strategy != PanicStrategy::Unwind {\n-        // In panic=abort mode we assume nothing can unwind anywhere, so\n-        // optimize based on this!\n-        false\n-    } else if codegen_fn_attr_flags.contains(CodegenFnAttrFlags::UNWIND) {\n-        // If a specific #[unwind] attribute is present, use that.\n-        true\n-    } else if codegen_fn_attr_flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n-        // Special attribute for allocator functions, which can't unwind.\n-        false\n-    } else {\n-        if call_conv == Conv::Rust {\n-            // Any Rust method (or `extern \"Rust\" fn` or `extern\n-            // \"rust-call\" fn`) is explicitly allowed to unwind\n-            // (unless it has no-unwind attribute, handled above).\n-            true\n-        } else {\n-            // Anything else is either:\n-            //\n-            //  1. A foreign item using a non-Rust ABI (like `extern \"C\" { fn foo(); }`), or\n-            //\n-            //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n-            //\n-            // In both of these cases, we should refer to the ABI to determine whether or not we\n-            // should unwind. See Rust RFC 2945 for more information on this behavior, here:\n-            // https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md\n-            use SpecAbi::*;\n-            match abi {\n-                C { unwind } | Stdcall { unwind } | System { unwind } | Thiscall { unwind } => {\n-                    unwind\n-                }\n-                Cdecl\n-                | Fastcall\n-                | Vectorcall\n-                | Aapcs\n-                | Win64\n-                | SysV64\n-                | PtxKernel\n-                | Msp430Interrupt\n-                | X86Interrupt\n-                | AmdGpuKernel\n-                | EfiApi\n-                | AvrInterrupt\n-                | AvrNonBlockingInterrupt\n-                | CCmseNonSecureCall\n-                | Wasm\n-                | RustIntrinsic\n-                | PlatformIntrinsic\n-                | Unadjusted => false,\n-                // In the `if` above, we checked for functions with the Rust calling convention.\n-                Rust | RustCall => unreachable!(),\n-            }\n+    // Special attribute for functions which can't unwind.\n+    if codegen_fn_attr_flags.contains(CodegenFnAttrFlags::NEVER_UNWIND) {\n+        return false;\n+    }\n+\n+    // Otherwise if this isn't special then unwinding is generally determined by\n+    // the ABI of the itself. ABIs like `C` have variants which also\n+    // specifically allow unwinding (`C-unwind`), but not all platform-specific\n+    // ABIs have such an option. Otherwise the only other thing here is Rust\n+    // itself, and those ABIs are determined by the panic strategy configured\n+    // for this compilation.\n+    //\n+    // Unfortunately at this time there's also another caveat. Rust [RFC\n+    // 2945][rfc] has been accepted and is in the process of being implemented\n+    // and stabilized. In this interim state we need to deal with historical\n+    // rustc behavior as well as plan for future rustc behavior.\n+    //\n+    // Historically functions declared with `extern \"C\"` were marked at the\n+    // codegen layer as `nounwind`. This happened regardless of `panic=unwind`\n+    // or not. This is UB for functions in `panic=unwind` mode that then\n+    // actually panic and unwind. Note that this behavior is true for both\n+    // externally declared functions as well as Rust-defined function.\n+    //\n+    // To fix this UB rustc would like to change in the future to catch unwinds\n+    // from function calls that may unwind within a Rust-defined `extern \"C\"`\n+    // function and forcibly abort the process, thereby respecting the\n+    // `nounwind` attribut emitted for `extern \"C\"`. This behavior change isn't\n+    // ready to roll out, so determining whether or not the `C` family of ABIs\n+    // unwinds is conditional not only on their definition but also whether the\n+    // `#![feature(c_unwind)]` feature gate is active.\n+    //\n+    // Note that this means that unlike historical compilers rustc now, by\n+    // default, unconditionally thinks that the `C` ABI may unwind. This will\n+    // prevent some optimization opportunities, however, so we try to scope this\n+    // change and only assume that `C` unwinds with `panic=unwind` (as opposed\n+    // to `panic=abort`).\n+    //\n+    // Eventually the check against `c_unwind` here will ideally get removed and\n+    // this'll be a little cleaner as it'll be a straightforward check of the\n+    // ABI.\n+    //\n+    // [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/2945-c-unwind-abi.md\n+    use SpecAbi::*;\n+    match abi {\n+        C { unwind } | Stdcall { unwind } | System { unwind } | Thiscall { unwind } => {\n+            unwind\n+                || (!tcx.features().c_unwind && tcx.sess.panic_strategy() == PanicStrategy::Unwind)\n         }\n+        Cdecl\n+        | Fastcall\n+        | Vectorcall\n+        | Aapcs\n+        | Win64\n+        | SysV64\n+        | PtxKernel\n+        | Msp430Interrupt\n+        | X86Interrupt\n+        | AmdGpuKernel\n+        | EfiApi\n+        | AvrInterrupt\n+        | AvrNonBlockingInterrupt\n+        | CCmseNonSecureCall\n+        | Wasm\n+        | RustIntrinsic\n+        | PlatformIntrinsic\n+        | Unadjusted => false,\n+        Rust | RustCall => tcx.sess.panic_strategy() == PanicStrategy::Unwind,\n     }\n }\n \n@@ -2695,11 +2754,6 @@ pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n     }\n }\n \n-pub fn fn_ptr_codegen_fn_attr_flags() -> CodegenFnAttrFlags {\n-    // Assume that fn pointers may always unwind\n-    CodegenFnAttrFlags::UNWIND\n-}\n-\n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n@@ -2709,7 +2763,7 @@ where\n         + HasParamEnv<'tcx>,\n {\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnAbi::new_internal(cx, sig, extra_args, None, fn_ptr_codegen_fn_attr_flags(), false)\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, CodegenFnAttrFlags::empty(), false)\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2901,12 +2955,7 @@ where\n             c_variadic: sig.c_variadic,\n             fixed_count: inputs.len(),\n             conv,\n-            can_unwind: fn_can_unwind(\n-                cx.tcx().sess.panic_strategy(),\n-                codegen_fn_attr_flags,\n-                conv,\n-                sig.abi,\n-            ),\n+            can_unwind: fn_can_unwind(cx.tcx(), codegen_fn_attr_flags, sig.abi),\n         };\n         fn_abi.adjust_for_abi(cx, sig.abi);\n         debug!(\"FnAbi::new_internal = {:?}\", fn_abi);"}, {"sha": "5265af7d7db793b482278c670001c512b1503f13", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -18,12 +18,7 @@ use super::{\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn fn_can_unwind(&self, attrs: CodegenFnAttrFlags, abi: Abi) -> bool {\n-        layout::fn_can_unwind(\n-            self.tcx.sess.panic_strategy(),\n-            attrs,\n-            layout::conv_from_spec_abi(*self.tcx, abi),\n-            abi,\n-        )\n+        layout::fn_can_unwind(*self.tcx, attrs, abi)\n     }\n \n     pub(super) fn eval_terminator(\n@@ -77,7 +72,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (\n                             fn_val,\n                             caller_abi,\n-                            self.fn_can_unwind(layout::fn_ptr_codegen_fn_attr_flags(), caller_abi),\n+                            self.fn_can_unwind(CodegenFnAttrFlags::empty(), caller_abi),\n                         )\n                     }\n                     ty::FnDef(def_id, substs) => {"}, {"sha": "82c5e85dcecc08835cbbac27e1e3e8ad88eec6e1", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -16,7 +16,7 @@ use std::fmt;\n use std::iter;\n \n use crate::transform::{\n-    add_call_guards, add_moves_for_packed_drops, no_landing_pads, remove_noop_landing_pads,\n+    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, remove_noop_landing_pads,\n     run_passes, simplify,\n };\n use crate::util::elaborate_drops::{self, DropElaborator, DropFlagMode, DropStyle};\n@@ -81,10 +81,10 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         MirPhase::Const,\n         &[&[\n             &add_moves_for_packed_drops::AddMovesForPackedDrops,\n-            &no_landing_pads::NoLandingPads,\n             &remove_noop_landing_pads::RemoveNoopLandingPads,\n             &simplify::SimplifyCfg::new(\"make_shim\"),\n             &add_call_guards::CriticalCallEdges,\n+            &abort_unwinding_calls::AbortUnwindingCalls,\n         ]],\n     );\n "}, {"sha": "1a84ce45be3232b9fb72e596787842eb23681758", "filename": "compiler/rustc_mir/src/transform/abort_unwinding_calls.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fabort_unwinding_calls.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -0,0 +1,124 @@\n+use crate::transform::MirPass;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::layout;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_target::spec::abi::Abi;\n+\n+/// A pass that runs which is targeted at ensuring that codegen guarantees about\n+/// unwinding are upheld for compilations of panic=abort programs.\n+///\n+/// When compiling with panic=abort codegen backends generally want to assume\n+/// that all Rust-defined functions do not unwind, and it's UB if they actually\n+/// do unwind. Foreign functions, however, can be declared as \"may unwind\" via\n+/// their ABI (e.g. `extern \"C-unwind\"`). To uphold the guarantees that\n+/// Rust-defined functions never unwind a well-behaved Rust program needs to\n+/// catch unwinding from foreign functions and force them to abort.\n+///\n+/// This pass walks over all functions calls which may possibly unwind,\n+/// and if any are found sets their cleanup to a block that aborts the process.\n+/// This forces all unwinds, in panic=abort mode happening in foreign code, to\n+/// trigger a process abort.\n+#[derive(PartialEq)]\n+pub struct AbortUnwindingCalls;\n+\n+impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // This pass only runs on functions which themselves cannot unwind,\n+        // forcibly changing the body of the function to structurally provide\n+        // this guarantee by aborting on an unwind. If this function can unwind,\n+        // then there's nothing to do because it already should work correctly.\n+        //\n+        // Here we test for this function itself whether its ABI allows\n+        // unwinding or not.\n+        let body_flags = tcx.codegen_fn_attrs(body.source.def_id()).flags;\n+        let body_ty = tcx.type_of(body.source.def_id());\n+        let body_abi = match body_ty.kind() {\n+            ty::FnDef(..) => body_ty.fn_sig(tcx).abi(),\n+            ty::Closure(..) => Abi::RustCall,\n+            ty::Generator(..) => Abi::Rust,\n+            _ => span_bug!(body.span, \"unexpected body ty: {:?}\", body_ty),\n+        };\n+        let body_can_unwind = layout::fn_can_unwind(tcx, body_flags, body_abi);\n+\n+        // Look in this function body for any basic blocks which are terminated\n+        // with a function call, and whose function we're calling may unwind.\n+        // This will filter to functions with `extern \"C-unwind\"` ABIs, for\n+        // example.\n+        let mut calls_to_terminate = Vec::new();\n+        let mut cleanups_to_remove = Vec::new();\n+        for (id, block) in body.basic_blocks().iter_enumerated() {\n+            if block.is_cleanup {\n+                continue;\n+            }\n+\n+            let (func, source_info) = match &block.terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { func, .. }, source_info }) => {\n+                    (func, source_info)\n+                }\n+                _ => continue,\n+            };\n+            let ty = func.ty(body, tcx);\n+            let sig = ty.fn_sig(tcx);\n+            let flags = match ty.kind() {\n+                ty::FnPtr(_) => CodegenFnAttrFlags::empty(),\n+                ty::FnDef(def_id, _) => tcx.codegen_fn_attrs(*def_id).flags,\n+                _ => span_bug!(source_info.span, \"invalid callee of type {:?}\", ty),\n+            };\n+\n+            let call_can_unwind = layout::fn_can_unwind(tcx, flags, sig.abi());\n+\n+            // If this function call can't unwind, then there's no need for it\n+            // to have a landing pad. This means that we can remove any cleanup\n+            // registered for it.\n+            if !call_can_unwind {\n+                cleanups_to_remove.push(id);\n+                continue;\n+            }\n+\n+            // Otherwise if this function can unwind, then if the outer function\n+            // can also unwind there's nothing to do. If the outer function\n+            // can't unwind, however, we need to change the landing pad for this\n+            // function call to one that aborts.\n+            if !body_can_unwind {\n+                calls_to_terminate.push(id);\n+            }\n+        }\n+\n+        // For call instructions which need to be terminated, we insert a\n+        // singular basic block which simply terminates, and then configure the\n+        // `cleanup` attribute for all calls we found to this basic block we\n+        // insert which means that any unwinding that happens in the functions\n+        // will force an abort of the process.\n+        if !calls_to_terminate.is_empty() {\n+            let bb = BasicBlockData {\n+                statements: Vec::new(),\n+                is_cleanup: true,\n+                terminator: Some(Terminator {\n+                    source_info: SourceInfo::outermost(body.span),\n+                    kind: TerminatorKind::Abort,\n+                }),\n+            };\n+            let abort_bb = body.basic_blocks_mut().push(bb);\n+\n+            for bb in calls_to_terminate {\n+                let cleanup = match &mut body.basic_blocks_mut()[bb].terminator {\n+                    Some(Terminator { kind: TerminatorKind::Call { cleanup, .. }, .. }) => cleanup,\n+                    _ => unreachable!(),\n+                };\n+                *cleanup = Some(abort_bb);\n+            }\n+        }\n+\n+        for id in cleanups_to_remove {\n+            let cleanup = match &mut body.basic_blocks_mut()[id].terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { cleanup, .. }, .. }) => cleanup,\n+                _ => unreachable!(),\n+            };\n+            *cleanup = None;\n+        }\n+\n+        // We may have invalidated some `cleanup` blocks so clean those up now.\n+        super::simplify::remove_dead_blocks(tcx, body);\n+    }\n+}"}, {"sha": "ce4540b124fc1a7324de5eda00330e8b460d0713", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -53,7 +53,6 @@ use crate::dataflow::impls::{\n     MaybeBorrowedLocals, MaybeLiveLocals, MaybeRequiresStorage, MaybeStorageLive,\n };\n use crate::dataflow::{self, Analysis};\n-use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n use crate::transform::MirPass;\n use crate::util::dump_mir;\n@@ -960,8 +959,6 @@ fn create_generator_drop_shim<'tcx>(\n         )\n     }\n \n-    no_landing_pads(tcx, &mut body);\n-\n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function\n     simplify::remove_dead_blocks(tcx, &mut body);\n@@ -1133,8 +1130,6 @@ fn create_generator_resume_function<'tcx>(\n     make_generator_state_argument_indirect(tcx, body);\n     make_generator_state_argument_pinned(tcx, body);\n \n-    no_landing_pads(tcx, body);\n-\n     // Make sure we remove dead blocks to remove\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(tcx, body);"}, {"sha": "6cc95bab49208eed77ee276dd78f205a730a0903", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n \n+pub mod abort_unwinding_calls;\n pub mod add_call_guards;\n pub mod add_moves_for_packed_drops;\n pub mod add_retag;\n@@ -39,7 +40,6 @@ pub mod lower_intrinsics;\n pub mod lower_slice_len;\n pub mod match_branches;\n pub mod multiple_return_terminators;\n-pub mod no_landing_pads;\n pub mod nrvo;\n pub mod promote_consts;\n pub mod remove_noop_landing_pads;\n@@ -451,15 +451,13 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n \n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n         // Remove all things only needed by analysis\n-        &no_landing_pads::NoLandingPads,\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &cleanup_post_borrowck::CleanupNonCodegenStatements,\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n-        &no_landing_pads::NoLandingPads,\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n@@ -530,6 +528,10 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n     let pre_codegen_cleanup: &[&dyn MirPass<'tcx>] = &[\n+        // This will remove extraneous landing pads which are no longer\n+        // necessary as well as well as forcing any call in a non-unwinding\n+        // function calling a possibly-unwinding function to abort the process.\n+        &abort_unwinding_calls::AbortUnwindingCalls,\n         &add_call_guards::CriticalCallEdges,\n         // Dump the end result for testing and debugging purposes.\n         &dump_mir::Marker(\"PreCodegen\"),"}, {"sha": "5479f0cc5861d3ee8b5cbbd463c2297f7e565658", "filename": "compiler/rustc_mir/src/transform/no_landing_pads.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fno_landing_pads.rs?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,28 +0,0 @@\n-//! This pass removes the unwind branch of all the terminators when the no-landing-pads option is\n-//! specified.\n-\n-use crate::transform::MirPass;\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_target::spec::PanicStrategy;\n-\n-pub struct NoLandingPads;\n-\n-impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        no_landing_pads(tcx, body)\n-    }\n-}\n-\n-pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    if tcx.sess.panic_strategy() != PanicStrategy::Abort {\n-        return;\n-    }\n-\n-    for block in body.basic_blocks_mut() {\n-        let terminator = block.terminator_mut();\n-        if let Some(unwind) = terminator.kind.unwind_mut() {\n-            unwind.take();\n-        }\n-    }\n-}"}, {"sha": "0d623806eb7e1bddc209fe31ca818729bd7d04be", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 59, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -2,7 +2,6 @@ use crate::build;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use crate::thir::pattern::pat_from_hir;\n-use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -19,7 +18,6 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n-use rustc_target::spec::PanicStrategy;\n \n use super::lints;\n \n@@ -581,60 +579,6 @@ macro_rules! unpack {\n     }};\n }\n \n-fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, abi: Abi) -> bool {\n-    // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n-    let attrs = &tcx.get_attrs(fn_def_id.to_def_id());\n-    let unwind_attr = attr::find_unwind_attr(&tcx.sess, attrs);\n-\n-    // We never unwind, so it's not relevant to stop an unwind.\n-    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return false;\n-    }\n-\n-    match unwind_attr {\n-        // If an `#[unwind]` attribute was found, we should adhere to it.\n-        Some(UnwindAttr::Allowed) => false,\n-        Some(UnwindAttr::Aborts) => true,\n-        // If no attribute was found and the panic strategy is `unwind`, then we should examine\n-        // the function's ABI string to determine whether it should abort upon panic.\n-        None if tcx.features().c_unwind => {\n-            use Abi::*;\n-            match abi {\n-                // In the case of ABI's that have an `-unwind` equivalent, check whether the ABI\n-                // permits unwinding. If so, we should not abort. Otherwise, we should.\n-                C { unwind } | Stdcall { unwind } | System { unwind } | Thiscall { unwind } => {\n-                    !unwind\n-                }\n-                // Rust and `rust-call` functions are allowed to unwind, and should not abort.\n-                Rust | RustCall => false,\n-                // Other ABI's should abort.\n-                Cdecl\n-                | Fastcall\n-                | Vectorcall\n-                | Aapcs\n-                | Win64\n-                | SysV64\n-                | PtxKernel\n-                | Msp430Interrupt\n-                | X86Interrupt\n-                | AmdGpuKernel\n-                | EfiApi\n-                | AvrInterrupt\n-                | AvrNonBlockingInterrupt\n-                | CCmseNonSecureCall\n-                | Wasm\n-                | RustIntrinsic\n-                | PlatformIntrinsic\n-                | Unadjusted => true,\n-            }\n-        }\n-        // If the `c_unwind` feature gate is not active, follow the behavior that was in place\n-        // prior to #76570. This is a special case: some functions have a C ABI but are meant to\n-        // unwind anyway. Don't stop them.\n-        None => false, // FIXME(#58794); should be `!(abi == Abi::Rust || abi == Abi::RustCall)`\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n@@ -704,8 +648,7 @@ where\n             }));\n         let source_info = builder.source_info(fn_end);\n         builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-        let should_abort = should_abort_on_panic(tcx, fn_def.did, abi);\n-        builder.build_drop_trees(should_abort);\n+        builder.build_drop_trees();\n         return_block.unit()\n     }));\n \n@@ -752,7 +695,7 @@ fn construct_const<'a, 'tcx>(\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n \n-    builder.build_drop_trees(false);\n+    builder.build_drop_trees();\n \n     builder.finish()\n }"}, {"sha": "496db58758cdcc18b33c964a98a6e93846107a79", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1249,21 +1249,20 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n     }\n \n     /// Build the unwind and generator drop trees.\n-    crate fn build_drop_trees(&mut self, should_abort: bool) {\n+    crate fn build_drop_trees(&mut self) {\n         if self.generator_kind.is_some() {\n-            self.build_generator_drop_trees(should_abort);\n+            self.build_generator_drop_trees();\n         } else {\n             Self::build_unwind_tree(\n                 &mut self.cfg,\n                 &mut self.scopes.unwind_drops,\n                 self.fn_span,\n-                should_abort,\n                 &mut None,\n             );\n         }\n     }\n \n-    fn build_generator_drop_trees(&mut self, should_abort: bool) {\n+    fn build_generator_drop_trees(&mut self) {\n         // Build the drop tree for dropping the generator while it's suspended.\n         let drops = &mut self.scopes.generator_drops;\n         let cfg = &mut self.cfg;\n@@ -1281,7 +1280,7 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n         // Build the drop tree for unwinding in the normal control flow paths.\n         let resume_block = &mut None;\n         let unwind_drops = &mut self.scopes.unwind_drops;\n-        Self::build_unwind_tree(cfg, unwind_drops, fn_span, should_abort, resume_block);\n+        Self::build_unwind_tree(cfg, unwind_drops, fn_span, resume_block);\n \n         // Build the drop tree for unwinding when dropping a suspended\n         // generator.\n@@ -1296,26 +1295,20 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n                 drops.entry_points.push((drop_data.1, blocks[drop_idx].unwrap()));\n             }\n         }\n-        Self::build_unwind_tree(cfg, drops, fn_span, should_abort, resume_block);\n+        Self::build_unwind_tree(cfg, drops, fn_span, resume_block);\n     }\n \n     fn build_unwind_tree(\n         cfg: &mut CFG<'tcx>,\n         drops: &mut DropTree,\n         fn_span: Span,\n-        should_abort: bool,\n         resume_block: &mut Option<BasicBlock>,\n     ) {\n         let mut blocks = IndexVec::from_elem(None, &drops.drops);\n         blocks[ROOT_NODE] = *resume_block;\n         drops.build_mir::<Unwind>(cfg, &mut blocks);\n         if let (None, Some(resume)) = (*resume_block, blocks[ROOT_NODE]) {\n-            // `TerminatorKind::Abort` is used for `#[unwind(aborts)]`\n-            // functions.\n-            let terminator =\n-                if should_abort { TerminatorKind::Abort } else { TerminatorKind::Resume };\n-\n-            cfg.terminate(resume, SourceInfo::outermost(fn_span), terminator);\n+            cfg.terminate(resume, SourceInfo::outermost(fn_span), TerminatorKind::Resume);\n \n             *resume_block = blocks[ROOT_NODE];\n         }"}, {"sha": "06cb33b9ebf4b3d7079a5a49e949b43710c7a3ee", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -2776,8 +2776,6 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n         } else if tcx.sess.check_name(attr, sym::rustc_allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if tcx.sess.check_name(attr, sym::unwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n         } else if tcx.sess.check_name(attr, sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n@@ -2829,7 +2827,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 .emit();\n             }\n         } else if tcx.sess.check_name(attr, sym::rustc_allocator_nounwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n         } else if tcx.sess.check_name(attr, sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n         } else if tcx.sess.check_name(attr, sym::no_mangle) {\n@@ -3200,6 +3198,15 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n     }\n \n+    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n+    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n+    // intrinsic functions.\n+    if let Some(name) = &codegen_fn_attrs.link_name {\n+        if name.as_str().starts_with(\"llvm.\") {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        }\n+    }\n+\n     codegen_fn_attrs\n }\n "}, {"sha": "1ab7227933bbb164ed8c3605a75b3675fc1300c1", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -147,7 +147,6 @@\n #![feature(try_blocks)]\n #![feature(unboxed_closures)]\n #![feature(unsized_fn_params)]\n-#![feature(unwind_attributes)]\n #![feature(variant_count)]\n #![feature(tbm_target_feature)]\n #![feature(sse4a_target_feature)]"}, {"sha": "14b454da4f46f58675e6069509107218cf9fad79", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -20,11 +20,11 @@\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n-#![feature(unwind_attributes)]\n #![feature(abi_thiscall)]\n #![feature(rustc_attrs)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n+#![feature(c_unwind)]\n // `real_imp` is unused with Miri, so silence warnings.\n #![cfg_attr(miri, allow(dead_code))]\n \n@@ -98,8 +98,7 @@ pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[rustc_std_internal_symbol]\n-#[unwind(allowed)]\n-pub unsafe extern \"C\" fn __rust_start_panic(payload: *mut &mut dyn BoxMeUp) -> u32 {\n+pub unsafe extern \"C-unwind\" fn __rust_start_panic(payload: *mut &mut dyn BoxMeUp) -> u32 {\n     let payload = Box::from_raw((*payload).take_box());\n \n     imp::panic(payload)"}, {"sha": "9f1eb411ff66032519bcd865c05996943f299b4c", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -233,15 +233,14 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n // support capturing exceptions with std::exception_ptr, which we can't support\n // because Box<dyn Any> isn't clonable.\n macro_rules! define_cleanup {\n-    ($abi:tt) => {\n+    ($abi:tt $abi2:tt) => {\n         unsafe extern $abi fn exception_cleanup(e: *mut Exception) {\n             if let Exception { data: Some(b) } = e.read() {\n                 drop(b);\n                 super::__rust_drop_panic();\n             }\n         }\n-        #[unwind(allowed)]\n-        unsafe extern $abi fn exception_copy(_dest: *mut Exception,\n+        unsafe extern $abi2 fn exception_copy(_dest: *mut Exception,\n                                              _src: *mut Exception)\n                                              -> *mut Exception {\n             panic!(\"Rust panics cannot be copied\");\n@@ -250,9 +249,9 @@ macro_rules! define_cleanup {\n }\n cfg_if::cfg_if! {\n    if #[cfg(target_arch = \"x86\")] {\n-       define_cleanup!(\"thiscall\");\n+       define_cleanup!(\"thiscall\" \"thiscall-unwind\");\n    } else {\n-       define_cleanup!(\"C\");\n+       define_cleanup!(\"C\" \"C-unwind\");\n    }\n }\n \n@@ -307,8 +306,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n         ptr!(exception_copy) as u32,\n     );\n \n-    extern \"system\" {\n-        #[unwind(allowed)]\n+    extern \"system-unwind\" {\n         fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8) -> !;\n     }\n "}, {"sha": "9dd99e44e809b57782671c3ef96b0637d78a0471", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -235,6 +235,7 @@\n #![feature(auto_traits)]\n #![feature(bench_black_box)]\n #![feature(box_syntax)]\n+#![feature(c_unwind)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]\n #![feature(cfg_eval)]\n@@ -327,7 +328,6 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_cell_raw_get)]\n-#![feature(unwind_attributes)]\n #![feature(unwrap_infallible)]\n #![feature(vec_into_raw_parts)]\n #![feature(vec_spare_capacity)]"}, {"sha": "7de70091becf4f1188437962cdae2e40cd375907", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -43,11 +43,13 @@ use realstd::io::set_output_capture;\n #[allow(improper_ctypes)]\n extern \"C\" {\n     fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static);\n+}\n \n+#[allow(improper_ctypes)]\n+extern \"C-unwind\" {\n     /// `payload` is passed through another layer of raw pointers as `&mut dyn Trait` is not\n     /// FFI-safe. `BoxMeUp` lazily performs allocation only when needed (this avoids allocations\n     /// when using the \"abort\" panic runtime).\n-    #[unwind(allowed)]\n     fn __rust_start_panic(payload: *mut &mut dyn BoxMeUp) -> u32;\n }\n \n@@ -460,7 +462,6 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n \n /// Entry point of panics from the libcore crate (`panic_impl` lang item).\n #[cfg_attr(not(test), panic_handler)]\n-#[unwind(allowed)]\n pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     struct PanicPayload<'a> {\n         inner: &'a fmt::Arguments<'a>,"}, {"sha": "9e52802450682137789e05161593441cad620451", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -3,8 +3,8 @@\n #![feature(link_cfg)]\n #![feature(nll)]\n #![feature(staged_api)]\n-#![feature(unwind_attributes)]\n #![feature(static_nobundle)]\n+#![feature(c_unwind)]\n #![cfg_attr(not(target_env = \"msvc\"), feature(libc))]\n \n cfg_if::cfg_if! {"}, {"sha": "196be74decba4e4fb9c454f3fdf7a50ede26585e", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -81,9 +81,10 @@ pub type _Unwind_Exception_Cleanup_Fn =\n     all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n     link(name = \"unwind\", kind = \"static\")\n )]\n-extern \"C\" {\n-    #[unwind(allowed)]\n+extern \"C-unwind\" {\n     pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n+}\n+extern \"C\" {\n     pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n     pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> *mut c_void;\n     pub fn _Unwind_GetRegionStart(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n@@ -230,9 +231,10 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     #[cfg_attr(all(feature = \"llvm-libunwind\",\n                    any(target_os = \"fuchsia\", target_os = \"linux\")),\n                link(name = \"unwind\", kind = \"static\"))]\n-    extern \"C\" {\n-        #[unwind(allowed)]\n+    extern \"C-unwind\" {\n         pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n+    }\n+    extern \"C\" {\n         pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                  trace_argument: *mut c_void)\n                                  -> _Unwind_Reason_Code;\n@@ -242,8 +244,7 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     #[cfg_attr(all(feature = \"llvm-libunwind\",\n                    any(target_os = \"fuchsia\", target_os = \"linux\")),\n                link(name = \"unwind\", kind = \"static\"))]\n-    extern \"C\" {\n-        #[unwind(allowed)]\n+    extern \"C-unwind\" {\n         pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n     }\n "}, {"sha": "668d023af96a5512e758227d048a0ce426d4e878", "filename": "src/test/codegen/c-variadic.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -4,7 +4,7 @@\n \n #![crate_type = \"lib\"]\n #![feature(c_variadic)]\n-#![feature(unwind_attributes)]\n+#![feature(c_unwind)]\n #![no_std]\n use core::ffi::VaList;\n \n@@ -13,7 +13,6 @@ extern \"C\" {\n     fn foreign_c_variadic_1(_: VaList, ...);\n }\n \n-#[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n     // Ensure that we correctly call foreign C-variadic functions.\n     // CHECK: call void (i32, ...) @foreign_c_variadic_0([[PARAM:i32( signext)?]] 0)\n@@ -28,24 +27,20 @@ pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n \n // Ensure that we do not remove the `va_list` passed to the foreign function when\n // removing the \"spoofed\" `VaListImpl` that is used by Rust defined C-variadics.\n-#[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_0(ap: VaList) {\n     // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n     foreign_c_variadic_1(ap);\n }\n \n-#[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_1(ap: VaList) {\n     // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 42)\n     foreign_c_variadic_1(ap, 42i32);\n }\n-#[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_2(ap: VaList) {\n     // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42)\n     foreign_c_variadic_1(ap, 2i32, 42i32);\n }\n \n-#[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_3(ap: VaList) {\n     // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42, [[PARAM]] 0)\n     foreign_c_variadic_1(ap, 2i32, 42i32, 0i32);"}, {"sha": "b89c590add0d788cde7517b53375f59f0318620b", "filename": "src/test/codegen/catch-unwind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -10,6 +10,7 @@\n // ignore-riscv64 FIXME\n \n #![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n \n extern \"C\" {\n     fn bar();"}, {"sha": "166d2bb99426d44ce0940c89c43051ffddeb1d87", "filename": "src/test/codegen/try-panic-abort.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftry-panic-abort.rs?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,20 +0,0 @@\n-// compile-flags: -C panic=abort -O\n-\n-#![crate_type = \"lib\"]\n-#![feature(unwind_attributes, core_intrinsics)]\n-\n-extern \"C\" {\n-    #[unwind(allow)]\n-    fn bar(data: *mut u8);\n-}\n-extern \"Rust\" {\n-    fn catch(data: *mut u8, exception: *mut u8);\n-}\n-\n-// CHECK-LABEL: @foo\n-#[no_mangle]\n-pub unsafe fn foo() -> i32 {\n-    // CHECK: call void @bar\n-    // CHECK: ret i32 0\n-    std::intrinsics::r#try(|x| bar(x), 0 as *mut u8, |x, y| catch(x, y))\n-}"}, {"sha": "398937a04c9236bfade8d7defb02ae9858665700", "filename": "src/test/codegen/unwind-abis/c-unwind-abi-panic-abort.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fc-unwind-abi-panic-abort.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,18 +1,22 @@\n-// compile-flags: -C panic=abort -C opt-level=0\n+// compile-flags: -C panic=abort\n \n-// Test that `nounwind` atributes are applied to `C-unwind` extern functions when the\n-// code is compiled with `panic=abort`.  We disable optimizations above to prevent LLVM from\n-// inferring the attribute.\n+// Test that `nounwind` atributes are not applied to `C-unwind` extern functions\n+// even when the code is compiled with `panic=abort`.\n \n #![crate_type = \"lib\"]\n #![feature(c_unwind)]\n \n-// CHECK: @rust_item_that_can_unwind() unnamed_addr #0 {\n+extern \"C-unwind\" {\n+    fn may_unwind();\n+}\n+\n+// CHECK: @rust_item_that_can_unwind() unnamed_addr #0\n #[no_mangle]\n-pub extern \"C-unwind\" fn rust_item_that_can_unwind() {\n+pub unsafe extern \"C-unwind\" fn rust_item_that_can_unwind() {\n+    may_unwind();\n }\n \n // Now, make sure that the LLVM attributes for this functions are correct.  First, make\n // sure that the first item is correctly marked with the `nounwind` attribute:\n //\n-// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }\n+// CHECK-NOT: attributes #0 = { {{.*}}nounwind{{.*}} }"}, {"sha": "9a4b3d3b4848080f8c07696429bba0b669d1f229", "filename": "src/test/codegen/unwind-abis/nounwind-on-stable-panic-abort.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind-on-stable-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind-on-stable-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind-on-stable-panic-abort.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -C opt-level=0 -Cpanic=abort\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![crate_type = \"lib\"]\n+\n+// We disable optimizations to prevent LLVM from infering the attribute.\n+\n+// CHECK: Function Attrs:{{.*}}nounwind\n+// CHECK-NEXT: @foo\n+#[no_mangle]\n+pub extern \"C\" fn foo() {}\n+\n+// CHECK: Function Attrs:{{.*}}nounwind\n+// CHECK-NEXT: @bar\n+#[no_mangle]\n+pub fn bar() {}"}, {"sha": "2783c83d3efe08e6c94827e33dfe89e45cc28999", "filename": "src/test/codegen/unwind-abis/nounwind-on-stable-panic-unwind.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind-on-stable-panic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind-on-stable-panic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind-on-stable-panic-unwind.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -C opt-level=0\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![crate_type = \"lib\"]\n+\n+// We disable optimizations to prevent LLVM from infering the attribute.\n+\n+extern \"C\" {\n+    fn bar();\n+}\n+\n+// CHECK-NOT: Function Attrs:{{.*}}nounwind\n+pub unsafe extern \"C\" fn foo() {\n+    bar();\n+}\n+\n+// Note that this test will get removed when `C-unwind` is fully stabilized"}, {"sha": "cfc140361f62363bb03c27eba653bc554dd3916a", "filename": "src/test/codegen/unwind-abis/nounwind.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-abis%2Fnounwind.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -C opt-level=0 -Cpanic=abort\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n+\n+// We disable optimizations to prevent LLVM from infering the attribute.\n+\n+// CHECK: Function Attrs:{{.*}}nounwind\n+// CHECK-NEXT: @foo\n+#[no_mangle]\n+pub extern \"C\" fn foo() {}\n+\n+// CHECK: Function Attrs:{{.*}}nounwind\n+// CHECK-NEXT: @bar\n+#[no_mangle]\n+pub fn bar() {}"}, {"sha": "05d97f3256aca28981b7ee04336d228089349565", "filename": "src/test/codegen/unwind-and-panic-abort.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-and-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-and-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-and-panic-abort.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -C panic=abort\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_unwind)]\n+\n+extern \"C-unwind\" {\n+    fn bar();\n+}\n+\n+// CHECK: Function Attrs:{{.*}}nounwind\n+// CHECK-NEXT: define{{.*}}void @foo\n+// CHECK: call void @llvm.trap()\n+#[no_mangle]\n+pub unsafe extern \"C\" fn foo() {\n+    bar();\n+}"}, {"sha": "c939235fb5006c121d4afa0c5402b0e2a21a58d9", "filename": "src/test/codegen/unwind-extern-exports.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-extern-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-extern-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-extern-exports.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -2,19 +2,15 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![crate_type = \"lib\"]\n-#![feature(unwind_attributes)]\n+#![feature(c_unwind)]\n \n // Make sure these all do *not* get the attribute.\n // We disable optimizations to prevent LLVM from infering the attribute.\n // CHECK-NOT: nounwind\n \n // \"C\" ABI\n-// pub extern fn foo() {} // FIXME right now we don't abort-on-panic but add `nounwind` nevertheless\n-#[unwind(allowed)]\n-pub extern \"C\" fn foo_allowed() {}\n+pub extern \"C-unwind\" fn foo_unwind() {}\n \n // \"Rust\"\n // (`extern \"Rust\"` could be removed as all `fn` get it implicitly; we leave it in for clarity.)\n-pub extern \"Rust\" fn bar() {}\n-#[unwind(allowed)]\n-pub extern \"Rust\" fn bar_allowed() {}\n+pub fn bar() {}"}, {"sha": "e33e3e80521c1935c0c837038122c8e4b641aaa2", "filename": "src/test/codegen/unwind-extern-imports.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-extern-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fcodegen%2Funwind-extern-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-extern-imports.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -2,41 +2,21 @@\n // ignore-wasm32-bare compiled with panic=abort by default\n \n #![crate_type = \"lib\"]\n-#![feature(unwind_attributes)]\n+#![feature(c_unwind)]\n \n extern \"C\" {\n-// CHECK: Function Attrs:{{.*}}nounwind\n-// CHECK-NEXT: declare{{.*}}void @extern_fn\n+    // CHECK: Function Attrs:{{.*}}nounwind\n+    // CHECK-NEXT: declare{{.*}}void @extern_fn\n     fn extern_fn();\n-// CHECK-NOT: Function Attrs:{{.*}}nounwind\n-// CHECK: declare{{.*}}void @unwinding_extern_fn\n-    #[unwind(allowed)]\n-    fn unwinding_extern_fn();\n-// CHECK-NOT: nounwind\n-// CHECK: declare{{.*}}void @aborting_extern_fn\n-    #[unwind(aborts)]\n-    fn aborting_extern_fn(); // FIXME: we want to have the attribute here\n }\n \n-extern \"Rust\" {\n-// CHECK-NOT: nounwind\n-// CHECK: declare{{.*}}void @rust_extern_fn\n-    fn rust_extern_fn();\n-// CHECK-NOT: nounwind\n-// CHECK: declare{{.*}}void @rust_unwinding_extern_fn\n-    #[unwind(allowed)]\n-    fn rust_unwinding_extern_fn();\n-// CHECK-NOT: nounwind\n-// CHECK: declare{{.*}}void @rust_aborting_extern_fn\n-    #[unwind(aborts)]\n-    fn rust_aborting_extern_fn(); // FIXME: we want to have the attribute here\n+extern \"C-unwind\" {\n+    // CHECK-NOT: nounwind\n+    // CHECK: declare{{.*}}void @c_unwind_extern_fn\n+    fn c_unwind_extern_fn();\n }\n \n pub unsafe fn force_declare() {\n     extern_fn();\n-    unwinding_extern_fn();\n-    aborting_extern_fn();\n-    rust_extern_fn();\n-    rust_unwinding_extern_fn();\n-    rust_aborting_extern_fn();\n+    c_unwind_extern_fn();\n }"}, {"sha": "3d78752eeb9deb02dcfb60ba46f845f1a006d6a4", "filename": "src/test/run-make-fulldeps/coverage/abort.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fabort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fabort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fabort.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,8 +1,7 @@\n-#![feature(unwind_attributes)]\n+#![feature(c_unwind)]\n #![allow(unused_assignments)]\n \n-#[unwind(aborts)]\n-fn might_abort(should_abort: bool) {\n+extern \"C\" fn might_abort(should_abort: bool) {\n     if should_abort {\n         println!(\"aborting...\");\n         panic!(\"panics and aborts\");\n@@ -18,11 +17,16 @@ fn main() -> Result<(), u8> {\n             might_abort(false);\n         }\n         // See discussion (below the `Notes` section) on coverage results for the closing brace.\n-        if countdown < 5 { might_abort(false); } // Counts for different regions on one line.\n+        if countdown < 5 {\n+            might_abort(false);\n+        }\n+        // Counts for different regions on one line.\n         // For the following example, the closing brace is the last character on the line.\n         // This shows the character after the closing brace is highlighted, even if that next\n         // character is a newline.\n-        if countdown < 5 { might_abort(false); }\n+        if countdown < 5 {\n+            might_abort(false);\n+        }\n         countdown -= 1;\n     }\n     Ok(())"}, {"sha": "c279cf7e8bf10bcb77e5b150b909f00563a0149f", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -4,7 +4,7 @@\n \n // For linking libstdc++ on MinGW\n #![cfg_attr(all(windows, target_env = \"gnu\"), feature(static_nobundle))]\n-#![feature(unwind_attributes)]\n+#![feature(c_unwind)]\n \n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n@@ -18,22 +18,21 @@ impl<'a> Drop for DropCheck<'a> {\n \n extern \"C\" {\n     fn test_cxx_exception();\n+}\n \n-    #[unwind(allowed)]\n-    fn cxx_catch_callback(cb: extern \"C\" fn(), ok: *mut bool);\n+extern \"C-unwind\" {\n+    fn cxx_catch_callback(cb: extern \"C-unwind\" fn(), ok: *mut bool);\n }\n \n #[no_mangle]\n-#[unwind(allowed)]\n-extern \"C\" fn rust_catch_callback(cb: extern \"C\" fn(), rust_ok: &mut bool) {\n+extern \"C-unwind\" fn rust_catch_callback(cb: extern \"C-unwind\" fn(), rust_ok: &mut bool) {\n     let _drop = DropCheck(rust_ok);\n     cb();\n     unreachable!(\"should have unwound instead of returned\");\n }\n \n fn test_rust_panic() {\n-    #[unwind(allowed)]\n-    extern \"C\" fn callback() {\n+    extern \"C-unwind\" fn callback() {\n         println!(\"throwing rust panic\");\n         panic!(1234i32);\n     }"}, {"sha": "89b5135fd37e386ab609e711f7619a340522e38e", "filename": "src/test/ui/consts/const-eval/unwind-abort.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,12 +1,11 @@\n-#![feature(unwind_attributes, const_panic)]\n+#![feature(c_unwind, const_panic, const_extern_fn)]\n \n-#[unwind(aborts)]\n-const fn foo() {\n+const extern \"C\" fn foo() {\n     panic!() //~ ERROR evaluation of constant value failed\n }\n \n const _: () = foo();\n-// Ensure that the CTFE engine handles calls to `#[unwind(aborts)]` gracefully\n+// Ensure that the CTFE engine handles calls to `extern \"C\"` aborting gracefully\n \n fn main() {\n     let _ = foo();"}, {"sha": "78ebd36abd86b14dcf8c28df78029d6aa2c50fab", "filename": "src/test/ui/consts/const-eval/unwind-abort.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.stderr?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,14 +1,14 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/unwind-abort.rs:5:5\n+  --> $DIR/unwind-abort.rs:4:5\n    |\n LL |     panic!()\n    |     ^^^^^^^^\n    |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/unwind-abort.rs:5:5\n+   |     the evaluated program panicked at 'explicit panic', $DIR/unwind-abort.rs:4:5\n    |     inside `foo` at $SRC_DIR/std/src/panic.rs:LL:COL\n ...\n LL | const _: () = foo();\n-   |               ----- inside `_` at $DIR/unwind-abort.rs:8:15\n+   |               ----- inside `_` at $DIR/unwind-abort.rs:7:15\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "d9d0b91011d9a9e5c757b2a7d7b4614ff0e04ed2", "filename": "src/test/ui/consts/unwind-abort.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fconsts%2Funwind-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fconsts%2Funwind-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funwind-abort.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,10 +1,9 @@\n // check-pass\n \n-#![feature(unwind_attributes, const_panic)]\n+#![feature(c_unwind, const_panic, const_extern_fn)]\n \n-// `#[unwind(aborts)]` is okay for a `const fn`. We don't unwind in const-eval anyways.\n-#[unwind(aborts)]\n-const fn foo() {\n+// We don't unwind in const-eval anyways.\n+const extern \"C\" fn foo() {\n     panic!()\n }\n "}, {"sha": "cd348ded4d7ce29ee3df89bfa69818bf46f988e1", "filename": "src/test/ui/feature-gates/feature-gate-unwind-attributes.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,19 +0,0 @@\n-// ignore-wasm32-bare compiled with panic=abort by default\n-// compile-flags: -C no-prepopulate-passes -Cpasses=name-anon-globals\n-\n-#![crate_type = \"lib\"]\n-\n-extern \"C\" {\n-    // CHECK: Function Attrs: nounwind\n-    // CHECK-NEXT: declare void @extern_fn\n-    fn extern_fn();\n-    // CHECK-NOT: Function Attrs: nounwind\n-    // CHECK: declare void @unwinding_extern_fn\n-    #[unwind(allowed)] //~ ERROR the `#[unwind]` attribute is an experimental feature\n-    fn unwinding_extern_fn();\n-}\n-\n-pub unsafe fn force_declare() {\n-    extern_fn();\n-    unwinding_extern_fn();\n-}"}, {"sha": "8e7895555c7a3ba9b8808eb98b29b54881cf78fc", "filename": "src/test/ui/feature-gates/feature-gate-unwind-attributes.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: the `#[unwind]` attribute is an experimental feature\n-  --> $DIR/feature-gate-unwind-attributes.rs:12:5\n-   |\n-LL |     #[unwind(allowed)]\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #58760 <https://github.com/rust-lang/rust/issues/58760> for more information\n-   = help: add `#![feature(unwind_attributes)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "009695b177f965d1fa0ecf88272d5073814ab906", "filename": "src/test/ui/malformed/malformed-unwind-1.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.rs?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,9 +0,0 @@\n-#![feature(unwind_attributes)]\n-\n-#[unwind] //~ ERROR malformed `unwind` attribute\n-extern \"C\" fn f1() {}\n-\n-#[unwind = \"\"] //~ ERROR malformed `unwind` attribute\n-extern \"C\" fn f2() {}\n-\n-fn main() {}"}, {"sha": "0a553e8a245f6e51d5e83f1b3f4ad34ec8ac1946", "filename": "src/test/ui/malformed/malformed-unwind-1.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-1.stderr?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,14 +0,0 @@\n-error: malformed `unwind` attribute input\n-  --> $DIR/malformed-unwind-1.rs:3:1\n-   |\n-LL | #[unwind]\n-   | ^^^^^^^^^ help: must be of the form: `#[unwind(allowed|aborts)]`\n-\n-error: malformed `unwind` attribute input\n-  --> $DIR/malformed-unwind-1.rs:6:1\n-   |\n-LL | #[unwind = \"\"]\n-   | ^^^^^^^^^^^^^^ help: must be of the form: `#[unwind(allowed|aborts)]`\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "9aafc7ca9b851db1e567e7077edd5d71b1b206fe", "filename": "src/test/ui/malformed/malformed-unwind-2.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.rs?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,11 +0,0 @@\n-#![feature(unwind_attributes)]\n-\n-#[unwind(allowed, aborts)]\n-//~^ ERROR malformed `unwind` attribute\n-extern \"C\" fn f1() {}\n-\n-#[unwind(unsupported)]\n-//~^ ERROR malformed `unwind` attribute\n-extern \"C\" fn f2() {}\n-\n-fn main() {}"}, {"sha": "28512bf9ef10fed05cd012e5bd10fca1626e6581", "filename": "src/test/ui/malformed/malformed-unwind-2.stderr", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2939249f294dd54a9ce78a8ee1f2922a44e7fb7c/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-unwind-2.stderr?ref=2939249f294dd54a9ce78a8ee1f2922a44e7fb7c", "patch": "@@ -1,29 +0,0 @@\n-error[E0633]: malformed `unwind` attribute input\n-  --> $DIR/malformed-unwind-2.rs:3:1\n-   |\n-LL | #[unwind(allowed, aborts)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid argument\n-   |\n-help: the allowed arguments are `allowed` and `aborts`\n-   |\n-LL | #[unwind(allowed)]\n-   |\n-LL | #[unwind(aborts)]\n-   |\n-\n-error[E0633]: malformed `unwind` attribute input\n-  --> $DIR/malformed-unwind-2.rs:7:1\n-   |\n-LL | #[unwind(unsupported)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^ invalid argument\n-   |\n-help: the allowed arguments are `allowed` and `aborts`\n-   |\n-LL | #[unwind(allowed)]\n-   |\n-LL | #[unwind(aborts)]\n-   |\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0633`."}, {"sha": "1f6ad64c071f514d0aaf78b47d3216bba5327d1d", "filename": "src/test/ui/panics/abort-on-panic.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c07096a45a15de64216f12ec726333870e372b1/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs?ref=1c07096a45a15de64216f12ec726333870e372b1", "patch": "@@ -1,31 +1,25 @@\n // run-pass\n \n #![allow(unused_must_use)]\n-#![feature(unwind_attributes)]\n+#![feature(c_unwind)]\n #![feature(panic_always_abort)]\n // Since we mark some ABIs as \"nounwind\" to LLVM, we must make sure that\n // we never unwind through them.\n \n // ignore-emscripten no processes\n // ignore-sgx no processes\n \n-use std::{env, panic};\n-use std::io::prelude::*;\n use std::io;\n+use std::io::prelude::*;\n use std::process::{exit, Command, Stdio};\n use std::sync::{Arc, Barrier};\n use std::thread;\n+use std::{env, panic};\n \n-#[unwind(aborts)] // FIXME(#58794) should work even without the attribute\n extern \"C\" fn panic_in_ffi() {\n     panic!(\"Test\");\n }\n \n-#[unwind(aborts)]\n-extern \"Rust\" fn panic_in_rust_abi() {\n-    panic!(\"TestRust\");\n-}\n-\n fn should_have_aborted() {\n     io::stdout().write(b\"This should never be printed.\\n\");\n     let _ = io::stdout().flush();\n@@ -37,26 +31,25 @@ fn bomb_out_but_not_abort(msg: &str) {\n }\n \n fn test() {\n-    let _ = panic::catch_unwind(|| { panic_in_ffi(); });\n-    should_have_aborted();\n-}\n-\n-fn testrust() {\n-    let _ = panic::catch_unwind(|| { panic_in_rust_abi(); });\n+    let _ = panic::catch_unwind(|| {\n+        panic_in_ffi();\n+    });\n     should_have_aborted();\n }\n \n fn test_always_abort() {\n     panic::always_abort();\n-    let _ = panic::catch_unwind(|| { panic!(); });\n+    let _ = panic::catch_unwind(|| {\n+        panic!();\n+    });\n     should_have_aborted();\n }\n \n fn test_always_abort_thread() {\n     let barrier = Arc::new(Barrier::new(2));\n     let thr = {\n         let barrier = barrier.clone();\n-        thread::spawn(move ||{\n+        thread::spawn(move || {\n             barrier.wait();\n             panic!(\"in thread\");\n         })\n@@ -70,33 +63,36 @@ fn test_always_abort_thread() {\n fn main() {\n     let tests: &[(_, fn())] = &[\n         (\"test\", test),\n-        (\"testrust\", testrust),\n         (\"test_always_abort\", test_always_abort),\n         (\"test_always_abort_thread\", test_always_abort_thread),\n     ];\n \n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 {\n         // This is inside the self-executed command.\n-        for (a,f) in tests {\n-            if &args[1] == a { return f() }\n+        for (a, f) in tests {\n+            if &args[1] == a {\n+                return f();\n+            }\n         }\n         bomb_out_but_not_abort(\"bad test\");\n     }\n \n     let execute_self_expecting_abort = |arg| {\n         let mut p = Command::new(&args[0])\n-                            .stdout(Stdio::piped())\n-                            .stdin(Stdio::piped())\n-                            .arg(arg).spawn().unwrap();\n+            .stdout(Stdio::piped())\n+            .stdin(Stdio::piped())\n+            .arg(arg)\n+            .spawn()\n+            .unwrap();\n         let status = p.wait().unwrap();\n         assert!(!status.success());\n         // Any reasonable platform can distinguish a process which\n         // called exit(1) from one which panicked.\n         assert_ne!(status.code(), Some(1));\n     };\n \n-    for (a,_f) in tests {\n+    for (a, _f) in tests {\n         execute_self_expecting_abort(a);\n     }\n }"}]}