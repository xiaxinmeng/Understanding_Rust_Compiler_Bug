{"sha": "5f33adce1bfe01e4c0c8754400bf782a95af88c9", "node_id": "C_kwDOAAsO6NoAKDVmMzNhZGNlMWJmZTAxZTRjMGM4NzU0NDAwYmY3ODJhOTVhZjg4Yzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-21T09:04:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-21T09:04:05Z"}, "message": "Auto merge of #93963 - GuillaumeGomez:reduce-clean-type-size, r=notriddle\n\nrustdoc: Reduce clean::Type size\n\nThere is no need to keep the `DefId` around since it's allow used to compute if we should show a cast or not. As such, we can simply directly store the boolean.\n\nI think it's not what you had in mind `@camelid` but I guess it's still an improvement? :wink:\n\nIt was discussed in https://github.com/rust-lang/rust/pull/93941.\n\nr? `@camelid`", "tree": {"sha": "94614304362da4a1a7a27909f37819b8a4d824f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94614304362da4a1a7a27909f37819b8a4d824f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f33adce1bfe01e4c0c8754400bf782a95af88c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f33adce1bfe01e4c0c8754400bf782a95af88c9", "html_url": "https://github.com/rust-lang/rust/commit/5f33adce1bfe01e4c0c8754400bf782a95af88c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f33adce1bfe01e4c0c8754400bf782a95af88c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "html_url": "https://github.com/rust-lang/rust/commit/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b"}, {"sha": "2e1369c198e27da9eec015a9e11088e431feb50b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1369c198e27da9eec015a9e11088e431feb50b", "html_url": "https://github.com/rust-lang/rust/commit/2e1369c198e27da9eec015a9e11088e431feb50b"}], "stats": {"total": 419, "additions": 213, "deletions": 206}, "files": [{"sha": "04d97e0dabfa0712b1fc9c8e1a3c7315e5428a88", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 208, "deletions": 195, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/5f33adce1bfe01e4c0c8754400bf782a95af88c9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f33adce1bfe01e4c0c8754400bf782a95af88c9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5f33adce1bfe01e4c0c8754400bf782a95af88c9", "patch": "@@ -379,20 +379,41 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n+fn clean_projection<'tcx>(\n+    ty: ty::ProjectionTy<'tcx>,\n+    cx: &mut DocContext<'_>,\n+    def_id: Option<DefId>,\n+) -> Type {\n+    let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n+    let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n+    let self_type = ty.self_ty().clean(cx);\n+    let self_def_id = if let Some(def_id) = def_id {\n+        cx.tcx.opt_parent(def_id).or(Some(def_id))\n+    } else {\n+        self_type.def_id(&cx.cache)\n+    };\n+    let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n+    Type::QPath {\n+        assoc: Box::new(projection_to_path_segment(ty, cx)),\n+        should_show_cast,\n+        self_type: box self_type,\n+        trait_,\n+    }\n+}\n+\n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n-        let lifted = self.lift_to_tcx(cx.tcx).unwrap();\n-        let trait_ = lifted.trait_ref(cx.tcx).clean(cx);\n-        let self_type = self.self_ty().clean(cx);\n-        Type::QPath {\n-            assoc: Box::new(projection_to_path_segment(*self, cx)),\n-            self_def_id: self_type.def_id(&cx.cache),\n-            self_type: box self_type,\n-            trait_,\n-        }\n+        clean_projection(*self, cx, None)\n     }\n }\n \n+fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type: &Type) -> bool {\n+    !trait_.segments.is_empty()\n+        && self_def_id\n+            .zip(Some(trait_.def_id()))\n+            .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_)\n+}\n+\n fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>) -> PathSegment {\n     let item = cx.tcx.associated_item(ty.item_def_id);\n     let generics = cx.tcx.generics_of(ty.item_def_id);\n@@ -413,19 +434,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n             }\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 let default = if has_default {\n-                    let mut default = cx.tcx.type_of(self.def_id).clean(cx);\n-\n-                    // We need to reassign the `self_def_id`, if there's a parent (which is the\n-                    // `Self` type), so we can properly render `<Self as X>` casts, because the\n-                    // information about which type `Self` is, is only present here, but not in\n-                    // the cleaning process of the type itself. To resolve this and have the\n-                    // `self_def_id` set, we override it here.\n-                    // See https://github.com/rust-lang/rust/issues/85454\n-                    if let QPath { ref mut self_def_id, .. } = default {\n-                        *self_def_id = Some(cx.tcx.parent(self.def_id));\n-                    }\n-\n-                    Some(default)\n+                    Some(clean_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n                 } else {\n                     None\n                 };\n@@ -1309,10 +1318,13 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 segments: trait_segments.iter().map(|x| x.clean(cx)).collect(),\n             };\n             register_res(cx, trait_.res);\n+            let self_def_id = DefId::local(qself.hir_id.owner.local_def_index);\n+            let self_type = qself.clean(cx);\n+            let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);\n             Type::QPath {\n                 assoc: Box::new(p.segments.last().expect(\"segments were empty\").clean(cx)),\n-                self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n-                self_type: box qself.clean(cx),\n+                should_show_cast,\n+                self_type: box self_type,\n                 trait_,\n             }\n         }\n@@ -1326,10 +1338,13 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n             };\n             let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n             register_res(cx, trait_.res);\n+            let self_def_id = res.opt_def_id();\n+            let self_type = qself.clean(cx);\n+            let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n             Type::QPath {\n                 assoc: Box::new(segment.clean(cx)),\n-                self_def_id: res.opt_def_id(),\n-                self_type: box qself.clean(cx),\n+                should_show_cast,\n+                self_type: box self_type,\n                 trait_,\n             }\n         }\n@@ -1515,196 +1530,194 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n-        trace!(\"cleaning type: {:?}\", self);\n-        let ty = normalize(cx, *self).unwrap_or(*self);\n-        match *ty.kind() {\n-            ty::Never => Primitive(PrimitiveType::Never),\n-            ty::Bool => Primitive(PrimitiveType::Bool),\n-            ty::Char => Primitive(PrimitiveType::Char),\n-            ty::Int(int_ty) => Primitive(int_ty.into()),\n-            ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n-            ty::Float(float_ty) => Primitive(float_ty.into()),\n-            ty::Str => Primitive(PrimitiveType::Str),\n-            ty::Slice(ty) => Slice(box ty.clean(cx)),\n-            ty::Array(ty, n) => {\n-                let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n-                n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n-                let n = print_const(cx, n);\n-                Array(box ty.clean(cx), n)\n-            }\n-            ty::RawPtr(mt) => RawPointer(mt.mutbl, box mt.ty.clean(cx)),\n-            ty::Ref(r, ty, mutbl) => {\n-                BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: box ty.clean(cx) }\n-            }\n-            ty::FnDef(..) | ty::FnPtr(_) => {\n-                let ty = cx.tcx.lift(*self).expect(\"FnPtr lift failed\");\n-                let sig = ty.fn_sig(cx.tcx);\n-                let decl = clean_fn_decl_from_did_and_sig(cx, None, sig);\n-                BareFunction(box BareFunctionDecl {\n-                    unsafety: sig.unsafety(),\n-                    generic_params: Vec::new(),\n-                    decl,\n-                    abi: sig.abi(),\n-                })\n-            }\n-            ty::Adt(def, substs) => {\n-                let did = def.did();\n-                let kind = match def.adt_kind() {\n-                    AdtKind::Struct => ItemType::Struct,\n-                    AdtKind::Union => ItemType::Union,\n-                    AdtKind::Enum => ItemType::Enum,\n-                };\n-                inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, did, false, vec![], substs);\n-                Type::Path { path }\n-            }\n-            ty::Foreign(did) => {\n-                inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n-                let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n-                Type::Path { path }\n-            }\n-            ty::Dynamic(obj, ref reg) => {\n-                // HACK: pick the first `did` as the `did` of the trait object. Someone\n-                // might want to implement \"native\" support for marker-trait-only\n-                // trait objects.\n-                let mut dids = obj.principal_def_id().into_iter().chain(obj.auto_traits());\n-                let did = dids\n-                    .next()\n-                    .unwrap_or_else(|| panic!(\"found trait object `{:?}` with no traits?\", self));\n-                let substs = match obj.principal() {\n-                    Some(principal) => principal.skip_binder().substs,\n-                    // marker traits have no substs.\n-                    _ => cx.tcx.intern_substs(&[]),\n-                };\n+fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'_>, def_id: Option<DefId>) -> Type {\n+    trace!(\"cleaning type: {:?}\", this);\n+    let ty = normalize(cx, this).unwrap_or(this);\n+    match *ty.kind() {\n+        ty::Never => Primitive(PrimitiveType::Never),\n+        ty::Bool => Primitive(PrimitiveType::Bool),\n+        ty::Char => Primitive(PrimitiveType::Char),\n+        ty::Int(int_ty) => Primitive(int_ty.into()),\n+        ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n+        ty::Float(float_ty) => Primitive(float_ty.into()),\n+        ty::Str => Primitive(PrimitiveType::Str),\n+        ty::Slice(ty) => Slice(box ty.clean(cx)),\n+        ty::Array(ty, n) => {\n+            let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n+            n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n+            let n = print_const(cx, n);\n+            Array(box ty.clean(cx), n)\n+        }\n+        ty::RawPtr(mt) => RawPointer(mt.mutbl, box mt.ty.clean(cx)),\n+        ty::Ref(r, ty, mutbl) => {\n+            BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: box ty.clean(cx) }\n+        }\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let ty = cx.tcx.lift(this).expect(\"FnPtr lift failed\");\n+            let sig = ty.fn_sig(cx.tcx);\n+            let decl = clean_fn_decl_from_did_and_sig(cx, None, sig);\n+            BareFunction(box BareFunctionDecl {\n+                unsafety: sig.unsafety(),\n+                generic_params: Vec::new(),\n+                decl,\n+                abi: sig.abi(),\n+            })\n+        }\n+        ty::Adt(def, substs) => {\n+            let did = def.did();\n+            let kind = match def.adt_kind() {\n+                AdtKind::Struct => ItemType::Struct,\n+                AdtKind::Union => ItemType::Union,\n+                AdtKind::Enum => ItemType::Enum,\n+            };\n+            inline::record_extern_fqn(cx, did, kind);\n+            let path = external_path(cx, did, false, vec![], substs);\n+            Type::Path { path }\n+        }\n+        ty::Foreign(did) => {\n+            inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n+            let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n+            Type::Path { path }\n+        }\n+        ty::Dynamic(obj, ref reg) => {\n+            // HACK: pick the first `did` as the `did` of the trait object. Someone\n+            // might want to implement \"native\" support for marker-trait-only\n+            // trait objects.\n+            let mut dids = obj.principal_def_id().into_iter().chain(obj.auto_traits());\n+            let did = dids\n+                .next()\n+                .unwrap_or_else(|| panic!(\"found trait object `{:?}` with no traits?\", this));\n+            let substs = match obj.principal() {\n+                Some(principal) => principal.skip_binder().substs,\n+                // marker traits have no substs.\n+                _ => cx.tcx.intern_substs(&[]),\n+            };\n \n-                inline::record_extern_fqn(cx, did, ItemType::Trait);\n+            inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n-                let lifetime = reg.clean(cx);\n-                let mut bounds = vec![];\n+            let lifetime = reg.clean(cx);\n+            let mut bounds = vec![];\n \n-                for did in dids {\n-                    let empty = cx.tcx.intern_substs(&[]);\n-                    let path = external_path(cx, did, false, vec![], empty);\n-                    inline::record_extern_fqn(cx, did, ItemType::Trait);\n-                    let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n-                    bounds.push(bound);\n-                }\n+            for did in dids {\n+                let empty = cx.tcx.intern_substs(&[]);\n+                let path = external_path(cx, did, false, vec![], empty);\n+                inline::record_extern_fqn(cx, did, ItemType::Trait);\n+                let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n+                bounds.push(bound);\n+            }\n \n-                let mut bindings = vec![];\n-                for pb in obj.projection_bounds() {\n-                    bindings.push(TypeBinding {\n-                        assoc: projection_to_path_segment(\n-                            pb.skip_binder()\n-                                .lift_to_tcx(cx.tcx)\n-                                .unwrap()\n-                                // HACK(compiler-errors): Doesn't actually matter what self\n-                                // type we put here, because we're only using the GAT's substs.\n-                                .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n-                                .projection_ty,\n-                            cx,\n-                        ),\n-                        kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n-                    });\n-                }\n+            let mut bindings = vec![];\n+            for pb in obj.projection_bounds() {\n+                bindings.push(TypeBinding {\n+                    assoc: projection_to_path_segment(\n+                        pb.skip_binder()\n+                            .lift_to_tcx(cx.tcx)\n+                            .unwrap()\n+                            // HACK(compiler-errors): Doesn't actually matter what self\n+                            // type we put here, because we're only using the GAT's substs.\n+                            .with_self_ty(cx.tcx, cx.tcx.types.self_param)\n+                            .projection_ty,\n+                        cx,\n+                    ),\n+                    kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n+                });\n+            }\n \n-                let path = external_path(cx, did, false, bindings, substs);\n-                bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n+            let path = external_path(cx, did, false, bindings, substs);\n+            bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n \n-                DynTrait(bounds, lifetime)\n-            }\n-            ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n+            DynTrait(bounds, lifetime)\n+        }\n+        ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n \n-            ty::Projection(ref data) => data.clean(cx),\n+        ty::Projection(ref data) => clean_projection(*data, cx, def_id),\n \n-            ty::Param(ref p) => {\n-                if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n-                    ImplTrait(bounds)\n-                } else {\n-                    Generic(p.name)\n-                }\n+        ty::Param(ref p) => {\n+            if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n+                ImplTrait(bounds)\n+            } else {\n+                Generic(p.name)\n             }\n+        }\n \n-            ty::Opaque(def_id, substs) => {\n-                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the bounds associated with the def_id.\n-                let substs = cx.tcx.lift(substs).expect(\"Opaque lift failed\");\n-                let bounds = cx\n-                    .tcx\n-                    .explicit_item_bounds(def_id)\n-                    .iter()\n-                    .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n-                    .collect::<Vec<_>>();\n-                let mut regions = vec![];\n-                let mut has_sized = false;\n-                let mut bounds = bounds\n-                    .iter()\n-                    .filter_map(|bound| {\n-                        let bound_predicate = bound.kind();\n-                        let trait_ref = match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n-                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n-                                if let Some(r) = reg.clean(cx) {\n-                                    regions.push(GenericBound::Outlives(r));\n-                                }\n-                                return None;\n+        ty::Opaque(def_id, substs) => {\n+            // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+            // by looking up the bounds associated with the def_id.\n+            let substs = cx.tcx.lift(substs).expect(\"Opaque lift failed\");\n+            let bounds = cx\n+                .tcx\n+                .explicit_item_bounds(def_id)\n+                .iter()\n+                .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n+                .collect::<Vec<_>>();\n+            let mut regions = vec![];\n+            let mut has_sized = false;\n+            let mut bounds = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    let bound_predicate = bound.kind();\n+                    let trait_ref = match bound_predicate.skip_binder() {\n+                        ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n+                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                            if let Some(r) = reg.clean(cx) {\n+                                regions.push(GenericBound::Outlives(r));\n                             }\n-                            _ => return None,\n-                        };\n+                            return None;\n+                        }\n+                        _ => return None,\n+                    };\n \n-                        if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                            if trait_ref.def_id() == sized {\n-                                has_sized = true;\n-                                return None;\n-                            }\n+                    if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n+                        if trait_ref.def_id() == sized {\n+                            has_sized = true;\n+                            return None;\n                         }\n+                    }\n \n-                        let bindings: Vec<_> = bounds\n-                            .iter()\n-                            .filter_map(|bound| {\n-                                if let ty::PredicateKind::Projection(proj) =\n-                                    bound.kind().skip_binder()\n-                                {\n-                                    if proj.projection_ty.trait_ref(cx.tcx)\n-                                        == trait_ref.skip_binder()\n-                                    {\n-                                        Some(TypeBinding {\n-                                            assoc: projection_to_path_segment(\n-                                                proj.projection_ty,\n-                                                cx,\n-                                            ),\n-                                            kind: TypeBindingKind::Equality {\n-                                                term: proj.term.clean(cx),\n-                                            },\n-                                        })\n-                                    } else {\n-                                        None\n-                                    }\n+                    let bindings: Vec<_> = bounds\n+                        .iter()\n+                        .filter_map(|bound| {\n+                            if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder()\n+                            {\n+                                if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n+                                    Some(TypeBinding {\n+                                        assoc: projection_to_path_segment(proj.projection_ty, cx),\n+                                        kind: TypeBindingKind::Equality {\n+                                            term: proj.term.clean(cx),\n+                                        },\n+                                    })\n                                 } else {\n                                     None\n                                 }\n-                            })\n-                            .collect();\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .collect();\n \n-                        Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, &bindings))\n-                    })\n-                    .collect::<Vec<_>>();\n-                bounds.extend(regions);\n-                if !has_sized && !bounds.is_empty() {\n-                    bounds.insert(0, GenericBound::maybe_sized(cx));\n-                }\n-                ImplTrait(bounds)\n+                    Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, &bindings))\n+                })\n+                .collect::<Vec<_>>();\n+            bounds.extend(regions);\n+            if !has_sized && !bounds.is_empty() {\n+                bounds.insert(0, GenericBound::maybe_sized(cx));\n             }\n+            ImplTrait(bounds)\n+        }\n \n-            ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n+        ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n-            ty::Bound(..) => panic!(\"Bound\"),\n-            ty::Placeholder(..) => panic!(\"Placeholder\"),\n-            ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n-            ty::Infer(..) => panic!(\"Infer\"),\n-            ty::Error(_) => panic!(\"Error\"),\n-        }\n+        ty::Bound(..) => panic!(\"Bound\"),\n+        ty::Placeholder(..) => panic!(\"Placeholder\"),\n+        ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n+        ty::Infer(..) => panic!(\"Infer\"),\n+        ty::Error(_) => panic!(\"Error\"),\n+    }\n+}\n+\n+impl<'tcx> Clean<Type> for Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+        clean_ty(*self, cx, None)\n     }\n }\n "}, {"sha": "3123ece37734b2ad5f5ad4fc4f262bdb7c990148", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f33adce1bfe01e4c0c8754400bf782a95af88c9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f33adce1bfe01e4c0c8754400bf782a95af88c9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=5f33adce1bfe01e4c0c8754400bf782a95af88c9", "patch": "@@ -1560,10 +1560,8 @@ pub(crate) enum Type {\n     QPath {\n         assoc: Box<PathSegment>,\n         self_type: Box<Type>,\n-        /// FIXME: This is a hack that should be removed; see [this discussion][1].\n-        ///\n-        /// [1]: https://github.com/rust-lang/rust/pull/85479#discussion_r635729093\n-        self_def_id: Option<DefId>,\n+        /// FIXME: compute this field on demand.\n+        should_show_cast: bool,\n         trait_: Path,\n     },\n \n@@ -1576,7 +1574,7 @@ pub(crate) enum Type {\n \n // `Type` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Type, 80);\n+rustc_data_structures::static_assert_size!(Type, 72);\n \n impl Type {\n     /// When comparing types for equality, it can help to ignore `&` wrapping.\n@@ -2180,7 +2178,7 @@ pub(crate) enum GenericArg {\n // `GenericArg` can occur many times in a single `Path`, so make sure it\n // doesn't increase in size unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericArg, 88);\n+rustc_data_structures::static_assert_size!(GenericArg, 80);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) enum GenericArgs {"}, {"sha": "1214e4367c2f80b890e2a7947066ece4ac73bb15", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f33adce1bfe01e4c0c8754400bf782a95af88c9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f33adce1bfe01e4c0c8754400bf782a95af88c9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5f33adce1bfe01e4c0c8754400bf782a95af88c9", "patch": "@@ -985,11 +985,7 @@ fn fmt_type<'cx>(\n                 write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n-        clean::QPath { ref assoc, ref self_type, ref trait_, ref self_def_id } => {\n-            let should_show_cast = !trait_.segments.is_empty()\n-                && self_def_id\n-                    .zip(Some(trait_.def_id()))\n-                    .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_);\n+        clean::QPath { ref assoc, ref self_type, ref trait_, should_show_cast } => {\n             if f.alternate() {\n                 if should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?"}]}