{"sha": "208d23a9966a91318e59b474eb2fe7e1891a590a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOGQyM2E5OTY2YTkxMzE4ZTU5YjQ3NGViMmZlN2UxODkxYTU5MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-17T08:14:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-17T08:14:55Z"}, "message": "Auto merge of #41961 - kennytm:fix-35829, r=petrochenkov\n\nFix #35829 (`quote!()` does not handle `br#\"\u2026\"#`)\n\nFix issue #35829 (syntax extension's `quote_expr!()` does not handle `b\"\u2026\"` and proc_macro's `quote!()` does not handle `r#\"\u2026\"#`)\n\n* Handles `b\"\u2026\"`, `br#\"\u2026\"#` and `...` for `quote_expr!()`.\n* Refactored the match statement to allow it to complain loudly on any unhandled token.\n* Similarly, proc_macro's `quote!()` did not handle `br#\"\u2026\"#` or `r#\"\u2026\"#`, so this PR fixes it too.", "tree": {"sha": "46b8215b6e1821f7994e82eabaa21ff733a716a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46b8215b6e1821f7994e82eabaa21ff733a716a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/208d23a9966a91318e59b474eb2fe7e1891a590a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/208d23a9966a91318e59b474eb2fe7e1891a590a", "html_url": "https://github.com/rust-lang/rust/commit/208d23a9966a91318e59b474eb2fe7e1891a590a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/208d23a9966a91318e59b474eb2fe7e1891a590a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42e3732d7d9c5e3d253082faa09ea348d1a0a309", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e3732d7d9c5e3d253082faa09ea348d1a0a309", "html_url": "https://github.com/rust-lang/rust/commit/42e3732d7d9c5e3d253082faa09ea348d1a0a309"}, {"sha": "115854e19c3ab0c9896a388cfff38a8e2cc81113", "url": "https://api.github.com/repos/rust-lang/rust/commits/115854e19c3ab0c9896a388cfff38a8e2cc81113", "html_url": "https://github.com/rust-lang/rust/commit/115854e19c3ab0c9896a388cfff38a8e2cc81113"}], "stats": {"total": 144, "additions": 103, "deletions": 41}, "files": [{"sha": "09675564291a248b4ded93dddccee6aa6371a73f", "filename": "src/libproc_macro_plugin/quote.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Flibproc_macro_plugin%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Flibproc_macro_plugin%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fquote.rs?ref=208d23a9966a91318e59b474eb2fe7e1891a590a", "patch": "@@ -133,6 +133,14 @@ impl<'a> Quote for &'a str {\n     }\n }\n \n+impl Quote for usize {\n+    fn quote(&self) -> TokenStream {\n+        let integer_symbol = Symbol::intern(&self.to_string());\n+        TokenTree::Token(DUMMY_SP, Token::Literal(token::Lit::Integer(integer_symbol), None))\n+            .into()\n+    }\n+}\n+\n impl Quote for Ident {\n     fn quote(&self) -> TokenStream {\n         // FIXME(jseyfried) quote hygiene\n@@ -193,15 +201,17 @@ impl Quote for token::BinOpToken {\n impl Quote for Lit {\n     fn quote(&self) -> TokenStream {\n         macro_rules! gen_match {\n-            ($($i:ident),*) => {\n+            ($($i:ident),*; $($raw:ident),*) => {\n                 match *self {\n                     $( Lit::$i(lit) => quote!(::syntax::parse::token::Lit::$i((quote lit))), )*\n-                    _ => panic!(\"Unsupported literal\"),\n+                    $( Lit::$raw(lit, n) => {\n+                        quote!(::syntax::parse::token::Lit::$raw((quote lit), (quote n)))\n+                    })*\n                 }\n             }\n         }\n \n-        gen_match!(Byte, Char, Float, Str_, Integer, ByteStr)\n+        gen_match!(Byte, Char, Float, Str_, Integer, ByteStr; StrRaw, ByteStrRaw)\n     }\n }\n "}, {"sha": "f8fac847a053ef63c68e00b8ca7bcb7d4c4f2ebd", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=208d23a9966a91318e59b474eb2fe7e1891a590a", "patch": "@@ -612,16 +612,20 @@ fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> {\n #[allow(non_upper_case_globals)]\n fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     macro_rules! mk_lit {\n-        ($name: expr, $suffix: expr, $($args: expr),*) => {{\n-            let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![$($args),*]);\n+        ($name: expr, $suffix: expr, $content: expr $(, $count: expr)*) => {{\n+            let name = mk_name(cx, sp, ast::Ident::with_empty_ctxt($content));\n+            let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![\n+                name $(, cx.expr_usize(sp, $count))*\n+            ]);\n             let suffix = match $suffix {\n                 Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::with_empty_ctxt(name))),\n                 None => cx.expr_none(sp)\n             };\n             cx.expr_call(sp, mk_token_path(cx, sp, \"Literal\"), vec![inner, suffix])\n         }}\n     }\n-    match *tok {\n+\n+    let name = match *tok {\n         token::BinOp(binop) => {\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOp\"), vec![mk_binop(cx, sp, binop)]);\n         }\n@@ -639,34 +643,14 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec![mk_delim(cx, sp, delim)]);\n         }\n \n-        token::Literal(token::Byte(i), suf) => {\n-            let e_byte = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n-            return mk_lit!(\"Byte\", suf, e_byte);\n-        }\n-\n-        token::Literal(token::Char(i), suf) => {\n-            let e_char = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n-            return mk_lit!(\"Char\", suf, e_char);\n-        }\n-\n-        token::Literal(token::Integer(i), suf) => {\n-            let e_int = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n-            return mk_lit!(\"Integer\", suf, e_int);\n-        }\n-\n-        token::Literal(token::Float(fident), suf) => {\n-            let e_fident = mk_name(cx, sp, ast::Ident::with_empty_ctxt(fident));\n-            return mk_lit!(\"Float\", suf, e_fident);\n-        }\n-\n-        token::Literal(token::Str_(ident), suf) => {\n-            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)))\n-        }\n-\n-        token::Literal(token::StrRaw(ident, n), suf) => {\n-            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)),\n-                           cx.expr_usize(sp, n))\n-        }\n+        token::Literal(token::Byte(i), suf) => return mk_lit!(\"Byte\", suf, i),\n+        token::Literal(token::Char(i), suf) => return mk_lit!(\"Char\", suf, i),\n+        token::Literal(token::Integer(i), suf) => return mk_lit!(\"Integer\", suf, i),\n+        token::Literal(token::Float(i), suf) => return mk_lit!(\"Float\", suf, i),\n+        token::Literal(token::Str_(i), suf) => return mk_lit!(\"Str_\", suf, i),\n+        token::Literal(token::StrRaw(i, n), suf) => return mk_lit!(\"StrRaw\", suf, i, n),\n+        token::Literal(token::ByteStr(i), suf) => return mk_lit!(\"ByteStr\", suf, i),\n+        token::Literal(token::ByteStrRaw(i, n), suf) => return mk_lit!(\"ByteStrRaw\", suf, i, n),\n \n         token::Ident(ident) => {\n             return cx.expr_call(sp,\n@@ -688,10 +672,6 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n         token::Interpolated(_) => panic!(\"quote! with interpolated token\"),\n \n-        _ => ()\n-    }\n-\n-    let name = match *tok {\n         token::Eq           => \"Eq\",\n         token::Lt           => \"Lt\",\n         token::Le           => \"Le\",\n@@ -706,6 +686,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::At           => \"At\",\n         token::Dot          => \"Dot\",\n         token::DotDot       => \"DotDot\",\n+        token::DotDotDot    => \"DotDotDot\",\n         token::Comma        => \"Comma\",\n         token::Semi         => \"Semi\",\n         token::Colon        => \"Colon\",\n@@ -718,7 +699,10 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::Question     => \"Question\",\n         token::Underscore   => \"Underscore\",\n         token::Eof          => \"Eof\",\n-        _                   => panic!(\"unhandled token in quote!\"),\n+\n+        token::Whitespace | token::SubstNt(_) | token::Comment | token::Shebang(_) => {\n+            panic!(\"unhandled token in quote!\");\n+        }\n     };\n     mk_token_path(cx, sp, name)\n }"}, {"sha": "0a4c15a9236b9bc6042b4f510b228a119aed5e95", "filename": "src/test/run-pass-fulldeps/issue-35829.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "raw_url": "https://github.com/rust-lang/rust/raw/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs?ref=208d23a9966a91318e59b474eb2fe7e1891a590a", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// ignore-cross-compile\n+#![feature(quote, rustc_private)]\n+\n+extern crate syntax;\n+\n+use syntax::ext::base::{ExtCtxt, DummyResolver};\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::parse::ParseSess;\n+use syntax::codemap::{FilePathMapping, dummy_spanned};\n+use syntax::print::pprust::expr_to_string;\n+use syntax::ast::{Expr, ExprKind, LitKind, StrStyle, RangeLimits};\n+use syntax::symbol::Symbol;\n+use syntax::ptr::P;\n+\n+use std::rc::Rc;\n+\n+fn main() {\n+    let parse_sess = ParseSess::new(FilePathMapping::empty());\n+    let exp_cfg = ExpansionConfig::default(\"issue_35829\".to_owned());\n+    let mut resolver = DummyResolver;\n+    let cx = ExtCtxt::new(&parse_sess, exp_cfg, &mut resolver);\n+\n+    // check byte string\n+    let byte_string = quote_expr!(&cx, b\"one\");\n+    let byte_string_lit_kind = LitKind::ByteStr(Rc::new(b\"one\".to_vec()));\n+    assert_eq!(byte_string.node, ExprKind::Lit(P(dummy_spanned(byte_string_lit_kind))));\n+\n+    // check raw byte string\n+    let raw_byte_string = quote_expr!(&cx, br###\"#\"two\"#\"###);\n+    let raw_byte_string_lit_kind = LitKind::ByteStr(Rc::new(b\"#\\\"two\\\"#\".to_vec()));\n+    assert_eq!(raw_byte_string.node, ExprKind::Lit(P(dummy_spanned(raw_byte_string_lit_kind))));\n+\n+    // check dotdotdot\n+    let closed_range = quote_expr!(&cx, 0 ... 1);\n+    assert_eq!(closed_range.node, ExprKind::Range(\n+        Some(quote_expr!(&cx, 0)),\n+        Some(quote_expr!(&cx, 1)),\n+        RangeLimits::Closed\n+    ));\n+\n+    // test case from 35829\n+    let expr_35829 = quote_expr!(&cx, std::io::stdout().write(b\"one\"));\n+    assert_eq!(expr_to_string(&expr_35829), r#\"std::io::stdout().write(b\"one\")\"#);\n+}"}, {"sha": "e7d0a83017be004c4128d318ea1978515e18ed22", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/208d23a9966a91318e59b474eb2fe7e1891a590a/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=208d23a9966a91318e59b474eb2fe7e1891a590a", "patch": "@@ -17,11 +17,24 @@\n extern crate syntax;\n extern crate syntax_pos;\n \n-use syntax::ast::Ident;\n-use syntax::parse::token;\n+use syntax::ast::{Ident, Name};\n+use syntax::parse::token::{self, Token, Lit};\n use syntax::tokenstream::TokenTree;\n \n fn main() {\n     let true_tok = token::Ident(Ident::from_str(\"true\"));\n     assert!(quote!(true).eq_unspanned(&true_tok.into()));\n+\n+    // issue #35829, extended check to proc_macro.\n+    let triple_dot_tok = Token::DotDotDot;\n+    assert!(quote!(...).eq_unspanned(&triple_dot_tok.into()));\n+\n+    let byte_str_tok = Token::Literal(Lit::ByteStr(Name::intern(\"one\")), None);\n+    assert!(quote!(b\"one\").eq_unspanned(&byte_str_tok.into()));\n+\n+    let byte_str_raw_tok = Token::Literal(Lit::ByteStrRaw(Name::intern(\"#\\\"two\\\"#\"), 3), None);\n+    assert!(quote!(br###\"#\"two\"#\"###).eq_unspanned(&byte_str_raw_tok.into()));\n+\n+    let str_raw_tok = Token::Literal(Lit::StrRaw(Name::intern(\"#\\\"three\\\"#\"), 2), None);\n+    assert!(quote!(r##\"#\"three\"#\"##).eq_unspanned(&str_raw_tok.into()));\n }"}]}