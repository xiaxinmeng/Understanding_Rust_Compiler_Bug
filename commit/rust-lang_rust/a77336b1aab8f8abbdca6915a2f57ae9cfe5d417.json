{"sha": "a77336b1aab8f8abbdca6915a2f57ae9cfe5d417", "node_id": "C_kwDOAAsO6NoAKGE3NzMzNmIxYWFiOGY4YWJiZGNhNjkxNWEyZjU3YWU5Y2ZlNWQ0MTc", "commit": {"author": {"name": "Noritada Kobayashi", "email": "noritada.kobayashi@gmail.com", "date": "2022-12-13T17:12:24Z"}, "committer": {"name": "Noritada Kobayashi", "email": "noritada.kobayashi@gmail.com", "date": "2022-12-13T17:12:24Z"}, "message": "Implement inline macro handling for AsciiDoc-to-Markdown conversion", "tree": {"sha": "33ba3cceb9afb4111468a991a03fe5e4bf29961f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ba3cceb9afb4111468a991a03fe5e4bf29961f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a77336b1aab8f8abbdca6915a2f57ae9cfe5d417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a77336b1aab8f8abbdca6915a2f57ae9cfe5d417", "html_url": "https://github.com/rust-lang/rust/commit/a77336b1aab8f8abbdca6915a2f57ae9cfe5d417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a77336b1aab8f8abbdca6915a2f57ae9cfe5d417/comments", "author": {"login": "noritada", "id": 20850, "node_id": "MDQ6VXNlcjIwODUw", "avatar_url": "https://avatars.githubusercontent.com/u/20850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noritada", "html_url": "https://github.com/noritada", "followers_url": "https://api.github.com/users/noritada/followers", "following_url": "https://api.github.com/users/noritada/following{/other_user}", "gists_url": "https://api.github.com/users/noritada/gists{/gist_id}", "starred_url": "https://api.github.com/users/noritada/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noritada/subscriptions", "organizations_url": "https://api.github.com/users/noritada/orgs", "repos_url": "https://api.github.com/users/noritada/repos", "events_url": "https://api.github.com/users/noritada/events{/privacy}", "received_events_url": "https://api.github.com/users/noritada/received_events", "type": "User", "site_admin": false}, "committer": {"login": "noritada", "id": 20850, "node_id": "MDQ6VXNlcjIwODUw", "avatar_url": "https://avatars.githubusercontent.com/u/20850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noritada", "html_url": "https://github.com/noritada", "followers_url": "https://api.github.com/users/noritada/followers", "following_url": "https://api.github.com/users/noritada/following{/other_user}", "gists_url": "https://api.github.com/users/noritada/gists{/gist_id}", "starred_url": "https://api.github.com/users/noritada/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noritada/subscriptions", "organizations_url": "https://api.github.com/users/noritada/orgs", "repos_url": "https://api.github.com/users/noritada/repos", "events_url": "https://api.github.com/users/noritada/events{/privacy}", "received_events_url": "https://api.github.com/users/noritada/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7c6c6b8145dbf6d0fe4676325a143f4e584c25e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7c6c6b8145dbf6d0fe4676325a143f4e584c25e", "html_url": "https://github.com/rust-lang/rust/commit/c7c6c6b8145dbf6d0fe4676325a143f4e584c25e"}], "stats": {"total": 182, "additions": 182, "deletions": 0}, "files": [{"sha": "974baabefeaf1baa9e3eab59e62bc9991c9afe39", "filename": "xtask/src/publish/notes.rs", "status": "modified", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/a77336b1aab8f8abbdca6915a2f57ae9cfe5d417/xtask%2Fsrc%2Fpublish%2Fnotes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77336b1aab8f8abbdca6915a2f57ae9cfe5d417/xtask%2Fsrc%2Fpublish%2Fnotes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpublish%2Fnotes.rs?ref=a77336b1aab8f8abbdca6915a2f57ae9cfe5d417", "patch": "@@ -1,5 +1,6 @@\n use anyhow::{anyhow, bail};\n use std::{\n+    borrow::Cow,\n     io::{BufRead, Lines},\n     iter::Peekable,\n };\n@@ -431,6 +432,141 @@ impl ListMarker {\n     }\n }\n \n+fn process_inline_macros(line: &str) -> anyhow::Result<Cow<'_, str>> {\n+    let mut chars = line.char_indices();\n+    loop {\n+        let (start, end, a_macro) = match get_next_line_component(&mut chars) {\n+            Component::None => break,\n+            Component::Text => continue,\n+            Component::Macro(s, e, m) => (s, e, m),\n+        };\n+        let mut src = line.chars();\n+        let mut processed = String::new();\n+        for _ in 0..start {\n+            processed.push(src.next().unwrap());\n+        }\n+        processed.push_str(a_macro.process()?.as_str());\n+        for _ in start..end {\n+            let _ = src.next().unwrap();\n+        }\n+        let mut pos = end;\n+\n+        loop {\n+            let (start, end, a_macro) = match get_next_line_component(&mut chars) {\n+                Component::None => break,\n+                Component::Text => continue,\n+                Component::Macro(s, e, m) => (s, e, m),\n+            };\n+            for _ in pos..start {\n+                processed.push(src.next().unwrap());\n+            }\n+            processed.push_str(a_macro.process()?.as_str());\n+            for _ in start..end {\n+                let _ = src.next().unwrap();\n+            }\n+            pos = end;\n+        }\n+        for ch in src {\n+            processed.push(ch);\n+        }\n+        return Ok(Cow::Owned(processed));\n+    }\n+    Ok(Cow::Borrowed(line))\n+}\n+\n+fn get_next_line_component(chars: &mut std::str::CharIndices<'_>) -> Component {\n+    let (start, mut macro_name) = match chars.next() {\n+        None => return Component::None,\n+        Some((_, ch)) if ch == ' ' || !ch.is_ascii() => return Component::Text,\n+        Some((pos, ch)) => (pos, String::from(ch)),\n+    };\n+    loop {\n+        match chars.next() {\n+            None => return Component::None,\n+            Some((_, ch)) if ch == ' ' || !ch.is_ascii() => return Component::Text,\n+            Some((_, ':')) => break,\n+            Some((_, ch)) => macro_name.push(ch),\n+        }\n+    }\n+\n+    let mut macro_target = String::new();\n+    loop {\n+        match chars.next() {\n+            None => return Component::None,\n+            Some((_, ' ')) => return Component::Text,\n+            Some((_, '[')) => break,\n+            Some((_, ch)) => macro_target.push(ch),\n+        }\n+    }\n+\n+    let mut attr_value = String::new();\n+    let end = loop {\n+        match chars.next() {\n+            None => return Component::None,\n+            Some((pos, ']')) => break pos + 1,\n+            Some((_, ch)) => attr_value.push(ch),\n+        }\n+    };\n+\n+    Component::Macro(start, end, Macro::new(macro_name, macro_target, attr_value))\n+}\n+\n+enum Component {\n+    None,\n+    Text,\n+    Macro(usize, usize, Macro),\n+}\n+\n+struct Macro {\n+    name: String,\n+    target: String,\n+    attrs: String,\n+}\n+\n+impl Macro {\n+    fn new(name: String, target: String, attrs: String) -> Self {\n+        Self { name, target, attrs }\n+    }\n+\n+    fn process(&self) -> anyhow::Result<String> {\n+        let name = &self.name;\n+        let text = match name.as_str() {\n+            \"https\" => {\n+                let url = &self.target;\n+                let anchor_text = &self.attrs;\n+                format!(\"[{anchor_text}](https:{url})\")\n+            }\n+            \"image\" => {\n+                let url = &self.target;\n+                let alt = &self.attrs;\n+                format!(\"![{alt}]({url})\")\n+            }\n+            \"kbd\" => {\n+                let keys = self.attrs.split('+').map(|k| Cow::Owned(format!(\"<kbd>{k}</kbd>\")));\n+                keys.collect::<Vec<_>>().join(\"+\")\n+            }\n+            \"pr\" => {\n+                let pr = &self.target;\n+                let url = format!(\"https://github.com/rust-analyzer/rust-analyzer/pull/{pr}\");\n+                format!(\"[`#{pr}`]({url})\")\n+            }\n+            \"commit\" => {\n+                let hash = &self.target;\n+                let short = &hash[0..7];\n+                let url = format!(\"https://github.com/rust-analyzer/rust-analyzer/commit/{hash}\");\n+                format!(\"[`{short}`]({url})\")\n+            }\n+            \"release\" => {\n+                let date = &self.target;\n+                let url = format!(\"https://github.com/rust-analyzer/rust-analyzer/releases/{date}\");\n+                format!(\"[`{date}`]({url})\")\n+            }\n+            _ => bail!(\"macro not supported: {name}\"),\n+        };\n+        Ok(text)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -612,4 +748,50 @@ This is a plain listing.\n \n         assert_eq!(actual, expected);\n     }\n+\n+    macro_rules! test_inline_macro_processing {\n+        ($((\n+            $name:ident,\n+            $input:expr,\n+            $expected:expr\n+        ),)*) => ($(\n+            #[test]\n+            fn $name() {\n+                let input = $input;\n+                let actual = process_inline_macros(&input).unwrap();\n+                let expected = $expected;\n+                assert_eq!(actual, expected)\n+            }\n+        )*);\n+    }\n+\n+    test_inline_macro_processing! {\n+        (inline_macro_processing_for_empty_line, \"\", \"\"),\n+        (inline_macro_processing_for_line_with_no_macro, \"foo bar\", \"foo bar\"),\n+        (\n+            inline_macro_processing_for_macro_in_line_start,\n+            \"kbd::[Ctrl+T] foo\",\n+            \"<kbd>Ctrl</kbd>+<kbd>T</kbd> foo\"\n+        ),\n+        (\n+            inline_macro_processing_for_macro_in_line_end,\n+            \"foo kbd::[Ctrl+T]\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd>\"\n+        ),\n+        (\n+            inline_macro_processing_for_macro_in_the_middle_of_line,\n+            \"foo kbd::[Ctrl+T] foo\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd> foo\"\n+        ),\n+        (\n+            inline_macro_processing_for_several_macros,\n+            \"foo kbd::[Ctrl+T] foo kbd::[Enter] foo\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd> foo <kbd>Enter</kbd> foo\"\n+        ),\n+        (\n+            inline_macro_processing_for_several_macros_without_text_in_between,\n+            \"foo kbd::[Ctrl+T]kbd::[Enter] foo\",\n+            \"foo <kbd>Ctrl</kbd>+<kbd>T</kbd><kbd>Enter</kbd> foo\"\n+        ),\n+    }\n }"}]}