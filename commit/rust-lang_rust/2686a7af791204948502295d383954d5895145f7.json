{"sha": "2686a7af791204948502295d383954d5895145f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ODZhN2FmNzkxMjA0OTQ4NTAyMjk1ZDM4Mzk1NGQ1ODk1MTQ1Zjc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-11T22:06:02Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-02T00:45:03Z"}, "message": "rustc_apfloat: stub IEEE & PPC implementations.", "tree": {"sha": "fc49add9af0f4e7ac8836040394280aa1552e73f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc49add9af0f4e7ac8836040394280aa1552e73f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2686a7af791204948502295d383954d5895145f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2686a7af791204948502295d383954d5895145f7", "html_url": "https://github.com/rust-lang/rust/commit/2686a7af791204948502295d383954d5895145f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2686a7af791204948502295d383954d5895145f7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "877ec946543cae6f2c86742e79bcb3182e8960df", "url": "https://api.github.com/repos/rust-lang/rust/commits/877ec946543cae6f2c86742e79bcb3182e8960df", "html_url": "https://github.com/rust-lang/rust/commit/877ec946543cae6f2c86742e79bcb3182e8960df"}], "stats": {"total": 456, "additions": 455, "deletions": 1}, "files": [{"sha": "aab426a5caff32551198c04987b255d230dddb34", "filename": "src/librustc_apfloat/ieee.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/2686a7af791204948502295d383954d5895145f7/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2686a7af791204948502295d383954d5895145f7/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=2686a7af791204948502295d383954d5895145f7", "patch": "@@ -0,0 +1,265 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Category, ExpInt};\n+use {Float, FloatConvert, ParseError, Round, StatusAnd};\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::marker::PhantomData;\n+use std::ops::Neg;\n+\n+#[must_use]\n+pub struct IeeeFloat<S> {\n+    marker: PhantomData<S>,\n+}\n+\n+/// Represents floating point arithmetic semantics.\n+pub trait Semantics: Sized {\n+    /// Total number of bits in the in-memory format.\n+    const BITS: usize;\n+\n+    /// Number of bits in the significand. This includes the integer bit.\n+    const PRECISION: usize;\n+\n+    /// The largest E such that 2^E is representable; this matches the\n+    /// definition of IEEE 754.\n+    const MAX_EXP: ExpInt;\n+\n+    /// The smallest E such that 2^E is a normalized number; this\n+    /// matches the definition of IEEE 754.\n+    const MIN_EXP: ExpInt = -Self::MAX_EXP + 1;\n+}\n+\n+impl<S> Copy for IeeeFloat<S> {}\n+impl<S> Clone for IeeeFloat<S> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+macro_rules! ieee_semantics {\n+    ($($name:ident = $sem:ident($bits:tt : $exp_bits:tt)),*) => {\n+        $(pub struct $sem;)*\n+        $(pub type $name = IeeeFloat<$sem>;)*\n+        $(impl Semantics for $sem {\n+            const BITS: usize = $bits;\n+            const PRECISION: usize = ($bits - 1 - $exp_bits) + 1;\n+            const MAX_EXP: ExpInt = (1 << ($exp_bits - 1)) - 1;\n+        })*\n+    }\n+}\n+\n+ieee_semantics! {\n+    Half = HalfS(16:5),\n+    Single = SingleS(32:8),\n+    Double = DoubleS(64:11),\n+    Quad = QuadS(128:15)\n+}\n+\n+pub struct X87DoubleExtendedS;\n+pub type X87DoubleExtended = IeeeFloat<X87DoubleExtendedS>;\n+impl Semantics for X87DoubleExtendedS {\n+    const BITS: usize = 80;\n+    const PRECISION: usize = 64;\n+    const MAX_EXP: ExpInt = (1 << (15 - 1)) - 1;\n+}\n+\n+float_common_impls!(IeeeFloat<S>);\n+\n+impl<S: Semantics> PartialEq for IeeeFloat<S> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.partial_cmp(rhs) == Some(Ordering::Equal)\n+    }\n+}\n+\n+#[allow(unused)]\n+impl<S: Semantics> PartialOrd for IeeeFloat<S> {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n+        panic!(\"NYI PartialOrd::partial_cmp\");\n+    }\n+}\n+\n+impl<S> Neg for IeeeFloat<S> {\n+    type Output = Self;\n+    fn neg(self) -> Self {\n+        panic!(\"NYI Neg::neg\");\n+    }\n+}\n+\n+/// Prints this value as a decimal string.\n+///\n+/// \\param precision The maximum number of digits of\n+///   precision to output. If there are fewer digits available,\n+///   zero padding will not be used unless the value is\n+///   integral and small enough to be expressed in\n+///   precision digits. 0 means to use the natural\n+///   precision of the number.\n+/// \\param width The maximum number of zeros to\n+///   consider inserting before falling back to scientific\n+///   notation. 0 means to always use scientific notation.\n+///\n+/// \\param alternate Indicate whether to remove the trailing zero in\n+///   fraction part or not. Also setting this parameter to true forces\n+///   producing of output more similar to default printf behavior.\n+///   Specifically the lower e is used as exponent delimiter and exponent\n+///   always contains no less than two digits.\n+///\n+/// Number       precision    width      Result\n+/// ------       ---------    -----      ------\n+/// 1.01E+4              5        2       10100\n+/// 1.01E+4              4        2       1.01E+4\n+/// 1.01E+4              5        1       1.01E+4\n+/// 1.01E-2              5        2       0.0101\n+/// 1.01E-2              4        2       0.0101\n+/// 1.01E-2              4        1       1.01E-2\n+#[allow(unused)]\n+impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let frac_digits = f.precision().unwrap_or(0);\n+        let width = f.width().unwrap_or(3);\n+        let alternate = f.alternate();\n+        panic!(\"NYI Display::fmt\");\n+    }\n+}\n+\n+impl<S: Semantics> fmt::Debug for IeeeFloat<S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+#[allow(unused)]\n+impl<S: Semantics> Float for IeeeFloat<S> {\n+    const BITS: usize = S::BITS;\n+    const PRECISION: usize = S::PRECISION;\n+    const MAX_EXP: ExpInt = S::MAX_EXP;\n+    const MIN_EXP: ExpInt = S::MIN_EXP;\n+\n+    const ZERO: Self = IeeeFloat { marker: PhantomData };\n+\n+    const INFINITY: Self = IeeeFloat { marker: PhantomData };\n+\n+    // FIXME(eddyb) remove when qnan becomes const fn.\n+    const NAN: Self = IeeeFloat { marker: PhantomData };\n+\n+    fn qnan(payload: Option<u128>) -> Self {\n+        panic!(\"NYI qnan\")\n+    }\n+\n+    fn snan(payload: Option<u128>) -> Self {\n+        panic!(\"NYI snan\")\n+    }\n+\n+    fn largest() -> Self {\n+        panic!(\"NYI largest\")\n+    }\n+\n+    const SMALLEST: Self = IeeeFloat { marker: PhantomData };\n+\n+    fn smallest_normalized() -> Self {\n+        panic!(\"NYI smallest_normalized\")\n+    }\n+\n+    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI add_r\")\n+    }\n+\n+    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI mul_r\")\n+    }\n+\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI mul_add_r\")\n+    }\n+\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI div_r\")\n+    }\n+\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self> {\n+        panic!(\"NYI c_fmod\")\n+    }\n+\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI round_to_integral\")\n+    }\n+\n+    fn next_up(self) -> StatusAnd<Self> {\n+        panic!(\"NYI next_up\")\n+    }\n+\n+    fn from_bits(input: u128) -> Self {\n+        panic!(\"NYI from_bits\")\n+    }\n+\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI from_u128_r\")\n+    }\n+\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        panic!(\"NYI from_str_r\")\n+    }\n+\n+    fn to_bits(self) -> u128 {\n+        panic!(\"NYI to_bits\")\n+    }\n+\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n+        panic!(\"NYI to_u128_r\");\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n+        panic!(\"NYI cmp_abs_normal\")\n+    }\n+\n+    fn bitwise_eq(self, rhs: Self) -> bool {\n+        panic!(\"NYI bitwise_eq\")\n+    }\n+\n+    fn is_negative(self) -> bool {\n+        panic!(\"NYI is_negative\")\n+    }\n+\n+    fn is_denormal(self) -> bool {\n+        panic!(\"NYI is_denormal\")\n+    }\n+\n+    fn is_signaling(self) -> bool {\n+        panic!(\"NYI is_signaling\")\n+    }\n+\n+    fn category(self) -> Category {\n+        panic!(\"NYI category\")\n+    }\n+\n+    fn get_exact_inverse(self) -> Option<Self> {\n+        panic!(\"NYI get_exact_inverse\")\n+    }\n+\n+    fn ilogb(self) -> ExpInt {\n+        panic!(\"NYI ilogb\")\n+    }\n+\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self {\n+        panic!(\"NYI scalbn\")\n+    }\n+\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self {\n+        panic!(\"NYI frexp\")\n+    }\n+}\n+\n+#[allow(unused)]\n+impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n+    fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<IeeeFloat<T>> {\n+        panic!(\"NYI convert_r\");\n+    }\n+}"}, {"sha": "eb372b52c0a1044af9b785bf3939d611b5167070", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2686a7af791204948502295d383954d5895145f7/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2686a7af791204948502295d383954d5895145f7/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=2686a7af791204948502295d383954d5895145f7", "patch": "@@ -603,7 +603,6 @@ pub trait FloatConvert<T: Float>: Float {\n     }\n }\n \n-#[allow(unused)]\n macro_rules! float_common_impls {\n     ($ty:ident<$t:tt>) => {\n         impl<$t> Default for $ty<$t> where Self: Float {\n@@ -687,3 +686,6 @@ macro_rules! float_common_impls {\n         }\n     }\n }\n+\n+pub mod ieee;\n+pub mod ppc;"}, {"sha": "03c4830d49e87ca3dd25910934c1857e84ca23da", "filename": "src/librustc_apfloat/ppc.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/2686a7af791204948502295d383954d5895145f7/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2686a7af791204948502295d383954d5895145f7/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=2686a7af791204948502295d383954d5895145f7", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {ieee, Category, ExpInt, Float, Round, ParseError, StatusAnd};\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::ops::Neg;\n+\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n+pub struct DoubleFloat<F>(F, F);\n+pub type DoubleDouble = DoubleFloat<ieee::Double>;\n+\n+// These are legacy semantics for the Fallback, inaccrurate implementation of\n+// IBM double-double, if the accurate DoubleDouble doesn't handle the\n+// operation. It's equivalent to having an IEEE number with consecutive 106\n+// bits of mantissa and 11 bits of exponent.\n+//\n+// It's not equivalent to IBM double-double. For example, a legit IBM\n+// double-double, 1 + epsilon:\n+//\n+//   1 + epsilon = 1 + (1 >> 1076)\n+//\n+// is not representable by a consecutive 106 bits of mantissa.\n+//\n+// Currently, these semantics are used in the following way:\n+//\n+//   DoubleDouble -> (Double, Double) ->\n+//   DoubleDouble's Fallback -> IEEE operations\n+//\n+// FIXME: Implement all operations in DoubleDouble, and delete these\n+// semantics.\n+// FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n+pub struct FallbackS<F>(F);\n+type Fallback<F> = ieee::IeeeFloat<FallbackS<F>>;\n+impl<F: Float> ieee::Semantics for FallbackS<F> {\n+    // Forbid any conversion to/from bits.\n+    const BITS: usize = 0;\n+    const PRECISION: usize = F::PRECISION * 2;\n+    const MAX_EXP: ExpInt = F::MAX_EXP as ExpInt;\n+    const MIN_EXP: ExpInt = F::MIN_EXP as ExpInt + F::PRECISION as ExpInt;\n+}\n+\n+float_common_impls!(DoubleFloat<F>);\n+\n+impl<F: Float> Neg for DoubleFloat<F> {\n+    type Output = Self;\n+    fn neg(self) -> Self {\n+        panic!(\"NYI Neg::neg\");\n+    }\n+}\n+\n+#[allow(unused)]\n+impl<F: Float> fmt::Display for DoubleFloat<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        panic!(\"NYI Display::fmt\");\n+    }\n+}\n+\n+#[allow(unused)]\n+impl<F: Float> Float for DoubleFloat<F> {\n+    const BITS: usize = F::BITS * 2;\n+    const PRECISION: usize = Fallback::<F>::PRECISION;\n+    const MAX_EXP: ExpInt = Fallback::<F>::MAX_EXP;\n+    const MIN_EXP: ExpInt = Fallback::<F>::MIN_EXP;\n+\n+    const ZERO: Self = DoubleFloat(F::ZERO, F::ZERO);\n+\n+    const INFINITY: Self = DoubleFloat(F::INFINITY, F::ZERO);\n+\n+    // FIXME(eddyb) remove when qnan becomes const fn.\n+    const NAN: Self = DoubleFloat(F::NAN, F::ZERO);\n+\n+    fn qnan(payload: Option<u128>) -> Self {\n+        panic!(\"NYI qnan\")\n+    }\n+\n+    fn snan(payload: Option<u128>) -> Self {\n+        panic!(\"NYI snan\")\n+    }\n+\n+    fn largest() -> Self {\n+        panic!(\"NYI largest\")\n+    }\n+\n+    const SMALLEST: Self = DoubleFloat(F::SMALLEST, F::ZERO);\n+\n+    fn smallest_normalized() -> Self {\n+        panic!(\"NYI smallest_normalized\")\n+    }\n+\n+    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI add_r\")\n+    }\n+\n+    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI mul_r\")\n+    }\n+\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI mul_add_r\")\n+    }\n+\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI div_r\")\n+    }\n+\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self> {\n+        panic!(\"NYI c_fmod\")\n+    }\n+\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI round_to_integral\")\n+    }\n+\n+    fn next_up(self) -> StatusAnd<Self> {\n+        panic!(\"NYI next_up\")\n+    }\n+\n+    fn from_bits(input: u128) -> Self {\n+        panic!(\"NYI from_bits\")\n+    }\n+\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n+        panic!(\"NYI from_u128_r\")\n+    }\n+\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        panic!(\"NYI from_str_r\")\n+    }\n+\n+    fn to_bits(self) -> u128 {\n+        panic!(\"NYI to_bits\")\n+    }\n+\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n+        panic!(\"NYI to_u128_r\");\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n+        panic!(\"NYI cmp_abs_normal\")\n+    }\n+\n+    fn bitwise_eq(self, rhs: Self) -> bool {\n+        panic!(\"NYI bitwise_eq\")\n+    }\n+\n+    fn is_negative(self) -> bool {\n+        panic!(\"NYI is_negative\")\n+    }\n+\n+    fn is_denormal(self) -> bool {\n+        panic!(\"NYI is_denormal\")\n+    }\n+\n+    fn is_signaling(self) -> bool {\n+        panic!(\"NYI is_signaling\")\n+    }\n+\n+    fn category(self) -> Category {\n+        panic!(\"NYI category\")\n+    }\n+\n+    fn get_exact_inverse(self) -> Option<Self> {\n+        panic!(\"NYI get_exact_inverse\")\n+    }\n+\n+    fn ilogb(self) -> ExpInt {\n+        panic!(\"NYI ilogb\")\n+    }\n+\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self {\n+        panic!(\"NYI scalbn\")\n+    }\n+\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self {\n+        panic!(\"NYI frexp\")\n+    }\n+}"}]}