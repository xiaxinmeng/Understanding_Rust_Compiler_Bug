{"sha": "0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NzZjM2JmMDMxNWI3Y2I1ZGQzMDk0MzViNmM1ZWFkNWJmMmJjMmY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-09T18:44:51Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:48Z"}, "message": "librustc_trans: use unboxed closures", "tree": {"sha": "87cecf8c3c22f244d14daa61742f8de0441d70c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87cecf8c3c22f244d14daa61742f8de0441d70c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "html_url": "https://github.com/rust-lang/rust/commit/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/comments", "author": null, "committer": null, "parents": [{"sha": "0d4d8b9b78daff70b2b251fb5f71954d69a3b204", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d4d8b9b78daff70b2b251fb5f71954d69a3b204", "html_url": "https://github.com/rust-lang/rust/commit/0d4d8b9b78daff70b2b251fb5f71954d69a3b204"}], "stats": {"total": 247, "additions": 140, "deletions": 107}, "files": [{"sha": "c52f31532dcd0c63c74ab4dfe8367ab41f854194", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -488,8 +488,12 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     // pass manager passed to the closure should be ensured to not\n     // escape the closure itself, and the manager should only be\n     // used once.\n-    unsafe fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n-                    no_builtins: bool, f: |PassManagerRef|) {\n+    unsafe fn with_codegen<F>(tm: TargetMachineRef,\n+                              llmod: ModuleRef,\n+                              no_builtins: bool,\n+                              f: F) where\n+        F: FnOnce(PassManagerRef),\n+    {\n         let cpm = llvm::LLVMCreatePassManager();\n         llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n         llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);"}, {"sha": "329241b24e6520f0fa3d5daa4db8a60a674371d8", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -79,7 +79,9 @@ struct DxrVisitor<'l, 'tcx: 'l> {\n }\n \n impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n-    fn nest(&mut self, scope_id: NodeId, f: |&mut DxrVisitor<'l, 'tcx>|) {\n+    fn nest<F>(&mut self, scope_id: NodeId, f: F) where\n+        F: FnOnce(&mut DxrVisitor<'l, 'tcx>),\n+    {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n         f(self);"}, {"sha": "b051292571980fe47987f7cdf79ed9c75a00d0d0", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -1578,14 +1578,15 @@ pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n }\n \n-fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n-                                    p_id: ast::NodeId,\n-                                    ident: &ast::Ident,\n-                                    cleanup_scope: cleanup::ScopeId,\n-                                    arg: A,\n-                                    populate: |A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|\n-                                              -> Block<'blk, 'tcx>)\n-                                    -> Block<'blk, 'tcx> {\n+fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n+                                       p_id: ast::NodeId,\n+                                       ident: &ast::Ident,\n+                                       cleanup_scope: cleanup::ScopeId,\n+                                       arg: A,\n+                                       populate: F)\n+                                       -> Block<'blk, 'tcx> where\n+    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+{\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding."}, {"sha": "991333d8f07ddb9a9b4d97b27058641783a2952a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -858,10 +858,13 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     GEPi(bcx, val, &[0, ix])\n }\n \n-pub fn fold_variants<'blk, 'tcx>(\n-        bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, value: ValueRef,\n-        f: |Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef| -> Block<'blk, 'tcx>)\n-        -> Block<'blk, 'tcx> {\n+pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                    r: &Repr<'tcx>,\n+                                    value: ValueRef,\n+                                    mut f: F)\n+                                    -> Block<'blk, 'tcx> where\n+    F: FnMut(Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n+{\n     let fcx = bcx.fcx;\n     match *r {\n         Univariant(ref st, _) => {"}, {"sha": "5170746404e01d0a440c57aa6258e5bc53031f7a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -107,9 +107,11 @@ thread_local!(static TASK_LOCAL_INSN_KEY: RefCell<Option<Vec<&'static str>>> = {\n     RefCell::new(None)\n })\n \n-pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n-    TASK_LOCAL_INSN_KEY.with(|slot| {\n-        slot.borrow().as_ref().map(|s| blk(s.as_slice()));\n+pub fn with_insn_ctxt<F>(blk: F) where\n+    F: FnOnce(&[&'static str]),\n+{\n+    TASK_LOCAL_INSN_KEY.with(move |slot| {\n+        slot.borrow().as_ref().map(move |s| blk(s.as_slice()));\n     })\n }\n \n@@ -841,12 +843,15 @@ pub fn cast_shift_const_rhs(op: ast::BinOp,\n                    |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n-pub fn cast_shift_rhs(op: ast::BinOp,\n-                      lhs: ValueRef,\n-                      rhs: ValueRef,\n-                      trunc: |ValueRef, Type| -> ValueRef,\n-                      zext: |ValueRef, Type| -> ValueRef)\n-                      -> ValueRef {\n+pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n+                            lhs: ValueRef,\n+                            rhs: ValueRef,\n+                            trunc: F,\n+                            zext: G)\n+                            -> ValueRef where\n+    F: FnOnce(ValueRef, Type) -> ValueRef,\n+    G: FnOnce(ValueRef, Type) -> ValueRef,\n+{\n     // Shifts may have any size int on the rhs\n     unsafe {\n         if ast_util::is_shift_binop(op) {\n@@ -1101,10 +1106,12 @@ pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n     common::BlockS::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn with_cond<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             val: ValueRef,\n-                             f: |Block<'blk, 'tcx>| -> Block<'blk, 'tcx>)\n-                             -> Block<'blk, 'tcx> {\n+pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                val: ValueRef,\n+                                f: F)\n+                                -> Block<'blk, 'tcx> where\n+    F: FnOnce(Block<'blk, 'tcx>) -> Block<'blk, 'tcx>,\n+{\n     let _icx = push_ctxt(\"with_cond\");\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");"}, {"sha": "4a6bc58051c57aa9b4132d56b332c0d9c2d2c690", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -342,11 +342,13 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    fn x86_64_ty(ccx: &CrateContext,\n-                 ty: Type,\n-                 is_mem_cls: |cls: &[RegClass]| -> bool,\n-                 ind_attr: Attribute)\n-                 -> ArgType {\n+    fn x86_64_ty<F>(ccx: &CrateContext,\n+                    ty: Type,\n+                    is_mem_cls: F,\n+                    ind_attr: Attribute)\n+                    -> ArgType where\n+        F: FnOnce(&[RegClass]) -> bool,\n+    {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls.as_slice()) {"}, {"sha": "b8b2395dde17229225bbe45ec1dc4a77f24d45a1", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -781,15 +781,15 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n-pub fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                        call_info: Option<NodeInfo>,\n-                                        callee_ty: Ty<'tcx>,\n-                                        get_callee: |bcx: Block<'blk, 'tcx>,\n-                                                     arg_cleanup_scope: cleanup::ScopeId|\n-                                                     -> Callee<'blk, 'tcx>,\n-                                        args: CallArgs<'a, 'tcx>,\n-                                        dest: Option<expr::Dest>)\n-                                        -> Result<'blk, 'tcx> {\n+pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                           call_info: Option<NodeInfo>,\n+                                           callee_ty: Ty<'tcx>,\n+                                           get_callee: F,\n+                                           args: CallArgs<'a, 'tcx>,\n+                                           dest: Option<expr::Dest>)\n+                                           -> Result<'blk, 'tcx> where\n+    F: FnOnce(Block<'blk, 'tcx>, cleanup::ScopeId) -> Callee<'blk, 'tcx>,\n+{\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n     // this cleanup is to ensure that, should a panic occur while"}, {"sha": "2fd6551409e90e734f288039805cd98862820da0", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -527,7 +527,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         self.scopes.borrow_mut().pop().unwrap()\n     }\n \n-    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R {\n+    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R {\n         f(self.scopes.borrow().last().unwrap())\n     }\n \n@@ -1145,5 +1145,5 @@ trait CleanupHelperMethods<'blk, 'tcx> {\n     fn scopes_len(&self) -> uint;\n     fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n     fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n-    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R;\n+    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R;\n }"}, {"sha": "531b22c8fb5f2d221c0757c8d2ad1fe7ea8c3f53", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -113,15 +113,16 @@ pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// it. The memory will be dropped upon exit from `scope`. The callback `populate` should\n /// initialize the memory. If `zero` is true, the space will be zeroed when it is allocated; this\n /// is not necessary unless `bcx` does not dominate the end of `scope`.\n-pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n-                                           ty: Ty<'tcx>,\n-                                           name: &str,\n-                                           zero: bool,\n-                                           scope: cleanup::ScopeId,\n-                                           arg: A,\n-                                           populate: |A, Block<'blk, 'tcx>, ValueRef|\n-                                                      -> Block<'blk, 'tcx>)\n-                                          -> DatumBlock<'blk, 'tcx, Lvalue> {\n+pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n+                                              ty: Ty<'tcx>,\n+                                              name: &str,\n+                                              zero: bool,\n+                                              scope: cleanup::ScopeId,\n+                                              arg: A,\n+                                              populate: F)\n+                                              -> DatumBlock<'blk, 'tcx, Lvalue> where\n+    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n+{\n     let scratch = if zero {\n         alloca_zeroed(bcx, ty, name)\n     } else {\n@@ -339,10 +340,10 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n /// here since we can `match self.kind` rather than having to implement\n /// generic methods in `KindOps`.)\n impl<'tcx> Datum<'tcx, Expr> {\n-    fn match_kind<R>(self,\n-                     if_lvalue: |Datum<'tcx, Lvalue>| -> R,\n-                     if_rvalue: |Datum<'tcx, Rvalue>| -> R)\n-                     -> R {\n+    fn match_kind<R, F, G>(self, if_lvalue: F, if_rvalue: G) -> R where\n+        F: FnOnce(Datum<'tcx, Lvalue>) -> R,\n+        G: FnOnce(Datum<'tcx, Rvalue>) -> R,\n+    {\n         let Datum { val, ty, kind } = self;\n         match kind {\n             LvalueExpr => if_lvalue(Datum::new(val, ty, Lvalue)),\n@@ -455,9 +456,11 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n     // datum may also be unsized _without the size information_. It is the\n     // callers responsibility to package the result in some way to make a valid\n     // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element<'blk>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n-                             gep: |ValueRef| -> ValueRef)\n-                             -> Datum<'tcx, Lvalue> {\n+    pub fn get_element<'blk, F>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n+                                gep: F)\n+                                -> Datum<'tcx, Lvalue> where\n+        F: FnOnce(ValueRef) -> ValueRef,\n+    {\n         let val = match self.ty.sty {\n             _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {"}, {"sha": "de169fc9d62a6f2f67e92beac98b4e73b94e137c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -3212,13 +3212,13 @@ fn populate_scope_map(cx: &CrateContext,\n     });\n \n     // local helper functions for walking the AST.\n-    fn with_new_scope(cx: &CrateContext,\n-                      scope_span: Span,\n-                      scope_stack: &mut Vec<ScopeStackEntry> ,\n-                      scope_map: &mut NodeMap<DIScope>,\n-                      inner_walk: |&CrateContext,\n-                                   &mut Vec<ScopeStackEntry> ,\n-                                   &mut NodeMap<DIScope>|) {\n+    fn with_new_scope<F>(cx: &CrateContext,\n+                         scope_span: Span,\n+                         scope_stack: &mut Vec<ScopeStackEntry> ,\n+                         scope_map: &mut NodeMap<DIScope>,\n+                         inner_walk: F) where\n+        F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n+    {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name.as_slice());"}, {"sha": "e1769001942d586950358355618d518603289fed", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=0676c3bf0315b7cb5dd309435b6c5ead5bf2bc2f", "patch": "@@ -295,6 +295,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // into a type to be destructed. If we want to end up with a Box pointer,\n     // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n     // borrowed reference then it should be T -> &T.\n+    // FIXME(#19596) unbox `mk_ty`\n     fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 kind: &ty::UnsizeKind<'tcx>,\n                                 id: ast::NodeId,\n@@ -341,27 +342,30 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"dest_ty={}\", unsized_ty.repr(bcx.tcx()));\n         // Closures for extracting and manipulating the data and payload parts of\n         // the fat pointer.\n-        let base = match k {\n-            &ty::UnsizeStruct(..) =>\n-                |bcx, val| PointerCast(bcx,\n-                                       val,\n-                                       type_of::type_of(bcx.ccx(), unsized_ty).ptr_to()),\n-            &ty::UnsizeLength(..) =>\n-                |bcx, val| GEPi(bcx, val, &[0u, 0u]),\n-            &ty::UnsizeVtable(..) =>\n-                |_bcx, val| PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n-        };\n-        let info = |bcx, _val| unsized_info(bcx,\n-                                            k,\n-                                            expr.id,\n-                                            datum_ty,\n-                                            |t| ty::mk_rptr(tcx,\n-                                                            ty::ReStatic,\n-                                                            ty::mt{\n-                                                                ty: t,\n-                                                                mutbl: ast::MutImmutable\n-                                                            }));\n-        into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n+        let info = |: bcx, _val| unsized_info(bcx,\n+                                              k,\n+                                              expr.id,\n+                                              datum_ty,\n+                                              |t| ty::mk_rptr(tcx,\n+                                                              ty::ReStatic,\n+                                                              ty::mt{\n+                                                                  ty: t,\n+                                                                  mutbl: ast::MutImmutable\n+                                                              }));\n+        match *k {\n+            ty::UnsizeStruct(..) =>\n+                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n+                    PointerCast(bcx, val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n+                }, info),\n+            ty::UnsizeLength(..) =>\n+                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n+                    GEPi(bcx, val, &[0u, 0u])\n+                }, info),\n+            ty::UnsizeVtable(..) =>\n+                into_fat_ptr(bcx, expr, datum, dest_ty, |_bcx, val| {\n+                    PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n+                }, info),\n+        }\n     }\n \n     fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -370,18 +374,21 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let dest_ty = ty::close_type(tcx, datum.ty);\n-        let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n-        let len = |bcx, val| Load(bcx, get_len(bcx, val));\n+        let base = |: bcx, val| Load(bcx, get_dataptr(bcx, val));\n+        let len = |: bcx, val| Load(bcx, get_len(bcx, val));\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n     }\n \n-    fn into_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                expr: &ast::Expr,\n-                                datum: Datum<'tcx, Expr>,\n-                                dest_ty: Ty<'tcx>,\n-                                base: |Block<'blk, 'tcx>, ValueRef| -> ValueRef,\n-                                info: |Block<'blk, 'tcx>, ValueRef| -> ValueRef)\n-                                -> DatumBlock<'blk, 'tcx, Expr> {\n+    fn into_fat_ptr<'blk, 'tcx, F, G>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr,\n+                                      datum: Datum<'tcx, Expr>,\n+                                      dest_ty: Ty<'tcx>,\n+                                      base: F,\n+                                      info: G)\n+                                      -> DatumBlock<'blk, 'tcx, Expr> where\n+        F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n+        G: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n+    {\n         let mut bcx = bcx;\n \n         // Arrange cleanup\n@@ -659,17 +666,19 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           base: &ast::Expr,\n-                           get_idx: |&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]| -> uint)\n-                           -> DatumBlock<'blk, 'tcx, Expr> {\n+fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                              base: &ast::Expr,\n+                              get_idx: F)\n+                              -> DatumBlock<'blk, 'tcx, Expr> where\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> uint,\n+{\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n     let bare_ty = ty::unopen_type(base_datum.ty);\n     let repr = adt::represent_type(bcx.ccx(), bare_ty);\n-    with_field_tys(bcx.tcx(), bare_ty, None, |discr, field_tys| {\n+    with_field_tys(bcx.tcx(), bare_ty, None, move |discr, field_tys| {\n         let ix = get_idx(bcx.tcx(), field_tys);\n         let d = base_datum.get_element(\n             bcx,\n@@ -1254,11 +1263,13 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Helper for enumerating the field types of structs, enums, or records. The optional node ID here\n /// is the node ID of the path identifying the enum variant in use. If none, this cannot possibly\n /// an enum variant (so, if it is and `node_id_opt` is none, this function panics).\n-pub fn with_field_tys<'tcx, R>(tcx: &ty::ctxt<'tcx>,\n-                               ty: Ty<'tcx>,\n-                               node_id_opt: Option<ast::NodeId>,\n-                               op: |ty::Disr, (&[ty::field<'tcx>])| -> R)\n-                               -> R {\n+pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  node_id_opt: Option<ast::NodeId>,\n+                                  op: F)\n+                                  -> R where\n+    F: FnOnce(ty::Disr, &[ty::field<'tcx>]) -> R,\n+{\n     match ty.sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs).as_slice())"}]}