{"sha": "0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNGFmNzI1N2RkZWE1Y2Y1MDgzMDU2MzVmYmRjNGMwZDFlNmJkZDU=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-04-14T17:40:51Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-04-14T18:11:08Z"}, "message": "PR suggestions and removing utils::parent_node_is_if_expr", "tree": {"sha": "b1b173dfb8ba061c8c5dab7dd060559716737338", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b173dfb8ba061c8c5dab7dd060559716737338"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "html_url": "https://github.com/rust-lang/rust/commit/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2992b19c82c0c5f96327b3be037777bf42862230", "url": "https://api.github.com/repos/rust-lang/rust/commits/2992b19c82c0c5f96327b3be037777bf42862230", "html_url": "https://github.com/rust-lang/rust/commit/2992b19c82c0c5f96327b3be037777bf42862230"}], "stats": {"total": 136, "additions": 40, "deletions": 96}, "files": [{"sha": "42e153909ce75b29f8264d6c4982ec732e2a435b", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, if_sequence, parent_node_is_if_expr, paths, SpanlessEq};\n+use clippy_utils::{get_trait_def_id, if_sequence, is_else_clause, paths, SpanlessEq};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n         }\n \n         // We only care about the top-most `if` in the chain\n-        if parent_node_is_if_expr(expr, cx) {\n+        if is_else_clause(cx.tcx, expr) {\n             return;\n         }\n "}, {"sha": "f956d171bfbe0519e9d222eebd4c581aa39c6c46", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n use clippy_utils::{\n-    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, parent_node_is_if_expr,\n+    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, is_else_clause,\n     run_lints, search_same, ContainsName, SpanlessEq, SpanlessHash,\n };\n use if_chain::if_chain;\n@@ -188,13 +188,18 @@ fn lint_same_then_else<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     // We only lint ifs with multiple blocks\n-    if blocks.len() < 2 || parent_node_is_if_expr(expr, cx) {\n+    if blocks.len() < 2 || is_else_clause(cx.tcx, expr) {\n         return;\n     }\n \n     // Check if each block has shared code\n     let has_expr = blocks[0].expr.is_some();\n-    let (start_eq, mut end_eq, expr_eq) = scan_block_for_eq(cx, blocks);\n+\n+    let (start_eq, mut end_eq, expr_eq) = if let Some(block_eq) = scan_block_for_eq(cx, blocks) {\n+        (block_eq.start_eq, block_eq.end_eq, block_eq.expr_eq)\n+    } else {\n+        return;\n+    };\n \n     // BRANCHES_SHARING_CODE prerequisites\n     if has_conditional_else || (start_eq == 0 && end_eq == 0 && (has_expr && !expr_eq)) {\n@@ -290,15 +295,19 @@ fn lint_same_then_else<'tcx>(\n     }\n }\n \n-/// The return tuple is structured as follows:\n-/// 1. The amount of equal statements from the start\n-/// 2. The amount of equal statements from the end\n-/// 3. An indication if the block expressions are the same. This will also be true if both are\n-/// `None`\n-///\n-/// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `(0, 0,\n-/// false)` to aboard any further processing and avoid duplicate lint triggers.\n-fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize, usize, bool) {\n+struct BlockEqual {\n+    /// The amount statements that are equal from the start\n+    start_eq: usize,\n+    /// The amount statements that are equal from the end\n+    end_eq: usize,\n+    ///  An indication if the block expressions are the same. This will also be true if both are\n+    /// `None`\n+    expr_eq: bool,\n+}\n+\n+/// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `None` to\n+/// abort any further processing and avoid duplicate lint triggers.\n+fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<BlockEqual> {\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n     let mut expr_eq = true;\n@@ -308,7 +317,7 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize,\n \n         // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n         // The comparison therefore needs to be done in a way that builds the correct context.\n-        let mut evaluator = SpanlessEq::new(cx).enable_check_inferred_local_types();\n+        let mut evaluator = SpanlessEq::new(cx);\n         let mut evaluator = evaluator.inter_expr();\n \n         let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));\n@@ -340,7 +349,7 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize,\n                     \"same as this\",\n                 );\n \n-                return (0, 0, false);\n+                return None;\n             }\n         }\n \n@@ -360,7 +369,11 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize,\n         end_eq = min_block_size - start_eq;\n     }\n \n-    (start_eq, end_eq, expr_eq)\n+    Some(BlockEqual {\n+        start_eq,\n+        end_eq,\n+        expr_eq,\n+    })\n }\n \n fn check_for_warn_of_moved_symbol("}, {"sha": "85c95f1151f84b53db10ffdacc68cc98cdd92783", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{is_lang_ctor, meets_msrv, parent_node_is_if_expr};\n+use clippy_utils::{is_else_clause, is_lang_ctor, meets_msrv};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind};\n@@ -68,7 +68,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         // We only care about the top-most `if` in the chain\n-        if parent_node_is_if_expr(expr, cx) {\n+        if is_else_clause(cx.tcx, expr) {\n             return;\n         }\n "}, {"sha": "dd4581986377f54b02e6034a3a1bf23e487af971", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "patch": "@@ -5,7 +5,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{is_expn_of, parent_node_is_if_expr};\n+use clippy_utils::{is_else_clause, is_expn_of};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     snip = snip.make_return();\n                 }\n \n-                if parent_node_is_if_expr(e, cx) {\n+                if is_else_clause(cx.tcx, e) {\n                     snip = snip.blockify()\n                 }\n "}, {"sha": "f0d7f76bea2008af4b12e4c633705c8f52fed3f0", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 44, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "patch": "@@ -1,7 +1,6 @@\n use crate::consts::{constant_context, constant_simple};\n use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n-use if_chain::if_chain;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def::Res;\n@@ -30,30 +29,6 @@ pub struct SpanlessEq<'a, 'tcx> {\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n     allow_side_effects: bool,\n     expr_fallback: Option<Box<dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n-    /// This adds an additional type comparison to locals that insures that even the\n-    /// inferred of the value is the same.\n-    ///\n-    /// **Example**\n-    /// * Context 1\n-    /// ```ignore\n-    /// let vec = Vec::new();\n-    /// vec.push(\"A string\");\n-    /// ```\n-    ///\n-    /// * Context 2\n-    /// ```ignore\n-    /// let vec = Vec::new();\n-    /// vec.push(0); // An integer\n-    /// ```\n-    ///\n-    /// Only comparing the first local definition would usually return that they are\n-    /// equal, since they are identical. However, they are different due to the context\n-    /// as they have different inferred types.\n-    ///\n-    /// This option enables or disables the specific check of the inferred type.\n-    ///\n-    /// Note: This check will only be done if `self.maybe_typeck_results` is `Some()`.\n-    check_inferred_local_types: bool,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n@@ -63,7 +38,6 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             maybe_typeck_results: cx.maybe_typeck_results(),\n             allow_side_effects: true,\n             expr_fallback: None,\n-            check_inferred_local_types: false,\n         }\n     }\n \n@@ -82,13 +56,6 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    pub fn enable_check_inferred_local_types(self) -> Self {\n-        Self {\n-            check_inferred_local_types: true,\n-            ..self\n-        }\n-    }\n-\n     /// Use this method to wrap comparisons that may involve inter-expression context.\n     /// See `self.locals`.\n     pub fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n@@ -129,17 +96,12 @@ impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n-                // See `SpanlessEq::check_inferred_local_types` for an explication of this check\n-                if_chain! {\n-                    if l.ty.is_none() && r.ty.is_none();\n-                    if self.inner.check_inferred_local_types;\n-                    if let Some(tcx) = self.inner.maybe_typeck_results;\n-\n-                    // Check the inferred types\n-                    let l_ty = tcx.pat_ty(&l.pat);\n-                    let r_ty = tcx.pat_ty(&r.pat);\n-                    if l_ty != r_ty;\n-                    then {\n+                // This additional check ensures that the type of the locals are equivalent even if the init\n+                // expression or type have some inferred parts.\n+                if let Some(typeck) = self.inner.maybe_typeck_results {\n+                    let l_ty = typeck.pat_ty(&l.pat);\n+                    let r_ty = typeck.pat_ty(&r.pat);\n+                    if !rustc_middle::ty::TyS::same_type(l_ty, r_ty) {\n                         return false;\n                     }\n                 }"}, {"sha": "c21cef61df4bc8f020b21f04c60ac9664e6f579b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=0b4af7257ddea5cf508305635fbdc4c0d1e6bdd5", "patch": "@@ -1206,37 +1206,6 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     (conds, blocks)\n }\n \n-/// This function returns true if the given expression is the `else` or `if else` part of an if\n-/// statement\n-pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    let parent_id = map.get_parent_node(expr.hir_id);\n-    let parent_node = map.get(parent_id);\n-\n-    // Check for `if`\n-    if_chain! {\n-        if let Node::Expr(expr) = parent_node;\n-        if let ExprKind::If(_, _, _) = expr.kind;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    // Check for `if let`\n-    if_chain! {\n-        if let Node::Arm(arm) = parent_node;\n-        let arm_parent_id = map.get_parent_node(arm.hir_id);\n-        let arm_parent_node = map.get(arm_parent_id);\n-        if let Node::Expr(expr) = arm_parent_node;\n-        if let ExprKind::Match(_, _, MatchSource::IfLetDesugar { .. }) = expr.kind;\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n // Finds the `#[must_use]` attribute, if any\n pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n     attrs.iter().find(|a| a.has_name(sym::must_use))"}]}