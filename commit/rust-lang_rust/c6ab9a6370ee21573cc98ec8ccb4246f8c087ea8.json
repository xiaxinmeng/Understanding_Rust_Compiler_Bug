{"sha": "c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YWI5YTYzNzBlZTIxNTczY2M5OGVjOGNjYjQyNDZmOGMwODdlYTg=", "commit": {"author": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2015-01-11T10:10:04Z"}, "committer": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2015-01-16T07:18:56Z"}, "message": "Don't use NoSend/NoSync in libstd", "tree": {"sha": "5b33a19849a3cb9513c2868808e486c6e2b5cb47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b33a19849a3cb9513c2868808e486c6e2b5cb47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "html_url": "https://github.com/rust-lang/rust/commit/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/comments", "author": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb04121138b636f6aa43e10fa38629043a0f0f48", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb04121138b636f6aa43e10fa38629043a0f0f48", "html_url": "https://github.com/rust-lang/rust/commit/bb04121138b636f6aa43e10fa38629043a0f0f48"}], "stats": {"total": 163, "additions": 163, "deletions": 0}, "files": [{"sha": "182344452a484580154d250f765c6a9e50fc19c0", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "patch": "@@ -110,6 +110,7 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n+#![feature(optin_builtin_traits)]\n #![allow(unknown_features)] #![feature(int_uint)]\n \n // Don't link to std. We are std."}, {"sha": "17e690e9540925e323a6b52b0d34d99e197e2f96", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "patch": "@@ -14,6 +14,7 @@ use thread::Thread;\n use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n+#[cfg(stage0)] // NOTE remove use after next snapshot\n use marker::{NoSend, NoSync};\n use mem;\n use clone::Clone;\n@@ -31,12 +32,25 @@ pub struct SignalToken {\n     inner: Arc<Inner>,\n }\n \n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct WaitToken {\n     inner: Arc<Inner>,\n     no_send: NoSend,\n     no_sync: NoSync,\n }\n \n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct WaitToken {\n+    inner: Arc<Inner>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl !Send for WaitToken {}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl !Sync for WaitToken {}\n+\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),\n@@ -53,6 +67,21 @@ pub fn tokens() -> (WaitToken, SignalToken) {\n     (wait_token, signal_token)\n }\n \n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub fn tokens() -> (WaitToken, SignalToken) {\n+    let inner = Arc::new(Inner {\n+        thread: Thread::current(),\n+        woken: ATOMIC_BOOL_INIT,\n+    });\n+    let wait_token = WaitToken {\n+        inner: inner.clone(),\n+    };\n+    let signal_token = SignalToken {\n+        inner: inner\n+    };\n+    (wait_token, signal_token)\n+}\n+\n impl SignalToken {\n     pub fn signal(&self) -> bool {\n         let wake = !self.inner.woken.compare_and_swap(false, true, Ordering::SeqCst);"}, {"sha": "0ba19b706176b8f0beb25e87d4f63c8a244bc851", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "patch": "@@ -370,12 +370,24 @@ unsafe impl<T:Send> Send for Sender<T> { }\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n \n+/// The sending-half of Rust's synchronous channel type. This half can only be\n+/// owned by one task, but it can be cloned to send to other tasks.\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct SyncSender<T> {\n+    inner: Arc<RacyCell<sync::Packet<T>>>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<T> !marker::Sync for SyncSender<T> {}\n+\n /// An error returned from the `send` function on channels.\n ///\n /// A `send` operation can only fail if the receiving end of a channel is\n@@ -677,10 +689,16 @@ impl<T: Send> Drop for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> SyncSender<T> {\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner, _marker: marker::NoSync }\n     }\n \n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n+        SyncSender { inner: inner }\n+    }\n+\n     /// Sends a value on this synchronous channel.\n     ///\n     /// This function will *block* until space in the internal buffer becomes"}, {"sha": "62a7b823ec8acd5e9df8af58cd441a084c1699ac", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "patch": "@@ -66,13 +66,26 @@ use sync::mpsc::blocking::{self, SignalToken};\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Select {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n     next_id: Cell<uint>,\n     marker1: marker::NoSend,\n }\n \n+/// The \"receiver set\" of the select interface. This structure is used to manage\n+/// a set of receivers which are being selected over.\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct Select {\n+    head: *mut Handle<'static, ()>,\n+    tail: *mut Handle<'static, ()>,\n+    next_id: Cell<uint>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl !marker::Send for Select {}\n+\n /// A handle to a receiver which is currently a member of a `Select` set of\n /// receivers.  This handle is used to keep the receiver in the set as well as\n /// interact with the underlying receiver.\n@@ -113,6 +126,7 @@ impl Select {\n     ///\n     /// Usage of this struct directly can sometimes be burdensome, and usage is\n     /// rather much easier through the `select!` macro.\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     pub fn new() -> Select {\n         Select {\n             marker1: marker::NoSend,\n@@ -122,6 +136,20 @@ impl Select {\n         }\n     }\n \n+    /// Creates a new selection structure. This set is initially empty and\n+    /// `wait` will panic!() if called.\n+    ///\n+    /// Usage of this struct directly can sometimes be burdensome, and usage is\n+    /// rather much easier through the `select!` macro.\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    pub fn new() -> Select {\n+        Select {\n+            head: 0 as *mut Handle<'static, ()>,\n+            tail: 0 as *mut Handle<'static, ()>,\n+            next_id: Cell::new(1),\n+        }\n+    }\n+\n     /// Creates a new handle into this receiver set for a new receiver. Note\n     /// that this does *not* add the receiver to the receiver set, for that you\n     /// must call the `add` method on the handle itself."}, {"sha": "73d5332d16fe4f02dd4ea48a947b9121bf8d1ee4", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "patch": "@@ -160,6 +160,7 @@ unsafe impl Sync for StaticMutex {}\n /// Deref and DerefMut implementations\n #[must_use]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n@@ -169,6 +170,25 @@ pub struct MutexGuard<'a, T: 'a> {\n     __marker: marker::NoSend,\n }\n \n+/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n+/// dropped (falls out of scope), the lock will be unlocked.\n+///\n+/// The data protected by the mutex can be access through this guard via its\n+/// Deref and DerefMut implementations\n+#[must_use]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct MutexGuard<'a, T: 'a> {\n+    // funny underscores due to how Deref/DerefMut currently work (they\n+    // disregard field privacy).\n+    __lock: &'a StaticMutex,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n+\n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n #[unstable = \"may be merged with Mutex in the future\"]\n@@ -279,6 +299,7 @@ impl StaticMutex {\n }\n \n impl<'mutex, T> MutexGuard<'mutex, T> {\n+    #[cfg(stage0)] // NOTE remove afte next snapshot\n     fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -290,6 +311,18 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n             }\n         })\n     }\n+\n+    #[cfg(not(stage0))] // NOTE remove cfg afte next snapshot\n+    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n+           -> LockResult<MutexGuard<'mutex, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            MutexGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+            }\n+        })\n+    }\n }\n \n #[stable]"}, {"sha": "237f6d08a9541885314e25706655aebf614f760b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=c6ab9a6370ee21573cc98ec8ccb4246f8c087ea8", "patch": "@@ -110,23 +110,52 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// dropped.\n #[must_use]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __marker: marker::NoSend,\n }\n \n+/// RAII structure used to release the shared read access of a lock when\n+/// dropped.\n+#[must_use]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct RwLockReadGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n+    __data: &'a UnsafeCell<T>,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n+\n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n #[stable]\n+#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n     __marker: marker::NoSend,\n }\n \n+/// RAII structure used to release the exclusive write access of a lock when\n+/// dropped.\n+#[must_use]\n+#[stable]\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+pub struct RwLockWriteGuard<'a, T: 'a> {\n+    __lock: &'a StaticRwLock,\n+    __data: &'a UnsafeCell<T>,\n+    __poison: poison::Guard,\n+}\n+\n+#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n+\n impl<T: Send + Sync> RwLock<T> {\n     /// Creates a new instance of an RwLock which is unlocked and read to go.\n     #[stable]\n@@ -303,6 +332,7 @@ impl StaticRwLock {\n }\n \n impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n@@ -313,8 +343,20 @@ impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n             }\n         })\n     }\n+\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |_| {\n+            RwLockReadGuard {\n+                __lock: lock,\n+                __data: data,\n+            }\n+        })\n+    }\n }\n impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n+    #[cfg(stage0)] // NOTE remove impl after next snapshot\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -326,6 +368,18 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n             }\n         })\n     }\n+\n+    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n+    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n+        poison::map_result(lock.poison.borrow(), |guard| {\n+            RwLockWriteGuard {\n+                __lock: lock,\n+                __data: data,\n+                __poison: guard,\n+            }\n+        })\n+    }\n }\n \n #[stable]"}]}