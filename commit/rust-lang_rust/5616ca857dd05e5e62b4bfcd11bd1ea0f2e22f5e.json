{"sha": "5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MTZjYTg1N2RkMDVlNWU2MmI0YmZjZDExYmQxZWEwZjJlMjJmNWU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-09T14:30:10Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: uniformize ty::print's error handling by requiring Result.", "tree": {"sha": "bc27aad1498276b5f667407e894b10bec4c6cafd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc27aad1498276b5f667407e894b10bec4c6cafd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "html_url": "https://github.com/rust-lang/rust/commit/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "972af5e808eb76b449e7af6ee087bb611c722326", "url": "https://api.github.com/repos/rust-lang/rust/commits/972af5e808eb76b449e7af6ee087bb611c722326", "html_url": "https://github.com/rust-lang/rust/commit/972af5e808eb76b449e7af6ee087bb611c722326"}], "stats": {"total": 199, "additions": 114, "deletions": 85}, "files": [{"sha": "b777b0dc9f37f44617086987c4ecb8b57a4becd9", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "patch": "@@ -454,9 +454,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         struct NonTrivialPath;\n \n         impl Printer for AbsolutePathPrinter {\n-            type Path = Result<Vec<String>, NonTrivialPath>;\n+            type Error = NonTrivialPath;\n \n-            fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+            type Path = Vec<String>;\n+\n+            fn path_crate(\n+                self: &mut PrintCx<'_, '_, '_, Self>,\n+                cnum: CrateNum,\n+            ) -> Result<Self::Path, Self::Error> {\n                 Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n             }\n             fn path_qualified<'tcx>(\n@@ -465,15 +470,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 _self_ty: Ty<'tcx>,\n                 _trait_ref: Option<ty::TraitRef<'tcx>>,\n                 _ns: Namespace,\n-            ) -> Self::Path {\n+            ) -> Result<Self::Path, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n             fn path_append(\n                 self: &mut PrintCx<'_, '_, '_, Self>,\n-                path: Self::Path,\n+                mut path: Self::Path,\n                 text: &str,\n-            ) -> Self::Path {\n-                let mut path = path?;\n+            ) -> Result<Self::Path, Self::Error> {\n                 path.push(text.to_string());\n                 Ok(path)\n             }\n@@ -484,8 +488,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 _substs: SubstsRef<'tcx>,\n                 _ns: Namespace,\n                 _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-            ) -> Self::Path {\n-                path\n+            ) -> Result<Self::Path, Self::Error> {\n+                Ok(path)\n             }\n         }\n "}, {"sha": "f179619b5f83cea6bc00dfe9dfdfc0a8f78dc532", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "patch": "@@ -109,16 +109,20 @@ impl<P> PrintCx<'a, 'gcx, 'tcx, P> {\n \n pub trait Print<'tcx, P> {\n     type Output;\n+    type Error;\n \n-    fn print(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output;\n-    fn print_display(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output {\n+    fn print(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error>;\n+    fn print_display(\n+        &self,\n+        cx: &mut PrintCx<'_, '_, 'tcx, P>,\n+    ) -> Result<Self::Output, Self::Error> {\n         let old_debug = cx.is_debug;\n         cx.is_debug = false;\n         let result = self.print(cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_debug(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Self::Output {\n+    fn print_debug(&self, cx: &mut PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n         let old_debug = cx.is_debug;\n         cx.is_debug = true;\n         let result = self.print(cx);\n@@ -128,55 +132,54 @@ pub trait Print<'tcx, P> {\n }\n \n pub trait Printer: Sized {\n+    type Error;\n+\n     type Path;\n \n-    #[must_use]\n     fn print_def_path(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Self::Path {\n+    ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs, ns, projections)\n     }\n-    #[must_use]\n     fn print_impl_path(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n         impl_def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Self::Path {\n+    ) -> Result<Self::Path, Self::Error> {\n         self.default_print_impl_path(impl_def_id, substs, ns, self_ty, trait_ref)\n     }\n \n-    #[must_use]\n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path;\n-    #[must_use]\n+    fn path_crate(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error>;\n     fn path_qualified(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n         impl_prefix: Option<Self::Path>,\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n-    ) -> Self::Path;\n-    #[must_use]\n+    ) -> Result<Self::Path, Self::Error>;\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n         path: Self::Path,\n         text: &str,\n-    ) -> Self::Path;\n-    #[must_use]\n+    ) -> Result<Self::Path, Self::Error>;\n     fn path_generic_args(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n         path: Self::Path,\n         params: &[ty::GenericParamDef],\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Self::Path;\n+    ) -> Result<Self::Path, Self::Error>;\n }\n \n #[must_use]\n@@ -185,7 +188,7 @@ pub struct PrettyPath {\n }\n \n /// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter: Printer<Path = Result<PrettyPath, fmt::Error>> + fmt::Write {}\n+pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = PrettyPath> + fmt::Write {}\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n@@ -225,7 +228,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> P::Path {\n+    ) -> Result<P::Path, P::Error> {\n         debug!(\"default_print_def_path: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n         let key = self.tcx.def_key(def_id);\n         debug!(\"default_print_def_path: key={:?}\", key);\n@@ -263,12 +266,12 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                         parent_generics.has_self && parent_generics.parent_count == 0;\n                     if let (Some(substs), true) = (substs, parent_has_own_self) {\n                         let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n-                        self.path_qualified(None, trait_ref.self_ty(), Some(trait_ref), ns)\n+                        self.path_qualified(None, trait_ref.self_ty(), Some(trait_ref), ns)?\n                     } else {\n-                        self.print_def_path(parent_def_id, substs, ns, iter::empty())\n+                        self.print_def_path(parent_def_id, substs, ns, iter::empty())?\n                     }\n                 } else {\n-                    self.print_def_path(parent_def_id, None, ns, iter::empty())\n+                    self.print_def_path(parent_def_id, None, ns, iter::empty())?\n                 };\n                 let path = match key.disambiguated_data.data {\n                     // Skip `::{{constructor}}` on tuple/unit structs.\n@@ -278,7 +281,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                         self.path_append(\n                             path,\n                             &key.disambiguated_data.data.as_interned_str().as_str(),\n-                        )\n+                        )?\n                     }\n                 };\n \n@@ -287,7 +290,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n                     let params = &generics.params[has_own_self as usize..];\n                     self.path_generic_args(path, params, substs, ns, projections)\n                 } else {\n-                    path\n+                    Ok(path)\n                 }\n             }\n         }\n@@ -300,7 +303,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n         ns: Namespace,\n         self_ty: Ty<'tcx>,\n         impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> P::Path {\n+    ) -> Result<P::Path, P::Error> {\n         debug!(\"default_print_impl_path: impl_def_id={:?}, self_ty={}, impl_trait_ref={:?}\",\n                impl_def_id, self_ty, impl_trait_ref);\n \n@@ -323,7 +326,7 @@ impl<P: Printer> PrintCx<'a, 'gcx, 'tcx, P> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            Some(self.print_def_path(parent_def_id, None, ns, iter::empty()))\n+            Some(self.print_def_path(parent_def_id, None, ns, iter::empty())?)\n         } else {\n             // Otherwise, try to give a good form that would be valid language\n             // syntax. Preferably using associated item notation.\n@@ -390,7 +393,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n     /// If possible, this returns a global path resolving to `def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    fn try_print_visible_def_path(&mut self, def_id: DefId) -> Option<P::Path> {\n+    fn try_print_visible_def_path(&mut self, def_id: DefId) -> Result<Option<P::Path>, P::Error> {\n         debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n \n         // If `def_id` is a direct or injected extern crate, return the\n@@ -399,7 +402,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             let cnum = def_id.krate;\n \n             if cnum == LOCAL_CRATE {\n-                return Some(self.path_crate(cnum));\n+                return Ok(Some(self.path_crate(cnum)?));\n             }\n \n             // In local mode, when we encounter a crate other than\n@@ -421,21 +424,21 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n                 }) => {\n                     debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n                     let path = if !span.is_dummy() {\n-                        self.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())\n+                        self.print_def_path(def_id, None, Namespace::TypeNS, iter::empty())?\n                     } else {\n-                        self.path_crate(cnum)\n+                        self.path_crate(cnum)?\n                     };\n-                    return Some(path);\n+                    return Ok(Some(path));\n                 }\n                 None => {\n-                    return Some(self.path_crate(cnum));\n+                    return Ok(Some(self.path_crate(cnum)?));\n                 }\n                 _ => {},\n             }\n         }\n \n         if def_id.is_local() {\n-            return None;\n+            return Ok(None);\n         }\n \n         let visible_parent_map = self.tcx.visible_parent_map(LOCAL_CRATE);\n@@ -453,8 +456,14 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             cur_def_key = self.tcx.def_key(parent);\n         }\n \n-        let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n-        let path = self.try_print_visible_def_path(visible_parent)?;\n+        let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n+            Some(parent) => parent,\n+            None => return Ok(None),\n+        };\n+        let path = match self.try_print_visible_def_path(visible_parent)? {\n+            Some(path) => path,\n+            None => return Ok(None),\n+        };\n         let actual_parent = self.tcx.parent(def_id);\n \n         let data = cur_def_key.disambiguated_data.data;\n@@ -515,7 +524,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             },\n         };\n         debug!(\"try_print_visible_def_path: symbol={:?}\", symbol);\n-        Some(self.path_append(path, &symbol))\n+        Ok(Some(self.path_append(path, &symbol)?))\n     }\n \n     pub fn pretty_path_qualified(\n@@ -524,7 +533,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n-    ) -> P::Path {\n+    ) -> Result<P::Path, P::Error> {\n         if let Some(prefix) = impl_prefix {\n             // HACK(eddyb) going through `path_append` means symbol name\n             // computation gets to handle its equivalent of `::` correctly.\n@@ -582,9 +591,7 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> P::Path {\n-        let path = path?;\n-\n+    ) -> Result<P::Path, P::Error> {\n         let mut empty = true;\n         let mut start_or_continue = |cx: &mut Self, start: &str, cont: &str| {\n             if empty {\n@@ -671,28 +678,30 @@ impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n }\n \n impl<F: fmt::Write> Printer for FmtPrinter<F> {\n-    type Path = Result<PrettyPath, fmt::Error>;\n+    type Error = fmt::Error;\n+\n+    type Path = PrettyPath;\n \n     fn print_def_path(\n         self: &mut PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Self::Path {\n+    ) -> Result<Self::Path, Self::Error> {\n         // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n         // both here and in `default_print_def_path`.\n         let generics = substs.map(|_| self.tcx.generics_of(def_id));\n         if generics.as_ref().and_then(|g| g.parent).is_none() {\n-            if let Some(path) = self.try_print_visible_def_path(def_id) {\n+            if let Some(path) = self.try_print_visible_def_path(def_id)? {\n                 let path = if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let has_own_self = generics.has_self && generics.parent_count == 0;\n                     let params = &generics.params[has_own_self as usize..];\n-                    self.path_generic_args(path, params, substs, ns, projections)\n+                    self.path_generic_args(path, params, substs, ns, projections)?\n                 } else {\n                     path\n                 };\n-                return path;\n+                return Ok(path);\n             }\n         }\n \n@@ -712,7 +721,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n                 // pretty printing some span information. This should\n                 // only occur very early in the compiler pipeline.\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let path = self.print_def_path(parent_def_id, None, ns, iter::empty());\n+                let path = self.print_def_path(parent_def_id, None, ns, iter::empty())?;\n                 let span = self.tcx.def_span(def_id);\n                 return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n             }\n@@ -721,7 +730,10 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self.default_print_def_path(def_id, substs, ns, projections)\n     }\n \n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+    fn path_crate(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n         if cnum == LOCAL_CRATE {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n@@ -742,16 +754,14 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n-    ) -> Self::Path {\n+    ) -> Result<Self::Path, Self::Error> {\n         self.pretty_path_qualified(impl_prefix, self_ty, trait_ref, ns)\n     }\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n         path: Self::Path,\n         text: &str,\n-    ) -> Self::Path {\n-        let path = path?;\n-\n+    ) -> Result<Self::Path, Self::Error> {\n         // FIXME(eddyb) this shouldn't happen, but is currently\n         // the case for `extern { ... }` \"foreign modules\".\n         if text.is_empty() {\n@@ -771,7 +781,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Self::Path {\n+    ) -> Result<Self::Path, Self::Error> {\n         self.pretty_path_generic_args(path, params, substs, ns, projections)\n     }\n }"}, {"sha": "d0d51e7f38c147741771ef4e4c92dee4767d0097", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "patch": "@@ -193,7 +193,8 @@ macro_rules! gen_display_debug {\n macro_rules! gen_print_impl {\n     ( ($($x:tt)+) $target:ty, ($self:ident, $cx:ident) $disp:block $dbg:block ) => {\n         impl<$($x)+, P: PrettyPrinter> Print<'tcx, P> for $target {\n-            type Output = fmt::Result;\n+            type Output = ();\n+            type Error = fmt::Error;\n             fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n                 define_scoped_cx!($cx);\n                 if $cx.is_debug $dbg\n@@ -203,7 +204,8 @@ macro_rules! gen_print_impl {\n     };\n     ( () $target:ty, ($self:ident, $cx:ident) $disp:block $dbg:block ) => {\n         impl<P: PrettyPrinter> Print<'tcx, P> for $target {\n-            type Output = fmt::Result;\n+            type Output = ();\n+            type Error = fmt::Error;\n             fn print(&$self, $cx: &mut PrintCx<'_, '_, 'tcx, P>) -> fmt::Result {\n                 define_scoped_cx!($cx);\n                 if $cx.is_debug $dbg\n@@ -298,8 +300,8 @@ impl<P: PrettyPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         Ok(())\n     }\n \n-    fn in_binder<T>(&mut self, value: &ty::Binder<T>) -> fmt::Result\n-        where T: Print<'tcx, P, Output = fmt::Result> + TypeFoldable<'tcx>\n+    fn in_binder<T>(&mut self, value: &ty::Binder<T>) -> Result<T::Output, fmt::Error>\n+        where T: Print<'tcx, P, Error = fmt::Error> + TypeFoldable<'tcx>\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n             match index {"}, {"sha": "c73c5950c0da515fcdea6cf584e5614eb7fad73f", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "patch": "@@ -404,9 +404,14 @@ impl SymbolPath {\n // symbol names should have their own printing machinery.\n \n impl Printer for SymbolPath {\n-    type Path = Result<PrettyPath, fmt::Error>;\n+    type Error = fmt::Error;\n \n-    fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n+    type Path = PrettyPath;\n+\n+    fn path_crate(\n+        self: &mut PrintCx<'_, '_, '_, Self>,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n         self.printer.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n         Ok(PrettyPath { empty: false })\n     }\n@@ -416,7 +421,7 @@ impl Printer for SymbolPath {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n         ns: Namespace,\n-    ) -> Self::Path {\n+    ) -> Result<Self::Path, Self::Error> {\n         // HACK(eddyb) avoid `keep_within_component` for the cases\n         // that print without `<...>` around `self_ty`.\n         match self_ty.sty {\n@@ -432,14 +437,17 @@ impl Printer for SymbolPath {\n \n         // HACK(eddyb) make sure to finalize the last component of the\n         // `impl` prefix, to avoid it fusing with the following text.\n-        let impl_prefix = impl_prefix.map(|prefix| {\n-            let mut prefix = self.path_append(prefix, \"\")?;\n+        let impl_prefix = match impl_prefix {\n+            Some(prefix) => {\n+                let mut prefix = self.path_append(prefix, \"\")?;\n \n-            // HACK(eddyb) also avoid an unnecessary `::`.\n-            prefix.empty = true;\n+                // HACK(eddyb) also avoid an unnecessary `::`.\n+                prefix.empty = true;\n \n-            Ok(prefix)\n-        });\n+                Some(prefix)\n+            }\n+            None => None,\n+        };\n \n         let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n         let r = self.pretty_path_qualified(impl_prefix, self_ty, trait_ref, ns);\n@@ -448,11 +456,9 @@ impl Printer for SymbolPath {\n     }\n     fn path_append(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n-        path: Self::Path,\n+        mut path: Self::Path,\n         text: &str,\n-    ) -> Self::Path {\n-        let mut path = path?;\n-\n+    ) -> Result<Self::Path, Self::Error> {\n         if self.keep_within_component {\n             // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n             if !path.empty {\n@@ -475,7 +481,7 @@ impl Printer for SymbolPath {\n         substs: SubstsRef<'tcx>,\n         ns: Namespace,\n         projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Self::Path {\n+    )  -> Result<Self::Path, Self::Error> {\n         let kept_within_component = mem::replace(&mut self.printer.keep_within_component, true);\n         let r = self.pretty_path_generic_args(path, params, substs, ns, projections);\n         self.printer.keep_within_component = kept_within_component;"}, {"sha": "2a8db6455bf228717af2b95fd3980b9c04712a45", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "patch": "@@ -4230,18 +4230,23 @@ where F: Fn(DefId) -> Def {\n     struct AbsolutePathPrinter;\n \n     impl Printer for AbsolutePathPrinter {\n+        type Error = !;\n+\n         type Path = Vec<String>;\n \n-        fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {\n-            vec![self.tcx.original_crate_name(cnum).to_string()]\n+        fn path_crate(\n+            self: &mut PrintCx<'_, '_, '_, Self>,\n+            cnum: CrateNum,\n+        ) -> Result<Self::Path, Self::Error> {\n+            Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n         }\n         fn path_qualified(\n             self: &mut PrintCx<'_, '_, 'tcx, Self>,\n             impl_prefix: Option<Self::Path>,\n             self_ty: Ty<'tcx>,\n             trait_ref: Option<ty::TraitRef<'tcx>>,\n             _ns: Namespace,\n-        ) -> Self::Path {\n+        ) -> Result<Self::Path, Self::Error> {\n             let mut path = impl_prefix.unwrap_or(vec![]);\n \n             // This shouldn't ever be needed, but just in case:\n@@ -4251,15 +4256,15 @@ where F: Fn(DefId) -> Def {\n                 path.push(format!(\"<{}>\", self_ty));\n             }\n \n-            path\n+            Ok(path)\n         }\n         fn path_append(\n             self: &mut PrintCx<'_, '_, '_, Self>,\n             mut path: Self::Path,\n             text: &str,\n-        ) -> Self::Path {\n+        ) -> Result<Self::Path, Self::Error> {\n             path.push(text.to_string());\n-            path\n+            Ok(path)\n         }\n         fn path_generic_args(\n             self: &mut PrintCx<'_, '_, 'tcx, Self>,\n@@ -4268,13 +4273,14 @@ where F: Fn(DefId) -> Def {\n             _substs: SubstsRef<'tcx>,\n             _ns: Namespace,\n             _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-        ) -> Self::Path {\n-            path\n+        ) -> Result<Self::Path, Self::Error> {\n+            Ok(path)\n         }\n     }\n \n     let names = PrintCx::new(tcx, AbsolutePathPrinter)\n-        .print_def_path(def_id, None, Namespace::TypeNS, iter::empty());\n+        .print_def_path(def_id, None, Namespace::TypeNS, iter::empty())\n+        .unwrap();\n \n     hir::Path {\n         span: DUMMY_SP,"}, {"sha": "fccf5a67ad46564fede5025f5925e3fc836968aa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5616ca857dd05e5e62b4bfcd11bd1ea0f2e22f5e", "patch": "@@ -18,6 +18,7 @@\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(inner_deref)]\n+#![feature(never_type)]\n \n #![recursion_limit=\"256\"]\n "}]}