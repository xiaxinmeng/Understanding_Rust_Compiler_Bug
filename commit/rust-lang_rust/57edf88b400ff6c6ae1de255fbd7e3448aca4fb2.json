{"sha": "57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZWRmODhiNDAwZmY2YzZhZTFkZTI1NWZiZDdlMzQ0OGFjYTRmYjI=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-27T10:09:22Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-09-01T13:05:56Z"}, "message": "Replace some trivial struct_span_err!s in typeck.", "tree": {"sha": "045701e9634422d42f22a6d26ce789bc38f01adf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/045701e9634422d42f22a6d26ce789bc38f01adf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "html_url": "https://github.com/rust-lang/rust/commit/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93eaf15646e980a5e578eb58f295b9a066b7560f", "url": "https://api.github.com/repos/rust-lang/rust/commits/93eaf15646e980a5e578eb58f295b9a066b7560f", "html_url": "https://github.com/rust-lang/rust/commit/93eaf15646e980a5e578eb58f295b9a066b7560f"}], "stats": {"total": 448, "additions": 254, "deletions": 194}, "files": [{"sha": "e3ba0bea7e8e29106cf3169c8fb52a163aaa178c", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -11,6 +11,7 @@ doctest = false\n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n tracing = \"0.1\"\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "a434406c284ac09b5307d980bb31c2759177c12c", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -1,6 +1,7 @@\n use crate::astconv::{\n     AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n };\n+use crate::errors::AssocTypeBindingNotAllowed;\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n@@ -544,13 +545,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Emits an error regarding forbidden type binding associations\n     pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0229,\n-            \"associated type bindings are not allowed here\"\n-        );\n-        err.span_label(span, \"associated type not allowed here\").emit();\n+        tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n     }\n \n     /// Prohibits explicit lifetime arguments if late-bound lifetime parameters"}, {"sha": "8a9fe687ae7212564b9ba671427f109674b1a12f", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -7,6 +7,10 @@ mod generics;\n \n use crate::bounds::Bounds;\n use crate::collect::PlaceholderHirTyCollector;\n+use crate::errors::{\n+    AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n+    TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n+};\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n@@ -684,14 +688,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if unbound.is_none() {\n                     unbound = Some(&ptr.trait_ref);\n                 } else {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0203,\n-                        \"type parameter has more than one relaxed default \\\n-                        bound, only one is supported\"\n-                    )\n-                    .emit();\n+                    tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n                 }\n             }\n         }\n@@ -927,18 +924,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             dup_bindings\n                 .entry(assoc_ty.def_id)\n                 .and_modify(|prev_span| {\n-                    struct_span_err!(\n-                        self.tcx().sess,\n-                        binding.span,\n-                        E0719,\n-                        \"the value of the associated type `{}` (from trait `{}`) \\\n-                         is already specified\",\n-                        binding.item_name,\n-                        tcx.def_path_str(assoc_ty.container.id())\n-                    )\n-                    .span_label(binding.span, \"re-bound here\")\n-                    .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n-                    .emit();\n+                    self.tcx().sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n+                        span: binding.span,\n+                        prev_span: *prev_span,\n+                        item_name: binding.item_name,\n+                        def_path: tcx.def_path_str(assoc_ty.container.id()),\n+                    });\n                 })\n                 .or_insert(binding.span);\n         }\n@@ -1051,13 +1042,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         if regular_traits.is_empty() && auto_traits.is_empty() {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0224,\n-                \"at least one trait is required for an object type\"\n-            )\n-            .emit();\n+            tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span });\n             return tcx.ty_error();\n         }\n \n@@ -2059,15 +2044,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyKind::Typeof(ref _e) => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    ast_ty.span,\n-                    E0516,\n-                    \"`typeof` is a reserved keyword but unimplemented\"\n-                )\n-                .span_label(ast_ty.span, \"reserved keyword\")\n-                .emit();\n-\n+                tcx.sess.emit_err(TypeofReservedKeywordUsed { span: ast_ty.span });\n                 tcx.ty_error()\n             }\n             hir::TyKind::Infer => {\n@@ -2283,13 +2260,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // error.\n         let r = derived_region_bounds[0];\n         if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0227,\n-                \"ambiguous lifetime bound, explicit lifetime bound required\"\n-            )\n-            .emit();\n+            tcx.sess.emit_err(AmbiguousLifetimeBound { span });\n         }\n         Some(r)\n     }"}, {"sha": "bbf5153d35d9b361b2e23ad539fc40fec8b106bf", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -366,24 +367,18 @@ fn check_region_bounds_on_impl_item<'tcx>(\n         let item_kind = assoc_item_kind_str(impl_m);\n         let def_span = tcx.sess.source_map().guess_head_span(span);\n         let span = tcx.hir().get_generics(impl_m.def_id).map(|g| g.span).unwrap_or(def_span);\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n+        let generics_span = if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n+            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n+            Some(tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp))\n+        } else {\n+            None\n+        };\n+        tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {\n             span,\n-            E0195,\n-            \"lifetime parameters or bounds on {} `{}` do not match the trait declaration\",\n             item_kind,\n-            impl_m.ident,\n-        );\n-        err.span_label(span, &format!(\"lifetimes do not match {} in trait\", item_kind));\n-        if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n-            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n-            let sp = tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp);\n-            err.span_label(\n-                sp,\n-                &format!(\"lifetimes in impl do not match this {} in trait\", item_kind),\n-            );\n-        }\n-        err.emit();\n+            ident: impl_m.ident,\n+            generics_span,\n+        });\n         return Err(ErrorReported);\n     }\n "}, {"sha": "ce3cdd6ff6be5f7e1f5f7a947a6cdffabf0433f1", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -14,8 +14,13 @@ use crate::check::Expectation::{self, ExpectCastableToType, ExpectHasType, NoExp\n use crate::check::FnCtxt;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n+use crate::errors::{\n+    FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct,\n+    YieldExprOutsideOfGenerator,\n+};\n use crate::type_error_struct;\n \n+use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n@@ -439,14 +444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n         });\n         if !is_named {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                oprnd.span,\n-                E0745,\n-                \"cannot take address of a temporary\"\n-            )\n-            .span_label(oprnd.span, \"temporary value\")\n-            .emit();\n+            self.tcx.sess.emit_err(AddressOfTemporaryTaken { span: oprnd.span })\n         }\n     }\n \n@@ -665,13 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                expr.span,\n-                E0572,\n-                \"return statement outside of function body\",\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n         } else if let Some(ref e) = expr_opt {\n             if self.ret_coercion_span.borrow().is_none() {\n                 *self.ret_coercion_span.borrow_mut() = Some(e.span);\n@@ -740,6 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_span: &Span,\n     ) {\n         if !lhs.is_syntactic_place_expr() {\n+            // FIXME: Make this use SessionDiagnostic once error codes can be dynamically set.\n             let mut err = self.tcx.sess.struct_span_err_with_code(\n                 *expr_span,\n                 \"invalid left-hand side of assignment\",\n@@ -1120,14 +1113,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Prohibit struct expressions when non-exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n         if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                expr.span,\n-                E0639,\n-                \"cannot create non-exhaustive {} using struct expression\",\n-                adt.variant_descr()\n-            )\n-            .emit();\n+            self.tcx\n+                .sess\n+                .emit_err(StructExprNonExhaustive { span: expr.span, what: adt.variant_descr() });\n         }\n \n         let error_happened = self.check_expr_struct_fields(\n@@ -1165,13 +1153,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .insert(expr.hir_id, fru_field_types);\n                     }\n                     _ => {\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            base_expr.span,\n-                            E0436,\n-                            \"functional record update syntax requires a struct\"\n-                        )\n-                        .emit();\n+                        self.tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n                     }\n                 }\n             }\n@@ -1234,18 +1218,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 error_happened = true;\n                 if let Some(prev_span) = seen_fields.get(&ident) {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        field.ident.span,\n-                        E0062,\n-                        \"field `{}` specified more than once\",\n-                        ident\n-                    );\n-\n-                    err.span_label(field.ident.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n-\n-                    err.emit();\n+                    tcx.sess.emit_err(FieldMultiplySpecifiedInInitializer {\n+                        span: field.ident.span,\n+                        prev_span: *prev_span,\n+                        ident,\n+                    });\n                 } else {\n                     self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name, span);\n                 }\n@@ -1876,13 +1853,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx.mk_unit()\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    expr.span,\n-                    E0627,\n-                    \"yield expression outside of generator literal\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(YieldExprOutsideOfGenerator { span: expr.span });\n                 self.tcx.mk_unit()\n             }\n         }"}, {"sha": "b8230f524446a6d33ea287b4d548d5ae4682b4ab", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -1,6 +1,10 @@\n //! Type-checking for the rust-intrinsic and platform-intrinsic\n //! intrinsics that the compiler exposes.\n \n+use crate::errors::{\n+    SimdShuffleMissingLength, UnrecognizedAtomicOperation, UnrecognizedIntrinsicFunction,\n+    WrongNumberOfTypeArgumentsToInstrinsic,\n+};\n use crate::require_same_types;\n \n use rustc_errors::struct_span_err;\n@@ -41,17 +45,11 @@ fn equate_intrinsic_type<'tcx>(\n             _ => bug!(),\n         };\n \n-        struct_span_err!(\n-            tcx.sess,\n+        tcx.sess.emit_err(WrongNumberOfTypeArgumentsToInstrinsic {\n             span,\n-            E0094,\n-            \"intrinsic has wrong number of type \\\n-                         parameters: found {}, expected {}\",\n-            i_n_tps,\n-            n_tps\n-        )\n-        .span_label(span, format!(\"expected {} type parameter\", n_tps))\n-        .emit();\n+            found: i_n_tps,\n+            expected: n_tps,\n+        });\n         return;\n     }\n \n@@ -146,15 +144,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             | \"umin\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], param(0)),\n             \"fence\" | \"singlethreadfence\" => (0, Vec::new(), tcx.mk_unit()),\n             op => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    it.span,\n-                    E0092,\n-                    \"unrecognized atomic operation function: `{}`\",\n-                    op\n-                )\n-                .span_label(it.span, \"unrecognized atomic operation\")\n-                .emit();\n+                tcx.sess.emit_err(UnrecognizedAtomicOperation { span: it.span, op });\n                 return;\n             }\n         };\n@@ -380,15 +370,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             other => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    it.span,\n-                    E0093,\n-                    \"unrecognized intrinsic function: `{}`\",\n-                    other,\n-                )\n-                .span_label(it.span, \"unrecognized intrinsic\")\n-                .emit();\n+                tcx.sess.emit_err(UnrecognizedIntrinsicFunction { span: it.span, name: other });\n                 return;\n             }\n         };\n@@ -468,14 +450,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n                     (2, params, param(1))\n                 }\n                 Err(_) => {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        it.span,\n-                        E0439,\n-                        \"invalid `simd_shuffle`, needs length: `{}`\",\n-                        name\n-                    )\n-                    .emit();\n+                    tcx.sess.emit_err(SimdShuffleMissingLength { span: it.span, name });\n                     return;\n                 }\n             }"}, {"sha": "5817212374bd5f85991bf9692502c8be8d9561d8", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -4,14 +4,14 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n \n use crate::check::FnCtxt;\n+use crate::errors::MethodCallOnUnknownType;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n \n use rustc_ast as ast;\n use rustc_ast::util::lev_distance::{find_best_match_for_name, lev_distance};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n@@ -376,14 +376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // so we do a future-compat lint here for the 2015 edition\n                 // (see https://github.com/rust-lang/rust/issues/46906)\n                 if self.tcx.sess.rust_2018() {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0699,\n-                        \"the type of this value must be known to call a method on a raw pointer on \\\n-                         it\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(MethodCallOnUnknownType { span });\n                 } else {\n                     self.tcx.struct_span_lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,"}, {"sha": "cd6d17999f9468f8d62c780aaaf6920281a13e5d", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -1,6 +1,7 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n+use crate::errors::{CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -58,14 +59,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => bug!(\"expected Drop impl item\"),\n     };\n \n-    struct_span_err!(\n-        tcx.sess,\n-        sp,\n-        E0120,\n-        \"the `Drop` trait may only be implemented for structs, enums, and unions\",\n-    )\n-    .span_label(sp, \"must be a struct, enum, or union\")\n-    .emit();\n+    tcx.sess.emit_err(DropImplOnWrongItem { span: sp });\n }\n \n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n@@ -108,25 +102,10 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n             let span =\n                 if let ItemKind::Impl { self_ty, .. } = item.kind { self_ty.span } else { span };\n \n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0206,\n-                \"the trait `Copy` may not be implemented for this type\"\n-            )\n-            .span_label(span, \"type is not a structure or enumeration\")\n-            .emit();\n+            tcx.sess.emit_err(CopyImplOnNonAdt { span });\n         }\n         Err(CopyImplementationError::HasDestructor) => {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0184,\n-                \"the trait `Copy` may not be implemented for this type; the \\\n-                              type has a destructor\"\n-            )\n-            .span_label(span, \"Copy not allowed on types with destructors\")\n-            .emit();\n+            tcx.sess.emit_err(CopyImplOnTypeWithDtor { span });\n         }\n     }\n }"}, {"sha": "0f64b96b291061d4ab225a60464c7add3abc35d1", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -1,5 +1,6 @@\n+use crate::errors::AssocTypeOnInherentImpl;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, Applicability, ErrorReported, StashKey};\n+use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -627,11 +628,5 @@ fn infer_placeholder_type(\n }\n \n fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0202,\n-        \"associated types are not yet supported in inherent impls (see #8995)\"\n-    )\n-    .emit();\n+    tcx.sess.emit_err(AssocTypeOnInherentImpl { span });\n }"}, {"sha": "a769e48d2ca80bc8350cfeaf459663eaacd28d7a", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 186, "deletions": 1, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57edf88b400ff6c6ae1de255fbd7e3448aca4fb2/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=57edf88b400ff6c6ae1de255fbd7e3448aca4fb2", "patch": "@@ -1,6 +1,66 @@\n //! Errors emitted by typeck.\n use rustc_macros::SessionDiagnostic;\n-use rustc_span::{symbol::Ident, Span };\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0062\"]\n+pub struct FieldMultiplySpecifiedInInitializer {\n+    #[message = \"field `{ident}` specified more than once\"]\n+    #[label = \"used more than once\"]\n+    pub span: Span,\n+    #[label = \"first use of `{ident}`\"]\n+    pub prev_span: Span,\n+    pub ident: Ident,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0092\"]\n+pub struct UnrecognizedAtomicOperation<'a> {\n+    #[message = \"unrecognized atomic operation function: `{op}`\"]\n+    #[label = \"unrecognized atomic operation\"]\n+    pub span: Span,\n+    pub op: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0094\"]\n+pub struct WrongNumberOfTypeArgumentsToInstrinsic {\n+    #[message = \"intrinsic has wrong number of type \\\n+                         parameters: found {found}, expected {expected}\"]\n+    #[label = \"expected {expected} type parameter\"]\n+    pub span: Span,\n+    pub found: usize,\n+    pub expected: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0093\"]\n+pub struct UnrecognizedIntrinsicFunction {\n+    #[message = \"unrecognized intrinsic function: `{name}`\"]\n+    #[label = \"unrecognized intrinsic\"]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0195\"]\n+pub struct LifetimesOrBoundsMismatchOnTrait {\n+    #[message = \"lifetime parameters or bounds on {item_kind} `{ident}` do not match the trait declaration\"]\n+    #[label = \"lifetimes do not match {item_kind} in trait\"]\n+    pub span: Span,\n+    #[label = \"lifetimes in impl do not match this {item_kind} in trait\"]\n+    pub generics_span: Option<Span>,\n+    pub item_kind: &'static str,\n+    pub ident: Ident,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0120\"]\n+pub struct DropImplOnWrongItem {\n+    #[message = \"the `Drop` trait may only be implemented for structs, enums, and unions\"]\n+    #[label = \"must be a struct, enum, or union\"]\n+    pub span: Span,\n+}\n \n #[derive(SessionDiagnostic)]\n #[error = \"E0124\"]\n@@ -12,3 +72,128 @@ pub struct FieldAlreadyDeclared {\n     #[label = \"`{field_name}` first declared here\"]\n     pub prev_span: Span,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0184\"]\n+pub struct CopyImplOnTypeWithDtor {\n+    #[message = \"the trait `Copy` may not be implemented for this type; the \\\n+                              type has a destructor\"]\n+    #[label = \"Copy not allowed on types with destructors\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0202\"]\n+pub struct AssocTypeOnInherentImpl {\n+    #[message = \"associated types are not yet supported in inherent impls (see #8995)\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0203\"]\n+pub struct MultipleRelaxedDefaultBounds {\n+    #[message = \"type parameter has more than one relaxed default bound, only one is supported\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0206\"]\n+pub struct CopyImplOnNonAdt {\n+    #[message = \"the trait `Copy` may not be implemented for this type\"]\n+    #[label = \"type is not a structure or enumeration\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0224\"]\n+pub struct TraitObjectDeclaredWithNoTraits {\n+    #[message = \"at least one trait is required for an object type\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0227\"]\n+pub struct AmbiguousLifetimeBound {\n+    #[message = \"ambiguous lifetime bound, explicit lifetime bound required\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0229\"]\n+pub struct AssocTypeBindingNotAllowed {\n+    #[message = \"associated type bindings are not allowed here\"]\n+    #[label = \"associated type not allowed here\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0439\"]\n+pub struct SimdShuffleMissingLength {\n+    #[message = \"invalid `simd_shuffle`, needs length: `{name}`\"]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0436\"]\n+pub struct FunctionalRecordUpdateOnNonStruct {\n+    #[message = \"functional record update syntax requires a struct\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0516\"]\n+pub struct TypeofReservedKeywordUsed {\n+    #[message = \"`typeof` is a reserved keyword but unimplemented\"]\n+    #[label = \"reserved keyword\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0572\"]\n+pub struct ReturnStmtOutsideOfFnBody {\n+    #[message = \"return statement outside of function body\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0627\"]\n+pub struct YieldExprOutsideOfGenerator {\n+    #[message = \"yield expression outside of generator literal\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0639\"]\n+pub struct StructExprNonExhaustive {\n+    #[message = \"cannot create non-exhaustive {what} using struct expression\"]\n+    pub span: Span,\n+    pub what: &'static str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0699\"]\n+pub struct MethodCallOnUnknownType {\n+    #[message = \"the type of this value must be known to call a method on a raw pointer on it\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0719\"]\n+pub struct ValueOfAssociatedStructAlreadySpecified {\n+    #[message = \"the value of the associated type `{item_name}` (from trait `{def_path}`) is already specified\"]\n+    #[label = \"re-bound here\"]\n+    pub span: Span,\n+    #[label = \"`{item_name}` bound here first\"]\n+    pub prev_span: Span,\n+    pub item_name: Ident,\n+    pub def_path: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0745\"]\n+pub struct AddressOfTemporaryTaken {\n+    #[message = \"cannot take address of a temporary\"]\n+    #[label = \"temporary value\"]\n+    pub span: Span,\n+}"}]}