{"sha": "d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYzJkNmM1NGU2ZDg4YTY4YTNiM2U0ZGE2NDMzYWZjZjk0YTIxYWM=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-12-06T04:48:28Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-06T23:01:17Z"}, "message": "Update macro tutorial to recognize item/statement macros and be clearer\nabout invocation location vs. interpolation location.", "tree": {"sha": "ea751013ec949e64fe8bc8e76619c89cfa5b5c71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea751013ec949e64fe8bc8e76619c89cfa5b5c71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac", "html_url": "https://github.com/rust-lang/rust/commit/d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a7be31bba0174b7657853e1738babf8c06406a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a7be31bba0174b7657853e1738babf8c06406a", "html_url": "https://github.com/rust-lang/rust/commit/14a7be31bba0174b7657853e1738babf8c06406a"}], "stats": {"total": 33, "additions": 27, "deletions": 6}, "files": [{"sha": "e3b0bad2901a432f982fd3f99e90f9acd658dbac", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=d0c2d6c54e6d88a68a3b3e4da6433afcf94a21ac", "patch": "@@ -84,23 +84,44 @@ To take as an argument a fragment of Rust code, write `$` followed by a name\n * `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n   a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n * `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)\n- \n+\n The parser interprets any token that's not preceded by a `$` literally. Rust's usual\n rules of tokenization apply,\n \n So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a macro\n that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n+## Invocation location\n+\n+A macro invocation may take the place of (and therefore expand to) either an\n+expression, an item, or a statement. The Rust parser will parse the macro\n+invocation as a \"placeholder\" for whichever of those three nonterminals is\n+appropriate for the location.\n+\n+At expansion time, the output of the macro will be parsed as whichever of the\n+three nonterminals it stands in for. This means that a single macro might,\n+for example, expand to an item or an expression, depending on its arguments\n+(and cause a syntax error if it is called with the wrong argument for its\n+location). Although this behavior sounds excessively dynamic, it is known to\n+be useful under some circumstances.\n+\n+\n # Transcription syntax\n \n The right-hand side of the `=>` follows the same rules as the left-hand side,\n except that a `$` need only be followed by the name of the syntactic fragment\n to transcribe into the macro expansion; its type need not be repeated.\n \n-The right-hand side must be enclosed by delimiters, and must be\n-an expression. Currently, invocations of user-defined macros can only appear in a context\n-where the Rust grammar requires an expression, even though `macro_rules!` itself can appear\n-in a context where the grammar requires an item.\n+The right-hand side must be enclosed by delimiters, which are ignored by the\n+transcriber (therefore `() => ((1,2,3))` is a macro that expands to a tuple\n+expression, `() => (let $x=$val)` is a macro that expands to a statement, and\n+`() => (1,2,3)` is a macro that expands to a syntax errror).\n+\n+## Interpolation location\n+\n+The interpolation `$argument_name` may appear in any location consistent with\n+its fragment specifier (i.e., if it is specified as `ident`, it may be used\n+anywhere an identifier is permitted).\n \n # Multiplicity\n \n@@ -163,7 +184,7 @@ fragments by the macro parser:\n fragment. For example, if the comma were omitted from the syntax of\n `early_return!` above, `input_1 [` would've been interpreted as the beginning\n of an array index. In fact, invoking the macro would have been impossible.\n-2. The parser must have eliminated all ambiguity by the time it reaches a \n+2. The parser must have eliminated all ambiguity by the time it reaches a\n `$name:fragment_specifier` declaration. This limitation can result in parse\n errors when declarations occur at the beginning of, or immediately after,\n a `$(...)*`. For example, the grammar `$($t:ty)* $e:expr` will always fail to"}]}