{"sha": "aaf6e06b01c4f7490e71693d3c96f466032e80d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZjZlMDZiMDFjNGY3NDkwZTcxNjkzZDNjOTZmNDY2MDMyZTgwZDA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-05-06T21:01:16Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-05-10T23:58:17Z"}, "message": "use jemalloc to implement Vec<T>", "tree": {"sha": "70f5b0bc538302c70f38744a78c78430c5d3d947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70f5b0bc538302c70f38744a78c78430c5d3d947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaf6e06b01c4f7490e71693d3c96f466032e80d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf6e06b01c4f7490e71693d3c96f466032e80d0", "html_url": "https://github.com/rust-lang/rust/commit/aaf6e06b01c4f7490e71693d3c96f466032e80d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaf6e06b01c4f7490e71693d3c96f466032e80d0/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a5eb4b5295ada37e1e42ad1299857fcb8e81e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a5eb4b5295ada37e1e42ad1299857fcb8e81e9", "html_url": "https://github.com/rust-lang/rust/commit/03a5eb4b5295ada37e1e42ad1299857fcb8e81e9"}], "stats": {"total": 76, "additions": 49, "deletions": 27}, "files": [{"sha": "1b4b1e444fef99658e886571c5505578416bbe8b", "filename": "src/libstd/rt/heap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aaf6e06b01c4f7490e71693d3c96f466032e80d0/src%2Flibstd%2Frt%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf6e06b01c4f7490e71693d3c96f466032e80d0/src%2Flibstd%2Frt%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fheap.rs?ref=aaf6e06b01c4f7490e71693d3c96f466032e80d0", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME: #13994: port to the sized deallocation API when available\n+// FIXME: #13996: need a way to mark the `allocate` and `reallocate` return values as `noalias`\n+\n use intrinsics::{abort, cttz32};\n use libc::{c_int, c_void, size_t};\n use ptr::RawPtr;"}, {"sha": "28035c32f8e683abab2a5ff4ea4cc13e80e1aca7", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/aaf6e06b01c4f7490e71693d3c96f466032e80d0/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf6e06b01c4f7490e71693d3c96f466032e80d0/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=aaf6e06b01c4f7490e71693d3c96f466032e80d0", "patch": "@@ -12,23 +12,22 @@\n \n use cast::{forget, transmute};\n use clone::Clone;\n-use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd};\n+use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd, max};\n use container::{Container, Mutable};\n use default::Default;\n use fmt;\n use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator, range};\n-use libc::{free, c_void};\n-use mem::{size_of, move_val_init};\n+use mem::{min_align_of, move_val_init, size_of};\n use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n use ops::{Add, Drop};\n use option::{None, Option, Some, Expect};\n use ptr::RawPtr;\n use ptr;\n-use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n use RawVec = raw::Vec;\n+use rt::heap::{allocate, reallocate, deallocate};\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n use slice::{MutableVectorAllocating};\n@@ -96,7 +95,7 @@ impl<T> Vec<T> {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n-            let ptr = unsafe { malloc_raw(size) };\n+            let ptr = unsafe { allocate(size, min_align_of::<T>()) };\n             Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n         }\n     }\n@@ -401,6 +400,16 @@ impl<T> Container for Vec<T> {\n     }\n }\n \n+// FIXME: #13996: need a way to mark the return value as `noalias`\n+#[inline(never)]\n+unsafe fn alloc_or_realloc(ptr: *mut u8, size: uint, align: uint, old_size: uint) -> *mut u8 {\n+    if old_size == 0 {\n+        allocate(size, align)\n+    } else {\n+        reallocate(ptr, size, align, old_size)\n+    }\n+}\n+\n impl<T> Vec<T> {\n     /// Returns the number of elements the vector can hold without\n     /// reallocating.\n@@ -479,31 +488,35 @@ impl<T> Vec<T> {\n     pub fn reserve_exact(&mut self, capacity: uint) {\n         if capacity > self.cap {\n             let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n-            self.cap = capacity;\n             unsafe {\n-                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+                self.ptr = alloc_or_realloc(self.ptr as *mut u8, size, min_align_of::<T>(),\n+                                            self.cap * size_of::<T>()) as *mut T;\n             }\n+            self.cap = capacity;\n         }\n     }\n \n-    /// Shrink the capacity of the vector to match the length\n+    /// Shrink the capacity of the vector as much as possible\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let mut vec = vec!(1, 2, 3);\n     /// vec.shrink_to_fit();\n-    /// assert_eq!(vec.capacity(), vec.len());\n     /// ```\n     pub fn shrink_to_fit(&mut self) {\n         if self.len == 0 {\n-            unsafe { free(self.ptr as *mut c_void) };\n-            self.cap = 0;\n-            self.ptr = 0 as *mut T;\n+            if self.cap != 0 {\n+                unsafe {\n+                    deallocate(self.ptr as *mut u8, self.cap * size_of::<T>(), min_align_of::<T>())\n+                }\n+                self.cap = 0;\n+            }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at least this large.\n-                self.ptr = realloc_raw(self.ptr as *mut u8, self.len * size_of::<T>()) as *mut T;\n+                self.ptr = reallocate(self.ptr as *mut u8, self.len * size_of::<T>(),\n+                                      min_align_of::<T>(), self.cap * size_of::<T>()) as *mut T;\n             }\n             self.cap = self.len;\n         }\n@@ -547,14 +560,14 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn push(&mut self, value: T) {\n         if self.len == self.cap {\n-            if self.cap == 0 { self.cap += 2 }\n             let old_size = self.cap * size_of::<T>();\n-            self.cap = self.cap * 2;\n-            let size = old_size * 2;\n+            let size = max(old_size, 2 * size_of::<T>()) * 2;\n             if old_size > size { fail!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+                self.ptr = alloc_or_realloc(self.ptr as *mut u8, size, min_align_of::<T>(),\n+                                            self.cap * size_of::<T>()) as *mut u8 as *mut T;\n             }\n+            self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n@@ -638,9 +651,10 @@ impl<T> Vec<T> {\n     pub fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n             let iter = transmute(self.as_slice().iter());\n-            let ptr = self.ptr as *mut c_void;\n+            let ptr = self.ptr as *mut u8;\n+            let cap = self.cap;\n             forget(self);\n-            MoveItems { allocation: ptr, iter: iter }\n+            MoveItems { allocation: ptr, cap: cap, iter: iter }\n         }\n     }\n \n@@ -1386,11 +1400,13 @@ impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n-        unsafe {\n-            for x in self.as_mut_slice().iter() {\n-                ptr::read(x);\n+        if self.cap != 0 {\n+            unsafe {\n+                for x in self.as_mut_slice().iter() {\n+                    ptr::read(x);\n+                }\n+                deallocate(self.ptr as *mut u8, self.cap * size_of::<T>(), min_align_of::<T>())\n             }\n-            free(self.ptr as *mut c_void)\n         }\n     }\n }\n@@ -1409,7 +1425,8 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n \n /// An iterator that moves out of a vector.\n pub struct MoveItems<T> {\n-    allocation: *mut c_void, // the block of memory allocated for the vector\n+    allocation: *mut u8, // the block of memory allocated for the vector\n+    cap: uint, // the capacity of the vector\n     iter: Items<'static, T>\n }\n \n@@ -1440,9 +1457,11 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n impl<T> Drop for MoveItems<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n-        for _x in *self {}\n-        unsafe {\n-            free(self.allocation)\n+        if self.cap != 0 {\n+            for _x in *self {}\n+            unsafe {\n+                deallocate(self.allocation, self.cap * size_of::<T>(), min_align_of::<T>())\n+            }\n         }\n     }\n }"}]}