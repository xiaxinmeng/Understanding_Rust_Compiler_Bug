{"sha": "9fca57ceb9a976b54602f86440f7411a359ff0d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmY2E1N2NlYjlhOTc2YjU0NjAyZjg2NDQwZjc0MTFhMzU5ZmYwZDE=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-05T12:23:11Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-18T09:07:42Z"}, "message": "BTreeMap: reuse NodeRef as Root, keep BoxedNode for edges only, ban Unique", "tree": {"sha": "bca5394838d1899bd1852428ff4b7ed6f63e0148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bca5394838d1899bd1852428ff4b7ed6f63e0148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fca57ceb9a976b54602f86440f7411a359ff0d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fca57ceb9a976b54602f86440f7411a359ff0d1", "html_url": "https://github.com/rust-lang/rust/commit/9fca57ceb9a976b54602f86440f7411a359ff0d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fca57ceb9a976b54602f86440f7411a359ff0d1/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4f836ad1aceb83507810d9499f56988fd24578d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f836ad1aceb83507810d9499f56988fd24578d", "html_url": "https://github.com/rust-lang/rust/commit/c4f836ad1aceb83507810d9499f56988fd24578d"}], "stats": {"total": 344, "additions": 168, "deletions": 176}, "files": [{"sha": "d3edcd0b87e0f144edf0968250ce25d7c987b4fa", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -34,7 +34,7 @@ impl<K, V> Root<K, V> {\n     where\n         I: Iterator<Item = (K, V)>,\n     {\n-        let mut cur_node = self.node_as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = self.borrow_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -86,7 +86,7 @@ impl<K, V> Root<K, V> {\n \n     fn fix_right_edge(&mut self) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.node_as_mut();\n+        let mut cur_node = self.borrow_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_kv = internal.last_kv().consider_for_balancing();"}, {"sha": "6641ad33f92a608383374b5dc1e8138da375cb18", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -157,7 +157,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n-                        let mut out_node = match root.node_as_mut().force() {\n+                        let mut out_node = match root.borrow_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -213,7 +213,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             // Ord` constraint, which this method lacks.\n             BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().node_as_ref()) // unwrap succeeds because not empty\n+            clone_subtree(self.root.as_ref().unwrap().reborrow()) // unwrap succeeds because not empty\n         }\n     }\n }\n@@ -226,7 +226,7 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        let root_node = self.root.as_ref()?.node_as_ref();\n+        let root_node = self.root.as_ref()?.reborrow();\n         match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n@@ -235,7 +235,7 @@ where\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = map.root.as_mut()?.node_as_mut();\n+        let root_node = map.root.as_mut()?.borrow_mut();\n         match search::search_tree(root_node, key) {\n             Found(handle) => {\n                 Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_kv().0)\n@@ -246,7 +246,7 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = Self::ensure_is_owned(&mut map.root).node_as_mut();\n+        let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n         match search::search_tree::<marker::Mut<'_>, K, (), K>(root_node, &key) {\n             Found(handle) => Some(mem::replace(handle.into_key_mut(), key)),\n             GoDown(handle) => {\n@@ -522,7 +522,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        let root_node = self.root.as_ref()?.node_as_ref();\n+        let root_node = self.root.as_ref()?.reborrow();\n         match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n@@ -550,7 +550,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        let root_node = self.root.as_ref()?.node_as_ref();\n+        let root_node = self.root.as_ref()?.reborrow();\n         match search::search_tree(root_node, k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n@@ -576,7 +576,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_key_value(&self) -> Option<(&K, &V)> {\n-        let root_node = self.root.as_ref()?.node_as_ref();\n+        let root_node = self.root.as_ref()?.reborrow();\n         root_node.first_leaf_edge().right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -603,7 +603,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = map.root.as_mut()?.node_as_mut();\n+        let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.first_leaf_edge().right_kv().ok()?;\n         Some(OccupiedEntry { handle: kv.forget_node_type(), dormant_map, _marker: PhantomData })\n     }\n@@ -650,7 +650,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_key_value(&self) -> Option<(&K, &V)> {\n-        let root_node = self.root.as_ref()?.node_as_ref();\n+        let root_node = self.root.as_ref()?.reborrow();\n         root_node.last_leaf_edge().left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -677,7 +677,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = map.root.as_mut()?.node_as_mut();\n+        let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.last_leaf_edge().left_kv().ok()?;\n         Some(OccupiedEntry { handle: kv.forget_node_type(), dormant_map, _marker: PhantomData })\n     }\n@@ -758,7 +758,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        let root_node = self.root.as_mut()?.node_as_mut();\n+        let root_node = self.root.as_mut()?.borrow_mut();\n         match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_val_mut()),\n             GoDown(_) => None,\n@@ -854,7 +854,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         Q: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = map.root.as_mut()?.node_as_mut();\n+        let root_node = map.root.as_mut()?.borrow_mut();\n         match search::search_tree(root_node, key) {\n             Found(handle) => {\n                 Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_entry())\n@@ -971,7 +971,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n-            let (f, b) = root.node_as_ref().range_search(range);\n+            let (f, b) = root.reborrow().range_search(range);\n \n             Range { front: Some(f), back: Some(b) }\n         } else {\n@@ -1017,7 +1017,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = root.node_as_valmut().range_search(range);\n+            let (f, b) = root.borrow_valmut().range_search(range);\n \n             RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n         } else {\n@@ -1047,7 +1047,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = Self::ensure_is_owned(&mut map.root).node_as_mut();\n+        let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n         match search::search_tree(root_node, &key) {\n             Found(handle) => Occupied(OccupiedEntry { handle, dormant_map, _marker: PhantomData }),\n             GoDown(handle) => {\n@@ -1103,10 +1103,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         left_root.split_off(right_root, key);\n \n         if left_root.height() < right_root.height() {\n-            self.length = left_root.node_as_ref().calc_length();\n+            self.length = left_root.reborrow().calc_length();\n             right.length = total_num - self.len();\n         } else {\n-            right.length = right_root.node_as_ref().calc_length();\n+            right.length = right_root.reborrow().calc_length();\n             self.length = total_num - right.len();\n         }\n \n@@ -1154,7 +1154,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         if let Some(root) = self.root.as_mut() {\n             let (root, dormant_root) = DormantMutRef::new(root);\n-            let front = root.node_as_mut().first_leaf_edge();\n+            let front = root.borrow_mut().first_leaf_edge();\n             DrainFilterInner {\n                 length: &mut self.length,\n                 dormant_root: Some(dormant_root),\n@@ -1361,7 +1361,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n         if let Some(root) = me.root.take() {\n-            let (f, b) = root.into_ref().full_range();\n+            let (f, b) = root.full_range();\n \n             IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {\n@@ -2007,7 +2007,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         if let Some(root) = &self.root {\n-            let (f, b) = root.node_as_ref().full_range();\n+            let (f, b) = root.reborrow().full_range();\n \n             Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n         } else {\n@@ -2039,7 +2039,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = root.node_as_valmut().full_range();\n+            let (f, b) = root.borrow_valmut().full_range();\n \n             IterMut {\n                 range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },"}, {"sha": "69926ac2aff6d0c7ecffcf58fe2b7d68ab6d54e2", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -286,7 +286,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n                 // Safety: We have consumed self.handle and the reference returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 let root = map.root.as_mut().unwrap();\n-                root.push_internal_level().push(ins.k, ins.v, ins.right);\n+                root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);\n                 map.length += 1;\n                 val_ptr\n             }"}, {"sha": "f15959a1665dd6067b9300a807948a8de1d6c62f", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -49,7 +49,7 @@ impl<K, V> BTreeMap<K, V> {\n     // Panics if the map (or the code navigating it) is corrupted.\n     fn check_invariants(&self) {\n         if let Some(root) = &self.root {\n-            let root_node = root.node_as_ref();\n+            let root_node = root.reborrow();\n \n             // Check the back pointers top-down, before we attempt to rely on\n             // more serious navigation code.\n@@ -92,7 +92,7 @@ impl<K, V> BTreeMap<K, V> {\n         K: Debug,\n     {\n         if let Some(root) = self.root.as_ref() {\n-            root.node_as_ref().dump_keys()\n+            root.reborrow().dump_keys()\n         } else {\n             String::from(\"not yet allocated\")\n         }"}, {"sha": "4658629753da272e7b6412da1f5c5b7c49b4acd1", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 87, "deletions": 99, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -31,7 +31,7 @@\n use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n-use core::ptr::{self, NonNull, Unique};\n+use core::ptr::{self, NonNull};\n \n use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n@@ -114,100 +114,80 @@ impl<K, V> InternalNode<K, V> {\n /// of nodes it actually contains, and, partially due to this lack of information,\n /// has no destructor.\n struct BoxedNode<K, V> {\n-    ptr: Unique<LeafNode<K, V>>,\n+    ptr: NonNull<LeafNode<K, V>>,\n }\n \n impl<K, V> BoxedNode<K, V> {\n-    fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(Box::leak(node)) }\n-    }\n-\n-    fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(Box::leak(node)).cast() }\n+    fn from_owned(ptr: NonNull<LeafNode<K, V>>) -> Self {\n+        BoxedNode { ptr }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n-        NonNull::from(self.ptr)\n+        self.ptr\n     }\n }\n \n /// An owned tree.\n ///\n /// Note that this does not have a destructor, and must be cleaned up manually.\n-pub struct Root<K, V> {\n-    node: BoxedNode<K, V>,\n-    /// The number of levels below the root node.\n-    height: usize,\n-}\n-\n-unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n-unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n+pub type Root<K, V> = NodeRef<marker::Owned, K, V, marker::LeafOrInternal>;\n \n impl<K, V> Root<K, V> {\n-    /// Returns the number of levels below the root.\n-    pub fn height(&self) -> usize {\n-        self.height\n-    }\n-\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n-        Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n-    }\n-\n-    /// Borrows and returns an immutable reference to the node owned by the root.\n-    pub fn node_as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+        NodeRef::new().forget_type()\n     }\n+}\n \n-    /// Borrows and returns a mutable reference to the node owned by the root.\n-    pub fn node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+    fn new() -> Self {\n+        Self::from_new_leaf(Box::new(unsafe { LeafNode::new() }))\n     }\n \n-    /// Borrows and returns a mutable reference to the leaf node owned by the root.\n-    /// # Safety\n-    /// The root node is a leaf.\n-    unsafe fn leaf_node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Leaf> {\n-        debug_assert!(self.height == 0);\n-        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+    fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n+        NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }\n     }\n+}\n \n-    /// Borrows and returns a mutable reference to the internal node owned by the root.\n-    /// # Safety\n-    /// The root node is not a leaf.\n-    unsafe fn internal_node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        debug_assert!(self.height > 0);\n-        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n+    fn from_new_internal(internal: Box<InternalNode<K, V>>, height: usize) -> Self {\n+        NodeRef { height, node: NonNull::from(Box::leak(internal)).cast(), _marker: PhantomData }\n     }\n+}\n \n-    pub fn node_as_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n+    /// Mutably borrows the owned node. Unlike `reborrow_mut`, this is safe,\n+    /// because the return value cannot be used to destroy the node itself,\n+    /// and there cannot be other references to the tree (except during the\n+    /// process of `into_iter` or `drop`, but that is a horrific already).\n+    pub fn borrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    pub fn into_ref(self) -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+    /// Slightly mutably borrows the owned node.\n+    pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Packs the reference, aware of type and height, into a type-agnostic pointer.\n     fn into_boxed_node(self) -> BoxedNode<K, V> {\n-        self.node\n+        BoxedNode::from_owned(self.node)\n     }\n+}\n \n+impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Adds a new internal node with a single edge pointing to the previous root node,\n     /// make that new node the root node, and return it. This increases the height by 1\n     /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0].write(unsafe { ptr::read(&mut self.node) });\n+        new_node.edges[0].write(BoxedNode::from_owned(self.node));\n+        let mut new_root = NodeRef::from_new_internal(new_node, self.height + 1);\n+        new_root.borrow_mut().first_edge().correct_parent_link();\n+        *self = new_root.forget_type();\n \n-        self.node = BoxedNode::from_internal(new_node);\n-        self.height += 1;\n-\n-        unsafe {\n-            let mut ret = self.internal_node_as_mut();\n-            ret.reborrow_mut().first_edge().correct_parent_link();\n-            ret\n-        }\n+        // `self.borrow_mut()`, except that we just forgot we're internal now:\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Removes the internal root node, using its first child as the new root node.\n@@ -216,19 +196,17 @@ impl<K, V> Root<K, V> {\n     /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n     ///\n     /// Requires exclusive access to the `Root` object but not to the root node;\n-    /// it will not invalidate existing handles or references to the root node.\n+    /// it will not invalidate other handles or references to the root node.\n     ///\n     /// Panics if there is no internal level, i.e., if the root node is a leaf.\n     pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n-        let top = BoxedNode::as_ptr(&self.node);\n+        let top = self.node;\n \n-        let mut internal_node = unsafe { self.internal_node_as_mut() };\n-        let internal_node = NodeRef::as_internal_mut(&mut internal_node);\n-        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n-        self.height -= 1;\n-        self.node_as_mut().clear_parent_link();\n+        let internal_node = NodeRef { height: self.height, node: top, _marker: PhantomData };\n+        *self = internal_node.first_edge().descend();\n+        self.borrow_mut().clear_parent_link();\n \n         unsafe {\n             Global.dealloc(top.cast(), Layout::new::<InternalNode<K, V>>());\n@@ -755,10 +733,10 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n                     let boxed_node = ptr::read(internal.reborrow().edge_at(idx + 1));\n-                    let mut edge = Root { node: boxed_node, height: internal.height - 1 };\n+                    let mut edge = Root::from_boxed_node(boxed_node, internal.height - 1);\n                     // In practice, clearing the parent is a waste of time, because we will\n                     // insert the node elsewhere and set its parent link again.\n-                    edge.node_as_mut().clear_parent_link();\n+                    edge.borrow_mut().clear_parent_link();\n                     Some(edge)\n                 }\n             };\n@@ -784,10 +762,10 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Internal(mut internal) => {\n                     let boxed_node =\n                         slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n-                    let mut edge = Root { node: boxed_node, height: internal.height - 1 };\n+                    let mut edge = Root::from_boxed_node(boxed_node, internal.height - 1);\n                     // In practice, clearing the parent is a waste of time, because we will\n                     // insert the node elsewhere and set its parent link again.\n-                    edge.node_as_mut().clear_parent_link();\n+                    edge.borrow_mut().clear_parent_link();\n \n                     internal.correct_childrens_parent_links(0..old_len);\n \n@@ -1028,17 +1006,17 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n-            let (mut left, k, v, mut right) = middle.split();\n+            let mut result = middle.split();\n             let mut insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), insert_idx)\n+                    Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                 },\n                 LeftOrRight::Right(insert_idx) => unsafe {\n-                    Handle::new_edge(right.leaf_node_as_mut(), insert_idx)\n+                    Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                 },\n             };\n             let val_ptr = insertion_edge.insert_fit(key, val);\n-            (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), val_ptr)\n+            (InsertResult::Split(result), val_ptr)\n         }\n     }\n }\n@@ -1092,17 +1070,17 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n-            let (mut left, k, v, mut right) = middle.split();\n+            let mut result = middle.split();\n             let mut insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), insert_idx)\n+                    Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                 },\n                 LeftOrRight::Right(insert_idx) => unsafe {\n-                    Handle::new_edge(right.internal_node_as_mut(), insert_idx)\n+                    Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                 },\n             };\n             insertion_edge.insert_fit(key, val, edge);\n-            InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right })\n+            InsertResult::Split(result)\n         }\n     }\n }\n@@ -1124,16 +1102,16 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             (InsertResult::Fit(handle), ptr) => {\n                 return (InsertResult::Fit(handle.forget_node_type()), ptr);\n             }\n-            (InsertResult::Split(split), val_ptr) => (split, val_ptr),\n+            (InsertResult::Split(split), val_ptr) => (split.forget_node_type(), val_ptr),\n         };\n \n         loop {\n             split = match split.left.ascend() {\n-                Ok(parent) => match parent.insert(split.k, split.v, split.right) {\n+                Ok(parent) => match parent.insert(split.kv.0, split.kv.1, split.right) {\n                     InsertResult::Fit(handle) => {\n                         return (InsertResult::Fit(handle.forget_node_type()), val_ptr);\n                     }\n-                    InsertResult::Split(split) => split,\n+                    InsertResult::Split(split) => split.forget_node_type(),\n                 },\n                 Err(root) => {\n                     return (InsertResult::Split(SplitResult { left: root, ..split }), val_ptr);\n@@ -1239,14 +1217,14 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n-    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+    pub fn split(mut self) -> SplitResult<'a, K, V, marker::Leaf> {\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n-            let (k, v) = self.split_leaf_data(&mut new_node);\n+            let kv = self.split_leaf_data(&mut new_node);\n \n-            let right = Root { node: BoxedNode::from_leaf(new_node), height: 0 };\n-            (self.node, k, v, right)\n+            let right = NodeRef::from_new_leaf(new_node);\n+            SplitResult { left: self.node, kv, right }\n         }\n     }\n \n@@ -1272,7 +1250,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the edges and key/value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n-    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n+    pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n             let new_len = self.split_new_node_len();\n@@ -1282,14 +1260,14 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n-            let (k, v) = self.split_leaf_data(&mut new_node.data);\n+            let kv = self.split_leaf_data(&mut new_node.data);\n \n             let height = self.node.height;\n-            let mut right = Root { node: BoxedNode::from_internal(new_node), height };\n+            let mut right = NodeRef::from_new_internal(new_node, height);\n \n-            right.internal_node_as_mut().correct_childrens_parent_links(0..=new_len);\n+            right.borrow_mut().correct_childrens_parent_links(0..=new_len);\n \n-            (self.node, k, v, right)\n+            SplitResult { left: self.node, kv, right }\n         }\n     }\n }\n@@ -1756,20 +1734,30 @@ pub enum ForceResult<Leaf, Internal> {\n }\n \n /// Result of insertion, when a node needed to expand beyond its capacity.\n-/// Does not distinguish between `Leaf` and `Internal` because `Root` doesn't.\n-pub struct SplitResult<'a, K, V> {\n-    // Altered node in existing tree with elements and edges that belong to the left of `k`.\n-    pub left: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+pub struct SplitResult<'a, K, V, NodeType> {\n+    // Altered node in existing tree with elements and edges that belong to the left of `kv`.\n+    pub left: NodeRef<marker::Mut<'a>, K, V, NodeType>,\n     // Some key and value split off, to be inserted elsewhere.\n-    pub k: K,\n-    pub v: V,\n-    // Owned, unattached, new node with elements and edges that belong to the right of `k`.\n-    pub right: Root<K, V>,\n+    pub kv: (K, V),\n+    // Owned, unattached, new node with elements and edges that belong to the right of `kv`.\n+    pub right: NodeRef<marker::Owned, K, V, NodeType>,\n+}\n+\n+impl<'a, K, V> SplitResult<'a, K, V, marker::Leaf> {\n+    pub fn forget_node_type(self) -> SplitResult<'a, K, V, marker::LeafOrInternal> {\n+        SplitResult { left: self.left.forget_type(), kv: self.kv, right: self.right.forget_type() }\n+    }\n+}\n+\n+impl<'a, K, V> SplitResult<'a, K, V, marker::Internal> {\n+    pub fn forget_node_type(self) -> SplitResult<'a, K, V, marker::LeafOrInternal> {\n+        SplitResult { left: self.left.forget_type(), kv: self.kv, right: self.right.forget_type() }\n+    }\n }\n \n-pub enum InsertResult<'a, K, V, Type> {\n-    Fit(Handle<NodeRef<marker::Mut<'a>, K, V, Type>, marker::KV>),\n-    Split(SplitResult<'a, K, V>),\n+pub enum InsertResult<'a, K, V, NodeType> {\n+    Fit(Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV>),\n+    Split(SplitResult<'a, K, V, NodeType>),\n }\n \n pub mod marker {"}, {"sha": "bbf35891b568fd80e205c801d4254458299b0480", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -74,16 +74,19 @@ fn test_splitpoint() {\n \n #[test]\n fn test_partial_cmp_eq() {\n-    let mut root1: Root<i32, ()> = Root::new_leaf();\n-    let mut leaf1 = unsafe { root1.leaf_node_as_mut() };\n+    let mut root1 = NodeRef::new();\n+    let mut leaf1 = root1.borrow_mut();\n     leaf1.push(1, ());\n+    let mut root1 = root1.forget_type();\n     root1.push_internal_level();\n-    let root2: Root<i32, ()> = Root::new_leaf();\n+    let root2 = Root::new_leaf();\n+    root1.reborrow().assert_back_pointers();\n+    root2.reborrow().assert_back_pointers();\n \n-    let leaf_edge_1a = root1.node_as_ref().first_leaf_edge().forget_node_type();\n-    let leaf_edge_1b = root1.node_as_ref().last_leaf_edge().forget_node_type();\n-    let top_edge_1 = root1.node_as_ref().first_edge();\n-    let top_edge_2 = root2.node_as_ref().first_edge();\n+    let leaf_edge_1a = root1.reborrow().first_leaf_edge().forget_node_type();\n+    let leaf_edge_1b = root1.reborrow().last_leaf_edge().forget_node_type();\n+    let top_edge_1 = root1.reborrow().first_edge();\n+    let top_edge_2 = root2.reborrow().first_edge();\n \n     assert!(leaf_edge_1a == leaf_edge_1a);\n     assert!(leaf_edge_1a != leaf_edge_1b);\n@@ -100,8 +103,8 @@ fn test_partial_cmp_eq() {\n     assert_eq!(top_edge_1.partial_cmp(&top_edge_2), None);\n \n     root1.pop_internal_level();\n-    unsafe { root1.into_ref().deallocate_and_ascend() };\n-    unsafe { root2.into_ref().deallocate_and_ascend() };\n+    unsafe { root1.deallocate_and_ascend() };\n+    unsafe { root2.deallocate_and_ascend() };\n }\n \n #[test]"}, {"sha": "701f36c37ee8884b47dcc93502ff23a80cd22a85", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -9,16 +9,16 @@ impl<K, V> Root<K, V> {\n         K: Borrow<Q>,\n     {\n         debug_assert!(right_root.height() == 0);\n-        debug_assert!(right_root.node_as_ref().len() == 0);\n+        debug_assert!(right_root.len() == 0);\n \n         let left_root = self;\n         for _ in 0..left_root.height() {\n             right_root.push_internal_level();\n         }\n \n         {\n-            let mut left_node = left_root.node_as_mut();\n-            let mut right_node = right_root.node_as_mut();\n+            let mut left_node = left_root.borrow_mut();\n+            let mut right_node = right_root.borrow_mut();\n \n             loop {\n                 let mut split_edge = match search_node(left_node, key) {\n@@ -48,7 +48,7 @@ impl<K, V> Root<K, V> {\n \n     /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n-        while self.height() > 0 && self.node_as_ref().len() == 0 {\n+        while self.height() > 0 && self.len() == 0 {\n             self.pop_internal_level();\n         }\n     }\n@@ -57,7 +57,7 @@ impl<K, V> Root<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.node_as_mut();\n+            let mut cur_node = self.borrow_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv().consider_for_balancing();\n@@ -83,7 +83,7 @@ impl<K, V> Root<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.node_as_mut();\n+            let mut cur_node = self.borrow_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv().consider_for_balancing();"}, {"sha": "b5ade324bba1023a0b1d5e3cd6621bc05f1aa8f0", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -207,42 +207,43 @@ def children(self):\n         yield \"borrow\", self.borrow\n \n \n-# Yields children (in a provider's sense of the word) for a tree headed by a BoxedNode.\n-# In particular, yields each key/value pair in the node and in any child nodes.\n-def children_of_node(boxed_node, height):\n-    def cast_to_internal(node):\n-        internal_type_name = node.type.target().name.replace(\"LeafNode\", \"InternalNode\", 1)\n-        internal_type = lookup_type(internal_type_name)\n-        return node.cast(internal_type.pointer())\n-\n-    node_ptr = unwrap_unique_or_non_null(boxed_node[\"ptr\"])\n-    leaf = node_ptr.dereference()\n-    keys = leaf[\"keys\"]\n-    vals = leaf[\"vals\"]\n-    edges = cast_to_internal(node_ptr)[\"edges\"] if height > 0 else None\n-    length = int(leaf[\"len\"])\n-\n-    for i in xrange(0, length + 1):\n-        if height > 0:\n-            boxed_child_node = edges[i][\"value\"][\"value\"]\n-            for child in children_of_node(boxed_child_node, height - 1):\n-                yield child\n-        if i < length:\n-            # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n-            key = keys[i][\"value\"][\"value\"] if keys.type.sizeof > 0 else \"()\"\n-            val = vals[i][\"value\"][\"value\"] if vals.type.sizeof > 0 else \"()\"\n-            yield key, val\n-\n-\n-# Yields children for a BTreeMap.\n-def children_of_map(map):\n+# Yields children (in a provider's sense of the word) for a BTreeMap.\n+def children_of_btree_map(map):\n+    # Yields each key/value pair in the node and in any child nodes.\n+    def children_of_node(node_ptr, height):\n+        def cast_to_internal(node):\n+            internal_type_name = node.type.target().name.replace(\"LeafNode\", \"InternalNode\", 1)\n+            internal_type = lookup_type(internal_type_name)\n+            return node.cast(internal_type.pointer())\n+\n+        leaf = node_ptr.dereference()\n+        keys = leaf[\"keys\"]\n+        vals = leaf[\"vals\"]\n+        edges = cast_to_internal(node_ptr)[\"edges\"] if height > 0 else None\n+        length = leaf[\"len\"]\n+\n+        for i in xrange(0, length + 1):\n+            if height > 0:\n+                boxed_child_node = edges[i][\"value\"][\"value\"]\n+                child_node = unwrap_unique_or_non_null(boxed_child_node[\"ptr\"])\n+                for child in children_of_node(child_node, height - 1):\n+                    yield child\n+            if i < length:\n+                # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n+                key = keys[i][\"value\"][\"value\"] if keys.type.sizeof > 0 else \"()\"\n+                val = vals[i][\"value\"][\"value\"] if vals.type.sizeof > 0 else \"()\"\n+                yield key, val\n+\n     if map[\"length\"] > 0:\n         root = map[\"root\"]\n         if root.type.name.startswith(\"core::option::Option<\"):\n             root = root.cast(gdb.lookup_type(root.type.name[21:-1]))\n-        boxed_root_node = root[\"node\"]\n+        node_ptr = root[\"node\"]\n+        if node_ptr.type.name.startswith(\"alloc::collections::btree::node::BoxedNode<\"):\n+            node_ptr = node_ptr[\"ptr\"]\n+        node_ptr = unwrap_unique_or_non_null(node_ptr)\n         height = root[\"height\"]\n-        for child in children_of_node(boxed_root_node, height):\n+        for child in children_of_node(node_ptr, height):\n             yield child\n \n \n@@ -255,7 +256,7 @@ def to_string(self):\n \n     def children(self):\n         inner_map = self.valobj[\"map\"]\n-        for i, (child, _) in enumerate(children_of_map(inner_map)):\n+        for i, (child, _) in enumerate(children_of_btree_map(inner_map)):\n             yield \"[{}]\".format(i), child\n \n     @staticmethod\n@@ -271,7 +272,7 @@ def to_string(self):\n         return \"BTreeMap(size={})\".format(self.valobj[\"length\"])\n \n     def children(self):\n-        for i, (key, val) in enumerate(children_of_map(self.valobj)):\n+        for i, (key, val) in enumerate(children_of_btree_map(self.valobj)):\n             yield \"key{}\".format(i), key\n             yield \"val{}\".format(i), val\n "}, {"sha": "b79f00a9d0438e39933306fe3daa39e728fb4187", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fca57ceb9a976b54602f86440f7411a359ff0d1/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fca57ceb9a976b54602f86440f7411a359ff0d1/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=9fca57ceb9a976b54602f86440f7411a359ff0d1", "patch": "@@ -101,15 +101,15 @@ fn main() {\n         btree_set.insert(i);\n     }\n \n-    let mut empty_btree_set: BTreeSet<i32> = BTreeSet::new();\n+    let empty_btree_set: BTreeSet<i32> = BTreeSet::new();\n \n     // BTreeMap\n     let mut btree_map = BTreeMap::new();\n     for i in 0..15 {\n         btree_map.insert(i, i);\n     }\n \n-    let mut empty_btree_map: BTreeMap<i32, u32> = BTreeMap::new();\n+    let empty_btree_map: BTreeMap<i32, u32> = BTreeMap::new();\n \n     let mut option_btree_map: BTreeMap<bool, Option<bool>> = BTreeMap::new();\n     option_btree_map.insert(false, None);"}]}