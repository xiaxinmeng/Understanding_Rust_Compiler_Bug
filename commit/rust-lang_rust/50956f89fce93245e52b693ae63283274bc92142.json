{"sha": "50956f89fce93245e52b693ae63283274bc92142", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOTU2Zjg5ZmNlOTMyNDVlNTJiNjkzYWU2MzI4MzI3NGJjOTIxNDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-27T08:54:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-27T08:54:18Z"}, "message": "Merge #3285\n\n3285: Handle trivia in Structural Search and Replace r=matklad a=adamrk\n\nAddresses the second point of https://github.com/rust-analyzer/rust-analyzer/issues/3186.\r\n\r\nStructural search and replace will now match code that has varies from the pattern in whitespace or comments.\r\n\r\nOne issue is that it's not clear where comments in the matched code should go in the replacement. With this change they're just tacked on at the end, which can cause some unexpected moving of comments (see the last test example).\n\nCo-authored-by: adamrk <ark.email@gmail.com>", "tree": {"sha": "3393c2c20b6adb02faf8156308f18ff842f6968d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3393c2c20b6adb02faf8156308f18ff842f6968d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50956f89fce93245e52b693ae63283274bc92142", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeV4O6CRBK7hj4Ov3rIwAAdHIIABenmqAld9LQQ1d6tlrUsowb\nO3+wJL4Wqmn9NbU0QJkWnyzaun44YZ6N0dL+uN2UKQQShCB//IoJM04tY1gqNl1q\nzpHfoi8xAFCbwp6BTdU6s/H7wMoKQ6jbZVD52qAkQKrhhGaT/EjExBhzq8b9Sa12\nYO8y9SBkiwSqpAJjbphT18Pih0UdvBgo+WGkaAWUdD8seSh58pubDMTIue2G7MJ3\nF120kc5fK9Wa416fr7mPKgvATjJNfdAPTMA5bivuQLbaxWf2vbVfgRBml9xzmkYE\noB/S6CeHEuee+uF9Uv1ooiqjpWT+V+XNdpHjsCqsRoGPN6SGt61ely+XuqdLwtQ=\n=sxZV\n-----END PGP SIGNATURE-----\n", "payload": "tree 3393c2c20b6adb02faf8156308f18ff842f6968d\nparent 7f7d96cffed6ed4836432a16cfc1dbd080bbab17\nparent b1ee6d17a4af6a2fcbaeb0b98965cd610c7b1b72\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582793658 +0000\ncommitter GitHub <noreply@github.com> 1582793658 +0000\n\nMerge #3285\n\n3285: Handle trivia in Structural Search and Replace r=matklad a=adamrk\n\nAddresses the second point of https://github.com/rust-analyzer/rust-analyzer/issues/3186.\r\n\r\nStructural search and replace will now match code that has varies from the pattern in whitespace or comments.\r\n\r\nOne issue is that it's not clear where comments in the matched code should go in the replacement. With this change they're just tacked on at the end, which can cause some unexpected moving of comments (see the last test example).\n\nCo-authored-by: adamrk <ark.email@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50956f89fce93245e52b693ae63283274bc92142", "html_url": "https://github.com/rust-lang/rust/commit/50956f89fce93245e52b693ae63283274bc92142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50956f89fce93245e52b693ae63283274bc92142/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f7d96cffed6ed4836432a16cfc1dbd080bbab17", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7d96cffed6ed4836432a16cfc1dbd080bbab17", "html_url": "https://github.com/rust-lang/rust/commit/7f7d96cffed6ed4836432a16cfc1dbd080bbab17"}, {"sha": "b1ee6d17a4af6a2fcbaeb0b98965cd610c7b1b72", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ee6d17a4af6a2fcbaeb0b98965cd610c7b1b72", "html_url": "https://github.com/rust-lang/rust/commit/b1ee6d17a4af6a2fcbaeb0b98965cd610c7b1b72"}], "stats": {"total": 141, "additions": 115, "deletions": 26}, "files": [{"sha": "c011a2e74f3c41f2a5aecc24a50261ad78821d2a", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 115, "deletions": 26, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/50956f89fce93245e52b693ae63283274bc92142/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50956f89fce93245e52b693ae63283274bc92142/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=50956f89fce93245e52b693ae63283274bc92142", "patch": "@@ -3,9 +3,8 @@\n use crate::source_change::SourceFileEdit;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::make::expr_from_text;\n-use ra_syntax::AstNode;\n-use ra_syntax::SyntaxElement;\n-use ra_syntax::SyntaxNode;\n+use ra_syntax::ast::{AstToken, Comment};\n+use ra_syntax::{AstNode, SyntaxElement, SyntaxNode};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use rustc_hash::FxHashMap;\n use std::collections::HashMap;\n@@ -72,6 +71,7 @@ type Binding = HashMap<Var, SyntaxNode>;\n struct Match {\n     place: SyntaxNode,\n     binding: Binding,\n+    ignored_comments: Vec<Comment>,\n }\n \n #[derive(Debug)]\n@@ -179,44 +179,61 @@ fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n         pattern: &SyntaxElement,\n         code: &SyntaxElement,\n         placeholders: &[Var],\n-        match_: &mut Match,\n-    ) -> bool {\n+        mut match_: Match,\n+    ) -> Option<Match> {\n         match (pattern, code) {\n             (SyntaxElement::Token(ref pattern), SyntaxElement::Token(ref code)) => {\n-                pattern.text() == code.text()\n+                if pattern.text() == code.text() {\n+                    Some(match_)\n+                } else {\n+                    None\n+                }\n             }\n             (SyntaxElement::Node(ref pattern), SyntaxElement::Node(ref code)) => {\n                 if placeholders.iter().any(|n| n.0.as_str() == pattern.text()) {\n                     match_.binding.insert(Var(pattern.text().to_string()), code.clone());\n-                    true\n+                    Some(match_)\n                 } else {\n-                    pattern.green().children().count() == code.green().children().count()\n-                        && pattern\n-                            .children_with_tokens()\n-                            .zip(code.children_with_tokens())\n-                            .all(|(a, b)| check(&a, &b, placeholders, match_))\n+                    let mut pattern_children = pattern\n+                        .children_with_tokens()\n+                        .filter(|element| !element.kind().is_trivia());\n+                    let mut code_children =\n+                        code.children_with_tokens().filter(|element| !element.kind().is_trivia());\n+                    let new_ignored_comments = code.children_with_tokens().filter_map(|element| {\n+                        element.as_token().and_then(|token| Comment::cast(token.clone()))\n+                    });\n+                    match_.ignored_comments.extend(new_ignored_comments);\n+                    let match_from_children = pattern_children\n+                        .by_ref()\n+                        .zip(code_children.by_ref())\n+                        .fold(Some(match_), |accum, (a, b)| {\n+                            accum.and_then(|match_| check(&a, &b, placeholders, match_))\n+                        });\n+                    match_from_children.and_then(|match_| {\n+                        if pattern_children.count() == 0 && code_children.count() == 0 {\n+                            Some(match_)\n+                        } else {\n+                            None\n+                        }\n+                    })\n                 }\n             }\n-            _ => false,\n+            _ => None,\n         }\n     }\n     let kind = pattern.pattern.kind();\n     let matches = code\n-        .descendants_with_tokens()\n+        .descendants()\n         .filter(|n| n.kind() == kind)\n         .filter_map(|code| {\n-            let mut match_ =\n-                Match { place: code.as_node().unwrap().clone(), binding: HashMap::new() };\n-            if check(\n+            let match_ =\n+                Match { place: code.clone(), binding: HashMap::new(), ignored_comments: vec![] };\n+            check(\n                 &SyntaxElement::from(pattern.pattern.clone()),\n-                &code,\n+                &SyntaxElement::from(code),\n                 &pattern.vars,\n-                &mut match_,\n-            ) {\n-                Some(match_)\n-            } else {\n-                None\n-            }\n+                match_,\n+            )\n         })\n         .collect();\n     SsrMatches { matches }\n@@ -225,18 +242,28 @@ fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n fn replace(matches: &SsrMatches, template: &SsrTemplate) -> TextEdit {\n     let mut builder = TextEditBuilder::default();\n     for match_ in &matches.matches {\n-        builder.replace(match_.place.text_range(), render_replace(&match_.binding, template));\n+        builder.replace(\n+            match_.place.text_range(),\n+            render_replace(&match_.binding, &match_.ignored_comments, template),\n+        );\n     }\n     builder.finish()\n }\n \n-fn render_replace(binding: &Binding, template: &SsrTemplate) -> String {\n+fn render_replace(\n+    binding: &Binding,\n+    ignored_comments: &Vec<Comment>,\n+    template: &SsrTemplate,\n+) -> String {\n     let mut builder = TextEditBuilder::default();\n     for element in template.template.descendants() {\n         if let Some(var) = template.placeholders.get(&element) {\n             builder.replace(element.text_range(), binding[var].to_string())\n         }\n     }\n+    for comment in ignored_comments {\n+        builder.insert(template.template.text_range().end(), comment.syntax().to_string())\n+    }\n     builder.finish().apply(&template.template.text().to_string())\n }\n \n@@ -325,4 +352,66 @@ mod tests {\n         let edit = replace(&matches, &query.template);\n         assert_eq!(edit.apply(input), \"fn main() { bar(1+2); }\");\n     }\n+\n+    fn assert_ssr_transform(query: &str, input: &str, result: &str) {\n+        let query: SsrQuery = query.parse().unwrap();\n+        let code = SourceFile::parse(input).tree();\n+        let matches = find(&query.pattern, code.syntax());\n+        let edit = replace(&matches, &query.template);\n+        assert_eq!(edit.apply(input), result);\n+    }\n+\n+    #[test]\n+    fn ssr_function_to_method() {\n+        assert_ssr_transform(\n+            \"my_function($a:expr, $b:expr) ==>> ($a).my_method($b)\",\n+            \"loop { my_function( other_func(x, y), z + w) }\",\n+            \"loop { (other_func(x, y)).my_method(z + w) }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn ssr_nested_function() {\n+        assert_ssr_transform(\n+            \"foo($a:expr, $b:expr, $c:expr) ==>> bar($c, baz($a, $b))\",\n+            \"fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n+            \"fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn ssr_expected_spacing() {\n+        assert_ssr_transform(\n+            \"foo($x:expr) + bar() ==>> bar($x)\",\n+            \"fn main() { foo(5) + bar() }\",\n+            \"fn main() { bar(5) }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn ssr_with_extra_space() {\n+        assert_ssr_transform(\n+            \"foo($x:expr  ) +    bar() ==>> bar($x)\",\n+            \"fn main() { foo(  5 )  +bar(   ) }\",\n+            \"fn main() { bar(5) }\",\n+        );\n+    }\n+\n+    #[test]\n+    fn ssr_keeps_nested_comment() {\n+        assert_ssr_transform(\n+            \"foo($x:expr) ==>> bar($x)\",\n+            \"fn main() { foo(other(5 /* using 5 */)) }\",\n+            \"fn main() { bar(other(5 /* using 5 */)) }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn ssr_keeps_comment() {\n+        assert_ssr_transform(\n+            \"foo($x:expr) ==>> bar($x)\",\n+            \"fn main() { foo(5 /* using 5 */) }\",\n+            \"fn main() { bar(5)/* using 5 */ }\",\n+        )\n+    }\n }"}]}