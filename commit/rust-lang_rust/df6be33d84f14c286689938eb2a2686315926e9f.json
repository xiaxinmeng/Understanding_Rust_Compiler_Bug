{"sha": "df6be33d84f14c286689938eb2a2686315926e9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNmJlMzNkODRmMTRjMjg2Njg5OTM4ZWIyYTI2ODYzMTU5MjZlOWY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-24T12:21:28Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:09Z"}, "message": "async-llvm(4): Move work coordination to separate thread in order to free up the main thread for translation.", "tree": {"sha": "bffabe5e0f3821fc7d9905f36fffd679367dae75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bffabe5e0f3821fc7d9905f36fffd679367dae75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df6be33d84f14c286689938eb2a2686315926e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df6be33d84f14c286689938eb2a2686315926e9f", "html_url": "https://github.com/rust-lang/rust/commit/df6be33d84f14c286689938eb2a2686315926e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df6be33d84f14c286689938eb2a2686315926e9f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "html_url": "https://github.com/rust-lang/rust/commit/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb"}], "stats": {"total": 124, "additions": 61, "deletions": 63}, "files": [{"sha": "08eccd8fdf3a46ac52046718187f4a18954d6347", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/df6be33d84f14c286689938eb2a2686315926e9f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df6be33d84f14c286689938eb2a2686315926e9f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=df6be33d84f14c286689938eb2a2686315926e9f", "patch": "@@ -28,7 +28,6 @@ use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n use jobserver::{Client, Acquired};\n-use crossbeam::{scope, Scope};\n use rustc_demangle;\n \n use std::cmp;\n@@ -38,8 +37,10 @@ use std::io;\n use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::str;\n+use std::sync::Arc;\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::slice;\n+use std::thread;\n use libc::{c_uint, c_void, c_char, size_t};\n \n pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n@@ -283,13 +284,13 @@ impl ModuleConfig {\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n-pub struct CodegenContext<'a> {\n+pub struct CodegenContext {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n     pub lto: bool,\n     pub no_landing_pads: bool,\n-    pub exported_symbols: &'a ExportedSymbols,\n-    pub opts: &'a config::Options,\n+    pub exported_symbols: Arc<ExportedSymbols>,\n+    pub opts: Arc<config::Options>,\n     pub crate_types: Vec<config::CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n     // Handler to use for diagnostics produced during codegen.\n@@ -307,18 +308,18 @@ pub struct CodegenContext<'a> {\n     pub coordinator_send: Sender<Message>,\n }\n \n-impl<'a> CodegenContext<'a> {\n+impl CodegenContext {\n     fn create_diag_handler(&self) -> Handler {\n         Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n     }\n }\n \n struct HandlerFreeVars<'a> {\n-    cgcx: &'a CodegenContext<'a>,\n+    cgcx: &'a CodegenContext,\n     diag_handler: &'a Handler,\n }\n \n-unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n+unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n     cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_string());\n@@ -775,9 +776,8 @@ pub fn run_passes(sess: &Session,\n         let num_workers = cmp::min(work_items.len() - 1, 32);\n         Client::new(num_workers).expect(\"failed to create jobserver\")\n     });\n-    scope(|scope| {\n-        execute_work(sess, work_items, client, &trans.exported_symbols, scope);\n-    });\n+\n+    execute_work(sess, work_items, client, trans.exported_symbols.clone());\n \n     // If in incr. comp. mode, preserve the `.o` files for potential re-use\n     for mtrans in modules.iter() {\n@@ -1052,11 +1052,10 @@ pub struct Diagnostic {\n     lvl: Level,\n }\n \n-fn execute_work<'a>(sess: &'a Session,\n-                    mut work_items: Vec<WorkItem>,\n-                    jobserver: Client,\n-                    exported_symbols: &'a ExportedSymbols,\n-                    scope: &Scope<'a>) {\n+fn execute_work(sess: &Session,\n+                mut work_items: Vec<WorkItem>,\n+                jobserver: Client,\n+                exported_symbols: Arc<ExportedSymbols>) {\n     let (tx, rx) = channel();\n     let tx2 = tx.clone();\n \n@@ -1092,7 +1091,7 @@ fn execute_work<'a>(sess: &'a Session,\n         each_linked_rlib_for_lto: each_linked_rlib_for_lto,\n         lto: sess.lto(),\n         no_landing_pads: sess.no_landing_pads(),\n-        opts: &sess.opts,\n+        opts: Arc::new(sess.opts.clone()),\n         time_passes: sess.time_passes(),\n         exported_symbols: exported_symbols,\n         plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n@@ -1158,68 +1157,67 @@ fn execute_work<'a>(sess: &'a Session,\n     // Before that work finishes, however, we may acquire a token. In that case\n     // we actually wastefully acquired the token, so we relinquish it back to\n     // the jobserver.\n-    let mut tokens = Vec::new();\n-    let mut running = 0;\n-    while work_items.len() > 0 || running > 0 {\n-\n-        // Spin up what work we can, only doing this while we've got available\n-        // parallelism slots and work left to spawn.\n-        while work_items.len() > 0 && running < tokens.len() + 1 {\n-            let item = work_items.pop().unwrap();\n-            let worker_index = work_items.len();\n-\n-            let cgcx = CodegenContext {\n-                worker: worker_index,\n-                .. cgcx.clone()\n-            };\n \n-            spawn_work(cgcx,\n-                       scope,\n-                       item);\n-            running += 1;\n-        }\n+    thread::spawn(move || {\n+        let mut tokens = Vec::new();\n+        let mut running = 0;\n+        while work_items.len() > 0 || running > 0 {\n \n-        // Relinquish accidentally acquired extra tokens\n-        tokens.truncate(running.saturating_sub(1));\n+            // Spin up what work we can, only doing this while we've got available\n+            // parallelism slots and work left to spawn.\n+            while work_items.len() > 0 && running < tokens.len() + 1 {\n+                let item = work_items.pop().unwrap();\n+                let worker_index = work_items.len();\n \n-        match rx.recv().unwrap() {\n-            // Save the token locally and the next turn of the loop will use\n-            // this to spawn a new unit of work, or it may get dropped\n-            // immediately if we have no more work to spawn.\n-            Message::Token(token) => {\n-                tokens.push(token.expect(\"failed to acquire jobserver token\"));\n-            }\n+                let cgcx = CodegenContext {\n+                    worker: worker_index,\n+                    .. cgcx.clone()\n+                };\n \n-            // If a thread exits successfully then we drop a token associated\n-            // with that worker and update our `running` count. We may later\n-            // re-acquire a token to continue running more work. We may also not\n-            // actually drop a token here if the worker was running with an\n-            // \"ephemeral token\"\n-            //\n-            // Note that if the thread failed that means it panicked, so we\n-            // abort immediately.\n-            Message::Done { success: true } => {\n-                drop(tokens.pop());\n-                running -= 1;\n+                spawn_work(cgcx, item);\n+                running += 1;\n             }\n-            Message::Done { success: false } => {\n-                shared_emitter.fatal(\"aborting due to worker thread panic\".to_string());\n+\n+            // Relinquish accidentally acquired extra tokens\n+            tokens.truncate(running.saturating_sub(1));\n+\n+            match rx.recv().unwrap() {\n+                // Save the token locally and the next turn of the loop will use\n+                // this to spawn a new unit of work, or it may get dropped\n+                // immediately if we have no more work to spawn.\n+                Message::Token(token) => {\n+                    tokens.push(token.expect(\"failed to acquire jobserver token\"));\n+                }\n+\n+                // If a thread exits successfully then we drop a token associated\n+                // with that worker and update our `running` count. We may later\n+                // re-acquire a token to continue running more work. We may also not\n+                // actually drop a token here if the worker was running with an\n+                // \"ephemeral token\"\n+                //\n+                // Note that if the thread failed that means it panicked, so we\n+                // abort immediately.\n+                Message::Done { success: true } => {\n+                    drop(tokens.pop());\n+                    running -= 1;\n+                }\n+                Message::Done { success: false } => {\n+                    shared_emitter.fatal(\"aborting due to worker thread panic\".to_string());\n+                }\n             }\n         }\n+    }).join().unwrap();\n \n-        shared_emitter_main.check(sess);\n-    }\n+    shared_emitter_main.check(sess);\n \n     // Just in case, check this on the way out.\n     sess.diagnostic().abort_if_errors();\n }\n \n-fn spawn_work<'a>(cgcx: CodegenContext<'a>,\n-                  scope: &Scope<'a>,\n-                  work: WorkItem) {\n+fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n     let depth = time_depth();\n \n-    scope.spawn(move || {\n+    thread::spawn(move || {\n         set_time_depth(depth);\n \n         // Set up a destructor which will fire off a message that we're done as"}]}