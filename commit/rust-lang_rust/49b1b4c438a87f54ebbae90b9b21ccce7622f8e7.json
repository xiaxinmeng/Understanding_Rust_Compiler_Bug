{"sha": "49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YjFiNGM0MzhhODdmNTRlYmJhZTkwYjliMjFjY2NlNzYyMmY4ZTc=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-17T15:02:57Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-30T10:22:29Z"}, "message": "more `LocalDefId`s", "tree": {"sha": "a18c12b5e3e10736c3d293fffc5aa62d43a1d536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a18c12b5e3e10736c3d293fffc5aa62d43a1d536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "html_url": "https://github.com/rust-lang/rust/commit/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "html_url": "https://github.com/rust-lang/rust/commit/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9"}], "stats": {"total": 29, "additions": 18, "deletions": 11}, "files": [{"sha": "c06fd91133b5cfe7edcf09ed24a6b7626592943b", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "patch": "@@ -838,7 +838,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id.to_def_id())\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n         }\n     });\n "}, {"sha": "59b6f5e529baabc9da003a51af33b587173b9604", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "patch": "@@ -386,8 +386,14 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n         }\n \n-        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n-        query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n+        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error.\n+        ///\n+        /// Unsafety checking is executed for each method separately, but we only want\n+        /// to emit this error once per derive. As there are some impls with multiple\n+        /// methods, we use a query for deduplication.\n+        query unsafe_derive_on_repr_packed(key: LocalDefId) -> () {\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n \n         /// The signature of functions and closures.\n         query fn_sig(_: DefId) -> ty::PolyFnSig<'tcx> {}"}, {"sha": "e32bccc85ee6ffc6b8442adccb6e05242dfc51e6", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b1b4c438a87f54ebbae90b9b21ccce7622f8e7/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=49b1b4c438a87f54ebbae90b9b21ccce7622f8e7", "patch": "@@ -579,8 +579,8 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: LocalDefId) -> UnsafetyCheckRe\n     }\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let lint_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let lint_hir_id = tcx.hir().as_local_hir_id(def_id);\n \n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its\n@@ -659,16 +659,15 @@ fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     }\n }\n \n-pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n     // closures are handled by their parent fn.\n-    if tcx.is_closure(def_id) {\n+    if tcx.is_closure(def_id.to_def_id()) {\n         return;\n     }\n \n-    let UnsafetyCheckResult { violations, unsafe_blocks } =\n-        tcx.unsafety_check_result(def_id.expect_local());\n+    let UnsafetyCheckResult { violations, unsafe_blocks } = tcx.unsafety_check_result(def_id);\n \n     for &UnsafetyViolation { source_info, lint_root, description, details, kind } in\n         violations.iter()\n@@ -693,8 +692,10 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                 .emit();\n             }\n             UnsafetyViolationKind::BorrowPacked => {\n-                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n-                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id);\n+                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id.to_def_id()) {\n+                    // If a method is defined in the local crate,\n+                    // the impl containing that method should also be.\n+                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n                 } else {\n                     tcx.struct_span_lint_hir(\n                         SAFE_PACKED_BORROWS,"}]}