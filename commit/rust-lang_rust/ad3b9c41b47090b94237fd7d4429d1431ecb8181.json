{"sha": "ad3b9c41b47090b94237fd7d4429d1431ecb8181", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkM2I5YzQxYjQ3MDkwYjk0MjM3ZmQ3ZDQ0MjlkMTQzMWVjYjgxODE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-22T01:13:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-22T01:14:23Z"}, "message": "rt: Implement cycle collection marking. Simple cycles can now be detected.", "tree": {"sha": "569bdda0d918153948674314d88fd60258d62e74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/569bdda0d918153948674314d88fd60258d62e74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad3b9c41b47090b94237fd7d4429d1431ecb8181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3b9c41b47090b94237fd7d4429d1431ecb8181", "html_url": "https://github.com/rust-lang/rust/commit/ad3b9c41b47090b94237fd7d4429d1431ecb8181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad3b9c41b47090b94237fd7d4429d1431ecb8181/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a993621e43eeb6d4303d1f78faaf54cc881d49ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/a993621e43eeb6d4303d1f78faaf54cc881d49ab", "html_url": "https://github.com/rust-lang/rust/commit/a993621e43eeb6d4303d1f78faaf54cc881d49ab"}], "stats": {"total": 250, "additions": 244, "deletions": 6}, "files": [{"sha": "11f8332bcd7fd6737ff804b28cb11bcf6c1bf0c8", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 244, "deletions": 6, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/ad3b9c41b47090b94237fd7d4429d1431ecb8181/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ad3b9c41b47090b94237fd7d4429d1431ecb8181/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=ad3b9c41b47090b94237fd7d4429d1431ecb8181", "patch": "@@ -5,9 +5,11 @@\n #include \"rust_internal.h\"\n #include \"rust_shape.h\"\n #include \"rust_task.h\"\n+#include <cassert>\n #include <cstdio>\n #include <cstdlib>\n #include <map>\n+#include <set>\n #include <vector>\n #include <stdint.h>\n \n@@ -23,7 +25,7 @@ typedef std::map<void *,uintptr_t> irc_map;\n class irc : public shape::data<irc,shape::ptr> {\n     friend class shape::data<irc,shape::ptr>;\n \n-    irc_map ircs;\n+    irc_map &ircs;\n \n     irc(const irc &other, const shape::ptr &in_dp)\n     : shape::data<irc,shape::ptr>(other.task, other.align, other.sp,\n@@ -114,10 +116,13 @@ class irc : public shape::data<irc,shape::ptr> {\n             return;\n \n         // Bump the internal reference count of the box.\n-        if (ircs.find((void *)dp) == ircs.end())\n-            ircs[(void *)dp] = 1;\n-        else\n-            ++ircs[(void *)dp];\n+        if (ircs.find((void *)ref_count_dp) == ircs.end()) {\n+            //DPRINT(\"setting internal reference count for %p\\n\",\n+            //       (void *)ref_count_dp);\n+            ircs[(void *)ref_count_dp] = 1;\n+        } else {\n+            ++ircs[(void *)ref_count_dp];\n+        }\n \n         // Do not traverse the contents of this box; it's in the allocation\n         // somewhere, so we're guaranteed to come back to it (if we haven't\n@@ -167,7 +172,8 @@ irc::compute_ircs(rust_task *task, irc_map &ircs) {\n \n         type_desc *tydesc = begin->second;\n \n-        DPRINT(\"determining internal ref counts: %p, tydesc=%p\\n\", p, tydesc);\n+        //DPRINT(\"determining internal ref counts: %p, tydesc=%p\\n\", p,\n+        //tydesc);\n \n         shape::arena arena;\n         shape::type_param *params =\n@@ -187,10 +193,242 @@ irc::compute_ircs(rust_task *task, irc_map &ircs) {\n }\n \n \n+// Root finding\n+\n+void\n+find_roots(rust_task *task, irc_map &ircs, std::vector<void *> &roots) {\n+    std::map<void *,type_desc *>::iterator begin(task->local_allocs.begin()),\n+                                           end(task->local_allocs.end());\n+    while (begin != end) {\n+        void *alloc = begin->first;\n+        uintptr_t *ref_count_ptr = reinterpret_cast<uintptr_t *>(alloc);\n+        uintptr_t ref_count = *ref_count_ptr;\n+\n+        uintptr_t irc;\n+        if (ircs.find(alloc) != ircs.end())\n+            irc = ircs[alloc];\n+        else\n+            irc = 0;\n+\n+        if (irc < ref_count) {\n+            // This allocation must be a root, because the internal reference\n+            // count is smaller than the total reference count.\n+            //DPRINT(\"root found: %p, irc %lu, ref count %lu\\n\", alloc, irc,\n+            //       ref_count);\n+            roots.push_back(alloc);\n+        } else {\n+            //DPRINT(\"nonroot found: %p, ref count %lu\\n\", alloc, ref_count);\n+            /*assert(irc == ref_count && \"Internal reference count must be \"\n+                   \"less than or equal to the total reference count!\");*/\n+        }\n+\n+        ++begin;\n+    }\n+}\n+\n+\n+// Marking\n+\n+class mark : public shape::data<mark,shape::ptr> {\n+    friend class shape::data<mark,shape::ptr>;\n+\n+    std::set<void *> &marked;\n+\n+    mark(const mark &other, const shape::ptr &in_dp)\n+    : shape::data<mark,shape::ptr>(other.task, other.align, other.sp,\n+                                   other.params, other.tables, in_dp),\n+      marked(other.marked) {}\n+\n+    mark(const mark &other,\n+         const uint8_t *in_sp,\n+         const shape::type_param *in_params,\n+         const rust_shape_tables *in_tables = NULL)\n+    : shape::data<mark,shape::ptr>(other.task,\n+                                   other.align,\n+                                   in_sp,\n+                                   in_params,\n+                                   in_tables ? in_tables : other.tables,\n+                                   other.dp),\n+      marked(other.marked) {}\n+\n+    mark(const mark &other,\n+         const uint8_t *in_sp,\n+         const shape::type_param *in_params,\n+         const rust_shape_tables *in_tables,\n+         shape::ptr in_dp)\n+    : shape::data<mark,shape::ptr>(other.task,\n+                                   other.align,\n+                                   in_sp,\n+                                   in_params,\n+                                   in_tables,\n+                                   in_dp),\n+      marked(other.marked) {}\n+\n+    mark(rust_task *in_task,\n+         bool in_align,\n+         const uint8_t *in_sp,\n+         const shape::type_param *in_params,\n+         const rust_shape_tables *in_tables,\n+         uint8_t *in_data,\n+         std::set<void *> &in_marked)\n+    : shape::data<mark,shape::ptr>(in_task, in_align, in_sp, in_params,\n+                                   in_tables, in_data),\n+      marked(in_marked) {}\n+\n+    void walk_vec(bool is_pod, uint16_t sp_size) {\n+        if (is_pod || shape::get_dp<void *>(dp) == NULL)\n+            return;     // There can't be any outbound pointers from this.\n+\n+        std::pair<uint8_t *,uint8_t *> data_range(get_vec_data_range(dp));\n+        if (data_range.second - data_range.first > 100000)\n+            abort();    // FIXME: Temporary sanity check.\n+\n+        mark sub(*this, data_range.first);\n+        shape::ptr data_end = sub.end_dp = data_range.second;\n+        while (sub.dp < data_end) {\n+            sub.walk_reset();\n+            align = true;\n+        }\n+    }\n+\n+    void walk_tag(shape::tag_info &tinfo, uint32_t tag_variant) {\n+        shape::data<mark,shape::ptr>::walk_variant(tinfo, tag_variant);\n+    }\n+\n+    void walk_box() {\n+        shape::data<mark,shape::ptr>::walk_box_contents();\n+    }\n+\n+    void walk_fn() {\n+        shape::data<mark,shape::ptr>::walk_fn_contents(dp);\n+    }\n+\n+    void walk_obj() {\n+        shape::data<mark,shape::ptr>::walk_obj_contents(dp);\n+    }\n+\n+    void walk_res(const shape::rust_fn *dtor, unsigned n_params,\n+                  const shape::type_param *params, const uint8_t *end_sp,\n+                  bool live) {\n+        while (this->sp != end_sp) {\n+            this->walk();\n+            align = true;\n+        }\n+    }\n+\n+    void walk_subcontext(mark &sub) { sub.walk(); }\n+\n+    void walk_box_contents(mark &sub, shape::ptr &ref_count_dp) {\n+        if (!ref_count_dp)\n+            return;\n+\n+        if (marked.find((void *)ref_count_dp) != marked.end())\n+            return; // Skip to avoid chasing cycles.\n+\n+        marked.insert((void *)ref_count_dp);\n+        sub.walk();\n+    }\n+\n+    void walk_struct(const uint8_t *end_sp) {\n+        while (this->sp != end_sp) {\n+            this->walk();\n+            align = true;\n+        }\n+    }\n+\n+    void walk_variant(shape::tag_info &tinfo, uint32_t variant_id,\n+                      const std::pair<const uint8_t *,const uint8_t *>\n+                      variant_ptr_and_end);\n+\n+    template<typename T>\n+    inline void walk_number() { /* no-op */ }\n+\n+public:\n+    static void do_mark(rust_task *task, const std::vector<void *> &roots,\n+                        std::set<void *> &marked);\n+};\n+\n+void\n+mark::walk_variant(shape::tag_info &tinfo, uint32_t variant_id,\n+                   const std::pair<const uint8_t *,const uint8_t *>\n+                   variant_ptr_and_end) {\n+    mark sub(*this, variant_ptr_and_end.first, tinfo.params);\n+\n+    assert(variant_id < 256);   // FIXME: Temporary sanity check.\n+\n+    const uint8_t *variant_end = variant_ptr_and_end.second;\n+    while (sub.sp < variant_end) {\n+        sub.walk();\n+        align = true;\n+    }\n+}\n+\n+void\n+mark::do_mark(rust_task *task, const std::vector<void *> &roots,\n+              std::set<void *> &marked) {\n+    std::vector<void *>::const_iterator begin(roots.begin()),\n+                                        end(roots.end());\n+    while (begin != end) {\n+        void *alloc = *begin;\n+        if (marked.find(alloc) == marked.end()) {\n+            marked.insert(alloc);\n+\n+            uint8_t *p = reinterpret_cast<uint8_t *>(alloc);\n+            p += sizeof(uintptr_t); // Skip over the reference count.\n+\n+            type_desc *tydesc = task->local_allocs[*begin];\n+\n+            //DPRINT(\"marking: %p, tydesc=%p\\n\", p, tydesc);\n+\n+            shape::arena arena;\n+            shape::type_param *params =\n+                shape::type_param::from_tydesc(tydesc, arena);\n+\n+#if 0\n+            shape::log log(task, true, tydesc->shape, params,\n+                           tydesc->shape_tables, p, std::cerr);\n+            log.walk();\n+            DPRINT(\"\\n\");\n+#endif\n+\n+            mark mark(task, true, tydesc->shape, params, tydesc->shape_tables,\n+                      p, marked);\n+            mark.walk();\n+        }\n+\n+        ++begin;\n+    }\n+}\n+\n+\n+void\n+sweep(rust_task *task, const std::set<void *> &marked) {\n+    std::map<void *,type_desc *>::iterator begin(task->local_allocs.begin()),\n+                                           end(task->local_allocs.end());\n+    while (begin != end) {\n+        void *alloc = begin->first;\n+        if (marked.find(alloc) == marked.end()) {\n+            DPRINT(\"object is part of a cycle: %p\\n\", alloc);\n+        }\n+        ++begin;\n+    }\n+}\n+\n+\n void\n do_cc(rust_task *task) {\n+    DPRINT(\"cc; n allocs = %lu\\n\", task->local_allocs.size());\n+\n     irc_map ircs;\n     irc::compute_ircs(task, ircs);\n+\n+    std::vector<void *> roots;\n+    find_roots(task, ircs, roots);\n+\n+    std::set<void *> marked;\n+    mark::do_mark(task, roots, marked);\n+\n+    sweep(task, marked);\n }\n \n void"}]}