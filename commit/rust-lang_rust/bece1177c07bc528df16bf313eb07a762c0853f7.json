{"sha": "bece1177c07bc528df16bf313eb07a762c0853f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlY2UxMTc3YzA3YmM1MjhkZjE2YmYzMTNlYjA3YTc2MmMwODUzZjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-19T20:48:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-19T20:48:54Z"}, "message": "Rollup merge of #63376 - nikomatsakis:async-await-issue-62517, r=cramertj\n\nuse different lifetime name for object-lifetime-default elision\n\nIntroduce a distinct value for `LifetimeName` to use when this is a object-lifetime-default elision. This allows us to avoid creating incorrect lifetime parameters for the opaque types that result. We really need to overhaul this setup at some point! It's getting increasingly byzantine. But this seems like a relatively... surgical fix.\n\nr? @cramertj\n\nFixes #62517", "tree": {"sha": "e3ae8dfed8e5e84a52cca92fa5cdd053e17c92b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ae8dfed8e5e84a52cca92fa5cdd053e17c92b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bece1177c07bc528df16bf313eb07a762c0853f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWws2CRBK7hj4Ov3rIwAAdHIIAG5t+7YVUQJ+jZlzNn+M041s\nbesx6U+s2YTRDGpT22RVCxYdSE9pCErC9SefCpsvm86QPPnLQQZzOY51E2YIssmT\nFRJSWDMvYIZ/tr3Gj5ILdunzVYkfXFqi9mtbNCgOz4a16HCn787WhFDI5AWZLs+W\n0zfKLTYyB9UcxL/hXF0W2f+R0CVPDGHLMlqTWyLJML2XQY3m1+pkett23g8XOrlA\ng4M3dLisvjUaQ+XwrEKmzmjCrpziaAbpWoZdHReTBPAJ6NexKl+znLWCsWZO+QXn\nF8dQYG6l8Qm7tWLumcJLa75TarQ+3Bw6efn9MQwnDpljrgtvS8SSZU/SRZuPX3A=\n=EmGU\n-----END PGP SIGNATURE-----\n", "payload": "tree e3ae8dfed8e5e84a52cca92fa5cdd053e17c92b5\nparent 4486c02695ae3a3074f7039bc30cb44827940e92\nparent 7ee1af51ccc521779300eba0819bcb08c07632cf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566247734 +0200\ncommitter GitHub <noreply@github.com> 1566247734 +0200\n\nRollup merge of #63376 - nikomatsakis:async-await-issue-62517, r=cramertj\n\nuse different lifetime name for object-lifetime-default elision\n\nIntroduce a distinct value for `LifetimeName` to use when this is a object-lifetime-default elision. This allows us to avoid creating incorrect lifetime parameters for the opaque types that result. We really need to overhaul this setup at some point! It's getting increasingly byzantine. But this seems like a relatively... surgical fix.\n\nr? @cramertj\n\nFixes #62517\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bece1177c07bc528df16bf313eb07a762c0853f7", "html_url": "https://github.com/rust-lang/rust/commit/bece1177c07bc528df16bf313eb07a762c0853f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bece1177c07bc528df16bf313eb07a762c0853f7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4486c02695ae3a3074f7039bc30cb44827940e92", "url": "https://api.github.com/repos/rust-lang/rust/commits/4486c02695ae3a3074f7039bc30cb44827940e92", "html_url": "https://github.com/rust-lang/rust/commit/4486c02695ae3a3074f7039bc30cb44827940e92"}, {"sha": "7ee1af51ccc521779300eba0819bcb08c07632cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee1af51ccc521779300eba0819bcb08c07632cf", "html_url": "https://github.com/rust-lang/rust/commit/7ee1af51ccc521779300eba0819bcb08c07632cf"}], "stats": {"total": 442, "additions": 429, "deletions": 13}, "files": [{"sha": "fa274f831b7950267332d6440b6c8cc86567ce96", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -433,6 +433,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         LifetimeName::Static |\n         LifetimeName::Error |\n         LifetimeName::Implicit |\n+        LifetimeName::ImplicitObjectLifetimeDefault |\n         LifetimeName::Underscore => {}\n     }\n }"}, {"sha": "e04e45e5fbc92c7bbb19a54cdf39d84a1042f107", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -322,7 +322,7 @@ enum ParenthesizedGenericArgs {\n /// `resolve_lifetime` module. Often we \"fallthrough\" to that code by generating\n /// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n /// everything into HIR lowering.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n enum AnonymousLifetimeMode {\n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n@@ -715,10 +715,16 @@ impl<'a> LoweringContext<'a> {\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         op: impl FnOnce(&mut Self) -> R,\n     ) -> R {\n+        debug!(\n+            \"with_anonymous_lifetime_mode(anonymous_lifetime_mode={:?})\",\n+            anonymous_lifetime_mode,\n+        );\n         let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n         self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n         let result = op(self);\n         self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n+        debug!(\"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n+               old_anonymous_lifetime_mode);\n         result\n     }\n \n@@ -1355,6 +1361,13 @@ impl<'a> LoweringContext<'a> {\n         opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n+        debug!(\n+            \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n+            fn_def_id,\n+            opaque_ty_node_id,\n+            span,\n+        );\n+\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1382,6 +1395,14 @@ impl<'a> LoweringContext<'a> {\n             &hir_bounds,\n         );\n \n+        debug!(\n+            \"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,\n+        );\n+\n+        debug!(\n+            \"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,\n+        );\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -1397,7 +1418,7 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::OpaqueTyOrigin::FnReturn,\n             };\n \n-            trace!(\"exist ty from impl trait def-index: {:#?}\", opaque_ty_def_index);\n+            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n             let opaque_ty_id = lctx.generate_opaque_type(\n                 opaque_ty_node_id,\n                 opaque_ty_item,\n@@ -1445,6 +1466,13 @@ impl<'a> LoweringContext<'a> {\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n+        debug!(\n+            \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n+             parent_index={:?}, \\\n+             bounds={:#?})\",\n+            opaque_ty_id, parent_index, bounds,\n+        );\n+\n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n@@ -1532,6 +1560,11 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     }\n                     hir::LifetimeName::Param(_) => lifetime.name,\n+\n+                    // Refers to some other lifetime that is \"in\n+                    // scope\" within the type.\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n+\n                     hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n                 };\n \n@@ -2182,6 +2215,14 @@ impl<'a> LoweringContext<'a> {\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n     ) -> hir::FunctionRetTy {\n+        debug!(\n+            \"lower_async_fn_ret_ty(\\\n+             output={:?}, \\\n+             fn_def_id={:?}, \\\n+             opaque_ty_node_id={:?})\",\n+            output, fn_def_id, opaque_ty_node_id,\n+        );\n+\n         let span = output.span();\n \n         let opaque_ty_span = self.mark_span_with_reason(\n@@ -2264,6 +2305,8 @@ impl<'a> LoweringContext<'a> {\n                 ),\n             );\n \n+            debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+\n             // Calculate all the lifetimes that should be captured\n             // by the opaque type. This should include all in-scope\n             // lifetime parameters, including those defined in-band.\n@@ -2512,6 +2555,12 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit\n                         | hir::LifetimeName::Underscore\n                         | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                        span_bug!(\n+                            param.ident.span,\n+                            \"object-lifetime-default should not occur here\",\n+                        );\n+                    }\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n@@ -3255,7 +3304,13 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::PassThrough => {}\n         }\n \n-        self.new_implicit_lifetime(span)\n+        let r = hir::Lifetime {\n+            hir_id: self.next_id(),\n+            span,\n+            name: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n+        };\n+        debug!(\"elided_dyn_bound: r={:?}\", r);\n+        r\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {"}, {"sha": "983048188527fd12f9e34aeaaa9050982ac88cc0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -221,6 +221,19 @@ pub enum LifetimeName {\n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n+    /// Implicit lifetime in a context like `dyn Foo`. This is\n+    /// distinguished from implicit lifetimes elsewhere because the\n+    /// lifetime that they default to must appear elsewhere within the\n+    /// enclosing type.  This means that, in an `impl Trait` context, we\n+    /// don't have to create a parameter for them. That is, `impl\n+    /// Trait<Item = &u32>` expands to an opaque type like `type\n+    /// Foo<'a> = impl Trait<Item = &'a u32>`, but `impl Trait<item =\n+    /// dyn Bar>` expands to `type Foo = impl Trait<Item = dyn Bar +\n+    /// 'static>`. The latter uses `ImplicitObjectLifetimeDefault` so\n+    /// that surrounding code knows not to create a lifetime\n+    /// parameter.\n+    ImplicitObjectLifetimeDefault,\n+\n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n@@ -235,7 +248,9 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::Implicit | LifetimeName::Error => Ident::invalid(),\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+                | LifetimeName::Implicit\n+                | LifetimeName::Error => Ident::invalid(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n@@ -244,7 +259,9 @@ impl LifetimeName {\n \n     pub fn is_elided(&self) -> bool {\n         match self {\n-            LifetimeName::Implicit | LifetimeName::Underscore => true,\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+            | LifetimeName::Implicit\n+            | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n             // *not* elided -- but this is because, as far as the code"}, {"sha": "fd4f2c99659c8db2fe22595c802dc78a0bcc5a06", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -1108,6 +1108,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+            debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);"}, {"sha": "f5b0af61693be6eba33db255fedb9b9a45f9065c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -5,6 +5,8 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n+// ignore-tidy-filelength\n+\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n@@ -556,6 +558,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n+        debug!(\"visit_ty: ty.node={:?}\", ty.node);\n         match ty.node {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -585,11 +588,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                debug!(\"visit_ty: TraitObject(bounds={:?}, lifetime={:?})\", bounds, lifetime);\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n                 match lifetime.name {\n                     LifetimeName::Implicit => {\n+                        // For types like `dyn Foo`, we should\n+                        // generate a special form of elided.\n+                        span_bug!(\n+                            ty.span,\n+                            \"object-lifetime-default expected, not implict\",\n+                        );\n+                    }\n+                    LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n                         // rules. So e.g., `Box<dyn Debug>` becomes\n@@ -897,6 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"visit_lifetime(lifetime_ref={:?})\", lifetime_ref);\n         if lifetime_ref.is_elided() {\n             self.resolve_elided_lifetimes(vec![lifetime_ref]);\n             return;\n@@ -1911,6 +1924,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+        debug!(\n+            \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n+            res,\n+            depth,\n+            generic_args,\n+        );\n+\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1964,6 +1984,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             _ => None,\n         };\n \n+        debug!(\"visit_segment_args: type_def_id={:?}\", type_def_id);\n+\n+        // Compute a vector of defaults, one for each type parameter,\n+        // per the rules given in RFCs 599 and 1156. Example:\n+        //\n+        // ```rust\n+        // struct Foo<'a, T: 'a, U> { }\n+        // ```\n+        //\n+        // If you have `Foo<'x, dyn Bar, dyn Baz>`, we want to default\n+        // `dyn Bar` to `dyn Bar + 'x` (because of the `T: 'a` bound)\n+        // and `dyn Baz` to `dyn Baz + 'static` (because there is no\n+        // such bound).\n+        //\n+        // Therefore, we would compute `object_lifetime_defaults` to a\n+        // vector like `['x, 'static]`. Note that the vector only\n+        // includes type parameters.\n         let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n             let in_body = {\n                 let mut scope = self.scope;\n@@ -2003,6 +2040,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             .collect()\n                     })\n             };\n+            debug!(\"visit_segment_args: unsubst={:?}\", unsubst);\n             unsubst\n                 .iter()\n                 .map(|set| match *set {\n@@ -2023,6 +2061,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 .collect()\n         });\n \n+        debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n+\n         let mut i = 0;\n         for arg in &generic_args.args {\n             match arg {\n@@ -2045,8 +2085,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n+        // Hack: when resolving the type `XX` in binding like `dyn\n+        // Foo<'b, Item = XX>`, the current object-lifetime default\n+        // would be to examine the trait `Foo` to check whether it has\n+        // a lifetime bound declared on `Item`. e.g., if `Foo` is\n+        // declared like so, then the default object lifetime bound in\n+        // `XX` should be `'b`:\n+        //\n+        // ```rust\n+        // trait Foo<'a> {\n+        //   type Item: 'a;\n+        // }\n+        // ```\n+        //\n+        // but if we just have `type Item;`, then it would be\n+        // `'static`. However, we don't get all of this logic correct.\n+        //\n+        // Instead, we do something hacky: if there are no lifetime parameters\n+        // to the trait, then we simply use a default object lifetime\n+        // bound of `'static`, because there is no other possibility. On the other hand,\n+        // if there ARE lifetime parameters, then we require the user to give an\n+        // explicit bound for now.\n+        //\n+        // This is intended to leave room for us to implement the\n+        // correct behavior in the future.\n+        let has_lifetime_parameter = generic_args\n+            .args\n+            .iter()\n+            .any(|arg| match arg {\n+                GenericArg::Lifetime(_) => true,\n+                _ => false,\n+            });\n+\n+        // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n         for b in &generic_args.bindings {\n-            self.visit_assoc_type_binding(b);\n+            let scope = Scope::ObjectLifetimeDefault {\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(Region::Static)\n+                },\n+                s: self.scope,\n+            };\n+            self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n         }\n     }\n \n@@ -2347,6 +2428,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+        debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n+\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2539,6 +2622,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let lifetime = loop {\n@@ -2638,6 +2722,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n+                        hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                            self.tcx.sess.delay_span_bug(\n+                                lt.span,\n+                                \"lowering generated `ImplicitObjectLifetimeDefault` \\\n+                                 outside of an object type\",\n+                            )\n+                        }\n                         hir::LifetimeName::Error => {\n                             // No need to do anything, error already reported.\n                         }"}, {"sha": "ca68b9e31b6b91337e4fa2b555d7c53f0de24f12", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -578,7 +578,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             }\n \n-            hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "5955d9751afbbf3afe57767893c046c1eaa2a590", "filename": "src/test/ui/async-await/issues/issue-62517-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for #62517. We used to ICE when you had an `async\n+// fn` with an `impl Trait` return that mentioned a `dyn Bar` with no\n+// explicit lifetime bound.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![feature(async_await)]\n+\n+trait FirstTrait {}\n+trait SecondTrait {\n+    type Item: ?Sized;\n+}\n+\n+async fn foo(x: &str) -> impl SecondTrait<Item = dyn FirstTrait> {\n+}\n+\n+\n+impl<T> SecondTrait for T {\n+    type Item = dyn FirstTrait;\n+}\n+\n+fn main() { }"}, {"sha": "17fac408151eaeb359771c8c9e8c55b957dd2517", "filename": "src/test/ui/async-await/issues/issue-62517-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for #62517. We used to ICE when you had an `async\n+// fn` with an `impl Trait` return that mentioned a `dyn Bar` with no\n+// explicit lifetime bound.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![feature(async_await)]\n+\n+trait Object {}\n+\n+trait Alpha<Param: ?Sized> {}\n+\n+async fn foo<'a>(_: &'a ()) -> impl Alpha<dyn Object> {}\n+\n+impl<T> Alpha<dyn Object> for T { }\n+\n+fn main() { }"}, {"sha": "3b7141573847f6fe39c554ef505553b6f824d488", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-assoc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,16 @@\n+// Test that we don't get an error with `dyn Bar` in an impl Trait\n+// when there are multiple inputs.  The `dyn Bar` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Foo { type Item: ?Sized; }\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn foo(x: &str, y: &str) -> impl Foo<Item = dyn Bar> { () }\n+\n+fn main() { }"}, {"sha": "e8da52aad0eac01b8a9ddfb16875dcdb3d3b77e3", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-param.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,11 @@\n+// Test that we don't get an error with `dyn Object` in an impl Trait\n+// when there are multiple inputs.  The `dyn Object` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Alpha<Item: ?Sized> {}\n+trait Object {}\n+impl<T> Alpha<dyn Object> for T {}\n+fn alpha(x: &str, y: &str) -> impl Alpha<dyn Object> { () }\n+fn main() { }"}, {"sha": "aad9d89fe2433ecaaa4479c7cc2d1e6672d99dd0", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-ref-assoc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,27 @@\n+// Test that we don't get an error with `dyn Bar` in an impl Trait\n+// when there are multiple inputs.  The `dyn Bar` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Foo {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+fn bar(x: &str) -> &impl Foo<Item = dyn Bar> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "8d34c1b6c2af7a90bcddd6ba5c29384fd7193e6a", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-ref-param.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,23 @@\n+// Test that `impl Alpha<dyn Object>` resets the object-lifetime\n+// default to `'static`.\n+//\n+// check-pass\n+\n+trait Alpha<Item: ?Sized> {\n+    fn item(&self) -> Box<Item> {\n+        panic!()\n+    }\n+}\n+\n+trait Object {}\n+impl<T> Alpha<dyn Object> for T {}\n+fn alpha(x: &str, y: &str) -> impl Alpha<dyn Object> { () }\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+fn bar(x: &str) -> &impl Alpha<dyn Object> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "ea0d0ccbc553270c9fc290f10065a3080571377d", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -6,7 +6,7 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-//~^ ERROR missing lifetime\n+//~^ ERROR not satisfied\n     Ok(())\n }\n "}, {"sha": "228582d0001daafdf6bca1198a862316cc9e1da0", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -1,11 +1,11 @@\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/lifetime-elision-return-type-trait.rs:8:44\n+error[E0277]: the trait bound `std::result::Result<(), _>: Future` is not satisfied\n+  --> $DIR/lifetime-elision-return-type-trait.rs:8:13\n    |\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-   |                                            ^^^^^^^^^ help: consider giving it a 'static lifetime: `dyn Error + 'static`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `std::result::Result<(), _>`\n    |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0106`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7337383e2978425a83715e9fe4a978bc38eb04e0", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,27 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo<'_> for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we should default to `dyn Bar + 'static`, but the current\n+// code forces us into a conservative, hacky path.\n+fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "9dbf7a78ed7a7406ace2e3185c9b1db8a3742d83", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic1.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic1.rs:20:50\n+   |\n+LL | fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+   |                                                  ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a7415174f8a0ca20f3df9378520953e77da2216", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,30 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: 'a + ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo<'_> for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we default to `dyn Bar + 'a`.  Or, we *should*, but the\n+// current code forces us into a conservative, hacky path.\n+fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+\n+    // If it weren't for the conservative path above, we'd expect an\n+    // error here.\n+    is_static(r.item());\n+}"}, {"sha": "d069f52ce47db4ef1cb13fff4d4ca2bf33b910de", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic2.rs:20:50\n+   |\n+LL | fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+   |                                                  ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "51be999a6329d09f85cda3e7a804827eba0765cc", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,23 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we should default to `dyn Bar + 'static`, but the current\n+// code forces us into a conservative, hacky path.\n+fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "9c7b6b98f2e3620375fca614ca63f47114dc634b", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic3.rs:16:36\n+   |\n+LL | fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+   |                                    ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "339f3356bd71ea66f2a1dc1df6130ac63f8cbf30", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-static.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bece1177c07bc528df16bf313eb07a762c0853f7/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs?ref=bece1177c07bc528df16bf313eb07a762c0853f7", "patch": "@@ -0,0 +1,28 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+//\n+// check-pass\n+\n+trait Foo {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we default to `dyn Bar + 'static`, and not `&'x dyn Foo<Item\n+// = dyn Bar + 'x>`.\n+fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}]}