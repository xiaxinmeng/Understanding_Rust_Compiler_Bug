{"sha": "20cb7005b0c1e12383a4c2f9031c5c5f5c907efc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwY2I3MDA1YjBjMWUxMjM4M2E0YzJmOTAzMWM1YzVmNWM5MDdlZmM=", "commit": {"author": {"name": "Nathan Stocks", "email": "nathan.stocks@gmail.com", "date": "2017-04-04T01:15:31Z"}, "committer": {"name": "Nathan Stocks", "email": "nathan.stocks@gmail.com", "date": "2017-04-04T01:15:31Z"}, "message": "Handle options-with-arguments before subcommands such as './x.py -j 10 build' and detect pathological cases like './x.py --option-that-takes-argument clean build'", "tree": {"sha": "8b25ee921099ef7fb13e6d065d67a80c95427daf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b25ee921099ef7fb13e6d065d67a80c95427daf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20cb7005b0c1e12383a4c2f9031c5c5f5c907efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20cb7005b0c1e12383a4c2f9031c5c5f5c907efc", "html_url": "https://github.com/rust-lang/rust/commit/20cb7005b0c1e12383a4c2f9031c5c5f5c907efc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20cb7005b0c1e12383a4c2f9031c5c5f5c907efc/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "1e5389853ca3a99a338f3a40cbb96150f711410c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5389853ca3a99a338f3a40cbb96150f711410c", "html_url": "https://github.com/rust-lang/rust/commit/1e5389853ca3a99a338f3a40cbb96150f711410c"}], "stats": {"total": 60, "additions": 44, "deletions": 16}, "files": [{"sha": "3af3b76163c1e129403360f29e111cbc21bb9f3a", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/20cb7005b0c1e12383a4c2f9031c5c5f5c907efc/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20cb7005b0c1e12383a4c2f9031c5c5f5c907efc/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=20cb7005b0c1e12383a4c2f9031c5c5f5c907efc", "patch": "@@ -119,7 +119,13 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n         let mut possible_subcommands = args.iter().collect::<Vec<_>>();\n-        possible_subcommands.retain(|&s| !s.starts_with('-'));\n+        possible_subcommands.retain(|&s|\n+                                           (s == \"build\")\n+                                        || (s == \"test\")\n+                                        || (s == \"bench\")\n+                                        || (s == \"doc\")\n+                                        || (s == \"clean\")\n+                                        || (s == \"dist\"));\n         let subcommand = match possible_subcommands.first() {\n             Some(s) => s,\n             None => {\n@@ -129,7 +135,43 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n             }\n         };\n \n-        // Some subcommands have specific arguments help text\n+        // Some subcommands get extra options\n+        match subcommand.as_str() {\n+            \"test\"  => opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"),\n+            \"bench\" => opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"),\n+            \"dist\"  => opts.optflag(\"\", \"install\", \"run installer as well\"),\n+            _ => { }\n+        };\n+\n+        // Done specifying what options are possible, so do the getopts parsing\n+        let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n+            // Invalid argument/option format\n+            println!(\"\\n{}\\n\", e);\n+            usage(1, &opts, &subcommand_help, &extra_help);\n+        });\n+        // Extra sanity check to make sure we didn't hit this crazy corner case:\n+        //\n+        //     ./x.py --frobulate clean build\n+        //            ^-- option  ^     ^- actual subcommand\n+        //                        \\_ arg to option could be mistaken as subcommand\n+        let mut pass_sanity_check = true;\n+        match matches.free.get(0) {\n+            Some(check_subcommand) => {\n+                if &check_subcommand != subcommand {\n+                    pass_sanity_check = false;\n+                }\n+            },\n+            None => {\n+                pass_sanity_check = false;\n+            }\n+        }\n+        if !pass_sanity_check {\n+            println!(\"{}\\n\", subcommand_help);\n+            println!(\"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n+                      You may need to move some options to after the subcommand.\\n\");\n+            process::exit(1);\n+        }\n+        // Extra help text for some commands\n         match subcommand.as_str() {\n             \"build\" => {\n                 subcommand_help.push_str(\"\\n\n@@ -152,7 +194,6 @@ Arguments:\n         ./x.py build --stage 1 src/libtest\");\n             }\n             \"test\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 subcommand_help.push_str(\"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n@@ -168,9 +209,6 @@ Arguments:\n         ./x.py test\n         ./x.py test --stage 1\");\n             }\n-            \"bench\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-            }\n             \"doc\" => {\n                 subcommand_help.push_str(\"\\n\n Arguments:\n@@ -186,18 +224,8 @@ Arguments:\n         ./x.py doc\n         ./x.py doc --stage 1\");\n             }\n-            \"dist\" => {\n-                opts.optflag(\"\", \"install\", \"run installer as well\");\n-            }\n             _ => { }\n         };\n-\n-        // Done specifying what options are possible, so do the getopts parsing\n-        let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n-            // Invalid argument/option format\n-            println!(\"\\n{}\\n\", e);\n-            usage(1, &opts, &subcommand_help, &extra_help);\n-        });\n         // Get any optional paths which occur after the subcommand\n         let cwd = t!(env::current_dir());\n         let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();"}]}