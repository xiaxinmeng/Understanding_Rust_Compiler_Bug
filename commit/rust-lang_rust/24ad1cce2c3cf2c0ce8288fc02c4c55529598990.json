{"sha": "24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YWQxY2NlMmMzY2YyYzBjZTgyODhmYzAyYzRjNTU1Mjk1OTg5OTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-02T17:54:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-02T17:56:37Z"}, "message": "Avoid premature pessimization\n\nThe extra allocation for message should not matter here at all, but\nusing a static string is just as ergonomic, if not more, and there's\nno reason to write deliberately slow code", "tree": {"sha": "04241d931e7d2f57799a4ff28a11f020090def74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04241d931e7d2f57799a4ff28a11f020090def74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "html_url": "https://github.com/rust-lang/rust/commit/24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "856e4ba126ae776753f38c00593c02c4f43be510", "url": "https://api.github.com/repos/rust-lang/rust/commits/856e4ba126ae776753f38c00593c02c4f43be510", "html_url": "https://github.com/rust-lang/rust/commit/856e4ba126ae776753f38c00593c02c4f43be510"}], "stats": {"total": 67, "additions": 34, "deletions": 33}, "files": [{"sha": "18dad2ea316650cba9a1deba14ff3716cdb66eef", "filename": "crates/ra_ide/src/change.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/crates%2Fra_ide%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/crates%2Fra_ide%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fchange.rs?ref=24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "patch": "@@ -145,6 +145,8 @@ impl LibraryData {\n         root_id: SourceRootId,\n         files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n     ) -> LibraryData {\n+        let _p = profile(\"LibraryData::prepare\");\n+\n         #[cfg(not(feature = \"wasm\"))]\n         let iter = files.par_iter();\n         #[cfg(feature = \"wasm\")]"}, {"sha": "508fe08c034f2b143cd24787fb6a2d3a14c68af5", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "patch": "@@ -403,7 +403,6 @@ fn loop_turn(\n         let sender = libdata_sender.clone();\n         pool.execute(move || {\n             log::info!(\"indexing {:?} ... \", root);\n-            let _p = profile(&format!(\"indexed {:?}\", root));\n             let data = LibraryData::prepare(root, files);\n             sender.send(data).unwrap();\n         });"}, {"sha": "d38ff397e33294a5cd1a1b7d45d114e59dc0f9c1", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ad1cce2c3cf2c0ce8288fc02c4c55529598990/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=24ad1cce2c3cf2c0ce8288fc02c4c55529598990", "patch": "@@ -9,7 +9,6 @@ use std::{\n     collections::BTreeMap,\n     collections::HashSet,\n     io::{stderr, Write},\n-    mem,\n     sync::{\n         atomic::{AtomicBool, Ordering},\n         RwLock,\n@@ -50,6 +49,8 @@ pub fn set_filter(f: Filter) {\n     *old = filter_data;\n }\n \n+pub type Label = &'static str;\n+\n /// This function starts a profiling scope in the current execution stack with a given description.\n /// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n /// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n@@ -77,10 +78,10 @@ pub fn set_filter(f: Filter) {\n ///  0ms - profile\n ///      0ms - profile2\n /// ```\n-pub fn profile(desc: &str) -> Profiler {\n-    assert!(!desc.is_empty());\n+pub fn profile(label: Label) -> Profiler {\n+    assert!(!label.is_empty());\n     if !PROFILING_ENABLED.load(Ordering::Relaxed) {\n-        return Profiler { desc: None };\n+        return Profiler { label: None };\n     }\n \n     PROFILE_STACK.with(|stack| {\n@@ -93,35 +94,35 @@ pub fn profile(desc: &str) -> Profiler {\n             };\n         }\n         if stack.starts.len() > stack.filter_data.depth {\n-            return Profiler { desc: None };\n+            return Profiler { label: None };\n         }\n         let allowed = &stack.filter_data.allowed;\n-        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(desc) {\n-            return Profiler { desc: None };\n+        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n+            return Profiler { label: None };\n         }\n \n         stack.starts.push(Instant::now());\n-        Profiler { desc: Some(desc.to_string()) }\n+        Profiler { label: Some(label) }\n     })\n }\n \n-pub fn print_time(desc: &str) -> impl Drop + '_ {\n-    struct Guard<'a> {\n-        desc: &'a str,\n+pub fn print_time(label: Label) -> impl Drop {\n+    struct Guard {\n+        label: Label,\n         start: Instant,\n     }\n \n-    impl Drop for Guard<'_> {\n+    impl Drop for Guard {\n         fn drop(&mut self) {\n-            eprintln!(\"{}: {:?}\", self.desc, self.start.elapsed())\n+            eprintln!(\"{}: {:?}\", self.label, self.start.elapsed())\n         }\n     }\n \n-    Guard { desc, start: Instant::now() }\n+    Guard { label, start: Instant::now() }\n }\n \n pub struct Profiler {\n-    desc: Option<String>,\n+    label: Option<Label>,\n }\n \n pub struct Filter {\n@@ -174,7 +175,7 @@ struct ProfileStack {\n struct Message {\n     level: usize,\n     duration: Duration,\n-    message: String,\n+    label: Label,\n }\n \n impl ProfileStack {\n@@ -200,14 +201,13 @@ thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(Profile\n impl Drop for Profiler {\n     fn drop(&mut self) {\n         match self {\n-            Profiler { desc: Some(desc) } => {\n+            Profiler { label: Some(label) } => {\n                 PROFILE_STACK.with(|stack| {\n                     let mut stack = stack.borrow_mut();\n                     let start = stack.starts.pop().unwrap();\n                     let duration = start.elapsed();\n                     let level = stack.starts.len();\n-                    let message = mem::replace(desc, String::new());\n-                    stack.messages.push(Message { level, duration, message });\n+                    stack.messages.push(Message { level, duration, label: label });\n                     if level == 0 {\n                         let stdout = stderr();\n                         let longer_than = stack.filter_data.longer_than;\n@@ -221,7 +221,7 @@ impl Drop for Profiler {\n                     }\n                 });\n             }\n-            Profiler { desc: None } => (),\n+            Profiler { label: None } => (),\n         }\n     }\n }\n@@ -244,7 +244,7 @@ fn print_for_idx(\n ) {\n     let current = &msgs[current_idx];\n     let current_indent = \"    \".repeat(current.level);\n-    writeln!(out, \"{}{:5}ms - {}\", current_indent, current.duration.as_millis(), current.message)\n+    writeln!(out, \"{}{:5}ms - {}\", current_indent, current.duration.as_millis(), current.label)\n         .expect(\"printing profiling info\");\n \n     let longer_than_millis = longer_than.as_millis();\n@@ -257,7 +257,7 @@ fn print_for_idx(\n         if child.duration.as_millis() > longer_than_millis {\n             print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n         } else {\n-            let pair = short_children.entry(&child.message).or_insert((Duration::default(), 0));\n+            let pair = short_children.entry(child.label).or_insert((Duration::default(), 0));\n             pair.0 += child.duration;\n             pair.1 += 1;\n         }\n@@ -409,9 +409,9 @@ mod tests {\n     fn test_longer_than() {\n         let mut result = vec![];\n         let msgs = vec![\n-            Message { level: 1, duration: Duration::from_nanos(3), message: \"bar\".to_owned() },\n-            Message { level: 1, duration: Duration::from_nanos(2), message: \"bar\".to_owned() },\n-            Message { level: 0, duration: Duration::from_millis(1), message: \"foo\".to_owned() },\n+            Message { level: 1, duration: Duration::from_nanos(3), label: \"bar\" },\n+            Message { level: 1, duration: Duration::from_nanos(2), label: \"bar\" },\n+            Message { level: 0, duration: Duration::from_millis(1), label: \"foo\" },\n         ];\n         print(&msgs, Duration::from_millis(0), &mut result);\n         // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n@@ -426,8 +426,8 @@ mod tests {\n     fn test_unaccounted_for_topmost() {\n         let mut result = vec![];\n         let msgs = vec![\n-            Message { level: 1, duration: Duration::from_millis(2), message: \"bar\".to_owned() },\n-            Message { level: 0, duration: Duration::from_millis(5), message: \"foo\".to_owned() },\n+            Message { level: 1, duration: Duration::from_millis(2), label: \"bar\" },\n+            Message { level: 0, duration: Duration::from_millis(5), label: \"foo\" },\n         ];\n         print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n@@ -445,11 +445,11 @@ mod tests {\n     fn test_unaccounted_for_multiple_levels() {\n         let mut result = vec![];\n         let msgs = vec![\n-            Message { level: 2, duration: Duration::from_millis(3), message: \"baz\".to_owned() },\n-            Message { level: 1, duration: Duration::from_millis(5), message: \"bar\".to_owned() },\n-            Message { level: 2, duration: Duration::from_millis(2), message: \"baz\".to_owned() },\n-            Message { level: 1, duration: Duration::from_millis(4), message: \"bar\".to_owned() },\n-            Message { level: 0, duration: Duration::from_millis(9), message: \"foo\".to_owned() },\n+            Message { level: 2, duration: Duration::from_millis(3), label: \"baz\" },\n+            Message { level: 1, duration: Duration::from_millis(5), label: \"bar\" },\n+            Message { level: 2, duration: Duration::from_millis(2), label: \"baz\" },\n+            Message { level: 1, duration: Duration::from_millis(4), label: \"bar\" },\n+            Message { level: 0, duration: Duration::from_millis(9), label: \"foo\" },\n         ];\n         print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!("}]}