{"sha": "1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNTdlNDg0MTE1N2Q1Y2JkNGM0ZTIyMDE4ZjkzYmQxODAxYzk4YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-23T18:42:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-23T18:42:20Z"}, "message": "Auto merge of #56186 - kennytm:rollup, r=kennytm\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #55767 (Disable some pretty-printers when gdb is rust-enabled)\n - #55838 (Fix #[cfg] for step impl on ranges)\n - #55869 (Add std::iter::unfold)\n - #55945 (Ensure that the argument to `static_assert` is a `bool`)\n - #56022 (When popping in CTFE, perform validation before jumping to next statement to have a better span for the error)\n - #56048 (Add rustc_codegen_ssa to sysroot)\n - #56091 (Fix json output in the self-profiler)\n - #56097 (Fix invalid bitcast taking bool out of a union represented as a scalar)\n - #56116 (ci: Download clang/lldb from tarballs)\n - #56120 (Add unstable Literal::subspan().)\n - #56154 (Pass additional linker flags when targeting Fuchsia)\n - #56162 (std::str Adapt documentation to reality)\n - #56163 ([master] Backport 1.30.1 release notes)\n - #56168 (Fix the tracking issue for hash_raw_entry)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1c6b53efd2d50c15afb6896ba713bf1bf10f8412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c6b53efd2d50c15afb6896ba713bf1bf10f8412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "html_url": "https://github.com/rust-lang/rust/commit/1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "821bad3a5b13862e9fbfae35b446ab91a976a75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/821bad3a5b13862e9fbfae35b446ab91a976a75e", "html_url": "https://github.com/rust-lang/rust/commit/821bad3a5b13862e9fbfae35b446ab91a976a75e"}, {"sha": "36189a2739f22dd03a8067544c42ebc2288fbeb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/36189a2739f22dd03a8067544c42ebc2288fbeb1", "html_url": "https://github.com/rust-lang/rust/commit/36189a2739f22dd03a8067544c42ebc2288fbeb1"}], "stats": {"total": 702, "additions": 606, "deletions": 96}, "files": [{"sha": "f7d5a1a507babca2bbba8a8605ccdbcd6a718773", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -2073,6 +2073,7 @@ dependencies = [\n name = \"rustc-main\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustc_target 0.0.0\",\n ]\n@@ -2169,18 +2170,34 @@ dependencies = [\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n ]\n \n [[package]]\n name = \"rustc_codegen_ssa\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_allocator 0.0.0\",\n+ \"rustc_apfloat 0.0.0\",\n+ \"rustc_codegen_utils 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_fs_util 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_target 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "da09af3edfe8a534cc0713aae8f1d59a3b47698a", "filename": "RELEASES.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -74,6 +74,14 @@ Cargo\n [cargo-rename-reference]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml\n [const-reference]: https://doc.rust-lang.org/reference/items/functions.html#const-functions\n \n+Version 1.30.1 (2018-11-08)\n+===========================\n+\n+- [Fixed overflow ICE in rustdoc][54199]\n+- [Cap Cargo progress bar width at 60 in MSYS terminals][cargo/6122]\n+\n+[54199]: https://github.com/rust-lang/rust/pull/54199\n+[cargo/6122]: https://github.com/rust-lang/cargo/pull/6122\n \n Version 1.30.0 (2018-10-25)\n =========================="}, {"sha": "8345ab3bc33768e0565ff601f079bb091b17cc78", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -55,6 +55,7 @@ function fetch_submodule {\n }\n \n included=\"src/llvm src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n+included=\"$included src/tools/lld src/tools/clang src/tools/lldb\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n modules=($modules)\n use_git=\"\""}, {"sha": "4c7465365472367cdb8b7e903943c2d5eaa2b123", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -18,6 +18,8 @@\n if sys.version_info[0] >= 3:\n     xrange = range\n \n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string = True)\n+\n #===============================================================================\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n@@ -99,27 +101,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     val = GdbValue(gdb_val)\n     type_kind = val.type.get_type_kind()\n \n-    if type_kind == rustpp.TYPE_KIND_EMPTY:\n-        return RustEmptyPrinter(val)\n-\n-    if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n-\n-    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n-        return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n-\n     if type_kind == rustpp.TYPE_KIND_SLICE:\n         return RustSlicePrinter(val)\n \n-    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n-        return RustStringSlicePrinter(val)\n-\n     if type_kind == rustpp.TYPE_KIND_STD_VEC:\n         return RustStdVecPrinter(val)\n \n@@ -138,6 +122,29 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     if type_kind == rustpp.TYPE_KIND_OS_STRING:\n         return RustOsStringPrinter(val)\n \n+    # Checks after this point should only be for \"compiler\" types --\n+    # things that gdb's Rust language support knows about.\n+    if rust_enabled:\n+        return None\n+\n+    if type_kind == rustpp.TYPE_KIND_EMPTY:\n+        return RustEmptyPrinter(val)\n+\n+    if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n+        return RustStructPrinter(val,\n+                                 omit_first_field = False,\n+                                 omit_type_name = False,\n+                                 is_tuple_like = False)\n+\n+    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n+        return RustStructPrinter(val,\n+                                 omit_first_field = True,\n+                                 omit_type_name = False,\n+                                 is_tuple_like = False)\n+\n+    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n+        return RustStringSlicePrinter(val)\n+\n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return RustStructPrinter(val,\n                                  omit_first_field = False,"}, {"sha": "62e1f9fcb640c7c59e46b71e90559568b9ea5934", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -112,10 +112,10 @@\n //!\n //!     // next() is the only required method\n //!     fn next(&mut self) -> Option<usize> {\n-//!         // increment our count. This is why we started at zero.\n+//!         // Increment our count. This is why we started at zero.\n //!         self.count += 1;\n //!\n-//!         // check to see if we've finished counting or not.\n+//!         // Check to see if we've finished counting or not.\n //!         if self.count < 6 {\n //!             Some(self.count)\n //!         } else {\n@@ -339,6 +339,8 @@ pub use self::sources::{RepeatWith, repeat_with};\n pub use self::sources::{Empty, empty};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub use self::sources::{Once, once};\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub use self::sources::{Unfold, unfold, Successors, successors};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};"}, {"sha": "f0fd07b43cae0522ab75b7fde6612e06cb8f6948", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -166,14 +166,14 @@ macro_rules! step_impl_no_between {\n }\n \n step_impl_unsigned!(usize u8 u16);\n-#[cfg(not(target_pointer_witdth = \"16\"))]\n+#[cfg(not(target_pointer_width = \"16\"))]\n step_impl_unsigned!(u32);\n-#[cfg(target_pointer_witdth = \"16\")]\n+#[cfg(target_pointer_width = \"16\")]\n step_impl_no_between!(u32);\n step_impl_signed!([isize: usize] [i8: u8] [i16: u16]);\n-#[cfg(not(target_pointer_witdth = \"16\"))]\n+#[cfg(not(target_pointer_width = \"16\"))]\n step_impl_signed!([i32: u32]);\n-#[cfg(target_pointer_witdth = \"16\")]\n+#[cfg(target_pointer_width = \"16\")]\n step_impl_no_between!(i32);\n #[cfg(target_pointer_width = \"64\")]\n step_impl_unsigned!(u64);"}, {"sha": "f6a4a7a6fa80a36bc617ca6f6ed2430309d085b9", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -386,3 +386,164 @@ impl<T> FusedIterator for Once<T> {}\n pub fn once<T>(value: T) -> Once<T> {\n     Once { inner: Some(value).into_iter() }\n }\n+\n+/// Creates a new iterator where each iteration calls the provided closure\n+/// `F: FnMut(&mut St) -> Option<T>`.\n+///\n+/// This allows creating a custom iterator with any behavior\n+/// without using the more verbose syntax of creating a dedicated type\n+/// and implementing the `Iterator` trait for it.\n+///\n+/// In addition to its captures and environment,\n+/// the closure is given a mutable reference to some state\n+/// that is preserved across iterations.\n+/// That state starts as the given `initial_state` value.\n+///\n+/// Note that the `Unfold` iterator doesn\u2019t make assumptions about the behavior of the closure,\n+/// and therefore conservatively does not implement [`FusedIterator`],\n+/// or override [`Iterator::size_hint`] from its default `(0, None)`.\n+///\n+/// [`FusedIterator`]: trait.FusedIterator.html\n+/// [`Iterator::size_hint`]: trait.Iterator.html#method.size_hint\n+///\n+/// # Examples\n+///\n+/// Let\u2019s re-implement the counter iterator from [module-level documentation]:\n+///\n+/// [module-level documentation]: index.html\n+///\n+/// ```\n+/// #![feature(iter_unfold)]\n+/// let counter = std::iter::unfold(0, |count| {\n+///     // Increment our count. This is why we started at zero.\n+///     *count += 1;\n+///\n+///     // Check to see if we've finished counting or not.\n+///     if *count < 6 {\n+///         Some(*count)\n+///     } else {\n+///         None\n+///     }\n+/// });\n+/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub fn unfold<St, T, F>(initial_state: St, f: F) -> Unfold<St, F>\n+    where F: FnMut(&mut St) -> Option<T>\n+{\n+    Unfold {\n+        state: initial_state,\n+        f,\n+    }\n+}\n+\n+/// An iterator where each iteration calls the provided closure `F: FnMut(&mut St) -> Option<T>`.\n+///\n+/// This `struct` is created by the [`unfold`] function.\n+/// See its documentation for more.\n+///\n+/// [`unfold`]: fn.unfold.html\n+#[derive(Clone)]\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub struct Unfold<St, F> {\n+    state: St,\n+    f: F,\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<St, T, F> Iterator for Unfold<St, F>\n+    where F: FnMut(&mut St) -> Option<T>\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        (self.f)(&mut self.state)\n+    }\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<St: fmt::Debug, F> fmt::Debug for Unfold<St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Unfold\")\n+            .field(\"state\", &self.state)\n+            .finish()\n+    }\n+}\n+\n+/// Creates a new iterator where each successive item is computed based on the preceding one.\n+///\n+/// The iterator starts with the given first item (if any)\n+/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n+///\n+/// ```\n+/// #![feature(iter_unfold)]\n+/// use std::iter::successors;\n+///\n+/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+/// ```\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n+    where F: FnMut(&T) -> Option<T>\n+{\n+    // If this function returned `impl Iterator<Item=T>`\n+    // it could be based on `unfold` and not need a dedicated type.\n+    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n+    Successors {\n+        next: first,\n+        succ,\n+    }\n+}\n+\n+/// An new iterator where each successive item is computed based on the preceding one.\n+///\n+/// This `struct` is created by the [`successors`] function.\n+/// See its documentation for more.\n+///\n+/// [`successors`]: fn.successors.html\n+#[derive(Clone)]\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+pub struct Successors<T, F> {\n+    next: Option<T>,\n+    succ: F,\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<T, F> Iterator for Successors<T, F>\n+    where F: FnMut(&T) -> Option<T>\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.next.take().map(|item| {\n+            self.next = (self.succ)(&item);\n+            item\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.next.is_some() {\n+            (1, None)\n+        } else {\n+            (0, Some(0))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<T, F> FusedIterator for Successors<T, F>\n+    where F: FnMut(&T) -> Option<T>\n+{}\n+\n+#[unstable(feature = \"iter_unfold\", issue = \"55977\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Successors\")\n+            .field(\"next\", &self.next)\n+            .finish()\n+    }\n+}"}, {"sha": "89efa120a6faba670b59b8cb29eb16da35d3f4b6", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -1424,10 +1424,8 @@ fn contains_nonascii(x: usize) -> bool {\n     (x & NONASCII_MASK) != 0\n }\n \n-/// Walks through `iter` checking that it's a valid UTF-8 sequence,\n-/// returning `true` in that case, or, if it is invalid, `false` with\n-/// `iter` reset such that it is pointing at the first byte in the\n-/// invalid sequence.\n+/// Walks through `v` checking that it's a valid UTF-8 sequence,\n+/// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n #[inline]\n fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n     let mut index = 0;"}, {"sha": "495483db5551cc5ff8ff792605e83f59ab8c744a", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -1759,6 +1759,17 @@ fn test_repeat_with_take_collect() {\n     assert_eq!(v, vec![1, 2, 4, 8, 16]);\n }\n \n+#[test]\n+fn test_successors() {\n+    let mut powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+    assert_eq!(powers_of_10.by_ref().collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+    assert_eq!(powers_of_10.next(), None);\n+\n+    let mut empty = successors(None::<u32>, |_| unimplemented!());\n+    assert_eq!(empty.next(), None);\n+    assert_eq!(empty.next(), None);\n+}\n+\n #[test]\n fn test_fuse() {\n     let mut it = 0..3;"}, {"sha": "7d62b4fa90f203cbb4f6c682cc1a7666194ffa63", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -19,6 +19,7 @@\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]\n+#![feature(iter_unfold)]\n #![feature(pattern)]\n #![feature(range_is_empty)]\n #![feature(raw)]"}, {"sha": "e9d2d97e3646bada963ff2b1a8c48c839a9735aa", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -50,6 +50,7 @@ mod diagnostic;\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n pub use diagnostic::{Diagnostic, Level, MultiSpan};\n \n+use std::ops::{Bound, RangeBounds};\n use std::{ascii, fmt, iter};\n use std::path::PathBuf;\n use rustc_data_structures::sync::Lrc;\n@@ -59,7 +60,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream::{self, DelimSpan};\n-use syntax_pos::{Pos, FileName};\n+use syntax_pos::{Pos, FileName, BytePos};\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n@@ -1168,6 +1169,50 @@ impl Literal {\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n+\n+    /// Returns a `Span` that is a subset of `self.span()` containing only the\n+    /// source bytes in range `range`. Returns `None` if the would-be trimmed\n+    /// span is outside the bounds of `self`.\n+    // FIXME(SergioBenitez): check that the byte range starts and ends at a\n+    // UTF-8 boundary of the source. otherwise, it's likely that a panic will\n+    // occur elsewhere when the source text is printed.\n+    // FIXME(SergioBenitez): there is no way for the user to know what\n+    // `self.span()` actually maps to, so this method can currently only be\n+    // called blindly. For example, `to_string()` for the character 'c' returns\n+    // \"'\\u{63}'\"; there is no way for the user to know whether the source text\n+    // was 'c' or whether it was '\\u{63}'.\n+    #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n+    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n+        let inner = self.span().0;\n+        let length = inner.hi().to_usize() - inner.lo().to_usize();\n+\n+        let start = match range.start_bound() {\n+            Bound::Included(&lo) => lo,\n+            Bound::Excluded(&lo) => lo + 1,\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match range.end_bound() {\n+            Bound::Included(&hi) => hi + 1,\n+            Bound::Excluded(&hi) => hi,\n+            Bound::Unbounded => length,\n+        };\n+\n+        // Bounds check the values, preventing addition overflow and OOB spans.\n+        if start > u32::max_value() as usize\n+            || end > u32::max_value() as usize\n+            || (u32::max_value() - start as u32) < inner.lo().to_u32()\n+            || (u32::max_value() - end as u32) < inner.lo().to_u32()\n+            || start >= end\n+            || end > length\n+        {\n+            return None;\n+        }\n+\n+        let new_lo = inner.lo() + BytePos::from_usize(start);\n+        let new_hi = inner.lo() + BytePos::from_usize(end);\n+        Some(Span(inner.with_lo(new_lo).with_hi(new_hi)))\n+    }\n }\n \n /// Prints the literal as a string that should be losslessly convertible"}, {"sha": "dfd3f2ee184cebd87cb0490e06783bed66178cec", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -93,16 +93,27 @@ macro_rules! define_categories {\n                 $(\n                     let (hits, total) = self.query_counts.$name;\n \n+                    //normalize hits to 0%\n+                    let hit_percent =\n+                        if total > 0 {\n+                            ((hits as f32) / (total as f32)) * 100.0\n+                        } else {\n+                            0.0\n+                        };\n+\n                     json.push_str(&format!(\n                         \"{{ \\\"category\\\": {}, \\\"time_ms\\\": {},\n-                            \\\"query_count\\\": {}, \\\"query_hits\\\": {} }}\",\n+                            \\\"query_count\\\": {}, \\\"query_hits\\\": {} }},\",\n                         stringify!($name),\n                         self.times.$name / 1_000_000,\n                         total,\n-                        format!(\"{:.2}\", (((hits as f32) / (total as f32)) * 100.0))\n+                        format!(\"{:.2}\", hit_percent)\n                     ));\n                 )*\n \n+                //remove the trailing ',' character\n+                json.pop();\n+\n                 json.push(']');\n \n                 json"}, {"sha": "b711502b14b7fb1af4222d0859fbf82a03e75d06", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -13,7 +13,6 @@ test = false\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n rustc-demangle = \"0.1.4\"\n-rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n memmap = \"0.6\"\n "}, {"sha": "8380b7136213882b905f4b43202ea2aacfe02419", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -19,7 +19,7 @@ use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n use rustc::session::config::{self, DebugInfo, OutputFilenames, OutputType, PrintRequest};\n-use rustc::session::config::{RUST_CGU_EXT, Lto};\n+use rustc::session::config::{RUST_CGU_EXT, Lto, Sanitizer};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n@@ -491,6 +491,14 @@ fn link_natively(sess: &Session,\n     }\n     cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n \n+    if sess.target.target.options.is_like_fuchsia {\n+        let prefix = match sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => \"asan/\",\n+            _ => \"\",\n+        };\n+        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n+    }\n+\n     let pre_link_objects = if crate_type == config::CrateType::Executable {\n         &sess.target.target.options.pre_link_objects_exe\n     } else {"}, {"sha": "7b1c7cfb56f4cb19029a6e2970df866109574487", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -6,10 +6,29 @@ version = \"0.0.0\"\n [lib]\n name = \"rustc_codegen_ssa\"\n path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+bitflags = \"1.0.4\"\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n rustc-demangle = \"0.1.4\"\n memmap = \"0.6\"\n+log = \"0.4.5\"\n+libc = \"0.2.43\"\n+jobserver = \"0.1.11\"\n+\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc = { path = \"../librustc\" }\n+rustc_allocator = { path = \"../librustc_allocator\" }\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n+rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\"}\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_fs_util = { path = \"../librustc_fs_util\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "92d0219caf06bf2e9fd036782380c4d5e7ee695b", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -244,13 +244,24 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         };\n \n         // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+        // Bools in union fields needs to be truncated.\n+        let to_immediate_or_cast = |bx: &mut Bx, val, ty| {\n+            if ty == bx.cx().type_i1() {\n+                bx.trunc(val, ty)\n+            } else {\n+                bx.bitcast(val, ty)\n+            }\n+        };\n+\n         match val {\n             OperandValue::Immediate(ref mut llval) => {\n-                *llval = bx.bitcast(*llval, bx.cx().immediate_backend_type(field));\n+                *llval = to_immediate_or_cast(bx, *llval, bx.cx().immediate_backend_type(field));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bx.bitcast(*a, bx.cx().scalar_pair_element_backend_type(field, 0, true));\n-                *b = bx.bitcast(*b, bx.cx().scalar_pair_element_backend_type(field, 1, true));\n+                *a = to_immediate_or_cast(bx, *a, bx.cx()\n+                    .scalar_pair_element_backend_type(field, 0, true));\n+                *b = to_immediate_or_cast(bx, *b, bx.cx()\n+                    .scalar_pair_element_backend_type(field, 1, true));\n             }\n             OperandValue::Ref(..) => bug!()\n         }"}, {"sha": "286a374b280b146a10eaf4ef8583413248d919ce", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -11,11 +11,12 @@\n /// A simple static assertion macro. The first argument should be a unique\n /// ALL_CAPS identifier that describes the condition.\n #[macro_export]\n+#[allow_internal_unstable]\n macro_rules! static_assert {\n     ($name:ident: $test:expr) => {\n         // Use the bool to access an array such that if the bool is false, the access\n         // is out-of-bounds.\n         #[allow(dead_code)]\n-        static $name: () = [()][!$test as usize];\n+        static $name: () = [()][!($test: bool) as usize];\n     }\n }"}, {"sha": "2eb5f7c853f8c97447332f6836e928734387f001", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -504,15 +504,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n+        // Abort early if we do not want to clean up: We also avoid validation in that case,\n+        // because this is CTFE and the final value will be thoroughly validated anyway.\n         match frame.return_to_block {\n-            StackPopCleanup::Goto(block) => {\n-                self.goto_block(block)?;\n-            }\n+            StackPopCleanup::Goto(_) => {},\n             StackPopCleanup::None { cleanup } => {\n                 if !cleanup {\n-                    // Leak the locals. Also skip validation, this is only used by\n-                    // static/const computation which does its own (stronger) final\n-                    // validation.\n+                    assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n+                    // Leak the locals, skip validation.\n                     return Ok(());\n                 }\n             }\n@@ -521,7 +520,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         for local in frame.locals {\n             self.deallocate_local(local)?;\n         }\n-        // Validate the return value.\n+        // Validate the return value. Do this after deallocating so that we catch dangling\n+        // references.\n         if let Some(return_place) = frame.return_place {\n             if M::enforce_validity(self) {\n                 // Data got changed, better make sure it matches the type!\n@@ -542,6 +542,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // Uh, that shouldn't happen... the function did not intend to return\n             return err!(Unreachable);\n         }\n+        // Jump to new block -- *after* validation so that the spans make more sense.\n+        match frame.return_to_block {\n+            StackPopCleanup::Goto(block) => {\n+                self.goto_block(block)?;\n+            }\n+            StackPopCleanup::None { .. } => {}\n+        }\n \n         if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n             debug!(\"CONTINUING({}) {}\", self.cur_frame(), self.frame().instance);"}, {"sha": "1d0474e1a9a90eb5bd5c82ca9da34cded9349a62", "filename": "src/librustc_target/spec/fuchsia_base.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -12,9 +12,11 @@ use spec::{LldFlavor, LinkArgs, LinkerFlavor, TargetOptions};\n use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n-    let mut args = LinkArgs::new();\n-    args.insert(LinkerFlavor::Lld(LldFlavor::Ld), vec![\n-        \"--build-id\".to_string(), \"--hash-style=gnu\".to_string(),\n+    let mut pre_link_args = LinkArgs::new();\n+    pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Ld), vec![\n+        \"--build-id\".to_string(),\n+        \"--eh-frame-hdr\".to_string(),\n+        \"--hash-style=gnu\".to_string(),\n         \"-z\".to_string(), \"rodynamic\".to_string(),\n     ]);\n \n@@ -24,9 +26,13 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         target_family: Some(\"unix\".to_string()),\n+        is_like_fuchsia: true,\n         linker_is_gnu: true,\n         has_rpath: false,\n-        pre_link_args: args,\n+        pre_link_args: pre_link_args,\n+        pre_link_objects_exe: vec![\n+            \"Scrt1.o\".to_string()\n+        ],\n         position_independent_executables: true,\n         has_elf_tls: true,\n         .. Default::default()"}, {"sha": "3285ccfd6c12d6021250d9efae6d52144ca86c30", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -560,6 +560,8 @@ pub struct TargetOptions {\n     /// Emscripten toolchain.\n     /// Defaults to false.\n     pub is_like_emscripten: bool,\n+    /// Whether the target toolchain is like Fuchsia's.\n+    pub is_like_fuchsia: bool,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n     /// The MinGW toolchain has a known issue that prevents it from correctly\n@@ -729,6 +731,7 @@ impl Default for TargetOptions {\n             is_like_android: false,\n             is_like_emscripten: false,\n             is_like_msvc: false,\n+            is_like_fuchsia: false,\n             linker_is_gnu: false,\n             allows_weak_linkage: true,\n             has_rpath: false,\n@@ -1028,6 +1031,7 @@ impl Target {\n         key!(is_like_msvc, bool);\n         key!(is_like_emscripten, bool);\n         key!(is_like_android, bool);\n+        key!(is_like_fuchsia, bool);\n         key!(linker_is_gnu, bool);\n         key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n@@ -1238,6 +1242,7 @@ impl ToJson for Target {\n         target_option_val!(is_like_msvc);\n         target_option_val!(is_like_emscripten);\n         target_option_val!(is_like_android);\n+        target_option_val!(is_like_fuchsia);\n         target_option_val!(linker_is_gnu);\n         target_option_val!(allows_weak_linkage);\n         target_option_val!(has_rpath);"}, {"sha": "7c717d832fa540145e3001c79dd6d1334908cdae", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -1571,7 +1571,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// so that the map now contains keys which compare equal, search may start\n     /// acting erratically, with two keys randomly masking each other. Implementations\n     /// are free to assume this doesn't happen (within the limits of memory-safety).\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {\n         self.reserve(1);\n         RawEntryBuilderMut { map: self }\n@@ -1592,7 +1592,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// `get` should be preferred.\n     ///\n     /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn raw_entry(&self) -> RawEntryBuilder<K, V, S> {\n         RawEntryBuilder { map: self }\n     }\n@@ -1844,7 +1844,7 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n ///\n /// [`HashMap::raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a mut HashMap<K, V, S>,\n }\n@@ -1858,7 +1858,7 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n /// [`HashMap`]: struct.HashMap.html\n /// [`Entry`]: enum.Entry.html\n /// [`raw_entry`]: struct.HashMap.html#method.raw_entry\n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n     Occupied(RawOccupiedEntryMut<'a, K, V>),\n@@ -1870,7 +1870,7 @@ pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n /// It is part of the [`RawEntryMut`] enum.\n ///\n /// [`RawEntryMut`]: enum.RawEntryMut.html\n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n@@ -1879,7 +1879,7 @@ pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n /// It is part of the [`RawEntryMut`] enum.\n ///\n /// [`RawEntryMut`]: enum.RawEntryMut.html\n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n     hash_builder: &'a S,\n@@ -1890,7 +1890,7 @@ pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n /// See the [`HashMap::raw_entry`] docs for usage examples.\n ///\n /// [`HashMap::raw_entry`]: struct.HashMap.html#method.raw_entry\n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a HashMap<K, V, S>,\n }\n@@ -1900,7 +1900,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n           K: Eq + Hash,\n {\n     /// Create a `RawEntryMut` from the given key.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n@@ -1911,7 +1911,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     }\n \n     /// Create a `RawEntryMut` from the given key and its hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n               Q: Eq\n@@ -1941,7 +1941,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n         }\n     }\n     /// Create a `RawEntryMut` from the given hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n     {\n@@ -1951,7 +1951,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n     /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n     /// hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn search_bucket<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n     {\n@@ -1963,7 +1963,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     where S: BuildHasher,\n {\n     /// Access an entry by key.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n@@ -1974,7 +1974,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     }\n \n     /// Access an entry by a key and its hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n@@ -1997,7 +1997,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     }\n \n     /// Access an entry by hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n         where F: FnMut(&K) -> bool\n     {\n@@ -2007,7 +2007,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n     /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n     /// hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn search_bucket<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n         where F: FnMut(&K) -> bool\n     {\n@@ -2033,7 +2033,7 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 10).1 *= 2;\n     /// assert_eq!(map[\"poneyland\"], 6);\n     /// ```\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n         where K: Hash,\n               S: BuildHasher,\n@@ -2061,7 +2061,7 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n         where F: FnOnce() -> (K, V),\n               K: Hash,\n@@ -2099,7 +2099,7 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     ///    .or_insert(\"poneyland\", 0);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn and_modify<F>(self, f: F) -> Self\n         where F: FnOnce(&mut K, &mut V)\n     {\n@@ -2118,82 +2118,82 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n \n impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn key(&self) -> &K {\n         self.elem.read().0\n     }\n \n     /// Gets a mutable reference to the key in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn key_mut(&mut self) -> &mut K {\n         self.elem.read_mut().0\n     }\n \n     /// Converts the entry into a mutable reference to the key in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn into_key(self) -> &'a mut K {\n         self.elem.into_mut_refs().0\n     }\n \n     /// Gets a reference to the value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n     /// Gets a reference to the key and value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get_key_value(&mut self) -> (&K, &V) {\n         self.elem.read()\n     }\n \n     /// Gets a mutable reference to the key and value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n         self.elem.read_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n         self.elem.into_mut_refs()\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert_key(&mut self, key: K) -> K {\n         mem::replace(self.key_mut(), key)\n     }\n \n     /// Takes the value out of the entry, and returns it.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n \n     /// Take the ownership of the key and value from the map.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn remove_entry(self) -> (K, V) {\n         let (k, v, _) = pop_internal(self.elem);\n         (k, v)\n@@ -2203,7 +2203,7 @@ impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n         where K: Hash,\n               S: BuildHasher,\n@@ -2215,7 +2215,7 @@ impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n     pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n         let hash = SafeHash::new(hash);\n         let b = match self.elem {\n@@ -2236,15 +2236,15 @@ impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<'a, K, V, S> Debug for RawEntryBuilderMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawEntryBuilder\")\n          .finish()\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<'a, K: Debug, V: Debug, S> Debug for RawEntryMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -2262,7 +2262,7 @@ impl<'a, K: Debug, V: Debug, S> Debug for RawEntryMut<'a, K, V, S> {\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawOccupiedEntryMut\")\n@@ -2272,15 +2272,15 @@ impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<'a, K, V, S> Debug for RawVacantEntryMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawVacantEntryMut\")\n          .finish()\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawEntryBuilder\")"}, {"sha": "32969d09e8567abe884a226a7c79eaa79239f0b2", "filename": "src/rustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -11,5 +11,9 @@ path = \"rustc.rs\"\n rustc_target = { path = \"../librustc_target\" }\n rustc_driver = { path = \"../librustc_driver\" }\n \n+# Make sure rustc_codegen_ssa ends up in the sysroot, because this\n+# crate is intended to be used by codegen backends, which may not be in-tree.\n+rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n+\n [features]\n jemalloc = ['rustc_driver/jemalloc-sys']"}, {"sha": "5a6df52502eb5cc4423f8905b3b2153484d0d753", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -78,3 +78,9 @@ pub union CUnionU128{a:u128}\n #[no_mangle]\n pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n \n+pub union UnionBool { b:bool }\n+// CHECK: define zeroext i1 @test_UnionBool(i8 %b)\n+#[no_mangle]\n+pub fn test_UnionBool(b: UnionBool) -> bool { unsafe { b.b }  }\n+// CHECK: %0 = trunc i8 %b to i1\n+"}, {"sha": "34fa3bc4b0ce2bd8beeba91c909f4b7f0521e1a6", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -8,34 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-bitrig\n-// ignore-solaris\n-// ignore-windows failing on win32 bot\n-// ignore-freebsd: gdb package too new\n // ignore-tidy-linelength\n // ignore-lldb\n // ignore-android: FIXME(#10381)\n+// min-gdb-version: 7.11\n+\n // compile-flags:-g\n \n // gdb-command: run\n \n // gdb-command: print regular_struct\n-// gdb-check:$1 = RegularStruct = {the_first_field = 101, the_second_field = 102.5, the_third_field = false}\n+// gdbg-check:$1 = RegularStruct = {the_first_field = 101, the_second_field = 102.5, the_third_field = false}\n+// gdbr-check:$1 = gdb_pretty_struct_and_enums::RegularStruct {the_first_field: 101, the_second_field: 102.5, the_third_field: false}\n \n // gdb-command: print empty_struct\n-// gdb-check:$2 = EmptyStruct\n+// gdbg-check:$2 = EmptyStruct\n+// gdbr-check:$2 = gdb_pretty_struct_and_enums::EmptyStruct\n \n // gdb-command: print c_style_enum1\n // gdbg-check:$3 = CStyleEnumVar1\n-// gdbr-check:$3 = gdb_pretty_struct_and_enums_pre_gdb_7_7::CStyleEnum::CStyleEnumVar1\n+// gdbr-check:$3 = gdb_pretty_struct_and_enums::CStyleEnum::CStyleEnumVar1\n \n // gdb-command: print c_style_enum2\n // gdbg-check:$4 = CStyleEnumVar2\n-// gdbr-check:$4 = gdb_pretty_struct_and_enums_pre_gdb_7_7::CStyleEnum::CStyleEnumVar2\n+// gdbr-check:$4 = gdb_pretty_struct_and_enums::CStyleEnum::CStyleEnumVar2\n \n // gdb-command: print c_style_enum3\n // gdbg-check:$5 = CStyleEnumVar3\n-// gdbr-check:$5 = gdb_pretty_struct_and_enums_pre_gdb_7_7::CStyleEnum::CStyleEnumVar3\n+// gdbr-check:$5 = gdb_pretty_struct_and_enums::CStyleEnum::CStyleEnumVar3\n \n #![allow(dead_code, unused_variables)]\n ", "previous_filename": "src/test/debuginfo/gdb-pretty-struct-and-enums-pre-gdb-7-7.rs"}, {"sha": "134b04d7333bcba3cb56718a2b43a0f8021f1067", "filename": "src/test/ui-fulldeps/auxiliary/subspan.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fsubspan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fsubspan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fsubspan.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_diagnostic, proc_macro_span)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, Span, Diagnostic};\n+\n+fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n+    if let Some(TokenTree::Literal(lit)) = input.into_iter().next() {\n+        let mut spans = vec![];\n+        let string = lit.to_string();\n+        for hi in string.matches(\"hi\") {\n+            let index = hi.as_ptr() as usize - string.as_ptr() as usize;\n+            let subspan = lit.subspan(index..(index + hi.len())).unwrap();\n+            spans.push(subspan);\n+        }\n+\n+        if !spans.is_empty() {\n+            Err(Span::call_site().error(\"found 'hi's\").span_note(spans, \"here\"))\n+        } else {\n+            Ok(())\n+        }\n+    } else {\n+        Err(Span::call_site().error(\"invalid input: expected string literal\"))\n+    }\n+}\n+\n+#[proc_macro]\n+pub fn subspan(input: TokenStream) -> TokenStream {\n+    if let Err(diag) = parse(input) {\n+        diag.emit();\n+    }\n+\n+    TokenStream::new()\n+}"}, {"sha": "437123ca4795e4d7e0caf67eef1272c8e1eda15d", "filename": "src/test/ui-fulldeps/subspan.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fui-fulldeps%2Fsubspan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fui-fulldeps%2Fsubspan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsubspan.rs?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:subspan.rs\n+// ignore-stage1\n+\n+extern crate subspan;\n+\n+use subspan::subspan;\n+\n+// This one emits no error.\n+subspan!(\"\");\n+\n+// Exactly one 'hi'.\n+subspan!(\"hi\"); //~ ERROR found 'hi's\n+\n+// Now two, back to back.\n+subspan!(\"hihi\"); //~ ERROR found 'hi's\n+\n+// Now three, back to back.\n+subspan!(\"hihihi\"); //~ ERROR found 'hi's\n+\n+// Now several, with spacing.\n+subspan!(\"why I hide? hi!\"); //~ ERROR found 'hi's\n+subspan!(\"hey, hi, hidy, hidy, hi hi\"); //~ ERROR found 'hi's\n+subspan!(\"this is a hi, and this is another hi\"); //~ ERROR found 'hi's\n+subspan!(\"how are you this evening\"); //~ ERROR found 'hi's\n+subspan!(\"this is highly eradic\"); //~ ERROR found 'hi's\n+\n+fn main() { }"}, {"sha": "4d3928cae723a775e0dd477c9ecb7abf3efbd8b5", "filename": "src/test/ui-fulldeps/subspan.stderr", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fui-fulldeps%2Fsubspan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f57e4841157d5cbd4c4e22018f93bd1801c98c2/src%2Ftest%2Fui-fulldeps%2Fsubspan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsubspan.stderr?ref=1f57e4841157d5cbd4c4e22018f93bd1801c98c2", "patch": "@@ -0,0 +1,98 @@\n+error: found 'hi's\n+  --> $DIR/subspan.rs:22:1\n+   |\n+LL | subspan!(\"hi\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:22:11\n+   |\n+LL | subspan!(\"hi\"); //~ ERROR found 'hi's\n+   |           ^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:25:1\n+   |\n+LL | subspan!(\"hihi\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:25:11\n+   |\n+LL | subspan!(\"hihi\"); //~ ERROR found 'hi's\n+   |           ^^^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:28:1\n+   |\n+LL | subspan!(\"hihihi\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:28:11\n+   |\n+LL | subspan!(\"hihihi\"); //~ ERROR found 'hi's\n+   |           ^^^^^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:31:1\n+   |\n+LL | subspan!(\"why I hide? hi!\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:31:17\n+   |\n+LL | subspan!(\"why I hide? hi!\"); //~ ERROR found 'hi's\n+   |                 ^^    ^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:32:1\n+   |\n+LL | subspan!(\"hey, hi, hidy, hidy, hi hi\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:32:16\n+   |\n+LL | subspan!(\"hey, hi, hidy, hidy, hi hi\"); //~ ERROR found 'hi's\n+   |                ^^  ^^    ^^    ^^ ^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:33:1\n+   |\n+LL | subspan!(\"this is a hi, and this is another hi\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:33:12\n+   |\n+LL | subspan!(\"this is a hi, and this is another hi\"); //~ ERROR found 'hi's\n+   |            ^^       ^^       ^^             ^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:34:1\n+   |\n+LL | subspan!(\"how are you this evening\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:34:24\n+   |\n+LL | subspan!(\"how are you this evening\"); //~ ERROR found 'hi's\n+   |                        ^^\n+\n+error: found 'hi's\n+  --> $DIR/subspan.rs:35:1\n+   |\n+LL | subspan!(\"this is highly eradic\"); //~ ERROR found 'hi's\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: here\n+  --> $DIR/subspan.rs:35:12\n+   |\n+LL | subspan!(\"this is highly eradic\"); //~ ERROR found 'hi's\n+   |            ^^     ^^\n+\n+error: aborting due to 8 previous errors\n+"}]}