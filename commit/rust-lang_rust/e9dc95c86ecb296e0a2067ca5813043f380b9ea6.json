{"sha": "e9dc95c86ecb296e0a2067ca5813043f380b9ea6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZGM5NWM4NmVjYjI5NmUwYTIwNjdjYTU4MTMwNDNmMzgwYjllYTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-02T14:08:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-04T06:01:37Z"}, "message": "remove peek_token from StringReader", "tree": {"sha": "1925ce43ec26a56158d2a09304b7cecac06c7a7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1925ce43ec26a56158d2a09304b7cecac06c7a7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9dc95c86ecb296e0a2067ca5813043f380b9ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9dc95c86ecb296e0a2067ca5813043f380b9ea6", "html_url": "https://github.com/rust-lang/rust/commit/e9dc95c86ecb296e0a2067ca5813043f380b9ea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9dc95c86ecb296e0a2067ca5813043f380b9ea6/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "830ff4a592cf6a5adc0e5482d4294779d7a91177", "url": "https://api.github.com/repos/rust-lang/rust/commits/830ff4a592cf6a5adc0e5482d4294779d7a91177", "html_url": "https://github.com/rust-lang/rust/commit/830ff4a592cf6a5adc0e5482d4294779d7a91177"}], "stats": {"total": 26, "additions": 8, "deletions": 18}, "files": [{"sha": "2ab0bebf9292781d8c81f86b9a099a49ca8eaba9", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9dc95c86ecb296e0a2067ca5813043f380b9ea6/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9dc95c86ecb296e0a2067ca5813043f380b9ea6/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=e9dc95c86ecb296e0a2067ca5813043f380b9ea6", "patch": "@@ -268,7 +268,7 @@ fn read_block_comment(rdr: &mut StringReader<'_>,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if rdr.is_eof() {\n-                rdr.fatal(\"unterminated block comment\").raise();\n+                rdr.fatal_span_(rdr.pos, rdr.pos, \"unterminated block comment\").raise();\n             }\n             if rdr.ch_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);"}, {"sha": "a24c72ecc24f176f166ef8a01c4e411cd4a629d5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9dc95c86ecb296e0a2067ca5813043f380b9ea6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9dc95c86ecb296e0a2067ca5813043f380b9ea6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e9dc95c86ecb296e0a2067ca5813043f380b9ea6", "patch": "@@ -39,7 +39,6 @@ pub struct StringReader<'a> {\n     /// Stop reading src at this index.\n     crate end_src_index: usize,\n     // cached:\n-    peek_token: Token,\n     peek_span_src_raw: Span,\n     fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     // cache a direct reference to the source text, so that we don't have to\n@@ -78,9 +77,7 @@ impl<'a> StringReader<'a> {\n     /// Returns the next token. EFFECT: advances the string_reader.\n     pub fn try_next_token(&mut self) -> Result<Token, ()> {\n         assert!(self.fatal_errs.is_empty());\n-        let ret_val = self.peek_token.take();\n-        self.advance_token()?;\n-        Ok(ret_val)\n+        self.advance_token()\n     }\n \n     fn try_real_token(&mut self) -> Result<Token, ()> {\n@@ -120,10 +117,6 @@ impl<'a> StringReader<'a> {\n         FatalError.raise();\n     }\n \n-    fn fatal(&self, m: &str) -> FatalError {\n-        self.fatal_span(self.peek_token.span, m)\n-    }\n-\n     crate fn emit_fatal_errors(&mut self) {\n         for err in &mut self.fatal_errs {\n             err.emit();\n@@ -169,7 +162,6 @@ impl<'a> StringReader<'a> {\n             ch: Some('\\n'),\n             source_file,\n             end_src_index: src.len(),\n-            peek_token: Token::dummy(),\n             peek_span_src_raw: syntax_pos::DUMMY_SP,\n             src,\n             fatal_errs: Vec::new(),\n@@ -267,11 +259,11 @@ impl<'a> StringReader<'a> {\n \n     /// Advance peek_token to refer to the next token, and\n     /// possibly update the interner.\n-    fn advance_token(&mut self) -> Result<(), ()> {\n+    fn advance_token(&mut self) -> Result<Token, ()> {\n         match self.scan_whitespace_or_comment() {\n             Some(comment) => {\n                 self.peek_span_src_raw = comment.span;\n-                self.peek_token = comment;\n+                Ok(comment)\n             }\n             None => {\n                 let (kind, start_pos, end_pos) = if self.is_eof() {\n@@ -281,12 +273,10 @@ impl<'a> StringReader<'a> {\n                     (self.next_token_inner()?, start_pos, self.pos)\n                 };\n                 let (real, raw) = self.mk_sp_and_raw(start_pos, end_pos);\n-                self.peek_token = Token::new(kind, real);\n                 self.peek_span_src_raw = raw;\n+                Ok(Token::new(kind, real))\n             }\n         }\n-\n-        Ok(())\n     }\n \n     #[inline]\n@@ -1484,17 +1474,17 @@ mod tests {\n             assert_eq!(tok1.kind, tok2.kind);\n             assert_eq!(tok1.span, tok2.span);\n             assert_eq!(string_reader.next_token(), token::Whitespace);\n-            // the 'main' id is already read:\n-            assert_eq!(string_reader.pos.clone(), BytePos(28));\n             // read another token:\n             let tok3 = string_reader.next_token();\n+            assert_eq!(string_reader.pos.clone(), BytePos(28));\n             let tok4 = Token::new(\n                 mk_ident(\"main\"),\n                 Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n             );\n             assert_eq!(tok3.kind, tok4.kind);\n             assert_eq!(tok3.span, tok4.span);\n-            // the lparen is already read:\n+\n+            assert_eq!(string_reader.next_token(), token::OpenDelim(token::Paren));\n             assert_eq!(string_reader.pos.clone(), BytePos(29))\n         })\n     }"}]}