{"sha": "03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYzVhNjY5MGQ5NDNlNDhhYzViNTQ2NGMyYWMyZmQwNTRlYTYyNTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-27T15:53:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-27T17:22:31Z"}, "message": "Add light-weight snapshot testing library with editor integration", "tree": {"sha": "ffb971e1d7647f9c72a24210f63b265ebae23c23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffb971e1d7647f9c72a24210f63b265ebae23c23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "html_url": "https://github.com/rust-lang/rust/commit/03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "491d000c27676305cc7d5d734d4476cf731b7940", "url": "https://api.github.com/repos/rust-lang/rust/commits/491d000c27676305cc7d5d734d4476cf731b7940", "html_url": "https://github.com/rust-lang/rust/commit/491d000c27676305cc7d5d734d4476cf731b7940"}], "stats": {"total": 362, "additions": 357, "deletions": 5}, "files": [{"sha": "a3cfe5dc4b3a7bae4f53d2a40a2365ef0f4ca3d9", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -347,6 +347,14 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"expect\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"once_cell\",\n+ \"stdx\",\n+]\n+\n [[package]]\n name = \"filetime\"\n version = \"0.2.10\""}, {"sha": "09eb57a432841d0004b234897b075e12fea0882c", "filename": "crates/expect/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Fexpect%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Fexpect%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2FCargo.toml?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"expect\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+once_cell = \"1\"\n+stdx = { path = \"../stdx\" }"}, {"sha": "08d0eafdf9f25fcbe92caea9e530eabfd4d9693a", "filename": "crates/expect/src/lib.rs", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Fexpect%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Fexpect%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2Fsrc%2Flib.rs?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -0,0 +1,308 @@\n+//! Snapshot testing library, see\n+//! https://github.com/rust-analyzer/rust-analyzer/pull/5101\n+use std::{\n+    collections::HashMap,\n+    env, fmt, fs,\n+    ops::Range,\n+    path::{Path, PathBuf},\n+    sync::Mutex,\n+};\n+\n+use once_cell::sync::Lazy;\n+use stdx::{lines_with_ends, trim_indent};\n+\n+const HELP: &str = \"\n+You can update all `expect![[]]` tests by:\n+\n+    env UPDATE_EXPECT=1 cargo test\n+\n+To update a single test, place the cursor on `expect` token and use `run` feature of rust-analyzer.\n+\";\n+\n+fn update_expect() -> bool {\n+    env::var(\"UPDATE_EXPECT\").is_ok()\n+}\n+\n+/// expect![[\"\"]]\n+#[macro_export]\n+macro_rules! expect {\n+    [[$lit:literal]] => {$crate::Expect {\n+        file: file!(),\n+        line: line!(),\n+        column: column!(),\n+        data: $lit,\n+    }};\n+    [[]] => { $crate::expect![[\"\"]] };\n+}\n+\n+#[derive(Debug)]\n+pub struct Expect {\n+    pub file: &'static str,\n+    pub line: u32,\n+    pub column: u32,\n+    pub data: &'static str,\n+}\n+\n+impl Expect {\n+    pub fn assert_eq(&self, actual: &str) {\n+        let trimmed = self.trimmed();\n+        if &trimmed == actual {\n+            return;\n+        }\n+        Runtime::fail(self, &trimmed, actual);\n+    }\n+    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n+        let actual = format!(\"{:#?}\\n\", actual);\n+        self.assert_eq(&actual)\n+    }\n+\n+    fn trimmed(&self) -> String {\n+        if !self.data.contains('\\n') {\n+            return self.data.to_string();\n+        }\n+        trim_indent(self.data)\n+    }\n+\n+    fn locate(&self, file: &str) -> Location {\n+        let mut target_line = None;\n+        let mut line_start = 0;\n+        for (i, line) in lines_with_ends(file).enumerate() {\n+            if i == self.line as usize - 1 {\n+                let pat = \"expect![[\";\n+                let offset = line.find(pat).unwrap();\n+                let literal_start = line_start + offset + pat.len();\n+                let indent = line.chars().take_while(|&it| it == ' ').count();\n+                target_line = Some((literal_start, indent));\n+                break;\n+            }\n+            line_start += line.len();\n+        }\n+        let (literal_start, line_indent) = target_line.unwrap();\n+        let literal_length = file[literal_start..].find(\"]]\").unwrap();\n+        let literal_range = literal_start..literal_start + literal_length;\n+        Location { line_indent, literal_range }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct Runtime {\n+    help_printed: bool,\n+    per_file: HashMap<&'static str, FileRuntime>,\n+}\n+static RT: Lazy<Mutex<Runtime>> = Lazy::new(Default::default);\n+\n+impl Runtime {\n+    fn fail(expect: &Expect, expected: &str, actual: &str) {\n+        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n+        let mut updated = \"\";\n+        if update_expect() {\n+            updated = \" (updated)\";\n+            rt.per_file\n+                .entry(expect.file)\n+                .or_insert_with(|| FileRuntime::new(expect))\n+                .update(expect, actual);\n+        }\n+        let print_help = !rt.help_printed && !update_expect();\n+        rt.help_printed = true;\n+\n+        let help = if print_help { HELP } else { \"\" };\n+        panic!(\n+            \"\\n\n+error: expect test failed{}\n+  --> {}:{}:{}\n+{}\n+Expect:\n+----\n+{}\n+----\n+\n+Actual:\n+----\n+{}\n+----\n+\",\n+            updated, expect.file, expect.line, expect.column, help, expected, actual\n+        )\n+    }\n+}\n+\n+struct FileRuntime {\n+    path: PathBuf,\n+    original_text: String,\n+    patchwork: Patchwork,\n+}\n+\n+impl FileRuntime {\n+    fn new(expect: &Expect) -> FileRuntime {\n+        let path = workspace_root().join(expect.file);\n+        let original_text = fs::read_to_string(&path).unwrap();\n+        let patchwork = Patchwork::new(original_text.clone());\n+        FileRuntime { path, original_text, patchwork }\n+    }\n+    fn update(&mut self, expect: &Expect, actual: &str) {\n+        let loc = expect.locate(&self.original_text);\n+        let patch = format_patch(loc.line_indent.clone(), actual);\n+        self.patchwork.patch(loc.literal_range, &patch);\n+        fs::write(&self.path, &self.patchwork.text).unwrap()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Location {\n+    line_indent: usize,\n+    literal_range: Range<usize>,\n+}\n+\n+#[derive(Debug)]\n+struct Patchwork {\n+    text: String,\n+    indels: Vec<(Range<usize>, usize)>,\n+}\n+\n+impl Patchwork {\n+    fn new(text: String) -> Patchwork {\n+        Patchwork { text, indels: Vec::new() }\n+    }\n+    fn patch(&mut self, mut range: Range<usize>, patch: &str) {\n+        self.indels.push((range.clone(), patch.len()));\n+        self.indels.sort_by_key(|(delete, _insert)| delete.start);\n+\n+        let (delete, insert) = self\n+            .indels\n+            .iter()\n+            .take_while(|(delete, _)| delete.start < range.start)\n+            .map(|(delete, insert)| (delete.end - delete.start, insert))\n+            .fold((0usize, 0usize), |(x1, y1), (x2, y2)| (x1 + x2, y1 + y2));\n+\n+        for pos in &mut [&mut range.start, &mut range.end] {\n+            **pos += insert;\n+            **pos -= delete\n+        }\n+\n+        self.text.replace_range(range, &patch);\n+    }\n+}\n+\n+fn format_patch(line_indent: usize, patch: &str) -> String {\n+    let mut max_hashes = 0;\n+    let mut cur_hashes = 0;\n+    for byte in patch.bytes() {\n+        if byte != b'#' {\n+            cur_hashes = 0;\n+            continue;\n+        }\n+        cur_hashes += 1;\n+        max_hashes = max_hashes.max(cur_hashes);\n+    }\n+    let hashes = &\"#\".repeat(max_hashes + 1);\n+    let indent = &\" \".repeat(line_indent);\n+    let is_multiline = patch.contains('\\n');\n+\n+    let mut buf = String::new();\n+    buf.push('r');\n+    buf.push_str(hashes);\n+    buf.push('\"');\n+    if is_multiline {\n+        buf.push('\\n');\n+    }\n+    let mut final_newline = false;\n+    for line in lines_with_ends(patch) {\n+        if is_multiline {\n+            buf.push_str(indent);\n+            buf.push_str(\"    \");\n+        }\n+        buf.push_str(line);\n+        final_newline = line.ends_with('\\n');\n+    }\n+    if final_newline {\n+        buf.push_str(indent);\n+    }\n+    buf.push('\"');\n+    buf.push_str(hashes);\n+    buf\n+}\n+\n+fn workspace_root() -> PathBuf {\n+    Path::new(\n+        &env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned()),\n+    )\n+    .ancestors()\n+    .nth(2)\n+    .unwrap()\n+    .to_path_buf()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_expect_macro() {\n+        let empty = expect![[]];\n+        expect![[r#\"\n+            Expect {\n+                file: \"crates/expect/src/lib.rs\",\n+                line: 241,\n+                column: 21,\n+                data: \"\",\n+            }\n+        \"#]]\n+        .assert_debug_eq(&empty);\n+\n+        let expect = expect![[\"\n+            hello\n+            world\n+        \"]];\n+        expect![[r#\"\n+            Expect {\n+                file: \"crates/expect/src/lib.rs\",\n+                line: 252,\n+                column: 22,\n+                data: \"\\n            hello\\n            world\\n        \",\n+            }\n+        \"#]]\n+        .assert_debug_eq(&expect);\n+    }\n+\n+    #[test]\n+    fn test_format_patch() {\n+        let patch = format_patch(0, \"hello\\nworld\\n\");\n+        expect![[r##\"\n+            r#\"\n+                hello\n+                world\n+            \"#\"##]]\n+        .assert_eq(&patch);\n+\n+        let patch = format_patch(4, \"single line\");\n+        expect![[r##\"r#\"single line\"#\"##]].assert_eq(&patch);\n+    }\n+\n+    #[test]\n+    fn test_patchwork() {\n+        let mut patchwork = Patchwork::new(\"one two three\".to_string());\n+        patchwork.patch(4..7, \"zwei\");\n+        patchwork.patch(0..3, \"\u043e\u0434\u0438\u043d\");\n+        patchwork.patch(8..13, \"3\");\n+        expect![[r#\"\n+            Patchwork {\n+                text: \"\u043e\u0434\u0438\u043d zwei 3\",\n+                indels: [\n+                    (\n+                        0..3,\n+                        8,\n+                    ),\n+                    (\n+                        4..7,\n+                        4,\n+                    ),\n+                    (\n+                        8..13,\n+                        1,\n+                    ),\n+                ],\n+            }\n+        \"#]]\n+        .assert_debug_eq(&patchwork);\n+    }\n+}"}, {"sha": "4d0684b2a3fe845c194f55287df184fe2ed3313a", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -23,7 +23,7 @@ use ra_ide::{\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n-use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n+use ra_syntax::{algo, ast, AstNode, SyntaxKind, TextRange, TextSize};\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n use stdx::{format_to, split_delim};\n@@ -407,8 +407,21 @@ pub(crate) fn handle_runnables(\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n     let line_index = snap.analysis.file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n-    let mut res = Vec::new();\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+\n+    let expect_test = match offset {\n+        Some(offset) => {\n+            let source_file = snap.analysis.parse(file_id)?;\n+            algo::find_node_at_offset::<ast::MacroCall>(source_file.syntax(), offset)\n+                .and_then(|it| it.path())\n+                .and_then(|it| it.segment())\n+                .and_then(|it| it.name_ref())\n+                .map_or(false, |it| it.text() == \"expect\")\n+        }\n+        None => false,\n+    };\n+\n+    let mut res = Vec::new();\n     for runnable in snap.analysis.runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.nav.full_range().contains_inclusive(offset) {\n@@ -418,8 +431,12 @@ pub(crate) fn handle_runnables(\n         if should_skip_target(&runnable, cargo_spec.as_ref()) {\n             continue;\n         }\n-\n-        res.push(to_proto::runnable(&snap, file_id, runnable)?);\n+        let mut runnable = to_proto::runnable(&snap, file_id, runnable)?;\n+        if expect_test {\n+            runnable.label = format!(\"{} + expect\", runnable.label);\n+            runnable.args.expect_test = Some(true);\n+        }\n+        res.push(runnable);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n@@ -438,6 +455,7 @@ pub(crate) fn handle_runnables(\n                             spec.package.clone(),\n                         ],\n                         executable_args: Vec::new(),\n+                        expect_test: None,\n                     },\n                 })\n             }\n@@ -451,6 +469,7 @@ pub(crate) fn handle_runnables(\n                     workspace_root: None,\n                     cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n                     executable_args: Vec::new(),\n+                    expect_test: None,\n                 },\n             });\n         }"}, {"sha": "1befe678c132137445d6b837e23270116370a97e", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -161,6 +161,8 @@ pub struct CargoRunnable {\n     pub cargo_args: Vec<String>,\n     // stuff after --\n     pub executable_args: Vec<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub expect_test: Option<bool>,\n }\n \n pub enum InlayHints {}"}, {"sha": "a03222ae96bd590a09850fd48c2af82415e83380", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -666,6 +666,7 @@ pub(crate) fn runnable(\n             workspace_root: workspace_root.map(|it| it.into()),\n             cargo_args,\n             executable_args,\n+            expect_test: None,\n         },\n     })\n }"}, {"sha": "fdb99956b5137a0c91a1b4f38aba6a2eae7f1e2b", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -60,6 +60,7 @@ export interface Runnable {\n         workspaceRoot?: string;\n         cargoArgs: string[];\n         executableArgs: string[];\n+        expectTest?: boolean;\n     };\n }\n export const runnables = new lc.RequestType<RunnablesParams, Runnable[], void>(\"experimental/runnables\");"}, {"sha": "e1430e31f76174addecc123b961d87ecfc0df16b", "filename": "editors/code/src/run.ts", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/editors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/03c5a6690d943e48ac5b5464c2ac2fd054ea6251/editors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Frun.ts?ref=03c5a6690d943e48ac5b5464c2ac2fd054ea6251", "patch": "@@ -108,12 +108,16 @@ export async function createTask(runnable: ra.Runnable, config: Config): Promise\n     if (runnable.args.executableArgs.length > 0) {\n         args.push('--', ...runnable.args.executableArgs);\n     }\n+    const env: { [key: string]: string } = { \"RUST_BACKTRACE\": \"short\" };\n+    if (runnable.args.expectTest) {\n+        env[\"UPDATE_EXPECT\"] = \"1\";\n+    }\n     const definition: tasks.CargoTaskDefinition = {\n         type: tasks.TASK_TYPE,\n         command: args[0], // run, test, etc...\n         args: args.slice(1),\n         cwd: runnable.args.workspaceRoot,\n-        env: Object.assign({}, process.env as { [key: string]: string }, { \"RUST_BACKTRACE\": \"short\" }),\n+        env: Object.assign({}, process.env as { [key: string]: string }, env),\n     };\n \n     const target = vscode.workspace.workspaceFolders![0]; // safe, see main activate()"}]}