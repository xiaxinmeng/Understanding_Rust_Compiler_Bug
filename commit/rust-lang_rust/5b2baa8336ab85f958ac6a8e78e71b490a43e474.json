{"sha": "5b2baa8336ab85f958ac6a8e78e71b490a43e474", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMmJhYTgzMzZhYjg1Zjk1OGFjNmE4ZTc4ZTcxYjQ5MGE0M2U0NzQ=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-03T15:08:50Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-24T00:24:40Z"}, "message": "Implement some instantiate / canonical routines", "tree": {"sha": "f1fe913c9dfce524483340abbf7fce67d8e00d6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1fe913c9dfce524483340abbf7fce67d8e00d6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b2baa8336ab85f958ac6a8e78e71b490a43e474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2baa8336ab85f958ac6a8e78e71b490a43e474", "html_url": "https://github.com/rust-lang/rust/commit/5b2baa8336ab85f958ac6a8e78e71b490a43e474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b2baa8336ab85f958ac6a8e78e71b490a43e474/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95861b159072c404ad5ef2951d1f8c323a3878ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/95861b159072c404ad5ef2951d1f8c323a3878ca", "html_url": "https://github.com/rust-lang/rust/commit/95861b159072c404ad5ef2951d1f8c323a3878ca"}], "stats": {"total": 165, "additions": 113, "deletions": 52}, "files": [{"sha": "14d4be2b1787d215565e2083b3fb434a819709b2", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 113, "deletions": 52, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/5b2baa8336ab85f958ac6a8e78e71b490a43e474/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2baa8336ab85f958ac6a8e78e71b490a43e474/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=5b2baa8336ab85f958ac6a8e78e71b490a43e474", "patch": "@@ -11,7 +11,7 @@\n mod program_clauses;\n \n use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n-use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n+use chalk_engine::{context, hh::HhGoal, DelayedLiteral, Literal, ExClause};\n use rustc::infer::canonical::{\n     Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n@@ -28,7 +28,7 @@ use rustc::traits::{\n     InEnvironment,\n };\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc::ty::subst::Kind;\n+use rustc::ty::subst::{Kind, UnpackedKind};\n use rustc::ty::{self, TyCtxt};\n \n use std::fmt::{self, Debug};\n@@ -44,7 +44,7 @@ crate struct ChalkArenas<'gcx> {\n #[derive(Copy, Clone)]\n crate struct ChalkContext<'cx, 'gcx: 'cx> {\n     _arenas: ChalkArenas<'gcx>,\n-    _tcx: TyCtxt<'cx, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'cx, 'gcx, 'gcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -68,7 +68,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl context::Context for ChalkArenas<'tcx> {\n-    type CanonicalExClause = Canonical<'tcx, ExClause<Self>>;\n+    type CanonicalExClause = Canonical<'tcx, ChalkExClause<'tcx>>;\n \n     type CanonicalGoalInEnvironment = Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>;\n \n@@ -147,19 +147,29 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     /// - the environment and goal found by substitution `S` into `arg`\n     fn instantiate_ucanonical_goal<R>(\n         &self,\n-        _arg: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'gcx>, Output = R>,\n+        arg: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'gcx>, Output = R>,\n     ) -> R {\n-        unimplemented!()\n+        self.tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, arg, |ref infcx, arg, subst| {\n+            let chalk_infcx = &mut ChalkInferenceContext {\n+                infcx,\n+            };\n+            op.with(chalk_infcx, subst, arg.environment, arg.goal)\n+        })\n     }\n \n     fn instantiate_ex_clause<R>(\n         &self,\n         _num_universes: usize,\n-        _canonical_ex_clause: &Canonical<'gcx, ChalkExClause<'gcx>>,\n-        _op: impl context::WithInstantiatedExClause<ChalkArenas<'gcx>, Output = R>,\n+        arg: &Canonical<'gcx, ChalkExClause<'gcx>>,\n+        op: impl context::WithInstantiatedExClause<ChalkArenas<'gcx>, Output = R>,\n     ) -> R {\n-        unimplemented!()\n+        self.tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &arg.upcast(), |ref infcx, arg, _| {\n+            let chalk_infcx = &mut ChalkInferenceContext {\n+                infcx,\n+            };\n+            op.with(chalk_infcx,arg)\n+        })\n     }\n \n     /// True if this solution has no region constraints.\n@@ -186,14 +196,33 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     }\n \n     fn is_trivial_substitution(\n-        _u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n-        _canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+        u_canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n+        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n     ) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn num_universes(_: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>) -> usize {\n-        0 // FIXME\n+        let subst = &canonical_subst.value.subst;\n+        assert_eq!(u_canon.variables.len(), subst.var_values.len());\n+        subst.var_values\n+            .iter_enumerated()\n+            .all(|(cvar, kind)| match kind.unpack() {\n+                UnpackedKind::Lifetime(r) => match r {\n+                    &ty::ReLateBound(debruijn, br) => {\n+                        debug_assert_eq!(debruijn, ty::INNERMOST);\n+                        cvar == br.assert_bound_var()\n+                    }\n+                    _ => false,\n+                },\n+                UnpackedKind::Type(ty) => match ty.sty {\n+                    ty::Bound(debruijn, bound_ty) => {\n+                        debug_assert_eq!(debruijn, ty::INNERMOST);\n+                        cvar == bound_ty.var\n+                    }\n+                    _ => false,\n+                },\n+            })\n+    }\n+\n+    fn num_universes(canon: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>) -> usize {\n+        canon.max_universe.index() + 1\n     }\n \n     /// Convert a goal G *from* the canonical universes *into* our\n@@ -214,39 +243,6 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     }\n }\n \n-//impl context::UCanonicalGoalInEnvironment<ChalkContext<'cx, 'gcx>>\n-//    for Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>\n-//{\n-//    fn canonical(&self) -> &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n-//        self\n-//    }\n-//\n-//    fn is_trivial_substitution(\n-//        &self,\n-//        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n-//    ) -> bool {\n-//        let subst = &canonical_subst.value.subst;\n-//        assert_eq!(self.canonical.variables.len(), subst.var_values.len());\n-//        subst\n-//            .var_values\n-//            .iter_enumerated()\n-//            .all(|(cvar, kind)| match kind.unpack() {\n-//                Kind::Lifetime(r) => match r {\n-//                    ty::ReCanonical(cvar1) => cvar == cvar1,\n-//                    _ => false,\n-//                },\n-//                Kind::Type(ty) => match ty.sty {\n-//                    ty::Infer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n-//                    _ => false,\n-//                },\n-//            })\n-//    }\n-//\n-//    fn num_universes(&self) -> usize {\n-//        0 // FIXME\n-//    }\n-//}\n-\n impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n {\n@@ -338,9 +334,9 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn instantiate_binders_universally(\n         &mut self,\n-        _arg: &ty::Binder<Goal<'tcx>>,\n+        arg: &ty::Binder<Goal<'tcx>>,\n     ) -> Goal<'tcx> {\n-        panic!(\"FIXME -- universal instantiation needs sgrif's branch\")\n+        self.infcx.replace_bound_vars_with_placeholders(arg).0\n     }\n \n     fn instantiate_binders_existentially(\n@@ -491,3 +487,68 @@ BraceStructLiftImpl! {\n         subst, constraints\n     }\n }\n+\n+trait Upcast<'tcx, 'gcx: 'tcx>: 'gcx {\n+    type Upcasted: 'tcx;\n+\n+    fn upcast(&self) -> Self::Upcasted;\n+}\n+\n+impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for DelayedLiteral<ChalkArenas<'gcx>> {\n+    type Upcasted = DelayedLiteral<ChalkArenas<'tcx>>;\n+\n+    fn upcast(&self) -> Self::Upcasted {\n+        match self {\n+            &DelayedLiteral::CannotProve(..) => DelayedLiteral::CannotProve(()),\n+            &DelayedLiteral::Negative(index) => DelayedLiteral::Negative(index),\n+            DelayedLiteral::Positive(index, subst) => DelayedLiteral::Positive(\n+                *index,\n+                subst.clone()\n+            ),\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for Literal<ChalkArenas<'gcx>> {\n+    type Upcasted = Literal<ChalkArenas<'tcx>>;\n+\n+    fn upcast(&self) -> Self::Upcasted {\n+        match self {\n+            &Literal::Negative(goal) => Literal::Negative(goal),\n+            &Literal::Positive(goal) => Literal::Positive(goal),\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'gcx: 'tcx> Upcast<'tcx, 'gcx> for ExClause<ChalkArenas<'gcx>> {\n+    type Upcasted = ExClause<ChalkArenas<'tcx>>;\n+\n+    fn upcast(&self) -> Self::Upcasted {\n+        ExClause {\n+            subst: self.subst.clone(),\n+            delayed_literals: self.delayed_literals\n+                .iter()\n+                .map(|l| l.upcast())\n+                .collect(),\n+            constraints: self.constraints.clone(),\n+            subgoals: self.subgoals\n+                .iter()\n+                .map(|g| g.upcast())\n+                .collect(),\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'gcx: 'tcx, T> Upcast<'tcx, 'gcx> for Canonical<'gcx, T>\n+    where T: Upcast<'tcx, 'gcx>\n+{\n+    type Upcasted = Canonical<'tcx, T::Upcasted>;\n+\n+    fn upcast(&self) -> Self::Upcasted {\n+        Canonical {\n+            max_universe: self.max_universe,\n+            value: self.value.upcast(),\n+            variables: self.variables,\n+        }\n+    }\n+}"}]}