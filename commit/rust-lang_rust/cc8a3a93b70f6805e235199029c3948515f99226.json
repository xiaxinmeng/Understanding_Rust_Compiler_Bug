{"sha": "cc8a3a93b70f6805e235199029c3948515f99226", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOGEzYTkzYjcwZjY4MDVlMjM1MTk5MDI5YzM5NDg1MTVmOTkyMjY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-07T09:47:35Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc: consolidate dep-tracked hashmaps in tcx.maps.", "tree": {"sha": "d77bf3230bff39264a87c5ac7b8553917a488848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77bf3230bff39264a87c5ac7b8553917a488848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc8a3a93b70f6805e235199029c3948515f99226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8a3a93b70f6805e235199029c3948515f99226", "html_url": "https://github.com/rust-lang/rust/commit/cc8a3a93b70f6805e235199029c3948515f99226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc8a3a93b70f6805e235199029c3948515f99226/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96a171453973bad66ed9b5df3a7f6e37d9bce31", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96a171453973bad66ed9b5df3a7f6e37d9bce31", "html_url": "https://github.com/rust-lang/rust/commit/e96a171453973bad66ed9b5df3a7f6e37d9bce31"}], "stats": {"total": 422, "additions": 200, "deletions": 222}, "files": [{"sha": "592e4cb92359ce2d222850b969df4935296909f6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -478,7 +478,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         if let Some(impl_list) =\n-                self.tcx.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n+                self.tcx.maps.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n             for &impl_did in impl_list.iter() {\n                 for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                     if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {"}, {"sha": "4cbbb67c7e43d8a1cd1caa7648b2064a2c215407", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -114,14 +114,14 @@ impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n     {\n-        let def_ids = tcx.mir_map.borrow().keys();\n+        let def_ids = tcx.maps.mir.borrow().keys();\n         for def_id in def_ids {\n             if !def_id.is_local() {\n                 continue;\n             }\n \n             let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mir = &mut tcx.mir_map.borrow()[&def_id].borrow_mut();\n+            let mir = &mut tcx.maps.mir.borrow()[&def_id].borrow_mut();\n             tcx.dep_graph.write(DepNode::Mir(def_id));\n \n             let id = tcx.hir.as_local_node_id(def_id).unwrap();"}, {"sha": "e28a8392e58d7da6e2ae1e838a9fbbeb0e1be6f2", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n                       -> Option<Vec<PredicateObligation<'tcx>>> {\n         if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n             let ty = if def_id.is_local() {\n-                tcx.item_types.borrow().get(&def_id).cloned()\n+                tcx.maps.types.borrow().get(&def_id).cloned()\n             } else {\n                 Some(tcx.item_type(def_id))\n             };"}, {"sha": "665d60281d1a9b54ada85e163b056894860506bd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 92, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -10,7 +10,7 @@\n \n //! type context book-keeping\n \n-use dep_graph::{DepGraph, DepTrackingMap};\n+use dep_graph::DepGraph;\n use session::Session;\n use lint;\n use middle;\n@@ -412,44 +412,9 @@ pub struct GlobalCtxt<'tcx> {\n     // borrowck. (They are not used during trans, and hence are not\n     // serialized or needed for cross-crate fns.)\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n-    // FIXME: jroesch make this a refcell\n-\n-    pub tables: RefCell<DepTrackingMap<maps::TypeckTables<'tcx>>>,\n-\n-    /// Maps from a trait item to the trait item \"descriptor\"\n-    pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n-\n-    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub associated_item_def_ids: RefCell<DepTrackingMap<maps::AssociatedItemDefIds<'tcx>>>,\n-\n-    pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n-    pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n-    pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n-    pub adt_sized_constraint: RefCell<DepTrackingMap<maps::AdtSizedConstraint<'tcx>>>,\n-\n-    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated generics and predicates.\n-    pub generics: RefCell<DepTrackingMap<maps::Generics<'tcx>>>,\n-    pub predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n-\n-    /// Maps from the def-id of a trait to the list of\n-    /// super-predicates. This is a subset of the full list of\n-    /// predicates. We store these in a separate map because we must\n-    /// evaluate them even during type conversion, often before the\n-    /// full predicates are available (note that supertraits have\n-    /// additional acyclicity requirements).\n-    pub super_predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     pub hir: hir_map::Map<'tcx>,\n-\n-    /// Maps from the def-id of a function/method or const/static\n-    /// to its MIR. Mutation is done at an item granularity to\n-    /// allow MIR optimization passes to function and still\n-    /// access cross-crate MIR (e.g. inlining or const eval).\n-    ///\n-    /// Note that cross-crate MIR appears to be always borrowed\n-    /// (in the `RefCell` sense) to prevent accidental mutation.\n-    pub mir_map: RefCell<DepTrackingMap<maps::Mir<'tcx>>>,\n+    pub maps: maps::Maps<'tcx>,\n \n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n@@ -458,9 +423,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub maybe_unused_trait_imports: NodeSet,\n \n-    // Records the type of every item.\n-    pub item_types: RefCell<DepTrackingMap<maps::Types<'tcx>>>,\n-\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n@@ -474,18 +436,9 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub lang_items: middle::lang_items::LanguageItems,\n \n-    /// Maps from def-id of a type or region parameter to its\n-    /// (inferred) variance.\n-    pub item_variance_map: RefCell<DepTrackingMap<maps::ItemVariances<'tcx>>>,\n-\n     /// True if the variance has been computed yet; false otherwise.\n     pub variance_computed: Cell<bool>,\n \n-    /// Maps a DefId of a type to a list of its inherent impls.\n-    /// Contains implementations of methods that are inherent to a type.\n-    /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n-\n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n     pub used_unsafe: RefCell<NodeSet>,\n@@ -495,10 +448,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// Set of trait imports actually used in the method resolution.\n-    /// This is used for warning unused imports.\n-    pub used_trait_imports: RefCell<DepTrackingMap<maps::UsedTraitImports<'tcx>>>,\n-\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n@@ -507,10 +456,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// Results of evaluating monomorphic constants embedded in\n-    /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: RefCell<DepTrackingMap<maps::MonomorphicConstEval<'tcx>>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -529,23 +474,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// (i.e., no type or lifetime parameters).\n     pub fulfilled_predicates: RefCell<traits::GlobalFulfilledPredicates<'tcx>>,\n \n-    /// Caches the representation hints for struct definitions.\n-    repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n-\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n-    /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n-\n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_tys: RefCell<DepTrackingMap<maps::ClosureTypes<'tcx>>>,\n-\n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_kinds: RefCell<DepTrackingMap<maps::ClosureKinds<'tcx>>>,\n-\n     /// Maps Fn items to a collection of fragment infos.\n     ///\n     /// The main goal is to identify data (each of which may be moved\n@@ -754,46 +685,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n             free_region_maps: RefCell::new(FxHashMap()),\n-            item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n             trait_map: resolutions.trait_map,\n-            tables: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            adt_sized_constraint: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n-            mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            maps: maps::Maps::new(dep_graph),\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n-            item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),\n-            associated_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n-            inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            used_trait_imports: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n-            monomorphic_const_eval: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n-            custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n-            closure_tys: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            closure_kinds: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n@@ -1541,7 +1453,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-        self.repr_hint_cache.memoize(did, || {\n+        self.maps.repr_hints.memoize(did, || {\n             Rc::new(self.get_attrs(did).iter().flat_map(|meta| {\n                 attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n             }).collect())"}, {"sha": "c31895b3e9df793e39a3162cef883084189929a5", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // for local crates, check whether type info is\n             // available; typeck might not have completed yet\n-            self.impl_trait_refs.borrow().contains_key(&impl_def_id)\n+            self.maps.impl_trait_refs.borrow().contains_key(&impl_def_id)\n         };\n \n         if !use_types {"}, {"sha": "3e37bd50f942c8932e0dceea92fa5e29d90e2f5d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 90, "deletions": 26, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepNode, DepTrackingMapConfig};\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n-use mir;\n use ty::{self, Ty};\n use util::nodemap::DefIdSet;\n \n@@ -20,36 +19,101 @@ use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::attr;\n \n-macro_rules! dep_map_ty {\n-    ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n-        pub struct $ty_name<'tcx> {\n+macro_rules! define_maps {\n+    ($($(#[$attr:meta])* pub $field:ident: $node_name:ident($key:ty) -> $value:ty),*) => {\n+        pub struct Maps<'tcx> {\n+            $($(#[$attr])* pub $field: RefCell<DepTrackingMap<$field<'tcx>>>),*\n+        }\n+\n+        impl<'tcx> Maps<'tcx> {\n+            pub fn new(dep_graph: DepGraph) -> Self {\n+                Maps {\n+                    $($field: RefCell::new(DepTrackingMap::new(dep_graph.clone()))),*\n+                }\n+            }\n+        }\n+\n+        $(#[allow(bad_style)]\n+        pub struct $field<'tcx> {\n             data: PhantomData<&'tcx ()>\n         }\n \n-        impl<'tcx> DepTrackingMapConfig for $ty_name<'tcx> {\n+        impl<'tcx> DepTrackingMapConfig for $field<'tcx> {\n             type Key = $key;\n             type Value = $value;\n             fn to_dep_node(key: &$key) -> DepNode<DefId> { DepNode::$node_name(*key) }\n-        }\n+        })*\n     }\n }\n \n-dep_map_ty! { AssociatedItems: AssociatedItems(DefId) -> ty::AssociatedItem }\n-dep_map_ty! { Types: ItemSignature(DefId) -> Ty<'tcx> }\n-dep_map_ty! { Generics: ItemSignature(DefId) -> &'tcx ty::Generics }\n-dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n-dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n-dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n-dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef }\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> &'tcx ty::AdtDef }\n-dep_map_ty! { AdtSizedConstraint: SizedConstraint(DefId) -> Ty<'tcx> }\n-dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n-dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n-dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n-dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }\n-dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n-dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n-dep_map_ty! { TypeckTables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx> }\n-dep_map_ty! { UsedTraitImports: UsedTraitImports(DefId) -> DefIdSet }\n-dep_map_ty! { MonomorphicConstEval: MonomorphicConstEval(DefId) -> Result<ConstVal, ()> }\n+define_maps! {\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    pub associated_items: AssociatedItems(DefId) -> ty::AssociatedItem,\n+\n+    /// Records the type of every item.\n+    pub types: ItemSignature(DefId) -> Ty<'tcx>,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+    /// associated generics and predicates.\n+    pub generics: ItemSignature(DefId) -> &'tcx ty::Generics,\n+    pub predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    pub super_predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+\n+    pub impl_trait_refs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    pub trait_defs: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n+    pub adt_defs: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n+\n+    /// Maps from def-id of a type or region parameter to its\n+    /// (inferred) variance.\n+    pub variances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+\n+    /// Maps a DefId of a type to a list of its inherent impls.\n+    /// Contains implementations of methods that are inherent to a type.\n+    /// Methods in these implementations don't need to be exported.\n+    pub inherent_impls: InherentImpls(DefId) -> Vec<DefId>,\n+\n+    /// Caches the representation hints for struct definitions.\n+    pub repr_hints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>>,\n+\n+    /// Maps from the def-id of a function/method or const/static\n+    /// to its MIR. Mutation is done at an item granularity to\n+    /// allow MIR optimization passes to function and still\n+    /// access cross-crate MIR (e.g. inlining or const eval).\n+    ///\n+    /// Note that cross-crate MIR appears to be always borrowed\n+    /// (in the `RefCell` sense) to prevent accidental mutation.\n+    pub mir: Mir(DefId) -> &'tcx RefCell<::mir::Mir<'tcx>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: ItemSignature(DefId) -> ty::ClosureKind,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_types: ItemSignature(DefId) -> ty::ClosureTy<'tcx>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    pub custom_coerce_unsized_kinds: ItemSignature(DefId)\n+        -> ty::adjustment::CustomCoerceUnsized,\n+\n+    pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+\n+    /// Set of trait imports actually used in the method resolution.\n+    /// This is used for warning unused imports.\n+    pub used_trait_imports: UsedTraitImports(DefId) -> DefIdSet,\n+\n+    /// Results of evaluating monomorphic constants embedded in\n+    /// other items, such as enum variant explicit discriminants.\n+    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal, ()>\n+}"}, {"sha": "7e0a35916d0bcf23e57ae3d806133d482a22139c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -1592,7 +1592,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().map(move |v| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                match tcx.monomorphic_const_eval.borrow()[&expr_did] {\n+                match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n@@ -1646,7 +1646,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                                         stack: &mut Vec<DefId>)\n                                         -> Ty<'tcx>\n     {\n-        if let Some(ty) = tcx.adt_sized_constraint.borrow().get(&self.did) {\n+        if let Some(ty) = tcx.maps.adt_sized_constraint.borrow().get(&self.did) {\n             return ty;\n         }\n \n@@ -1660,7 +1660,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            tcx.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n+            tcx.maps.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n             return tcx.types.err;\n         }\n \n@@ -1684,7 +1684,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             _ => tcx.intern_tup(&tys[..], false)\n         };\n \n-        let old = tcx.adt_sized_constraint.borrow().get(&self.did).cloned();\n+        let old = tcx.maps.adt_sized_constraint.borrow().get(&self.did).cloned();\n         match old {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n@@ -1693,7 +1693,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                tcx.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n+                tcx.maps.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n                 ty\n             }\n         }\n@@ -1969,7 +1969,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn item_tables(self, def_id: DefId) -> &'gcx TypeckTables<'gcx> {\n-        self.tables.memoize(def_id, || {\n+        self.maps.typeck_tables.memoize(def_id, || {\n             if def_id.is_local() {\n                 // Closures' tables come from their outermost function,\n                 // as they are part of the same \"inference environment\".\n@@ -1983,7 +1983,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // Cross-crate side-tables only exist alongside serialized HIR.\n             self.sess.cstore.maybe_get_item_body(self.global_tcx(), def_id).map(|_| {\n-                self.tables.borrow()[&def_id]\n+                self.maps.typeck_tables.borrow()[&def_id]\n             }).unwrap_or_else(|| {\n                 bug!(\"tcx.item_tables({:?}): missing from metadata\", def_id)\n             })\n@@ -2095,7 +2095,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        self.custom_coerce_unsized_kinds.memoize(did, || {\n+        self.maps.custom_coerce_unsized_kinds.memoize(did, || {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n             } else {\n@@ -2114,7 +2114,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n-        self.associated_items.memoize(def_id, || {\n+        self.maps.associated_items.memoize(def_id, || {\n             if !def_id.is_local() {\n                 return self.sess.cstore.associated_item(def_id)\n                            .expect(\"missing AssociatedItem in metadata\");\n@@ -2141,15 +2141,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             self.associated_item_from_impl_item_ref(parent_def_id,\n                                                                     impl_trait_ref.is_some(),\n                                                                     impl_item_ref);\n-                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n+                        self.maps.associated_items.borrow_mut()\n+                            .insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n \n                 hir::ItemTrait(.., ref trait_item_refs) => {\n                     for trait_item_ref in trait_item_refs {\n                         let assoc_item =\n                             self.associated_item_from_trait_item_ref(parent_def_id, trait_item_ref);\n-                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n+                        self.maps.associated_items.borrow_mut()\n+                            .insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n \n@@ -2160,7 +2162,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // memoize wants us to return something, so return\n             // the one we generated for this def-id\n-            *self.associated_items.borrow().get(&def_id).unwrap()\n+            *self.maps.associated_items.borrow().get(&def_id).unwrap()\n         })\n     }\n \n@@ -2218,7 +2220,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n-        self.associated_item_def_ids.memoize(def_id, || {\n+        self.maps.associated_item_def_ids.memoize(def_id, || {\n             if !def_id.is_local() {\n                 return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n             }\n@@ -2255,7 +2257,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// an inherent impl.\n     pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n         lookup_locally_or_in_crate_store(\n-            \"impl_trait_refs\", id, &self.impl_trait_refs,\n+            \"impl_trait_refs\", id, &self.maps.impl_trait_refs,\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n@@ -2336,49 +2338,49 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // the type cache. Returns the type parameters and type.\n     pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n         lookup_locally_or_in_crate_store(\n-            \"item_types\", did, &self.item_types,\n+            \"item_types\", did, &self.maps.types,\n             || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n         lookup_locally_or_in_crate_store(\n-            \"trait_defs\", did, &self.trait_defs,\n+            \"trait_defs\", did, &self.maps.trait_defs,\n             || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n         )\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n     pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n         lookup_locally_or_in_crate_store(\n-            \"adt_defs\", did, &self.adt_defs,\n+            \"adt_defs\", did, &self.maps.adt_defs,\n             || self.sess.cstore.adt_def(self.global_tcx(), did))\n     }\n \n     /// Given the did of an item, returns its generics.\n     pub fn item_generics(self, did: DefId) -> &'gcx Generics {\n         lookup_locally_or_in_crate_store(\n-            \"generics\", did, &self.generics,\n+            \"generics\", did, &self.maps.generics,\n             || self.alloc_generics(self.sess.cstore.item_generics(did)))\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n     pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n-            \"predicates\", did, &self.predicates,\n+            \"predicates\", did, &self.maps.predicates,\n             || self.sess.cstore.item_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n-            \"super_predicates\", did, &self.super_predicates,\n+            \"super_predicates\", did, &self.maps.super_predicates,\n             || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of an item, returns its MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        lookup_locally_or_in_crate_store(\"mir_map\", did, &self.mir_map, || {\n+        lookup_locally_or_in_crate_store(\"mir_map\", did, &self.maps.mir, || {\n             let mir = self.sess.cstore.get_item_mir(self.global_tcx(), did);\n             let mir = self.alloc_mir(mir);\n \n@@ -2450,7 +2452,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n         lookup_locally_or_in_crate_store(\n-            \"item_variance_map\", item_id, &self.item_variance_map,\n+            \"item_variance_map\", item_id, &self.maps.variances,\n             || Rc::new(self.sess.cstore.item_variances(item_id)))\n     }\n \n@@ -2488,7 +2490,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n \n-        self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n+        self.maps.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n     }\n \n@@ -2529,12 +2531,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n-        if let Some(&kind) = self.closure_kinds.borrow().get(&def_id) {\n+        if let Some(&kind) = self.maps.closure_kinds.borrow().get(&def_id) {\n             return kind;\n         }\n \n         let kind = self.sess.cstore.closure_kind(def_id);\n-        self.closure_kinds.borrow_mut().insert(def_id, kind);\n+        self.maps.closure_kinds.borrow_mut().insert(def_id, kind);\n         kind\n     }\n \n@@ -2546,12 +2548,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n-        if let Some(ty) = self.closure_tys.borrow().get(&def_id) {\n+        if let Some(ty) = self.maps.closure_types.borrow().get(&def_id) {\n             return ty.subst(self, substs.substs);\n         }\n \n         let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n-        self.closure_tys.borrow_mut().insert(def_id, ty.clone());\n+        self.maps.closure_types.borrow_mut().insert(def_id, ty.clone());\n         ty.subst(self, substs.substs)\n     }\n \n@@ -2572,7 +2574,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n         }\n-        match self.associated_items.borrow().get(&def_id).cloned() {\n+        match self.maps.associated_items.borrow().get(&def_id).cloned() {\n             Some(trait_item) => {\n                 match trait_item.container {\n                     TraitContainer(_) => None,\n@@ -2590,7 +2592,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.associated_items.borrow().get(&def_id) {\n+        match self.maps.associated_items.borrow().get(&def_id) {\n             Some(associated_item) => {\n                 match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),"}, {"sha": "fa53760eca4666dd2ffe0b4e1f557b98f7a798f8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -770,7 +770,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n-                          !tcx.item_types.borrow().contains_key(&def.did) {\n+                          !tcx.maps.types.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n                         parameterized(f, substs, def.did, &[])"}, {"sha": "13ece31f4ce13eb4a52938855dbf5cb1aa46cc73", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -58,7 +58,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         return variant.node.disr_expr.map(|e| {\n                             let def_id = tcx.hir.body_owner_def_id(e);\n                             (&tcx.hir.body(e).value,\n-                             tcx.tables.borrow().get(&def_id).cloned())\n+                             tcx.maps.typeck_tables.borrow().get(&def_id).cloned())\n                         });\n                     }\n                 }\n@@ -89,7 +89,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 node: hir::ImplItemKind::Const(ref ty, body), ..\n             })) => {\n                 Some((&tcx.hir.body(body).value,\n-                      tcx.tables.borrow().get(&def_id).cloned(),\n+                      tcx.maps.typeck_tables.borrow().get(&def_id).cloned(),\n                       tcx.ast_ty_to_prim_ty(ty)))\n             }\n             Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n@@ -102,7 +102,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let trait_id = tcx.hir.local_def_id(trait_id);\n                         let default_value = default.map(|body| {\n                             (&tcx.hir.body(body).value,\n-                             tcx.tables.borrow().get(&def_id).cloned(),\n+                             tcx.maps.typeck_tables.borrow().get(&def_id).cloned(),\n                              tcx.ast_ty_to_prim_ty(ty))\n                         });\n                         resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n@@ -156,7 +156,7 @@ fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n                 Some((tcx.hir.body(fn_like.body()),\n-                      tcx.tables.borrow().get(&def_id).cloned()))\n+                      tcx.maps.typeck_tables.borrow().get(&def_id).cloned()))\n             } else {\n                 None\n             }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n         let def_id = tcx.hir.body_owner_def_id(body);\n         ConstContext {\n             tcx: tcx,\n-            tables: tcx.tables.borrow().get(&def_id).cloned(),\n+            tables: tcx.maps.typeck_tables.borrow().get(&def_id).cloned(),\n             fn_args: None\n         }\n     }"}, {"sha": "429e4ffef0c2a793efcb9c8289c5df1c2dd57bd6", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -996,11 +996,13 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 } else {\n                     match ppm {\n                         PpmMir => {\n-                            write_mir_pretty(tcx, tcx.mir_map.borrow().keys().into_iter(), &mut out)\n+                            write_mir_pretty(tcx,\n+                                             tcx.maps.mir.borrow().keys().into_iter(),\n+                                             &mut out)\n                         }\n                         PpmMirCFG => {\n                             write_mir_graphviz(tcx,\n-                                               tcx.mir_map.borrow().keys().into_iter(),\n+                                               tcx.maps.mir.borrow().keys().into_iter(),\n                                                &mut out)\n                         }\n                         _ => unreachable!(),"}, {"sha": "5fcefe0d53997250b01c637c40ce4d8063fcd9ea", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -29,7 +29,7 @@ pub enum MethodLateContext {\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.hir.local_def_id(id);\n-    match cx.tcx.associated_items.borrow().get(&def_id) {\n+    match cx.tcx.maps.associated_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {\n             match item.container {"}, {"sha": "aa18fbe2ba8cdaaee35962dec7f7b89e5eb5cf66", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n         if let ty::VariantDiscr::Explicit(def_id) = data.discr {\n             let result = data.evaluated_discr.map_or(Err(()), Ok);\n-            tcx.monomorphic_const_eval.borrow_mut().insert(def_id, result);\n+            tcx.maps.monomorphic_const_eval.borrow_mut().insert(def_id, result);\n         }\n \n         (ty::VariantDef {\n@@ -584,7 +584,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n-            tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n+            tcx.maps.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n         }\n \n         adt\n@@ -789,7 +789,7 @@ impl<'a, 'tcx> CrateMetadata {\n             let ast = ast.decode(self);\n \n             let tables = ast.tables.decode((self, tcx));\n-            tcx.tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n+            tcx.maps.typeck_tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n \n             let body = ast.body.decode((self, tcx));\n             tcx.hir.intern_inlined_body(def_id, body)"}, {"sha": "e6110172fc41fe28ab6fd050cf363543ce13806f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             discr: variant.discr,\n             evaluated_discr: match variant.discr {\n                 ty::VariantDiscr::Explicit(def_id) => {\n-                    tcx.monomorphic_const_eval.borrow()[&def_id].clone().ok()\n+                    tcx.maps.monomorphic_const_eval.borrow()[&def_id].clone().ok()\n                 }\n                 ty::VariantDiscr::Relative(_) => None\n             },\n@@ -604,12 +604,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n-        self.tcx.mir_map.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n+        self.tcx.maps.mir.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n-        match self.tcx.inherent_impls.borrow().get(&def_id) {\n+        match self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n             None => LazySeq::empty(),\n             Some(implementations) => {\n                 self.lazy_seq(implementations.iter().map(|&def_id| {\n@@ -711,7 +711,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds\n+                    coerce_unsized_kind: tcx.maps.custom_coerce_unsized_kinds\n                         .borrow()\n                         .get(&def_id)\n                         .cloned(),\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.closure_tys.borrow()[&def_id]),\n+            ty: self.lazy(&tcx.maps.closure_types.borrow()[&def_id]),\n         };\n \n         Entry {"}, {"sha": "913b0d5fb8ae883bc1d4d53aeb0a9f4eac5042c0", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n             let mir = tcx.alloc_mir(mir);\n             let def_id = tcx.hir.local_def_id(src.item_id());\n-            tcx.mir_map.borrow_mut().insert(def_id, mir);\n+            tcx.maps.mir.borrow_mut().insert(def_id, mir);\n         });\n \n         let body = self.tcx.hir.body(body_id);"}, {"sha": "ad20c535decbbd63946aaa12abdd53da75dc8ad0", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -44,7 +44,7 @@ pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n     // For debugging instrumentation like this, we don't need to worry\n     // about maintaining the dep graph.\n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mir_map = tcx.mir_map.borrow();\n+    let mir_map = tcx.maps.mir.borrow();\n     for def_id in mir_map.keys() {\n         let mir = mir_map.get(&def_id).unwrap();\n         collector.visit_mir(&mir.borrow());"}, {"sha": "3c275e0996dac0c3877c693f5bad6a7763cf0274", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -112,7 +112,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        match self.tcx.tables.borrow().get(&item_def_id) {\n+        match self.tcx.maps.typeck_tables.borrow().get(&item_def_id) {\n             Some(tables) => {\n                 let old_tables = self.save_ctxt.tables;\n                 self.save_ctxt.tables = tables;"}, {"sha": "a940faac8387735a7288f915564ea3b1dc0f88a0", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -28,7 +28,7 @@ impl Disr {\n                     explicit_index -= distance;\n                 }\n                 ty::VariantDiscr::Explicit(expr_did) => {\n-                    match tcx.monomorphic_const_eval.borrow()[&expr_did] {\n+                    match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n                         Ok(ConstVal::Integral(v)) => {\n                             explicit_value = Disr::from(v);\n                             break;"}, {"sha": "11ad47eef7159cc5b32c9f99808cf229bc933970", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -1209,7 +1209,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                 ast_ty.span);\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n-                    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+                    tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n                         parent: None,\n                         predicates: predicates\n                     });"}, {"sha": "468a38cd2bace9f894c1da83438fadd401b2e839", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // metadata if necessary.\n         self.tcx.populate_inherent_implementations_for_type_if_necessary(def_id);\n \n-        if let Some(impl_infos) = self.tcx.inherent_impls.borrow().get(&def_id) {\n+        if let Some(impl_infos) = self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in impl_infos.iter() {\n                 self.assemble_inherent_impl_probe(impl_def_id);\n             }"}, {"sha": "b3a4b83b6832c0e8dfb597c64bfadce8191dfdf9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -56,12 +56,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_lints();\n \n         let tables = self.tcx.alloc_tables(wbcx.tables);\n-        self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n+        self.tcx.maps.typeck_tables.borrow_mut().insert(item_def_id, tables);\n \n         let used_trait_imports = mem::replace(&mut *self.used_trait_imports.borrow_mut(),\n                                               DefIdSet());\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n-        self.tcx.used_trait_imports.borrow_mut().insert(item_def_id, used_trait_imports);\n+        self.tcx.maps.used_trait_imports.borrow_mut().insert(item_def_id, used_trait_imports);\n     }\n }\n \n@@ -290,12 +290,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n             let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().closure_tys.borrow_mut().insert(def_id, closure_ty);\n+            self.tcx().maps.closure_types.borrow_mut().insert(def_id, closure_ty);\n         }\n \n         for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n             let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().closure_kinds.borrow_mut().insert(def_id, closure_kind);\n+            self.tcx().maps.closure_kinds.borrow_mut().insert(def_id, closure_kind);\n         }\n     }\n \n@@ -361,7 +361,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.item_types.borrow_mut().insert(def_id, outside_ty);\n+            gcx.maps.types.borrow_mut().insert(def_id, outside_ty);\n         }\n     }\n "}, {"sha": "0f992f75fce34a94cd963f39706eeb43b61ad327", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -70,7 +70,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let item_def_id = tcx.hir.local_def_id(item_id);\n \n         // this will have been written by the main typeck pass\n-        if let Some(imports) = tcx.used_trait_imports.borrow().get(&item_def_id) {\n+        if let Some(imports) = tcx.maps.used_trait_imports.borrow().get(&item_def_id) {\n             debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n             used_trait_imports.extend(imports);\n         } else {"}, {"sha": "e15386b87ad97ef3e589858c0d919c24daa1096b", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -341,7 +341,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n         if let Some(kind) = kind {\n-            tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+            tcx.maps.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n         }\n     });\n }"}, {"sha": "1301f33d30b0819b21dbfbd93a99986f94b497e6", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -39,7 +39,7 @@ mod unsafety;\n \n struct CoherenceCollect<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    inherent_impls: RefMut<'a, DepTrackingMap<maps::InherentImpls<'tcx>>>,\n+    inherent_impls: RefMut<'a, DepTrackingMap<maps::inherent_impls<'tcx>>>,\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n@@ -58,7 +58,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n \n impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n     fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        let inherent_impls = tcx.inherent_impls.borrow_mut();\n+        let inherent_impls = tcx.maps.inherent_impls.borrow_mut();\n         let mut this = &mut CoherenceCollect { tcx, inherent_impls };\n \n         // Check implementations and traits. This populates the tables"}, {"sha": "45493d40eb802e3375e9cda0b9bb253a81928b41", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -79,7 +79,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n         let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n \n-        let inherent_impls = self.tcx.inherent_impls.borrow();\n+        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n         let impls = match inherent_impls.get(&ty_def_id) {\n             Some(impls) => impls,\n             None => return,"}, {"sha": "3851cd2bb442ad4bc1f0bcce9337409f8b373e43", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -606,8 +606,8 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     generics_of_def_id(ccx, ty_f.did);\n     let tt = ccx.icx(ty_f.did).to_ty(&field.ty);\n-    ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n-    ccx.tcx.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n+    ccx.tcx.maps.types.borrow_mut().insert(ty_f.did, tt);\n+    ccx.tcx.maps.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n         parent: Some(ccx.tcx.hir.get_parent_did(field.id)),\n         predicates: vec![]\n     });\n@@ -619,7 +619,7 @@ fn convert_method(ccx: &CrateCtxt, id: ast::NodeId, sig: &hir::MethodSig) {\n     let fty = AstConv::ty_of_fn(&ccx.icx(def_id), sig.unsafety, sig.abi, &sig.decl);\n     let substs = mk_item_substs(ccx, def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n-    ccx.tcx.item_types.borrow_mut().insert(def_id, fty);\n+    ccx.tcx.maps.types.borrow_mut().insert(def_id, fty);\n \n     ty_generic_predicates(ccx, def_id, &sig.generics);\n }\n@@ -634,8 +634,8 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         predicates: vec![]\n     };\n     let def_id = ccx.tcx.hir.local_def_id(id);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n-    ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n+    ccx.tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n+    ccx.tcx.maps.types.borrow_mut().insert(def_id, ty);\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -648,10 +648,10 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         predicates: vec![]\n     };\n     let def_id = ccx.tcx.hir.local_def_id(id);\n-    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n+    ccx.tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n \n     if let Some(ty) = ty {\n-        ccx.tcx.item_types.borrow_mut().insert(def_id, ty);\n+        ccx.tcx.maps.types.borrow_mut().insert(def_id, ty);\n     }\n }\n \n@@ -725,8 +725,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n-                                                    Some(trait_ref));\n+            tcx.maps.impl_trait_refs.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n+                                                         Some(trait_ref));\n         }\n         hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n             generics_of_def_id(ccx, def_id);\n@@ -735,7 +735,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n             });\n-            tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n+            tcx.maps.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n             predicates_of_item(ccx, it);\n         },\n@@ -864,8 +864,8 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }))\n         }\n     };\n-    tcx.item_types.borrow_mut().insert(def_id, ctor_ty);\n-    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+    tcx.maps.types.borrow_mut().insert(def_id, ctor_ty);\n+    tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n         parent: Some(ccx.tcx.hir.get_parent_did(ctor_id)),\n         predicates: vec![]\n     });\n@@ -888,7 +888,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let result = evaluate_disr_expr(ccx, repr_type, e);\n \n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            tcx.monomorphic_const_eval.borrow_mut()\n+            tcx.maps.monomorphic_const_eval.borrow_mut()\n                .insert(expr_did, result.map(ConstVal::Integral));\n \n             result.ok()\n@@ -966,10 +966,10 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n-        ccx.tcx.adt_defs.borrow_mut().insert(ctor_id, adt);\n+        ccx.tcx.maps.adt_defs.borrow_mut().insert(ctor_id, adt);\n     }\n \n-    ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n+    ccx.tcx.maps.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n@@ -983,7 +983,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                ty::VariantDiscr::Relative(0), def)];\n \n     let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n-    ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n+    ccx.tcx.maps.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n@@ -1061,7 +1061,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let did = tcx.hir.local_def_id(it.id);\n     let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n-    tcx.adt_defs.borrow_mut().insert(did, adt);\n+    tcx.maps.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n@@ -1091,7 +1091,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         return Vec::new();\n     };\n \n-    let superpredicates = tcx.super_predicates.borrow().get(&trait_def_id).cloned();\n+    let superpredicates = tcx.maps.super_predicates.borrow().get(&trait_def_id).cloned();\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n         let item = match ccx.tcx.hir.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n@@ -1130,7 +1130,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                tcx.hir.local_def_id(item.id),\n                superpredicates);\n \n-        tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n+        tcx.maps.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n \n         superpredicates\n     });\n@@ -1150,7 +1150,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'t\n     let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(it.id);\n \n-    tcx.trait_defs.memoize(def_id, || {\n+    tcx.maps.trait_defs.memoize(def_id, || {\n         let unsafety = match it.node {\n             hir::ItemTrait(unsafety, ..) => unsafety,\n             _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n@@ -1182,7 +1182,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     } else {\n         return tcx.item_generics(def_id);\n     };\n-    tcx.generics.memoize(def_id, || {\n+    tcx.maps.generics.memoize(def_id, || {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n@@ -1380,7 +1380,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     } else {\n         return ccx.tcx.item_type(def_id);\n     };\n-    ccx.tcx.item_types.memoize(def_id, || {\n+    ccx.tcx.maps.types.memoize(def_id, || {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n@@ -1718,7 +1718,7 @@ fn ty_generic_predicates(ccx: &CrateCtxt, def_id: DefId, ast_generics: &hir::Gen\n                                            &mut ctp::parameters_for_impl(self_ty, trait_ref));\n     }\n \n-    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+    tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n         parent: generics.parent,\n         predicates: predicates\n     });"}, {"sha": "3d2b746b85548e0d36fcb52caf0ca1dc3954d4c7", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -13,12 +13,10 @@\n //! The second pass over the AST determines the set of constraints.\n //! We walk the set of items and, for each member, generate new constraints.\n \n-use dep_graph::DepTrackingMapConfig;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::maps::ItemVariances;\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n@@ -28,6 +26,8 @@ use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n+use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n+\n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n@@ -65,8 +65,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n-                                      &mut constraint_cx);\n+    tcx.visit_all_item_likes_in_krate(VarianceDepNode, &mut constraint_cx);\n \n     constraint_cx\n }\n@@ -291,7 +290,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // This edge is actually implied by the call to\n         // `lookup_trait_def`, but I'm trying to be future-proof. See\n         // README.md for a discussion on dep-graph management.\n-        self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+        self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n         self.add_constraints_from_substs(generics,\n                                          trait_ref.def_id,\n@@ -350,7 +349,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n                 // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n+                self.tcx().dep_graph.read(VarianceDepNode(def.did));\n \n                 self.add_constraints_from_substs(generics,\n                                                  def.did,\n@@ -367,7 +366,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n                 // README.md for a discussion on dep-graph management.\n-                self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n+                self.tcx().dep_graph.read(VarianceDepNode(trait_ref.def_id));\n \n                 self.add_constraints_from_substs(generics,\n                                                  trait_ref.def_id,"}, {"sha": "6628c7c521fd103dec06ea7f5489b3f94d5dbecc", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                           item_variances);\n             }\n \n-            tcx.item_variance_map\n+            tcx.maps.variances\n                .borrow_mut()\n                .insert(item_def_id, Rc::new(item_variances));\n         }"}, {"sha": "36352f50e4406237115aa36abf42d55a53438c38", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -20,9 +20,7 @@\n // a variable.\n \n use arena::TypedArena;\n-use dep_graph::DepTrackingMapConfig;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::maps::ItemVariances;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -34,6 +32,8 @@ use self::VarianceTerm::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n+use dep_graph::DepNode::ItemSignature as VarianceDepNode;\n+\n #[derive(Copy, Clone, Debug)]\n pub struct InferredIndex(pub usize);\n \n@@ -109,7 +109,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_item_likes_in_krate(|def_id| ItemVariances::to_dep_node(&def_id), &mut terms_cx);\n+    tcx.visit_all_item_likes_in_krate(|def_id| VarianceDepNode(def_id), &mut terms_cx);\n \n     terms_cx\n }\n@@ -178,8 +178,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n             let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            self.tcx\n-                .item_variance_map\n+            self.tcx.maps.variances\n                 .borrow_mut()\n                 .insert(item_def_id, self.empty_variances.clone());\n         }"}, {"sha": "02d934783d464a1d318066ba79aa7a82e4d4e3d5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8a3a93b70f6805e235199029c3948515f99226/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cc8a3a93b70f6805e235199029c3948515f99226", "patch": "@@ -238,7 +238,7 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n-    if let Some(i) = tcx.inherent_impls.borrow().get(&did) {\n+    if let Some(i) = tcx.maps.inherent_impls.borrow().get(&did) {\n         for &did in i.iter() {\n             build_impl(cx, did, &mut impls);\n         }"}]}