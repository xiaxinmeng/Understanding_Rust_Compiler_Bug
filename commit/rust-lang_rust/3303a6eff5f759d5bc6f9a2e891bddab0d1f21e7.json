{"sha": "3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "node_id": "C_kwDOAAsO6NoAKDMzMDNhNmVmZjVmNzU5ZDViYzZmOWEyZTg5MWJkZGFiMGQxZjIxZTc", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-20T18:18:01Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-20T18:18:01Z"}, "message": "Implement some intrinsics", "tree": {"sha": "05d0e1ed25e457b8cbf58e4e819bd7e510a5ad2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d0e1ed25e457b8cbf58e4e819bd7e510a5ad2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "html_url": "https://github.com/rust-lang/rust/commit/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e73ea52537fe5189fac5cd02380592563fe7f0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e73ea52537fe5189fac5cd02380592563fe7f0c", "html_url": "https://github.com/rust-lang/rust/commit/8e73ea52537fe5189fac5cd02380592563fe7f0c"}], "stats": {"total": 666, "additions": 521, "deletions": 145}, "files": [{"sha": "47ef26fc58606b4c3d993ab2447d1f813e8b2a90", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -11,6 +11,8 @@ use super::{\n     ConstEvalError,\n };\n \n+mod intrinsics;\n+\n fn simplify(e: ConstEvalError) -> ConstEvalError {\n     match e {\n         ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e)) => {\n@@ -82,6 +84,49 @@ fn bit_op() {\n     check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n }\n \n+#[test]\n+fn casts() {\n+    check_number(r#\"const GOAL: usize = 12 as *const i32 as usize\"#, 12);\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: i32 = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[i32] = &a;\n+        let y: *const [i32] = x;\n+        let z = y as *const i32;\n+        unsafe { *z }\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: i16 = {\n+        let a = &mut 5;\n+        let z = a as *mut _;\n+        unsafe { *z }\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[i32] = &a;\n+        let y: *const [i32] = x;\n+        let z = y as *const [u8]; // slice fat pointer cast don't touch metadata\n+        let w = unsafe { &*z };\n+        w.len()\n+    };\n+        \"#,\n+        4,\n+    );\n+}\n+\n #[test]\n fn locals() {\n     check_number(\n@@ -279,20 +324,6 @@ fn function_call() {\n     );\n }\n \n-#[test]\n-fn intrinsics() {\n-    check_number(\n-        r#\"\n-    extern \"rust-intrinsic\" {\n-        pub fn size_of<T>() -> usize;\n-    }\n-\n-    const GOAL: usize = size_of::<i32>();\n-    \"#,\n-        4,\n-    );\n-}\n-\n #[test]\n fn trait_basic() {\n     check_number(\n@@ -1353,6 +1384,17 @@ fn array_and_index() {\n     check_number(\n         r#\"\n     //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = [1, 2, 3];\n+        let x: &[i32] = &a;\n+        let y = &*x;\n+        y.len()\n+    };\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n     const GOAL: usize = [1, 2, 3, 4, 5].len();\"#,\n         5,\n     );"}, {"sha": "371d5cab3378ddccdf92da5102abcf1c8100befc", "filename": "crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -0,0 +1,162 @@\n+use super::*;\n+\n+#[test]\n+fn size_of() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn size_of<T>() -> usize;\n+        }\n+\n+        const GOAL: usize = size_of::<i32>();\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn transmute() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn transmute<T, U>(e: T) -> U;\n+        }\n+\n+        const GOAL: i32 = transmute((1i16, 1i16));\n+        \"#,\n+        0x00010001,\n+    );\n+}\n+\n+#[test]\n+fn const_eval_select() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n+            where\n+                G: FnOnce<ARG, Output = RET>,\n+                F: FnOnce<ARG, Output = RET>;\n+        }\n+\n+        const fn in_const(x: i32, y: i32) -> i32 {\n+            x + y\n+        }\n+\n+        fn in_rt(x: i32, y: i32) -> i32 {\n+            x + y\n+        }\n+\n+        const GOAL: i32 = const_eval_select((2, 3), in_const, in_rt);\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn wrapping_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn wrapping_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: u8 = wrapping_add(10, 250);\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn offset() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ar: &[(u8, u8, u8)] = &[\n+                (10, 11, 12),\n+                (20, 21, 22),\n+                (30, 31, 32),\n+                (40, 41, 42),\n+                (50, 51, 52),\n+            ];\n+            let ar: *const [(u8, u8, u8)] = ar;\n+            let ar = ar as *const (u8, u8, u8);\n+            let element = offset(ar, 2);\n+            element.1\n+        };\n+        \"#,\n+        31,\n+    );\n+}\n+\n+#[test]\n+fn arith_offset() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ar: &[(u8, u8, u8)] = &[\n+                (10, 11, 12),\n+                (20, 21, 22),\n+                (30, 31, 32),\n+                (40, 41, 42),\n+                (50, 51, 52),\n+            ];\n+            let ar: *const [(u8, u8, u8)] = ar;\n+            let ar = ar as *const (u8, u8, u8);\n+            let element = arith_offset(arith_offset(ar, 102), -100);\n+            element.1\n+        };\n+        \"#,\n+        31,\n+    );\n+}\n+\n+#[test]\n+fn copy_nonoverlapping() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let mut x = 2;\n+            let y = 5;\n+            copy_nonoverlapping(&y, &mut x, 1);\n+            x\n+        };\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn copy() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+        }\n+\n+        const GOAL: i32 = unsafe {\n+            let mut x = [1i32, 2, 3, 4, 5];\n+            let y = (&mut x as *mut _) as *mut i32;\n+            let z = (y as usize + 4) as *const i32;\n+            copy(z, y, 4);\n+            x[0] + x[1] + x[2] + x[3] + x[4]\n+        };\n+        \"#,\n+        19,\n+    );\n+}"}, {"sha": "d14b3f7140e4aeac7d73596c6957ef3aef538a8b", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -630,8 +630,15 @@ impl<'a> InferenceContext<'a> {\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME: propagate the \"castable to\" expectation\n-                let _inner_ty = self.infer_expr_no_expect(*expr);\n-                // FIXME check the cast...\n+                let inner_ty = self.infer_expr_no_expect(*expr);\n+                match (inner_ty.kind(Interner), cast_ty.kind(Interner)) {\n+                    (TyKind::Ref(_, _, inner), TyKind::Raw(_, cast)) => {\n+                        // FIXME: record invalid cast diagnostic in case of mismatch\n+                        self.unify(inner, cast);\n+                    }\n+                    // FIXME check the other kinds of cast...\n+                    _ => (),\n+                }\n                 cast_ty\n             }\n             Expr::Ref { expr, rawness, mutability } => {"}, {"sha": "26bf877cf0b0fc8c674608567d06ae42d654990b", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 274, "deletions": 109, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -96,11 +96,18 @@ enum Address {\n \n use Address::*;\n \n+#[derive(Debug, Clone, Copy)]\n struct Interval {\n     addr: Address,\n     size: usize,\n }\n \n+#[derive(Debug, Clone)]\n+struct IntervalAndTy {\n+    interval: Interval,\n+    ty: Ty,\n+}\n+\n impl Interval {\n     fn new(addr: Address, size: usize) -> Self {\n         Self { addr, size }\n@@ -110,11 +117,37 @@ impl Interval {\n         memory.read_memory(self.addr, self.size)\n     }\n \n+    fn write_from_bytes(&self, memory: &mut Evaluator<'_>, bytes: &[u8]) -> Result<()> {\n+        memory.write_memory(self.addr, bytes)\n+    }\n+\n+    fn write_from_interval(&self, memory: &mut Evaluator<'_>, interval: Interval) -> Result<()> {\n+        // FIXME: this could be more efficent\n+        let bytes = &interval.get(memory)?.to_vec();\n+        memory.write_memory(self.addr, bytes)\n+    }\n+\n     fn slice(self, range: Range<usize>) -> Interval {\n         Interval { addr: self.addr.offset(range.start), size: range.len() }\n     }\n }\n \n+impl IntervalAndTy {\n+    fn get<'a>(&self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n+        memory.read_memory(self.interval.addr, self.interval.size)\n+    }\n+\n+    fn new(\n+        addr: Address,\n+        ty: Ty,\n+        evaluator: &Evaluator<'_>,\n+        locals: &Locals<'_>,\n+    ) -> Result<IntervalAndTy> {\n+        let size = evaluator.size_of_sized(&ty, locals, \"type of interval\")?;\n+        Ok(IntervalAndTy { interval: Interval { addr, size }, ty })\n+    }\n+}\n+\n enum IntervalOrOwned {\n     Owned(Vec<u8>),\n     Borrowed(Interval),\n@@ -135,7 +168,7 @@ impl Address {\n \n     fn from_usize(x: usize) -> Self {\n         if x > usize::MAX / 2 {\n-            Stack(usize::MAX - x)\n+            Stack(x - usize::MAX / 2)\n         } else {\n             Heap(x)\n         }\n@@ -147,7 +180,7 @@ impl Address {\n \n     fn to_usize(&self) -> usize {\n         let as_num = match self {\n-            Stack(x) => usize::MAX - *x,\n+            Stack(x) => *x + usize::MAX / 2,\n             Heap(x) => *x,\n         };\n         as_num\n@@ -174,7 +207,7 @@ pub enum MirEvalError {\n     /// Means that code had undefined behavior. We don't try to actively detect UB, but if it was detected\n     /// then use this type of error.\n     UndefinedBehavior(&'static str),\n-    Panic,\n+    Panic(String),\n     MirLowerError(FunctionId, MirLowerError),\n     TypeIsUnsized(Ty, &'static str),\n     NotSupported(String),\n@@ -197,7 +230,7 @@ impl std::fmt::Debug for MirEvalError {\n             Self::UndefinedBehavior(arg0) => {\n                 f.debug_tuple(\"UndefinedBehavior\").field(arg0).finish()\n             }\n-            Self::Panic => write!(f, \"Panic\"),\n+            Self::Panic(msg) => write!(f, \"Panic with message:\\n{msg:?}\"),\n             Self::TargetDataLayoutNotAvailable => write!(f, \"TargetDataLayoutNotAvailable\"),\n             Self::TypeIsUnsized(ty, it) => write!(f, \"{ty:?} is unsized. {it} should be sized.\"),\n             Self::ExecutionLimitExceeded => write!(f, \"execution limit exceeded\"),\n@@ -289,7 +322,19 @@ impl Evaluator<'_> {\n     }\n \n     fn place_addr(&self, p: &Place, locals: &Locals<'_>) -> Result<Address> {\n-        Ok(self.place_addr_and_ty(p, locals)?.0)\n+        Ok(self.place_addr_and_ty_and_metadata(p, locals)?.0)\n+    }\n+\n+    fn place_interval(&self, p: &Place, locals: &Locals<'_>) -> Result<Interval> {\n+        let place_addr_and_ty = self.place_addr_and_ty_and_metadata(p, locals)?;\n+        Ok(Interval {\n+            addr: place_addr_and_ty.0,\n+            size: self.size_of_sized(\n+                &place_addr_and_ty.1,\n+                locals,\n+                \"Type of place that we need its interval\",\n+            )?,\n+        })\n     }\n \n     fn ptr_size(&self) -> usize {\n@@ -299,10 +344,15 @@ impl Evaluator<'_> {\n         }\n     }\n \n-    fn place_addr_and_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<(Address, Ty)> {\n+    fn place_addr_and_ty_and_metadata<'a>(\n+        &'a self,\n+        p: &Place,\n+        locals: &'a Locals<'a>,\n+    ) -> Result<(Address, Ty, Option<Interval>)> {\n         let mut addr = locals.ptr[p.local];\n         let mut ty: Ty =\n             self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n+        let mut metadata = None; // locals are always sized\n         for proj in &p.projection {\n             match proj {\n                 ProjectionElem::Deref => {\n@@ -314,12 +364,18 @@ impl Evaluator<'_> {\n                             ))\n                         }\n                     };\n+                    metadata = if self.size_of(&ty, locals)?.is_none() {\n+                        Some(Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() })\n+                    } else {\n+                        None\n+                    };\n                     let x = from_bytes!(usize, self.read_memory(addr, self.ptr_size())?);\n                     addr = Address::from_usize(x);\n                 }\n                 ProjectionElem::Index(op) => {\n                     let offset =\n                         from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n+                    metadata = None; // Result of index is always sized\n                     match &ty.data(Interner).kind {\n                         TyKind::Ref(_, _, inner) => match &inner.data(Interner).kind {\n                             TyKind::Slice(inner) => {\n@@ -357,6 +413,7 @@ impl Evaluator<'_> {\n                             .clone();\n                         let offset = layout.fields.offset(f).bytes_usize();\n                         addr = addr.offset(offset);\n+                        metadata = None; // tuple field is always sized\n                     }\n                     _ => return Err(MirEvalError::TypeError(\"Only tuple has tuple fields\")),\n                 },\n@@ -386,6 +443,8 @@ impl Evaluator<'_> {\n                             .offset(u32::from(f.local_id.into_raw()) as usize)\n                             .bytes_usize();\n                         addr = addr.offset(offset);\n+                        // FIXME: support structs with unsized fields\n+                        metadata = None;\n                     }\n                     _ => return Err(MirEvalError::TypeError(\"Only adt has fields\")),\n                 },\n@@ -396,7 +455,7 @@ impl Evaluator<'_> {\n                 ProjectionElem::OpaqueCast(_) => not_supported!(\"opaque cast\"),\n             }\n         }\n-        Ok((addr, ty))\n+        Ok((addr, ty, metadata))\n     }\n \n     fn layout(&self, ty: &Ty) -> Result<Layout> {\n@@ -411,16 +470,23 @@ impl Evaluator<'_> {\n     }\n \n     fn place_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<Ty> {\n-        Ok(self.place_addr_and_ty(p, locals)?.1)\n+        Ok(self.place_addr_and_ty_and_metadata(p, locals)?.1)\n     }\n \n-    fn operand_ty<'a>(&'a self, o: &'a Operand, locals: &'a Locals<'a>) -> Result<Ty> {\n+    fn operand_ty(&self, o: &Operand, locals: &Locals<'_>) -> Result<Ty> {\n         Ok(match o {\n             Operand::Copy(p) | Operand::Move(p) => self.place_ty(p, locals)?,\n             Operand::Constant(c) => c.data(Interner).ty.clone(),\n         })\n     }\n \n+    fn operand_ty_and_eval(&mut self, o: &Operand, locals: &Locals<'_>) -> Result<IntervalAndTy> {\n+        Ok(IntervalAndTy {\n+            interval: self.eval_operand(o, locals)?,\n+            ty: self.operand_ty(o, locals)?,\n+        })\n+    }\n+\n     fn interpret_mir(\n         &mut self,\n         body: &MirBody,\n@@ -498,14 +564,19 @@ impl Evaluator<'_> {\n                     cleanup: _,\n                     from_hir_call: _,\n                 } => {\n+                    let destination = self.place_interval(destination, &locals)?;\n                     let fn_ty = self.operand_ty(func, &locals)?;\n+                    let args = args\n+                        .iter()\n+                        .map(|x| self.operand_ty_and_eval(x, &locals))\n+                        .collect::<Result<Vec<_>>>()?;\n                     match &fn_ty.data(Interner).kind {\n                         TyKind::Function(_) => {\n                             let bytes = self.eval_operand(func, &locals)?;\n-                            self.exec_fn_pointer(bytes, destination, args, &locals)?;\n+                            self.exec_fn_pointer(bytes, destination, &args, &locals)?;\n                         }\n                         TyKind::FnDef(def, generic_args) => {\n-                            self.exec_fn_def(*def, generic_args, destination, args, &locals)?;\n+                            self.exec_fn_def(*def, generic_args, destination, &args, &locals)?;\n                         }\n                         x => not_supported!(\"unknown function type {x:?}\"),\n                     }\n@@ -545,8 +616,12 @@ impl Evaluator<'_> {\n         Ok(match r {\n             Rvalue::Use(x) => Borrowed(self.eval_operand(x, locals)?),\n             Rvalue::Ref(_, p) => {\n-                let addr = self.place_addr(p, locals)?;\n-                Owned(addr.to_bytes())\n+                let (addr, _, metadata) = self.place_addr_and_ty_and_metadata(p, locals)?;\n+                let mut r = addr.to_bytes();\n+                if let Some(metadata) = metadata {\n+                    r.extend(metadata.get(self)?);\n+                }\n+                Owned(r)\n             }\n             Rvalue::Len(_) => not_supported!(\"rvalue len\"),\n             Rvalue::UnaryOp(op, val) => {\n@@ -624,8 +699,12 @@ impl Evaluator<'_> {\n                         let r = match op {\n                             BinOp::Add => l128.overflowing_add(r128).0,\n                             BinOp::Mul => l128.overflowing_mul(r128).0,\n-                            BinOp::Div => l128.checked_div(r128).ok_or(MirEvalError::Panic)?,\n-                            BinOp::Rem => l128.checked_rem(r128).ok_or(MirEvalError::Panic)?,\n+                            BinOp::Div => l128.checked_div(r128).ok_or_else(|| {\n+                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                            })?,\n+                            BinOp::Rem => l128.checked_rem(r128).ok_or_else(|| {\n+                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                            })?,\n                             BinOp::Sub => l128.overflowing_sub(r128).0,\n                             BinOp::BitAnd => l128 & r128,\n                             BinOp::BitOr => l128 | r128,\n@@ -635,16 +714,16 @@ impl Evaluator<'_> {\n                         let r = r.to_le_bytes();\n                         for &k in &r[lc.len()..] {\n                             if k != 0 && (k != 255 || !is_signed) {\n-                                return Err(MirEvalError::Panic);\n+                                return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                             }\n                         }\n                         Owned(r[0..lc.len()].into())\n                     }\n                     BinOp::Shl | BinOp::Shr => {\n                         let shift_amout = if r128 < 0 {\n-                            return Err(MirEvalError::Panic);\n+                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                         } else if r128 > 128 {\n-                            return Err(MirEvalError::Panic);\n+                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                         } else {\n                             r128 as u8\n                         };\n@@ -720,47 +799,54 @@ impl Evaluator<'_> {\n             }\n             Rvalue::ShallowInitBox(_, _) => not_supported!(\"shallow init box\"),\n             Rvalue::CopyForDeref(_) => not_supported!(\"copy for deref\"),\n-            Rvalue::Aggregate(kind, values) => match kind {\n-                AggregateKind::Array(_) => {\n-                    let mut r = vec![];\n-                    for x in values {\n-                        let value = self.eval_operand(x, locals)?.get(&self)?;\n-                        r.extend(value);\n+            Rvalue::Aggregate(kind, values) => {\n+                let values = values\n+                    .iter()\n+                    .map(|x| self.eval_operand(x, locals))\n+                    .collect::<Result<Vec<_>>>()?;\n+                match kind {\n+                    AggregateKind::Array(_) => {\n+                        let mut r = vec![];\n+                        for x in values {\n+                            let value = x.get(&self)?;\n+                            r.extend(value);\n+                        }\n+                        Owned(r)\n+                    }\n+                    AggregateKind::Tuple(ty) => {\n+                        let layout = self.layout(&ty)?;\n+                        Owned(self.make_by_layout(\n+                            layout.size.bytes_usize(),\n+                            &layout,\n+                            None,\n+                            values.iter().copied(),\n+                        )?)\n+                    }\n+                    AggregateKind::Union(x, f) => {\n+                        let layout = self.layout_adt((*x).into(), Substitution::empty(Interner))?;\n+                        let offset = layout\n+                            .fields\n+                            .offset(u32::from(f.local_id.into_raw()) as usize)\n+                            .bytes_usize();\n+                        let op = values[0].get(&self)?;\n+                        let mut result = vec![0; layout.size.bytes_usize()];\n+                        result[offset..offset + op.len()].copy_from_slice(op);\n+                        Owned(result)\n+                    }\n+                    AggregateKind::Adt(x, subst) => {\n+                        let subst = self.subst_filler(subst, locals);\n+                        let (size, variant_layout, tag) =\n+                            self.layout_of_variant(*x, subst, locals)?;\n+                        Owned(self.make_by_layout(\n+                            size,\n+                            &variant_layout,\n+                            tag,\n+                            values.iter().copied(),\n+                        )?)\n                     }\n-                    Owned(r)\n-                }\n-                AggregateKind::Tuple(ty) => {\n-                    let layout = self.layout(&ty)?;\n-                    Owned(self.make_by_layout(\n-                        layout.size.bytes_usize(),\n-                        &layout,\n-                        None,\n-                        values,\n-                        locals,\n-                    )?)\n-                }\n-                AggregateKind::Union(x, f) => {\n-                    let layout = self.layout_adt((*x).into(), Substitution::empty(Interner))?;\n-                    let offset = layout\n-                        .fields\n-                        .offset(u32::from(f.local_id.into_raw()) as usize)\n-                        .bytes_usize();\n-                    let op = self.eval_operand(&values[0], locals)?.get(&self)?;\n-                    let mut result = vec![0; layout.size.bytes_usize()];\n-                    result[offset..offset + op.len()].copy_from_slice(op);\n-                    Owned(result)\n-                }\n-                AggregateKind::Adt(x, subst) => {\n-                    let subst = self.subst_filler(subst, locals);\n-                    let (size, variant_layout, tag) = self.layout_of_variant(*x, subst, locals)?;\n-                    Owned(self.make_by_layout(size, &variant_layout, tag, values, locals)?)\n                 }\n-            },\n+            }\n             Rvalue::Cast(kind, operand, target_ty) => match kind {\n-                CastKind::PointerExposeAddress => not_supported!(\"exposing pointer address\"),\n-                CastKind::PointerFromExposedAddress => {\n-                    not_supported!(\"creating pointer from exposed address\")\n-                }\n                 CastKind::Pointer(cast) => match cast {\n                     PointerCast::ReifyFnPointer => {\n                         let current_ty = self.operand_ty(operand, locals)?;\n@@ -818,7 +904,9 @@ impl Evaluator<'_> {\n                     x => not_supported!(\"pointer cast {x:?}\"),\n                 },\n                 CastKind::DynStar => not_supported!(\"dyn star cast\"),\n-                CastKind::IntToInt => {\n+                CastKind::IntToInt\n+                | CastKind::PointerExposeAddress\n+                | CastKind::PointerFromExposedAddress => {\n                     // FIXME: handle signed cast\n                     let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n                     let dest_size =\n@@ -828,7 +916,12 @@ impl Evaluator<'_> {\n                 CastKind::FloatToInt => not_supported!(\"float to int cast\"),\n                 CastKind::FloatToFloat => not_supported!(\"float to float cast\"),\n                 CastKind::IntToFloat => not_supported!(\"float to int cast\"),\n-                CastKind::PtrToPtr => not_supported!(\"ptr to ptr cast\"),\n+                CastKind::PtrToPtr => {\n+                    let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n+                    let dest_size =\n+                        self.size_of_sized(target_ty, locals, \"destination of ptr to ptr cast\")?;\n+                    Owned(current[0..dest_size].to_vec())\n+                }\n                 CastKind::FnPtrToPtr => not_supported!(\"fn ptr to ptr cast\"),\n             },\n         })\n@@ -895,16 +988,15 @@ impl Evaluator<'_> {\n         size: usize, // Not neccessarily equal to variant_layout.size\n         variant_layout: &Layout,\n         tag: Option<(usize, usize, i128)>,\n-        values: &[Operand],\n-        locals: &Locals<'_>,\n+        values: impl Iterator<Item = Interval>,\n     ) -> Result<Vec<u8>> {\n         let mut result = vec![0; size];\n         if let Some((offset, size, value)) = tag {\n             result[offset..offset + size].copy_from_slice(&value.to_le_bytes()[0..size]);\n         }\n-        for (i, op) in values.iter().enumerate() {\n+        for (i, op) in values.enumerate() {\n             let offset = variant_layout.fields.offset(i).bytes_usize();\n-            let op = self.eval_operand(op, locals)?.get(&self)?;\n+            let op = op.get(&self)?;\n             result[offset..offset + op.len()].copy_from_slice(op);\n         }\n         Ok(result)\n@@ -1196,28 +1288,89 @@ impl Evaluator<'_> {\n     }\n \n     fn exec_intrinsic(\n-        &self,\n+        &mut self,\n         as_str: &str,\n-        mut arg_bytes: impl Iterator<Item = Vec<u8>>,\n+        args: &[IntervalAndTy],\n         generic_args: Substitution,\n+        destination: Interval,\n         locals: &Locals<'_>,\n-    ) -> Result<Vec<u8>> {\n+    ) -> Result<()> {\n         match as_str {\n             \"size_of\" => {\n                 let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n                     return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n                 };\n-                let size = self.size_of(ty, locals)?;\n-                match size {\n-                    Some(x) => Ok(x.to_le_bytes().to_vec()),\n-                    None => return Err(MirEvalError::TypeError(\"size_of arg is unsized\")),\n-                }\n+                let size = self.size_of_sized(ty, locals, \"size_of arg\")?;\n+                destination.write_from_bytes(self, &size.to_le_bytes()[0..destination.size])\n+            }\n+            \"wrapping_add\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.wrapping_add(rhs);\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+                let [src, dst, offset] = args else {\n+                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping args are not provided\"));\n+                };\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping generic arg is not provided\"));\n+                };\n+                let src = Address::from_bytes(src.get(self)?)?;\n+                let dst = Address::from_bytes(dst.get(self)?)?;\n+                let offset = from_bytes!(usize, offset.get(self)?);\n+                let size = self.size_of_sized(ty, locals, \"copy_nonoverlapping ptr type\")?;\n+                let size = offset * size;\n+                let src = Interval { addr: src, size };\n+                let dst = Interval { addr: dst, size };\n+                dst.write_from_interval(self, src)\n+            }\n+            \"offset\" | \"arith_offset\" => {\n+                let [ptr, offset] = args else {\n+                    return Err(MirEvalError::TypeError(\"offset args are not provided\"));\n+                };\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"offset generic arg is not provided\"));\n+                };\n+                let ptr = u128::from_le_bytes(pad16(ptr.get(self)?, false));\n+                let offset = u128::from_le_bytes(pad16(offset.get(self)?, false));\n+                let size = self.size_of_sized(ty, locals, \"offset ptr type\")? as u128;\n+                let ans = ptr + offset * size;\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n+                // FIXME: We should actually implement these checks\n+                Ok(())\n+            }\n+            \"forget\" => {\n+                // We don't call any drop glue yet, so there is nothing here\n+                Ok(())\n             }\n             \"transmute\" => {\n-                let Some(arg) = arg_bytes.next() else {\n+                let [arg] = args else {\n                     return Err(MirEvalError::TypeError(\"trasmute arg is not provided\"));\n                 };\n-                Ok(arg)\n+                destination.write_from_interval(self, arg.interval)\n+            }\n+            \"const_eval_select\" => {\n+                let [tuple, const_fn, _] = args else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n+                };\n+                let mut args = vec![const_fn.clone()];\n+                let TyKind::Tuple(_, fields) = tuple.ty.kind(Interner) else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select arg[0] is not a tuple\"));\n+                };\n+                let layout = self.layout(&tuple.ty)?;\n+                for (i, field) in fields.iter(Interner).enumerate() {\n+                    let field = field.assert_ty_ref(Interner).clone();\n+                    let offset = layout.fields.offset(i).bytes_usize();\n+                    let addr = tuple.interval.addr.offset(offset);\n+                    args.push(IntervalAndTy::new(addr, field, self, locals)?);\n+                }\n+                self.exec_fn_trait(&args, destination, locals)\n             }\n             _ => not_supported!(\"unknown intrinsic {as_str}\"),\n         }\n@@ -1226,8 +1379,8 @@ impl Evaluator<'_> {\n     fn exec_fn_pointer(\n         &mut self,\n         bytes: Interval,\n-        destination: &Place,\n-        args: &[Operand],\n+        destination: Interval,\n+        args: &[IntervalAndTy],\n         locals: &Locals<'_>,\n     ) -> Result<()> {\n         let id = from_bytes!(usize, bytes.get(self)?);\n@@ -1244,38 +1397,41 @@ impl Evaluator<'_> {\n         &mut self,\n         def: FnDefId,\n         generic_args: &Substitution,\n-        destination: &Place,\n-        args: &[Operand],\n+        destination: Interval,\n+        args: &[IntervalAndTy],\n         locals: &Locals<'_>,\n     ) -> Result<()> {\n         let def: CallableDefId = from_chalk(self.db, def);\n         let generic_args = self.subst_filler(generic_args, &locals);\n         match def {\n             CallableDefId::FunctionId(def) => {\n-                let dest_addr = self.place_addr(destination, &locals)?;\n-                if let Some(x) = self.detect_fn_trait(def) {\n-                    self.exec_fn_trait(x, &args, destination, locals)?;\n+                if let Some(_) = self.detect_fn_trait(def) {\n+                    self.exec_fn_trait(&args, destination, locals)?;\n                     return Ok(());\n                 }\n-                let arg_bytes = args\n-                    .iter()\n-                    .map(|x| Ok(self.eval_operand(x, &locals)?.get(&self)?.to_owned()))\n-                    .collect::<Result<Vec<_>>>()?;\n-                self.exec_fn_with_args(def, arg_bytes, generic_args, locals, dest_addr)?;\n+                self.exec_fn_with_args(def, args, generic_args, locals, destination)?;\n             }\n             CallableDefId::StructId(id) => {\n                 let (size, variant_layout, tag) =\n                     self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n-                let result = self.make_by_layout(size, &variant_layout, tag, args, &locals)?;\n-                let dest_addr = self.place_addr(destination, &locals)?;\n-                self.write_memory(dest_addr, &result)?;\n+                let result = self.make_by_layout(\n+                    size,\n+                    &variant_layout,\n+                    tag,\n+                    args.iter().map(|x| x.interval),\n+                )?;\n+                destination.write_from_bytes(self, &result)?;\n             }\n             CallableDefId::EnumVariantId(id) => {\n                 let (size, variant_layout, tag) =\n                     self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n-                let result = self.make_by_layout(size, &variant_layout, tag, args, &locals)?;\n-                let dest_addr = self.place_addr(destination, &locals)?;\n-                self.write_memory(dest_addr, &result)?;\n+                let result = self.make_by_layout(\n+                    size,\n+                    &variant_layout,\n+                    tag,\n+                    args.iter().map(|x| x.interval),\n+                )?;\n+                destination.write_from_bytes(self, &result)?;\n             }\n         }\n         Ok(())\n@@ -1284,10 +1440,10 @@ impl Evaluator<'_> {\n     fn exec_fn_with_args(\n         &mut self,\n         def: FunctionId,\n-        arg_bytes: Vec<Vec<u8>>,\n+        args: &[IntervalAndTy],\n         generic_args: Substitution,\n         locals: &Locals<'_>,\n-        dest_addr: Address,\n+        destination: Interval,\n     ) -> Result<()> {\n         let function_data = self.db.function_data(def);\n         let is_intrinsic = match &function_data.abi {\n@@ -1301,14 +1457,18 @@ impl Evaluator<'_> {\n                 _ => false,\n             },\n         };\n-        let result = if is_intrinsic {\n-            self.exec_intrinsic(\n+        if is_intrinsic {\n+            return self.exec_intrinsic(\n                 function_data.name.as_text().unwrap_or_default().as_str(),\n-                arg_bytes.iter().cloned(),\n+                args,\n                 generic_args,\n+                destination,\n                 &locals,\n-            )?\n-        } else if let Some(x) = self.detect_lang_function(def) {\n+            );\n+        }\n+        let arg_bytes =\n+            args.iter().map(|x| Ok(x.get(&self)?.to_owned())).collect::<Result<Vec<_>>>()?;\n+        let result = if let Some(x) = self.detect_lang_function(def) {\n             self.exec_lang_item(x, &arg_bytes)?\n         } else {\n             if let Some(self_ty_idx) =\n@@ -1321,9 +1481,12 @@ impl Evaluator<'_> {\n                 let ty = self\n                     .vtable_map\n                     .ty_of_bytes(&arg_bytes[0][self.ptr_size()..self.ptr_size() * 2])?;\n+                let mut args_for_target = args.to_vec();\n+                args_for_target[0] = IntervalAndTy {\n+                    interval: args_for_target[0].interval.slice(0..self.ptr_size()),\n+                    ty: ty.clone(),\n+                };\n                 let ty = GenericArgData::Ty(ty.clone()).intern(Interner);\n-                let mut args_for_target = arg_bytes;\n-                args_for_target[0] = args_for_target[0][0..self.ptr_size()].to_vec();\n                 let generics_for_target = Substitution::from_iter(\n                     Interner,\n                     generic_args.iter(Interner).enumerate().map(|(i, x)| {\n@@ -1336,10 +1499,10 @@ impl Evaluator<'_> {\n                 );\n                 return self.exec_fn_with_args(\n                     def,\n-                    args_for_target,\n+                    &args_for_target,\n                     generics_for_target,\n                     locals,\n-                    dest_addr,\n+                    destination,\n                 );\n             }\n             let (imp, generic_args) =\n@@ -1351,20 +1514,19 @@ impl Evaluator<'_> {\n             self.interpret_mir(&mir_body, arg_bytes.iter().cloned(), generic_args)\n                 .map_err(|e| MirEvalError::InFunction(imp, Box::new(e)))?\n         };\n-        self.write_memory(dest_addr, &result)?;\n+        destination.write_from_bytes(self, &result)?;\n         Ok(())\n     }\n \n     fn exec_fn_trait(\n         &mut self,\n-        ft: FnTrait,\n-        args: &[Operand],\n-        destination: &Place,\n+        args: &[IntervalAndTy],\n+        destination: Interval,\n         locals: &Locals<'_>,\n     ) -> Result<()> {\n         let func = args.get(0).ok_or(MirEvalError::TypeError(\"fn trait with no arg\"))?;\n-        let mut func_ty = self.operand_ty(func, locals)?;\n-        let mut func_data = self.eval_operand(func, locals)?;\n+        let mut func_ty = func.ty.clone();\n+        let mut func_data = func.interval;\n         while let TyKind::Ref(_, _, z) = func_ty.kind(Interner) {\n             func_ty = z.clone();\n             if matches!(func_ty.kind(Interner), TyKind::Dyn(_)) {\n@@ -1383,7 +1545,7 @@ impl Evaluator<'_> {\n             TyKind::Function(_) => {\n                 self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n             }\n-            x => not_supported!(\"Call {ft:?} trait methods with type {x:?}\"),\n+            x => not_supported!(\"Call FnTrait methods with type {x:?}\"),\n         }\n         Ok(())\n     }\n@@ -1392,7 +1554,10 @@ impl Evaluator<'_> {\n         use LangItem::*;\n         let mut args = args.iter();\n         match x {\n-            PanicFmt | BeginPanic => Err(MirEvalError::Panic),\n+            // FIXME: we want to find the panic message from arguments, but it wouldn't work\n+            // currently even if we do that, since macro expansion of panic related macros\n+            // is dummy.\n+            PanicFmt | BeginPanic => Err(MirEvalError::Panic(\"<format-args>\".to_string())),\n             SliceLen => {\n                 let arg = args\n                     .next()"}, {"sha": "65e3348b21896f3cee2f3926098cc9c2438a7e44", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -1285,6 +1285,11 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n             (_, chalk_ir::Scalar::Float(_)) => CastKind::IntToFloat,\n             (_, _) => CastKind::IntToInt,\n         },\n+        (TyKind::Scalar(_), TyKind::Raw(..)) => CastKind::PointerFromExposedAddress,\n+        (TyKind::Raw(..), TyKind::Scalar(_)) => CastKind::PointerExposeAddress,\n+        (TyKind::Raw(..) | TyKind::Ref(..), TyKind::Raw(..) | TyKind::Ref(..)) => {\n+            CastKind::PtrToPtr\n+        }\n         // Enum to int casts\n         (TyKind::Scalar(_), TyKind::Adt(..)) | (TyKind::Adt(..), TyKind::Scalar(_)) => {\n             CastKind::IntToInt"}, {"sha": "8322b9e1ca64ad3c01e6666a078054c9b4fe059c", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -2696,6 +2696,21 @@ fn f() {\n     )\n }\n \n+#[test]\n+fn infer_ref_to_raw_cast() {\n+    check_types(\n+        r#\"\n+struct S;\n+\n+fn f() {\n+    let s = &mut S;\n+    let s = s as *mut _;\n+      //^ *mut S\n+}\n+    \"#,\n+    );\n+}\n+\n #[test]\n fn infer_missing_type() {\n     check_types(\n@@ -3258,25 +3273,6 @@ fn f<T>(t: Ark<T>) {\n     );\n }\n \n-// FIXME\n-#[test]\n-fn castable_to2() {\n-    check_infer(\n-        r#\"\n-fn func() {\n-    let x = &0u32 as *const _;\n-}\n-\"#,\n-        expect![[r#\"\n-            10..44 '{     ...t _; }': ()\n-            20..21 'x': *const {unknown}\n-            24..29 '&0u32': &u32\n-            24..41 '&0u32 ...onst _': *const {unknown}\n-            25..29 '0u32': u32\n-        \"#]],\n-    );\n-}\n-\n #[test]\n fn issue_14275() {\n     // FIXME: evaluate const generic"}, {"sha": "fb7b15e05d81f66c4286c4fc3adf34d6bae6de39", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=3303a6eff5f759d5bc6f9a2e891bddab0d1f21e7", "patch": "@@ -409,7 +409,6 @@ pub(super) fn definition(\n             }\n             match it.eval(db) {\n                 Ok(()) => Some(\"pass\".into()),\n-                Err(MirEvalError::Panic) => Some(\"fail\".into()),\n                 Err(MirEvalError::MirLowerError(f, e)) => {\n                     let name = &db.function_data(f).name;\n                     Some(format!(\"error: fail to lower {name} due {e:?}\"))"}]}