{"sha": "a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZjFiYjQzZWY2YmE0YTQ3NzRjY2JkNjIxMTgxNGJiMzVkNzcyNGY=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-04-15T21:08:26Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-04-20T10:30:01Z"}, "message": "test for mutex eq, add another test case", "tree": {"sha": "1028f391100659463b0d44c2eb0f239679e95333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1028f391100659463b0d44c2eb0f239679e95333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "html_url": "https://github.com/rust-lang/rust/commit/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae820924c4f39c5a83287ba1cb6f9af572cabf55", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae820924c4f39c5a83287ba1cb6f9af572cabf55", "html_url": "https://github.com/rust-lang/rust/commit/ae820924c4f39c5a83287ba1cb6f9af572cabf55"}], "stats": {"total": 80, "additions": 51, "deletions": 29}, "files": [{"sha": "21749f8ad0944e2f7f666f788a4acca8d6f24550", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "patch": "@@ -1,7 +1,7 @@\n+use crate::utils::{match_type, paths, span_lint_and_help, SpanlessEq};\n use if_chain::if_chain;\n-use crate::utils::{match_type, paths, span_lint_and_help};\n use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_hir::{Expr, ExprKind, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,10 +44,12 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, ex: &'_ Expr<'_>) {\n         let mut arm_visit = ArmVisitor {\n             mutex_lock_called: false,\n+            found_mutex: None,\n             cx,\n         };\n         let mut op_visit = OppVisitor {\n             mutex_lock_called: false,\n+            found_mutex: None,\n             cx,\n         };\n         if let ExprKind::Match(\n@@ -64,7 +66,7 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n                     arm_visit.visit_arm(arm);\n                 }\n \n-                if arm_visit.mutex_lock_called {\n+                if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n                     span_lint_and_help(\n                         cx,\n                         IF_LET_MUTEX,\n@@ -80,8 +82,9 @@ impl LateLintPass<'_, '_> for IfLetMutex {\n \n /// Checks if `Mutex::lock` is called in the `if let _ = expr.\n pub struct OppVisitor<'tcx, 'l> {\n-    pub mutex_lock_called: bool,\n-    pub cx: &'tcx LateContext<'tcx, 'l>,\n+    mutex_lock_called: bool,\n+    found_mutex: Option<&'tcx Expr<'tcx>>,\n+    cx: &'tcx LateContext<'tcx, 'l>,\n }\n \n impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n@@ -94,6 +97,7 @@ impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n             let ty = self.cx.tables.expr_ty(&args[0]);\n             if match_type(self.cx, ty, &paths::MUTEX);\n             then {\n+                self.found_mutex = Some(&args[0]);\n                 self.mutex_lock_called = true;\n                 return;\n             }\n@@ -108,46 +112,40 @@ impl<'tcx, 'l> Visitor<'tcx> for OppVisitor<'tcx, 'l> {\n \n /// Checks if `Mutex::lock` is called in any of the branches.\n pub struct ArmVisitor<'tcx, 'l> {\n-    pub mutex_lock_called: bool,\n-    pub cx: &'tcx LateContext<'tcx, 'l>,\n+    mutex_lock_called: bool,\n+    found_mutex: Option<&'tcx Expr<'tcx>>,\n+    cx: &'tcx LateContext<'tcx, 'l>,\n }\n \n impl<'tcx, 'l> Visitor<'tcx> for ArmVisitor<'tcx, 'l> {\n     type Map = Map<'tcx>;\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if let ExprKind::MethodCall(path, _span, args) = &expr.kind;\n             if path.ident.to_string() == \"lock\";\n             let ty = self.cx.tables.expr_ty(&args[0]);\n             if match_type(self.cx, ty, &paths::MUTEX);\n             then {\n+                self.found_mutex = Some(&args[0]);\n                 self.mutex_lock_called = true;\n                 return;\n             }\n         }\n         visit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &'tcx Arm<'_>) {\n-        if let ExprKind::Block(ref block, _l) = arm.body.kind {\n-            for stmt in block.stmts {\n-                match stmt.kind {\n-                    StmtKind::Local(loc) => {\n-                        if let Some(expr) = loc.init {\n-                            self.visit_expr(expr)\n-                        }\n-                    },\n-                    StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(expr),\n-                    // we don't care about `Item`\n-                    _ => {},\n-                }\n-            }\n-        };\n-        visit::walk_arm(self, arm);\n-    }\n-\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }\n }\n+\n+impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n+    fn same_mutex(&self, cx: &LateContext<'_, '_>, op_mutex: &Expr<'_>) -> bool {\n+        if let Some(arm_mutex) = self.found_mutex {\n+            SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "d59ec83679a9e50f64756814c169471d98daeac5", "filename": "tests/ui/if_let_mutex.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/tests%2Fui%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/tests%2Fui%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.rs?ref=a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "patch": "@@ -1,11 +1,12 @@\n #![warn(clippy::if_let_mutex)]\n \n+use std::ops::Deref;\n use std::sync::Mutex;\n \n fn do_stuff<T>(_: T) {}\n \n fn if_let() {\n-    let m = Mutex::new(1u8);\n+    let m = Mutex::new(1_u8);\n     if let Err(locked) = m.lock() {\n         do_stuff(locked);\n     } else {\n@@ -14,4 +15,14 @@ fn if_let() {\n     };\n }\n \n+fn if_let_option() {\n+    let m = Mutex::new(Some(0_u8));\n+    if let Some(locked) = m.lock().unwrap().deref() {\n+        do_stuff(locked);\n+    } else {\n+        let lock = m.lock().unwrap();\n+        do_stuff(lock);\n+    };\n+}\n+\n fn main() {}"}, {"sha": "0c24d650c27bffbfbf65ff461c8cfbc53f94d582", "filename": "tests/ui/if_let_mutex.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/tests%2Fui%2Fif_let_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f/tests%2Fui%2Fif_let_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_mutex.stderr?ref=a9f1bb43ef6ba4a4774ccbd6211814bb35d7724f", "patch": "@@ -1,5 +1,5 @@\n error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n-  --> $DIR/if_let_mutex.rs:9:5\n+  --> $DIR/if_let_mutex.rs:10:5\n    |\n LL | /     if let Err(locked) = m.lock() {\n LL | |         do_stuff(locked);\n@@ -12,5 +12,18 @@ LL | |     };\n    = note: `-D clippy::if-let-mutex` implied by `-D warnings`\n    = help: move the lock call outside of the `if let ...` expression\n \n-error: aborting due to previous error\n+error: calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\n+  --> $DIR/if_let_mutex.rs:20:5\n+   |\n+LL | /     if let Some(locked) = m.lock().unwrap().deref() {\n+LL | |         do_stuff(locked);\n+LL | |     } else {\n+LL | |         let lock = m.lock().unwrap();\n+LL | |         do_stuff(lock);\n+LL | |     };\n+   | |_____^\n+   |\n+   = help: move the lock call outside of the `if let ...` expression\n+\n+error: aborting due to 2 previous errors\n "}]}