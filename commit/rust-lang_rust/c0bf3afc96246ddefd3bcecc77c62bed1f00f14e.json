{"sha": "c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYmYzYWZjOTYyNDZkZGVmZDNiY2VjYzc3YzYyYmVkMWYwMGYxNGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-21T14:29:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-21T14:29:42Z"}, "message": "Rollup merge of #67355 - Centril:merge-mut, r=oli-obk\n\nMerge `ast::Mutability` and `mir::Mutability`\n\nr? @oli-obk", "tree": {"sha": "08c77e36e090a85f5d9693b605bb74b145457984", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08c77e36e090a85f5d9693b605bb74b145457984"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/ixWCRBK7hj4Ov3rIwAAdHIIAF4CqRa6hqjKQ37QQavAn831\nkqNvLkeZzGYVlwIj3Bs4v5ZvAyiUb6bbrUxhYR+FDFPc3xaOta8yWIwXC8RdOhwQ\nYGAoEnpz8MZUrRdkzEJddU1LknhYkyIdndtrSfqstR9jyDPwWM9GABBOvsddg0I6\nxc6gn+o4jCZ5O1TxmGwih4L3wh3FsuH3nyYQYkhZgpukyD7fYPP2vrjwbHG42HTn\neofnRAdAkIDTu87a+pThJLGKKi45cLh9E3xMR2zGvxoivPGDxJprjKj437uG9P+R\nA1O261DxOPcdepgibRJDN3Oqvr8KEp6uEoLSAYsEcVsy30l6okeaoPwWEWK+4Z0=\n=EfOO\n-----END PGP SIGNATURE-----\n", "payload": "tree 08c77e36e090a85f5d9693b605bb74b145457984\nparent 1113eb5cc07f19eab34fa7984f08a4ba9fd2c987\nparent 6d7c6d7384233b58ba98090797f7c45b8040a68d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576938582 +0100\ncommitter GitHub <noreply@github.com> 1576938582 +0100\n\nRollup merge of #67355 - Centril:merge-mut, r=oli-obk\n\nMerge `ast::Mutability` and `mir::Mutability`\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "html_url": "https://github.com/rust-lang/rust/commit/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "url": "https://api.github.com/repos/rust-lang/rust/commits/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "html_url": "https://github.com/rust-lang/rust/commit/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987"}, {"sha": "6d7c6d7384233b58ba98090797f7c45b8040a68d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7c6d7384233b58ba98090797f7c45b8040a68d", "html_url": "https://github.com/rust-lang/rust/commit/6d7c6d7384233b58ba98090797f7c45b8040a68d"}], "stats": {"total": 620, "additions": 294, "deletions": 326}, "files": [{"sha": "2fd708f1ea344b00ded6bd88d0d4bfb379f09151", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2253,7 +2253,7 @@ impl<'a> LoweringContext<'a> {\n                     let is_mutable_pat = match arg.pat.kind {\n                         PatKind::Ident(BindingMode::ByValue(mt), _, _) |\n                         PatKind::Ident(BindingMode::ByRef(mt), _, _) =>\n-                            mt == Mutability::Mutable,\n+                            mt == Mutability::Mut,\n                         _ => false,\n                     };\n \n@@ -2264,7 +2264,7 @@ impl<'a> LoweringContext<'a> {\n                         // the case where we have a mutable pattern to a reference as that would\n                         // no longer be an `ImplicitSelf`.\n                         TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() &&\n-                            mt.mutbl == ast::Mutability::Mutable =>\n+                            mt.mutbl == ast::Mutability::Mut =>\n                                 hir::ImplicitSelfKind::MutRef,\n                         TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() =>\n                             hir::ImplicitSelfKind::ImmRef,\n@@ -3068,10 +3068,10 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n         match *b {\n-            BindingMode::ByValue(Mutability::Immutable) => hir::BindingAnnotation::Unannotated,\n-            BindingMode::ByRef(Mutability::Immutable) => hir::BindingAnnotation::Ref,\n-            BindingMode::ByValue(Mutability::Mutable) => hir::BindingAnnotation::Mutable,\n-            BindingMode::ByRef(Mutability::Mutable) => hir::BindingAnnotation::RefMut,\n+            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n         }\n     }\n "}, {"sha": "a1a37719812b6fba2523a0437093f38708a73c3b", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1340,7 +1340,7 @@ impl LoweringContext<'_> {\n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n         self.expr(\n             span,\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mutable, e),\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n             ThinVec::new(),\n         )\n     }"}, {"sha": "b59c7438005b22a8b96b5cc0daebba919681e908", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -169,11 +169,10 @@ impl hir::Pat {\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n                 hir::BindingAnnotation::Ref => match result {\n-                    None | Some(hir::Mutability::Immutable) =>\n-                        result = Some(hir::Mutability::Immutable),\n+                    None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n                     _ => {}\n                 }\n-                hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mutable),\n+                hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mut),\n                 _ => {}\n             }\n         });"}, {"sha": "92ad1c38fa04335097a61a384125e5d2de385da3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -386,7 +386,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::Mutability::Mutable {\n+                if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -502,7 +502,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::Mutability::Mutable {\n+                if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -1632,11 +1632,11 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Immutable, false);\n+                        self.print_mutability(hir::Mutability::Not, false);\n                     }\n                     hir::BindingAnnotation::RefMut => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mutable, false);\n+                        self.print_mutability(hir::Mutability::Mut, false);\n                     }\n                     hir::BindingAnnotation::Unannotated => {}\n                     hir::BindingAnnotation::Mutable => {\n@@ -2065,8 +2065,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mutability(&mut self, mutbl: hir::Mutability, print_const: bool) {\n         match mutbl {\n-            hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            hir::Mutability::Immutable => if print_const { self.word_nbsp(\"const\") },\n+            hir::Mutability::Mut => self.word_nbsp(\"mut\"),\n+            hir::Mutability::Not => if print_const { self.word_nbsp(\"const\") },\n         }\n     }\n "}, {"sha": "f80a72365e361de3eed56712e704e8554d00cf7f", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n             }\n-            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Immutable }) => {\n+            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Not }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;"}, {"sha": "a1bb80f6179e22f6654885c3fa8e8f211be0cb0f", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -106,7 +106,7 @@ impl<Tag> Allocation<Tag> {\n             undef_mask: UndefMask::new(size, true),\n             size,\n             align,\n-            mutability: Mutability::Immutable,\n+            mutability: Mutability::Not,\n             extra: (),\n         }\n     }\n@@ -123,7 +123,7 @@ impl<Tag> Allocation<Tag> {\n             undef_mask: UndefMask::new(size, false),\n             size,\n             align,\n-            mutability: Mutability::Mutable,\n+            mutability: Mutability::Mut,\n             extra: (),\n         }\n     }"}, {"sha": "0757e02da970d7ab95c413d6eebdf92fa36341be", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -34,6 +34,7 @@ use std::ops::Index;\n use std::slice;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n+pub use syntax::ast::Mutability;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -396,22 +397,7 @@ pub struct SourceInfo {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Mutability and borrow kinds\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum Mutability {\n-    Mut,\n-    Not,\n-}\n-\n-impl From<Mutability> for hir::Mutability {\n-    fn from(m: Mutability) -> Self {\n-        match m {\n-            Mutability::Mut => hir::Mutability::Mutable,\n-            Mutability::Not => hir::Mutability::Immutable,\n-        }\n-    }\n-}\n+// Borrow kinds\n \n #[derive(\n     Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, HashStable,\n@@ -2886,7 +2872,6 @@ pub enum ClosureOutlivesSubject<'tcx> {\n CloneTypeFoldableAndLiftImpls! {\n     BlockTailInfo,\n     MirPhase,\n-    Mutability,\n     SourceInfo,\n     FakeReadCause,\n     RetagKind,"}, {"sha": "841c0b458d157a3e78549fdd037fce31194c6530", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -279,17 +279,17 @@ impl<'tcx> BinOp {\n impl BorrowKind {\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            BorrowKind::Mut { .. } => hir::Mutability::Mutable,\n-            BorrowKind::Shared => hir::Mutability::Immutable,\n+            BorrowKind::Mut { .. } => hir::Mutability::Mut,\n+            BorrowKind::Shared => hir::Mutability::Not,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            BorrowKind::Unique => hir::Mutability::Mutable,\n+            BorrowKind::Unique => hir::Mutability::Mut,\n \n             // We have no type corresponding to a shallow borrow, so use\n             // `&` as an approximation.\n-            BorrowKind::Shallow => hir::Mutability::Immutable,\n+            BorrowKind::Shallow => hir::Mutability::Not,\n         }\n     }\n }"}, {"sha": "735627578a6275019ba689bff1da905e84e7fd5a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1548,8 +1548,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n                 let trait_type = match mutability {\n-                    hir::Mutability::Mutable => self.tcx.mk_imm_ref(region, t_type),\n-                    hir::Mutability::Immutable => self.tcx.mk_mut_ref(region, t_type),\n+                    hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n                 let new_obligation = self.mk_obligation_for_def_id(\n@@ -1565,7 +1565,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let sp = self.tcx.sess.source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n                     if points_at_arg &&\n-                        mutability == hir::Mutability::Immutable &&\n+                        mutability == hir::Mutability::Not &&\n                         refs_number > 0\n                     {\n                         err.span_suggestion("}, {"sha": "f1cd002d19b647533b889e2664348034881ec884", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2622,7 +2622,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Char\n             | ty::RawPtr(..)\n             | ty::Never\n-            | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+            | ty::Ref(_, _, hir::Mutability::Not) => {\n                 // Implementations provided in libcore\n                 None\n             }\n@@ -2633,7 +2633,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n             | ty::Foreign(..)\n-            | ty::Ref(_, _, hir::Mutability::Mutable) => None,\n+            | ty::Ref(_, _, hir::Mutability::Mut) => None,\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here"}, {"sha": "0c04ba96365ed0999477921692c8ae7737186fac", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -109,8 +109,8 @@ pub struct OverloadedDeref<'tcx> {\n impl<'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::Mutability::Immutable => tcx.lang_items().deref_trait(),\n-            hir::Mutability::Mutable => tcx.lang_items().deref_mut_trait()\n+            hir::Mutability::Not => tcx.lang_items().deref_trait(),\n+            hir::Mutability::Mut => tcx.lang_items().deref_mut_trait()\n         };\n         let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n             .find(|m| m.kind == ty::AssocKind::Method).unwrap().def_id;\n@@ -138,15 +138,15 @@ pub enum AllowTwoPhase {\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AutoBorrowMutability {\n-    Mutable { allow_two_phase_borrow: AllowTwoPhase },\n-    Immutable,\n+    Mut { allow_two_phase_borrow: AllowTwoPhase },\n+    Not,\n }\n \n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {\n-            AutoBorrowMutability::Mutable { .. } => hir::Mutability::Mutable,\n-            AutoBorrowMutability::Immutable => hir::Mutability::Immutable,\n+            AutoBorrowMutability::Mut { .. } => hir::Mutability::Mut,\n+            AutoBorrowMutability::Not => hir::Mutability::Not,\n         }\n     }\n }"}, {"sha": "00cff1f1be17fd675e65d97ec1ddb879061f3328", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -13,10 +13,10 @@ CloneTypeFoldableAndLiftImpls! { BindingMode, }\n impl BindingMode {\n     pub fn convert(ba: BindingAnnotation) -> BindingMode {\n         match ba {\n-            Unannotated => BindingMode::BindByValue(Mutability::Immutable),\n-            Mutable => BindingMode::BindByValue(Mutability::Mutable),\n-            Ref => BindingMode::BindByReference(Mutability::Immutable),\n-            RefMut => BindingMode::BindByReference(Mutability::Mutable),\n+            Unannotated => BindingMode::BindByValue(Mutability::Not),\n+            Mutable => BindingMode::BindByValue(Mutability::Mut),\n+            Ref => BindingMode::BindByReference(Mutability::Not),\n+            RefMut => BindingMode::BindByReference(Mutability::Mut),\n         }\n     }\n }"}, {"sha": "0806e2d77650e58a316cfd02b6445a68bdc0093d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2406,22 +2406,22 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mut })\n     }\n \n     #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Not })\n     }\n \n     #[inline]"}, {"sha": "0218cb1d6fda7129c558d45723556e832ae6b229", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                     format!(\"`&{}`\", tymut_string).into()\n                 } else { // Unknown type name, it's long or has type arguments\n                     match mutbl {\n-                        hir::Mutability::Mutable => \"mutable reference\",\n+                        hir::Mutability::Mut => \"mutable reference\",\n                         _ => \"reference\",\n                     }.into()\n                 }\n@@ -293,7 +293,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Slice(_) => \"slice\".into(),\n             ty::RawPtr(_) => \"raw pointer\".into(),\n             ty::Ref(.., mutbl) => match mutbl {\n-                hir::Mutability::Mutable => \"mutable reference\",\n+                hir::Mutability::Mut => \"mutable reference\",\n                 _ => \"reference\"\n             }.into(),\n             ty::FnDef(..) => \"fn item\".into(),"}, {"sha": "a8c44aa507cd8a5938350879af4a0b5969f46f0b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2221,12 +2221,12 @@ where\n                 let tcx = cx.tcx();\n                 let is_freeze = ty.is_freeze(tcx, cx.param_env(), DUMMY_SP);\n                 let kind = match mt {\n-                    hir::Mutability::Immutable => if is_freeze {\n+                    hir::Mutability::Not => if is_freeze {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n-                    hir::Mutability::Mutable => {\n+                    hir::Mutability::Mut => {\n                         // Previously we would only emit noalias annotations for LLVM >= 6 or in\n                         // panic=abort mode. That was deemed right, as prior versions had many bugs\n                         // in conjunction with unwinding, but later versions didn\u2019t seem to have"}, {"sha": "62fea7c31a9d9f16807cbc5e26a1b2bf2eb87531", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2657,8 +2657,8 @@ impl<'tcx> TyS<'tcx> {\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n-            hir::Mutability::Mutable => MutBorrow,\n-            hir::Mutability::Immutable => ImmBorrow,\n+            hir::Mutability::Mut => MutBorrow,\n+            hir::Mutability::Not => ImmBorrow,\n         }\n     }\n \n@@ -2668,13 +2668,13 @@ impl BorrowKind {\n     /// question.\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            MutBorrow => hir::Mutability::Mutable,\n-            ImmBorrow => hir::Mutability::Immutable,\n+            MutBorrow => hir::Mutability::Mut,\n+            ImmBorrow => hir::Mutability::Not,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => hir::Mutability::Mutable,\n+            UniqueImmBorrow => hir::Mutability::Mut,\n         }\n     }\n "}, {"sha": "5e146119b51acb5be5bd74914c37cdee6cc23824", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -59,8 +59,8 @@ impl DefPathBasedNames<'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n                 output.push('*');\n                 match mutbl {\n-                    hir::Mutability::Immutable => output.push_str(\"const \"),\n-                    hir::Mutability::Mutable => output.push_str(\"mut \"),\n+                    hir::Mutability::Not => output.push_str(\"const \"),\n+                    hir::Mutability::Mut => output.push_str(\"mut \"),\n                 }\n \n                 self.push_type_name(inner_type, output, debug);"}, {"sha": "b4f1f9d779a69eda03edb657e79ed153673c71ed", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -490,8 +490,8 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Float(t) => p!(write(\"{}\", t.name_str())),\n             ty::RawPtr(ref tm) => {\n                 p!(write(\"*{} \", match tm.mutbl {\n-                    hir::Mutability::Mutable => \"mut\",\n-                    hir::Mutability::Immutable => \"const\",\n+                    hir::Mutability::Mut => \"mut\",\n+                    hir::Mutability::Not => \"const\",\n                 }));\n                 p!(print(tm.ty))\n             }"}, {"sha": "15b14c51c7843ec0a069098a4fa3bae7572e311e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -121,8 +121,8 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n         } else {\n             let mutbl = a.mutbl;\n             let variance = match mutbl {\n-                ast::Mutability::Immutable => ty::Covariant,\n-                ast::Mutability::Mutable => ty::Invariant,\n+                ast::Mutability::Not => ty::Covariant,\n+                ast::Mutability::Mut => ty::Invariant,\n             };\n             let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })"}, {"sha": "ea4369c0180fe3d42da34a6faddac4b5e56fd393", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1853,8 +1853,8 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n         match self.kind {\n-            RawPtr(TypeAndMut { mutbl: hir::Mutability::Mutable, .. }) |\n-            Ref(_, _, hir::Mutability::Mutable) => true,\n+            RawPtr(TypeAndMut { mutbl: hir::Mutability::Mut, .. }) |\n+            Ref(_, _, hir::Mutability::Mut) => true,\n             _ => false\n         }\n     }\n@@ -2044,7 +2044,7 @@ impl<'tcx> TyS<'tcx> {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n-                    mutbl: hir::Mutability::Immutable,\n+                    mutbl: hir::Mutability::Not,\n                 })\n             },\n             Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),"}, {"sha": "f054a630e4b8e8ce5ea8fa92eb86e44756337019", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -183,7 +183,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // Now libcore provides that impl.\n                 ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n                 ty::Char | ty::RawPtr(..) | ty::Never |\n-                ty::Ref(_, _, hir::Mutability::Immutable) => return Ok(()),\n+                ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n \n                 ty::Adt(adt, substs) => (adt, substs),\n \n@@ -679,7 +679,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns `true` if the node pointed to by `def_id` is a mutable `static` item.\n     pub fn is_mutable_static(&self, def_id: DefId) -> bool {\n-        self.static_mutability(def_id) == Some(hir::Mutability::Mutable)\n+        self.static_mutability(def_id) == Some(hir::Mutability::Mut)\n     }\n \n     /// Get the type of the pointer to the static that we use in MIR."}, {"sha": "cda8fbc3517a9cb31c41219f330e4acf099cd73d", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -277,7 +277,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let base_addr = match alloc_kind {\n                     Some(GlobalAlloc::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n-                        if alloc.mutability == Mutability::Mutable {\n+                        if alloc.mutability == Mutability::Mut {\n                             self.static_addr_of_mut(init, alloc.align, None)\n                         } else {\n                             self.static_addr_of(init, alloc.align, None)"}, {"sha": "e178050b36918fe0f3e3a9c4515447a92f9ea1cd", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1582,7 +1582,7 @@ fn generic_simd_intrinsic(\n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mutable\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {"}, {"sha": "c5340892daf0cafffbe88b865cef22e254e395c0", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -62,8 +62,8 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 output.push('*');\n             }\n             match mutbl {\n-                hir::Mutability::Immutable => output.push_str(\"const \"),\n-                hir::Mutability::Mutable => output.push_str(\"mut \"),\n+                hir::Mutability::Not => output.push_str(\"const \"),\n+                hir::Mutability::Mut => output.push_str(\"mut \"),\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);"}, {"sha": "858ad9f1cfda72d42f2510d02e533026bf6a235b", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -373,8 +373,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::Ref(r, ty, mutbl) => {\n                 self.push(match mutbl {\n-                    hir::Mutability::Immutable => \"R\",\n-                    hir::Mutability::Mutable => \"Q\",\n+                    hir::Mutability::Not => \"R\",\n+                    hir::Mutability::Mut => \"Q\",\n                 });\n                 if *r != ty::ReErased {\n                     self = r.print(self)?;\n@@ -384,8 +384,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::RawPtr(mt) => {\n                 self.push(match mt.mutbl {\n-                    hir::Mutability::Immutable => \"P\",\n-                    hir::Mutability::Mutable => \"O\",\n+                    hir::Mutability::Not => \"P\",\n+                    hir::Mutability::Mut => \"O\",\n                 });\n                 self = mt.ty.print(self)?;\n             }"}, {"sha": "4cf694631d0d38040b3c080ac5354d8d612818dd", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -887,8 +887,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n-                if to_mt == hir::Mutability::Mutable &&\n-                   from_mt == hir::Mutability::Immutable {\n+                if to_mt == hir::Mutability::Mut &&\n+                   from_mt == hir::Mutability::Not {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }"}, {"sha": "06ec3f380091560484f1e91b1732ead11dcbeb5b", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -392,7 +392,7 @@ impl UnusedParens {\n         avoid_or: bool,\n         avoid_mut: bool,\n     ) {\n-        use ast::{PatKind, BindingMode::ByValue, Mutability::Mutable};\n+        use ast::{PatKind, BindingMode, Mutability};\n \n         if let PatKind::Paren(inner) = &value.kind {\n             match inner.kind {\n@@ -404,7 +404,7 @@ impl UnusedParens {\n                 // Avoid `p0 | .. | pn` if we should.\n                 PatKind::Or(..) if avoid_or => return,\n                 // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(ByValue(Mutable), ..) if avoid_mut => return,\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n                 // Otherwise proceed with linting.\n                 _ => {}\n             }\n@@ -560,7 +560,7 @@ impl EarlyLintPass for UnusedParens {\n             Ident(.., Some(p)) | Box(p) => self.check_unused_parens_pat(cx, p, true, false),\n             // Avoid linting on `&(mut x)` as `&mut x` has a different meaning, #55342.\n             // Also avoid linting on `& mut? (p0 | .. | pn)`, #64106.\n-            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Immutable),\n+            Ref(p, m) => self.check_unused_parens_pat(cx, p, true, *m == Mutability::Not),\n         }\n     }\n \n@@ -668,9 +668,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n         for adj in cx.tables.expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n                 let msg = match m {\n-                    adjustment::AutoBorrowMutability::Immutable =>\n+                    adjustment::AutoBorrowMutability::Not =>\n                         \"unnecessary allocation, use `&` instead\",\n-                    adjustment::AutoBorrowMutability::Mutable { .. }=>\n+                    adjustment::AutoBorrowMutability::Mut { .. }=>\n                         \"unnecessary allocation, use `&mut` instead\"\n                 };\n                 cx.span_lint(UNUSED_ALLOCATION, e.span, msg);"}, {"sha": "eb2fb39fb2f25da9cf86930cdd1dedad29a1ca4d", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1401,9 +1401,9 @@ impl<'a, 'tcx> CrateMetadata {\n     fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic |\n-            EntryKind::ForeignImmStatic => Some(hir::Mutability::Immutable),\n+            EntryKind::ForeignImmStatic => Some(hir::Mutability::Not),\n             EntryKind::MutStatic |\n-            EntryKind::ForeignMutStatic => Some(hir::Mutability::Mutable),\n+            EntryKind::ForeignMutStatic => Some(hir::Mutability::Mut),\n             _ => None,\n         }\n     }"}, {"sha": "d963323342c33f76f68fa436412ad3b69f80579c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1054,8 +1054,8 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         record!(self.per_def.kind[def_id] <- match item.kind {\n-            hir::ItemKind::Static(_, hir::Mutability::Mutable, _) => EntryKind::MutStatic,\n-            hir::ItemKind::Static(_, hir::Mutability::Immutable, _) => EntryKind::ImmStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n                 let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n@@ -1544,10 +1544,8 @@ impl EncodeContext<'tcx> {\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Mutable) =>\n-                EntryKind::ForeignMutStatic,\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Immutable) =>\n-                EntryKind::ForeignImmStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Mut) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n         record!(self.per_def.visibility[def_id] <-"}, {"sha": "38101c35dcc14e22f1b746d769a5e0f96c868262", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // we have an explicit self. Do the same thing in this case and check\n                         // for a `self: &mut Self` to suggest removing the `&mut`.\n                         if let ty::Ref(\n-                            _, _, hir::Mutability::Mutable\n+                            _, _, hir::Mutability::Mut\n                         ) = local_decl.ty.kind {\n                             true\n                         } else {\n@@ -578,7 +578,7 @@ fn suggest_ampmut<'tcx>(\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::Mutability::Immutable);\n+    assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n     (highlight_span,\n      if local_decl.ty.is_region_ptr() {\n          format!(\"&mut {}\", ty_mut.ty)\n@@ -614,7 +614,7 @@ fn annotate_struct_field(\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {\n                 if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n-                    mutbl: hir::Mutability::Immutable,\n+                    mutbl: hir::Mutability::Not,\n                     ref ty\n                 }) = field.ty.kind {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and"}, {"sha": "cd1e72e9d170106acb0e3b3748aa87837229da22", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -160,7 +160,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             };\n             let bm = *tables.pat_binding_modes().get(var_hir_id)\n                 .expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n+            if bm == ty::BindByValue(hir::Mutability::Mut) {\n                 upvar.mutability = Mutability::Mut;\n             }\n             upvar\n@@ -2225,10 +2225,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::Mutability::Immutable => Err(place),\n+                                    hir::Mutability::Not => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n-                                    hir::Mutability::Mutable => {\n+                                    hir::Mutability::Mut => {\n                                         let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n@@ -2248,10 +2248,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::Mutability::Immutable => Err(place),\n+                                    hir::Mutability::Not => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n-                                    hir::Mutability::Mutable => {\n+                                    hir::Mutability::Mut => {\n                                         Ok(RootPlace {\n                                             place_base: place.base,\n                                             place_projection: place.projection,"}, {"sha": "e11db4ad5bb6047103b781bada0ce8b6607ea7bc", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -58,15 +58,15 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n                 match ty.kind {\n-                    ty::Ref(_, _, hir::Mutability::Immutable) if i == 0 => {\n+                    ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {\n                         // For references to thread-local statics, we do need\n                         // to track the borrow.\n                         if body.local_decls[local].is_ref_to_thread_local() {\n                             continue;\n                         }\n                         return true;\n                     }\n-                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Not) => {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and\n                         // therefore not significant.  In particular,"}, {"sha": "0cc7af330caad25d865d38666f45a2b47c385873", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -246,13 +246,11 @@ fn place_components_conflict<'tcx>(\n                     debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n                     return false;\n                 }\n-                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Immutable), _) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Not), _) => {\n                     // Shouldn't be tracked\n                     bug!(\"Tracking borrow behind shared reference.\");\n                 }\n-                (ProjectionElem::Deref,\n-                 ty::Ref(_, _, hir::Mutability::Mutable),\n-                 AccessDepth::Drop) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Mut), AccessDepth::Drop) => {\n                     // Values behind a mutable reference are not access either by dropping a\n                     // value, or by StorageDead\n                     debug!(\"borrow_conflicts_with_place: drop access behind ptr\");"}, {"sha": "5b9ce7cb5fd8df5e37786c5fc849657be550a803", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -149,7 +149,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::Mutability::Immutable\n+                            hir::Mutability::Not\n                             ) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows.\n@@ -160,7 +160,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::Mutability::Mutable,\n+                            hir::Mutability::Mut,\n                             ) => {\n                             self.next = Some(PlaceRef {\n                                 base: cursor.base,"}, {"sha": "5613fd045ea50f4651e959e6ea6d7753d22e3cd0", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2162,7 +2162,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_from = match op.ty(*body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n-                                mutbl: hir::Mutability::Mutable,\n+                                mutbl: hir::Mutability::Mut,\n                             }) => ty_from,\n                             _ => {\n                                 span_mirbug!(\n@@ -2177,7 +2177,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_to = match ty.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n-                                mutbl: hir::Mutability::Immutable,\n+                                mutbl: hir::Mutability::Not,\n                             }) => ty_to,\n                             _ => {\n                                 span_mirbug!(\n@@ -2211,7 +2211,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: array_ty }\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: array_ty }\n                             ) => {\n                                 match array_ty.kind {\n                                     ty::Array(ty_elem, _) => Some(ty_elem),\n@@ -2236,7 +2236,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                         let ty_to = match ty.kind {\n                             ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: ty_to }\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: ty_to }\n                             ) => {\n                                 ty_to\n                             }\n@@ -2504,13 +2504,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             });\n \n                             match mutbl {\n-                                hir::Mutability::Immutable => {\n+                                hir::Mutability::Not => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n                                     break;\n                                 }\n-                                hir::Mutability::Mutable => {\n+                                hir::Mutability::Mut => {\n                                     // Mutable reference. We *do* need the base\n                                     // to be valid, because after the base becomes\n                                     // invalid, someone else can use our mutable deref."}, {"sha": "608415408e35c8b3d05060ea584a2cfc9ccd5b10", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -300,16 +300,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 mutability,\n                 arg,\n             } => {\n-                let address_of = match mutability {\n-                    hir::Mutability::Immutable => Rvalue::AddressOf(\n-                        Mutability::Not,\n-                        unpack!(block = this.as_read_only_place(block, arg)),\n-                    ),\n-                    hir::Mutability::Mutable => Rvalue::AddressOf(\n-                        Mutability::Mut,\n-                        unpack!(block = this.as_place(block, arg)),\n-                    ),\n+                let place = match mutability {\n+                    hir::Mutability::Not => this.as_read_only_place(block, arg),\n+                    hir::Mutability::Mut => this.as_place(block, arg),\n                 };\n+                let address_of = Rvalue::AddressOf(mutability, unpack!(block = place));\n                 this.cfg.push_assign(block, source_info, destination, address_of);\n                 block.unit()\n             }"}, {"sha": "3479ad6749a9041f07f4d0a74281dfab7c78c060", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -821,7 +821,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         name = ident.name;\n \n                         if let Some(&bm) = hir_tables.pat_binding_modes().get(pat.hir_id) {\n-                            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n+                            if bm == ty::BindByValue(hir::Mutability::Mut) {\n                                 mutability = Mutability::Mut;\n                             } else {\n                                 mutability = Mutability::Not;"}, {"sha": "c05641fe8bf0a870763078123b3d49f72b8aacd5", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -812,22 +812,21 @@ impl ToBorrowKind for AutoBorrowMutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n         use rustc::ty::adjustment::AllowTwoPhase;\n         match *self {\n-            AutoBorrowMutability::Mutable { allow_two_phase_borrow } =>\n+            AutoBorrowMutability::Mut { allow_two_phase_borrow } =>\n                 BorrowKind::Mut { allow_two_phase_borrow: match allow_two_phase_borrow {\n                     AllowTwoPhase::Yes => true,\n                     AllowTwoPhase::No => false\n                 }},\n-            AutoBorrowMutability::Immutable =>\n-                BorrowKind::Shared,\n+            AutoBorrowMutability::Not => BorrowKind::Shared,\n         }\n     }\n }\n \n impl ToBorrowKind for hir::Mutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n         match *self {\n-            hir::Mutability::Mutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n-            hir::Mutability::Immutable => BorrowKind::Shared,\n+            hir::Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+            hir::Mutability::Not => BorrowKind::Shared,\n         }\n     }\n }\n@@ -994,7 +993,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::Mutability::Immutable,\n+                                                               mutbl: hir::Mutability::Not,\n                                                            });\n                         Expr {\n                             ty: closure_ty,\n@@ -1015,7 +1014,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::Mutability::Mutable,\n+                                                               mutbl: hir::Mutability::Mut,\n                                                            });\n                         Expr {\n                             ty: closure_ty,"}, {"sha": "28f0edadc89caec1267303110d8dc293deb495ed", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -269,7 +269,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if bm != ty::BindByValue(hir::Mutability::Immutable) {\n+                if bm != ty::BindByValue(hir::Mutability::Not) {\n                     // Nothing to check.\n                     return true;\n                 }"}, {"sha": "7f15b3de5efc0ffc828b8f12fdf63e08d9f2e7fb", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -598,14 +598,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n-                    ty::BindByValue(hir::Mutability::Mutable) =>\n-                        (Mutability::Mut, BindingMode::ByValue),\n-                    ty::BindByValue(hir::Mutability::Immutable) =>\n-                        (Mutability::Not, BindingMode::ByValue),\n-                    ty::BindByReference(hir::Mutability::Mutable) =>\n+                    ty::BindByValue(mutbl) => (mutbl, BindingMode::ByValue),\n+                    ty::BindByReference(hir::Mutability::Mut) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Mut { allow_two_phase_borrow: false })),\n-                    ty::BindByReference(hir::Mutability::Immutable) =>\n+                    ty::BindByReference(hir::Mutability::Not) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Shared)),\n                 };"}, {"sha": "e4698303afe993873d037fa07ef3b49c57b968ee", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -115,22 +115,22 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n-        if mutability == Mutability::Immutable && frozen {\n-            alloc.mutability = Mutability::Immutable;\n+        if mutability == Mutability::Not && frozen {\n+            alloc.mutability = Mutability::Not;\n         } else {\n             // Just making sure we are not \"upgrading\" an immutable allocation to mutable.\n-            assert_eq!(alloc.mutability, Mutability::Mutable);\n+            assert_eq!(alloc.mutability, Mutability::Mut);\n         }\n     } else {\n         // We *could* be non-frozen at `ConstBase`, for constants like `Cell::new(0)`.\n         // But we still intern that as immutable as the memory cannot be changed once the\n         // initial value was computed.\n         // Constants are never mutable.\n         assert_eq!(\n-            mutability, Mutability::Immutable,\n+            mutability, Mutability::Not,\n             \"Something went very wrong: mutability requested for a constant\"\n         );\n-        alloc.mutability = Mutability::Immutable;\n+        alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n@@ -179,7 +179,7 @@ for\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n-                let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n+                let old = std::mem::replace(&mut self.mutability, Mutability::Mut);\n                 assert_ne!(\n                     self.mode, InternMode::Const,\n                     \"UnsafeCells are not allowed behind references in constants. This should have \\\n@@ -210,7 +210,7 @@ for\n                 if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n                     // explitly choose `Immutable` here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable\n-                    self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n+                    self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n@@ -223,16 +223,16 @@ for\n                 // const qualification enforces it. We can lift it in the future.\n                 match (self.mode, mutability) {\n                     // immutable references are fine everywhere\n-                    (_, hir::Mutability::Immutable) => {},\n+                    (_, hir::Mutability::Not) => {},\n                     // all is \"good and well\" in the unsoundness of `static mut`\n \n                     // mutable references are ok in `static`. Either they are treated as immutable\n                     // because they are behind an immutable one, or they are behind an `UnsafeCell`\n                     // and thus ok.\n-                    (InternMode::Static, hir::Mutability::Mutable) => {},\n+                    (InternMode::Static, hir::Mutability::Mut) => {},\n                     // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase, hir::Mutability::Mutable) |\n-                    (InternMode::Const, hir::Mutability::Mutable) => {\n+                    (InternMode::ConstBase, hir::Mutability::Mut) |\n+                    (InternMode::Const, hir::Mutability::Mut) => {\n                         match referenced_ty.kind {\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n@@ -243,16 +243,14 @@ for\n                     },\n                 }\n                 // Compute the mutability with which we'll start visiting the allocation. This is\n-                // what gets changed when we encounter an `UnsafeCell`\n-                let mutability = match (self.mutability, mutability) {\n-                    // The only way a mutable reference actually works as a mutable reference is\n-                    // by being in a `static mut` directly or behind another mutable reference.\n-                    // If there's an immutable reference or we are inside a static, then our\n-                    // mutable reference is equivalent to an immutable one. As an example:\n-                    // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                    (Mutability::Mutable, hir::Mutability::Mutable) => Mutability::Mutable,\n-                    _ => Mutability::Immutable,\n-                };\n+                // what gets changed when we encounter an `UnsafeCell`.\n+                //\n+                // The only way a mutable reference actually works as a mutable reference is\n+                // by being in a `static mut` directly or behind another mutable reference.\n+                // If there's an immutable reference or we are inside a static, then our\n+                // mutable reference is equivalent to an immutable one. As an example:\n+                // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                let mutability = self.mutability.and(mutability);\n                 // Recursing behind references changes the intern mode for constants in order to\n                 // cause assertions to trigger if we encounter any `UnsafeCell`s.\n                 let mode = match self.mode {\n@@ -282,11 +280,10 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match place_mut {\n-        Some(hir::Mutability::Immutable) => (Mutability::Immutable, InternMode::Static),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        Some(hir::Mutability::Mutable) => (Mutability::Mutable, InternMode::Static),\n+        Some(mutbl) => (mutbl, InternMode::Static),\n         // consts, promoteds. FIXME: what about array lengths, array initializers?\n-        None => (Mutability::Immutable, InternMode::ConstBase),\n+        None => (Mutability::Not, InternMode::ConstBase),\n     };\n \n     // Type based interning.\n@@ -346,7 +343,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                 // We cannot have mutable memory inside a constant.\n                 // FIXME: ideally we would assert that they already are immutable, to double-\n                 // check our static checks.\n-                alloc.mutability = Mutability::Immutable;\n+                alloc.mutability = Mutability::Not;\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);"}, {"sha": "ba571043d38130da92617649a1b410946ce3c2fa", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -539,7 +539,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // Need to make a copy, even if `get_static_alloc` is able\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n-            if alloc.mutability == Mutability::Immutable {\n+            if alloc.mutability == Mutability::Not {\n                 throw_unsup!(ModifiedConstantMemory)\n             }\n             match M::STATIC_KIND {\n@@ -553,7 +553,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Err(e) => Err(e),\n             Ok(a) => {\n                 let a = &mut a.1;\n-                if a.mutability == Mutability::Immutable {\n+                if a.mutability == Mutability::Not {\n                     throw_unsup!(ModifiedConstantMemory)\n                 }\n                 Ok(a)\n@@ -643,7 +643,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_raw_mut(id)?.mutability = Mutability::Immutable;\n+        self.get_raw_mut(id)?.mutability = Mutability::Not;\n         Ok(())\n     }\n "}, {"sha": "a29748962181e6209f27c2b9f28b45901386cb14", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -471,7 +471,7 @@ impl CloneShimBuilder<'tcx> {\n             Mutability::Not,\n             tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                 ty,\n-                mutbl: hir::Mutability::Immutable,\n+                mutbl: hir::Mutability::Not,\n             })\n         );\n \n@@ -757,7 +757,7 @@ fn build_call_shim<'tcx>(\n                 Mutability::Not,\n                 tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n-                    mutbl: hir::Mutability::Mutable\n+                    mutbl: hir::Mutability::Mut\n                 }),\n                 span\n             ));"}, {"sha": "e8365a9ee1c13c779c38bf843ec00817b35f73db", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -87,8 +87,8 @@ impl ConstKind {\n \n             HirKind::Const => ConstKind::Const,\n \n-            HirKind::Static(hir::Mutability::Immutable) => ConstKind::Static,\n-            HirKind::Static(hir::Mutability::Mutable) => ConstKind::StaticMut,\n+            HirKind::Static(hir::Mutability::Not) => ConstKind::Static,\n+            HirKind::Static(hir::Mutability::Mut) => ConstKind::StaticMut,\n         };\n \n         Some(mode)"}, {"sha": "1a24a8b371d76efa4864f6a642ab0235e44e28d9", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -238,7 +238,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     ) -> InterpResult<'tcx> {\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n-        if allocation.mutability == Mutability::Mutable || allocation.relocations().len() > 0 {\n+        if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n             throw_unsup!(ConstPropUnsupported(\"can't eval mutable statics in ConstProp\"));\n         }\n "}, {"sha": "b314ff83abe6a757c3086927bcdaddebb4c6ff41", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -391,7 +391,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n \n     let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut {\n         ty: gen_ty,\n-        mutbl: hir::Mutability::Mutable\n+        mutbl: hir::Mutability::Mut\n     });\n \n     // Replace the by value generator argument\n@@ -969,7 +969,7 @@ fn create_generator_drop_shim<'tcx>(\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n-            mutbl: hir::Mutability::Mutable,\n+            mutbl: hir::Mutability::Mut,\n         }),\n         user_ty: UserTypeProjections::none(),\n         source_info,"}, {"sha": "0d2e0bb8281e0096a277e981d6373f3e91e9e98b", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -79,7 +79,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.kind {\n-            ty::Ref(_, _, hir::Mutability::Mutable) => {\n+            ty::Ref(_, _, hir::Mutability::Mut) => {\n                 if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n                     return Err((\n                         span,"}, {"sha": "6ff84996bd34aeb439134973124494c8e6b91053", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -521,7 +521,7 @@ where\n \n         let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n             ty,\n-            mutbl: hir::Mutability::Mutable\n+            mutbl: hir::Mutability::Mut\n         });\n         let ref_place = self.new_temp(ref_ty);\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n@@ -580,7 +580,7 @@ where\n \n         let ptr_ty = tcx.mk_ptr(ty::TypeAndMut {\n             ty: ety,\n-            mutbl: hir::Mutability::Mutable\n+            mutbl: hir::Mutability::Mut\n         });\n         let ptr = &Place::from(self.new_temp(ptr_ty));\n         let can_go = Place::from(self.new_temp(tcx.types.bool));"}, {"sha": "353f6607c1db77a2b01ee5c67325c4a77a8dc384", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -22,7 +22,7 @@ const TURBOFISH: &'static str = \"use `::<...>` instead of `<...>` to specify typ\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n+        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None),\n         span: ident.span,\n     });\n     let ty = Ty {"}, {"sha": "271e5092018d9ba8a020d264934a1a0d3cb6c3d3", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1239,8 +1239,8 @@ impl<'a> Parser<'a> {\n         // Construct the error and stash it away with the hope\n         // that typeck will later enrich the error with a type.\n         let kind = match m {\n-            Some(Mutability::Mutable) => \"static mut\",\n-            Some(Mutability::Immutable) => \"static\",\n+            Some(Mutability::Mut) => \"static mut\",\n+            Some(Mutability::Not) => \"static\",\n             None => \"const\",\n         };\n         let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{}` item\", kind));\n@@ -1960,7 +1960,7 @@ impl<'a> Parser<'a> {\n             match ty {\n                 Ok(ty) => {\n                     let ident = Ident::new(kw::Invalid, self.prev_span);\n-                    let bm = BindingMode::ByValue(Mutability::Immutable);\n+                    let bm = BindingMode::ByValue(Mutability::Not);\n                     let pat = self.mk_pat_ident(ty.span, bm, ident);\n                     (pat, ty)\n                 }\n@@ -2032,7 +2032,7 @@ impl<'a> Parser<'a> {\n                 .span_label(span, msg)\n                 .emit();\n \n-            Ok((SelfKind::Value(Mutability::Immutable), expect_self_ident(this), this.prev_span))\n+            Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_span))\n         };\n \n         // Parse optional `self` parameter of a method.\n@@ -2044,23 +2044,23 @@ impl<'a> Parser<'a> {\n                 let eself = if is_isolated_self(self, 1) {\n                     // `&self`\n                     self.bump();\n-                    SelfKind::Region(None, Mutability::Immutable)\n+                    SelfKind::Region(None, Mutability::Not)\n                 } else if is_isolated_mut_self(self, 1) {\n                     // `&mut self`\n                     self.bump();\n                     self.bump();\n-                    SelfKind::Region(None, Mutability::Mutable)\n+                    SelfKind::Region(None, Mutability::Mut)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_self(self, 2) {\n                     // `&'lt self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n-                    SelfKind::Region(Some(lt), Mutability::Immutable)\n+                    SelfKind::Region(Some(lt), Mutability::Not)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) && is_isolated_mut_self(self, 2) {\n                     // `&'lt mut self`\n                     self.bump();\n                     let lt = self.expect_lifetime();\n                     self.bump();\n-                    SelfKind::Region(Some(lt), Mutability::Mutable)\n+                    SelfKind::Region(Some(lt), Mutability::Mut)\n                 } else {\n                     // `&not_self`\n                     return Ok(None);\n@@ -2083,12 +2083,12 @@ impl<'a> Parser<'a> {\n             }\n             // `self` and `self: TYPE`\n             token::Ident(..) if is_isolated_self(self, 0) => {\n-                parse_self_possibly_typed(self, Mutability::Immutable)?\n+                parse_self_possibly_typed(self, Mutability::Not)?\n             }\n             // `mut self` and `mut self: TYPE`\n             token::Ident(..) if is_isolated_mut_self(self, 0) => {\n                 self.bump();\n-                parse_self_possibly_typed(self, Mutability::Mutable)?\n+                parse_self_possibly_typed(self, Mutability::Mut)?\n             }\n             _ => return Ok(None),\n         };"}, {"sha": "16bc2e1a8d60e4493ef6da3ba6c35864a832dec1", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -974,18 +974,18 @@ impl<'a> Parser<'a> {\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) {\n-            Mutability::Mutable\n+            Mutability::Mut\n         } else {\n-            Mutability::Immutable\n+            Mutability::Not\n         }\n     }\n \n     /// Possibly parses mutability (`const` or `mut`).\n     fn parse_const_or_mut(&mut self) -> Option<Mutability> {\n         if self.eat_keyword(kw::Mut) {\n-            Some(Mutability::Mutable)\n+            Some(Mutability::Mut)\n         } else if self.eat_keyword(kw::Const) {\n-            Some(Mutability::Immutable)\n+            Some(Mutability::Not)\n         } else {\n             None\n         }"}, {"sha": "33cac1aaceeb0bd4e28431901b516818d5af6741", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -325,7 +325,7 @@ impl<'a> Parser<'a> {\n                 // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n                 // they are dealt with later in resolve.\n-                self.parse_pat_ident(BindingMode::ByValue(Mutability::Immutable))?\n+                self.parse_pat_ident(BindingMode::ByValue(Mutability::Not))?\n             } else if self.is_start_of_pat_with_path() {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n@@ -539,7 +539,7 @@ impl<'a> Parser<'a> {\n             )\n             .emit();\n \n-        self.parse_pat_ident(BindingMode::ByRef(Mutability::Mutable))\n+        self.parse_pat_ident(BindingMode::ByRef(Mutability::Mut))\n     }\n \n     /// Turn all by-value immutable bindings in a pattern into mutable bindings.\n@@ -552,10 +552,10 @@ impl<'a> Parser<'a> {\n             }\n \n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-                if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Immutable), ..)\n+                if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Not), ..)\n                     = pat.kind\n                 {\n-                    *m = Mutability::Mutable;\n+                    *m = Mutability::Mut;\n                     self.0 = true;\n                 }\n                 noop_visit_pat(pat, self);\n@@ -986,10 +986,10 @@ impl<'a> Parser<'a> {\n             hi = self.prev_span;\n \n             let bind_type = match (is_ref, is_mut) {\n-                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n-                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n-                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n-                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n+                (true, true) => BindingMode::ByRef(Mutability::Mut),\n+                (true, false) => BindingMode::ByRef(Mutability::Not),\n+                (false, true) => BindingMode::ByValue(Mutability::Mut),\n+                (false, false) => BindingMode::ByValue(Mutability::Not),\n             };\n \n             let fieldpat = self.mk_pat_ident(boxed_span.to(hi), bind_type, fieldname);"}, {"sha": "86692610324d411806d0722441d1c0247b2a24f5", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -261,7 +261,7 @@ impl<'a> Parser<'a> {\n                 .span_label(span, msg)\n                 .help(\"use `*mut T` or `*const T` as appropriate\")\n                 .emit();\n-            Mutability::Immutable\n+            Mutability::Not\n         });\n         let t = self.parse_ty_no_plus()?;\n         Ok(MutTy { ty: t, mutbl })"}, {"sha": "ee6a67802ade38237ee305cb972dbf822e797f3b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -161,9 +161,9 @@ impl<'a> AstValidator<'a> {\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None) |\n                 PatKind::Wild => {}\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mutable), _, None) =>\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), _, None) =>\n                     report_err(pat.span, true),\n                 _ => report_err(pat.span, false),\n             }"}, {"sha": "f7bdefcb0690b83c5e87cff24beb39d6291cb82c", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -81,8 +81,8 @@ impl ConstKind {\n         let owner = hir_map.body_owner(body.id());\n         let const_kind = match hir_map.body_owner_kind(owner) {\n             hir::BodyOwnerKind::Const => Self::Const,\n-            hir::BodyOwnerKind::Static(Mutability::Mutable) => Self::StaticMut,\n-            hir::BodyOwnerKind::Static(Mutability::Immutable) => Self::Static,\n+            hir::BodyOwnerKind::Static(Mutability::Mut) => Self::StaticMut,\n+            hir::BodyOwnerKind::Static(Mutability::Not) => Self::Static,\n \n             hir::BodyOwnerKind::Fn if is_const_fn(owner) => Self::ConstFn,\n             hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => return None,"}, {"sha": "43ac85993344e24e91f5311757b39ed0790ce422", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1472,7 +1472,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n         // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n-        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Immutable);\n+        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n         match res {\n             Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |"}, {"sha": "0509748020a8452a57047312f42ce381e2f3b7af", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -985,7 +985,7 @@ impl<'l> Visitor<'l> for PathCollector<'l> {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n-                    ast::BindingMode::ByRef(_) => ast::Mutability::Immutable,\n+                    ast::BindingMode::ByRef(_) => ast::Mutability::Not,\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 self.collected_idents"}, {"sha": "d1ac0ac210e40894a7e1c8c35020bdebac3ce4e6", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -175,8 +175,8 @@ impl Sig for ast::Ty {\n             }\n             ast::TyKind::Ptr(ref mt) => {\n                 let prefix = match mt.mutbl {\n-                    ast::Mutability::Mutable => \"*mut \",\n-                    ast::Mutability::Immutable => \"*const \",\n+                    ast::Mutability::Mut => \"*mut \",\n+                    ast::Mutability::Not => \"*const \",\n                 };\n                 let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n                 let text = format!(\"{}{}\", prefix, nested.text);\n@@ -188,7 +188,7 @@ impl Sig for ast::Ty {\n                     prefix.push_str(&l.ident.to_string());\n                     prefix.push(' ');\n                 }\n-                if let ast::Mutability::Mutable = mt.mutbl {\n+                if let ast::Mutability::Mut = mt.mutbl {\n                     prefix.push_str(\"mut \");\n                 };\n \n@@ -330,7 +330,7 @@ impl Sig for ast::Item {\n         match self.kind {\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 let mut text = \"static \".to_owned();\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();\n@@ -787,7 +787,7 @@ impl Sig for ast::ForeignItem {\n             }\n             ast::ForeignItemKind::Static(ref ty, m) => {\n                 let mut text = \"static \".to_owned();\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();"}, {"sha": "f281ac176206499bc2a04d6bdf1f6a2282ecd42a", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -243,7 +243,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Float(..) |\n         ty::RawPtr(..) |\n         ty::Never |\n-        ty::Ref(_, _, hir::Mutability::Immutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Not) => (),\n \n         // Non parametric primitive types.\n         ty::Infer(ty::IntVar(_)) |\n@@ -319,7 +319,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Generator(..) |\n         ty::Str |\n         ty::Slice(..) |\n-        ty::Ref(_, _, hir::Mutability::Mutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Mut) => (),\n \n         ty::Bound(..) |\n         ty::GeneratorWitness(..) |"}, {"sha": "182c64e9069cdbb0bc68928ff755e063d28886ff", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -430,8 +430,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let contains_ref_bindings = arms.iter()\n             .filter_map(|a| a.pat.contains_explicit_ref_binding())\n             .max_by_key(|m| match *m {\n-                hir::Mutability::Mutable => 1,\n-                hir::Mutability::Immutable => 0,\n+                hir::Mutability::Mut => 1,\n+                hir::Mutability::Not => 0,\n             });\n \n         if let Some(m) = contains_ref_bindings {"}, {"sha": "db969486b8d16b180c9e38ad87a329dca3e067cf", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -217,8 +217,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Not => AutoBorrowMutability::Not,\n+                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                 // For initial two-phase borrow\n                                 // deployment, conservatively omit\n                                 // overloaded function call ops."}, {"sha": "052364396953f63c59f61ace3f7af410c2d6f477", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -637,8 +637,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n-        if m_expr.mutbl == hir::Mutability::Immutable &&\n-            m_cast.mutbl == hir::Mutability::Immutable {\n+        if m_expr.mutbl == hir::Mutability::Not &&\n+            m_cast.mutbl == hir::Mutability::Not {\n             if let ty::Array(ety, _) = m_expr.ty.kind {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of"}, {"sha": "e44b00d74bf0a162be23afd48210a736b13e1594", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -101,10 +101,10 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n                        -> RelateResult<'tcx, ()> {\n     match (from_mutbl, to_mutbl) {\n-        (hir::Mutability::Mutable, hir::Mutability::Mutable) |\n-        (hir::Mutability::Immutable, hir::Mutability::Immutable) |\n-        (hir::Mutability::Mutable, hir::Mutability::Immutable) => Ok(()),\n-        (hir::Mutability::Immutable, hir::Mutability::Mutable) => Err(TypeError::Mutability),\n+        (hir::Mutability::Mut, hir::Mutability::Mut) |\n+        (hir::Mutability::Not, hir::Mutability::Not) |\n+        (hir::Mutability::Mut, hir::Mutability::Not) => Ok(()),\n+        (hir::Mutability::Not, hir::Mutability::Mut) => Err(TypeError::Mutability),\n     }\n }\n \n@@ -412,7 +412,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        if ty == a && mt_a.mutbl == hir::Mutability::Immutable && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -424,7 +424,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mt_b.mutbl, hir::Mutability::Immutable); // can only coerce &T -> &U\n+            assert_eq!(mt_b.mutbl, hir::Mutability::Not); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -441,8 +441,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n-            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+            hir::Mutability::Not => AutoBorrowMutability::Not,\n+            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                 allow_two_phase_borrow: self.allow_two_phase,\n             }\n         };\n@@ -487,8 +487,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n                 let mutbl = match mutbl_b {\n-                    hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                    hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                    hir::Mutability::Not => AutoBorrowMutability::Not,\n+                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                         // We don't allow two-phase borrows here, at least for initial\n                         // implementation. If it happens that this coercion is a function argument,\n                         // the reborrow in coerce_borrowed_ptr will pick it up."}, {"sha": "ab8a4e5a9d053eb69f134e5b2bdcc9e5382e4add", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -534,8 +534,8 @@ fn compare_self_type<'tcx>(\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Immutable) => \"&self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::Mutability::Mutable) => \"&mut self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n                 _ => format!(\"self: {}\", self_arg_ty)\n             }\n         })"}, {"sha": "6a78a4d733a9450d41c6c7429a2a63ffa40d2eba", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -436,10 +436,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // bar(&x); // error, expected &mut\n                 // ```\n                 let ref_ty = match mutability {\n-                    hir::Mutability::Mutable => {\n+                    hir::Mutability::Mut => {\n                         self.tcx.mk_mut_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n-                    hir::Mutability::Immutable => {\n+                    hir::Mutability::Not => {\n                         self.tcx.mk_imm_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n                 };\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })) = self.tcx.hir().find(\n                             self.tcx.hir().get_parent_node(expr.hir_id),\n                         ) {\n-                            if mutability == hir::Mutability::Mutable {\n+                            if mutability == hir::Mutability::Mut {\n                                 // Found the following case:\n                                 // fn foo(opt: &mut Option<String>){ opt = None }\n                                 //                                   ---   ^^^^\n@@ -508,12 +508,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         return Some(match mutability {\n-                            hir::Mutability::Mutable => (\n+                            hir::Mutability::Mut => (\n                                 sp,\n                                 \"consider mutably borrowing here\",\n                                 format!(\"{}&mut {}\", field_name, sugg_expr),\n                             ),\n-                            hir::Mutability::Immutable => (\n+                            hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\",\n                                 format!(\"{}&{}\", field_name, sugg_expr),"}, {"sha": "17b168cfab05a193c10b336c8744208cbd72a9e2", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -365,8 +365,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let method = self.register_infer_ok_obligations(ok);\n                         if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                             let mutbl = match mutbl {\n-                                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                                hir::Mutability::Not => AutoBorrowMutability::Not,\n+                                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                     // (It shouldn't actually matter for unary ops whether\n                                     // we enable two-phase borrows or not, since a unary\n                                     // op has no additional operands.)"}, {"sha": "c5eb94e2165b8705a59879e0b2ed5e2669c1bc20", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -165,7 +165,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n                 (1, vec![tcx.mk_ptr(ty::TypeAndMut {\n                           ty: param(0),\n-                          mutbl: hir::Mutability::Immutable\n+                          mutbl: hir::Mutability::Not\n                          }), tcx.types.i32],\n                     tcx.mk_unit())\n             }\n@@ -181,25 +181,25 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Immutable\n+                      mutbl: hir::Mutability::Not\n                   }),\n                   tcx.types.isize\n                ],\n                tcx.mk_ptr(ty::TypeAndMut {\n                    ty: param(0),\n-                   mutbl: hir::Mutability::Immutable\n+                   mutbl: hir::Mutability::Not\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Immutable\n+                      mutbl: hir::Mutability::Not\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Mutable\n+                      mutbl: hir::Mutability::Mut\n                   }),\n                   tcx.types.usize,\n                ],\n@@ -210,11 +210,11 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Mutable\n+                      mutbl: hir::Mutability::Mut\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Immutable\n+                      mutbl: hir::Mutability::Not\n                   }),\n                   tcx.types.usize,\n                ],\n@@ -225,7 +225,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::Mutability::Mutable\n+                      mutbl: hir::Mutability::Mut\n                   }),\n                   tcx.types.u8,\n                   tcx.types.usize,\n@@ -351,14 +351,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             }\n \n             \"va_start\" | \"va_end\" => {\n-                match mk_va_list_ty(hir::Mutability::Mutable) {\n+                match mk_va_list_ty(hir::Mutability::Mut) {\n                     Some((va_list_ref_ty, _)) => (0, vec![va_list_ref_ty], tcx.mk_unit()),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_copy\" => {\n-                match mk_va_list_ty(hir::Mutability::Immutable) {\n+                match mk_va_list_ty(hir::Mutability::Not) {\n                     Some((va_list_ref_ty, va_list_ty)) => {\n                         let va_list_ptr_ty = tcx.mk_mut_ptr(va_list_ty);\n                         (0, vec![va_list_ptr_ty, va_list_ref_ty], tcx.mk_unit())\n@@ -368,7 +368,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             }\n \n             \"va_arg\" => {\n-                match mk_va_list_ty(hir::Mutability::Mutable) {\n+                match mk_va_list_ty(hir::Mutability::Mut) {\n                     Some((va_list_ref_ty, _)) => (1, vec![va_list_ref_ty], param(0)),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }"}, {"sha": "d04baf7dd077b4d8390ad57c0a63f194b300c568", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             sig: method_sig,\n         };\n \n-        if let Some(hir::Mutability::Mutable) = pick.autoref {\n+        if let Some(hir::Mutability::Mut) = pick.autoref {\n             self.convert_place_derefs_to_mutable();\n         }\n \n@@ -172,8 +172,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 ty: target\n             });\n             let mutbl = match mutbl {\n-                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                hir::Mutability::Not => AutoBorrowMutability::Not,\n+                hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                     // Method call receivers are the primary use case\n                     // for two-phase borrows.\n                     allow_two_phase_borrow: AllowTwoPhase::Yes,\n@@ -554,8 +554,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n                     debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n                     let mutbl = match mutbl {\n-                        hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                        hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                             // For initial two-phase borrow\n                             // deployment, conservatively omit\n                             // overloaded operators."}, {"sha": "f797eec911bfdc2a707faedf381c9f242b764336", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -608,11 +608,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let lang_def_id = lang_items.slice_u8_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Immutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n                 let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -1047,8 +1047,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n                     });\n                 self.pick_by_value_method(step, self_ty).or_else(|| {\n-                self.pick_autorefd_method(step, self_ty, hir::Mutability::Immutable).or_else(|| {\n-                self.pick_autorefd_method(step, self_ty, hir::Mutability::Mutable)\n+                self.pick_autorefd_method(step, self_ty, hir::Mutability::Not).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::Mutability::Mut)\n             })})})\n             .next()\n     }"}, {"sha": "afd027e34380d9f6197010872e91fc6bb7f58f02", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -397,8 +397,8 @@ pub enum Needs {\n impl Needs {\n     fn maybe_mut_place(m: hir::Mutability) -> Self {\n         match m {\n-            hir::Mutability::Mutable => Needs::MutPlace,\n-            hir::Mutability::Immutable => Needs::None,\n+            hir::Mutability::Mut => Needs::MutPlace,\n+            hir::Mutability::Not => Needs::None,\n         }\n     }\n }\n@@ -1436,7 +1436,7 @@ fn check_fn<'a, 'tcx>(\n                         ty::Ref(region, ty, mutbl) => match ty.kind {\n                             ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did &&\n-                                    mutbl == hir::Mutability::Immutable &&\n+                                    mutbl == hir::Mutability::Not &&\n                                     *region != RegionKind::ReStatic\n                             },\n                             _ => false,\n@@ -3419,8 +3419,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut adjustments = autoderef.adjust_steps(self, needs);\n                 if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n                     let mutbl = match r_mutbl {\n-                        hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                        hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                             // Indexing can be desugared to a method call,\n                             // so maybe we could use two-phase here.\n                             // See the documentation of AllowTwoPhase for why that's"}, {"sha": "041a6c6f44c519f2ffa937fccd0cbfbd8fb497a1", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -206,8 +206,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Not => AutoBorrowMutability::Not,\n+                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n                                 allow_two_phase_borrow: AllowTwoPhase::Yes,\n@@ -223,8 +223,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind {\n                         let mutbl = match mutbl {\n-                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n-                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Not => AutoBorrowMutability::Not,\n+                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n                                 allow_two_phase_borrow: AllowTwoPhase::Yes,"}, {"sha": "11f744e97614c7bfa007d04665968a17b8c18c1a", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -32,7 +32,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Immutable);\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n         self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n \n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //\n             // See issue #46688.\n             let def_bm = match pat.kind {\n-                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Immutable),\n+                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Not),\n                 _ => def_bm,\n             };\n             (expected, def_bm)\n@@ -277,10 +277,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // (depending on whether we observe `&` or `&mut`).\n                 ty::BindByValue(_) |\n                 // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref` (on `&`).\n-                ty::BindByReference(hir::Mutability::Mutable) => inner_mutability,\n+                ty::BindByReference(hir::Mutability::Mut) => inner_mutability,\n                 // Once a `ref`, always a `ref`.\n                 // This is because a `& &mut` cannot mutate the underlying value.\n-                ty::BindByReference(m @ hir::Mutability::Immutable) => m,\n+                ty::BindByReference(m @ hir::Mutability::Not) => m,\n             });\n         }\n "}, {"sha": "179c462f5e374a08d5b73ba44a88acfcc27396e4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1255,15 +1255,15 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         // know whether this scenario has occurred; but I wanted to show\n         // how all the types get adjusted.)\n         match ref_mutability {\n-            hir::Mutability::Immutable => {\n+            hir::Mutability::Not => {\n                 // The reference being reborrowed is a shareable ref of\n                 // type `&'a T`. In this case, it doesn't matter where we\n                 // *found* the `&T` pointer, the memory it references will\n                 // be valid and immutable for `'a`. So we can stop here.\n                 true\n             }\n \n-            hir::Mutability::Mutable => {\n+            hir::Mutability::Mut => {\n                 // The reference being reborrowed is either an `&mut T`. This is\n                 // the case where recursion is needed.\n                 false"}, {"sha": "68cb0080b7d4135f3704885eb3a04f45be60a1a9", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n                     // necessarily *mutable*\n-                    ty::Ref(.., hir::Mutability::Mutable) => borrow_kind = ty::UniqueImmBorrow,\n+                    ty::Ref(.., hir::Mutability::Mut) => borrow_kind = ty::UniqueImmBorrow,\n                     _ => (),\n                 }\n             }"}, {"sha": "3797fcb1a6b4c8295c7927f73cb318e17e981961", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -360,7 +360,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n                            mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Immutable, hir::Mutability::Mutable) {\n+            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n                 infcx.report_mismatched_types(&cause,\n                                               mk_ptr(mt_b.ty),\n                                               target,"}, {"sha": "2e2e56e6dcfeded2b99513ce1848f45b745e1bba", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -109,15 +109,15 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                                           \"[T]\",\n                                           item.span);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Immutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n                                           None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n                                           None,"}, {"sha": "30558a0f5f679f5f8dbbfc6611fce14e03107145", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -454,12 +454,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n-            hir::Mutability::Mutable => {\n+            hir::Mutability::Mut => {\n                 let invar = self.invariant(variance);\n                 self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n-            hir::Mutability::Immutable => {\n+            hir::Mutability::Not => {\n                 self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }"}, {"sha": "cebfd99452ad42b0b630c9d6f0e6291b96d013f5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -2101,8 +2101,8 @@ impl Clean<Item> for doctree::Constant<'_> {\n impl Clean<Mutability> for hir::Mutability {\n     fn clean(&self, _: &DocContext<'_>) -> Mutability {\n         match self {\n-            &hir::Mutability::Mutable => Mutable,\n-            &hir::Mutability::Immutable => Immutable,\n+            &hir::Mutability::Mut => Mutable,\n+            &hir::Mutability::Not => Immutable,\n         }\n     }\n }"}, {"sha": "aa38a8135cecbe462d6a9c982b2dbe33320363de", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -509,7 +509,7 @@ impl Pat {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) => {\n+            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n@@ -695,30 +695,30 @@ pub enum PatKind {\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n pub enum Mutability {\n-    Mutable,\n-    Immutable,\n+    Mut,\n+    Not,\n }\n \n impl Mutability {\n     /// Returns `MutMutable` only if both `self` and `other` are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n-            Mutability::Mutable => other,\n-            Mutability::Immutable => Mutability::Immutable,\n+            Mutability::Mut => other,\n+            Mutability::Not => Mutability::Not,\n         }\n     }\n \n     pub fn invert(self) -> Self {\n         match self {\n-            Mutability::Mutable => Mutability::Immutable,\n-            Mutability::Immutable => Mutability::Mutable,\n+            Mutability::Mut => Mutability::Not,\n+            Mutability::Not => Mutability::Mut,\n         }\n     }\n \n     pub fn prefix_str(&self) -> &'static str {\n         match self {\n-            Mutability::Mutable => \"mut \",\n-            Mutability::Immutable => \"\",\n+            Mutability::Mut => \"mut \",\n+            Mutability::Not => \"\",\n         }\n     }\n }\n@@ -2037,7 +2037,7 @@ impl Param {\n             SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n             SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n             SelfKind::Region(lt, mutbl) => param(\n-                Mutability::Immutable,\n+                Mutability::Not,\n                 P(Ty {\n                     id: DUMMY_NODE_ID,\n                     kind: TyKind::Rptr("}, {"sha": "e63d11ce832279a451a362f6bd666f642ca5f3f6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1071,7 +1071,7 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -1162,7 +1162,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mutable {\n+                if m == ast::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -2302,8 +2302,8 @@ impl<'a> State<'a> {\n                         self.word_nbsp(\"ref\");\n                         self.print_mutability(mutbl, false);\n                     }\n-                    ast::BindingMode::ByValue(ast::Mutability::Immutable) => {}\n-                    ast::BindingMode::ByValue(ast::Mutability::Mutable) => {\n+                    ast::BindingMode::ByValue(ast::Mutability::Not) => {}\n+                    ast::BindingMode::ByValue(ast::Mutability::Mut) => {\n                         self.word_nbsp(\"mut\");\n                     }\n                 }\n@@ -2366,7 +2366,7 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 self.s.word(\"&\");\n-                if mutbl == ast::Mutability::Mutable {\n+                if mutbl == ast::Mutability::Mut {\n                     self.s.word(\"mut \");\n                 }\n                 self.print_pat(inner);\n@@ -2667,8 +2667,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n-            ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            ast::Mutability::Immutable => if print_const { self.word_nbsp(\"const\"); },\n+            ast::Mutability::Mut => self.word_nbsp(\"mut\"),\n+            ast::Mutability::Not => if print_const { self.word_nbsp(\"const\"); },\n         }\n     }\n "}, {"sha": "7c69be56beb81f956da11af5ee9e57555b442b8c", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -178,7 +178,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n+            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mut);\n             self.pat_ident_binding_mode(sp, ident, binding_mode)\n         } else {\n             self.pat_ident(sp, ident)\n@@ -269,7 +269,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Immutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Not, e))\n     }\n \n     pub fn expr_call(\n@@ -421,7 +421,7 @@ impl<'a> ExtCtxt<'a> {\n         self.pat(span, PatKind::Lit(expr))\n     }\n     pub fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n-        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Immutable);\n+        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Not);\n         self.pat_ident_binding_mode(span, ident, binding_mode)\n     }\n "}, {"sha": "1b1a231f2d8703ba0e93f8bebc12fe258385879e", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -16,7 +16,7 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt<'_>,\n                              push: &mut dyn FnMut(Annotatable)) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(Box::new(Literal(path_std!(cx, fmt::Formatter))),\n-                   Borrowed(None, ast::Mutability::Mutable));\n+                   Borrowed(None, ast::Mutability::Mut));\n \n     let trait_def = TraitDef {\n         span,"}, {"sha": "5cc5aebaba02098a242eb9c1264350f9e5481e42", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -39,7 +39,7 @@ pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt<'_>,\n                           },\n                           explicit_self: None,\n                           args: vec![(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                                         Borrowed(None, Mutability::Mutable)), \"d\")],\n+                                         Borrowed(None, Mutability::Mut)), \"d\")],\n                           ret_ty:\n                               Literal(Path::new_(pathvec_std!(cx, result::Result),\n                                                  None,"}, {"sha": "99ee0f47d6d6667cdc207bc69bd7b827f172a593", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -123,7 +123,7 @@ pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt<'_>,\n                 },\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec![(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                           Borrowed(None, Mutability::Mutable)), \"s\")],\n+                           Borrowed(None, Mutability::Mut)), \"s\")],\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, result::Result),\n                     None,"}, {"sha": "5fecd13db9895d8901e0f78665701b3f14cc5f50", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -1017,7 +1017,7 @@ impl<'a> MethodDef<'a> {\n                                                                  struct_path,\n                                                                  struct_def,\n                                                                  &format!(\"__self_{}\", i),\n-                                                                 ast::Mutability::Immutable,\n+                                                                 ast::Mutability::Not,\n                                                                  use_temporaries);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -1227,8 +1227,8 @@ impl<'a> MethodDef<'a> {\n                                                      type_ident,\n                                                      variant,\n                                                      self_arg_name,\n-                                                     ast::Mutability::Immutable);\n-                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Immutable)), idents)\n+                                                     ast::Mutability::Not);\n+                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Not)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n@@ -1558,7 +1558,7 @@ impl<'a> TraitDef<'a> {\n         field_paths.iter()\n             .map(|path| {\n                 let binding_mode = if use_temporaries {\n-                    ast::BindingMode::ByValue(ast::Mutability::Immutable)\n+                    ast::BindingMode::ByValue(ast::Mutability::Not)\n                 } else {\n                     ast::BindingMode::ByRef(mutbl)\n                 };"}, {"sha": "b7aa8874aad3dc689c1b3c4f4faf47e80462593b", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -108,7 +108,7 @@ pub enum Ty<'a> {\n }\n \n pub fn borrowed_ptrty() -> PtrTy {\n-    Borrowed(None, ast::Mutability::Immutable)\n+    Borrowed(None, ast::Mutability::Not)\n }\n pub fn borrowed(ty: Box<Ty<'_>>) -> Ty<'_> {\n     Ptr(ty, borrowed_ptrty())\n@@ -268,7 +268,7 @@ pub fn get_explicit_self(cx: &ExtCtxt<'_>,\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n-        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable))),\n+        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Not))),\n         Some(ref ptr) => {\n             let self_ty =\n                 respan(span,"}, {"sha": "3ea8dcf46ec1b830989c45b7f5d8c3f0db81e7fa", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n                           },\n                           explicit_self: borrowed_explicit_self(),\n                           args: vec![(Ptr(Box::new(Literal(arg)),\n-                                         Borrowed(None, Mutability::Mutable)), \"state\")],\n+                                         Borrowed(None, Mutability::Mut)), \"state\")],\n                           ret_ty: nil_ty(),\n                           attributes: vec![],\n                           is_unsafe: false,"}, {"sha": "1ea202f630b620dccf348934dd79dcdeae3ccdbc", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -31,7 +31,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                                                      cx.ty_ident(sp,\n                                                                  Ident::new(sym::str, sp)),\n                                                      Some(lt),\n-                                                     ast::Mutability::Immutable))],\n+                                                     ast::Mutability::Not))],\n                                      ))\n         }\n         Ok(s) => {"}, {"sha": "025d3e91c8166375360226e66d9f4f5857f7eb8e", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -180,6 +180,6 @@ impl AllocFnFactory<'_, '_> {\n     fn ptr_u8(&self) -> P<Ty> {\n         let u8 = self.cx.path_ident(self.span, Ident::new(sym::u8, self.span));\n         let ty_u8 = self.cx.ty_path(u8);\n-        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n+        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mut)\n     }\n }"}, {"sha": "bcc38c8644a0902628d66b5f1001ba842b969497", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -415,8 +415,8 @@ fn mk_decls(\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,\n                     vec![proc_macro, bridge, client, proc_macro_ty])))),\n-            None, ast::Mutability::Immutable),\n-        ast::Mutability::Immutable,\n+            None, ast::Mutability::Not),\n+        ast::Mutability::Not,\n         cx.expr_vec_slice(span, decls),\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);"}, {"sha": "0c050e314133e49e84865c08ff8abf02568a683f", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0bf3afc96246ddefd3bcecc77c62bed1f00f14e/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=c0bf3afc96246ddefd3bcecc77c62bed1f00f14e", "patch": "@@ -141,7 +141,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             15 => {\n                 iter_exprs(\n                     depth - 1,\n-                    &mut |e| g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Immutable, e)),\n+                    &mut |e| g(ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, e)),\n                 );\n             },\n             16 => {"}]}