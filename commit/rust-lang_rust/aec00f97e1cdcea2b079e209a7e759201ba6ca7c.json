{"sha": "aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzAwZjk3ZTFjZGNlYTJiMDc5ZTIwOWE3ZTc1OTIwMWJhNmNhN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-17T07:49:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-17T07:49:25Z"}, "message": "Auto merge of #51466 - joshlf:ref-split, r=dtolnay\n\nAdd Ref/RefMut map_split method\n\nAs proposed [here](https://internals.rust-lang.org/t/make-refcell-support-slice-splitting/7707).\n\nTLDR: Add a `map_split` method that allows multiple `RefMut`s to exist simultaneously so long as they refer to non-overlapping regions of the original `RefCell`. This is useful for things like the slice `split_at_mut` method.", "tree": {"sha": "4ed19581adc5d794890fbf515848d2432b96a559", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ed19581adc5d794890fbf515848d2432b96a559"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "html_url": "https://github.com/rust-lang/rust/commit/aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f8f4903f73a21d7f408870551c08acd051abeb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f8f4903f73a21d7f408870551c08acd051abeb0", "html_url": "https://github.com/rust-lang/rust/commit/0f8f4903f73a21d7f408870551c08acd051abeb0"}, {"sha": "2a999b4b525ed8b4f735e233cc065b292d3eeb03", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a999b4b525ed8b4f735e233cc065b292d3eeb03", "html_url": "https://github.com/rust-lang/rust/commit/2a999b4b525ed8b4f735e233cc065b292d3eeb03"}], "stats": {"total": 204, "additions": 185, "deletions": 19}, "files": [{"sha": "dd8fce17cff903709409e3886d6d73626dcbccc0", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 126, "deletions": 19, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "patch": "@@ -570,11 +570,20 @@ impl Display for BorrowMutError {\n     }\n }\n \n-// Values [1, MAX-1] represent the number of `Ref` active\n-// (will not outgrow its range since `usize` is the size of the address space)\n+// Values [1, MIN_WRITING-1] represent the number of `Ref` active. Values in\n+// [MIN_WRITING, MAX-1] represent the number of `RefMut` active. Multiple\n+// `RefMut`s can only be active at a time if they refer to distinct,\n+// nonoverlapping components of a `RefCell` (e.g., different ranges of a slice).\n+//\n+// `Ref` and `RefMut` are both two words in size, and so there will likely never\n+// be enough `Ref`s or `RefMut`s in existence to overflow half of the `usize`\n+// range. Thus, a `BorrowFlag` will probably never overflow. However, this is\n+// not a guarantee, as a pathological program could repeatedly create and then\n+// mem::forget `Ref`s or `RefMut`s. Thus, all code must explicitly check for\n+// overflow in order to avoid unsafety.\n type BorrowFlag = usize;\n const UNUSED: BorrowFlag = 0;\n-const WRITING: BorrowFlag = !0;\n+const MIN_WRITING: BorrowFlag = (!0)/2 + 1; // 0b1000...\n \n impl<T> RefCell<T> {\n     /// Creates a new `RefCell` containing `value`.\n@@ -775,8 +784,9 @@ impl<T: ?Sized> RefCell<T> {\n \n     /// Mutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n+    /// The borrow lasts until the returned `RefMut` or all `RefMut`s derived\n+    /// from it exit scope. The value cannot be borrowed while this borrow is\n+    /// active.\n     ///\n     /// # Panics\n     ///\n@@ -818,8 +828,9 @@ impl<T: ?Sized> RefCell<T> {\n \n     /// Mutably borrows the wrapped value, returning an error if the value is currently borrowed.\n     ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value cannot be borrowed\n-    /// while this borrow is active.\n+    /// The borrow lasts until the returned `RefMut` or all `RefMut`s derived\n+    /// from it exit scope. The value cannot be borrowed while this borrow is\n+    /// active.\n     ///\n     /// This is the non-panicking variant of [`borrow_mut`](#method.borrow_mut).\n     ///\n@@ -1010,12 +1021,15 @@ struct BorrowRef<'b> {\n impl<'b> BorrowRef<'b> {\n     #[inline]\n     fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {\n-        match borrow.get() {\n-            WRITING => None,\n-            b => {\n-                borrow.set(b + 1);\n-                Some(BorrowRef { borrow: borrow })\n-            },\n+        let b = borrow.get();\n+        if b >= MIN_WRITING {\n+            None\n+        } else {\n+            // Prevent the borrow counter from overflowing into\n+            // a writing borrow.\n+            assert!(b < MIN_WRITING - 1);\n+            borrow.set(b + 1);\n+            Some(BorrowRef { borrow })\n         }\n     }\n }\n@@ -1024,7 +1038,7 @@ impl<'b> Drop for BorrowRef<'b> {\n     #[inline]\n     fn drop(&mut self) {\n         let borrow = self.borrow.get();\n-        debug_assert!(borrow != WRITING && borrow != UNUSED);\n+        debug_assert!(borrow < MIN_WRITING && borrow != UNUSED);\n         self.borrow.set(borrow - 1);\n     }\n }\n@@ -1036,8 +1050,9 @@ impl<'b> Clone for BorrowRef<'b> {\n         // is not set to WRITING.\n         let borrow = self.borrow.get();\n         debug_assert!(borrow != UNUSED);\n-        // Prevent the borrow counter from overflowing.\n-        assert!(borrow != WRITING);\n+        // Prevent the borrow counter from overflowing into\n+        // a writing borrow.\n+        assert!(borrow < MIN_WRITING - 1);\n         self.borrow.set(borrow + 1);\n         BorrowRef { borrow: self.borrow }\n     }\n@@ -1109,6 +1124,37 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n             borrow: orig.borrow,\n         }\n     }\n+\n+    /// Split a `Ref` into multiple `Ref`s for different components of the\n+    /// borrowed data.\n+    ///\n+    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::map_split(...)`. A method would interfere with methods of the same\n+    /// name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(refcell_map_split)]\n+    /// use std::cell::{Ref, RefCell};\n+    ///\n+    /// let cell = RefCell::new([1, 2, 3, 4]);\n+    /// let borrow = cell.borrow();\n+    /// let (begin, end) = Ref::map_split(borrow, |slice| slice.split_at(2));\n+    /// assert_eq!(*begin, [1, 2]);\n+    /// assert_eq!(*end, [3, 4]);\n+    /// ```\n+    #[unstable(feature = \"refcell_map_split\", issue = \"51476\")]\n+    #[inline]\n+    pub fn map_split<U: ?Sized, V: ?Sized, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>)\n+        where F: FnOnce(&T) -> (&U, &V)\n+    {\n+        let (a, b) = f(orig.value);\n+        let borrow = orig.borrow.clone();\n+        (Ref { value: a, borrow }, Ref { value: b, borrow: orig.borrow })\n+    }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n@@ -1157,6 +1203,44 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n             borrow: borrow,\n         }\n     }\n+\n+    /// Split a `RefMut` into multiple `RefMut`s for different components of the\n+    /// borrowed data.\n+    ///\n+    /// The underlying `RefCell` will remain mutably borrowed until both\n+    /// returned `RefMut`s go out of scope.\n+    ///\n+    /// The `RefCell` is already mutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::map_split(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(refcell_map_split)]\n+    /// use std::cell::{RefCell, RefMut};\n+    ///\n+    /// let cell = RefCell::new([1, 2, 3, 4]);\n+    /// let borrow = cell.borrow_mut();\n+    /// let (mut begin, mut end) = RefMut::map_split(borrow, |slice| slice.split_at_mut(2));\n+    /// assert_eq!(*begin, [1, 2]);\n+    /// assert_eq!(*end, [3, 4]);\n+    /// begin.copy_from_slice(&[4, 3]);\n+    /// end.copy_from_slice(&[2, 1]);\n+    /// ```\n+    #[unstable(feature = \"refcell_map_split\", issue = \"51476\")]\n+    #[inline]\n+    pub fn map_split<U: ?Sized, V: ?Sized, F>(\n+        orig: RefMut<'b, T>, f: F\n+    ) -> (RefMut<'b, U>, RefMut<'b, V>)\n+        where F: FnOnce(&mut T) -> (&mut U, &mut V)\n+    {\n+        let (a, b) = f(orig.value);\n+        let borrow = orig.borrow.clone();\n+        (RefMut { value: a, borrow }, RefMut { value: b, borrow: orig.borrow })\n+    }\n }\n \n struct BorrowRefMut<'b> {\n@@ -1167,22 +1251,45 @@ impl<'b> Drop for BorrowRefMut<'b> {\n     #[inline]\n     fn drop(&mut self) {\n         let borrow = self.borrow.get();\n-        debug_assert!(borrow == WRITING);\n-        self.borrow.set(UNUSED);\n+        debug_assert!(borrow >= MIN_WRITING);\n+        self.borrow.set(if borrow == MIN_WRITING {\n+            UNUSED\n+        } else {\n+            borrow - 1\n+        });\n     }\n }\n \n impl<'b> BorrowRefMut<'b> {\n     #[inline]\n     fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {\n+        // NOTE: Unlike BorrowRefMut::clone, new is called to create the initial\n+        // mutable reference, and so there must currently be no existing\n+        // references. Thus, while clone increments the mutable refcount, here\n+        // we simply go directly from UNUSED to MIN_WRITING.\n         match borrow.get() {\n             UNUSED => {\n-                borrow.set(WRITING);\n+                borrow.set(MIN_WRITING);\n                 Some(BorrowRefMut { borrow: borrow })\n             },\n             _ => None,\n         }\n     }\n+\n+    // Clone a `BorrowRefMut`.\n+    //\n+    // This is only valid if each `BorrowRefMut` is used to track a mutable\n+    // reference to a distinct, nonoverlapping range of the original object.\n+    // This isn't in a Clone impl so that code doesn't call this implicitly.\n+    #[inline]\n+    fn clone(&self) -> BorrowRefMut<'b> {\n+        let borrow = self.borrow.get();\n+        debug_assert!(borrow >= MIN_WRITING);\n+        // Prevent the borrow counter from overflowing.\n+        assert!(borrow != !0);\n+        self.borrow.set(borrow + 1);\n+        BorrowRefMut { borrow: self.borrow }\n+    }\n }\n \n /// A wrapper type for a mutably borrowed value from a `RefCell<T>`."}, {"sha": "4b7243b9cfc79e9d66d2409220a058e0170e4ff5", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "patch": "@@ -165,6 +165,64 @@ fn ref_map_does_not_update_flag() {\n     assert!(x.try_borrow_mut().is_ok());\n }\n \n+#[test]\n+fn ref_map_split_updates_flag() {\n+    let x = RefCell::new([1, 2]);\n+    {\n+        let b1 = x.borrow();\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_err());\n+        {\n+            let (_b2, _b3) = Ref::map_split(b1, |slc| slc.split_at(1));\n+            assert!(x.try_borrow().is_ok());\n+            assert!(x.try_borrow_mut().is_err());\n+        }\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_ok());\n+    }\n+    assert!(x.try_borrow().is_ok());\n+    assert!(x.try_borrow_mut().is_ok());\n+\n+    {\n+        let b1 = x.borrow_mut();\n+        assert!(x.try_borrow().is_err());\n+        assert!(x.try_borrow_mut().is_err());\n+        {\n+            let (_b2, _b3) = RefMut::map_split(b1, |slc| slc.split_at_mut(1));\n+            assert!(x.try_borrow().is_err());\n+            assert!(x.try_borrow_mut().is_err());\n+            drop(_b2);\n+            assert!(x.try_borrow().is_err());\n+            assert!(x.try_borrow_mut().is_err());\n+        }\n+        assert!(x.try_borrow().is_ok());\n+        assert!(x.try_borrow_mut().is_ok());\n+    }\n+    assert!(x.try_borrow().is_ok());\n+    assert!(x.try_borrow_mut().is_ok());\n+}\n+\n+#[test]\n+fn ref_map_split() {\n+    let x = RefCell::new([1, 2]);\n+    let (b1, b2) = Ref::map_split(x.borrow(), |slc| slc.split_at(1));\n+    assert_eq!(*b1, [1]);\n+    assert_eq!(*b2, [2]);\n+}\n+\n+#[test]\n+fn ref_mut_map_split() {\n+    let x = RefCell::new([1, 2]);\n+    {\n+        let (mut b1, mut b2) = RefMut::map_split(x.borrow_mut(), |slc| slc.split_at_mut(1));\n+        assert_eq!(*b1, [1]);\n+        assert_eq!(*b2, [2]);\n+        b1[0] = 2;\n+        b2[0] = 1;\n+    }\n+    assert_eq!(*x.borrow(), [2, 1]);\n+}\n+\n #[test]\n fn ref_map_accessor() {\n     struct X(RefCell<(u32, char)>);"}, {"sha": "87612b7e81887ee8216c28490f5c6785520debaa", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec00f97e1cdcea2b079e209a7e759201ba6ca7c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "patch": "@@ -27,6 +27,7 @@\n #![feature(pattern)]\n #![feature(range_is_empty)]\n #![feature(raw)]\n+#![feature(refcell_map_split)]\n #![feature(refcell_replace_swap)]\n #![feature(slice_patterns)]\n #![feature(slice_rotate)]"}]}