{"sha": "ce211434a6501e88cb83462f2443db085f1557d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMjExNDM0YTY1MDFlODhjYjgzNDYyZjI0NDNkYjA4NWYxNTU3ZDM=", "commit": {"author": {"name": "Lenard Pratt", "email": "l3np27@gmail.com", "date": "2019-04-15T10:01:29Z"}, "committer": {"name": "Lenard Pratt", "email": "l3np27@gmail.com", "date": "2019-04-22T20:35:44Z"}, "message": "Added macro resolution and expansion", "tree": {"sha": "2b0b2118fa38046d7b527ea1ea81d1c01a9a8207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b0b2118fa38046d7b527ea1ea81d1c01a9a8207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce211434a6501e88cb83462f2443db085f1557d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce211434a6501e88cb83462f2443db085f1557d3", "html_url": "https://github.com/rust-lang/rust/commit/ce211434a6501e88cb83462f2443db085f1557d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce211434a6501e88cb83462f2443db085f1557d3/comments", "author": {"login": "Lapz", "id": 19998186, "node_id": "MDQ6VXNlcjE5OTk4MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/19998186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lapz", "html_url": "https://github.com/Lapz", "followers_url": "https://api.github.com/users/Lapz/followers", "following_url": "https://api.github.com/users/Lapz/following{/other_user}", "gists_url": "https://api.github.com/users/Lapz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lapz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lapz/subscriptions", "organizations_url": "https://api.github.com/users/Lapz/orgs", "repos_url": "https://api.github.com/users/Lapz/repos", "events_url": "https://api.github.com/users/Lapz/events{/privacy}", "received_events_url": "https://api.github.com/users/Lapz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lapz", "id": 19998186, "node_id": "MDQ6VXNlcjE5OTk4MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/19998186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lapz", "html_url": "https://github.com/Lapz", "followers_url": "https://api.github.com/users/Lapz/followers", "following_url": "https://api.github.com/users/Lapz/following{/other_user}", "gists_url": "https://api.github.com/users/Lapz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lapz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lapz/subscriptions", "organizations_url": "https://api.github.com/users/Lapz/orgs", "repos_url": "https://api.github.com/users/Lapz/repos", "events_url": "https://api.github.com/users/Lapz/events{/privacy}", "received_events_url": "https://api.github.com/users/Lapz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afaeb18910414166801e3ca51272cfa3661175a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/afaeb18910414166801e3ca51272cfa3661175a4", "html_url": "https://github.com/rust-lang/rust/commit/afaeb18910414166801e3ca51272cfa3661175a4"}], "stats": {"total": 245, "additions": 138, "deletions": 107}, "files": [{"sha": "1515ea411027d7f155b4d0398d9ffc9c9fb044e0", "filename": ".vscode/launch.json", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Flaunch.json?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -14,7 +14,9 @@\n         \"--disable-extensions\"\n       ],\n       \"env\": {\n-        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/debug/ra_lsp_server\"\n+        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/debug/ra_lsp_server\",\n+        \"RUST_LOG\" :\"ra_hir=debug\",\n+        \"RA_INTERNAL_MODE\":\"1\"\n       },\n       \"outFiles\": [\"${workspaceFolder}/editors/code/out/**/*.js\"],\n       \"preLaunchTask\": \"Build All\""}, {"sha": "7d52574612f3000d073c8c9c5ee76f4e2827cd1e", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 113, "deletions": 88, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -12,7 +12,7 @@ use ra_syntax::{\n use crate::{\n     Path, Name, HirDatabase, Resolver,DefWithBody, Either,\n     name::AsName,\n-    ids::MacroDefId,\n+    ids::{MacroCallLoc,HirFileId},\n     type_ref::{Mutability, TypeRef},\n };\n use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n@@ -479,7 +479,8 @@ impl Pat {\n \n // Queries\n \n-pub(crate) struct ExprCollector {\n+pub(crate) struct ExprCollector<DB> {\n+    db: DB,\n     owner: DefWithBody,\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n@@ -489,20 +490,10 @@ pub(crate) struct ExprCollector {\n     resolver: Resolver,\n }\n \n-impl ExprCollector{\n-    fn new(owner: DefWithBody,resolver:Resolver) -> Self {\n-        ExprCollector {\n-            owner,\n-            resolver,\n-            exprs: Arena::default(),\n-            pats: Arena::default(),\n-            source_map: BodySourceMap::default(),\n-            params: Vec::new(),\n-            body_expr: None,\n-           \n-        }\n-    }\n-\n+impl<'a, DB> ExprCollector<&'a DB>\n+where\n+    DB: HirDatabase,\n+{\n     fn alloc_expr(&mut self, expr: Expr, syntax_ptr: SyntaxNodePtr) -> ExprId {\n         let id = self.exprs.alloc(expr);\n         self.source_map.expr_map.insert(syntax_ptr, id);\n@@ -522,23 +513,23 @@ impl ExprCollector{\n         self.exprs.alloc(block)\n     }\n \n-    fn collect_expr(&mut self, expr: &ast::Expr,db:&impl HirDatabase) -> ExprId {\n+    fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n                 if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n                     // if let -- desugar to match\n                     let pat = self.collect_pat(pat);\n                     let match_expr =\n-                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr(),db);\n-                    let then_branch = self.collect_block_opt(e.then_branch(),db);\n+                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr());\n+                    let then_branch = self.collect_block_opt(e.then_branch());\n                     let else_branch = e\n                         .else_branch()\n                         .map(|b| match b {\n-                            ast::ElseBranch::Block(it) => self.collect_block(it,db),\n+                            ast::ElseBranch::Block(it) => self.collect_block(it),\n                             ast::ElseBranch::IfExpr(elif) => {\n                                 let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n-                                self.collect_expr(expr,db)\n+                                self.collect_expr(expr)\n                             }\n                         })\n                         .unwrap_or_else(|| self.empty_block());\n@@ -549,56 +540,56 @@ impl ExprCollector{\n                     ];\n                     self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr)\n                 } else {\n-                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()),db);\n-                    let then_branch = self.collect_block_opt(e.then_branch(),db);\n+                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n+                    let then_branch = self.collect_block_opt(e.then_branch());\n                     let else_branch = e.else_branch().map(|b| match b {\n-                        ast::ElseBranch::Block(it) => self.collect_block(it,db),\n+                        ast::ElseBranch::Block(it) => self.collect_block(it),\n                         ast::ElseBranch::IfExpr(elif) => {\n                             let expr: &ast::Expr = ast::Expr::cast(elif.syntax()).unwrap();\n-                            self.collect_expr(expr,db)\n+                            self.collect_expr(expr)\n                         }\n                     });\n                     self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n                 }\n             }\n-            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block(),db),\n+            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n             ast::ExprKind::LoopExpr(e) => {\n-                let body = self.collect_block_opt(e.loop_body(),db);\n+                let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n             ast::ExprKind::WhileExpr(e) => {\n                 let condition = if let Some(condition) = e.condition() {\n                     if condition.pat().is_none() {\n-                        self.collect_expr_opt(condition.expr(),db)\n+                        self.collect_expr_opt(condition.expr())\n                     } else {\n                         // FIXME handle while let\n                         return self.alloc_expr(Expr::Missing, syntax_ptr);\n                     }\n                 } else {\n                     self.exprs.alloc(Expr::Missing)\n                 };\n-                let body = self.collect_block_opt(e.loop_body(),db);\n+                let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n             ast::ExprKind::ForExpr(e) => {\n-                let iterable = self.collect_expr_opt(e.iterable(),db);\n+                let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body(),db);\n+                let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n             }\n             ast::ExprKind::CallExpr(e) => {\n-                let callee = self.collect_expr_opt(e.expr(),db);\n+                let callee = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e,db)).collect()\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n                 } else {\n                     Vec::new()\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n             ast::ExprKind::MethodCallExpr(e) => {\n-                let receiver = self.collect_expr_opt(e.expr(),db);\n+                let receiver = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().map(|e| self.collect_expr(e,db)).collect()\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n                 } else {\n                     Vec::new()\n                 };\n@@ -610,17 +601,17 @@ impl ExprCollector{\n                 )\n             }\n             ast::ExprKind::MatchExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr(),db);\n+                let expr = self.collect_expr_opt(e.expr());\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n                         .arms()\n                         .map(|arm| MatchArm {\n                             pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n-                            expr: self.collect_expr_opt(arm.expr(),db),\n+                            expr: self.collect_expr_opt(arm.expr()),\n                             guard: arm\n                                 .guard()\n                                 .and_then(|guard| guard.expr())\n-                                .map(|e| self.collect_expr(e,db)),\n+                                .map(|e| self.collect_expr(e)),\n                         })\n                         .collect()\n                 } else {\n@@ -638,17 +629,17 @@ impl ExprCollector{\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n             ast::ExprKind::BreakExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e,db));\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n             }\n             ast::ExprKind::ParenExpr(e) => {\n-                let inner = self.collect_expr_opt(e.expr(),db);\n+                let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 self.source_map.expr_map.insert(syntax_ptr, inner);\n                 inner\n             }\n             ast::ExprKind::ReturnExpr(e) => {\n-                let expr = e.expr().map(|e| self.collect_expr(e,db));\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::ExprKind::StructLit(e) => {\n@@ -663,7 +654,7 @@ impl ExprCollector{\n                                 .map(|nr| nr.as_name())\n                                 .unwrap_or_else(Name::missing),\n                             expr: if let Some(e) = field.expr() {\n-                                self.collect_expr(e,db)\n+                                self.collect_expr(e)\n                             } else if let Some(nr) = field.name_ref() {\n                                 // field shorthand\n                                 let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n@@ -682,37 +673,37 @@ impl ExprCollector{\n                 } else {\n                     Vec::new()\n                 };\n-                let spread = e.spread().map(|s| self.collect_expr(s,db));\n+                let spread = e.spread().map(|s| self.collect_expr(s));\n                 let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n                     self.source_map.field_map.insert((res, i), ptr);\n                 }\n                 res\n             }\n             ast::ExprKind::FieldExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr(),db);\n+                let expr = self.collect_expr_opt(e.expr());\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n             ast::ExprKind::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr(),db);\n+                let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n             ast::ExprKind::CastExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr(),db);\n+                let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::ExprKind::RefExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr(),db);\n+                let expr = self.collect_expr_opt(e.expr());\n                 let mutability = Mutability::from_mutable(e.is_mut());\n                 self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n             }\n             ast::ExprKind::PrefixExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr(),db);\n+                let expr = self.collect_expr_opt(e.expr());\n                 if let Some(op) = e.op_kind() {\n                     self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n                 } else {\n@@ -730,17 +721,17 @@ impl ExprCollector{\n                         arg_types.push(type_ref);\n                     }\n                 }\n-                let body = self.collect_expr_opt(e.body(),db);\n+                let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n             }\n             ast::ExprKind::BinExpr(e) => {\n-                let lhs = self.collect_expr_opt(e.lhs(),db);\n-                let rhs = self.collect_expr_opt(e.rhs(),db);\n+                let lhs = self.collect_expr_opt(e.lhs());\n+                let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op_kind();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::ExprKind::TupleExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr,db)).collect();\n+                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n \n@@ -749,12 +740,12 @@ impl ExprCollector{\n \n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr,db)).collect();\n+                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n                         self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n-                        let initializer = self.collect_expr_opt(initializer,db);\n-                        let repeat = self.collect_expr_opt(repeat,db);\n+                        let initializer = self.collect_expr_opt(initializer);\n+                        let repeat = self.collect_expr_opt(repeat);\n                         self.alloc_expr(\n                             Expr::Array(Array::Repeat { initializer, repeat }),\n                             syntax_ptr,\n@@ -799,52 +790,79 @@ impl ExprCollector{\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::MacroCall(e) => {\n-\n-                let name = e.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-\n-                let res = self.resolver.resolve_name(db,&name);\n-\n-                // match res  {\n-\n-                // }\n-                \n-                // let resolver = Resolver\n-\n-                self.alloc_expr(Expr::Missing, syntax_ptr)\n-            },\n+                // very hacky.TODO change to use the macro resolution\n+                let name = e\n+                    .path()\n+                    .and_then(Path::from_ast)\n+                    .and_then(|path| path.expand_macro_expr())\n+                    .unwrap_or_else(Name::missing);\n+\n+                if let Some(macro_id) = self.resolver.resolve_macro_call(&name) {\n+                    if let Some((module, _)) = self.resolver.module() {\n+                        // we do this to get the ast_id for the macro call\n+                        // if we used the ast_id from the macro_id variable\n+                        // it gives us the ast_id of the defenition site\n+                        let module = module.mk_module(module.root());\n+                        let hir_file_id = module.definition_source(self.db).0;\n+                        let ast_id =\n+                            self.db.ast_id_map(hir_file_id).ast_id(e).with_file_id(hir_file_id);\n+\n+                        let call_loc = MacroCallLoc { def: *macro_id, ast_id };\n+                        let call_id = call_loc.id(self.db);\n+                        let file_id: HirFileId = call_id.into();\n+\n+                        log::debug!(\n+                            \"expanded macro ast {}\",\n+                            self.db.hir_parse(file_id).syntax().debug_dump()\n+                        );\n+\n+                        self.db\n+                            .hir_parse(file_id)\n+                            .syntax()\n+                            .descendants()\n+                            .find_map(ast::Expr::cast)\n+                            .map(|expr| self.collect_expr(expr))\n+                            .unwrap_or(self.alloc_expr(Expr::Missing, syntax_ptr))\n+                    } else {\n+                        self.alloc_expr(Expr::Missing, syntax_ptr)\n+                    }\n+                } else {\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                }\n+            }\n         }\n     }\n \n-    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>,db:&impl HirDatabase) -> ExprId {\n+    fn collect_expr_opt(&mut self, expr: Option<&ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n-            self.collect_expr(expr,db)\n+            self.collect_expr(expr)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n     }\n \n-    fn collect_block(&mut self, block: &ast::Block,db:&impl HirDatabase) -> ExprId {\n+    fn collect_block(&mut self, block: &ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n             .map(|s| match s.kind() {\n                 ast::StmtKind::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n-                    let initializer = stmt.initializer().map(|e| self.collect_expr(e,db));\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }\n                 ast::StmtKind::ExprStmt(stmt) => {\n-                    Statement::Expr(self.collect_expr_opt(stmt.expr(),db))\n+                    Statement::Expr(self.collect_expr_opt(stmt.expr()))\n                 }\n             })\n             .collect();\n-        let tail = block.expr().map(|e| self.collect_expr(e,db));\n+        let tail = block.expr().map(|e| self.collect_expr(e));\n         self.alloc_expr(Expr::Block { statements, tail }, SyntaxNodePtr::new(block.syntax()))\n     }\n \n-    fn collect_block_opt(&mut self, block: Option<&ast::Block>,db:&impl HirDatabase) -> ExprId {\n+    fn collect_block_opt(&mut self, block: Option<&ast::Block>) -> ExprId {\n         if let Some(block) = block {\n-            self.collect_block(block,db)\n+            self.collect_block(block)\n         } else {\n             self.exprs.alloc(Expr::Missing)\n         }\n@@ -917,17 +935,17 @@ impl ExprCollector{\n         }\n     }\n \n-    fn collect_const_body(&mut self, node: &ast::ConstDef,db:&impl HirDatabase) {\n-        let body = self.collect_expr_opt(node.body(),db);\n+    fn collect_const_body(&mut self, node: &ast::ConstDef) {\n+        let body = self.collect_expr_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_static_body(&mut self, node: &ast::StaticDef,db:&impl HirDatabase) {\n-        let body = self.collect_expr_opt(node.body(),db);\n+    fn collect_static_body(&mut self, node: &ast::StaticDef) {\n+        let body = self.collect_expr_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n-    fn collect_fn_body(&mut self, node: &ast::FnDef,db:&impl HirDatabase) {\n+    fn collect_fn_body(&mut self, node: &ast::FnDef) {\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let ptr = AstPtr::new(self_param);\n@@ -953,7 +971,7 @@ impl ExprCollector{\n             }\n         };\n \n-        let body = self.collect_block_opt(node.body(),db);\n+        let body = self.collect_block_opt(node.body());\n         self.body_expr = Some(body);\n     }\n \n@@ -973,14 +991,21 @@ pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,\n ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-\n-    let mut resolver = def.resolver(db);\n-    let mut collector = ExprCollector::new(def,resolver);\n+    let mut collector = ExprCollector {\n+        db,\n+        owner: def,\n+        resolver: def.resolver(db),\n+        exprs: Arena::default(),\n+        pats: Arena::default(),\n+        source_map: BodySourceMap::default(),\n+        params: Vec::new(),\n+        body_expr: None,\n+    };\n \n     match def {\n-        DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1,db),\n-        DefWithBody::Function(ref f) => collector.collect_fn_body(&f.source(db).1,db),\n-        DefWithBody::Static(ref s) => collector.collect_static_body(&s.source(db).1,db),\n+        DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1),\n+        DefWithBody::Function(ref f) => collector.collect_fn_body(&f.source(db).1),\n+        DefWithBody::Static(ref s) => collector.collect_static_body(&s.source(db).1),\n     }\n \n     let (body, source_map) = collector.finish();"}, {"sha": "a07624a19816c08da1215aad458eb1634eb36969", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -101,7 +101,7 @@ fn parse_macro(\n         return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n     }\n \n-    Ok(mbe::token_tree_to_ast_item_list(&tt))\n+    Some(mbe::token_tree_to_ast_item_list(&tt))\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "a450d7b843e4d603eb5e17d7ba6f6d7e1ba8248c", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -104,6 +104,7 @@ pub struct CrateDefMap {\n     /// However, do we want to put it as a global variable?\n     poison_macros: FxHashSet<MacroDefId>,\n \n+    local_macros: FxHashMap<Name, MacroDefId>,\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -209,6 +210,7 @@ impl CrateDefMap {\n                 modules,\n                 public_macros: FxHashMap::default(),\n                 poison_macros: FxHashSet::default(),\n+                local_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -270,6 +272,10 @@ impl CrateDefMap {\n         (res.resolved_def, res.segment_index)\n     }\n \n+    pub(crate) fn find_macro(&self, name: &Name) -> Option<&MacroDefId> {\n+        self.public_macros.get(name).or(self.local_macros.get(name))\n+    }\n+\n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n     fn resolve_path_fp("}, {"sha": "762a61604725b5901d331e875cebbca15ba06c38", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -131,6 +131,8 @@ where\n     fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n         if export {\n             self.def_map.public_macros.insert(name.clone(), macro_id);\n+        } else {\n+            self.def_map.local_macros.insert(name.clone(), macro_id);\n         }\n         self.global_macro_scope.insert(name, macro_id);\n     }\n@@ -517,10 +519,10 @@ where\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n-        if let Some(&macro_id) =\n-            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n+        if let Some(macro_id) =\n+            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(&name))\n         {\n-            let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n+            let macro_call_id = MacroCallLoc { def: *macro_id, ast_id }.id(self.def_collector.db);\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_id);\n             return;"}, {"sha": "1b129c752bef257114818d3eb3a47754fbf23841", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -126,6 +126,10 @@ impl Path {\n         }\n         self.segments.first().map(|s| &s.name)\n     }\n+\n+    pub fn expand_macro_expr(&self) -> Option<Name> {\n+        self.as_ident().and_then(|name| Some(name.clone()))\n+    }\n }\n \n impl GenericArgs {"}, {"sha": "1def032f952ab32ef2d1d8d06ab6aa1465359db4", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce211434a6501e88cb83462f2443db085f1557d3/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=ce211434a6501e88cb83462f2443db085f1557d3", "patch": "@@ -6,6 +6,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     ModuleDef,\n     code_model_api::Crate,\n+    MacroDefId,\n     db::HirDatabase,\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n@@ -130,6 +131,10 @@ impl Resolver {\n         resolution\n     }\n \n+    pub fn resolve_macro_call(&self, name: &Name) -> Option<&MacroDefId> {\n+        self.module().and_then(|(module, _)| module.find_macro(name))\n+    }\n+\n     /// Returns the resolved path segments\n     /// Which may be fully resolved, empty or partially resolved.\n     pub(crate) fn resolve_path_segments(&self, db: &impl HirDatabase, path: &Path) -> PathResult {\n@@ -192,7 +197,7 @@ impl Resolver {\n             .flatten()\n     }\n \n-    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    pub(crate) fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n "}, {"sha": "2106872c8318b75249e1cf6d4b60b4e65dd187c3", "filename": "crates/ra_parser/src/grammar/Untitled-1.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afaeb18910414166801e3ca51272cfa3661175a4/crates%2Fra_parser%2Fsrc%2Fgrammar%2FUntitled-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaeb18910414166801e3ca51272cfa3661175a4/crates%2Fra_parser%2Fsrc%2Fgrammar%2FUntitled-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2FUntitled-1.rs?ref=afaeb18910414166801e3ca51272cfa3661175a4", "patch": "@@ -1,13 +0,0 @@\n-macro_rules! vec {\n-    ($($item:expr),*) => \n-    {\n-        {\n-            let mut v = Vec::new();\n-            $(\n-                v.push($item);\n-            )*\n-            v\n-        }\n-    };\n-}\n-"}]}