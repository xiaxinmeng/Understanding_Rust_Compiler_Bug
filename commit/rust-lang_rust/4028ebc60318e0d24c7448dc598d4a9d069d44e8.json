{"sha": "4028ebc60318e0d24c7448dc598d4a9d069d44e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMjhlYmM2MDMxOGUwZDI0Yzc0NDhkYzU5OGQ0YTlkMDY5ZDQ0ZTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-09T04:54:13Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-11T21:16:05Z"}, "message": "Handle always-unsized structs\n\ncloses #16977", "tree": {"sha": "6ea66c3ce52cc4c447d0fe03bfeb1b0e40eb2086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ea66c3ce52cc4c447d0fe03bfeb1b0e40eb2086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4028ebc60318e0d24c7448dc598d4a9d069d44e8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4028ebc60318e0d24c7448dc598d4a9d069d44e8", "html_url": "https://github.com/rust-lang/rust/commit/4028ebc60318e0d24c7448dc598d4a9d069d44e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4028ebc60318e0d24c7448dc598d4a9d069d44e8/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc31953e7d1df1560ea43a13d19973a1374730d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc31953e7d1df1560ea43a13d19973a1374730d", "html_url": "https://github.com/rust-lang/rust/commit/1dc31953e7d1df1560ea43a13d19973a1374730d"}], "stats": {"total": 127, "additions": 117, "deletions": 10}, "files": [{"sha": "48173cc6804283d77992f9d7ba6b1fc7e22f9021", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4028ebc60318e0d24c7448dc598d4a9d069d44e8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4028ebc60318e0d24c7448dc598d4a9d069d44e8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4028ebc60318e0d24c7448dc598d4a9d069d44e8", "patch": "@@ -2992,14 +2992,13 @@ pub fn lltype_is_sized(cx: &ctxt, ty: t) -> bool {\n pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_str | ty_trait(..) | ty_vec(..) => ty,\n-        ty_struct(_, ref substs) => {\n-            // Exactly one of the type parameters must be unsized.\n-            for tp in substs.types.get_slice(subst::TypeSpace).iter() {\n-                if !type_is_sized(cx, *tp) {\n-                    return unsized_part_of_type(cx, *tp);\n-                }\n-            }\n-            fail!(\"Unsized struct type with no unsized type params? {}\", ty_to_string(cx, ty));\n+        ty_struct(def_id, ref substs) => {\n+            let unsized_fields: Vec<_> = struct_fields(cx, def_id, substs).iter()\n+                .map(|f| f.mt.ty).filter(|ty| !type_is_sized(cx, *ty)).collect();\n+            // Exactly one of the fields must be unsized.\n+            assert!(unsized_fields.len() == 1)\n+\n+            unsized_part_of_type(cx, unsized_fields[0])\n         }\n         _ => {\n             assert!(type_is_sized(cx, ty),"}, {"sha": "6eecc723431ca21ba3655f4d469722cf0baa3823", "filename": "src/test/compile-fail/unsized5.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4028ebc60318e0d24c7448dc598d4a9d069d44e8/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4028ebc60318e0d24c7448dc598d4a9d069d44e8/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=4028ebc60318e0d24c7448dc598d4a9d069d44e8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n #![feature(struct_variant)]\n \n-// Test `Sized?` types not allowed in fields.\n+// Test `Sized?` types not allowed in fields (except the last one).\n \n struct S1<Sized? X> {\n     f1: X, //~ ERROR type `f1` is dynamically sized. dynamically sized types may only appear as the\n@@ -20,7 +20,14 @@ struct S2<Sized? X> {\n     g: X, //~ ERROR type `g` is dynamically sized. dynamically sized types may only appear as the ty\n     h: int,\n }\n-\n+struct S3 {\n+    f: str, //~ ERROR type `f` is dynamically sized. dynamically sized types may only appear\n+    g: [uint]\n+}\n+struct S4 {\n+    f: str, //~ ERROR type `f` is dynamically sized. dynamically sized types may only appear\n+    g: uint\n+}\n enum E<Sized? X> {\n     V1(X, int), //~ERROR type `X` is dynamically sized. dynamically sized types may only appear as t\n     V2{f1: X, f: int}, //~ERROR type `f1` is dynamically sized. dynamically sized types may only app"}, {"sha": "e5e6ce6e76bb6dc3391a1010ae6c01852ad68944", "filename": "src/test/run-pass/unsized3.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4028ebc60318e0d24c7448dc598d4a9d069d44e8/src%2Ftest%2Frun-pass%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4028ebc60318e0d24c7448dc598d4a9d069d44e8/src%2Ftest%2Frun-pass%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized3.rs?ref=4028ebc60318e0d24c7448dc598d4a9d069d44e8", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test structs with always-unsized fields.\n+\n+use std::mem;\n+use std::raw;\n+\n+struct Foo<T> {\n+    f: [T],\n+}\n+\n+struct Bar {\n+    f1: uint,\n+    f2: [uint],\n+}\n+\n+struct Baz {\n+    f1: uint,\n+    f2: str,\n+}\n+\n+trait Tr {\n+    fn foo(&self) -> uint;\n+}\n+\n+struct St {\n+    f: uint\n+}\n+\n+impl Tr for St {\n+    fn foo(&self) -> uint {\n+        self.f\n+    }\n+}\n+\n+struct Qux<'a> {\n+    f: Tr+'a\n+}\n+\n+pub fn main() {\n+    let _: &Foo<f64>;\n+    let _: &Bar;\n+    let _: &Baz;\n+\n+    let _: Box<Foo<i32>>;\n+    let _: Box<Bar>;\n+    let _: Box<Baz>;\n+\n+    let _ = mem::size_of::<Box<Foo<u8>>>();\n+    let _ = mem::size_of::<Box<Bar>>();\n+    let _ = mem::size_of::<Box<Baz>>();\n+\n+    unsafe {\n+        struct Foo_<T> {\n+            f: [T, ..3]\n+        }\n+\n+        let data = box Foo_{f: [1i32, 2, 3] };\n+        let x: &Foo<i32> = mem::transmute(raw::Slice { len: 3, data: &*data });\n+        assert!(x.f.len() == 3);\n+        assert!(x.f[0] == 1);\n+        assert!(x.f[1] == 2);\n+        assert!(x.f[2] == 3);\n+\n+        struct Baz_ {\n+            f1: uint,\n+            f2: [u8, ..5],\n+        }\n+\n+        let data = box Baz_{ f1: 42, f2: ['a' as u8, 'b' as u8, 'c' as u8, 'd' as u8, 'e' as u8] };\n+        let x: &Baz = mem::transmute( raw::Slice { len: 5, data: &*data } );\n+        assert!(x.f1 == 42);\n+        let chs: Vec<char> = x.f2.chars().collect();\n+        assert!(chs.len() == 5);\n+        assert!(chs[0] == 'a');\n+        assert!(chs[1] == 'b');\n+        assert!(chs[2] == 'c');\n+        assert!(chs[3] == 'd');\n+        assert!(chs[4] == 'e');\n+\n+        struct Qux_ {\n+            f: St\n+        }\n+\n+        let obj: Box<St> = box St { f: 42 };\n+        let obj: &Tr = &*obj;\n+        let obj: raw::TraitObject = mem::transmute(&*obj);\n+        let data = box Qux_{ f: St { f: 234 } };\n+        let x: &Qux = mem::transmute(raw::TraitObject { vtable: obj.vtable,\n+                                                        data: mem::transmute(&*data) });\n+        assert!(x.f.foo() == 234);\n+    }\n+}"}]}