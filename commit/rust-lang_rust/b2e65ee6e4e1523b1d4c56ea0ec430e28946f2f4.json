{"sha": "b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZTY1ZWU2ZTRlMTUyM2IxZDRjNTZlYTBlYzQzMGUyODk0NmYyZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-07T00:57:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-07T00:57:08Z"}, "message": "Auto merge of #23952 - Kimundi:more_string_pattern, r=alexcrichton\n\nThis adds the missing methods and turns `str::pattern` in a user facing module, as per RFC.\r\n\r\nThis also contains some big internal refactorings:\r\n- string iterator pairs are implemented with a central macro to reduce redundancy \r\n- Moved all tests from `coretest::str` into `collectionstest::str` and left a note to prevent the two sets of tests drifting apart further.\r\n\r\nSee https://github.com/rust-lang/rust/issues/22477", "tree": {"sha": "5837198731a012961b7903cfa27fae690d4b2a5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5837198731a012961b7903cfa27fae690d4b2a5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "html_url": "https://github.com/rust-lang/rust/commit/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20", "html_url": "https://github.com/rust-lang/rust/commit/b49a5ef003fedcbb0d78aebda62ba30dfdd17a20"}, {"sha": "fbba28e246950b06a322947af0152dda5f0444c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbba28e246950b06a322947af0152dda5f0444c0", "html_url": "https://github.com/rust-lang/rust/commit/fbba28e246950b06a322947af0152dda5f0444c0"}], "stats": {"total": 2317, "additions": 1481, "deletions": 836}, "files": [{"sha": "28ba7369d52a3ffac26418334130ce0f0d5032bb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 392, "deletions": 96, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "patch": "@@ -58,6 +58,8 @@ use core::iter::{Iterator, Extend};\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n use core::str as core_str;\n+use core::str::pattern::Pattern;\n+use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n use core::convert::AsRef;\n@@ -69,14 +71,16 @@ use vec::Vec;\n use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n-pub use core::str::{Lines, LinesAny, MatchIndices, CharRange};\n-pub use core::str::{Split, SplitTerminator, SplitN};\n-pub use core::str::{RSplit, RSplitN};\n+pub use core::str::{Lines, LinesAny, CharRange};\n+pub use core::str::{Split, RSplit};\n+pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{SplitTerminator, RSplitTerminator};\n+pub use core::str::{Matches, RMatches};\n+pub use core::str::{MatchIndices, RMatchIndices};\n pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n-pub use core::str::Pattern;\n-pub use core::str::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n+pub use core::str::pattern;\n \n /*\n Section: Creating a string\n@@ -429,7 +433,8 @@ impl str {\n \n     /// Replaces all occurrences of one string with another.\n     ///\n-    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a second `&str` to\n+    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a\n+    /// second `&str` to\n     /// replace it with. If the original `&str` isn't found, no change occurs.\n     ///\n     /// # Examples\n@@ -581,94 +586,141 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search and forward/reverse search yields the same elements.\n+    /// This is true for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rsplit()` can be used.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         core_str::StrExt::split(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched\n-    /// by a pattern, returning most `count` items.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string.\n+    /// # Iterator behavior\n     ///\n-    /// # Examples\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n     ///\n-    /// Simple `&str` patterns:\n+    /// For iterating from the front, `split()` can be used.\n     ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had a little lambda\"]);\n+    /// # Examples\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"lion\", \"XtigerXleopard\"]);\n+    /// Simple patterns:\n     ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n     /// assert_eq!(v, [\"\"]);\n-    /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n     ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```rust\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".rsplit(char::is_uppercase).collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(&self[..], count, pat)\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(&self[..], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns\n+    /// like regular expressions.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty.\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _seperated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search\n+    /// and forward/reverse search yields the same elements. This is true\n+    /// for, eg, `char` but not for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rsplit_terminator()` can be used.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, [\"A\", \"B\"]);\n     ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n     /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n@@ -679,32 +731,98 @@ impl str {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by a pattern,\n-    /// starting from the end of the string.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring is\n+    /// skipped if empty.\n+    ///\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _seperated_ by a pattern.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// For iterating from the front, `split_terminator()` can be used.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi3\".rsplit_terminator(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        core_str::StrExt::rsplit(&self[..], pat)\n+        core_str::StrExt::rsplit_terminator(&self[..], pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// restricted to returning\n+    /// at most `count` items.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n+    ///\n+    /// If the pattern allows a reverse search, `rsplitn()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with closures:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by a pattern,\n@@ -714,6 +832,18 @@ impl str {\n     /// The last element returned, if any, will contain the remainder of the\n     /// string.\n     ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n+    ///\n+    /// `splitn()` can be used for splitting from the front.\n+    ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n@@ -722,11 +852,14 @@ impl str {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    ///\n     /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n     /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(2, |c: char| c.is_numeric()).collect();\n@@ -739,34 +872,166 @@ impl str {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n-    /// An iterator over the start and end indices of the disjoint matches of a `&str` within\n-    /// `self`.\n+    /// An iterator over the matches of a pattern within `self`.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows\n+    /// a reverse search\n+    /// and forward/reverse search yields the same elements. This is true\n+    /// for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rmatches()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"method got recently added\")]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        core_str::StrExt::matches(&self[..], pat)\n+    }\n+\n+    /// An iterator over the matches of a pattern within `self`, yielded in\n+    /// reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n+    ///\n+    /// For iterating from the front, `matches()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"method got recently added\")]\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatches(&self[..], pat)\n+    }\n+\n+    /// An iterator over the start and end indices of the disjoint matches\n+    /// of a pattern within `self`.\n     ///\n-    /// That is, each returned value `(start, end)` satisfies `self.slice(start, end) == sep`. For\n-    /// matches of `sep` within `self` that overlap, only the indices corresponding to the first\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first\n     /// match are returned.\n     ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search\n+    /// and forward/reverse search yields the same elements. This is true for,\n+    /// eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rmatch_indices()` can be used.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// # #![feature(collections)]\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n+    /// assert_eq!(v, [(0, 3), (6, 9), (12, 15)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1,4), (4,7)]);\n+    /// assert_eq!(v, [(1, 4), (4, 7)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n-    // NB: Right now MatchIndices yields `(usize, usize)`,\n-    // but it would be more consistent and useful to return `(usize, &str)`\n+    // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n+    // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n     pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n+    /// An iterator over the start and end indices of the disjoint matches of\n+    /// a pattern within\n+    /// `self`, yielded in reverse order.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last\n+    /// match are returned.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n+    ///\n+    /// For iterating from the front, `match_indices()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12, 15), (6, 9), (0, 3)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4, 7), (1, 4)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n+    // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n+    // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatch_indices(&self[..], pat)\n+    }\n+\n     /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n     /// This does not include the empty string after a trailing `\\n`.\n@@ -793,7 +1058,8 @@ impl str {\n         core_str::StrExt::lines(&self[..])\n     }\n \n-    /// An iterator over the lines of a string, separated by either `\\n` or `\\r\\n`.\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`.\n     ///\n     /// As with `.lines()`, this does not include an empty trailing line.\n     ///\n@@ -855,7 +1121,8 @@ impl str {\n     ///\n     /// # Unsafety\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of the entire slice as\n+    /// Caller must check both UTF-8 character boundaries and the boundaries\n+    /// of the entire slice as\n     /// well.\n     ///\n     /// # Examples\n@@ -898,13 +1165,15 @@ impl str {\n         core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n-    /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n+    /// Returns a string with all pre- and suffixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `char`, or a closure that determines\n+    /// the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n@@ -913,7 +1182,7 @@ impl str {\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n@@ -925,13 +1194,15 @@ impl str {\n         core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n-    /// Returns a string with all prefixes that match a pattern repeatedly removed.\n+    /// Returns a string with all prefixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n@@ -940,7 +1211,7 @@ impl str {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n@@ -950,21 +1221,23 @@ impl str {\n         core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n-    /// Returns a string with all suffixes that match a pattern repeatedly removed.\n+    /// Returns a string with all suffixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n@@ -976,9 +1249,11 @@ impl str {\n         core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n-    /// Check that `index`-th byte lies at the start and/or end of a UTF-8 code point sequence.\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n     ///\n-    /// The start and end of the string (when `index == self.len()`) are considered to be\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n     /// boundaries.\n     ///\n     /// # Panics\n@@ -1021,7 +1296,8 @@ impl str {\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string; this should normally be\n+    /// This example manually iterates through the characters of a string;\n+    /// this should normally be\n     /// done by `.chars()` or `.char_indices()`.\n     ///\n     /// ```\n@@ -1072,7 +1348,8 @@ impl str {\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string; this should normally be\n+    /// This example manually iterates through the characters of a string;\n+    /// this should normally be\n     /// done by `.chars().rev()` or `.char_indices()`.\n     ///\n     /// ```\n@@ -1135,7 +1412,8 @@ impl str {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n \n-    /// Given a byte position, return the `char` at that position, counting from the end.\n+    /// Given a byte position, return the `char` at that position, counting\n+    /// from the end.\n     ///\n     /// # Panics\n     ///\n@@ -1170,31 +1448,36 @@ impl str {\n         core_str::StrExt::as_bytes(&self[..])\n     }\n \n-    /// Returns the byte index of the first character of `self` that matches the pattern, if it\n+    /// Returns the byte index of the first character of `self` that matches\n+    /// the pattern, if it\n     /// exists.\n     ///\n     /// Returns `None` if it doesn't exist.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the\n+    /// split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n     ///\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n     /// ```\n     ///\n     /// Not finding the pattern:\n@@ -1210,16 +1493,18 @@ impl str {\n         core_str::StrExt::find(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the last character of `self` that matches the pattern, if it\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches the pattern, if it\n     /// exists.\n     ///\n     /// Returns `None` if it doesn't exist.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`,\n+    /// or a closure that determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n@@ -1228,12 +1513,13 @@ impl str {\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n     /// ```\n     ///\n     /// Not finding the pattern:\n@@ -1253,7 +1539,8 @@ impl str {\n \n     /// Retrieves the first character from a `&str` and returns it.\n     ///\n-    /// This does not allocate a new string; instead, it returns a slice that points one character\n+    /// This does not allocate a new string; instead, it returns a slice that\n+    /// points one character\n     /// beyond the character that was shifted.\n     ///\n     /// If the slice does not contain any characters, None is returned instead.\n@@ -1281,7 +1568,8 @@ impl str {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n \n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    /// Returns the byte offset of an inner slice relative to an enclosing\n+    /// outer slice.\n     ///\n     /// # Panics\n     ///\n@@ -1306,7 +1594,8 @@ impl str {\n \n     /// Return an unsafe pointer to the `&str`'s buffer.\n     ///\n-    /// The caller must ensure that the string outlives this pointer, and that it is not\n+    /// The caller must ensure that the string outlives this pointer, and\n+    /// that it is not\n     /// reallocated (e.g. by pushing to the string).\n     ///\n     /// # Examples\n@@ -1382,7 +1671,8 @@ impl str {\n     ///\n     /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n     ///\n-    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n+    /// If `is_extended` is true, the iterator is over the\n+    /// *extended grapheme clusters*;\n     /// otherwise, the iterator is over the *legacy grapheme clusters*.\n     /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// recommends extended grapheme cluster boundaries for general processing.\n@@ -1407,7 +1697,8 @@ impl str {\n         UnicodeStr::graphemes(&self[..], is_extended)\n     }\n \n-    /// Returns an iterator over the grapheme clusters of `self` and their byte offsets. See\n+    /// Returns an iterator over the grapheme clusters of `self` and their\n+    /// byte offsets. See\n     /// `graphemes()` for more information.\n     ///\n     /// # Examples\n@@ -1427,7 +1718,8 @@ impl str {\n \n     /// An iterator over the non-empty words of `self`.\n     ///\n-    /// A 'word' is a subsequence separated by any sequence of whitespace. Sequences of whitespace\n+    /// A 'word' is a subsequence separated by any sequence of whitespace.\n+    /// Sequences of whitespace\n     /// are collapsed, so empty \"words\" are not included.\n     ///\n     /// # Examples\n@@ -1449,11 +1741,15 @@ impl str {\n     ///\n     /// Control characters have zero width.\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n-    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is\n+    /// `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be\n     /// `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n-    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these\n+    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the\n+    /// locale is unknown.\n     #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn width(&self, is_cjk: bool) -> usize {"}, {"sha": "441d0f2c5df79e01a776d69c46f20a6b04fda2ca", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "patch": "@@ -24,7 +24,7 @@ use core::mem;\n use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::slice;\n-use core::str::Pattern;\n+use core::str::pattern::Pattern;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n "}, {"sha": "bc07c9b65a5886f49ef714432ebfa9770981f80d", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 500, "deletions": 1, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1506,6 +1506,403 @@ fn test_str_from_utf8() {\n     assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n }\n \n+#[test]\n+fn test_pattern_deref_forward() {\n+    let data = \"aabcdaa\";\n+    assert!(data.contains(\"bcd\"));\n+    assert!(data.contains(&\"bcd\"));\n+    assert!(data.contains(&\"bcd\".to_string()));\n+}\n+\n+#[test]\n+fn test_empty_match_indices() {\n+    let data = \"a\u00e4\u4e2d!\";\n+    let vec: Vec<_> = data.match_indices(\"\").collect();\n+    assert_eq!(vec, [(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n+}\n+\n+#[test]\n+fn test_bool_from_str() {\n+    assert_eq!(\"true\".parse().ok(), Some(true));\n+    assert_eq!(\"false\".parse().ok(), Some(false));\n+    assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n+}\n+\n+fn check_contains_all_substrings(s: &str) {\n+    assert!(s.contains(\"\"));\n+    for i in 0..s.len() {\n+        for j in i+1..s.len() + 1 {\n+            assert!(s.contains(&s[i..j]));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn strslice_issue_16589() {\n+    assert!(\"bananas\".contains(\"nana\"));\n+\n+    // prior to the fix for #16589, x.contains(\"abcdabcd\") returned false\n+    // test all substrings for good measure\n+    check_contains_all_substrings(\"012345678901234567890123456789bcdabcdabcd\");\n+}\n+\n+#[test]\n+fn strslice_issue_16878() {\n+    assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n+    assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n+}\n+\n+\n+#[test]\n+fn test_strslice_contains() {\n+    let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n+    check_contains_all_substrings(x);\n+}\n+\n+#[test]\n+fn test_rsplitn_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.rsplitn(4, ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let mut split: Vec<&str> = data.rsplitn(4, '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split(' ').collect();\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let split: Vec<&str> = data.split('\u00e4').collect();\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_rev_split_char_iterator_no_trailing() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.split('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+    let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+}\n+\n+#[test]\n+fn test_utf16_code_units() {\n+    use unicode::str::Utf16Encoder;\n+    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n+               [0xE9, 0xD83D, 0xDCA9])\n+}\n+\n+#[test]\n+fn starts_with_in_unicode() {\n+    assert!(!\"\u251c\u2500\u2500 Cargo.toml\".starts_with(\"# \"));\n+}\n+\n+#[test]\n+fn starts_short_long() {\n+    assert!(!\"\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\"));\n+    assert!(\"####\".starts_with(\"##\"));\n+    assert!(!\"##\u00e4\".starts_with(\"####\"));\n+    assert!(\"####\u00e4\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\u00e4\"));\n+    assert!(\"##\u00e4##\".starts_with(\"##\u00e4\"));\n+\n+    assert!(\"\".starts_with(\"\"));\n+    assert!(\"\u00e4\".starts_with(\"\"));\n+    assert!(\"#\u00e4\".starts_with(\"\"));\n+    assert!(\"##\u00e4\".starts_with(\"\"));\n+    assert!(\"\u00e4###\".starts_with(\"\"));\n+    assert!(\"#\u00e4##\".starts_with(\"\"));\n+    assert!(\"##\u00e4#\".starts_with(\"\"));\n+}\n+\n+#[test]\n+fn contains_weird_cases() {\n+    assert!(\"* \\t\".contains(' '));\n+    assert!(!\"* \\t\".contains('?'));\n+    assert!(!\"* \\t\".contains('\\u{1F4A9}'));\n+}\n+\n+#[test]\n+fn trim_ws() {\n+    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                    \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+                    \"a\");\n+    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                         \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+}\n+\n+mod pattern {\n+    use std::str::pattern::Pattern;\n+    use std::str::pattern::{Searcher, ReverseSearcher};\n+    use std::str::pattern::SearchStep::{self, Match, Reject, Done};\n+\n+    macro_rules! make_test {\n+        ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n+            mod $name {\n+                use std::str::pattern::SearchStep::{Match, Reject};\n+                use super::{cmp_search_to_vec};\n+                #[test]\n+                fn fwd() {\n+                    cmp_search_to_vec(false, $p, $h, vec![$($e),*]);\n+                }\n+                #[test]\n+                fn bwd() {\n+                    cmp_search_to_vec(true, $p, $h, vec![$($e),*]);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n+                                             right: Vec<SearchStep>)\n+    where P::Searcher: ReverseSearcher<'a>\n+    {\n+        let mut searcher = pat.into_searcher(haystack);\n+        let mut v = vec![];\n+        loop {\n+            match if !rev {searcher.next()} else {searcher.next_back()} {\n+                Match(a, b) => v.push(Match(a, b)),\n+                Reject(a, b) => v.push(Reject(a, b)),\n+                Done => break,\n+            }\n+        }\n+        if rev {\n+            v.reverse();\n+        }\n+\n+        let mut first_index = 0;\n+        let mut err = None;\n+\n+        for (i, e) in right.iter().enumerate() {\n+            match *e {\n+                Match(a, b) | Reject(a, b)\n+                if a <= b && a == first_index => {\n+                    first_index = b;\n+                }\n+                _ => {\n+                    err = Some(i);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if let Some(err) = err {\n+            panic!(\"Input skipped range at {}\", err);\n+        }\n+\n+        if first_index != haystack.len() {\n+            panic!(\"Did not cover whole input\");\n+        }\n+\n+        assert_eq!(v, right);\n+    }\n+\n+    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 3),\n+        Reject(3, 4),\n+        Match (4, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n+        Match (0, 0),\n+        Reject(0, 1),\n+        Match (1, 1),\n+        Reject(1, 2),\n+        Match (2, 2),\n+        Reject(2, 3),\n+        Match (3, 3),\n+        Reject(3, 4),\n+        Match (4, 4),\n+        Reject(4, 5),\n+        Match (5, 5),\n+        Reject(5, 6),\n+        Match (6, 6),\n+        Reject(6, 7),\n+        Match (7, 7),\n+    ]);\n+    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n+        Match (0, 0),\n+        Reject(0, 3),\n+        Match (3, 3),\n+        Reject(3, 6),\n+        Match (6, 6),\n+        Reject(6, 9),\n+        Match (9, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n+        Match(0, 0),\n+    ]);\n+    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n+    ]);\n+    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 2),\n+        Match (2, 3),\n+        Reject(3, 4),\n+        Match (4, 5),\n+        Match (5, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n+        Reject(0, 1),\n+        Reject(1, 2),\n+        Reject(2, 3),\n+    ]);\n+\n+}\n+\n+macro_rules! generate_iterator_test {\n+    {\n+        $name:ident {\n+            $(\n+                ($($arg:expr),*) -> [$($t:tt)*];\n+            )*\n+        }\n+        with $fwd:expr, $bwd:expr;\n+    } => {\n+        #[test]\n+        fn $name() {\n+            $(\n+                {\n+                    let res = vec![$($t)*];\n+\n+                    let fwd_vec: Vec<_> = ($fwd)($($arg),*).collect();\n+                    assert_eq!(fwd_vec, res);\n+\n+                    let mut bwd_vec: Vec<_> = ($bwd)($($arg),*).collect();\n+                    bwd_vec.reverse();\n+                    assert_eq!(bwd_vec, res);\n+                }\n+            )*\n+        }\n+    };\n+    {\n+        $name:ident {\n+            $(\n+                ($($arg:expr),*) -> [$($t:tt)*];\n+            )*\n+        }\n+        with $fwd:expr;\n+    } => {\n+        #[test]\n+        fn $name() {\n+            $(\n+                {\n+                    let res = vec![$($t)*];\n+\n+                    let fwd_vec: Vec<_> = ($fwd)($($arg),*).collect();\n+                    assert_eq!(fwd_vec, res);\n+                }\n+            )*\n+        }\n+    }\n+}\n+\n+generate_iterator_test! {\n+    double_ended_split {\n+        (\"foo.bar.baz\", '.') -> [\"foo\", \"bar\", \"baz\"];\n+        (\"foo::bar::baz\", \"::\") -> [\"foo\", \"bar\", \"baz\"];\n+    }\n+    with str::split, str::rsplit;\n+}\n+\n+generate_iterator_test! {\n+    double_ended_split_terminator {\n+        (\"foo;bar;baz;\", ';') -> [\"foo\", \"bar\", \"baz\"];\n+    }\n+    with str::split_terminator, str::rsplit_terminator;\n+}\n+\n+generate_iterator_test! {\n+    double_ended_matches {\n+        (\"a1b2c3\", char::is_numeric) -> [\"1\", \"2\", \"3\"];\n+    }\n+    with str::matches, str::rmatches;\n+}\n+\n+generate_iterator_test! {\n+    double_ended_match_indices {\n+        (\"a1b2c3\", char::is_numeric) -> [(1, 2), (3, 4), (5, 6)];\n+    }\n+    with str::match_indices, str::rmatch_indices;\n+}\n+\n+generate_iterator_test! {\n+    not_double_ended_splitn {\n+        (\"foo::bar::baz\", 2, \"::\") -> [\"foo\", \"bar::baz\"];\n+    }\n+    with str::splitn;\n+}\n+\n+generate_iterator_test! {\n+    not_double_ended_rsplitn {\n+        (\"foo::bar::baz\", 2, \"::\") -> [\"baz\", \"foo::bar\"];\n+    }\n+    with str::rsplitn;\n+}\n+\n mod bench {\n     use test::{Bencher, black_box};\n \n@@ -1693,4 +2090,106 @@ malesuada sollicitudin quam eu fermentum.\";\n             assert!(haystack.contains(needle));\n         })\n     }\n+\n+    macro_rules! make_test_inner {\n+        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n+            #[bench]\n+            fn $name(bencher: &mut Bencher) {\n+                let mut $s = $str;\n+                black_box(&mut $s);\n+                bencher.iter(|| $code);\n+            }\n+        }\n+    }\n+\n+    macro_rules! make_test {\n+        ($name:ident, $s:ident, $code:expr) => {\n+            mod $name {\n+                use test::Bencher;\n+                use test::black_box;\n+\n+                // Short strings: 65 bytes each\n+                make_test_inner!($s, $code, short_ascii,\n+                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n+                make_test_inner!($s, $code, short_mixed,\n+                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n+                make_test_inner!($s, $code, short_pile_of_poo,\n+                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n+                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum!\");\n+            }\n+        }\n+    }\n+\n+    make_test!(chars_count, s, s.chars().count());\n+\n+    make_test!(contains_bang_str, s, s.contains(\"!\"));\n+    make_test!(contains_bang_char, s, s.contains('!'));\n+\n+    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n+\n+    make_test!(split_a_str, s, s.split(\"a\").count());\n+\n+    make_test!(trim_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_matches(|c: char| c.is_ascii())\n+    });\n+    make_test!(trim_left_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_left_matches(|c: char| c.is_ascii())\n+    });\n+    make_test!(trim_right_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_right_matches(|c: char| c.is_ascii())\n+    });\n+\n+    make_test!(find_underscore_char, s, s.find('_'));\n+    make_test!(rfind_underscore_char, s, s.rfind('_'));\n+    make_test!(find_underscore_str, s, s.find(\"_\"));\n+\n+    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n+    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n+    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n+\n+    make_test!(split_space_char, s, s.split(' ').count());\n+    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n+\n+    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n+    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n+\n+    make_test!(split_space_str, s, s.split(\" \").count());\n+    make_test!(split_ad_str, s, s.split(\"ad\").count());\n }"}, {"sha": "5c8b6a774cd8bdd9b55506f65b40ace0ce2f335e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 447, "deletions": 284, "changes": 731, "blob_url": "https://github.com/rust-lang/rust/blob/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "patch": "@@ -17,6 +17,8 @@\n #![doc(primitive = \"str\")]\n \n use self::OldSearcher::{TwoWay, TwoWayLong};\n+use self::pattern::Pattern;\n+use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char::CharExt;\n use clone::Clone;\n@@ -34,100 +36,7 @@ use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n use usize;\n \n-pub use self::pattern::Pattern;\n-pub use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n-\n-mod pattern;\n-\n-macro_rules! delegate_iter {\n-    (exact $te:ty : $ti:ty) => {\n-        delegate_iter!{$te : $ti}\n-        impl<'a> ExactSizeIterator for $ti {\n-            #[inline]\n-            fn len(&self) -> usize {\n-                self.0.len()\n-            }\n-        }\n-    };\n-    ($te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> Iterator for $ti {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> DoubleEndedIterator for $ti {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$te> {\n-                self.0.next_back()\n-            }\n-        }\n-    };\n-    (pattern $te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> Iterator for $ti {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $ti\n-        where P::Searcher: DoubleEndedSearcher<'a> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$te> {\n-                self.0.next_back()\n-            }\n-        }\n-    };\n-    (pattern forward $te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> Iterator for $ti\n-        where P::Searcher: DoubleEndedSearcher<'a> {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-    };\n-    (pattern reverse $te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> Iterator for $ti\n-            where P::Searcher: ReverseSearcher<'a>\n-        {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-    };\n-}\n+pub mod pattern;\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n@@ -443,11 +352,9 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);\n-delegate_iter!{exact u8 : Bytes<'a>}\n \n-/// A temporary fn new type that ensures that the `Bytes` iterator\n-/// is cloneable.\n-#[derive(Copy, Clone)]\n+/// A nameable, clonable fn type\n+#[derive(Clone)]\n struct BytesDeref;\n \n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n@@ -473,58 +380,210 @@ impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n     }\n }\n \n-/// An iterator over the substrings of a string, separated by `sep`.\n-struct CharSplits<'a, P: Pattern<'a>> {\n-    /// The slice remaining to be iterated\n-    start: usize,\n-    end: usize,\n-    matcher: P::Searcher,\n-    /// Whether an empty string at the end is allowed\n-    allow_trailing_empty: bool,\n-    finished: bool,\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for Bytes<'a> {\n+    type Item = u8;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n-/// An iterator over the substrings of a string, separated by `sep`,\n-/// splitting at most `count` times.\n-struct CharSplitsN<'a, P: Pattern<'a>> {\n-    iter: CharSplits<'a, P>,\n-    /// The number of items remaining\n-    count: usize,\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Bytes<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.0.next_back()\n+    }\n }\n \n-/// An iterator over the substrings of a string, separated by a\n-/// pattern, in reverse order.\n-struct RCharSplits<'a, P: Pattern<'a>> {\n-    /// The slice remaining to be iterated\n-    start: usize,\n-    end: usize,\n-    matcher: P::Searcher,\n-    /// Whether an empty string at the end of iteration is allowed\n-    allow_final_empty: bool,\n-    finished: bool,\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> ExactSizeIterator for Bytes<'a> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n }\n \n-/// An iterator over the substrings of a string, separated by a\n-/// pattern, splitting at most `count` times, in reverse order.\n-struct RCharSplitsN<'a, P: Pattern<'a>> {\n-    iter: RCharSplits<'a, P>,\n-    /// The number of splits remaining\n-    count: usize,\n+/// This macro generates a Clone impl for string pattern API\n+/// wrapper types of the form X<'a, P>\n+macro_rules! derive_pattern_clone {\n+    (clone $t:ident with |$s:ident| $e:expr) => {\n+        impl<'a, P: Pattern<'a>> Clone for $t<'a, P>\n+            where P::Searcher: Clone\n+        {\n+            fn clone(&self) -> Self {\n+                let $s = self;\n+                $e\n+            }\n+        }\n+    }\n }\n \n-/// An iterator over the lines of a string, separated by `\\n`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Lines<'a> {\n-    inner: CharSplits<'a, char>,\n+/// This macro generates two public iterator structs\n+/// wrapping an private internal one that makes use of the `Pattern` API.\n+///\n+/// For all patterns `P: Pattern<'a>` the following items will be\n+/// generated (generics ommitted):\n+///\n+/// struct $forward_iterator($internal_iterator);\n+/// struct $reverse_iterator($internal_iterator);\n+///\n+/// impl Iterator for $forward_iterator\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// impl DoubleEndedIterator for $forward_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl Iterator for $reverse_iterator\n+///       where P::Searcher: ReverseSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl DoubleEndedIterator for $reverse_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// The internal one is defined outside the macro, and has almost the same\n+/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n+/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n+///\n+/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n+/// `Pattern` might not return the same elements, so actually implementing\n+/// `DoubleEndedIterator` for it would be incorrect.\n+/// (See the docs in `str::pattern` for more details)\n+///\n+/// However, the internal struct still represents a single ended iterator from\n+/// either end, and depending on pattern is also a valid double ended iterator,\n+/// so the two wrapper structs implement `Iterator`\n+/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n+/// to the complex impls seen above.\n+macro_rules! generate_pattern_iterators {\n+    {\n+        // Forward iterator\n+        forward:\n+            $(#[$forward_iterator_attribute:meta])*\n+            struct $forward_iterator:ident;\n+\n+        // Reverse iterator\n+        reverse:\n+            $(#[$reverse_iterator_attribute:meta])*\n+            struct $reverse_iterator:ident;\n+\n+        // Stability of all generated items\n+        stability:\n+            $(#[$common_stability_attribute:meta])*\n+\n+        // Internal almost-iterator that is being delegated to\n+        internal:\n+            $internal_iterator:ident yielding ($iterty:ty);\n+\n+        // Kind of delgation - either single ended or double ended\n+        delegate $($t:tt)*\n+    } => {\n+        $(#[$forward_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Clone for $forward_iterator<'a, P>\n+            where P::Searcher: Clone\n+        {\n+            fn clone(&self) -> Self {\n+                $forward_iterator(self.0.clone())\n+            }\n+        }\n+\n+        $(#[$reverse_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Iterator for $reverse_iterator<'a, P>\n+            where P::Searcher: ReverseSearcher<'a>\n+        {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Clone for $reverse_iterator<'a, P>\n+            where P::Searcher: Clone\n+        {\n+            fn clone(&self) -> Self {\n+                $reverse_iterator(self.0.clone())\n+            }\n+        }\n+\n+        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n+                                                $forward_iterator,\n+                                                $reverse_iterator, $iterty);\n+    };\n+    {\n+        double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $forward_iterator<'a, P>\n+            where P::Searcher: DoubleEndedSearcher<'a>\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $reverse_iterator<'a, P>\n+            where P::Searcher: DoubleEndedSearcher<'a>\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+    };\n+    {\n+        single ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {}\n }\n \n-/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LinesAny<'a> {\n-    inner: Map<Lines<'a>, fn(&str) -> &str>,\n+derive_pattern_clone!{\n+    clone SplitInternal\n+    with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n+}\n+struct SplitInternal<'a, P: Pattern<'a>> {\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n+    allow_trailing_empty: bool,\n+    finished: bool,\n }\n \n-impl<'a, P: Pattern<'a>> CharSplits<'a, P> {\n+impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n@@ -537,11 +596,6 @@ impl<'a, P: Pattern<'a>> CharSplits<'a, P> {\n             None\n         }\n     }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplits<'a, P> {\n-    type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n@@ -557,13 +611,11 @@ impl<'a, P: Pattern<'a>> Iterator for CharSplits<'a, P> {\n             None => self.get_end(),\n         }\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> DoubleEndedIterator for CharSplits<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n+    fn next_back(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         if self.finished { return None }\n \n         if !self.allow_trailing_empty {\n@@ -589,10 +641,45 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n-    type Item = &'a str;\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::split()`\n+        struct Split;\n+    reverse:\n+        /// Return type of `str::rsplit()`\n+        struct RSplit;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::split_terminator()`\n+        struct SplitTerminator;\n+    reverse:\n+        /// Return type of `str::rsplit_terminator()`\n+        struct RSplitTerminator;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n \n+derive_pattern_clone!{\n+    clone SplitNInternal\n+    with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n+}\n+struct SplitNInternal<'a, P: Pattern<'a>> {\n+    iter: SplitInternal<'a, P>,\n+    /// The number of splits remaining\n+    count: usize,\n+}\n+\n+impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         match self.count {\n@@ -601,58 +688,190 @@ impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n             _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n-}\n \n-impl<'a, P: Pattern<'a>> RCharSplits<'a, P> {\n     #[inline]\n-    fn get_remainder(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_final_empty || self.end - self.start > 0) {\n-            self.finished = true;\n-            unsafe {\n-                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n-                Some(string)\n-            }\n-        } else {\n-            None\n+    fn next_back(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        match self.count {\n+            0 => None,\n+            1 => { self.count = 0; self.iter.get_end() }\n+            _ => { self.count -= 1; self.iter.next_back() }\n         }\n     }\n }\n \n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::splitn()`\n+        struct SplitN;\n+    reverse:\n+        /// Return type of `str::rsplitn()`\n+        struct RSplitN;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitNInternal yielding (&'a str);\n+    delegate single ended;\n+}\n+\n+derive_pattern_clone!{\n+    clone MatchIndicesInternal\n+    with |s| MatchIndicesInternal(s.0.clone())\n+}\n+struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n+\n+impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        self.0.next_match()\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, usize)>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        self.0.next_match_back()\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::match_indices()`\n+        struct MatchIndices;\n+    reverse:\n+        /// Return type of `str::rmatch_indices()`\n+        struct RMatchIndices;\n+    stability:\n+        #[unstable(feature = \"core\",\n+                   reason = \"type may be removed or have its iterator impl changed\")]\n+    internal:\n+        MatchIndicesInternal yielding ((usize, usize));\n+    delegate double ended;\n+}\n+\n+derive_pattern_clone!{\n+    clone MatchesInternal\n+    with |s| MatchesInternal(s.0.clone())\n+}\n+struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n+\n+impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_match().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().slice_unchecked(a, b)\n+        })\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        self.0.next_match_back().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().slice_unchecked(a, b)\n+        })\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::matches()`\n+        struct Matches;\n+    reverse:\n+        /// Return type of `str::rmatches()`\n+        struct RMatches;\n+    stability:\n+        #[unstable(feature = \"core\", reason = \"type got recently added\")]\n+    internal:\n+        MatchesInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+/// Return type of `str::lines()`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Lines<'a>(SplitTerminator<'a, char>);\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for RCharSplits<'a, P>\n-    where P::Searcher: ReverseSearcher<'a>\n-{\n+impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n+        self.0.next()\n+    }\n \n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match_back() {\n-            Some((a, b)) => unsafe {\n-                let elt = haystack.slice_unchecked(b, self.end);\n-                self.end = a;\n-                Some(elt)\n-            },\n-            None => self.get_remainder(),\n-        }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Lines<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n+\n+/// Return type of `str::lines_any()`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct LinesAny<'a>(Map<Lines<'a>, LinesAnyMap>);\n+\n+/// A nameable, clonable fn type\n+#[derive(Clone)]\n+struct LinesAnyMap;\n+\n+impl<'a> Fn<(&'a str,)> for LinesAnyMap {\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (line,): (&'a str,)) -> &'a str {\n+        let l = line.len();\n+        if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n+        else { line }\n+    }\n+}\n+\n+impl<'a> FnMut<(&'a str,)> for LinesAnyMap {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str {\n+        Fn::call(&*self, (line,))\n+    }\n+}\n+\n+impl<'a> FnOnce<(&'a str,)> for LinesAnyMap {\n+    type Output = &'a str;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(self, (line,): (&'a str,)) -> &'a str {\n+        Fn::call(&self, (line,))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n-    where P::Searcher: ReverseSearcher<'a>\n-{\n+impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        match self.count {\n-            0 => None,\n-            1 => { self.count -= 1; self.iter.get_remainder() }\n-            _ => { self.count -= 1; self.iter.next() }\n-        }\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for LinesAny<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n     }\n }\n \n@@ -938,22 +1157,6 @@ struct OldMatchIndices<'a, 'b> {\n     searcher: OldSearcher\n }\n \n-// FIXME: #21637 Prevents a Clone impl\n-/// An iterator over the start and end indices of the matches of a\n-/// substring within a larger string\n-#[unstable(feature = \"core\", reason = \"type may be removed\")]\n-pub struct MatchIndices<'a, P: Pattern<'a>>(P::Searcher);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n-    type Item = (usize, usize);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        self.0.next_match()\n-    }\n-}\n-\n impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n     #[inline]\n     #[allow(dead_code)]\n@@ -1291,31 +1494,6 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n \n-/// Return type of `str::split`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str : Split<'a, P>}\n-\n-/// Return type of `str::split_terminator`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SplitTerminator<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n-\n-/// Return type of `str::splitn`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n-\n-/// Return type of `str::rsplit`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplit<'a, P: Pattern<'a>>(RCharSplits<'a, P>);\n-delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n-\n-/// Return type of `str::rsplitn`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P: Pattern<'a>>(RCharSplitsN<'a, P>);\n-delegate_iter!{pattern reverse &'a str : RSplitN<'a, P>}\n-\n /// Methods for string slices\n #[allow(missing_docs)]\n pub trait StrExt {\n@@ -1328,13 +1506,20 @@ pub trait StrExt {\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n-    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n     fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n+    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P>;\n+    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n+    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> usize;\n@@ -1401,7 +1586,7 @@ impl StrExt for str {\n \n     #[inline]\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        Split(CharSplits {\n+        Split(SplitInternal {\n             start: 0,\n             end: self.len(),\n             matcher: pat.into_searcher(self),\n@@ -1410,64 +1595,74 @@ impl StrExt for str {\n         })\n     }\n \n+    #[inline]\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplit(self.split(pat).0)\n+    }\n+\n     #[inline]\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        SplitN(CharSplitsN {\n+        SplitN(SplitNInternal {\n             iter: self.split(pat).0,\n             count: count,\n         })\n     }\n \n+    #[inline]\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplitN(self.splitn(count, pat).0)\n+    }\n+\n     #[inline]\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        SplitTerminator(CharSplits {\n+        SplitTerminator(SplitInternal {\n             allow_trailing_empty: false,\n             ..self.split(pat).0\n         })\n     }\n \n     #[inline]\n-    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        RSplit(RCharSplits {\n-            start: 0,\n-            end: self.len(),\n-            matcher: pat.into_searcher(self),\n-            allow_final_empty: true,\n-            finished: false,\n-        })\n+        RSplitTerminator(self.split_terminator(pat).0)\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        Matches(MatchesInternal(pat.into_searcher(self)))\n+    }\n+\n+    #[inline]\n+    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        RSplitN(RCharSplitsN {\n-            iter: self.rsplit(pat).0,\n-            count: count,\n-        })\n+        RMatches(self.matches(pat).0)\n     }\n \n     #[inline]\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        MatchIndices(pat.into_searcher(self))\n+        MatchIndices(MatchIndicesInternal(pat.into_searcher(self)))\n     }\n \n+    #[inline]\n+    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RMatchIndices(self.match_indices(pat).0)\n+    }\n     #[inline]\n     fn lines(&self) -> Lines {\n-        Lines { inner: self.split_terminator('\\n').0 }\n+        Lines(self.split_terminator('\\n'))\n     }\n \n+    #[inline]\n     fn lines_any(&self) -> LinesAny {\n-        fn f(line: &str) -> &str {\n-            let l = line.len();\n-            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n-            else { line }\n-        }\n-\n-        let f: fn(&str) -> &str = f; // coerce to fn pointer\n-        LinesAny { inner: self.lines().map(f) }\n+        LinesAny(self.lines().map(LinesAnyMap))\n     }\n \n     #[inline]\n@@ -1708,35 +1903,3 @@ impl<'a> Default for &'a str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a str { \"\" }\n }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Lines<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Lines<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for LinesAny<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for LinesAny<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n-}"}, {"sha": "9f701e1b031816692c216397f2afd8d54743548e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 140, "deletions": 79, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The string Pattern API.\n+//!\n+//! For more details, see the traits `Pattern`, `Searcher`,\n+//! `ReverseSearcher` and `DoubleEndedSearcher`.\n+\n use prelude::*;\n \n // Pattern\n@@ -223,7 +228,9 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n /// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\n pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n+/////////////////////////////////////////////////////////////////////////////\n // Impl for a CharEq wrapper\n+/////////////////////////////////////////////////////////////////////////////\n \n #[doc(hidden)]\n trait CharEq {\n@@ -261,6 +268,7 @@ impl<'a> CharEq for &'a [char] {\n \n struct CharEqPattern<C: CharEq>(C);\n \n+#[derive(Clone)]\n struct CharEqSearcher<'a, C: CharEq> {\n     char_eq: C,\n     haystack: &'a str,\n@@ -330,17 +338,27 @@ unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n \n impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n \n+/////////////////////////////////////////////////////////////////////////////\n // Impl for &str\n+/////////////////////////////////////////////////////////////////////////////\n \n // Todo: Optimize the naive implementation here\n \n+/// Associated type for `<&str as Pattern<'a>>::Searcher`.\n #[derive(Clone)]\n-struct StrSearcher<'a, 'b> {\n+pub struct StrSearcher<'a, 'b> {\n     haystack: &'a str,\n     needle: &'b str,\n     start: usize,\n     end: usize,\n-    done: bool,\n+    state: State,\n+}\n+\n+#[derive(Clone, PartialEq)]\n+enum State { Done, NotDone, Reject(usize, usize) }\n+impl State {\n+    #[inline] fn done(&self) -> bool { *self == State::Done }\n+    #[inline] fn take(&mut self) -> State { ::mem::replace(self, State::NotDone) }\n }\n \n /// Non-allocating substring search.\n@@ -357,7 +375,7 @@ impl<'a, 'b> Pattern<'a> for &'b str {\n             needle: self,\n             start: 0,\n             end: haystack.len(),\n-            done: false,\n+            state: State::NotDone,\n         }\n     }\n }\n@@ -374,8 +392,9 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n         |m: &mut StrSearcher| {\n             // Forward step for empty needle\n             let current_start = m.start;\n-            if !m.done {\n+            if !m.state.done() {\n                 m.start = m.haystack.char_range_at(current_start).next;\n+                m.state = State::Reject(current_start, m.start);\n             }\n             SearchStep::Match(current_start, current_start)\n         },\n@@ -404,8 +423,9 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n         |m: &mut StrSearcher| {\n             // Backward step for empty needle\n             let current_end = m.end;\n-            if !m.done {\n+            if !m.state.done() {\n                 m.end = m.haystack.char_range_at_reverse(current_end).next;\n+                m.state = State::Reject(m.end, current_end);\n             }\n             SearchStep::Match(current_end, current_end)\n         },\n@@ -435,137 +455,178 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n     where F: FnOnce(&mut StrSearcher) -> SearchStep,\n           G: FnOnce(&mut StrSearcher) -> SearchStep\n {\n-    if m.done {\n+    if m.state.done() {\n         SearchStep::Done\n     } else if m.needle.len() == 0 && m.start <= m.end {\n         // Case for needle == \"\"\n-        if m.start == m.end {\n-            m.done = true;\n+        if let State::Reject(a, b) = m.state.take() {\n+            SearchStep::Reject(a, b)\n+        } else {\n+            if m.start == m.end {\n+                m.state = State::Done;\n+            }\n+            empty_needle_step(&mut m)\n         }\n-        empty_needle_step(&mut m)\n     } else if m.start + m.needle.len() <= m.end {\n         // Case for needle != \"\"\n         nonempty_needle_step(&mut m)\n     } else if m.start < m.end {\n         // Remaining slice shorter than needle, reject it\n-        m.done = true;\n+        m.state = State::Done;\n         SearchStep::Reject(m.start, m.end)\n     } else {\n-        m.done = true;\n+        m.state = State::Done;\n         SearchStep::Done\n     }\n }\n \n-macro_rules! char_eq_pattern_impl {\n-    ($wrapper:ty, $wrapper_ident:ident) => {\n-        fn into_searcher(self, haystack: &'a str) -> $wrapper {\n-            $wrapper_ident(CharEqPattern(self).into_searcher(haystack))\n+/////////////////////////////////////////////////////////////////////////////\n+\n+macro_rules! pattern_methods {\n+    ($t:ty, $pmap:expr, $smap:expr) => {\n+        type Searcher = $t;\n+\n+        #[inline]\n+        fn into_searcher(self, haystack: &'a str) -> $t {\n+            ($smap)(($pmap)(self).into_searcher(haystack))\n         }\n+\n         #[inline]\n         fn is_contained_in(self, haystack: &'a str) -> bool {\n-            CharEqPattern(self).is_contained_in(haystack)\n+            ($pmap)(self).is_contained_in(haystack)\n         }\n+\n         #[inline]\n         fn is_prefix_of(self, haystack: &'a str) -> bool {\n-            CharEqPattern(self).is_prefix_of(haystack)\n+            ($pmap)(self).is_prefix_of(haystack)\n         }\n+\n         #[inline]\n         fn is_suffix_of(self, haystack: &'a str) -> bool\n-            where $wrapper: ReverseSearcher<'a>\n+            where $t: ReverseSearcher<'a>\n         {\n-            CharEqPattern(self).is_suffix_of(haystack)\n+            ($pmap)(self).is_suffix_of(haystack)\n         }\n     }\n }\n \n-// Pattern for char\n-\n-impl<'a> Pattern<'a> for char {\n-    type Searcher = CharSearcher<'a>;\n-    char_eq_pattern_impl!(CharSearcher<'a>, CharSearcher);\n+macro_rules! searcher_methods {\n+    (forward) => {\n+        #[inline]\n+        fn haystack(&self) -> &'a str {\n+            self.0.haystack()\n+        }\n+        #[inline]\n+        fn next(&mut self) -> SearchStep {\n+            self.0.next()\n+        }\n+        #[inline]\n+        fn next_match(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_match()\n+        }\n+        #[inline]\n+        fn next_reject(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_reject()\n+        }\n+    };\n+    (reverse) => {\n+        #[inline]\n+        fn next_back(&mut self) -> SearchStep {\n+            self.0.next_back()\n+        }\n+        #[inline]\n+        fn next_match_back(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_match_back()\n+        }\n+        #[inline]\n+        fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_reject_back()\n+        }\n+    }\n }\n \n-pub struct CharSearcher<'a>(CharEqSearcher<'a, char>);\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for char\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Associated type for `<char as Pattern<'a>>::Searcher`.\n+#[derive(Clone)]\n+pub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n-    #[inline]\n-    fn haystack(&self) -> &'a str { self.0.haystack() }\n-    #[inline]\n-    fn next(&mut self) -> SearchStep { self.0.next() }\n+    searcher_methods!(forward);\n }\n+\n unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+    searcher_methods!(reverse);\n }\n-impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n-// Pattern for &[char]\n+impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n-impl<'a, 'b> Pattern<'a> for &'b [char] {\n-    type Searcher = CharSliceSearcher<'a, 'b>;\n-    char_eq_pattern_impl!(CharSliceSearcher<'a, 'b>, CharSliceSearcher);\n+/// Searches for chars that are equal to a given char\n+impl<'a> Pattern<'a> for char {\n+    pattern_methods!(CharSearcher<'a>, CharEqPattern, CharSearcher);\n }\n \n-pub struct CharSliceSearcher<'a, 'b>(CharEqSearcher<'a, &'b [char]>);\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for &[char]\n+/////////////////////////////////////////////////////////////////////////////\n+\n+// Todo: Change / Remove due to ambiguity in meaning.\n+\n+/// Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n+#[derive(Clone)]\n+pub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n-    #[inline]\n-    fn haystack(&self) -> &'a str { self.0.haystack() }\n-    #[inline]\n-    fn next(&mut self) -> SearchStep { self.0.next() }\n+    searcher_methods!(forward);\n }\n+\n unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+    searcher_methods!(reverse);\n }\n-impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-// Pattern for predicates\n+impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-impl<'a, F: FnMut(char) -> bool> Pattern<'a> for F {\n-    type Searcher = CharPredSearcher<'a, F>;\n-    char_eq_pattern_impl!(CharPredSearcher<'a, F>, CharPredSearcher);\n+/// Searches for chars that are equal to any of the chars in the array\n+impl<'a, 'b> Pattern<'a> for &'b [char] {\n+    pattern_methods!(CharSliceSearcher<'a, 'b>, CharEqPattern, CharSliceSearcher);\n }\n \n-pub struct CharPredSearcher<'a, F: FnMut(char) -> bool>(CharEqSearcher<'a, F>);\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for F: FnMut(char) -> bool\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Associated type for `<F as Pattern<'a>>::Searcher`.\n+#[derive(Clone)]\n+pub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)\n+    where F: FnMut(char) -> bool;\n \n-unsafe impl<'a, F> Searcher<'a> for CharPredSearcher<'a, F>\n+unsafe impl<'a, F> Searcher<'a> for CharPredicateSearcher<'a, F>\n     where F: FnMut(char) -> bool\n {\n-    #[inline]\n-    fn haystack(&self) -> &'a str { self.0.haystack() }\n-    #[inline]\n-    fn next(&mut self) -> SearchStep { self.0.next() }\n+    searcher_methods!(forward);\n }\n-unsafe impl<'a, F> ReverseSearcher<'a> for CharPredSearcher<'a, F>\n+\n+unsafe impl<'a, F> ReverseSearcher<'a> for CharPredicateSearcher<'a, F>\n     where F: FnMut(char) -> bool\n {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+    searcher_methods!(reverse);\n }\n-impl<'a, F> DoubleEndedSearcher<'a> for CharPredSearcher<'a, F>\n-    where F: FnMut(char) -> bool\n-{}\n \n-// Pattern for &&str\n+impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F>\n+    where F: FnMut(char) -> bool {}\n \n+/// Searches for chars that match the given predicate\n+impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n+    pattern_methods!(CharPredicateSearcher<'a, F>, CharEqPattern, CharPredicateSearcher);\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for &&str\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Delegates to the `&str` impl.\n impl<'a, 'b> Pattern<'a> for &'b &'b str {\n-    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n-    #[inline]\n-    fn into_searcher(self, haystack: &'a str)\n-                     -> <&'b str as Pattern<'a>>::Searcher {\n-        (*self).into_searcher(haystack)\n-    }\n-    #[inline]\n-    fn is_contained_in(self, haystack: &'a str) -> bool {\n-        (*self).is_contained_in(haystack)\n-    }\n-    #[inline]\n-    fn is_prefix_of(self, haystack: &'a str) -> bool {\n-        (*self).is_prefix_of(haystack)\n-    }\n-    #[inline]\n-    fn is_suffix_of(self, haystack: &'a str) -> bool {\n-        (*self).is_suffix_of(haystack)\n-    }\n+    pattern_methods!(StrSearcher<'a, 'b>, |&s| s, |s| s);\n }"}, {"sha": "b7d9ba4463d98b0d9a4e2db1fee7398cfa2b99ef", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 1, "deletions": 375, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=b2e65ee6e4e1523b1d4c56ea0ec430e28946f2f4", "patch": "@@ -8,378 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[test]\n-fn test_pattern_deref_forward() {\n-    let data = \"aabcdaa\";\n-    assert!(data.contains(\"bcd\"));\n-    assert!(data.contains(&\"bcd\"));\n-    assert!(data.contains(&\"bcd\".to_string()));\n-}\n-\n-#[test]\n-fn test_empty_match_indices() {\n-    let data = \"a\u00e4\u4e2d!\";\n-    let vec: Vec<_> = data.match_indices(\"\").collect();\n-    assert_eq!(vec, [(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n-}\n-\n-#[test]\n-fn test_bool_from_str() {\n-    assert_eq!(\"true\".parse().ok(), Some(true));\n-    assert_eq!(\"false\".parse().ok(), Some(false));\n-    assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n-}\n-\n-fn check_contains_all_substrings(s: &str) {\n-    assert!(s.contains(\"\"));\n-    for i in 0..s.len() {\n-        for j in i+1..s.len() + 1 {\n-            assert!(s.contains(&s[i..j]));\n-        }\n-    }\n-}\n-\n-#[test]\n-fn strslice_issue_16589() {\n-    assert!(\"bananas\".contains(\"nana\"));\n-\n-    // prior to the fix for #16589, x.contains(\"abcdabcd\") returned false\n-    // test all substrings for good measure\n-    check_contains_all_substrings(\"012345678901234567890123456789bcdabcdabcd\");\n-}\n-\n-#[test]\n-fn strslice_issue_16878() {\n-    assert!(!\"1234567ah012345678901ah\".contains(\"hah\"));\n-    assert!(!\"00abc01234567890123456789abc\".contains(\"bcabc\"));\n-}\n-\n-\n-#[test]\n-fn test_strslice_contains() {\n-    let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n-    check_contains_all_substrings(x);\n-}\n-\n-#[test]\n-fn test_rsplitn_char_iterator() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-    let mut split: Vec<&str> = data.rsplitn(4, ' ').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == ' ').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    // Unicode\n-    let mut split: Vec<&str> = data.rsplitn(4, '\u00e4').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == '\u00e4').collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-}\n-\n-#[test]\n-fn test_split_char_iterator() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-    let split: Vec<&str> = data.split(' ').collect();\n-    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-    // Unicode\n-    let split: Vec<&str> = data.split('\u00e4').collect();\n-    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n-    rsplit.reverse();\n-    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-}\n-\n-#[test]\n-fn test_rev_split_char_iterator_no_trailing() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-    let mut split: Vec<&str> = data.split('\\n').rev().collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n-\n-    let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n-    split.reverse();\n-    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n-}\n-\n-#[test]\n-fn test_utf16_code_units() {\n-    use unicode::str::Utf16Encoder;\n-    assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n-               [0xE9, 0xD83D, 0xDCA9])\n-}\n-\n-#[test]\n-fn starts_with_in_unicode() {\n-    assert!(!\"\u251c\u2500\u2500 Cargo.toml\".starts_with(\"# \"));\n-}\n-\n-#[test]\n-fn starts_short_long() {\n-    assert!(!\"\".starts_with(\"##\"));\n-    assert!(!\"##\".starts_with(\"####\"));\n-    assert!(\"####\".starts_with(\"##\"));\n-    assert!(!\"##\u00e4\".starts_with(\"####\"));\n-    assert!(\"####\u00e4\".starts_with(\"##\"));\n-    assert!(!\"##\".starts_with(\"####\u00e4\"));\n-    assert!(\"##\u00e4##\".starts_with(\"##\u00e4\"));\n-\n-    assert!(\"\".starts_with(\"\"));\n-    assert!(\"\u00e4\".starts_with(\"\"));\n-    assert!(\"#\u00e4\".starts_with(\"\"));\n-    assert!(\"##\u00e4\".starts_with(\"\"));\n-    assert!(\"\u00e4###\".starts_with(\"\"));\n-    assert!(\"#\u00e4##\".starts_with(\"\"));\n-    assert!(\"##\u00e4#\".starts_with(\"\"));\n-}\n-\n-#[test]\n-fn contains_weird_cases() {\n-    assert!(\"* \\t\".contains(' '));\n-    assert!(!\"* \\t\".contains('?'));\n-    assert!(!\"* \\t\".contains('\\u{1F4A9}'));\n-}\n-\n-#[test]\n-fn trim_ws() {\n-    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n-                    \"a \\t  \");\n-    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n-               \" \\t  a\");\n-    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n-                    \"a\");\n-    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n-                         \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n-               \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n-               \"\");\n-}\n-\n-mod pattern {\n-    use std::str::Pattern;\n-    use std::str::{Searcher, ReverseSearcher};\n-    use std::str::SearchStep::{self, Match, Reject, Done};\n-\n-    macro_rules! make_test {\n-        ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n-            mod $name {\n-                use std::str::SearchStep::{Match, Reject};\n-                use super::{cmp_search_to_vec};\n-                #[test]\n-                fn fwd() {\n-                    cmp_search_to_vec(false, $p, $h, vec![$($e),*]);\n-                }\n-                #[test]\n-                fn bwd() {\n-                    cmp_search_to_vec(true, $p, $h, vec![$($e),*]);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n-                                             right: Vec<SearchStep>)\n-    where P::Searcher: ReverseSearcher<'a>\n-    {\n-        let mut searcher = pat.into_searcher(haystack);\n-        let mut v = vec![];\n-        loop {\n-            match if !rev {searcher.next()} else {searcher.next_back()} {\n-                Match(a, b) => v.push(Match(a, b)),\n-                Reject(a, b) => v.push(Reject(a, b)),\n-                Done => break,\n-            }\n-        }\n-        if rev {\n-            v.reverse();\n-        }\n-        assert_eq!(v, right);\n-    }\n-\n-    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n-        Reject(0, 1),\n-        Match (1, 3),\n-        Reject(3, 4),\n-        Match (4, 6),\n-        Reject(6, 7),\n-    ]);\n-    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n-        Match(0, 0),\n-        Match(1, 1),\n-        Match(2, 2),\n-        Match(3, 3),\n-        Match(4, 4),\n-        Match(5, 5),\n-        Match(6, 6),\n-        Match(7, 7),\n-    ]);\n-    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n-        Reject(0, 3),\n-        Reject(3, 6),\n-        Reject(6, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n-        Match(0, 0),\n-        Match(3, 3),\n-        Match(6, 6),\n-        Match(9, 9),\n-    ]);\n-    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n-        Match(0, 0),\n-    ]);\n-    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n-    ]);\n-    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n-        Reject(0, 1),\n-        Match (1, 2),\n-        Match (2, 3),\n-        Reject(3, 4),\n-        Match (4, 5),\n-        Match (5, 6),\n-        Reject(6, 7),\n-    ]);\n-    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n-        Reject(0, 3),\n-        Reject(3, 6),\n-        Reject(6, 9),\n-    ]);\n-    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n-        Reject(0, 1),\n-        Reject(1, 2),\n-        Reject(2, 3),\n-    ]);\n-\n-}\n-\n-mod bench {\n-    macro_rules! make_test_inner {\n-        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n-            #[bench]\n-            fn $name(bencher: &mut Bencher) {\n-                let mut $s = $str;\n-                black_box(&mut $s);\n-                bencher.iter(|| $code);\n-            }\n-        }\n-    }\n-\n-    macro_rules! make_test {\n-        ($name:ident, $s:ident, $code:expr) => {\n-            mod $name {\n-                use test::Bencher;\n-                use test::black_box;\n-\n-                // Short strings: 65 bytes each\n-                make_test_inner!($s, $code, short_ascii,\n-                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n-                make_test_inner!($s, $code, short_mixed,\n-                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n-                make_test_inner!($s, $code, short_pile_of_poo,\n-                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n-                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\n-\n-In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n-sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n-diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n-lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n-eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n-interdum. Curabitur ut nisi justo.\n-\n-Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n-mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n-lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n-est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n-felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n-ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n-feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n-Aliquam sit amet placerat lorem.\n-\n-Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n-mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n-Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n-lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n-suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n-cursus accumsan.\n-\n-Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n-feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n-vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n-leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum!\");\n-            }\n-        }\n-    }\n-\n-    make_test!(chars_count, s, s.chars().count());\n-\n-    make_test!(contains_bang_str, s, s.contains(\"!\"));\n-    make_test!(contains_bang_char, s, s.contains('!'));\n-\n-    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n-\n-    make_test!(split_a_str, s, s.split(\"a\").count());\n-\n-    make_test!(trim_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_left_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_left_matches(|c: char| c.is_ascii())\n-    });\n-    make_test!(trim_right_ascii_char, s, {\n-        use std::ascii::AsciiExt;\n-        s.trim_right_matches(|c: char| c.is_ascii())\n-    });\n-\n-    make_test!(find_underscore_char, s, s.find('_'));\n-    make_test!(rfind_underscore_char, s, s.rfind('_'));\n-    make_test!(find_underscore_str, s, s.find(\"_\"));\n-\n-    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n-    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n-    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n-\n-    make_test!(split_space_char, s, s.split(' ').count());\n-    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n-\n-    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n-    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n-\n-    make_test!(split_space_str, s, s.split(\" \").count());\n-    make_test!(split_ad_str, s, s.split(\"ad\").count());\n-}\n+// All `str` tests live in libcollectiontest::str"}]}