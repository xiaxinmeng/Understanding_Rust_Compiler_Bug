{"sha": "80524d3ad37665ef81582f3af4ac1721228a74c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNTI0ZDNhZDM3NjY1ZWY4MTU4MmYzYWY0YWMxNzIxMjI4YTc0YzA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T01:51:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T02:12:35Z"}, "message": "std: Demode test", "tree": {"sha": "67519fd456c339e6da0e37f0d2ea63fdd88e60ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67519fd456c339e6da0e37f0d2ea63fdd88e60ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80524d3ad37665ef81582f3af4ac1721228a74c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80524d3ad37665ef81582f3af4ac1721228a74c0", "html_url": "https://github.com/rust-lang/rust/commit/80524d3ad37665ef81582f3af4ac1721228a74c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80524d3ad37665ef81582f3af4ac1721228a74c0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c946f65d41550168da1d9d5fa97c93d053eed476", "url": "https://api.github.com/repos/rust-lang/rust/commits/c946f65d41550168da1d9d5fa97c93d053eed476", "html_url": "https://github.com/rust-lang/rust/commit/c946f65d41550168da1d9d5fa97c93d053eed476"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "6bb0f6cd02afb2988bba67fe92ac3db672c51e95", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80524d3ad37665ef81582f3af4ac1721228a74c0/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80524d3ad37665ef81582f3af4ac1721228a74c0/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=80524d3ad37665ef81582f3af4ac1721228a74c0", "patch": "@@ -114,7 +114,7 @@ fn mode_str(mode: mode) -> ~str {\n fn run_tests(config: config) {\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n-    let res = test::run_tests_console(opts, tests);\n+    let res = test::run_tests_console(&opts, tests);\n     if !res { fail ~\"Some tests failed\"; }\n }\n "}, {"sha": "268799dbaea8e51a987e33da4a05e34d1111f9da", "filename": "src/libstd/test.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/80524d3ad37665ef81582f3af4ac1721228a74c0/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80524d3ad37665ef81582f3af4ac1721228a74c0/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=80524d3ad37665ef81582f3af4ac1721228a74c0", "patch": "@@ -5,6 +5,9 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use core::cmp::Eq;\n use either::Either;\n use result::{Ok, Err};\n@@ -52,13 +55,13 @@ type TestDesc = {\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: ~[~str], tests: ~[TestDesc]) {\n+fn test_main(args: &[~str], tests: &[TestDesc]) {\n     let opts =\n         match parse_opts(args) {\n           either::Left(o) => o,\n           either::Right(m) => fail m\n         };\n-    if !run_tests_console(opts, tests) { fail ~\"Some tests failed\"; }\n+    if !run_tests_console(&opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n type TestOpts = {filter: Option<~str>, run_ignored: bool,\n@@ -67,7 +70,7 @@ type TestOpts = {filter: Option<~str>, run_ignored: bool,\n type OptRes = Either<TestOpts, ~str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: ~[~str]) -> OptRes {\n+fn parse_opts(args: &[~str]) -> OptRes {\n     let args_ = vec::tail(args);\n     let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n     let matches =\n@@ -110,12 +113,12 @@ type ConsoleTestState =\n       mut failures: ~[TestDesc]};\n \n // A simple console test runner\n-fn run_tests_console(opts: TestOpts,\n-                     tests: ~[TestDesc]) -> bool {\n+fn run_tests_console(opts: &TestOpts,\n+                     tests: &[TestDesc]) -> bool {\n \n-    fn callback(event: TestEvent, st: ConsoleTestState) {\n+    fn callback(event: &TestEvent, st: ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n-        match event {\n+        match *event {\n           TeFiltered(filtered_tests) => {\n             st.total = vec::len(filtered_tests);\n             let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n@@ -124,7 +127,7 @@ fn run_tests_console(opts: TestOpts,\n           TeWait(test) => st.out.write_str(fmt!(\"test %s ... \", test.name)),\n           TeResult(test, result) => {\n             match st.log_out {\n-                Some(f) => write_log(f, result, test),\n+                Some(f) => write_log(f, result, &test),\n                 None => ()\n             }\n             match result {\n@@ -170,7 +173,7 @@ fn run_tests_console(opts: TestOpts,\n           mut ignored: 0u,\n           mut failures: ~[]};\n \n-    run_tests(opts, tests, |x| callback(x, st));\n+    run_tests(opts, tests, |x| callback(&x, st));\n \n     assert (st.passed + st.failed + st.ignored == st.total);\n     let success = st.failed == 0u;\n@@ -189,7 +192,7 @@ fn run_tests_console(opts: TestOpts,\n \n     return success;\n \n-    fn write_log(out: io::Writer, result: TestResult, test: TestDesc) {\n+    fn write_log(out: io::Writer, result: TestResult, test: &TestDesc) {\n         out.write_line(fmt!(\"%s %s\",\n                     match result {\n                         TrOk => ~\"ok\",\n@@ -210,7 +213,7 @@ fn run_tests_console(opts: TestOpts,\n         write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n     }\n \n-    fn write_pretty(out: io::Writer, word: ~str, color: u8, use_color: bool) {\n+    fn write_pretty(out: io::Writer, word: &str, color: u8, use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out, color);\n         }\n@@ -276,7 +279,7 @@ enum TestEvent {\n \n type MonitorMsg = (TestDesc, TestResult);\n \n-fn run_tests(opts: TestOpts, tests: ~[TestDesc],\n+fn run_tests(opts: &TestOpts, tests: &[TestDesc],\n              callback: fn@(TestEvent)) {\n \n     let mut filtered_tests = filter_tests(opts, tests);\n@@ -333,9 +336,9 @@ fn get_concurrency() -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn filter_tests(opts: TestOpts,\n-                tests: ~[TestDesc]) -> ~[TestDesc] {\n-    let mut filtered = copy tests;\n+fn filter_tests(opts: &TestOpts,\n+                tests: &[TestDesc]) -> ~[TestDesc] {\n+    let mut filtered = vec::slice(tests, 0, tests.len());\n \n     // Remove tests that don't match the test filter\n     filtered = if option::is_none(opts.filter) {\n@@ -347,21 +350,21 @@ fn filter_tests(opts: TestOpts,\n           option::None => ~\"\"\n         };\n \n-        fn filter_fn(test: TestDesc, filter_str: ~str) ->\n+        fn filter_fn(test: &TestDesc, filter_str: &str) ->\n             Option<TestDesc> {\n             if str::contains(test.name, filter_str) {\n-                return option::Some(copy test);\n+                return option::Some(copy *test);\n             } else { return option::None; }\n         }\n \n-        vec::filter_map(filtered, |x| filter_fn(x, filter_str))\n+        vec::filter_map(filtered, |x| filter_fn(&x, filter_str))\n     };\n \n     // Maybe pull out the ignored test and unignore them\n     filtered = if !opts.run_ignored {\n         move filtered\n     } else {\n-        fn filter(test: TestDesc) -> Option<TestDesc> {\n+        fn filter(test: &TestDesc) -> Option<TestDesc> {\n             if test.ignore {\n                 return option::Some({name: test.name,\n                                   testfn: copy test.testfn,\n@@ -370,7 +373,7 @@ fn filter_tests(opts: TestOpts,\n             } else { return option::None; }\n         };\n \n-        vec::filter_map(filtered, |x| filter(x))\n+        vec::filter_map(filtered, |x| filter(&x))\n     };\n \n     // Sort the tests alphabetically\n@@ -399,12 +402,12 @@ fn run_test(+test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n             result_future = Some(move r);\n         }).spawn(move testfn);\n         let task_result = future::get(&option::unwrap(move result_future));\n-        let test_result = calc_result(test, task_result == task::Success);\n+        let test_result = calc_result(&test, task_result == task::Success);\n         comm::send(monitor_ch, (copy test, test_result));\n     };\n }\n \n-fn calc_result(test: TestDesc, task_succeeded: bool) -> TestResult {\n+fn calc_result(test: &TestDesc, task_succeeded: bool) -> TestResult {\n     if task_succeeded {\n         if test.should_fail { TrFailed }\n         else { TrOk }\n@@ -514,7 +517,7 @@ mod tests {\n                ignore: true, should_fail: false},\n              {name: ~\"2\", testfn: fn~() { },\n               ignore: false, should_fail: false}];\n-        let filtered = filter_tests(opts, tests);\n+        let filtered = filter_tests(&opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n         assert (filtered[0].name == ~\"1\");\n@@ -544,7 +547,7 @@ mod tests {\n             }\n             tests\n         };\n-        let filtered = filter_tests(opts, tests);\n+        let filtered = filter_tests(&opts, tests);\n \n         let expected =\n             ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\","}]}