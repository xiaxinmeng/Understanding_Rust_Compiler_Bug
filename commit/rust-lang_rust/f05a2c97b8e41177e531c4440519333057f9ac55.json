{"sha": "f05a2c97b8e41177e531c4440519333057f9ac55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNWEyYzk3YjhlNDExNzdlNTMxYzQ0NDA1MTkzMzMwNTdmOWFjNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T08:51:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-19T08:51:34Z"}, "message": "auto merge of #15754 : jakub-/rust/diagnostics, r=alexcrichton", "tree": {"sha": "ed74f67fdc05a3da9bb5dea86cc3cbd1770daf92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed74f67fdc05a3da9bb5dea86cc3cbd1770daf92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f05a2c97b8e41177e531c4440519333057f9ac55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a2c97b8e41177e531c4440519333057f9ac55", "html_url": "https://github.com/rust-lang/rust/commit/f05a2c97b8e41177e531c4440519333057f9ac55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f05a2c97b8e41177e531c4440519333057f9ac55/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb4c3f0af287423489e54b6415452d3f7881b592", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4c3f0af287423489e54b6415452d3f7881b592", "html_url": "https://github.com/rust-lang/rust/commit/fb4c3f0af287423489e54b6415452d3f7881b592"}, {"sha": "5274e997abc9273ef259199a1036f7753246bada", "url": "https://api.github.com/repos/rust-lang/rust/commits/5274e997abc9273ef259199a1036f7753246bada", "html_url": "https://github.com/rust-lang/rust/commit/5274e997abc9273ef259199a1036f7753246bada"}], "stats": {"total": 558, "additions": 276, "deletions": 282}, "files": [{"sha": "1b806e1c257dc6805ffe2fd3beeb63e421f8e904", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -110,5 +110,68 @@ register_diagnostics!(\n     E0091,\n     E0092,\n     E0093,\n-    E0094\n+    E0094,\n+    E0095,\n+    E0096,\n+    E0097,\n+    E0098,\n+    E0099,\n+    E0100,\n+    E0101,\n+    E0102,\n+    E0103,\n+    E0104,\n+    E0105,\n+    E0106,\n+    E0107,\n+    E0108,\n+    E0109,\n+    E0110,\n+    E0111,\n+    E0112,\n+    E0113,\n+    E0114,\n+    E0115,\n+    E0116,\n+    E0117,\n+    E0118,\n+    E0119,\n+    E0120,\n+    E0121,\n+    E0122,\n+    E0123,\n+    E0124,\n+    E0125,\n+    E0126,\n+    E0127,\n+    E0128,\n+    E0129,\n+    E0130,\n+    E0131,\n+    E0132,\n+    E0133,\n+    E0134,\n+    E0135,\n+    E0136,\n+    E0137,\n+    E0138,\n+    E0139,\n+    E0140,\n+    E0141,\n+    E0142,\n+    E0143,\n+    E0144,\n+    E0145,\n+    E0146,\n+    E0147,\n+    E0148,\n+    E0149,\n+    E0150,\n+    E0151,\n+    E0152,\n+    E0153,\n+    E0154,\n+    E0155,\n+    E0156,\n+    E0157\n )"}, {"sha": "e6160038b1d8c29662a7e57268ec423730713541", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -49,10 +49,9 @@ impl<'a> EffectCheckVisitor<'a> {\n         match self.unsafe_context {\n             SafeContext => {\n                 // Report an error.\n-                self.tcx.sess.span_err(span,\n-                                  format!(\"{} requires unsafe function or \\\n-                                           block\",\n-                                          description).as_slice())\n+                span_err!(self.tcx.sess, span, E0133,\n+                          \"{} requires unsafe function or block\",\n+                          description);\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n@@ -73,14 +72,14 @@ impl<'a> EffectCheckVisitor<'a> {\n         match ty::get(base_type).sty {\n             ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n                 ty::ty_str => {\n-                    self.tcx.sess.span_err(e.span,\n-                        \"modification of string types is not allowed\");\n+                    span_err!(self.tcx.sess, e.span, E0134,\n+                              \"modification of string types is not allowed\");\n                 }\n                 _ => {}\n             },\n             ty::ty_str => {\n-                self.tcx.sess.span_err(e.span,\n-                    \"modification of string types is not allowed\");\n+                span_err!(self.tcx.sess, e.span, E0135,\n+                          \"modification of string types is not allowed\");\n             }\n             _ => {}\n         }"}, {"sha": "3debdc158fe26c0d8c64f33cb454c1f0452284bd", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -87,9 +87,8 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                             if ctxt.main_fn.is_none() {\n                                 ctxt.main_fn = Some((item.id, item.span));\n                             } else {\n-                                ctxt.session.span_err(\n-                                    item.span,\n-                                    \"multiple 'main' functions\");\n+                                span_err!(ctxt.session, item.span, E0136,\n+                                          \"multiple 'main' functions\");\n                             }\n                         } else {\n                             // This isn't main\n@@ -102,19 +101,17 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n                 if ctxt.attr_main_fn.is_none() {\n                     ctxt.attr_main_fn = Some((item.id, item.span));\n                 } else {\n-                    ctxt.session.span_err(\n-                        item.span,\n-                        \"multiple 'main' functions\");\n+                    span_err!(ctxt.session, item.span, E0137,\n+                              \"multiple functions with a #[main] attribute\");\n                 }\n             }\n \n             if attr::contains_name(item.attrs.as_slice(), \"start\") {\n                 if ctxt.start_fn.is_none() {\n                     ctxt.start_fn = Some((item.id, item.span));\n                 } else {\n-                    ctxt.session.span_err(\n-                        item.span,\n-                        \"multiple 'start' functions\");\n+                    span_err!(ctxt.session, item.span, E0138,\n+                              \"multiple 'start' functions\");\n                 }\n             }\n         }"}, {"sha": "6669147b0dcacebf70cd721a5ebaf8faa8169dfe", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -94,14 +94,12 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n \n     fn check_transmute(&self, span: Span, from: ty::t, to: ty::t) {\n         if type_size_is_affected_by_type_parameters(self.tcx, from) {\n-            self.tcx.sess.span_err(span,\n-                                   \"cannot transmute from a type that \\\n-                                    contains type parameters\");\n+            span_err!(self.tcx.sess, span, E0139,\n+                      \"cannot transmute from a type that contains type parameters\");\n         }\n         if type_size_is_affected_by_type_parameters(self.tcx, to) {\n-            self.tcx.sess.span_err(span,\n-                                   \"cannot transmute to a type that contains \\\n-                                    type parameters\");\n+            span_err!(self.tcx.sess, span, E0140,\n+                      \"cannot transmute to a type that contains type parameters\");\n         }\n \n         let restriction = TransmuteRestriction {"}, {"sha": "d2a5342c17ee86a8a83b9ae1d320a854b32dadbb", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 59, "deletions": 71, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -92,22 +92,20 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did,\n                                       subst::Substs::empty());\n         if !ty::type_is_sendable(cx.tcx, struct_ty) {\n-            cx.tcx.sess.span_err(span,\n-                                 \"cannot implement a destructor on a \\\n-                                  structure that does not satisfy Send\");\n-            cx.tcx.sess.span_note(span,\n-                                  \"use \\\"#[unsafe_destructor]\\\" on the \\\n-                                   implementation to force the compiler to \\\n-                                   allow this\");\n+            span_err!(cx.tcx.sess, span, E0125,\n+                      \"cannot implement a destructor on a \\\n+                       structure that does not satisfy Send\");\n+            span_note!(cx.tcx.sess, span,\n+                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n+                        to force the compiler to allow this\");\n         }\n     } else {\n-        cx.tcx.sess.span_err(span,\n-                             \"cannot implement a destructor on a structure \\\n-                              with type parameters\");\n-        cx.tcx.sess.span_note(span,\n-                              \"use \\\"#[unsafe_destructor]\\\" on the \\\n-                               implementation to force the compiler to \\\n-                               allow this\");\n+        span_err!(cx.tcx.sess, span, E0141,\n+                  \"cannot implement a destructor on a structure \\\n+                   with type parameters\");\n+        span_note!(cx.tcx.sess, span,\n+                   \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n+                    to force the compiler to allow this\");\n     }\n }\n \n@@ -124,14 +122,12 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n     debug!(\"checking impl with self type {}\", ty::get(self_ty).sty);\n     check_builtin_bounds(cx, self_ty, trait_def.bounds, |missing| {\n-        cx.tcx.sess.span_err(self_type.span,\n-            format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n-                    trait\",\n-                    ty_to_string(cx.tcx, self_ty),\n-                    missing.user_string(cx.tcx)).as_slice());\n-        cx.tcx.sess.span_note(self_type.span,\n-            format!(\"types implementing this trait must fulfill `{}`\",\n-                    trait_def.bounds.user_string(cx.tcx)).as_slice());\n+        span_err!(cx.tcx.sess, self_type.span, E0142,\n+                  \"the type `{}', which does not fulfill `{}`, cannot implement this trait\",\n+                  ty_to_string(cx.tcx, self_ty), missing.user_string(cx.tcx));\n+        span_note!(cx.tcx.sess, self_type.span,\n+                   \"types implementing this trait must fulfill `{}`\",\n+                   trait_def.bounds.user_string(cx.tcx));\n     });\n \n     // If this is a destructor, check kinds.\n@@ -191,10 +187,9 @@ fn with_appropriate_checker(cx: &Context,\n     }\n \n     fn check_for_bare(cx: &Context, fv: &freevar_entry) {\n-        cx.tcx.sess.span_err(\n-            fv.span,\n-            \"can't capture dynamic environment in a fn item; \\\n-            use the || { ... } closure form instead\");\n+        span_err!(cx.tcx.sess, fv.span, E0143,\n+                  \"can't capture dynamic environment in a fn item; \\\n+                   use the || {} closure form instead\", \"{ ... }\");\n     } // same check is done in resolve.rs, but shouldn't be done\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n@@ -494,12 +489,11 @@ pub fn check_typaram_bounds(cx: &Context,\n                          ty,\n                          type_param_def.bounds.builtin_bounds,\n                          |missing| {\n-        cx.tcx.sess.span_err(\n-            sp,\n-            format!(\"instantiating a type parameter with an incompatible type \\\n-                     `{}`, which does not fulfill `{}`\",\n-                    ty_to_string(cx.tcx, ty),\n-                    missing.user_string(cx.tcx)).as_slice());\n+        span_err!(cx.tcx.sess, sp, E0144,\n+                  \"instantiating a type parameter with an incompatible type \\\n+                   `{}`, which does not fulfill `{}`\",\n+                   ty_to_string(cx.tcx, ty),\n+                   missing.user_string(cx.tcx));\n     });\n }\n \n@@ -511,36 +505,32 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n         // Emit a less mysterious error message in this case.\n         match referenced_ty {\n             Some(rty) => {\n-                cx.tcx.sess.span_err(sp,\n-                format!(\"cannot implicitly borrow variable of type `{}` in a \\\n-                         bounded stack closure (implicit reference does not \\\n-                         fulfill `{}`)\",\n-                        ty_to_string(cx.tcx, rty),\n-                        missing.user_string(cx.tcx)).as_slice())\n+                span_err!(cx.tcx.sess, sp, E0145,\n+                    \"cannot implicitly borrow variable of type `{}` in a \\\n+                     bounded stack closure (implicit reference does not fulfill `{}`)\",\n+                    ty_to_string(cx.tcx, rty), missing.user_string(cx.tcx));\n             }\n             None => {\n-                cx.tcx.sess.span_err(sp,\n-                format!(\"cannot capture variable of type `{}`, which does \\\n-                         not fulfill `{}`, in a bounded closure\",\n-                        ty_to_string(cx.tcx, ty),\n-                        missing.user_string(cx.tcx)).as_slice())\n+                span_err!(cx.tcx.sess, sp, E0146,\n+                    \"cannot capture variable of type `{}`, which does \\\n+                     not fulfill `{}`, in a bounded closure\",\n+                    ty_to_string(cx.tcx, ty), missing.user_string(cx.tcx));\n             }\n         }\n-        cx.tcx.sess.span_note(\n-            sp,\n-            format!(\"this closure's environment must satisfy `{}`\",\n-                    bounds.user_string(cx.tcx)).as_slice());\n+        span_note!(cx.tcx.sess, sp,\n+            \"this closure's environment must satisfy `{}`\",\n+            bounds.user_string(cx.tcx));\n     });\n }\n \n pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n     check_builtin_bounds(cx, ty, bounds, |missing| {\n-        cx.tcx.sess.span_err(sp,\n-            format!(\"cannot pack type `{}`, which does not fulfill \\\n-                     `{}`, as a trait bounded by {}\",\n-                    ty_to_string(cx.tcx, ty), missing.user_string(cx.tcx),\n-                    bounds.user_string(cx.tcx)).as_slice());\n+        span_err!(cx.tcx.sess, sp, E0147,\n+            \"cannot pack type `{}`, which does not fulfill `{}`, as a trait bounded by {}\",\n+            ty_to_string(cx.tcx, ty),\n+            missing.user_string(cx.tcx),\n+            bounds.user_string(cx.tcx));\n     });\n }\n \n@@ -549,26 +539,26 @@ fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n            ty_to_string(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_string());\n     if ty::type_moves_by_default(cx.tcx, ty) {\n-        cx.tcx.sess.span_err(\n-            sp,\n-            format!(\"copying a value of non-copyable type `{}`\",\n-                    ty_to_string(cx.tcx, ty)).as_slice());\n-        cx.tcx.sess.span_note(sp, format!(\"{}\", reason).as_slice());\n+        span_err!(cx.tcx.sess, sp, E0148,\n+            \"copying a value of non-copyable type `{}`\",\n+            ty_to_string(cx.tcx, ty));\n+        span_note!(cx.tcx.sess, sp, \"{}\", reason.as_slice());\n     }\n }\n \n pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n-          ty::ty_param(..) => {\n-            tcx.sess.span_err(sp,\n-                format!(\"value may contain references; \\\n-                         add `'static` bound to `{}`\",\n-                        ty_to_string(tcx, ty)).as_slice());\n-          }\n-          _ => {\n-            tcx.sess.span_err(sp, \"value may contain references\");\n-          }\n+            ty::ty_param(..) => {\n+                span_err!(tcx.sess, sp, E0149,\n+                    \"value may contain references; \\\n+                     add `'static` bound to `{}`\",\n+                     ty_to_string(tcx, ty));\n+            }\n+            _ => {\n+                span_err!(tcx.sess, sp, E0150,\n+                    \"value may contain references\");\n+            }\n         }\n         false\n     } else {\n@@ -685,11 +675,9 @@ pub fn check_cast_for_escaping_regions(\n // Ensure that `ty` has a statically known size (i.e., it has the `Sized` bound).\n fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n     if !ty::type_is_sized(tcx, ty) {\n-        tcx.sess.span_err(sp,\n-                          format!(\"variable `{}` has dynamically sized type \\\n-                                   `{}`\",\n-                                  name,\n-                                  ty_to_string(tcx, ty)).as_slice());\n+        span_err!(tcx.sess, sp, E0151,\n+            \"variable `{}` has dynamically sized type `{}`\",\n+            name, ty_to_string(tcx, ty));\n     }\n }\n "}, {"sha": "9abc9226c136456ade077a9f22b1e4fbb46d43c8", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -27,6 +27,7 @@ use middle::weak_lang_items;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -122,7 +123,7 @@ impl<'a> Visitor<()> for LanguageItemCollector<'a> {\n \n                 match item_index {\n                     Some(item_index) => {\n-                        self.collect_item(item_index, local_def(item.id))\n+                        self.collect_item(item_index, local_def(item.id), item.span)\n                     }\n                     None => {}\n                 }\n@@ -147,13 +148,13 @@ impl<'a> LanguageItemCollector<'a> {\n         }\n     }\n \n-    pub fn collect_item(&mut self, item_index: uint, item_def_id: ast::DefId) {\n+    pub fn collect_item(&mut self, item_index: uint,\n+                        item_def_id: ast::DefId, span: Span) {\n         // Check for duplicates.\n         match self.items.items.get(item_index) {\n             &Some(original_def_id) if original_def_id != item_def_id => {\n-                self.session.err(format!(\"duplicate entry for `{}`\",\n-                                         LanguageItems::item_name(\n-                                             item_index)).as_slice());\n+                span_err!(self.session, span, E0152,\n+                    \"duplicate entry for `{}`\", LanguageItems::item_name(item_index));\n             }\n             &Some(_) | &None => {\n                 // OK.\n@@ -173,7 +174,7 @@ impl<'a> LanguageItemCollector<'a> {\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n                 let def_id = ast::DefId { krate: crate_number, node: node_id };\n-                self.collect_item(item_index, def_id);\n+                self.collect_item(item_index, def_id, DUMMY_SP);\n                 true\n             });\n         })"}, {"sha": "187390821109a3180ba1092554d24654d8c1fe59", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -4016,14 +4016,17 @@ impl<'a> Resolver<'a> {\n                                 this.record_def(path_id, (def, lp));\n                             }\n                             Some((DefStruct(_), _)) => {\n-                                this.session.span_err(t.span,\n-                                                      \"super-struct is defined \\\n-                                                       in a different crate\")\n+                                span_err!(this.session, t.span, E0154,\n+                                    \"super-struct is defined in a different crate\");\n                             },\n-                            Some(_) => this.session.span_err(t.span,\n-                                                             \"super-struct is not a struct type\"),\n-                            None => this.session.span_err(t.span,\n-                                                          \"super-struct could not be resolved\"),\n+                            Some(_) => {\n+                                span_err!(this.session, t.span, E0155,\n+                                    \"super-struct is not a struct type\");\n+                            }\n+                            None => {\n+                                span_err!(this.session, t.span, E0156,\n+                                    \"super-struct could not be resolved\");\n+                            }\n                         }\n                     },\n                     _ => this.session.span_bug(t.span, \"path not mapped to a TyPath\")\n@@ -4297,17 +4300,13 @@ impl<'a> Resolver<'a> {\n                             if path.segments\n                                    .iter()\n                                    .any(|s| !s.lifetimes.is_empty()) {\n-                                self.session.span_err(path.span,\n-                                                      \"lifetime parameters \\\n-                                                       are not allowed on \\\n-                                                       this type\")\n+                                span_err!(self.session, path.span, E0157,\n+                                    \"lifetime parameters are not allowed on this type\");\n                             } else if path.segments\n                                           .iter()\n                                           .any(|s| s.types.len() > 0) {\n-                                self.session.span_err(path.span,\n-                                                      \"type parameters are \\\n-                                                       not allowed on this \\\n-                                                       type\")\n+                                span_err!(self.session, path.span, E0153,\n+                                    \"type parameters are not allowed on this type\");\n                             }\n                         }\n                         None => {"}, {"sha": "de169a886cfd3beca65652b51a19e0c3c217e90f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -129,8 +129,8 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n             match rscope.anon_regions(default_span, 1) {\n                 Err(()) => {\n                     debug!(\"optional region in illegal location\");\n-                    this.tcx().sess.span_err(\n-                        default_span, \"missing lifetime specifier\");\n+                    span_err!(this.tcx().sess, default_span, E0106,\n+                        \"missing lifetime specifier\");\n                     ty::ReStatic\n                 }\n \n@@ -187,12 +187,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n             rscope.anon_regions(path.span, expected_num_region_params);\n \n         if supplied_num_region_params != 0 || anon_regions.is_err() {\n-            tcx.sess.span_err(\n-                path.span,\n-                format!(\"wrong number of lifetime parameters: \\\n-                        expected {} but found {}\",\n-                        expected_num_region_params,\n-                        supplied_num_region_params).as_slice());\n+            span_err!(tcx.sess, path.span, E0107,\n+                \"wrong number of lifetime parameters: expected {} but found {}\",\n+                expected_num_region_params, supplied_num_region_params);\n         }\n \n         match anon_regions {\n@@ -235,10 +232,10 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n \n     if supplied_ty_param_count > required_ty_param_count\n         && !this.tcx().sess.features.default_type_params.get() {\n-        this.tcx().sess.span_err(path.span, \"default type parameters are \\\n-                                             experimental and possibly buggy\");\n-        this.tcx().sess.span_note(path.span, \"add #![feature(default_type_params)] \\\n-                                              to the crate attributes to enable\");\n+        span_err!(this.tcx().sess, path.span, E0108,\n+            \"default type parameters are experimental and possibly buggy\");\n+        span_note!(this.tcx().sess, path.span,\n+            \"add #![feature(default_type_params)] to the crate attributes to enable\");\n     }\n \n     let tps = path.segments.iter().flat_map(|s| s.types.iter())\n@@ -309,16 +306,14 @@ fn check_path_args(tcx: &ty::ctxt,\n                    flags: uint) {\n     if (flags & NO_TPS) != 0u {\n         if !path.segments.iter().all(|s| s.types.is_empty()) {\n-            tcx.sess.span_err(\n-                path.span,\n+            span_err!(tcx.sess, path.span, E0109,\n                 \"type parameters are not allowed on this type\");\n         }\n     }\n \n     if (flags & NO_REGIONS) != 0u {\n         if !path.segments.last().unwrap().lifetimes.is_empty() {\n-            tcx.sess.span_err(\n-                path.span,\n+            span_err!(tcx.sess, path.span, E0110,\n                 \"region parameters are not allowed on this type\");\n         }\n     }\n@@ -359,8 +354,8 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n                             Some(ty::mk_mach_float(ft))\n                         }\n                         ast::TyStr => {\n-                            tcx.sess.span_err(ast_ty.span,\n-                                              \"bare `str` is not a type\");\n+                            span_err!(tcx.sess, ast_ty.span, E0037,\n+                                      \"bare `str` is not a type\");\n                             // return /something/ so they can at least get more errors\n                             Some(ty::mk_uniq(tcx, ty::mk_str(tcx)))\n                         }\n@@ -408,10 +403,8 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                            .iter()\n                            .flat_map(|s| s.types.iter())\n                            .count() > 1 {\n-                        this.tcx()\n-                            .sess\n-                            .span_err(path.span,\n-                                      \"`Box` has only one type parameter\")\n+                        span_err!(this.tcx().sess, path.span, E0047,\n+                                  \"`Box` has only one type parameter\");\n                     }\n \n                     for inner_ast_type in path.segments\n@@ -428,26 +421,21 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                                |typ| {\n                             match ty::get(typ).sty {\n                                 ty::ty_str => {\n-                                    this.tcx()\n-                                        .sess\n-                                        .span_err(path.span,\n-                                                  \"`Box<str>` is not a type\");\n+                                    span_err!(this.tcx().sess, path.span, E0111,\n+                                              \"`Box<str>` is not a type\");\n                                     ty::mk_err()\n                                 }\n                                 ty::ty_vec(_, None) => {\n-                                    this.tcx()\n-                                        .sess\n-                                        .span_err(path.span,\n+                                        span_err!(this.tcx().sess, path.span, E0112,\n                                                   \"`Box<[T]>` is not a type\");\n                                     ty::mk_err()\n                                 }\n                                 _ => ty::mk_uniq(this.tcx(), typ),\n                             }\n                         }))\n                     }\n-                    this.tcx().sess.span_err(path.span,\n-                                             \"not enough type parameters \\\n-                                              supplied to `Box<T>`\");\n+                    span_err!(this.tcx().sess, path.span, E0113,\n+                              \"not enough type parameters supplied to `Box<T>`\");\n                     Some(ty::mk_err())\n                 }\n                 def::DefTy(did) | def::DefStruct(did)\n@@ -456,10 +444,8 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                            .iter()\n                            .flat_map(|s| s.types.iter())\n                            .count() > 1 {\n-                        this.tcx()\n-                            .sess\n-                            .span_err(path.span,\n-                                      \"`Gc` has only one type parameter\")\n+                        span_err!(this.tcx().sess, path.span, E0048,\n+                                  \"`Gc` has only one type parameter\");\n                     }\n \n                     for inner_ast_type in path.segments\n@@ -476,17 +462,13 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n                                                |typ| {\n                             match ty::get(typ).sty {\n                                 ty::ty_str => {\n-                                    this.tcx()\n-                                        .sess\n-                                        .span_err(path.span,\n-                                                  \"`Gc<str>` is not a type\");\n+                                    span_err!(this.tcx().sess, path.span, E0114,\n+                                              \"`Gc<str>` is not a type\");\n                                     ty::mk_err()\n                                 }\n                                 ty::ty_vec(_, None) => {\n-                                    this.tcx()\n-                                        .sess\n-                                        .span_err(path.span,\n-                                                  \"`Gc<[T]>` is not a type\");\n+                                    span_err!(this.tcx().sess, path.span, E0115,\n+                                              \"`Gc<[T]>` is not a type\");\n                                     ty::mk_err()\n                                 }\n                                 _ => ty::mk_box(this.tcx(), typ),"}, {"sha": "c176054b3aed0e0d289cd3c8f767730e09d4e91e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -206,11 +206,10 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 !ty::trait_ref_contains_error(&r_exp_trait_ref)\n             {\n                 let tcx = vcx.tcx();\n-                tcx.sess.span_err(span,\n-                    format!(\"expected {}, but found {} ({})\",\n-                            ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),\n-                            ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),\n-                            ty::type_err_to_str(tcx, err)).as_slice());\n+                span_err!(tcx.sess, span, E0095, \"expected {}, but found {} ({})\",\n+                          ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),\n+                          ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),\n+                          ty::type_err_to_str(tcx, err));\n             }\n         }\n     }\n@@ -536,7 +535,8 @@ fn search_for_vtable(vcx: &VtableContext,\n         1 => return Some(found.get(0).clone()),\n         _ => {\n             if !is_early {\n-                vcx.tcx().sess.span_err(span, \"multiple applicable methods in scope\");\n+                span_err!(vcx.tcx().sess, span, E0096,\n+                          \"multiple applicable methods in scope\");\n             }\n             return Some(found.get(0).clone());\n         }\n@@ -631,9 +631,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             if !mutability_allowed(mt.mutbl, mutbl) => {\n               match ty::get(ty).sty {\n                   ty::ty_trait(..) => {\n-                      fcx.tcx()\n-                         .sess\n-                         .span_err(ex.span, \"types differ in mutability\");\n+                      span_err!(fcx.tcx().sess, ex.span, E0097, \"types differ in mutability\");\n                   }\n                   _ => {}\n               }\n@@ -709,11 +707,9 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n           (&ty::ty_uniq(ty), _) => {\n               match ty::get(ty).sty {\n                   ty::ty_trait(..) => {\n-                      fcx.ccx.tcx.sess.span_err(\n-                          ex.span,\n-                          format!(\"can only cast an boxed pointer \\\n-                                   to a boxed object, not a {}\",\n-                               ty::ty_sort_string(fcx.tcx(), src_ty)).as_slice());\n+                      span_err!(fcx.ccx.tcx.sess, ex.span, E0098,\n+                                \"can only cast an boxed pointer to a boxed object, not a {}\",\n+                                ty::ty_sort_string(fcx.tcx(), src_ty));\n                   }\n                   _ => {}\n               }\n@@ -722,11 +718,9 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n           (&ty::ty_rptr(_, ty::mt{ty, ..}), _) => {\n               match ty::get(ty).sty {\n                   ty::ty_trait(..) => {\n-                      fcx.ccx.tcx.sess.span_err(\n-                          ex.span,\n-                          format!(\"can only cast an &-pointer \\\n-                                   to an &-object, not a {}\",\n-                                  ty::ty_sort_string(fcx.tcx(), src_ty)).as_slice());\n+                      span_err!(fcx.ccx.tcx.sess, ex.span, E0099,\n+                                \"can only cast an &-pointer to an &-object, not a {}\",\n+                                ty::ty_sort_string(fcx.tcx(), src_ty));\n                   }\n                   _ => {}\n               }"}, {"sha": "c3e7d06f3f896dd28a458b41955237442946da0c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -261,9 +261,8 @@ impl<'cx> WritebackCx<'cx> {\n                             Some(&def::DefStruct(_)) => {\n                             }\n                             _ => {\n-                                self.tcx().sess.span_err(\n-                                    reason.span(self.tcx()),\n-                                    \"cannot coerce non-statically resolved bare fn\")\n+                                span_err!(self.tcx().sess, reason.span(self.tcx()), E0100,\n+                                    \"cannot coerce non-statically resolved bare fn\");\n                             }\n                         }\n \n@@ -431,47 +430,34 @@ impl<'cx> Resolver<'cx> {\n         if !self.tcx.sess.has_errors() {\n             match self.reason {\n                 ResolvingExpr(span) => {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot determine a type for \\\n-                                 this expression: {}\",\n-                                infer::fixup_err_to_string(e)).as_slice())\n+                    span_err!(self.tcx.sess, span, E0101,\n+                        \"cannot determine a type for this expression: {}\",\n+                        infer::fixup_err_to_string(e));\n                 }\n \n                 ResolvingLocal(span) => {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot determine a type for \\\n-                                 this local variable: {}\",\n-                                infer::fixup_err_to_string(e)).as_slice())\n+                    span_err!(self.tcx.sess, span, E0102,\n+                        \"cannot determine a type for this local variable: {}\",\n+                        infer::fixup_err_to_string(e));\n                 }\n \n                 ResolvingPattern(span) => {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot determine a type for \\\n-                                 this pattern binding: {}\",\n-                                infer::fixup_err_to_string(e)).as_slice())\n+                    span_err!(self.tcx.sess, span, E0103,\n+                        \"cannot determine a type for this pattern binding: {}\",\n+                        infer::fixup_err_to_string(e));\n                 }\n \n                 ResolvingUpvar(upvar_id) => {\n                     let span = self.reason.span(self.tcx);\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot resolve lifetime for \\\n-                                 captured variable `{}`: {}\",\n-                                ty::local_var_name_str(\n-                                    self.tcx,\n-                                    upvar_id.var_id).get().to_string(),\n-                                infer::fixup_err_to_string(e)).as_slice());\n+                    span_err!(self.tcx.sess, span, E0104,\n+                        \"cannot resolve lifetime for captured variable `{}`: {}\",\n+                        ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_string(),\n+                        infer::fixup_err_to_string(e));\n                 }\n \n                 ResolvingImplRes(span) => {\n-                    self.tcx\n-                        .sess\n-                        .span_err(span,\n-                                  \"cannot determine a type for impl \\\n-                                   supertrait\");\n+                    span_err!(self.tcx.sess, span, E0105,\n+                        \"cannot determine a type for impl supertrait\");\n                 }\n \n                 ResolvingUnboxedClosure(_) => {"}, {"sha": "fe140cf2c97c28e9fd1d3eee9d14a06828bfd182", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -224,10 +224,10 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                 if !self.cc.ast_type_is_defined_in_local_crate(&**ast_ty) {\n                     // This is an error.\n                     let session = &self.cc.crate_context.tcx.sess;\n-                    session.span_err(item.span,\n-                                     \"cannot associate methods with a type outside the \\\n-                                     crate the type is defined in; define and implement \\\n-                                     a trait or new type instead\");\n+                    span_err!(session, item.span, E0116,\n+                              \"cannot associate methods with a type outside the \\\n+                               crate the type is defined in; define and implement \\\n+                               a trait or new type instead\");\n                 }\n             }\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n@@ -244,9 +244,9 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n \n                     if trait_def_id.krate != LOCAL_CRATE {\n                         let session = &self.cc.crate_context.tcx.sess;\n-                        session.span_err(item.span,\n-                                \"cannot provide an extension implementation \\\n-                                where both trait and type are not defined in this crate\");\n+                        span_err!(session, item.span, E0117,\n+                                  \"cannot provide an extension implementation \\\n+                                   where both trait and type are not defined in this crate\");\n                     }\n                 }\n \n@@ -302,9 +302,9 @@ impl<'a> CoherenceChecker<'a> {\n                                        self_type.ty) {\n                 None => {\n                     let session = &self.crate_context.tcx.sess;\n-                    session.span_err(item.span,\n-                                     \"no base type found for inherent implementation; \\\n-                                      implement a trait or new type instead\");\n+                    span_err!(session, item.span, E0118,\n+                              \"no base type found for inherent implementation; \\\n+                               implement a trait or new type instead\");\n                 }\n                 Some(_) => {\n                     // Nothing to do.\n@@ -441,22 +441,18 @@ impl<'a> CoherenceChecker<'a> {\n \n                     if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n                         let session = &self.crate_context.tcx.sess;\n-                        session.span_err(\n-                            self.span_of_impl(impl_a),\n-                            format!(\"conflicting implementations for trait `{}`\",\n-                                    ty::item_path_str(\n-                                        self.crate_context.tcx,\n-                                        trait_def_id)).as_slice());\n+                        span_err!(session, self.span_of_impl(impl_a), E0119,\n+                                  \"conflicting implementations for trait `{}`\",\n+                                  ty::item_path_str(self.crate_context.tcx, trait_def_id));\n                         if impl_b.krate == LOCAL_CRATE {\n-                            session.span_note(self.span_of_impl(impl_b),\n-                                              \"note conflicting implementation here\");\n+                            span_note!(session, self.span_of_impl(impl_b),\n+                                       \"note conflicting implementation here\");\n                         } else {\n                             let crate_store = &self.crate_context.tcx.sess.cstore;\n                             let cdata = crate_store.get_crate_data(impl_b.krate);\n-                            session.note(\n-                                format!(\"conflicting implementation in crate \\\n-                                         `{}`\",\n-                                        cdata.name).as_slice());\n+                            span_note!(session, self.span_of_impl(impl_a),\n+                                       \"conflicting implementation in crate `{}`\",\n+                                       cdata.name);\n                         }\n                     }\n                 }\n@@ -706,10 +702,8 @@ impl<'a> CoherenceChecker<'a> {\n                         {\n                             match tcx.map.find(impl_did.node) {\n                                 Some(ast_map::NodeItem(item)) => {\n-                                    tcx.sess.span_err((*item).span,\n-                                                      \"the Drop trait may \\\n-                                                       only be implemented \\\n-                                                       on structures\");\n+                                    span_err!(tcx.sess, item.span, E0120,\n+                                        \"the Drop trait may only be implemented on structures\");\n                                 }\n                                 _ => {\n                                     tcx.sess.bug(\"didn't find impl in ast \\"}, {"sha": "780faddb88639c8e384bc46882da01caa7dbdb09", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -140,9 +140,8 @@ impl<'a> AstConv for CrateCtxt<'a> {\n     }\n \n     fn ty_infer(&self, span: Span) -> ty::t {\n-        self.tcx.sess.span_err(span, \"the type placeholder `_` is not \\\n-                                      allowed within types on item \\\n-                                      signatures.\");\n+        span_err!(self.tcx.sess, span, E0121,\n+                  \"the type placeholder `_` is not allowed within types on item signatures.\");\n         ty::mk_err()\n     }\n }\n@@ -439,10 +438,8 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  thing: &'static str) {\n     for ty_param in generics.ty_params.iter() {\n         if ty_param.bounds.len() > 0 {\n-            ccx.tcx.sess.span_err(\n-                span,\n-                format!(\"trait bounds are not allowed in {} definitions\",\n-                        thing).as_slice());\n+            span_err!(ccx.tcx.sess, span, E0122,\n+                      \"trait bounds are not allowed in {} definitions\", thing);\n         }\n     }\n }\n@@ -453,8 +450,8 @@ fn ensure_generics_abi(ccx: &CrateCtxt,\n                        generics: &ast::Generics) {\n     if generics.ty_params.len() > 0 &&\n        !(abi == abi::Rust || abi == abi::RustIntrinsic) {\n-        ccx.tcx.sess.span_err(span,\n-                              \"foreign functions may not use type parameters\");\n+        span_err!(ccx.tcx.sess, span, E0123,\n+                  \"foreign functions may not use type parameters\");\n     }\n }\n \n@@ -607,12 +604,10 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.find(&result.name) {\n                 Some(prev_span) => {\n-                    tcx.sess.span_err(\n-                        f.span,\n-                        format!(\"field `{}` is already declared\",\n-                                token::get_name(result.name)).as_slice());\n-                    tcx.sess.span_note(*prev_span,\n-                                       \"previously declared here\");\n+                    span_err!(tcx.sess, f.span, E0124,\n+                              \"field `{}` is already declared\",\n+                              token::get_name(result.name));\n+                    span_note!(tcx.sess, *prev_span, \"previously declared here\");\n                     true\n                 },\n                 None => false,\n@@ -641,9 +636,9 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                             Some(ast_map::NodeItem(i)) => match i.node {\n                                 ast::ItemStruct(struct_def, _) => {\n                                     if !struct_def.is_virtual {\n-                                        tcx.sess.span_err(t.span,\n-                                            \"struct inheritance is only \\\n-                                             allowed from virtual structs\");\n+                                        span_err!(tcx.sess, t.span, E0126,\n+                                                  \"struct inheritance is only \\\n+                                                   allowed from virtual structs\");\n                                     }\n                                 },\n                                 _ => {},\n@@ -862,8 +857,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                 {\n                     // This means a trait inherited from the same\n                     // supertrait more than once.\n-                    tcx.sess.span_err(sp, \"duplicate supertrait in \\\n-                                           trait declaration\");\n+                    span_err!(tcx.sess, sp, E0127,\n+                              \"duplicate supertrait in trait declaration\");\n                     break;\n                 } else {\n                     ty_trait_refs.push(trait_ref);\n@@ -1129,10 +1124,9 @@ fn ty_generics(ccx: &CrateCtxt,\n             ty::walk_ty(ty, |t| {\n                 match ty::get(t).sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n-                        ccx.tcx.sess.span_err(\n-                            path.span,\n-                            \"type parameters with a default cannot use \\\n-                             forward declared identifiers\")\n+                    span_err!(ccx.tcx.sess, path.span, E0128,\n+                              \"type parameters with a default cannot use \\\n+                               forward declared identifiers\");\n                     },\n                     _ => {}\n                 }\n@@ -1239,12 +1233,11 @@ fn ty_generics(ccx: &CrateCtxt,\n                                                  |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n                 if trait_def.bounds.contains_elem(ty::BoundSized) {\n-                    tcx.sess.span_err(span,\n-                        format!(\"incompatible bounds on type parameter {}, \\\n-                                 bound {} does not allow unsized type\",\n-                        token::get_ident(ident),\n-                        ppaux::trait_ref_to_string(tcx,\n-                                                &*trait_ref)).as_slice());\n+                    span_err!(tcx.sess, span, E0129,\n+                              \"incompatible bounds on type parameter {}, \\\n+                               bound {} does not allow unsized type\",\n+                              token::get_ident(ident),\n+                              ppaux::trait_ref_to_string(tcx, &*trait_ref));\n                 }\n                 true\n             });\n@@ -1263,8 +1256,10 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n             ast::PatWild => (),\n-            _ => ccx.tcx.sess.span_err((*i).pat.span,\n-                    \"patterns aren't allowed in foreign function declarations\")\n+            _ => {\n+                span_err!(ccx.tcx.sess, (*i).pat.span, E0130,\n+                          \"patterns aren't allowed in foreign function declarations\");\n+            }\n         }\n     }\n "}, {"sha": "4000807ec1b8e87cd7e6b2fc74c27203adfc17e5", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -372,9 +372,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     match it.node {\n                         ast::ItemFn(_, _, _, ref ps, _)\n                         if ps.is_parameterized() => {\n-                            tcx.sess.span_err(\n-                                main_span,\n-                                \"main function is not allowed to have type parameters\");\n+                            span_err!(ccx.tcx.sess, main_span, E0131,\n+                                      \"main function is not allowed to have type parameters\");\n                             return;\n                         }\n                         _ => ()\n@@ -421,9 +420,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                     match it.node {\n                         ast::ItemFn(_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {\n-                            tcx.sess.span_err(\n-                                start_span,\n-                                \"start function is not allowed to have type parameters\");\n+                            span_err!(tcx.sess, start_span, E0132,\n+                                      \"start function is not allowed to have type parameters\");\n                             return;\n                         }\n                         _ => ()"}, {"sha": "4db5b93862f96360bd0c794bd511ea9fbe921064", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -44,24 +44,24 @@ macro_rules! __diagnostic_used(\n \n #[macro_export]\n macro_rules! span_err(\n-    ($session:expr, $span:expr, $code:ident, $($arg:expr),*) => ({\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n-        ($session).span_err_with_code($span, format!($($arg),*).as_slice(), stringify!($code))\n+        $session.span_err_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n     })\n )\n \n #[macro_export]\n macro_rules! span_warn(\n-    ($session:expr, $span:expr, $code:ident, $($arg:expr),*) => ({\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n-        ($session).span_warn_with_code($span, format!($($arg),*).as_slice(), stringify!($code))\n+        $session.span_warn_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n     })\n )\n \n #[macro_export]\n macro_rules! span_note(\n-    ($session:expr, $span:expr, $($arg:expr),*) => ({\n-        ($session).span_note($span, format!($($arg),*).as_slice())\n+    ($session:expr, $span:expr, $($message:tt)*) => ({\n+        ($session).span_note($span, format!($($message)*).as_slice())\n     })\n )\n "}, {"sha": "e3dbc67b7a9ef7fee3a591ed967642797ab1a08e", "filename": "src/test/compile-fail/multiple-main-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Ftest%2Fcompile-fail%2Fmultiple-main-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Ftest%2Fcompile-fail%2Fmultiple-main-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultiple-main-2.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -13,5 +13,5 @@ fn bar() {\n }\n \n #[main]\n-fn foo() { //~ ERROR multiple 'main' functions\n+fn foo() { //~ ERROR multiple functions with a #[main] attribute\n }"}, {"sha": "58cc148568ee6dfeb75acf4bc425d29be57bcb85", "filename": "src/test/compile-fail/multiple-main-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Ftest%2Fcompile-fail%2Fmultiple-main-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a2c97b8e41177e531c4440519333057f9ac55/src%2Ftest%2Fcompile-fail%2Fmultiple-main-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultiple-main-3.rs?ref=f05a2c97b8e41177e531c4440519333057f9ac55", "patch": "@@ -14,6 +14,6 @@ fn main1() {\n \n mod foo {\n     #[main]\n-    fn main2() { //~ ERROR multiple 'main' functions\n+    fn main2() { //~ ERROR multiple functions with a #[main] attribute\n     }\n }"}]}