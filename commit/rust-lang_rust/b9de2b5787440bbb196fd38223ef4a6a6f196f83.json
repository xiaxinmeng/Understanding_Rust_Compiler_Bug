{"sha": "b9de2b5787440bbb196fd38223ef4a6a6f196f83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZGUyYjU3ODc0NDBiYmIxOTZmZDM4MjIzZWY0YTZhNmYxOTZmODM=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-24T06:51:18Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-26T13:59:17Z"}, "message": "Switched over a bunch of splitting funktions to non-allocating iterators", "tree": {"sha": "a724b2b66ef1aaccddae1398cdc098714326f2f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a724b2b66ef1aaccddae1398cdc098714326f2f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9de2b5787440bbb196fd38223ef4a6a6f196f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9de2b5787440bbb196fd38223ef4a6a6f196f83", "html_url": "https://github.com/rust-lang/rust/commit/b9de2b5787440bbb196fd38223ef4a6a6f196f83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9de2b5787440bbb196fd38223ef4a6a6f196f83/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d74606ead60d524eb72afad2cd8b45facd6c5d40", "url": "https://api.github.com/repos/rust-lang/rust/commits/d74606ead60d524eb72afad2cd8b45facd6c5d40", "html_url": "https://github.com/rust-lang/rust/commit/d74606ead60d524eb72afad2cd8b45facd6c5d40"}], "stats": {"total": 233, "additions": 135, "deletions": 98}, "files": [{"sha": "ce6c015c13168e7609ed7fd6a7a9d054da478964", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -132,10 +132,10 @@ impl_NumStrConv_Integer!(u64)\n \n \n // Special value strings as [u8] consts.\n-const inf_buf:          [u8*3] = ['i' as u8, 'n' as u8, 'f' as u8];\n-const positive_inf_buf: [u8*4] = ['+' as u8, 'i' as u8, 'n' as u8, 'f' as u8];\n-const negative_inf_buf: [u8*4] = ['-' as u8, 'i' as u8, 'n' as u8, 'f' as u8];\n-const nan_buf:          [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n+static inf_buf:          [u8*3] = ['i' as u8, 'n' as u8, 'f' as u8];\n+static positive_inf_buf: [u8*4] = ['+' as u8, 'i' as u8, 'n' as u8, 'f' as u8];\n+static negative_inf_buf: [u8*4] = ['-' as u8, 'i' as u8, 'n' as u8, 'f' as u8];\n+static nan_buf:          [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n \n /**\n  * Converts a number to its string representation as a byte vector."}, {"sha": "9aa00e8e4576c5b7f22d4b866de9d90bd392a41a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -218,7 +218,8 @@ pub fn env() -> ~[(~str,~str)] {\n         fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n             for input.each |p| {\n-                let vs = str::splitn_char(*p, '=', 1);\n+                let mut vs = ~[];\n+                for str::each_splitn_char(*p, '=', 1) |s| { vs.push(s.to_owned()) }\n                 debug!(\"splitting: len: %u\",\n                     vs.len());\n                 fail_unless!(vs.len() == 2);"}, {"sha": "3d06809a4523ef6baf805aedf6a93552893b7e71", "filename": "src/libcore/path.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -381,7 +381,8 @@ impl ToStr for PosixPath {\n impl GenericPath for PosixPath {\n \n     fn from_str(s: &str) -> PosixPath {\n-        let mut components = str::split_nonempty(s, |c| c == '/');\n+        let mut components = ~[];\n+        for str::each_split_nonempty(s, |c| c == '/') |s| { components.push(s.to_owned()) }\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n                            components: components }\n@@ -504,9 +505,10 @@ impl GenericPath for PosixPath {\n     fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = str::split_nonempty(\n-                *e,\n-                |c| windows::is_sep(c as u8));\n+            let mut ss = ~[];\n+            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n+                ss.push(s.to_owned())\n+            }\n             unsafe { v.push_all_move(ss); }\n         }\n         PosixPath { is_absolute: self.is_absolute,\n@@ -515,7 +517,10 @@ impl GenericPath for PosixPath {\n \n     fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n-        let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n+        let mut ss = ~[];\n+        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n+            ss.push(s.to_owned())\n+        }\n         unsafe { v.push_all_move(ss); }\n         PosixPath { components: v, ..copy *self }\n     }\n@@ -590,8 +595,10 @@ impl GenericPath for WindowsPath {\n           }\n         }\n \n-        let mut components =\n-            str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n+        let mut components = ~[];\n+        for str::each_split_nonempty(rest, |c| windows::is_sep(c as u8)) |s| {\n+            components.push(s.to_owned())\n+        }\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n         return WindowsPath { host: host,\n                              device: device,\n@@ -759,9 +766,10 @@ impl GenericPath for WindowsPath {\n     fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            let mut ss = str::split_nonempty(\n-                *e,\n-                |c| windows::is_sep(c as u8));\n+            let mut ss = ~[];\n+            for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n+                ss.push(s.to_owned())\n+            }\n             unsafe { v.push_all_move(ss); }\n         }\n         // tedious, but as-is, we can't use ..self\n@@ -775,7 +783,10 @@ impl GenericPath for WindowsPath {\n \n     fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n-        let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n+        let mut ss = ~[];\n+        for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n+            ss.push(s.to_owned())\n+        }\n         unsafe { v.push_all_move(ss); }\n         return WindowsPath { components: v, ..copy *self }\n     }"}, {"sha": "afa4ea66ca677cd08f03909cd69ea1a3fd26f797", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -327,7 +327,9 @@ impl RngUtil for @Rng {\n      */\n     fn gen_char_from(&self, chars: &str) -> char {\n         fail_unless!(!chars.is_empty());\n-        self.choose(str::chars(chars))\n+        let mut cs = ~[];\n+        for str::each_char(chars) |c| { cs.push(c) }\n+        self.choose(cs)\n     }\n \n     /// Return a random bool"}, {"sha": "4fc960a7c04e07e48c20563c30581b4e5cfd0875", "filename": "src/libcore/str.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -463,7 +463,7 @@ pub fn each_split_char_nonempty(s: &str, sep: char, it: &fn(&str) -> bool) {\n }\n \n fn each_split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n-                         allow_trailing_empty: bool), it: &fn(&str) -> bool) {\n+                         allow_trailing_empty: bool, it: &fn(&str) -> bool) {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut done = 0u;\n@@ -513,8 +513,8 @@ pub fn each_split_nonempty(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> b\n     each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n-pure fn each_split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool, allow_trailing_empty: bool), it: &fn(&str) -> bool) {\n+fn each_split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n+               allow_empty: bool, allow_trailing_empty: bool, it: &fn(&str) -> bool) {\n     let l = len(s);\n     let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n@@ -534,7 +534,7 @@ pure fn each_split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -545,7 +545,7 @@ fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n             match_i += 1u;\n             // Found a match\n             if match_i == sep_len {\n-                f(match_start, i + 1u);\n+                if !f(match_start, i + 1u) { return; }\n                 match_i = 0u;\n             }\n             i += 1u;\n@@ -561,10 +561,10 @@ fn iter_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n     }\n }\n \n-fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n+fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n     let mut last_end = 0u;\n-    do iter_matches(s, sep) |from, to| {\n-        f(last_end, from);\n+    for iter_matches(s, sep) |from, to| {\n+        if !f(last_end, from) { return; }\n         last_end = to;\n     }\n     f(last_end, len(s));\n@@ -580,13 +580,13 @@ fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n  * ~~~\n  */\n pub fn each_split_str(s: &'a str, sep: &'b str, it: &fn(&str) -> bool) {\n-    do iter_between_matches(s, sep) |from, to| {\n+    for iter_between_matches(s, sep) |from, to| {\n         if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n     }\n }\n \n pub fn each_split_str_nonempty(s: &'a str, sep: &'b str, it: &fn(&str) -> bool) {\n-    do iter_between_matches(s, sep) |from, to| {\n+    for iter_between_matches(s, sep) |from, to| {\n         if to > from {\n             if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n         }\n@@ -630,7 +630,7 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n').\n  */\n-pub fn each_line(s: &str, it: &fn(&str) -> bool) { each_split_char(s, '\\n', it) }\n+pub fn each_line(s: &str, it: &fn(&str) -> bool) { each_split_char_no_trailing(s, '\\n', it) }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n@@ -656,52 +656,56 @@ pub fn each_word(s: &str, it: &fn(&str) -> bool) {\n  *  each of which is less bytes long than a limit\n  */\n pub fn each_split_within(ss: &str, lim: uint, it: &fn(&str) -> bool) {\n-    let words = str::words(ss);\n-\n-    // empty?\n-    if words == ~[] { return ~[]; }\n-\n-    let mut rows : ~[~str] = ~[];\n-    let mut row  : ~str    = ~\"\";\n-\n-    for words.each |wptr| {\n-        let word = copy *wptr;\n-\n-        // if adding this word to the row would go over the limit,\n-        // then start a new row\n-        if row.len() + word.len() + 1 > lim {\n-            rows.push(copy row); // save previous row\n-            row = word;    // start a new one\n-        } else {\n-            if row.len() > 0 { row += ~\" \" } // separate words\n-            row += word;  // append to this row\n-        }\n+    // Just for fun, let's write this as an automaton\n+    enum SplitWithinState {\n+        A, // Leading whitespace, initial state\n+        B, // Words\n+        C, // Internal and trailing whitespace\n     }\n+    enum Whitespace { Ws, Cr }\n+    enum LengthLimit { UnderLim, OverLim }\n \n-    // save the last row\n-    if row != ~\"\" { rows.push(row); }\n+    let mut slice_start = 0;\n+    let mut last_start = 0;\n+    let mut last_end = 0;\n+    let mut state = A;\n \n-    rows\n-    // NOTE: Finish change here\n+    let mut cont = true;\n+    let slice = || { cont = it(ss.slice(slice_start, last_end)) };\n \n-    let mut last_slice_i = 0, last_word_i = 0, word_start = true;\n-    for each_chari(s) |i, c| {\n-        if (i - last_slice_i) <= lim {\n-            if char::is_whitespace(c) {\n+    let machine = |i: uint, c: char| {\n+        let whitespace = if char::is_whitespace(c)       { Ws }       else { Cr };\n+        let limit      = if (i - slice_start + 1) <= lim { UnderLim } else { OverLim };\n \n-            } else {\n+        state = match (state, whitespace, limit) {\n+            (A, Ws, _)        => { A }\n+            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n \n-            }\n-        } else {\n+            (B, Cr, UnderLim) => { B }\n+            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n+                              => { fail!(~\"word longer than limit!\") }\n+            (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n+            (B, Ws, UnderLim) => { last_end = i; C }\n+            (B, Ws, OverLim)  => { last_end = i; slice(); A }\n \n-        }\n+            (C, Cr, UnderLim) => { last_start = i; B }\n+            (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n+            (C, Ws, OverLim)  => { slice(); A }\n+            (C, Ws, UnderLim) => { C }\n+        };\n+        cont\n+    };\n \n+    str::each_chari(ss, machine);\n \n+    // Let the automaton 'run out'\n+    let mut fake_i = ss.len();\n+    while cont && match state { B | C => true, A => false } {\n+        machine(fake_i, ' ');\n+        fake_i += 1;\n     }\n }\n \n-\n-\n /// Convert a string to lowercase. ASCII only\n pub fn to_lower(s: &str) -> ~str {\n     map(s,\n@@ -731,7 +735,7 @@ pub fn to_upper(s: &str) -> ~str {\n  */\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n-    do iter_between_matches(s, from) |start, end| {\n+    for iter_between_matches(s, from) |start, end| {\n         if first {\n             first = false;\n         } else {\n@@ -2286,9 +2290,9 @@ pub trait StrSlice {\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n-    fn split_char(&self, sep: char) -> ~[~str];\n-    fn split_str(&self, sep: &'a str) -> ~[~str];\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool);\n+    fn each_split_char(&self, sep: char, it: &fn(&str) -> bool);\n+    fn each_split_str(&self, sep: &'a str, it: &fn(&str) -> bool);\n     fn starts_with(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn to_lower(&self) -> ~str;\n@@ -2408,20 +2412,24 @@ impl StrSlice for &'self str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n-        split(*self, sepfn)\n+    fn each_split(&self, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+        each_split(*self, sepfn, it)\n     }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n+    fn each_split_char(&self, sep: char, it: &fn(&str) -> bool) {\n+        each_split_char(*self, sep, it)\n+    }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    fn split_str(&self, sep: &'a str) -> ~[~str] { split_str(*self, sep) }\n+    fn each_split_str(&self, sep: &'a str, it: &fn(&str) -> bool)  {\n+        each_split_str(*self, sep, it)\n+    }\n     /// Returns true if one string starts with another\n     #[inline]\n     fn starts_with(&self, needle: &'a str) -> bool {"}, {"sha": "018a365f37f5268d043cffa1cc3bf19da05e446f", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -120,7 +120,9 @@ pub fn get_used_libraries(cstore: @mut CStore) -> ~[~str] {\n }\n \n pub fn add_used_link_args(cstore: @mut CStore, args: &str) {\n-    cstore.used_link_args.push_all(args.split_char(' '));\n+    for args.each_split_char(' ') |s| {\n+        cstore.used_link_args.push(s.to_owned());\n+    }\n }\n \n pub fn get_used_link_args(cstore: @mut CStore) -> ~[~str] {"}, {"sha": "079110e67f511a3209482776b1a2c898ca48d7c2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -76,7 +76,7 @@ use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n use core::option::{Some, get, is_some, is_none};\n-use core::str::{connect, split_str};\n+use core::str::{connect, each_split_str};\n use core::hashmap::linear::LinearMap;\n use std::oldmap::HashMap;\n \n@@ -1696,7 +1696,8 @@ pub impl Resolver {\n                         entry: %s (%?)\",\n                     path_string, def_like);\n \n-            let mut pieces = split_str(path_string, ~\"::\");\n+            let mut pieces = ~[];\n+            for each_split_str(path_string, \"::\") |s| { pieces.push(s.to_owned()) }\n             let final_ident_str = pieces.pop();\n             let final_ident = self.session.ident_of(final_ident_str);\n "}, {"sha": "b11ad7052b92d27986e1cd3521d9e0b4ba956cee", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -16,12 +16,16 @@ pub trait ToBase64 {\n     fn to_base64(&self) -> ~str;\n }\n \n+static CHARS: &'static[char] = &[\n+    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+];\n+\n impl ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n-        let chars = str::chars(\n-          ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n-        );\n-\n         let mut s = ~\"\";\n         unsafe {\n             let len = self.len();\n@@ -35,10 +39,10 @@ impl ToBase64 for &'self [u8] {\n                         (self[i + 2u] as uint);\n \n                 // This 24-bit number gets separated into four 6-bit numbers.\n-                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n-                str::push_char(&mut s, chars[n & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n+                str::push_char(&mut s, CHARS[n & 63u]);\n \n                 i += 3u;\n             }\n@@ -49,17 +53,17 @@ impl ToBase64 for &'self [u8] {\n               0 => (),\n               1 => {\n                 let n = (self[i] as uint) << 16u;\n-                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n                 str::push_char(&mut s, '=');\n                 str::push_char(&mut s, '=');\n               }\n               2 => {\n                 let n = (self[i] as uint) << 16u |\n                     (self[i + 1u] as uint) << 8u;\n-                str::push_char(&mut s, chars[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n                 str::push_char(&mut s, '=');\n               }\n               _ => fail!(~\"Algebra is broken, please alert the math police\")"}, {"sha": "ae783fb9b697de69b89e3eed697e018a2f18f0ed", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -244,7 +244,8 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 let mut i_arg = None;\n                 if cur[1] == '-' as u8 {\n                     let tail = str::slice(cur, 2, curlen).to_owned();\n-                    let tail_eq = str::splitn_char(tail, '=', 1);\n+                    let mut tail_eq = ~[];\n+                    for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n                     if tail_eq.len() <= 1 {\n                         names = ~[Long(tail)];\n                     } else {\n@@ -627,16 +628,16 @@ pub mod groups {\n             };\n \n             // Normalize desc to contain words seperated by one space character\n-            let mut desc_normalized_whitespace = ~str\n-            for desc.each_word |word| {\n+            let mut desc_normalized_whitespace = ~\"\";\n+            for str::each_word(desc) |word| {\n                 desc_normalized_whitespace.push_str(word);\n                 desc_normalized_whitespace.push_char(' ');\n             }\n \n             // FIXME: #5516\n-            let mut desc_rows: ~[~str] = ~[];\n-            for desc_normalized_whitespace.each_split_within(54) |substr| {\n-                desc_rows.push(~substr);\n+            let mut desc_rows = ~[];\n+            for str::each_split_within(desc_normalized_whitespace, 54) |substr| {\n+                desc_rows.push(substr.to_owned());\n             }\n \n             // FIXME: #5516"}, {"sha": "f39e406bc0060b5e05c3ce9f9e5f6c892cc39059", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -806,7 +806,8 @@ impl serialize::Decoder for Decoder<'self> {\n     }\n \n     fn read_char(&self) -> char {\n-        let v = str::chars(self.read_owned_str());\n+        let mut v = ~[];\n+        for str::each_char(self.read_owned_str()) |c| { v.push(c) }\n         if v.len() != 1 { fail!(~\"string must have one character\") }\n         v[0]\n     }"}, {"sha": "4d82d35cc32062f39c5b92a8325a31de8f8bed62", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -197,7 +197,9 @@ pub mod v4 {\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n-        let parts = vec::map(str::split_char(ip, '.'), |s| {\n+        let mut parts = ~[];\n+        for str::each_split_char(ip, '.') |s| { parts.push(s.to_owned()) }\n+        let parts = vec::map(parts, |s| {\n             match uint::from_str(*s) {\n               Some(n) if n <= 255 => n,\n               _ => 256"}, {"sha": "9caab11d6434ed38752f2a44939b1e80104fd026", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -344,8 +344,8 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n-        for str::split_char(rawquery, '&').each |p| {\n-            let (k, v) = split_char_first(*p, '=');\n+        for str::each_split_char(rawquery, '&') |p| {\n+            let (k, v) = split_char_first(p, '=');\n             // FIXME(#3722): unsafe only because decode_inner does (string) IO\n             unsafe {query.push((decode_component(k), decode_component(v)));}\n         };"}, {"sha": "1b6b25db38ad640248bd049ca8777a5f4bcbfd40", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de2b5787440bbb196fd38223ef4a6a6f196f83/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b9de2b5787440bbb196fd38223ef4a6a6f196f83", "patch": "@@ -99,7 +99,8 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n \n         return do lines.map |line| {\n-            let chars = str::chars(*line);\n+            let mut chars = ~[];\n+            for str::each_char(*line) |c| { chars.push(c) }\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n@@ -116,7 +117,10 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     }\n \n     if comment.starts_with(~\"/*\") {\n-        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u).to_owned());\n+        let mut lines = ~[];\n+        for str::each_line_any(comment.slice(3u, comment.len() - 2u)) |line| {\n+            lines.push(line.to_owned())\n+        }\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));"}]}