{"sha": "27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3Yjc1YTU4MGRmYmE1ZjEzYjEzZGNjNzVlYjQyYzk1Y2ViNDlhYzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-14T14:33:05Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-21T21:16:00Z"}, "message": "refactor & address review comments", "tree": {"sha": "7e8a7360d3c80d798d139312528005cd0ea3ec55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e8a7360d3c80d798d139312528005cd0ea3ec55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "html_url": "https://github.com/rust-lang/rust/commit/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4420c8f5c9be977b72b9b0027800ae36aa0f302", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4420c8f5c9be977b72b9b0027800ae36aa0f302", "html_url": "https://github.com/rust-lang/rust/commit/b4420c8f5c9be977b72b9b0027800ae36aa0f302"}], "stats": {"total": 178, "additions": 108, "deletions": 70}, "files": [{"sha": "e2984e3ca97acb9ce9a5a665d2a1995ef8d42269", "filename": "src/test/ui/commandline-argfile-badutf8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-badutf8.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,6 +1,5 @@\n // Check to see if we can get parameters from an @argsfile file\n //\n-// build-fail\n // compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile-badutf8.args\n \n #[cfg(not(cmdline_set))]"}, {"sha": "020c3ff3c7e6346fe6770170d8a68314323f3caa", "filename": "src/test/ui/commandline-argfile-missing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fcommandline-argfile-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fcommandline-argfile-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommandline-argfile-missing.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,7 +1,6 @@\n // Check to see if we can get parameters from an @argsfile file\n //\n // ignore-tidy-linelength\n-// build-fail\n // normalize-stderr-test: \"os error \\d+\" -> \"os error $$ERR\"\n // normalize-stderr-test: \"commandline-argfile-missing.args:[^(]*\" -> \"commandline-argfile-missing.args: $$FILE_MISSING \"\n // compile-flags: --cfg cmdline_set @{{src-base}}/commandline-argfile-missing.args"}, {"sha": "6f8326fe247ba974a69c5e4fa7b8a104103a58cf", "filename": "src/test/ui/json-and-color.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-and-color.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-and-color.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-and-color.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,4 +1,3 @@\n-// build-fail\n // compile-flags: --json=artifacts --error-format=json --color never\n \n fn main() {}"}, {"sha": "6e2d73c76b7cbfa46f5d2686a803e95e310035ef", "filename": "src/test/ui/json-and-error-format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-and-error-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-and-error-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-and-error-format.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,4 +1,3 @@\n-// build-fail\n // compile-flags: --json=artifacts --error-format=short\n \n fn main() {}"}, {"sha": "9290e010403a1772da9a0e38a847083f2d89b7bd", "filename": "src/test/ui/json-bom-plus-crlf-multifile.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,6 +1,5 @@\n \ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n //\r\n-// build-fail\r\n // compile-flags: --json=diagnostic-short --error-format=json\r\n // ignore-tidy-cr\r\n \r"}, {"sha": "be5b7dd2a86a1487382e5cd347c9051a6a98c18d", "filename": "src/test/ui/json-bom-plus-crlf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,6 +1,5 @@\n \ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n //\r\n-// build-fail\r\n // compile-flags: --json=diagnostic-short --error-format=json\r\n // ignore-tidy-cr\r\n \r"}, {"sha": "1dd898db3ad8c0bbc83d8fb87c6ac0b372b14512", "filename": "src/test/ui/json-bom-plus-crlf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -15,7 +15,7 @@ let x: i32 = \\\"I am not a number!\\\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n-\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":612,\"byte_end\":618,\"line_start\":17,\"line_end\":17,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:17:22: error[E0308]: mismatched types\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":606,\"byte_end\":607,\"line_start\":16,\"line_end\":16,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":597,\"byte_end\":603,\"line_start\":16,\"line_end\":16,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":606,\"byte_end\":607,\"line_start\":16,\"line_end\":16,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:16:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"This error occurs when the compiler was unable to infer the concrete type of a\n variable. It can occur for several cases, the most common of which is a\n@@ -34,7 +34,7 @@ let x: i32 = \\\"I am not a number!\\\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n-\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":672,\"byte_end\":678,\"line_start\":19,\"line_end\":19,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:19:22: error[E0308]: mismatched types\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":666,\"byte_end\":667,\"line_start\":18,\"line_end\":18,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":657,\"byte_end\":663,\"line_start\":18,\"line_end\":18,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":666,\"byte_end\":667,\"line_start\":18,\"line_end\":18,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:18:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"This error occurs when the compiler was unable to infer the concrete type of a\n variable. It can occur for several cases, the most common of which is a\n@@ -53,7 +53,7 @@ let x: i32 = \\\"I am not a number!\\\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n-\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":735,\"byte_end\":741,\"line_start\":22,\"line_end\":22,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String =\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:23:1: error[E0308]: mismatched types\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":730,\"byte_end\":731,\"line_start\":22,\"line_end\":22,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":720,\"byte_end\":726,\"line_start\":21,\"line_end\":21,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String =\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":730,\"byte_end\":731,\"line_start\":22,\"line_end\":22,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:22:1: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"This error occurs when the compiler was unable to infer the concrete type of a\n variable. It can occur for several cases, the most common of which is a\n@@ -72,7 +72,7 @@ let x: i32 = \\\"I am not a number!\\\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n-\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found `()`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":792,\"byte_end\":798,\"line_start\":25,\"line_end\":25,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:25:22: error[E0308]: mismatched types\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":786,\"byte_end\":794,\"line_start\":24,\"line_end\":25,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found `()`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":777,\"byte_end\":783,\"line_start\":24,\"line_end\":24,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:24:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n \"}"}, {"sha": "54d0dd1849a3fe6c862261cef4b760ed189e69fe", "filename": "src/test/ui/json-invalid.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-invalid.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,4 +1,3 @@\n-// build-fail\n // compile-flags: --json=foo --error-format=json\n \n fn main() {}"}, {"sha": "7414a55869c608d7699d6793937a21786b006a74", "filename": "src/test/ui/json-short.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-short.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-short.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-short.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -1,2 +1 @@\n-// build-fail\n // compile-flags: --json=diagnostic-short --error-format=json"}, {"sha": "226343b1b8c7e20a8c88f67c91e4d060a5b362da", "filename": "src/test/ui/json-short.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-short.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftest%2Fui%2Fjson-short.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-short.stderr?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -10,7 +10,7 @@ fn main() {\n \n If you don't know the basics of Rust, you can go look to the Rust Book to get\n started: https://doc.rust-lang.org/book/\n-\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-short.rs\",\"byte_start\":76,\"byte_end\":76,\"line_start\":2,\"line_end\":2,\"column_start\":63,\"column_end\":63,\"is_primary\":true,\"text\":[{\"text\":\"// compile-flags: --json=diagnostic-short --error-format=json\",\"highlight_start\":63,\"highlight_end\":63}],\"label\":\"consider adding a `main` function to `$DIR/json-short.rs`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-short.rs:2:63: error[E0601]: `main` function not found in crate `json_short`\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-short.rs\",\"byte_start\":62,\"byte_end\":62,\"line_start\":1,\"line_end\":1,\"column_start\":63,\"column_end\":63,\"is_primary\":true,\"text\":[{\"text\":\"// compile-flags: --json=diagnostic-short --error-format=json\",\"highlight_start\":63,\"highlight_end\":63}],\"label\":\"consider adding a `main` function to `$DIR/json-short.rs`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-short.rs:1:63: error[E0601]: `main` function not found in crate `json_short`\n \"}\n {\"message\":\"aborting due to previous error\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to previous error\n \"}"}, {"sha": "a9be7ba5f96dcd81d9ea2a70841c0a887cf9b339", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -366,7 +366,7 @@ pub struct TestProps {\n     pass_mode: Option<PassMode>,\n     // Ignore `--pass` overrides from the command line for this test.\n     ignore_pass: bool,\n-    // How far this test should proceed while still failing.\n+    // How far this test should proceed to start failing.\n     pub fail_mode: Option<FailMode>,\n     // rustdoc will test the output of the `--test` option\n     pub check_test_line_numbers_match: bool,"}, {"sha": "83a69c321bbc406e966e393e15e847920a4e8931", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 102, "deletions": 56, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b75a580dfba5f13b13dcc75eb42c95ceb49ac0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=27b75a580dfba5f13b13dcc75eb42c95ceb49ac0", "patch": "@@ -264,7 +264,7 @@ pub fn compute_stamp_hash(config: &Config) -> String {\n         env::var_os(\"PYTHONPATH\").hash(&mut hash);\n     }\n \n-    if let Ui | Incremental | Pretty = config.mode {\n+    if let Ui = config.mode {\n         config.force_pass_mode.hash(&mut hash);\n     }\n \n@@ -294,6 +294,14 @@ enum TestOutput {\n     Run,\n }\n \n+/// Will this test be executed? Should we use `make_exe_name`?\n+#[derive(Copy, Clone, PartialEq)]\n+enum WillExecute { Yes, No }\n+\n+/// Should `--emit metadata` be used?\n+#[derive(Copy, Clone)]\n+enum EmitMetadata { Yes, No }\n+\n impl<'test> TestCx<'test> {\n     /// Code executed for each revision in turn (or, if there are no\n     /// revisions, exactly once, with revision == None).\n@@ -332,34 +340,36 @@ impl<'test> TestCx<'test> {\n         self.props.pass_mode(self.config)\n     }\n \n-    fn should_run(&self) -> bool {\n+    fn should_run(&self, pm: Option<PassMode>) -> WillExecute {\n         match self.config.mode {\n-            Ui => self.pass_mode() == Some(PassMode::Run)\n-                || self.props.fail_mode == Some(FailMode::Run),\n+            Ui if pm == Some(PassMode::Run) || self.props.fail_mode == Some(FailMode::Run) => {\n+                WillExecute::Yes\n+            }\n+            Ui => WillExecute::No,\n             mode => panic!(\"unimplemented for mode {:?}\", mode),\n         }\n     }\n \n-    fn should_run_successfully(&self) -> bool {\n+    fn should_run_successfully(&self, pm: Option<PassMode>) -> bool {\n         match self.config.mode {\n-            Ui => self.pass_mode() == Some(PassMode::Run),\n+            Ui => pm == Some(PassMode::Run),\n             mode => panic!(\"unimplemented for mode {:?}\", mode),\n         }\n     }\n \n-    fn should_compile_successfully(&self) -> bool {\n+    fn should_compile_successfully(&self, pm: Option<PassMode>) -> bool {\n         match self.config.mode {\n             CompileFail => false,\n             JsDocTest => true,\n-            Ui => self.pass_mode().is_some() || self.props.fail_mode > Some(FailMode::Build),\n+            Ui => pm.is_some() || self.props.fail_mode > Some(FailMode::Build),\n             Incremental => {\n                 let revision = self.revision\n                     .expect(\"incremental tests require a list of revisions\");\n                 if revision.starts_with(\"rpass\") || revision.starts_with(\"rfail\") {\n                     true\n                 } else if revision.starts_with(\"cfail\") {\n                     // FIXME: would be nice if incremental revs could start with \"cpass\"\n-                    self.pass_mode().is_some()\n+                    pm.is_some()\n                 } else {\n                     panic!(\"revision name must begin with rpass, rfail, or cfail\");\n                 }\n@@ -368,8 +378,8 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn check_if_test_should_compile(&self, proc_res: &ProcRes) {\n-        if self.should_compile_successfully() {\n+    fn check_if_test_should_compile(&self, proc_res: &ProcRes, pm: Option<PassMode>) {\n+        if self.should_compile_successfully(pm) {\n             if !proc_res.status.success() {\n                 self.fatal_proc_rec(\"test compilation failed although it shouldn't!\", proc_res);\n             }\n@@ -386,8 +396,9 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_cfail_test(&self) {\n-        let proc_res = self.compile_test();\n-        self.check_if_test_should_compile(&proc_res);\n+        let pm = self.pass_mode();\n+        let proc_res = self.compile_test(WillExecute::No, self.should_emit_metadata(pm));\n+        self.check_if_test_should_compile(&proc_res, pm);\n         self.check_no_compiler_crash(&proc_res, self.props.should_ice);\n \n         let output_to_check = self.get_output(&proc_res);\n@@ -398,7 +409,7 @@ impl<'test> TestCx<'test> {\n             }\n             self.check_expected_errors(expected_errors, &proc_res);\n         } else {\n-            self.check_error_patterns(&output_to_check, &proc_res);\n+            self.check_error_patterns(&output_to_check, &proc_res, pm);\n         }\n         if self.props.should_ice {\n             match proc_res.status.code() {\n@@ -411,7 +422,8 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_rfail_test(&self) {\n-        let proc_res = self.compile_test();\n+        let pm = self.pass_mode();\n+        let proc_res = self.compile_test(WillExecute::Yes, self.should_emit_metadata(pm));\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -427,7 +439,7 @@ impl<'test> TestCx<'test> {\n \n         let output_to_check = self.get_output(&proc_res);\n         self.check_correct_failure_status(&proc_res);\n-        self.check_error_patterns(&output_to_check, &proc_res);\n+        self.check_error_patterns(&output_to_check, &proc_res, pm);\n     }\n \n     fn get_output(&self, proc_res: &ProcRes) -> String {\n@@ -454,7 +466,8 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_rpass_test(&self) {\n-        let proc_res = self.compile_test();\n+        let emit_metadata = self.should_emit_metadata(self.pass_mode());\n+        let proc_res = self.compile_test(WillExecute::Yes, emit_metadata);\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -481,7 +494,7 @@ impl<'test> TestCx<'test> {\n             return self.run_rpass_test();\n         }\n \n-        let mut proc_res = self.compile_test();\n+        let mut proc_res = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -714,7 +727,7 @@ impl<'test> TestCx<'test> {\n \n     fn run_debuginfo_cdb_test_no_opt(&self) {\n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compile_result = self.compile_test();\n+        let compile_result = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n@@ -822,7 +835,7 @@ impl<'test> TestCx<'test> {\n         let mut cmds = commands.join(\"\\n\");\n \n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compiler_run_result = self.compile_test();\n+        let compiler_run_result = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n         if !compiler_run_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n         }\n@@ -1074,7 +1087,7 @@ impl<'test> TestCx<'test> {\n \n     fn run_debuginfo_lldb_test_no_opt(&self) {\n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compile_result = self.compile_test();\n+        let compile_result = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n@@ -1373,10 +1386,16 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn check_error_patterns(&self, output_to_check: &str, proc_res: &ProcRes) {\n+    fn check_error_patterns(\n+        &self,\n+        output_to_check: &str,\n+        proc_res: &ProcRes,\n+        pm: Option<PassMode>,\n+    ) {\n         debug!(\"check_error_patterns\");\n         if self.props.error_patterns.is_empty() {\n-            if self.props.fail_mode != Some(FailMode::Run) {\n+            if pm.is_some() {\n+                // FIXME(#65865)\n                 return;\n             } else {\n                 self.fatal(&format!(\n@@ -1552,22 +1571,30 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn compile_test(&self) -> ProcRes {\n+    fn should_emit_metadata(&self, pm: Option<PassMode>) -> EmitMetadata {\n+        match (pm, self.props.fail_mode, self.config.mode) {\n+            (Some(PassMode::Check), ..) | (_, Some(FailMode::Check), Ui) => EmitMetadata::Yes,\n+            _ => EmitMetadata::No,\n+        }\n+    }\n+\n+    fn compile_test(&self, will_execute: WillExecute, emit_metadata: EmitMetadata) -> ProcRes {\n+        self.compile_test_general(will_execute, emit_metadata, self.props.local_pass_mode())\n+    }\n+\n+    fn compile_test_general(\n+        &self,\n+        will_execute: WillExecute,\n+        emit_metadata: EmitMetadata,\n+        local_pm: Option<PassMode>,\n+    ) -> ProcRes {\n         // Only use `make_exe_name` when the test ends up being executed.\n-        let will_execute = match self.config.mode {\n-            Ui => self.should_run(),\n-            Incremental => self.revision.unwrap().starts_with(\"r\"),\n-            RunFail | RunPassValgrind | MirOpt |\n-            DebugInfoCdb | DebugInfoGdbLldb | DebugInfoGdb | DebugInfoLldb => true,\n-            _ => false,\n-        };\n-        let output_file = if will_execute {\n-            TargetLocation::ThisFile(self.make_exe_name())\n-        } else {\n-            TargetLocation::ThisDirectory(self.output_base_dir())\n+        let output_file = match will_execute {\n+            WillExecute::Yes => TargetLocation::ThisFile(self.make_exe_name()),\n+            WillExecute::No => TargetLocation::ThisDirectory(self.output_base_dir()),\n         };\n \n-        let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n+        let mut rustc = self.make_compile_args(&self.testpaths.file, output_file, emit_metadata);\n \n         rustc.arg(\"-L\").arg(&self.aux_output_dir_name());\n \n@@ -1578,11 +1605,12 @@ impl<'test> TestCx<'test> {\n                 // want to actually assert warnings about all this code. Instead\n                 // let's just ignore unused code warnings by defaults and tests\n                 // can turn it back on if needed.\n-                if !self.config.src_base.ends_with(\"rustdoc-ui\") &&\n-                    // Note that we don't call pass_mode() here as we don't want\n+                if !self.is_rustdoc()\n+                    // Note that we use the local pass mode here as we don't want\n                     // to set unused to allow if we've overriden the pass mode\n                     // via command line flags.\n-                    self.props.local_pass_mode() != Some(PassMode::Run) {\n+                    && local_pm != Some(PassMode::Run)\n+                {\n                     rustc.args(&[\"-A\", \"unused\"]);\n                 }\n             }\n@@ -1816,7 +1844,8 @@ impl<'test> TestCx<'test> {\n         };\n         // Create the directory for the stdout/stderr files.\n         create_dir_all(aux_cx.output_base_dir()).unwrap();\n-        let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n+        let input_file = &aux_testpaths.file;\n+        let mut aux_rustc = aux_cx.make_compile_args(input_file, aux_output, EmitMetadata::No);\n \n         let (dylib, crate_type) = if aux_props.no_prefer_dynamic {\n             (true, None)\n@@ -1927,13 +1956,18 @@ impl<'test> TestCx<'test> {\n         result\n     }\n \n+    fn is_rustdoc(&self) -> bool {\n+        self.config.src_base.ends_with(\"rustdoc-ui\")\n+        || self.config.src_base.ends_with(\"rustdoc-js\")\n+    }\n+\n     fn make_compile_args(\n         &self,\n         input_file: &Path,\n         output_file: TargetLocation,\n+        emit_metadata: EmitMetadata,\n     ) -> Command {\n-        let is_rustdoc = self.config.src_base.ends_with(\"rustdoc-ui\") ||\n-                         self.config.src_base.ends_with(\"rustdoc-js\");\n+        let is_rustdoc = self.is_rustdoc();\n         let mut rustc = if !is_rustdoc {\n             Command::new(&self.config.rustc_path)\n         } else {\n@@ -2028,9 +2062,7 @@ impl<'test> TestCx<'test> {\n             }\n         }\n \n-        if let (Some(PassMode::Check), ..) | (_, Some(FailMode::Check), Ui)\n-            = (self.pass_mode(), self.props.fail_mode, self.config.mode)\n-        {\n+        if let (false, EmitMetadata::Yes) = (is_rustdoc, emit_metadata) {\n             rustc.args(&[\"--emit\", \"metadata\"]);\n         }\n \n@@ -2279,7 +2311,8 @@ impl<'test> TestCx<'test> {\n         let aux_dir = self.aux_output_dir_name();\n \n         let output_file = TargetLocation::ThisDirectory(self.output_base_dir());\n-        let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n+        let input_file = &self.testpaths.file;\n+        let mut rustc = self.make_compile_args(input_file, output_file, EmitMetadata::No);\n         rustc.arg(\"-L\").arg(aux_dir).arg(\"--emit=llvm-ir\");\n \n         self.compose_and_run_compiler(rustc, None)\n@@ -2291,7 +2324,8 @@ impl<'test> TestCx<'test> {\n         let output_path = self.output_base_name().with_extension(\"s\");\n \n         let output_file = TargetLocation::ThisFile(output_path.clone());\n-        let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n+        let input_file = &self.testpaths.file;\n+        let mut rustc = self.make_compile_args(input_file, output_file, EmitMetadata::No);\n \n         rustc.arg(\"-L\").arg(self.aux_output_dir_name());\n \n@@ -2518,7 +2552,7 @@ impl<'test> TestCx<'test> {\n     fn run_codegen_units_test(&self) {\n         assert!(self.revision.is_none(), \"revisions not relevant here\");\n \n-        let proc_res = self.compile_test();\n+        let proc_res = self.compile_test(WillExecute::No, EmitMetadata::No);\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -3034,6 +3068,19 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_ui_test(&self) {\n+        if let Some(FailMode::Build) = self.props.fail_mode {\n+            // Make sure a build-fail test cannot fail due to failing analysis (e.g. typeck).\n+            let pm = Some(PassMode::Check);\n+            let proc_res = self.compile_test_general(WillExecute::No, EmitMetadata::Yes, pm);\n+            self.check_if_test_should_compile(&proc_res, pm);\n+        }\n+\n+        let pm = self.pass_mode();\n+        let should_run = self.should_run(pm);\n+        let emit_metadata = self.should_emit_metadata(pm);\n+        let proc_res = self.compile_test(should_run, emit_metadata);\n+        self.check_if_test_should_compile(&proc_res, pm);\n+\n         // if the user specified a format in the ui test\n         // print the output to the stderr file, otherwise extract\n         // the rendered error messages from json and print them\n@@ -3042,8 +3089,6 @@ impl<'test> TestCx<'test> {\n             .compile_flags\n             .iter()\n             .any(|s| s.contains(\"--error-format\"));\n-        let proc_res = self.compile_test();\n-        self.check_if_test_should_compile(&proc_res);\n \n         let expected_fixed = self.load_expected_output(UI_FIXED);\n \n@@ -3127,7 +3172,7 @@ impl<'test> TestCx<'test> {\n \n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n \n-        if self.should_run() {\n+        if let WillExecute::Yes = should_run {\n             let proc_res = self.exec_compiled_test();\n             let run_output_errors = if self.props.check_run_results {\n                 self.load_compare_outputs(&proc_res, TestOutput::Run, explicit)\n@@ -3140,7 +3185,7 @@ impl<'test> TestCx<'test> {\n                     &proc_res,\n                 );\n             }\n-            if self.should_run_successfully() {\n+            if self.should_run_successfully(pm) {\n                 if !proc_res.status.success() {\n                     self.fatal_proc_rec(\"test run failed!\", &proc_res);\n                 }\n@@ -3151,7 +3196,7 @@ impl<'test> TestCx<'test> {\n             }\n             if !self.props.error_patterns.is_empty() {\n                 // \"// error-pattern\" comments\n-                self.check_error_patterns(&proc_res.stderr, &proc_res);\n+                self.check_error_patterns(&proc_res.stderr, &proc_res, pm);\n             }\n         }\n \n@@ -3161,7 +3206,7 @@ impl<'test> TestCx<'test> {\n                self.props.error_patterns);\n         if !explicit && self.config.compare_mode.is_none() {\n             let check_patterns =\n-                !self.should_run() &&\n+                should_run == WillExecute::No &&\n                 !self.props.error_patterns.is_empty();\n \n             let check_annotations =\n@@ -3170,7 +3215,7 @@ impl<'test> TestCx<'test> {\n \n             if check_patterns {\n                 // \"// error-pattern\" comments\n-                self.check_error_patterns(&proc_res.stderr, &proc_res);\n+                self.check_error_patterns(&proc_res.stderr, &proc_res, pm);\n             }\n \n             if check_annotations {\n@@ -3185,6 +3230,7 @@ impl<'test> TestCx<'test> {\n             let mut rustc = self.make_compile_args(\n                 &self.testpaths.file.with_extension(UI_FIXED),\n                 TargetLocation::ThisFile(self.make_exe_name()),\n+                emit_metadata,\n             );\n             rustc.arg(\"-L\").arg(&self.aux_output_dir_name());\n             let res = self.compose_and_run_compiler(rustc, None);\n@@ -3198,7 +3244,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_mir_opt_test(&self) {\n-        let proc_res = self.compile_test();\n+        let proc_res = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);"}]}