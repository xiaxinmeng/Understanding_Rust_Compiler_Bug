{"sha": "aa99abeb262307d5e9aa11a792312fd620b7f89a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhOTlhYmViMjYyMzA3ZDVlOWFhMTFhNzkyMzEyZmQ2MjBiN2Y4OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-14T19:47:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-14T19:47:40Z"}, "message": "Auto merge of #59335 - Aaron1011:fix/extern-priv-final, r=Aaron1011\n\nProperly parse '--extern-private' with name and path\n\nIt turns out that https://github.com/rust-lang/rust/pull/57586 didn't properly parse `--extern-private name=path`.\n\nThis PR properly implements the `--extern-private` option. I've added a new `extern-private` option to `compiletest`, which causes an `--extern-private` option to be passed to the compiler with the proper path.\n\nPart of https://github.com/rust-lang/rust/issues/44663", "tree": {"sha": "d5c1e6a14f774b97aba3a71b3962eb038094aabe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5c1e6a14f774b97aba3a71b3962eb038094aabe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa99abeb262307d5e9aa11a792312fd620b7f89a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa99abeb262307d5e9aa11a792312fd620b7f89a", "html_url": "https://github.com/rust-lang/rust/commit/aa99abeb262307d5e9aa11a792312fd620b7f89a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa99abeb262307d5e9aa11a792312fd620b7f89a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cd61f025b1b92076e69a9ef2d9233325c7d8bdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd61f025b1b92076e69a9ef2d9233325c7d8bdc", "html_url": "https://github.com/rust-lang/rust/commit/9cd61f025b1b92076e69a9ef2d9233325c7d8bdc"}, {"sha": "5cd51b1d8416ce5670a2411a22886bd683bb2766", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd51b1d8416ce5670a2411a22886bd683bb2766", "html_url": "https://github.com/rust-lang/rust/commit/5cd51b1d8416ce5670a2411a22886bd683bb2766"}], "stats": {"total": 214, "additions": 158, "deletions": 56}, "files": [{"sha": "d22de6c6476996ea85f254427de7fbb933b75784", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -199,6 +199,7 @@ pub trait CrateStore {\n \n     // \"queries\" used in resolve that aren't tracked for incremental compilation\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool;\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator;\n     fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;"}, {"sha": "d3a734cbc6eadc8d8df3bf764f6bb2ae0891a3dd", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -283,22 +283,29 @@ impl OutputTypes {\n // DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n // would break dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n-pub struct Externs(BTreeMap<String, BTreeSet<Option<String>>>);\n+pub struct Externs(BTreeMap<String, ExternEntry>);\n+\n+#[derive(Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug, Default)]\n+pub struct ExternEntry {\n+    pub locations: BTreeSet<Option<String>>,\n+    pub is_private_dep: bool\n+}\n \n impl Externs {\n-    pub fn new(data: BTreeMap<String, BTreeSet<Option<String>>>) -> Externs {\n+    pub fn new(data: BTreeMap<String, ExternEntry>) -> Externs {\n         Externs(data)\n     }\n \n-    pub fn get(&self, key: &str) -> Option<&BTreeSet<Option<String>>> {\n+    pub fn get(&self, key: &str) -> Option<&ExternEntry> {\n         self.0.get(key)\n     }\n \n-    pub fn iter<'a>(&'a self) -> BTreeMapIter<'a, String, BTreeSet<Option<String>>> {\n+    pub fn iter<'a>(&'a self) -> BTreeMapIter<'a, String, ExternEntry> {\n         self.0.iter()\n     }\n }\n \n+\n macro_rules! hash_option {\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n@@ -427,10 +434,6 @@ top_level_options!(\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n \n         edition: Edition [TRACKED],\n-\n-        // The list of crates to consider private when\n-        // checking leaked private dependency types in public interfaces\n-        extern_private: Vec<String> [TRACKED],\n     }\n );\n \n@@ -633,7 +636,6 @@ impl Default for Options {\n             cli_forced_thinlto_off: false,\n             remap_path_prefix: Vec::new(),\n             edition: DEFAULT_EDITION,\n-            extern_private: Vec::new()\n         }\n     }\n }\n@@ -2315,10 +2317,14 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n-    let extern_private = matches.opt_strs(\"extern-private\");\n+    // We start out with a Vec<(Option<String>, bool)>>,\n+    // and later convert it into a BTreeSet<(Option<String>, bool)>\n+    // This allows to modify entries in-place to set their correct\n+    // 'public' value\n+    let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n+    for (arg, private) in matches.opt_strs(\"extern\").into_iter().map(|v| (v, false))\n+        .chain(matches.opt_strs(\"extern-private\").into_iter().map(|v| (v, true))) {\n \n-    let mut externs: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();\n-    for arg in matches.opt_strs(\"extern\").into_iter().chain(matches.opt_strs(\"extern-private\")) {\n         let mut parts = arg.splitn(2, '=');\n         let name = parts.next().unwrap_or_else(||\n             early_error(error_format, \"--extern value must not be empty\"));\n@@ -2331,10 +2337,17 @@ pub fn build_session_options_and_crate_config(\n             );\n         };\n \n-        externs\n+        let entry = externs\n             .entry(name.to_owned())\n-            .or_default()\n-            .insert(location);\n+            .or_default();\n+\n+\n+        entry.locations.insert(location.clone());\n+\n+        // Crates start out being not private,\n+        // and go to being private if we see an '--extern-private'\n+        // flag\n+        entry.is_private_dep |= private;\n     }\n \n     let crate_name = matches.opt_str(\"crate-name\");\n@@ -2386,7 +2399,6 @@ pub fn build_session_options_and_crate_config(\n             cli_forced_thinlto_off: disable_thinlto,\n             remap_path_prefix,\n             edition,\n-            extern_private\n         },\n         cfg,\n     )\n@@ -2651,7 +2663,7 @@ mod tests {\n         build_session_options_and_crate_config,\n         to_crate_config\n     };\n-    use crate::session::config::{LtoCli, LinkerPluginLto, PgoGenerate};\n+    use crate::session::config::{LtoCli, LinkerPluginLto, PgoGenerate, ExternEntry};\n     use crate::session::build_session;\n     use crate::session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n@@ -2664,6 +2676,19 @@ mod tests {\n     use syntax;\n     use super::Options;\n \n+    impl ExternEntry {\n+        fn new_public<S: Into<String>,\n+                      I: IntoIterator<Item = Option<S>>>(locations: I) -> ExternEntry {\n+            let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n+                .collect();\n+\n+            ExternEntry {\n+                locations,\n+                is_private_dep: false\n+            }\n+        }\n+    }\n+\n     fn optgroups() -> getopts::Options {\n         let mut opts = getopts::Options::new();\n         for group in super::rustc_optgroups() {\n@@ -2676,10 +2701,6 @@ mod tests {\n         BTreeMap::from_iter(entries.into_iter())\n     }\n \n-    fn mk_set<V: Ord>(entries: Vec<V>) -> BTreeSet<V> {\n-        BTreeSet::from_iter(entries.into_iter())\n-    }\n-\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n@@ -2797,33 +2818,33 @@ mod tests {\n         v1.externs = Externs::new(mk_map(vec![\n             (\n                 String::from(\"a\"),\n-                mk_set(vec![Some(String::from(\"b\")), Some(String::from(\"c\"))]),\n+                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n             ),\n             (\n                 String::from(\"d\"),\n-                mk_set(vec![Some(String::from(\"e\")), Some(String::from(\"f\"))]),\n+                ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n             ),\n         ]));\n \n         v2.externs = Externs::new(mk_map(vec![\n             (\n                 String::from(\"d\"),\n-                mk_set(vec![Some(String::from(\"e\")), Some(String::from(\"f\"))]),\n+                ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n             ),\n             (\n                 String::from(\"a\"),\n-                mk_set(vec![Some(String::from(\"b\")), Some(String::from(\"c\"))]),\n+                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n             ),\n         ]));\n \n         v3.externs = Externs::new(mk_map(vec![\n             (\n                 String::from(\"a\"),\n-                mk_set(vec![Some(String::from(\"b\")), Some(String::from(\"c\"))]),\n+                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n             ),\n             (\n                 String::from(\"d\"),\n-                mk_set(vec![Some(String::from(\"f\")), Some(String::from(\"e\"))]),\n+                ExternEntry::new_public(vec![Some(\"f\"), Some(\"e\")])\n             ),\n         ]));\n "}, {"sha": "1ce9ffd94330d8062709a87e9f07fdcea84714b6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -1397,6 +1397,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Returns whether or not the crate with CrateNum 'cnum'\n+    /// is marked as a private dependency\n+    pub fn is_private_dep(self, cnum: CrateNum) -> bool {\n+        if cnum == LOCAL_CRATE {\n+            false\n+        } else {\n+            self.cstore.crate_is_private_dep_untracked(cnum)\n+        }\n+    }\n+\n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n         if def_id.is_local() {"}, {"sha": "160d4c30c0bad24f513cd53b57636e0e17a3c77e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -131,9 +131,9 @@ impl<'a> CrateLoader<'a> {\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n             let source = &self.cstore.get_crate_data(cnum).source;\n-            if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n+            if let Some(entry) = self.sess.opts.externs.get(&*name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n-                let found = locs.iter().filter_map(|l| l.as_ref()).any(|l| {\n+                let found = entry.locations.iter().filter_map(|l| l.as_ref()).any(|l| {\n                     let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n                     source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n@@ -195,12 +195,20 @@ impl<'a> CrateLoader<'a> {\n         ident: Symbol,\n         span: Span,\n         lib: Library,\n-        dep_kind: DepKind\n+        dep_kind: DepKind,\n+        name: Symbol\n     ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n         let crate_root = lib.metadata.get_root();\n-        info!(\"register crate `extern crate {} as {}`\", crate_root.name, ident);\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n+        let private_dep = self.sess.opts.externs.get(&name.as_str())\n+            .map(|e| e.is_private_dep)\n+            .unwrap_or(false);\n+\n+        info!(\"register crate `extern crate {} as {}` (private_dep = {})\",\n+            crate_root.name, ident, private_dep);\n+\n+\n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n \n@@ -272,7 +280,8 @@ impl<'a> CrateLoader<'a> {\n                 dylib,\n                 rlib,\n                 rmeta,\n-            }\n+            },\n+            private_dep\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -390,7 +399,7 @@ impl<'a> CrateLoader<'a> {\n                 Ok((cnum, data))\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                Ok(self.register_crate(host_library, root, ident, span, library, dep_kind))\n+                Ok(self.register_crate(host_library, root, ident, span, library, dep_kind, name))\n             }\n             _ => panic!()\n         }"}, {"sha": "22a13f37722b8cfced8117c8d8f7684b62ae7b37", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -79,6 +79,10 @@ pub struct CrateMetadata {\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n+\n+    /// Whether or not this crate should be consider a private dependency\n+    /// for purposes of the 'exported_private_dependencies' lint\n+    pub private_dep: bool\n }\n \n pub struct CStore {\n@@ -114,7 +118,8 @@ impl CStore {\n     }\n \n     pub(super) fn get_crate_data(&self, cnum: CrateNum) -> Lrc<CrateMetadata> {\n-        self.metas.borrow()[cnum].clone().unwrap()\n+        self.metas.borrow()[cnum].clone()\n+            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n     }\n \n     pub(super) fn set_crate_data(&self, cnum: CrateNum, data: Lrc<CrateMetadata>) {"}, {"sha": "10a99e40c419cfa36e3fff52b873c76b6b775f36", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -499,6 +499,10 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).name\n     }\n \n+    fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool {\n+        self.get_crate_data(cnum).private_dep\n+    }\n+\n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator\n     {\n         self.get_crate_data(cnum).root.disambiguator"}, {"sha": "116042c53fb9e2455e2c00bea4bde81fdc6ea256", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -442,11 +442,11 @@ impl<'a> Context<'a> {\n         // must be loaded via -L plus some filtering.\n         if self.hash.is_none() {\n             self.should_match_name = false;\n-            if let Some(s) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n+            if let Some(entry) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n-                if s.iter().any(|l| l.is_some()) {\n+                if entry.locations.iter().any(|l| l.is_some()) {\n                     return self.find_commandline_library(\n-                        s.iter().filter_map(|l| l.as_ref()),\n+                        entry.locations.iter().filter_map(|l| l.as_ref()),\n                     );\n                 }\n             }"}, {"sha": "44621e5dc95d1b2b823f810fc109a6f7c64c780a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -1540,7 +1540,6 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     has_pub_restricted: bool,\n     has_old_errors: bool,\n     in_assoc_ty: bool,\n-    private_crates: FxHashSet<CrateNum>\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n@@ -1622,7 +1621,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     /// 2. It comes from a private crate\n     fn leaks_private_dep(&self, item_id: DefId) -> bool {\n         let ret = self.required_visibility == ty::Visibility::Public &&\n-            self.private_crates.contains(&item_id.krate);\n+            self.tcx.is_private_dep(item_id.krate);\n \n         log::debug!(\"leaks_private_dep(item_id={:?})={}\", item_id, ret);\n         return ret;\n@@ -1640,7 +1639,6 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a HirIdSet,\n-    private_crates: FxHashSet<CrateNum>\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n@@ -1678,7 +1676,6 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,\n             in_assoc_ty: false,\n-            private_crates: self.private_crates.clone()\n         }\n     }\n \n@@ -1876,17 +1873,11 @@ fn check_private_in_public<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, krate: CrateNum) {\n         pub_restricted_visitor.has_pub_restricted\n     };\n \n-    let private_crates: FxHashSet<CrateNum> = tcx.sess.opts.extern_private.iter()\n-        .flat_map(|c| {\n-            tcx.crates().iter().find(|&&krate| &tcx.crate_name(krate) == c).cloned()\n-        }).collect();\n-\n     // Check for private types and traits in public interfaces.\n     let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n         tcx,\n         has_pub_restricted,\n         old_error_set: &visitor.old_error_set,\n-        private_crates\n     };\n     krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n }"}, {"sha": "a4d2a3be863300aef1f5c7f1ca2e48cc403a4c15", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::BTreeMap;\n use std::fmt;\n use std::path::PathBuf;\n \n@@ -9,7 +9,7 @@ use rustc::lint::Level;\n use rustc::session::early_error;\n use rustc::session::config::{CodegenOptions, DebuggingOptions, ErrorOutputType, Externs};\n use rustc::session::config::{nightly_options, build_codegen_options, build_debugging_options,\n-                             get_cmd_lint_options};\n+                             get_cmd_lint_options, ExternEntry};\n use rustc::session::search_paths::SearchPath;\n use rustc_driver;\n use rustc_target::spec::TargetTriple;\n@@ -578,7 +578,7 @@ fn parse_extern_html_roots(\n /// error message.\n // FIXME(eddyb) This shouldn't be duplicated with `rustc::session`.\n fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n-    let mut externs: BTreeMap<_, BTreeSet<_>> = BTreeMap::new();\n+    let mut externs: BTreeMap<_, ExternEntry> = BTreeMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n         let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n@@ -588,7 +588,10 @@ fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n                         enable `--extern crate_name` without `=path`\".to_string());\n         }\n         let name = name.to_string();\n-        externs.entry(name).or_default().insert(location);\n+        // For Rustdoc purposes, we can treat all externs as public\n+        externs.entry(name)\n+            .or_default()\n+            .locations.insert(location.clone());\n     }\n     Ok(Externs::new(externs))\n }"}, {"sha": "784615354a95c6f5e105a4b5eb957bac7888d452", "filename": "src/test/ui/privacy/pub-priv-dep/pub-priv1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -1,6 +1,6 @@\n  // aux-build:priv_dep.rs\n  // aux-build:pub_dep.rs\n- // compile-flags: --extern-private priv_dep\n+ // extern-private:priv_dep\n #![deny(exported_private_dependencies)]\n \n // This crate is a private dependency"}, {"sha": "64882c603bad3c8cbf697100e489f9c09902e339", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -286,6 +286,10 @@ pub struct TestProps {\n     // directory as the test, but for backwards compatibility reasons\n     // we also check the auxiliary directory)\n     pub aux_builds: Vec<String>,\n+    // A list of crates to pass '--extern-private name:PATH' flags for\n+    // This should be a subset of 'aux_build'\n+    // FIXME: Replace this with a better solution: https://github.com/rust-lang/rust/pull/54020\n+    pub extern_private: Vec<String>,\n     // Environment settings to use for compiling\n     pub rustc_env: Vec<(String, String)>,\n     // Environment settings to use during execution\n@@ -353,6 +357,7 @@ impl TestProps {\n             run_flags: None,\n             pp_exact: None,\n             aux_builds: vec![],\n+            extern_private: vec![],\n             revisions: vec![],\n             rustc_env: vec![],\n             exec_env: vec![],\n@@ -469,6 +474,10 @@ impl TestProps {\n                 self.aux_builds.push(ab);\n             }\n \n+            if let Some(ep) = config.parse_extern_private(ln) {\n+                self.extern_private.push(ep);\n+            }\n+\n             if let Some(ee) = config.parse_env(ln, \"exec-env\") {\n                 self.exec_env.push(ee);\n             }\n@@ -610,6 +619,10 @@ impl Config {\n             .map(|r| r.trim().to_string())\n     }\n \n+    fn parse_extern_private(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"extern-private\")\n+    }\n+\n     fn parse_compile_flags(&self, line: &str) -> Option<String> {\n         self.parse_name_value_directive(line, \"compile-flags\")\n     }"}, {"sha": "9e3c49119deafd16a44ad66fbdc4242b09bebc94", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -1,5 +1,6 @@\n #![crate_name = \"compiletest\"]\n #![feature(test)]\n+#![feature(vec_remove_item)]\n #![deny(warnings, rust_2018_idioms)]\n \n #[cfg(unix)]"}, {"sha": "79868a781fdd140385c141db5de453415588cb41", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa99abeb262307d5e9aa11a792312fd620b7f89a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=aa99abeb262307d5e9aa11a792312fd620b7f89a", "patch": "@@ -74,6 +74,25 @@ pub fn dylib_env_var() -> &'static str {\n     }\n }\n \n+/// The platform-specific library name\n+pub fn get_lib_name(lib: &str, dylib: bool) -> String {\n+    // In some casess (e.g. MUSL), we build a static\n+    // library, rather than a dynamic library.\n+    // In this case, the only path we can pass\n+    // with '--extern-meta' is the '.lib' file\n+    if !dylib {\n+        return format!(\"lib{}.rlib\", lib);\n+    }\n+\n+    if cfg!(windows) {\n+        format!(\"{}.dll\", lib)\n+    } else if cfg!(target_os = \"macos\") {\n+        format!(\"lib{}.dylib\", lib)\n+    } else {\n+        format!(\"lib{}.so\", lib)\n+    }\n+}\n+\n #[derive(Debug, PartialEq)]\n pub enum DiffLine {\n     Context(String),\n@@ -1585,6 +1604,16 @@ impl<'test> TestCx<'test> {\n             create_dir_all(&aux_dir).unwrap();\n         }\n \n+        // Use a Vec instead of a HashMap to preserve original order\n+        let mut extern_priv = self.props.extern_private.clone();\n+\n+        let mut add_extern_priv = |priv_dep: &str, dylib: bool| {\n+            let lib_name = get_lib_name(priv_dep, dylib);\n+            rustc\n+                .arg(\"--extern-private\")\n+                .arg(format!(\"{}={}\", priv_dep, aux_dir.join(lib_name).to_str().unwrap()));\n+        };\n+\n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n             let aux_props =\n@@ -1601,8 +1630,8 @@ impl<'test> TestCx<'test> {\n             create_dir_all(aux_cx.output_base_dir()).unwrap();\n             let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n \n-            let crate_type = if aux_props.no_prefer_dynamic {\n-                None\n+            let (dylib, crate_type) = if aux_props.no_prefer_dynamic {\n+                (true, None)\n             } else if self.config.target.contains(\"cloudabi\")\n                 || self.config.target.contains(\"emscripten\")\n                 || (self.config.target.contains(\"musl\") && !aux_props.force_host)\n@@ -1618,11 +1647,20 @@ impl<'test> TestCx<'test> {\n                 // dynamic libraries so we just go back to building a normal library. Note,\n                 // however, that for MUSL if the library is built with `force_host` then\n                 // it's ok to be a dylib as the host should always support dylibs.\n-                Some(\"lib\")\n+                (false, Some(\"lib\"))\n             } else {\n-                Some(\"dylib\")\n+                (true, Some(\"dylib\"))\n             };\n \n+            let trimmed = rel_ab.trim_end_matches(\".rs\").to_string();\n+\n+            // Normally, every 'extern-private' has a correspodning 'aux-build'\n+            // entry. If so, we remove it from our list of private crates,\n+            // and add an '--extern-private' flag to rustc\n+            if extern_priv.remove_item(&trimmed).is_some() {\n+                add_extern_priv(&trimmed, dylib);\n+            }\n+\n             if let Some(crate_type) = crate_type {\n                 aux_rustc.args(&[\"--crate-type\", crate_type]);\n             }\n@@ -1646,6 +1684,12 @@ impl<'test> TestCx<'test> {\n             }\n         }\n \n+        // Add any '--extern-private' entries without a matching\n+        // 'aux-build'\n+        for private_lib in extern_priv {\n+            add_extern_priv(&private_lib, true);\n+        }\n+\n         rustc.envs(self.props.rustc_env.clone());\n         self.compose_and_run(\n             rustc,"}]}