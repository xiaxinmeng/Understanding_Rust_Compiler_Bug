{"sha": "d9596692a54205059a29677490fce7fd32311df6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NTk2NjkyYTU0MjA1MDU5YTI5Njc3NDkwZmNlN2ZkMzIzMTFkZjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-05T23:07:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:20Z"}, "message": "implement PickConstraintSet type", "tree": {"sha": "75996707433102da37cc36a7a4d4e4ebaa99269f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75996707433102da37cc36a7a4d4e4ebaa99269f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9596692a54205059a29677490fce7fd32311df6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9596692a54205059a29677490fce7fd32311df6", "html_url": "https://github.com/rust-lang/rust/commit/d9596692a54205059a29677490fce7fd32311df6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9596692a54205059a29677490fce7fd32311df6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "330cb7668cd944e0cd4c9ba0c810bb2f0f862b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/330cb7668cd944e0cd4c9ba0c810bb2f0f862b50", "html_url": "https://github.com/rust-lang/rust/commit/330cb7668cd944e0cd4c9ba0c810bb2f0f862b50"}], "stats": {"total": 211, "additions": 211, "deletions": 0}, "files": [{"sha": "364d12aa395fbd0ed0d8dde9d28b473cdc60cd9c", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9596692a54205059a29677490fce7fd32311df6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9596692a54205059a29677490fce7fd32311df6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=d9596692a54205059a29677490fce7fd32311df6", "patch": "@@ -37,6 +37,7 @@ crate mod type_check;\n mod universal_regions;\n \n mod constraints;\n+mod pick_constraints;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;"}, {"sha": "6bbd2e8052783e4d71b17fe74fd3fde6baa214f6", "filename": "src/librustc_mir/borrow_check/nll/pick_constraints.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/d9596692a54205059a29677490fce7fd32311df6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9596692a54205059a29677490fce7fd32311df6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs?ref=d9596692a54205059a29677490fce7fd32311df6", "patch": "@@ -0,0 +1,210 @@\n+#![allow(dead_code)] // TODO\n+\n+use crate::rustc::ty::{self, Ty};\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::region_constraints::PickConstraint;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::hash::Hash;\n+use std::ops::Index;\n+\n+/// Compactly stores a set of `pick R0 in [R1...Rn]` constraints,\n+/// indexed by the region R0.\n+crate struct PickConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    /// Stores the first \"pick\" constraint for a given R0. This is an\n+    /// index into the `constraints` vector below.\n+    first_constraints: FxHashMap<R, NllPickConstraintIndex>,\n+\n+    /// Stores the data about each `pick R0 from [R1..Rn]` constraint.\n+    /// These are organized into a linked list, so each constraint\n+    /// contains the index of the next constraint with the same R0.\n+    constraints: IndexVec<NllPickConstraintIndex, NllPickConstraint<'tcx>>,\n+\n+    /// Stores the `R1..Rn` regions for *all* sets. For any given\n+    /// constraint, we keep two indices so that we can pull out a\n+    /// slice.\n+    option_regions: Vec<ty::RegionVid>,\n+}\n+\n+/// Represents a `pick R0 in [R1..Rn]` constraint\n+crate struct NllPickConstraint<'tcx> {\n+    next_constraint: Option<NllPickConstraintIndex>,\n+\n+    /// The opaque type whose hidden type is being inferred. (Used in error reporting.)\n+    crate opaque_type_def_id: DefId,\n+\n+    /// The hidden type in which R0 appears. (Used in error reporting.)\n+    crate hidden_ty: Ty<'tcx>,\n+\n+    /// The region R0.\n+    crate pick_region_vid: ty::RegionVid,\n+\n+    /// Index of `R1` in `option_regions` vector from `PickConstraintSet`.\n+    start_index: usize,\n+\n+    /// Index of `Rn` in `option_regions` vector from `PickConstraintSet`.\n+    end_index: usize,\n+}\n+\n+newtype_index! {\n+    crate struct NllPickConstraintIndex {\n+        DEBUG_FORMAT = \"PickConstraintIndex({})\"\n+    }\n+}\n+\n+impl<'tcx> PickConstraintSet<'tcx, ty::RegionVid> {\n+    crate fn new() -> Self {\n+        Self {\n+            first_constraints: Default::default(),\n+            constraints: Default::default(),\n+            option_regions: Default::default(),\n+        }\n+    }\n+\n+    crate fn push_constraint(\n+        &mut self,\n+        p_c: PickConstraint<'tcx>,\n+        mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n+    ) {\n+        let pick_region_vid: ty::RegionVid = to_region_vid(p_c.pick_region);\n+        let next_constraint = self.first_constraints.get(&pick_region_vid).cloned();\n+        let start_index = self.option_regions.len();\n+        let end_index = start_index + p_c.option_regions.len();\n+        let constraint_index = self.constraints.push(NllPickConstraint {\n+            next_constraint,\n+            pick_region_vid,\n+            opaque_type_def_id: p_c.opaque_type_def_id,\n+            hidden_ty: p_c.hidden_ty,\n+            start_index,\n+            end_index,\n+        });\n+        self.first_constraints.insert(pick_region_vid, constraint_index);\n+        self.option_regions.extend(p_c.option_regions.iter().map(|&r| to_region_vid(r)));\n+    }\n+}\n+\n+impl<'tcx, R1> PickConstraintSet<'tcx, R1>\n+where\n+    R1: Copy + Hash + Eq,\n+{\n+    /// Remap the \"pick region\" key using `map_fn`, producing a new\n+    /// pick-constraint set.  This is used in the NLL code to map from\n+    /// the original `RegionVid` to an scc index. In some cases, we\n+    /// may have multiple R1 values mapping to the same R2 key -- that\n+    /// is ok, the two sets will be merged.\n+    crate fn into_mapped<R2>(self, mut map_fn: impl FnMut(R1) -> R2) -> PickConstraintSet<'tcx, R2>\n+    where\n+        R2: Copy + Hash + Eq,\n+    {\n+        // We can re-use most of the original data, just tweaking the\n+        // linked list links a bit.\n+        //\n+        // For example if we had two keys Ra and Rb that both now wind\n+        // up mapped to the same key S, we would append the linked\n+        // list for Ra onto the end of the linked list for Rb (or vice\n+        // versa) -- this basically just requires rewriting the final\n+        // link from one list to point at the othe other (see\n+        // `append_list`).\n+\n+        let PickConstraintSet { first_constraints, mut constraints, option_regions } = self;\n+\n+        let mut first_constraints2 = FxHashMap::default();\n+        first_constraints2.reserve(first_constraints.len());\n+\n+        for (r1, start1) in first_constraints {\n+            let r2 = map_fn(r1);\n+            if let Some(&start2) = first_constraints2.get(&r2) {\n+                append_list(&mut constraints, start1, start2);\n+            }\n+            first_constraints2.insert(r2, start1);\n+        }\n+\n+        PickConstraintSet {\n+            first_constraints: first_constraints2,\n+            constraints,\n+            option_regions,\n+        }\n+    }\n+}\n+\n+impl<'tcx, R> PickConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    /// Iterate down the constraint indices associated with a given\n+    /// peek-region.  You can then use `option_regions` and other\n+    /// methods to access data.\n+    crate fn indices(\n+        &self,\n+        pick_region_vid: R,\n+    ) -> impl Iterator<Item = NllPickConstraintIndex> + '_ {\n+        let mut next = self.first_constraints.get(&pick_region_vid).cloned();\n+        std::iter::from_fn(move || -> Option<NllPickConstraintIndex> {\n+            if let Some(current) = next {\n+                next = self.constraints[current].next_constraint;\n+                Some(current)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// Returns the \"option regions\" for a given pick constraint. This is the R1..Rn from\n+    /// a constraint like:\n+    ///\n+    /// ```\n+    /// pick R0 in [R1..Rn]\n+    /// ```\n+    crate fn option_regions(&self, pci: NllPickConstraintIndex) -> &[ty::RegionVid] {\n+        let NllPickConstraint { start_index, end_index, .. } = &self.constraints[pci];\n+        &self.option_regions[*start_index..*end_index]\n+    }\n+}\n+\n+impl<'tcx, R> Index<NllPickConstraintIndex> for PickConstraintSet<'tcx, R>\n+where\n+    R: Copy + Hash + Eq,\n+{\n+    type Output = NllPickConstraint<'tcx>;\n+\n+    fn index(&self, i: NllPickConstraintIndex) -> &NllPickConstraint<'tcx> {\n+        &self.constraints[i]\n+    }\n+}\n+\n+/// Given a linked list starting at `source_list` and another linked\n+/// list starting at `target_list`, modify `target_list` so that it is\n+/// followed by `source_list`.\n+///\n+/// Before:\n+///\n+/// ```\n+/// target_list: A -> B -> C -> (None)\n+/// source_list: D -> E -> F -> (None)\n+/// ```\n+///\n+/// After:\n+///\n+/// ```\n+/// target_list: A -> B -> C -> D -> E -> F -> (None)\n+/// ```\n+fn append_list(\n+    constraints: &mut IndexVec<NllPickConstraintIndex, NllPickConstraint<'_>>,\n+    target_list: NllPickConstraintIndex,\n+    source_list: NllPickConstraintIndex,\n+) {\n+    let mut p = target_list;\n+    loop {\n+        let mut r = &mut constraints[p];\n+        match r.next_constraint {\n+            Some(q) => p = q,\n+            None => {\n+                r.next_constraint = Some(source_list);\n+                return;\n+            }\n+        }\n+    }\n+}"}]}