{"sha": "a3727559c6eee465893f400ec4edad77be868f3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNzI3NTU5YzZlZWU0NjU4OTNmNDAwZWM0ZWRhZDc3YmU4NjhmM2M=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-16T22:39:06Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:32:44Z"}, "message": "rustc: use the TLS type context in Repr and UserString.", "tree": {"sha": "933a282cfba63a3f53eb182af84185ad4cc0be04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/933a282cfba63a3f53eb182af84185ad4cc0be04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3727559c6eee465893f400ec4edad77be868f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3727559c6eee465893f400ec4edad77be868f3c", "html_url": "https://github.com/rust-lang/rust/commit/a3727559c6eee465893f400ec4edad77be868f3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3727559c6eee465893f400ec4edad77be868f3c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "html_url": "https://github.com/rust-lang/rust/commit/1f70a2e370e2c0d69403ccadc6b55caee27a73c1"}], "stats": {"total": 3924, "additions": 1991, "deletions": 1933}, "files": [{"sha": "d955cda9b77b710f5a9f33084ea0047a6bba7f80", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -63,7 +63,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n         let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n             None => {\n                 tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\", path.repr(tcx)))\n+                                  &format!(\"unbound path {}\", path.repr()))\n             }\n             Some(d) => d.full_def()\n         };"}, {"sha": "a6386d941f5fef9ed3da8463a3205ece6575fc0b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -1624,7 +1624,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);\n                         debug!(\"inserting ty for node {}: {}\",\n-                               id,  ty.repr(dcx.tcx));\n+                               id,  ty.repr());\n                         dcx.tcx.node_type_insert(id, ty);\n                     }\n                     c::tag_table_item_subst => {"}, {"sha": "9100f45a5de89b286f2363742e269b0d13cd1689", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        debug!(\"visit_item(item={})\", i.repr(self.tcx));\n+        debug!(\"visit_item(item={})\", i.repr());\n         match i.node {\n             ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);"}, {"sha": "8982a45cee8f439969adbc3e1451857344d10738", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -210,7 +210,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n                               \"non-exhaustive patterns: type {} is non-empty\",\n-                              pat_ty.user_string(cx.tcx));\n+                              pat_ty.user_string());\n                 }\n                 // If the type *is* empty, it's vacuously exhaustive\n                 return;\n@@ -243,11 +243,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n-                                &token::get_ident(ident.node), pat_ty.user_string(cx.tcx));\n+                                &token::get_ident(ident.node), pat_ty.user_string());\n                             fileline_help!(cx.tcx.sess, p.span,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n-                                pat_ty.user_string(cx.tcx), &token::get_ident(ident.node));\n+                                pat_ty.user_string(), &token::get_ident(ident.node));\n                         }\n                     }\n                 }"}, {"sha": "a3881327b96ad2150b9b6242bf7993554d34bcd3", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -59,11 +59,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, cmt.ty.repr(self.tcx));\n+        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, cmt.ty.repr());\n         if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                cmt.ty.user_string(self.tcx));\n+                cmt.ty.user_string());\n         }\n     }\n "}, {"sha": "657115e781925b7250a15f640a1c2ececf57ad5c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -1031,7 +1031,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                            Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"resolve_trait_associated_const: trait_substs={}\",\n-           trait_substs.repr(tcx));\n+           trait_substs.repr());\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n \n@@ -1055,7 +1055,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                               &format!(\"Encountered error `{}` when trying \\\n                                         to select an implementation for \\\n                                         constant trait item reference.\",\n-                                       e.repr(tcx)))\n+                                       e.repr()))\n         }\n     };\n "}, {"sha": "7a593da3432c944388d9dbfd3ee27844758ec12c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {}\",\n-                 base_type.repr(self.tcx));\n+                 base_type.repr());\n         match base_type.sty {\n             ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => if ty::TyStr == ty.sty {\n                 span_err!(self.tcx.sess, e.span, E0134,\n@@ -143,7 +143,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 let method_call = MethodCall::expr(expr.id);\n                 let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n                 debug!(\"effect: method call case, base type is {}\",\n-                        base_type.repr(self.tcx));\n+                        base_type.repr());\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n@@ -152,15 +152,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             ast::ExprCall(ref base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: call case, base type is {}\",\n-                        base_type.repr(self.tcx));\n+                        base_type.repr());\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n-                        base_type.repr(self.tcx));\n+                        base_type.repr());\n                 if let ty::TyRawPtr(_) = base_type.sty {\n                     self.require_unsafe(expr.span, \"dereference of raw pointer\")\n                 }"}, {"sha": "7d4f93fb1326f81e3023b9fc15c99e1df96ae209", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -363,7 +363,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         consume_span: Span,\n                         cmt: mc::cmt<'tcx>) {\n         debug!(\"delegate_consume(consume_id={}, cmt={})\",\n-               consume_id, cmt.repr(self.tcx()));\n+               consume_id, cmt.repr());\n \n         let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n@@ -376,7 +376,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n-        debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n+        debug!(\"consume_expr(expr={})\", expr.repr());\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n@@ -398,7 +398,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n         debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n-               expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n+               expr.repr(), r.repr(), bk.repr());\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n@@ -414,7 +414,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     pub fn walk_expr(&mut self, expr: &ast::Expr) {\n-        debug!(\"walk_expr(expr={})\", expr.repr(self.tcx()));\n+        debug!(\"walk_expr(expr={})\", expr.repr());\n \n         self.walk_adjustment(expr);\n \n@@ -619,7 +619,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n         let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n-               callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n+               callee.repr(), callee_ty.repr());\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n         match callee_ty.sty {\n             ty::TyBareFn(..) => {\n@@ -637,7 +637,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         None => {\n                             self.tcx().sess.span_bug(\n                                 callee.span,\n-                                &format!(\"unexpected callee type {}\", callee_ty.repr(self.tcx())))\n+                                &format!(\"unexpected callee type {}\", callee_ty.repr()))\n                         }\n                     };\n                 match overloaded_call_type {\n@@ -811,7 +811,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoderefs(&mut self,\n                        expr: &ast::Expr,\n                        autoderefs: usize) {\n-        debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n+        debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(), autoderefs);\n \n         for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n@@ -829,7 +829,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 &format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())))\n+                                    method_ty.repr()))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -843,8 +843,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                          expr: &ast::Expr,\n                          adj: &ty::AutoDerefRef<'tcx>) {\n         debug!(\"walk_autoderefref expr={} adj={}\",\n-               expr.repr(self.tcx()),\n-               adj.repr(self.tcx()));\n+               expr.repr(),\n+               adj.repr());\n \n         self.walk_autoderefs(expr, adj.autoderefs);\n \n@@ -877,7 +877,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={} opt_autoref={:?})\",\n                expr.id,\n-               cmt_base.repr(self.tcx()),\n+               cmt_base.repr(),\n                opt_autoref);\n \n         let cmt_base_ty = cmt_base.ty;\n@@ -903,7 +903,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ty::AutoUnsafe(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n                        expr.id,\n-                       cmt_base.repr(self.tcx()));\n+                       cmt_base.repr());\n \n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n@@ -1011,8 +1011,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                cmt_discr: mc::cmt<'tcx>,\n                                pat: &ast::Pat,\n                                mode: &mut TrackMatchMode) {\n-        debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n-               pat.repr(self.tcx()));\n+        debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(),\n+               pat.repr());\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.tcx();\n             let def_map = &self.tcx().def_map;\n@@ -1043,8 +1043,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 cmt_discr: mc::cmt<'tcx>,\n                 pat: &ast::Pat,\n                 match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n-               pat.repr(self.tcx()));\n+        debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(),\n+               pat.repr());\n \n         let mc = &self.mc;\n         let typer = self.typer;\n@@ -1055,8 +1055,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 let tcx = typer.tcx();\n \n                 debug!(\"binding cmt_pat={} pat={} match_mode={:?}\",\n-                       cmt_pat.repr(tcx),\n-                       pat.repr(tcx),\n+                       cmt_pat.repr(),\n+                       pat.repr(),\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n@@ -1161,8 +1161,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 };\n \n                             debug!(\"variant downcast_cmt={} pat={}\",\n-                                   downcast_cmt.repr(tcx),\n-                                   pat.repr(tcx));\n+                                   downcast_cmt.repr(),\n+                                   pat.repr());\n \n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n@@ -1173,8 +1173,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // e.g. patterns for unit structs).\n \n                             debug!(\"struct cmt_pat={} pat={}\",\n-                                   cmt_pat.repr(tcx),\n-                                   pat.repr(tcx));\n+                                   cmt_pat.repr(),\n+                                   pat.repr());\n \n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n@@ -1194,7 +1194,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             if !tcx.sess.has_errors() {\n                                 let msg = format!(\"Pattern has unexpected type: {:?} and type {}\",\n                                                   def,\n-                                                  cmt_pat.ty.repr(tcx));\n+                                                  cmt_pat.ty.repr());\n                                 tcx.sess.span_bug(pat.span, &msg)\n                             }\n                         }\n@@ -1211,7 +1211,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             if !tcx.sess.has_errors() {\n                                 let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n-                                                  cmt_pat.ty.repr(tcx));\n+                                                  cmt_pat.ty.repr());\n                                 tcx.sess.span_bug(pat.span, &msg[..])\n                             }\n                         }\n@@ -1237,7 +1237,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n-        debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n+        debug!(\"walk_captures({})\", closure_expr.repr());\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n             for freevar in freevars {"}, {"sha": "a245de3deae38fa583b2c81b5084c0e25f8fc8c7", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -33,7 +33,7 @@ impl FreeRegionMap {\n                                                        implications: &[Implication<'tcx>])\n     {\n         for implication in implications {\n-            debug!(\"implication: {}\", implication.repr(tcx));\n+            debug!(\"implication: {}\", implication.repr());\n             match *implication {\n                 Implication::RegionSubRegion(_, ty::ReFree(free_a), ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n@@ -50,7 +50,7 @@ impl FreeRegionMap {\n     pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n                                                      tcx: &ty::ctxt<'tcx>,\n                                                      predicates: &[ty::Predicate<'tcx>]) {\n-        debug!(\"relate_free_regions_from_predicates(predicates={})\", predicates.repr(tcx));\n+        debug!(\"relate_free_regions_from_predicates(predicates={})\", predicates.repr());\n         for predicate in predicates {\n             match *predicate {\n                 ty::Predicate::Projection(..) |\n@@ -69,8 +69,8 @@ impl FreeRegionMap {\n                             // All named regions are instantiated with free regions.\n                             tcx.sess.bug(\n                                 &format!(\"record_region_bounds: non free region: {} / {}\",\n-                                         r_a.repr(tcx),\n-                                         r_b.repr(tcx)));\n+                                         r_a.repr(),\n+                                         r_b.repr()));\n                         }\n                     }\n                 }"}, {"sha": "599ecc6e7a97a9f020298315e22079730c31aae1", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -55,8 +55,8 @@ pub fn implications<'a,'tcx>(\n {\n     debug!(\"implications(body_id={}, ty={}, outer_region={})\",\n            body_id,\n-           ty.repr(closure_typer.tcx()),\n-           outer_region.repr(closure_typer.tcx()));\n+           ty.repr(),\n+           outer_region.repr());\n \n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n@@ -68,7 +68,7 @@ pub fn implications<'a,'tcx>(\n                               out: Vec::new(),\n                               visited: FnvHashSet() };\n     wf.accumulate_from_ty(ty);\n-    debug!(\"implications: out={}\", wf.out.repr(closure_typer.tcx()));\n+    debug!(\"implications: out={}\", wf.out.repr());\n     wf.out\n }\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n     fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n         debug!(\"accumulate_from_ty(ty={})\",\n-               ty.repr(self.tcx()));\n+               ty.repr());\n \n         // When expanding out associated types, we can visit a cyclic\n         // set of types. Issue #23003.\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                                               data: &ty::PolyTraitPredicate<'tcx>)\n     {\n         debug!(\"accumulate_from_assoc_types_transitive({})\",\n-               data.repr(self.tcx()));\n+               data.repr());\n \n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n             match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                                    trait_ref: ty::TraitRef<'tcx>)\n     {\n         debug!(\"accumulate_from_assoc_types({})\",\n-               trait_ref.repr(self.tcx()));\n+               trait_ref.repr());\n \n         let trait_def_id = trait_ref.def_id;\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                      .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n                      .collect();\n         debug!(\"accumulate_from_assoc_types: assoc_type_projections={}\",\n-               assoc_type_projections.repr(self.tcx()));\n+               assoc_type_projections.repr());\n         let tys = match self.fully_normalize(&assoc_type_projections) {\n             Ok(tys) => { tys }\n             Err(ErrorReported) => { return; }\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes + Clone + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes + Clone + Repr\n     {\n         let value =\n             traits::fully_normalize(self.infcx,\n@@ -455,32 +455,32 @@ pub fn object_region_bounds<'tcx>(\n     ty::required_region_bounds(tcx, open_ty, predicates)\n }\n \n-impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for Implication<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             Implication::RegionSubRegion(_, ref r_a, ref r_b) => {\n                 format!(\"RegionSubRegion({}, {})\",\n-                        r_a.repr(tcx),\n-                        r_b.repr(tcx))\n+                        r_a.repr(),\n+                        r_b.repr())\n             }\n \n             Implication::RegionSubGeneric(_, ref r, ref p) => {\n                 format!(\"RegionSubGeneric({}, {})\",\n-                        r.repr(tcx),\n-                        p.repr(tcx))\n+                        r.repr(),\n+                        p.repr())\n             }\n \n             Implication::RegionSubClosure(_, ref a, ref b, ref c) => {\n                 format!(\"RegionSubClosure({}, {}, {})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx))\n+                        a.repr(),\n+                        b.repr(),\n+                        c.repr())\n             }\n \n             Implication::Predicate(ref def_id, ref p) => {\n                 format!(\"Predicate({}, {})\",\n-                        def_id.repr(tcx),\n-                        p.repr(tcx))\n+                        def_id.repr(),\n+                        p.repr())\n             }\n         }\n     }"}, {"sha": "87eb08955117f0111c9491a4ecf10209c2afe14b", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+               a.repr(), b.repr());\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;"}, {"sha": "decd07b87c07a20534970d813f89cb5468385f70", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -214,9 +214,9 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n             };\n \n             debug!(\"instantiate(a_ty={} dir={:?} b_vid={})\",\n-                   a_ty.repr(tcx),\n+                   a_ty.repr(),\n                    dir,\n-                   b_vid.repr(tcx));\n+                   b_vid.repr());\n \n             // Check whether `vid` has been instantiated yet.  If not,\n             // make a generalized form of `ty` and instantiate with\n@@ -232,8 +232,8 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                     });\n                     debug!(\"instantiate(a_ty={}, dir={:?}, \\\n                                         b_vid={}, generalized_ty={})\",\n-                           a_ty.repr(tcx), dir, b_vid.repr(tcx),\n-                           generalized_ty.repr(tcx));\n+                           a_ty.repr(), dir, b_vid.repr(),\n+                           generalized_ty.repr());\n                     self.infcx.type_variables\n                         .borrow_mut()\n                         .instantiate_and_push(\n@@ -336,7 +336,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx())));\n+                            r.repr()));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "0d97535ed3abeb834ce687db3d7823d8e7822fff", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+               a.repr(), b.repr());\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -77,8 +77,8 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a.repr(),\n+               b.repr());\n         let origin = Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n         Ok(a)"}, {"sha": "fa324c57bcd064d6d30c9df2edbc30edc06a45e6", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -170,7 +170,7 @@ pub fn note_and_explain_region(tcx: &ty::ctxt,\n                 ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n                 _ => {\n                     format!(\"the lifetime {} as defined on\",\n-                            fr.bound_region.user_string(tcx))\n+                            fr.bound_region.user_string())\n                 }\n             };\n \n@@ -229,7 +229,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n+    fn expected_found_str<T: UserString + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n+    fn expected_found_str<T: UserString + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -523,8 +523,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         Some(format!(\"expected `{}`, found `{}`\",\n-                     expected.user_string(self.tcx),\n-                     found.user_string(self.tcx)))\n+                     expected.user_string(),\n+                     found.user_string()))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -540,9 +540,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n-                format!(\"the parameter type `{}`\", p.user_string(self.tcx)),\n+                format!(\"the parameter type `{}`\", p.user_string()),\n             GenericKind::Projection(ref p) =>\n-                format!(\"the associated type `{}`\", p.user_string(self.tcx)),\n+                format!(\"the associated type `{}`\", p.user_string()),\n         };\n \n         match sub {\n@@ -554,8 +554,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                        bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx)));\n+                        bound_kind.user_string(),\n+                        sub.user_string()));\n             }\n \n             ty::ReStatic => {\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx)));\n+                        bound_kind.user_string()));\n             }\n \n             _ => {\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx)));\n+                        bound_kind.user_string()));\n                 note_and_explain_region(\n                     self.tcx,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n@@ -1561,7 +1561,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let br_string = |br: ty::BoundRegion| {\n-            let mut s = br.user_string(self.tcx);\n+            let mut s = br.user_string();\n             if !s.is_empty() {\n                 s.push_str(\" \");\n             }"}, {"sha": "b611565c151ca0deb668de24210b833947292539", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -57,8 +57,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a.repr(),\n+               b.repr());\n \n         let origin = Subtype(self.fields.trace.clone());\n         Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))"}, {"sha": "d38de0f5a3f650a75555f3eb3937501e4b24acae", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -49,7 +49,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n         let tcx = self.infcx.tcx;\n \n         debug!(\"higher_ranked_sub(a={}, b={})\",\n-               a.repr(tcx), b.repr(tcx));\n+               a.repr(), b.repr());\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -75,8 +75,8 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             let (b_prime, skol_map) =\n                 self.infcx.skolemize_late_bound_regions(b, snapshot);\n \n-            debug!(\"a_prime={}\", a_prime.repr(tcx));\n-            debug!(\"b_prime={}\", b_prime.repr(tcx));\n+            debug!(\"a_prime={}\", a_prime.repr());\n+            debug!(\"b_prime={}\", b_prime.repr());\n \n             // Compare types now that bound regions have been replaced.\n             let result = try!(self.sub().relate(&a_prime, &b_prime));\n@@ -99,7 +99,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             }\n \n             debug!(\"higher_ranked_sub: OK result={}\",\n-                   result.repr(tcx));\n+                   result.repr());\n \n             Ok(ty::Binder(result))\n         });\n@@ -125,7 +125,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n+            debug!(\"lub result0 = {}\", result0.repr());\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n@@ -138,9 +138,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                                                     &new_vars, &a_map, r));\n \n             debug!(\"lub({},{}) = {}\",\n-                   a.repr(self.tcx()),\n-                   b.repr(self.tcx()),\n-                   result1.repr(self.tcx()));\n+                   a.repr(),\n+                   b.repr(),\n+                   result1.repr());\n \n             Ok(ty::Binder(result1))\n         });\n@@ -199,7 +199,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n         where T: Relate<'a,'tcx>\n     {\n         debug!(\"higher_ranked_glb({}, {})\",\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+               a.repr(), b.repr());\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -219,7 +219,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n+            debug!(\"glb result0 = {}\", result0.repr());\n \n             // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n@@ -234,9 +234,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                                                     r));\n \n             debug!(\"glb({},{}) = {}\",\n-                   a.repr(self.tcx()),\n-                   b.repr(self.tcx()),\n-                   result1.repr(self.tcx()));\n+                   a.repr(),\n+                   b.repr(),\n+                   result1.repr());\n \n             Ok(ty::Binder(result1))\n         });\n@@ -452,8 +452,8 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n         });\n \n         debug!(\"region_vars_confined_to_snapshot: region_vars={} escaping_types={}\",\n-               region_vars.repr(self.tcx),\n-               escaping_types.repr(self.tcx));\n+               region_vars.repr(),\n+               escaping_types.repr());\n \n         region_vars\n     }\n@@ -520,7 +520,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)\n                                                -> (T, SkolemizationMap)\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     /*!\n      * Replace all regions bound by `binder` with skolemized regions and\n@@ -535,9 +535,9 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     });\n \n     debug!(\"skolemize_bound_regions(binder={}, result={}, map={})\",\n-           binder.repr(infcx.tcx),\n-           result.repr(infcx.tcx),\n-           map.repr(infcx.tcx));\n+           binder.repr(),\n+           result.repr(),\n+           map.repr());\n \n     (result, map)\n }\n@@ -556,7 +556,7 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n      */\n \n     debug!(\"leak_check: skol_map={}\",\n-           skol_map.repr(infcx.tcx));\n+           skol_map.repr());\n \n     let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n     for (&skol_br, &skol) in skol_map {\n@@ -574,9 +574,9 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             };\n \n             debug!(\"{} (which replaced {}) is tainted by {}\",\n-                   skol.repr(infcx.tcx),\n-                   skol_br.repr(infcx.tcx),\n-                   tainted_region.repr(infcx.tcx));\n+                   skol.repr(),\n+                   skol_br.repr(),\n+                   tainted_region.repr());\n \n             // A is not as polymorphic as B:\n             return Err((skol_br, tainted_region));\n@@ -618,13 +618,13 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                              snapshot: &CombinedSnapshot,\n                              value: &T)\n                              -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n \n     debug!(\"plug_leaks(skol_map={}, value={})\",\n-           skol_map.repr(infcx.tcx),\n-           value.repr(infcx.tcx));\n+           skol_map.repr(),\n+           value.repr());\n \n     // Compute a mapping from the \"taint set\" of each skolemized\n     // region back to the `ty::BoundRegion` that it originally\n@@ -641,7 +641,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         .collect();\n \n     debug!(\"plug_leaks: inv_skol_map={}\",\n-           inv_skol_map.repr(infcx.tcx));\n+           inv_skol_map.repr());\n \n     // Remove any instantiated type variables from `value`; those can hide\n     // references to regions from the `fold_regions` code below.\n@@ -670,7 +670,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     });\n \n     debug!(\"plug_leaks: result={}\",\n-           result.repr(infcx.tcx));\n+           result.repr());\n \n     result\n }"}, {"sha": "6257b6e6a257964337ecf4bebb256dacfe7382e0", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -53,8 +53,8 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n-           a.repr(this.tcx()),\n-           b.repr(this.tcx()));\n+           a.repr(),\n+           b.repr());\n \n     if a == b {\n         return Ok(a);"}, {"sha": "f4ba639547bf1cfc8df723ccc14ad94c459f682d", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -57,8 +57,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a.repr(),\n+               b.repr());\n \n         let origin = Subtype(self.fields.trace.clone());\n         Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))"}, {"sha": "02a73cfb770520a6934b0e0da7ab5903bfb2831c", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -331,7 +331,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                   -> Ty<'tcx>\n {\n     debug!(\"common_supertype({}, {})\",\n-           a.repr(cx.tcx), b.repr(cx.tcx));\n+           a.repr(), b.repr());\n \n     let trace = TypeTrace {\n         origin: origin,\n@@ -355,15 +355,15 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           b: Ty<'tcx>)\n                           -> UnitResult<'tcx>\n {\n-    debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_subty({} <: {})\", a.repr(), b.repr());\n     cx.sub_types(a_is_expected, origin, a, b)\n }\n \n pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               a: Ty<'tcx>,\n                               b: Ty<'tcx>)\n                               -> UnitResult<'tcx> {\n-    debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"can_mk_subty({} <: {})\", a.repr(), b.repr());\n     cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n@@ -383,7 +383,7 @@ pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: SubregionOrigin<'tcx>,\n                          a: ty::Region,\n                          b: ty::Region) {\n-    debug!(\"mk_subr({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_subr({} <: {})\", a.repr(), b.repr());\n     let snapshot = cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit(snapshot);\n@@ -396,7 +396,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          b: Ty<'tcx>)\n                          -> UnitResult<'tcx>\n {\n-    debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    debug!(\"mk_eqty({} <: {})\", a.repr(), b.repr());\n     cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n }\n \n@@ -408,7 +408,7 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    -> UnitResult<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n-           a.repr(cx.tcx), b.repr(cx.tcx));\n+           a.repr(), b.repr());\n     cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n@@ -637,7 +637,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      b: Ty<'tcx>)\n                      -> UnitResult<'tcx>\n     {\n-        debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        debug!(\"sub_types({} <: {})\", a.repr(), b.repr());\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n@@ -665,8 +665,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           -> UnitResult<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+               a.repr(),\n+               b.repr());\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n@@ -684,8 +684,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                -> UnitResult<'tcx>\n     {\n         debug!(\"sub_poly_trait_refs({} <: {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+               a.repr(),\n+               b.repr());\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n                                            -> (T, SkolemizationMap)\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         /*! See `higher_ranked::skolemize_late_bound_regions` */\n \n@@ -733,7 +733,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                          snapshot: &CombinedSnapshot,\n                          value: &T)\n                          -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         /*! See `higher_ranked::plug_leaks` */\n \n@@ -861,7 +861,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(&t).user_string(self.tcx)\n+        self.resolve_type_vars_if_possible(&t).user_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -871,7 +871,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n         let t = self.resolve_type_vars_if_possible(t);\n-        t.user_string(self.tcx)\n+        t.user_string()\n     }\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n@@ -1033,7 +1033,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         ty_fold::replace_late_bound_regions(\n             self.tcx,\n@@ -1048,17 +1048,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 a: ty::Region,\n                                 bs: Vec<ty::Region>) {\n         debug!(\"verify_generic_bound({}, {} <: {})\",\n-               kind.repr(self.tcx),\n-               a.repr(self.tcx),\n-               bs.repr(self.tcx));\n+               kind.repr(),\n+               a.repr(),\n+               bs.repr());\n \n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n \n     pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'b,'tcx> + Repr<'tcx>\n+        where T: Relate<'b,'tcx> + Repr\n     {\n-        debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        debug!(\"can_equate({}, {})\", a.repr(), b.repr());\n         self.probe(|_| {\n             // Gin up a dummy trace, since this won't be committed\n             // anyhow. We should make this typetrace stuff more\n@@ -1099,9 +1099,9 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TypeTrace<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"TypeTrace({})\", self.origin.repr(tcx))\n+impl<'tcx> Repr for TypeTrace<'tcx> {\n+    fn repr(&self) -> String {\n+        format!(\"TypeTrace({})\", self.origin.repr())\n     }\n }\n \n@@ -1123,39 +1123,39 @@ impl TypeOrigin {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TypeOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr for TypeOrigin {\n+    fn repr(&self) -> String {\n         match *self {\n             MethodCompatCheck(a) => {\n-                format!(\"MethodCompatCheck({})\", a.repr(tcx))\n+                format!(\"MethodCompatCheck({})\", a.repr())\n             }\n             ExprAssignable(a) => {\n-                format!(\"ExprAssignable({})\", a.repr(tcx))\n+                format!(\"ExprAssignable({})\", a.repr())\n             }\n-            Misc(a) => format!(\"Misc({})\", a.repr(tcx)),\n+            Misc(a) => format!(\"Misc({})\", a.repr()),\n             RelateTraitRefs(a) => {\n-                format!(\"RelateTraitRefs({})\", a.repr(tcx))\n+                format!(\"RelateTraitRefs({})\", a.repr())\n             }\n             RelateSelfType(a) => {\n-                format!(\"RelateSelfType({})\", a.repr(tcx))\n+                format!(\"RelateSelfType({})\", a.repr())\n             }\n             RelateOutputImplTypes(a) => {\n-                format!(\"RelateOutputImplTypes({})\", a.repr(tcx))\n+                format!(\"RelateOutputImplTypes({})\", a.repr())\n             }\n             MatchExpressionArm(a, b) => {\n-                format!(\"MatchExpressionArm({}, {})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"MatchExpressionArm({}, {})\", a.repr(), b.repr())\n             }\n             IfExpression(a) => {\n-                format!(\"IfExpression({})\", a.repr(tcx))\n+                format!(\"IfExpression({})\", a.repr())\n             }\n             IfExpressionWithNoElse(a) => {\n-                format!(\"IfExpressionWithNoElse({})\", a.repr(tcx))\n+                format!(\"IfExpressionWithNoElse({})\", a.repr())\n             }\n             RangeExpression(a) => {\n-                format!(\"RangeExpression({})\", a.repr(tcx))\n+                format!(\"RangeExpression({})\", a.repr())\n             }\n             EquatePredicate(a) => {\n-                format!(\"EquatePredicate({})\", a.repr(tcx))\n+                format!(\"EquatePredicate({})\", a.repr())\n             }\n         }\n     }\n@@ -1190,66 +1190,66 @@ impl<'tcx> SubregionOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for SubregionOrigin<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             Subtype(ref a) => {\n-                format!(\"Subtype({})\", a.repr(tcx))\n+                format!(\"Subtype({})\", a.repr())\n             }\n             InfStackClosure(a) => {\n-                format!(\"InfStackClosure({})\", a.repr(tcx))\n+                format!(\"InfStackClosure({})\", a.repr())\n             }\n             InvokeClosure(a) => {\n-                format!(\"InvokeClosure({})\", a.repr(tcx))\n+                format!(\"InvokeClosure({})\", a.repr())\n             }\n             DerefPointer(a) => {\n-                format!(\"DerefPointer({})\", a.repr(tcx))\n+                format!(\"DerefPointer({})\", a.repr())\n             }\n             FreeVariable(a, b) => {\n-                format!(\"FreeVariable({}, {})\", a.repr(tcx), b)\n+                format!(\"FreeVariable({}, {})\", a.repr(), b)\n             }\n             IndexSlice(a) => {\n-                format!(\"IndexSlice({})\", a.repr(tcx))\n+                format!(\"IndexSlice({})\", a.repr())\n             }\n             RelateObjectBound(a) => {\n-                format!(\"RelateObjectBound({})\", a.repr(tcx))\n+                format!(\"RelateObjectBound({})\", a.repr())\n             }\n             RelateParamBound(a, b) => {\n                 format!(\"RelateParamBound({},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx))\n+                        a.repr(),\n+                        b.repr())\n             }\n             RelateRegionParamBound(a) => {\n                 format!(\"RelateRegionParamBound({})\",\n-                        a.repr(tcx))\n+                        a.repr())\n             }\n             RelateDefaultParamBound(a, b) => {\n                 format!(\"RelateDefaultParamBound({},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx))\n+                        a.repr(),\n+                        b.repr())\n             }\n-            Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n+            Reborrow(a) => format!(\"Reborrow({})\", a.repr()),\n             ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n+                format!(\"ReborrowUpvar({},{:?})\", a.repr(), b)\n             }\n             ReferenceOutlivesReferent(_, a) => {\n-                format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))\n+                format!(\"ReferenceOutlivesReferent({})\", a.repr())\n             }\n             ExprTypeIsNotInScope(a, b) => {\n                 format!(\"ExprTypeIsNotInScope({}, {})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx))\n+                        a.repr(),\n+                        b.repr())\n             }\n             BindingTypeIsNotValidAtDecl(a) => {\n-                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr(tcx))\n+                format!(\"BindingTypeIsNotValidAtDecl({})\", a.repr())\n             }\n-            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr(tcx)),\n-            CallArg(a) => format!(\"CallArg({})\", a.repr(tcx)),\n-            CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n-            Operand(a) => format!(\"Operand({})\", a.repr(tcx)),\n-            AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n-            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n-            SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr(tcx)),\n+            CallRcvr(a) => format!(\"CallRcvr({})\", a.repr()),\n+            CallArg(a) => format!(\"CallArg({})\", a.repr()),\n+            CallReturn(a) => format!(\"CallReturn({})\", a.repr()),\n+            Operand(a) => format!(\"Operand({})\", a.repr()),\n+            AddrOf(a) => format!(\"AddrOf({})\", a.repr()),\n+            AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr()),\n+            SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr()),\n         }\n     }\n }\n@@ -1270,31 +1270,31 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionVariableOrigin {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for RegionVariableOrigin {\n+    fn repr(&self) -> String {\n         match *self {\n             MiscVariable(a) => {\n-                format!(\"MiscVariable({})\", a.repr(tcx))\n+                format!(\"MiscVariable({})\", a.repr())\n             }\n             PatternRegion(a) => {\n-                format!(\"PatternRegion({})\", a.repr(tcx))\n+                format!(\"PatternRegion({})\", a.repr())\n             }\n             AddrOfRegion(a) => {\n-                format!(\"AddrOfRegion({})\", a.repr(tcx))\n+                format!(\"AddrOfRegion({})\", a.repr())\n             }\n-            Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            Autoref(a) => format!(\"Autoref({})\", a.repr()),\n+            Coercion(a) => format!(\"Coercion({})\", a.repr()),\n             EarlyBoundRegion(a, b) => {\n-                format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"EarlyBoundRegion({},{})\", a.repr(), b.repr())\n             }\n             LateBoundRegion(a, b, c) => {\n-                format!(\"LateBoundRegion({},{},{:?})\", a.repr(tcx), b.repr(tcx), c)\n+                format!(\"LateBoundRegion({},{},{:?})\", a.repr(), b.repr(), c)\n             }\n             BoundRegionInCoherence(a) => {\n-                format!(\"bound_regionInCoherence({})\", a.repr(tcx))\n+                format!(\"bound_regionInCoherence({})\", a.repr())\n             }\n             UpvarRegion(a, b) => {\n-                format!(\"UpvarRegion({}, {})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"UpvarRegion({}, {})\", a.repr(), b.repr())\n             }\n         }\n     }"}, {"sha": "be606e6fa4afd072ef17d14b387e50261c6844e2", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -191,13 +191,13 @@ impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n             Node::RegionVid(n_vid) =>\n                 dot::LabelText::label(format!(\"{:?}\", n_vid)),\n             Node::Region(n_rgn) =>\n-                dot::LabelText::label(format!(\"{}\", n_rgn.repr(self.tcx))),\n+                dot::LabelText::label(format!(\"{}\", n_rgn.repr())),\n         }\n     }\n     fn edge_label(&self, e: &Edge) -> dot::LabelText {\n         match *e {\n             Edge::Constraint(ref c) =>\n-                dot::LabelText::label(format!(\"{}\", self.map.get(c).unwrap().repr(self.tcx))),\n+                dot::LabelText::label(format!(\"{}\", self.map.get(c).unwrap().repr())),\n             Edge::EnclScope(..) =>\n                 dot::LabelText::label(format!(\"(enclosed)\")),\n         }"}, {"sha": "066083d27c73dfcea0637db8e5868aaf9075d524", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n         debug!(\"created new region variable {:?} with origin {}\",\n-               vid, origin.repr(self.tcx));\n+               vid, origin.repr());\n         return vid;\n     }\n \n@@ -392,7 +392,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: add_constraint({})\",\n-               constraint.repr(self.tcx));\n+               constraint.repr());\n \n         if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n             if self.in_snapshot() {\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: add_verify({})\",\n-               verify.repr(self.tcx));\n+               verify.repr());\n \n         let mut verifys = self.verifys.borrow_mut();\n         let index = verifys.len();\n@@ -426,7 +426,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n             debug!(\"add_given({} <= {:?})\",\n-                   sub.repr(self.tcx),\n+                   sub.repr(),\n                    sup);\n \n             self.undo_log.borrow_mut().push(AddGiven(sub, sup));\n@@ -453,9 +453,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: make_subregion({}, {}) due to {}\",\n-               sub.repr(self.tcx),\n-               sup.repr(self.tcx),\n-               origin.repr(self.tcx));\n+               sub.repr(),\n+               sup.repr(),\n+               origin.repr());\n \n         match (sub, sup) {\n           (ReEarlyBound(..), ReEarlyBound(..)) => {\n@@ -472,8 +472,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n                 &format!(\"cannot relate bound region: {} <= {}\",\n-                        sub.repr(self.tcx),\n-                        sup.repr(self.tcx)));\n+                        sub.repr(),\n+                        sup.repr()));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -511,8 +511,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: lub_regions({}, {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+               a.repr(),\n+               b.repr());\n         match (a, b) {\n             (ReStatic, _) | (_, ReStatic) => {\n                 ReStatic // nothing lives longer than static\n@@ -536,8 +536,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: glb_regions({}, {})\",\n-               a.repr(self.tcx),\n-               b.repr(self.tcx));\n+               a.repr(),\n+               b.repr());\n         match (a, b) {\n             (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n-                debug!(\"resolve_var({:?}) = {}\", rid, r.repr(self.tcx));\n+                debug!(\"resolve_var({:?}) = {}\", rid, r.repr());\n                 r\n             }\n         }\n@@ -620,7 +620,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n     pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={:?}, r0={})\", mark, r0.repr(self.tcx));\n+        debug!(\"tainted(mark={:?}, r0={})\", mark, r0.repr());\n         let _indenter = indenter();\n \n         // `result_set` acts as a worklist: we explore all outgoing\n@@ -732,8 +732,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (_, ReEarlyBound(..)) => {\n             self.tcx.sess.bug(\n                 &format!(\"cannot relate bound region: LUB({}, {})\",\n-                        a.repr(self.tcx),\n-                        b.repr(self.tcx)));\n+                        a.repr(),\n+                        b.repr()));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -837,8 +837,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (_, ReEarlyBound(..)) => {\n               self.tcx.sess.bug(\n                   &format!(\"cannot relate bound region: GLB({}, {})\",\n-                          a.repr(self.tcx),\n-                          b.repr(self.tcx)));\n+                          a.repr(),\n+                          b.repr()));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -1013,18 +1013,18 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn dump_constraints(&self) {\n         debug!(\"----() Start constraint listing ()----\");\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n-            debug!(\"Constraint {} => {}\", idx, constraint.repr(self.tcx));\n+            debug!(\"Constraint {} => {}\", idx, constraint.repr());\n         }\n     }\n \n     fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={} origin={}\",\n-                   constraint.repr(self.tcx),\n+                   constraint.repr(),\n                    self.constraints.borrow()\n                                    .get(constraint)\n                                    .unwrap()\n-                                   .repr(self.tcx));\n+                                   .repr());\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.index as usize];\n@@ -1055,9 +1055,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    -> bool\n     {\n         debug!(\"expand_node({}, {:?} == {})\",\n-               a_region.repr(self.tcx),\n+               a_region.repr(),\n                b_vid,\n-               b_data.value.repr(self.tcx));\n+               b_data.value.repr());\n \n         // Check if this relationship is implied by a given.\n         match a_region {\n@@ -1074,7 +1074,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match b_data.value {\n           NoValue => {\n             debug!(\"Setting initial value of {:?} to {}\",\n-                   b_vid, a_region.repr(self.tcx));\n+                   b_vid, a_region.repr());\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -1088,8 +1088,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n             debug!(\"Expanding value of {:?} from {} to {}\",\n                    b_vid,\n-                   cur_region.repr(self.tcx),\n-                   lub.repr(self.tcx));\n+                   cur_region.repr(),\n+                   lub.repr());\n \n             b_data.value = Value(lub);\n             return true;\n@@ -1106,11 +1106,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                    var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n             debug!(\"contraction: constraint={} origin={}\",\n-                   constraint.repr(self.tcx),\n+                   constraint.repr(),\n                    self.constraints.borrow()\n                                    .get(constraint)\n                                    .unwrap()\n-                                   .repr(self.tcx));\n+                                   .repr());\n             match *constraint {\n               ConstrainRegSubVar(..) => {\n                 // This is an expansion constraint.  Ignore.\n@@ -1140,8 +1140,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                      b_region: Region)\n                      -> bool {\n         debug!(\"contract_node({:?} == {}/{:?}, {})\",\n-               a_vid, a_data.value.repr(self.tcx),\n-               a_data.classification, b_region.repr(self.tcx));\n+               a_vid, a_data.value.repr(),\n+               a_data.classification, b_region.repr());\n \n         return match a_data.value {\n             NoValue => {\n@@ -1173,8 +1173,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             if !free_regions.is_subregion_of(this.tcx, a_region, b_region) {\n                 debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n                        a_vid,\n-                       a_region.repr(this.tcx),\n-                       b_region.repr(this.tcx));\n+                       a_region.repr(),\n+                       b_region.repr());\n                 a_data.value = ErrorValue;\n             }\n             false\n@@ -1194,17 +1194,17 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     } else {\n                         debug!(\"Contracting value of {:?} from {} to {}\",\n                                a_vid,\n-                               a_region.repr(this.tcx),\n-                               glb.repr(this.tcx));\n+                               a_region.repr(),\n+                               glb.repr());\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n                     debug!(\"Setting {:?} to ErrorValue: no glb of {}, {}\",\n                            a_vid,\n-                           a_region.repr(this.tcx),\n-                           b_region.repr(this.tcx));\n+                           a_region.repr(),\n+                           b_region.repr());\n                     a_data.value = ErrorValue;\n                     false\n                 }\n@@ -1230,8 +1230,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     }\n \n                     debug!(\"ConcreteFailure: !(sub <= sup): sub={}, sup={}\",\n-                           sub.repr(self.tcx),\n-                           sup.repr(self.tcx));\n+                           sub.repr(),\n+                           sup.repr());\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n@@ -1433,8 +1433,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             &format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n-                    lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx)));\n+                    lower_bounds.repr(),\n+                    upper_bounds.repr()));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1480,7 +1480,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx)));\n+                    upper_bounds.repr()));\n     }\n \n     fn collect_concrete_regions(&self,\n@@ -1579,7 +1579,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {}\",\n-                           constraint.repr(self.tcx));\n+                           constraint.repr());\n                     changed = true;\n                 }\n             }\n@@ -1589,31 +1589,31 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n }\n \n-impl<'tcx> Repr<'tcx> for Constraint {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl Repr for Constraint {\n+    fn repr(&self) -> String {\n         match *self {\n             ConstrainVarSubVar(a, b) => {\n-                format!(\"ConstrainVarSubVar({}, {})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"ConstrainVarSubVar({}, {})\", a.repr(), b.repr())\n             }\n             ConstrainRegSubVar(a, b) => {\n-                format!(\"ConstrainRegSubVar({}, {})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"ConstrainRegSubVar({}, {})\", a.repr(), b.repr())\n             }\n             ConstrainVarSubReg(a, b) => {\n-                format!(\"ConstrainVarSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"ConstrainVarSubReg({}, {})\", a.repr(), b.repr())\n             }\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Verify<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for Verify<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             VerifyRegSubReg(_, ref a, ref b) => {\n-                format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n+                format!(\"VerifyRegSubReg({}, {})\", a.repr(), b.repr())\n             }\n             VerifyGenericBound(_, ref p, ref a, ref bs) => {\n                 format!(\"VerifyGenericBound({}, {}, {})\",\n-                        p.repr(tcx), a.repr(tcx), bs.repr(tcx))\n+                        p.repr(), a.repr(), bs.repr())\n             }\n         }\n     }\n@@ -1634,38 +1634,38 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for VarValue {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl Repr for VarValue {\n+    fn repr(&self) -> String {\n         match *self {\n             NoValue => format!(\"NoValue\"),\n-            Value(r) => format!(\"Value({})\", r.repr(tcx)),\n+            Value(r) => format!(\"Value({})\", r.repr()),\n             ErrorValue => format!(\"ErrorValue\"),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionAndOrigin<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for RegionAndOrigin<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"RegionAndOrigin({},{})\",\n-                self.region.repr(tcx),\n-                self.origin.repr(tcx))\n+                self.region.repr(),\n+                self.origin.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for GenericKind<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for GenericKind<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n-            GenericKind::Param(ref p) => p.repr(tcx),\n-            GenericKind::Projection(ref p) => p.repr(tcx),\n+            GenericKind::Param(ref p) => p.repr(),\n+            GenericKind::Projection(ref p) => p.repr(),\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for GenericKind<'tcx> {\n-    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for GenericKind<'tcx> {\n+    fn user_string(&self) -> String {\n         match *self {\n-            GenericKind::Param(ref p) => p.user_string(tcx),\n-            GenericKind::Projection(ref p) => p.user_string(tcx),\n+            GenericKind::Param(ref p) => p.user_string(),\n+            GenericKind::Projection(ref p) => p.user_string(),\n         }\n     }\n }"}, {"sha": "c22aa6a4f996e679d87503595743495474ba5fe5", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 ty::TyInfer(_) => {\n                     self.infcx.tcx.sess.bug(\n                         &format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx)));\n+                                t.repr()));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "24eae6307fafdfced0ebda4ee1066ac673506123", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(), b.repr());\n \n         if a == b { return Ok(a); }\n \n@@ -87,8 +87,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a.repr(),\n+               b.repr());\n         let origin = Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n         Ok(a)"}, {"sha": "a3ea726f0f2f949940f5354cebb268a194162da7", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -203,14 +203,14 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         match types_in_scope.next() {\n             None => {\n                 debug!(\"with_each_combination(substs={})\",\n-                       substs.repr(self.tcx));\n+                       substs.repr());\n \n                 callback(substs);\n             }\n \n             Some((space, index, &param_ty)) => {\n                 debug!(\"with_each_combination: space={:?}, index={}, param_ty={}\",\n-                       space, index, param_ty.repr(self.tcx));\n+                       space, index, param_ty.repr());\n \n                 if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n-        debug!(\"Pushing transmute restriction: {}\", restriction.repr(self.tcx));\n+        debug!(\"Pushing transmute restriction: {}\", restriction.repr());\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n }\n@@ -277,13 +277,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TransmuteRestriction<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for TransmuteRestriction<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TransmuteRestriction(id={}, original=({},{}), substituted=({},{}))\",\n                 self.id,\n-                self.original_from.repr(tcx),\n-                self.original_to.repr(tcx),\n-                self.substituted_from.repr(tcx),\n-                self.substituted_to.repr(tcx))\n+                self.original_from.repr(),\n+                self.original_to.repr(),\n+                self.substituted_from.repr(),\n+                self.substituted_to.repr())\n     }\n }"}, {"sha": "a3e12db6644abf30d39f071b58b6da77716aea20", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -437,7 +437,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             _ => base_ty,\n         };\n         debug!(\"pat_ty(pat={}) base_ty={} ret_ty={}\",\n-               pat.repr(tcx), base_ty.repr(tcx), ret_ty.repr(tcx));\n+               pat.repr(), base_ty.repr(), ret_ty.repr());\n         Ok(ret_ty)\n     }\n \n@@ -461,8 +461,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     ty::AdjustUnsafeFnPointer |\n                     ty::AdjustDerefRef(_) => {\n                         debug!(\"cat_expr({}): {}\",\n-                               adjustment.repr(self.tcx()),\n-                               expr.repr(self.tcx()));\n+                               adjustment.repr(),\n+                               expr.repr());\n                         // Result is an rvalue.\n                         let expr_ty = try!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n@@ -479,15 +479,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let mut cmt = try!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n-               cmt.repr(self.tcx()));\n+               cmt.repr());\n         for deref in 1..autoderefs + 1 {\n             cmt = try!(self.cat_deref(expr, cmt, deref, None));\n         }\n         return Ok(cmt);\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n+        debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr());\n \n         let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n@@ -500,8 +500,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             let base_cmt = try!(self.cat_expr(&**base));\n             debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n                    expr.id,\n-                   expr.repr(self.tcx()),\n-                   base_cmt.repr(self.tcx()));\n+                   expr.repr(),\n+                   base_cmt.repr());\n             Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n@@ -525,7 +525,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         ty::TyRef(_, mt) => mt.ty,\n                         _ => {\n                             debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n-                                   ret_ty.repr(self.tcx()));\n+                                   ret_ty.repr());\n                             return Err(());\n                         }\n                     };\n@@ -584,7 +584,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    def: def::Def)\n                    -> McResult<cmt<'tcx>> {\n         debug!(\"cat_def: id={} expr={} def={:?}\",\n-               id, expr_ty.repr(self.tcx()), def);\n+               id, expr_ty.repr(), def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n@@ -637,7 +637,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           &format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx())));\n+                                  ty.repr()));\n                   }\n               }\n           }\n@@ -746,7 +746,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let ret = Rc::new(cmt_result);\n-        debug!(\"cat_upvar ret={}\", ret.repr(self.tcx()));\n+        debug!(\"cat_upvar ret={}\", ret.repr());\n         Ok(ret)\n     }\n \n@@ -817,7 +817,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             note: NoteClosureEnv(upvar_id)\n         };\n \n-        debug!(\"env_deref ret {}\", ret.repr(self.tcx()));\n+        debug!(\"env_deref ret {}\", ret.repr());\n \n         ret\n     }\n@@ -855,7 +855,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty::ReStatic\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n-        debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_rvalue_node ret {}\", ret.repr());\n         ret\n     }\n \n@@ -872,7 +872,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty:expr_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_rvalue ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_rvalue ret {}\", ret.repr());\n         ret\n     }\n \n@@ -890,7 +890,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: f_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_field ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_field ret {}\", ret.repr());\n         ret\n     }\n \n@@ -908,7 +908,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: f_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_tup_field ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_tup_field ret {}\", ret.repr());\n         ret\n     }\n \n@@ -925,7 +925,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let method_ty = self.typer.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n-               method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n+               method_call, method_ty.map(|ty| ty.repr()));\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n@@ -943,12 +943,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                               mt.ty,\n                                               deref_context,\n                                                 /* implicit: */ false);\n-                debug!(\"cat_deref ret {}\", ret.repr(self.tcx()));\n+                debug!(\"cat_deref ret {}\", ret.repr());\n                 ret\n             }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n-                       base_cmt_ty.repr(self.tcx()));\n+                       base_cmt_ty.repr());\n                 return Err(());\n             }\n         }\n@@ -991,7 +991,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: deref_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_deref_common ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_deref_common ret {}\", ret.repr());\n         Ok(ret)\n     }\n \n@@ -1042,7 +1042,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let m = base_cmt.mutbl.inherit();\n         let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n                            m, context, element_ty);\n-        debug!(\"cat_index ret {}\", ret.repr(self.tcx()));\n+        debug!(\"cat_index ret {}\", ret.repr());\n         return Ok(ret);\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n@@ -1096,7 +1096,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 base_cmt\n             }\n         };\n-        debug!(\"deref_vec ret {}\", ret.repr(self.tcx()));\n+        debug!(\"deref_vec ret {}\", ret.repr());\n         Ok(ret)\n     }\n \n@@ -1155,7 +1155,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: interior_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_imm_interior ret={}\", ret.repr(self.tcx()));\n+        debug!(\"cat_imm_interior ret={}\", ret.repr());\n         ret\n     }\n \n@@ -1173,7 +1173,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             ty: downcast_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_downcast ret={}\", ret.repr(self.tcx()));\n+        debug!(\"cat_downcast ret={}\", ret.repr());\n         ret\n     }\n \n@@ -1235,7 +1235,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_string(pat),\n-               cmt.repr(self.tcx()));\n+               cmt.repr());\n \n         (*op)(self, cmt.clone(), pat);\n \n@@ -1521,7 +1521,7 @@ impl<'tcx> cmt_<'tcx> {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&cat_upvar(ref var)) => {\n-                        var.user_string(tcx)\n+                        var.user_string()\n                     }\n                     Some(_) => unreachable!(),\n                     None => {\n@@ -1561,7 +1561,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"pattern-bound indexed content\".to_string()\n             }\n             cat_upvar(ref var) => {\n-                var.user_string(tcx)\n+                var.user_string()\n             }\n             cat_downcast(ref cmt, _) => {\n                 cmt.descriptive_string(tcx)\n@@ -1570,18 +1570,18 @@ impl<'tcx> cmt_<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for cmt_<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for cmt_<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n-                self.cat.repr(tcx),\n+                self.cat.repr(),\n                 self.id,\n                 self.mutbl,\n-                self.ty.repr(tcx))\n+                self.ty.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for categorization<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n@@ -1590,13 +1590,13 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n-                format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr.repr(tcx), derefs)\n+                format!(\"{}-{}{}->\", cmt.cat.repr(), ptr.repr(), derefs)\n             }\n             cat_interior(ref cmt, interior) => {\n-                format!(\"{}.{}\", cmt.cat.repr(tcx), interior.repr(tcx))\n+                format!(\"{}.{}\", cmt.cat.repr(), interior.repr())\n             }\n             cat_downcast(ref cmt, _) => {\n-                format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n+                format!(\"{}->(enum)\", cmt.cat.repr())\n             }\n         }\n     }\n@@ -1615,23 +1615,23 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for PointerKind {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl Repr for PointerKind {\n+    fn repr(&self) -> String {\n         match *self {\n             Unique => {\n                 format!(\"Box\")\n             }\n             BorrowedPtr(ty::ImmBorrow, ref r) |\n             Implicit(ty::ImmBorrow, ref r) => {\n-                format!(\"&{}\", r.repr(tcx))\n+                format!(\"&{}\", r.repr())\n             }\n             BorrowedPtr(ty::MutBorrow, ref r) |\n             Implicit(ty::MutBorrow, ref r) => {\n-                format!(\"&{} mut\", r.repr(tcx))\n+                format!(\"&{} mut\", r.repr())\n             }\n             BorrowedPtr(ty::UniqueImmBorrow, ref r) |\n             Implicit(ty::UniqueImmBorrow, ref r) => {\n-                format!(\"&{} uniq\", r.repr(tcx))\n+                format!(\"&{} uniq\", r.repr())\n             }\n             UnsafePtr(_) => {\n                 format!(\"*\")\n@@ -1640,8 +1640,8 @@ impl<'tcx> Repr<'tcx> for PointerKind {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for InteriorKind {\n-    fn repr(&self, _tcx: &ty::ctxt) -> String {\n+impl Repr for InteriorKind {\n+    fn repr(&self) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).to_string()\n@@ -1664,20 +1664,20 @@ fn element_kind(t: Ty) -> ElementKind {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ClosureKind {\n-    fn repr(&self, _: &ty::ctxt) -> String {\n+impl Repr for ty::ClosureKind {\n+    fn repr(&self) -> String {\n         format!(\"Upvar({:?})\", self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Upvar {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Upvar({})\", self.kind.repr(tcx))\n+impl Repr for Upvar {\n+    fn repr(&self) -> String {\n+        format!(\"Upvar({})\", self.kind.repr())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for Upvar {\n-    fn user_string(&self, _: &ty::ctxt) -> String {\n+impl UserString for Upvar {\n+    fn user_string(&self) -> String {\n         let kind = match self.kind {\n             ty::FnClosureKind => \"Fn\",\n             ty::FnMutClosureKind => \"FnMut\","}, {"sha": "3fec62cd8b481b8a8bf6669fe336bce81068f3c0", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -450,7 +450,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                     tcx.sess.span_bug(e.span,\n                                       &format!(\"stability::check_expr: struct construction \\\n                                                 of non-struct, type {:?}\",\n-                                               type_.repr(tcx)));\n+                                               type_.repr()));\n                 }\n             }\n         }\n@@ -551,7 +551,7 @@ pub fn lookup<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability>\n }\n \n fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    debug!(\"lookup(id={})\", id.repr(tcx));\n+    debug!(\"lookup(id={})\", id.repr());\n \n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {"}, {"sha": "8f6e85a17b128b361a56f52be4a27af86cc84ca7", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -623,7 +623,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                               when substituting in region {} (root type={}) \\\n                                               (space={:?}, index={})\",\n                                              data.name.as_str(),\n-                                             self.root_ty.repr(self.tcx()),\n+                                             self.root_ty.repr(),\n                                              data.space,\n                                              data.index));\n                             }\n@@ -677,12 +677,12 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                     span,\n                     &format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n-                            p.repr(self.tcx()),\n-                            source_ty.repr(self.tcx()),\n+                            p.repr(),\n+                            source_ty.repr(),\n                             p.space,\n                             p.idx,\n-                            self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx())));\n+                            self.root_ty.repr(),\n+                            self.substs.repr()));\n             }\n         };\n \n@@ -733,14 +733,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, type_has_escaping_regions={:?})\",\n-               ty.repr(self.tcx()), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+               ty.repr(), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n \n         if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n             return ty;\n         }\n \n         let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {:?}\", result.repr(self.tcx()));\n+        debug!(\"shift_regions: shifted result = {:?}\", result.repr());\n \n         result\n     }"}, {"sha": "b7568b565cec970d943de1557b66240d2dd4c6c3", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -36,8 +36,8 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={}, \\\n            impl2_def_id={})\",\n-           impl1_def_id.repr(infcx.tcx),\n-           impl2_def_id.repr(infcx.tcx));\n+           impl1_def_id.repr(),\n+           impl2_def_id.repr());\n \n     let param_env = &ty::empty_parameter_environment(infcx.tcx);\n     let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n@@ -54,8 +54,8 @@ fn overlap(selcx: &mut SelectionContext,\n            -> bool\n {\n     debug!(\"overlap(a_def_id={}, b_def_id={})\",\n-           a_def_id.repr(selcx.tcx()),\n-           b_def_id.repr(selcx.tcx()));\n+           a_def_id.repr(),\n+           b_def_id.repr());\n \n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                 a_def_id,\n@@ -65,9 +65,9 @@ fn overlap(selcx: &mut SelectionContext,\n                                                                 b_def_id,\n                                                                 util::fresh_type_vars_for_impl);\n \n-    debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+    debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr());\n \n-    debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n+    debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr());\n \n     // Does `a <: b` hold? If not, no overlap.\n     if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n@@ -90,7 +90,7 @@ fn overlap(selcx: &mut SelectionContext,\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(tcx));\n+        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr());\n         return false\n     }\n \n@@ -99,7 +99,7 @@ fn overlap(selcx: &mut SelectionContext,\n \n pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n-    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr(tcx));\n+    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr());\n \n     // if the orphan rules pass, that means that no ancestor crate can\n     // impl this, so it's up to us.\n@@ -181,17 +181,17 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           impl_def_id: ast::DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check({})\", impl_def_id.repr(tcx));\n+    debug!(\"orphan_check({})\", impl_def_id.repr());\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n-    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr());\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n         debug!(\"trait {} is local to current crate\",\n-               trait_ref.def_id.repr(tcx));\n+               trait_ref.def_id.repr());\n         return Ok(());\n     }\n \n@@ -204,7 +204,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check_trait_ref(trait_ref={}, infer_is_local={})\",\n-           trait_ref.repr(tcx), infer_is_local.0);\n+           trait_ref.repr(), infer_is_local.0);\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n@@ -215,14 +215,14 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // some local type.\n     for input_ty in input_tys {\n         if ty_is_local(tcx, input_ty, infer_is_local) {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr());\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n             let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n             for uncovered_ty in uncovered_tys {\n                 if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n-                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr());\n                     return Err(OrphanCheckErr::UncoveredTy(param));\n                 }\n             }\n@@ -235,7 +235,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // parameters reachable.\n         if !infer_is_local.0 {\n             if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n-                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr());\n                 return Err(OrphanCheckErr::UncoveredTy(param));\n             }\n         }\n@@ -295,7 +295,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  infer_is_local: InferIsLocal)\n                                  -> bool\n {\n-    debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n+    debug!(\"ty_is_local_constructor({})\", ty.repr());\n \n     match ty.sty {\n         ty::TyBool |\n@@ -337,7 +337,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::TyError => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx)))\n+                        ty.repr()))\n         }\n     }\n }"}, {"sha": "72f162638929fe91f39dd133fba01eaac83622b2", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -68,7 +68,7 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n         span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n-                predicate.user_string(infcx.tcx),\n+                predicate.user_string(),\n                 ty::type_err_to_str(infcx.tcx, &error.err));\n         note_obligation_cause(infcx, obligation);\n     }\n@@ -87,16 +87,16 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 item.meta().span\n             };\n             let def = ty::lookup_trait_def(infcx.tcx, def_id);\n-            let trait_str = def.trait_ref.user_string(infcx.tcx);\n+            let trait_str = def.trait_ref.user_string();\n             if let Some(ref istring) = item.value_str() {\n                 let mut generic_map = def.generics.types.iter_enumerated()\n                                          .map(|(param, i, gen)| {\n                                                (gen.name.as_str().to_string(),\n                                                 trait_ref.substs.types.get(param, i)\n-                                                         .user_string(infcx.tcx))\n+                                                         .user_string())\n                                               }).collect::<HashMap<String, String>>();\n                 generic_map.insert(\"Self\".to_string(),\n-                                   trait_ref.self_ty().user_string(infcx.tcx));\n+                                   trait_ref.self_ty().user_string());\n                 let parser = Parser::new(&istring);\n                 let mut errored = false;\n                 let err: String = parser.filter_map(|p| {\n@@ -157,13 +157,13 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                           obligation: &Obligation<'tcx, T>)\n                                           -> !\n-    where T: UserString<'tcx> + TypeFoldable<'tcx>\n+    where T: UserString + TypeFoldable<'tcx>\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n               \"overflow evaluating the requirement `{}`\",\n-              predicate.user_string(infcx.tcx));\n+              predicate.user_string());\n \n     suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -184,7 +184,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string(infcx.tcx));;\n+                            obligation.predicate.user_string());;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -197,8 +197,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n-                                        trait_ref.user_string(infcx.tcx),\n-                                        trait_ref.self_ty().user_string(infcx.tcx));\n+                                        trait_ref.user_string(),\n+                                        trait_ref.self_ty().user_string());\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n@@ -216,7 +216,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                &predicate).err().unwrap();\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate.user_string(infcx.tcx),\n+                                    predicate.user_string(),\n                                     ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n@@ -226,7 +226,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                       &predicate).err().unwrap();\n                             span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n-                                    predicate.user_string(infcx.tcx),\n+                                    predicate.user_string(),\n                                     ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n@@ -235,7 +235,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string(infcx.tcx));\n+                                        predicate.user_string());\n                         }\n                     }\n                 }\n@@ -249,9 +249,9 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty().user_string(infcx.tcx),\n-                        expected_trait_ref.user_string(infcx.tcx),\n-                        actual_trait_ref.user_string(infcx.tcx),\n+                        expected_trait_ref.self_ty().user_string(),\n+                        expected_trait_ref.user_string(),\n+                        actual_trait_ref.user_string(),\n                         ty::type_err_to_str(infcx.tcx, e));\n                     note_obligation_cause(infcx, obligation);\n             }\n@@ -282,7 +282,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.sess.span_note(\n                             obligation.cause.span,\n                             &format!(\"method `{}` has no receiver\",\n-                                    method.name.user_string(infcx.tcx)));\n+                                    method.name.user_string()));\n                     }\n \n                     ObjectSafetyViolation::Method(method,\n@@ -291,15 +291,15 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             obligation.cause.span,\n                             &format!(\"method `{}` references the `Self` type \\\n                                     in its arguments or return type\",\n-                                    method.name.user_string(infcx.tcx)));\n+                                    method.name.user_string()));\n                     }\n \n                     ObjectSafetyViolation::Method(method,\n                             MethodViolationCode::Generic) => {\n                         infcx.tcx.sess.span_note(\n                             obligation.cause.span,\n                             &format!(\"method `{}` has generic type parameters\",\n-                                    method.name.user_string(infcx.tcx)));\n+                                    method.name.user_string()));\n                     }\n                 }\n             }\n@@ -317,8 +317,8 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     let predicate = infcx.resolve_type_vars_if_possible(&obligation.predicate);\n \n     debug!(\"maybe_report_ambiguity(predicate={}, obligation={})\",\n-           predicate.repr(infcx.tcx),\n-           obligation.repr(infcx.tcx));\n+           predicate.repr(),\n+           obligation.repr());\n \n     match predicate {\n         ty::Predicate::Trait(ref data) => {\n@@ -349,11 +349,11 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations or generic parameter binding required\",\n-                                self_ty.user_string(infcx.tcx));\n+                                self_ty.user_string());\n                     } else {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string(infcx.tcx));;\n+                                predicate.user_string());;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -365,16 +365,16 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         \"coherence failed to report ambiguity: \\\n                          cannot locate the impl of the trait `{}` for \\\n                          the type `{}`\",\n-                        trait_ref.user_string(infcx.tcx),\n-                        self_ty.user_string(infcx.tcx)));\n+                        trait_ref.user_string(),\n+                        self_ty.user_string()));\n             }\n         }\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n                 span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string(infcx.tcx));;\n+                        predicate.user_string());;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -383,7 +383,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                       obligation: &Obligation<'tcx, T>)\n-    where T: UserString<'tcx>\n+    where T: UserString\n {\n     note_obligation_cause_code(infcx,\n                                &obligation.predicate,\n@@ -395,7 +395,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                            predicate: &T,\n                                            cause_span: Span,\n                                            cause_code: &ObligationCauseCode<'tcx>)\n-    where T: UserString<'tcx>\n+    where T: UserString\n {\n     let tcx = infcx.tcx;\n     match *cause_code {\n@@ -463,24 +463,24 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n                        \"required because it appears within the type `{}`\",\n-                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+                       parent_trait_ref.0.self_ty().user_string());\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n                        \"required because of the requirements on the impl of `{}` for `{}`\",\n-                       parent_trait_ref.user_string(infcx.tcx),\n-                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+                       parent_trait_ref.user_string(),\n+                       parent_trait_ref.0.self_ty().user_string());\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             span_note!(tcx.sess, cause_span,\n                       \"the requirement `{}` appears on the impl method \\\n                       but not on the corresponding trait method\",\n-                      predicate.user_string(infcx.tcx));\n+                      predicate.user_string());\n         }\n     }\n }"}, {"sha": "8615a7822bea94d61e7d4518f61b5416bc9254c5", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                          -> Ty<'tcx>\n     {\n         debug!(\"normalize_associated_type(projection_ty={})\",\n-               projection_ty.repr(infcx.tcx));\n+               projection_ty.repr());\n \n         assert!(!projection_ty.has_escaping_regions());\n \n@@ -151,7 +151,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n \n-        debug!(\"normalize_associated_type: result={}\", normalized.value.repr(infcx.tcx));\n+        debug!(\"normalize_associated_type: result={}\", normalized.value.repr());\n \n         normalized.value\n     }\n@@ -190,11 +190,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         assert!(!obligation.has_escaping_regions());\n \n         if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n-            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n+            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr());\n             return;\n         }\n \n-        debug!(\"register_predicate({})\", obligation.repr(infcx.tcx));\n+        debug!(\"register_predicate({})\", obligation.repr());\n         self.predicates.push(obligation);\n     }\n \n@@ -380,8 +380,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 }\n                 Err(selection_err) => {\n                     debug!(\"predicate: {} error: {}\",\n-                           obligation.repr(tcx),\n-                           selection_err.repr(tcx));\n+                           obligation.repr(),\n+                           selection_err.repr());\n                     errors.push(\n                         FulfillmentError::new(\n                             obligation.clone(),\n@@ -441,8 +441,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             let project_obligation = obligation.with(data.clone());\n             let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n             debug!(\"process_predicate: poly_project_and_unify_type({}) returned {}\",\n-                   project_obligation.repr(tcx),\n-                   result.repr(tcx));\n+                   project_obligation.repr(),\n+                   result.repr());\n             match result {\n                 Ok(Some(obligations)) => {\n                     new_obligations.extend(obligations);\n@@ -463,11 +463,11 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for RegionObligation<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"RegionObligation(sub_region={}, sup_type={})\",\n-                self.sub_region.repr(tcx),\n-                self.sup_type.repr(tcx))\n+                self.sub_region.repr(),\n+                self.sup_type.repr())\n     }\n }\n \n@@ -482,7 +482,7 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                cause: cause };\n \n     debug!(\"register_region_obligation({})\",\n-           region_obligation.repr(tcx));\n+           region_obligation.repr());\n \n     region_obligations.entry(region_obligation.cause.body_id).or_insert(vec![])\n         .push(region_obligation);"}, {"sha": "036aaedb446decc643aabf348bd65f556af356d4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -321,7 +321,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                                  -> bool\n {\n     debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={:?})\",\n-           ty.repr(infcx.tcx),\n+           ty.repr(),\n            bound);\n \n     let mut fulfill_cx = FulfillmentContext::new(false);\n@@ -339,15 +339,15 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     match fulfill_cx.select_all_or_error(infcx, typer) {\n         Ok(()) => {\n             debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} success\",\n-                   ty.repr(infcx.tcx),\n+                   ty.repr(),\n                    bound);\n             true\n         }\n         Err(e) => {\n             debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} errors={}\",\n-                   ty.repr(infcx.tcx),\n+                   ty.repr(),\n                    bound,\n-                   e.repr(infcx.tcx));\n+                   e.repr());\n             false\n         }\n     }\n@@ -378,7 +378,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     let body_id = cause.body_id;\n \n     debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n-           unnormalized_env.repr(tcx));\n+           unnormalized_env.repr());\n \n     let predicates: Vec<_> =\n         util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.clone())\n@@ -394,7 +394,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     // -nmatsakis\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={}\",\n-           predicates.repr(tcx));\n+           predicates.repr());\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n@@ -434,25 +434,25 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n {\n     let tcx = closure_typer.tcx();\n \n-    debug!(\"normalize_param_env(value={})\", value.repr(tcx));\n+    debug!(\"normalize_param_env(value={})\", value.repr());\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n     let mut fulfill_cx = FulfillmentContext::new(false);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n     debug!(\"normalize_param_env: normalized_value={} obligations={}\",\n-           normalized_value.repr(tcx),\n-           obligations.repr(tcx));\n+           normalized_value.repr(),\n+           obligations.repr());\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n     try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={}\", resolved_value.repr(tcx));\n+    debug!(\"normalize_param_env: resolved_value={}\", resolved_value.repr());\n     Ok(resolved_value)\n }\n "}, {"sha": "9be973c7018939eeead8c20f37347ec2e6020cd5", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -70,7 +70,7 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n         result\n     });\n \n-    debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n+    debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(), result);\n \n     result\n }\n@@ -112,8 +112,8 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     debug!(\"object_safety_violations_for_trait(trait_def_id={}) = {}\",\n-           trait_def_id.repr(tcx),\n-           violations.repr(tcx));\n+           trait_def_id.repr(),\n+           violations.repr());\n \n     violations\n }\n@@ -352,15 +352,15 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n     error\n }\n \n-impl<'tcx> Repr<'tcx> for ObjectSafetyViolation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ObjectSafetyViolation<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             ObjectSafetyViolation::SizedSelf =>\n                 format!(\"SizedSelf\"),\n             ObjectSafetyViolation::SupertraitSelf =>\n                 format!(\"SupertraitSelf\"),\n             ObjectSafetyViolation::Method(ref m, code) =>\n-                format!(\"Method({},{:?})\", m.repr(tcx), code),\n+                format!(\"Method({},{:?})\", m.repr(), code),\n         }\n     }\n }"}, {"sha": "ef89dc384bbd951aec07e9dd4a00fbef85b90389", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -77,7 +77,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n     debug!(\"poly_project_and_unify_type(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+           obligation.repr());\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n@@ -110,7 +110,7 @@ fn project_and_unify_type<'cx,'tcx>(\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n     debug!(\"project_and_unify_type(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+           obligation.repr());\n \n     let Normalized { value: normalized_ty, obligations } =\n         match opt_normalize_projection_type(selcx,\n@@ -125,8 +125,8 @@ fn project_and_unify_type<'cx,'tcx>(\n         };\n \n     debug!(\"project_and_unify_type: normalized_ty={} obligations={}\",\n-           normalized_ty.repr(selcx.tcx()),\n-           obligations.repr(selcx.tcx()));\n+           normalized_ty.repr(),\n+           obligations.repr());\n \n     let infcx = selcx.infcx();\n     let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n@@ -139,7 +139,7 @@ fn project_and_unify_type<'cx,'tcx>(\n fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n                                                     obligation: &ProjectionObligation<'tcx>) {\n     debug!(\"consider_unification_despite_ambiguity(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+           obligation.repr());\n \n     let def_id = obligation.predicate.projection_ty.trait_ref.def_id;\n     match selcx.tcx().lang_items.fn_trait_kind(def_id) {\n@@ -173,7 +173,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n                     &ty::Binder(ret_type));\n \n             debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n-                   ret_type.repr(selcx.tcx()));\n+                   ret_type.repr());\n             let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n@@ -193,7 +193,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n@@ -204,7 +204,7 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n                                           depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n     let result = normalizer.fold(value);\n@@ -356,7 +356,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     debug!(\"normalize_projection_type(\\\n            projection_ty={}, \\\n            depth={})\",\n-           projection_ty.repr(selcx.tcx()),\n+           projection_ty.repr(),\n            depth);\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n@@ -368,17 +368,17 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n             // re-normalize it\n \n             debug!(\"normalize_projection_type: projected_ty={} depth={} obligations={}\",\n-                   projected_ty.repr(selcx.tcx()),\n+                   projected_ty.repr(),\n                    depth,\n-                   obligations.repr(selcx.tcx()));\n+                   obligations.repr());\n \n             if ty::type_has_projection(projected_ty) {\n                 let tcx = selcx.tcx();\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n                 debug!(\"normalize_projection_type: normalized_ty={} depth={}\",\n-                       normalized_ty.repr(tcx),\n+                       normalized_ty.repr(),\n                        depth);\n \n                 obligations.extend(normalizer.obligations);\n@@ -395,7 +395,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\"normalize_projection_type: projected_ty={} no progress\",\n-                   projected_ty.repr(selcx.tcx()));\n+                   projected_ty.repr());\n             Some(Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n@@ -450,7 +450,7 @@ fn project_type<'cx,'tcx>(\n     -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n     debug!(\"project(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+           obligation.repr());\n \n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n@@ -461,7 +461,7 @@ fn project_type<'cx,'tcx>(\n     let obligation_trait_ref =\n         selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n \n-    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr(selcx.tcx()));\n+    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr());\n \n     if obligation_trait_ref.references_error() {\n         return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n@@ -590,11 +590,11 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n     debug!(\"assemble_candidates_from_predicates(obligation={})\",\n-           obligation.repr(selcx.tcx()));\n+           obligation.repr());\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={}\",\n-               predicate.repr(selcx.tcx()));\n+               predicate.repr());\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n@@ -612,7 +612,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate {} is_match {} same_name {}\",\n-                       data.repr(selcx.tcx()),\n+                       data.repr(),\n                        is_match,\n                        same_name);\n \n@@ -635,14 +635,14 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n {\n     let infcx = selcx.infcx();\n     debug!(\"assemble_candidates_from_object_type(object_ty={})\",\n-           object_ty.repr(infcx.tcx));\n+           object_ty.repr());\n     let data = match object_ty.sty {\n         ty::TyTrait(ref data) => data,\n         _ => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n                 &format!(\"assemble_candidates_from_object_type called with non-object: {}\",\n-                         object_ty.repr(selcx.tcx())));\n+                         object_ty.repr()));\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -673,15 +673,15 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n         }\n         Err(e) => {\n             debug!(\"assemble_candidates_from_impls: selection error {}\",\n-                   e.repr(selcx.tcx()));\n+                   e.repr());\n             return Err(e);\n         }\n     };\n \n     match vtable {\n         super::VtableImpl(data) => {\n             debug!(\"assemble_candidates_from_impls: impl candidate {}\",\n-                   data.repr(selcx.tcx()));\n+                   data.repr());\n \n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Impl(data));\n@@ -732,7 +732,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n                 &format!(\"Cannot project an associated type from `{}`\",\n-                         vtable.repr(selcx.tcx())));\n+                         vtable.repr()));\n         }\n     }\n \n@@ -748,8 +748,8 @@ fn confirm_candidate<'cx,'tcx>(\n     let infcx = selcx.infcx();\n \n     debug!(\"confirm_candidate(candidate={}, obligation={})\",\n-           candidate.repr(infcx.tcx),\n-           obligation.repr(infcx.tcx));\n+           candidate.repr(),\n+           obligation.repr());\n \n     match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection) => {\n@@ -814,8 +814,8 @@ fn confirm_callable_candidate<'cx,'tcx>(\n     let tcx = selcx.tcx();\n \n     debug!(\"confirm_callable_candidate({},{})\",\n-           obligation.repr(tcx),\n-           fn_sig.repr(tcx));\n+           obligation.repr(),\n+           fn_sig.repr());\n \n     // the `Output` associated type is declared on `FnOnce`\n     let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n@@ -866,8 +866,8 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,\n                 &format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n-                         obligation.repr(selcx.tcx()),\n-                         projection.repr(selcx.tcx()),\n+                         obligation.repr(),\n+                         projection.repr(),\n                          ty::type_err_to_str(selcx.tcx(), &e)));\n         }\n     }\n@@ -916,31 +916,31 @@ fn confirm_impl_candidate<'cx,'tcx>(\n \n     selcx.tcx().sess.span_bug(obligation.cause.span,\n                               &format!(\"No associated type for {}\",\n-                                       trait_ref.repr(selcx.tcx())));\n+                                       trait_ref.repr()));\n }\n \n-impl<'tcx> Repr<'tcx> for ProjectionTyError<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ProjectionTyError<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             ProjectionTyError::TooManyCandidates =>\n                 format!(\"NoCandidate\"),\n             ProjectionTyError::TraitSelectionError(ref e) =>\n-                format!(\"TraitSelectionError({})\", e.repr(tcx)),\n+                format!(\"TraitSelectionError({})\", e.repr()),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ProjectionTyCandidate<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             ProjectionTyCandidate::ParamEnv(ref data) =>\n-                format!(\"ParamEnv({})\", data.repr(tcx)),\n+                format!(\"ParamEnv({})\", data.repr()),\n             ProjectionTyCandidate::Impl(ref data) =>\n-                format!(\"Impl({})\", data.repr(tcx)),\n+                format!(\"Impl({})\", data.repr()),\n             ProjectionTyCandidate::Closure(ref data) =>\n-                format!(\"Closure({})\", data.repr(tcx)),\n+                format!(\"Closure({})\", data.repr()),\n             ProjectionTyCandidate::FnPointer(a) =>\n-                format!(\"FnPointer(({}))\", a.repr(tcx)),\n+                format!(\"FnPointer(({}))\", a.repr()),\n         }\n     }\n }\n@@ -954,10 +954,10 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Normalized<'tcx, T> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, T:Repr> Repr for Normalized<'tcx, T> {\n+    fn repr(&self) -> String {\n         format!(\"Normalized({},{})\",\n-                self.value.repr(tcx),\n-                self.obligations.repr(tcx))\n+                self.value.repr(),\n+                self.obligations.repr())\n     }\n }"}, {"sha": "ea5d789683f410a74330ed72447a52fadf3e1bae", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -298,7 +298,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// type environment by performing unification.\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n-        debug!(\"select({})\", obligation.repr(self.tcx()));\n+        debug!(\"select({})\", obligation.repr());\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n@@ -388,7 +388,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                -> bool\n     {\n         debug!(\"evaluate_obligation({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n             .may_apply()\n@@ -441,7 +441,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_predicate_recursively({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         // Check the cache from the tcx of predicates that we know\n         // have been proven elsewhere. This cache only contains\n@@ -500,7 +500,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         let stack = self.push_stack(previous_stack, obligation);\n \n@@ -548,7 +548,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                      &prev.fresh_trait_ref)))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n-                   stack.fresh_trait_ref.repr(self.tcx()));\n+                   stack.fresh_trait_ref.repr());\n             return EvaluatedToAmbig;\n         }\n \n@@ -577,7 +577,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .any(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n             debug!(\"evaluate_stack({}) --> recursive\",\n-                   stack.fresh_trait_ref.repr(self.tcx()));\n+                   stack.fresh_trait_ref.repr());\n             return EvaluatedToOk;\n         }\n \n@@ -596,8 +596,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          -> bool\n     {\n         debug!(\"evaluate_impl(impl_def_id={}, obligation={})\",\n-               impl_def_id.repr(self.tcx()),\n-               obligation.repr(self.tcx()));\n+               impl_def_id.repr(),\n+               obligation.repr());\n \n         self.infcx.probe(|snapshot| {\n             match self.match_impl(impl_def_id, obligation, snapshot) {\n@@ -644,15 +644,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let cache_fresh_trait_pred =\n             self.infcx.freshen(stack.obligation.predicate.clone());\n         debug!(\"candidate_from_obligation(cache_fresh_trait_pred={}, obligation={})\",\n-               cache_fresh_trait_pred.repr(self.tcx()),\n-               stack.repr(self.tcx()));\n+               cache_fresh_trait_pred.repr(),\n+               stack.repr());\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n         match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n                 debug!(\"CACHE HIT: cache_fresh_trait_pred={}, candidate={}\",\n-                       cache_fresh_trait_pred.repr(self.tcx()),\n-                       c.repr(self.tcx()));\n+                       cache_fresh_trait_pred.repr(),\n+                       c.repr());\n                 return c;\n             }\n             None => { }\n@@ -663,7 +663,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n             debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n-                   cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n+                   cache_fresh_trait_pred.repr(), candidate.repr());\n             self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         }\n \n@@ -694,8 +694,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"assembled {} candidates for {}: {}\",\n                candidates.len(),\n-               stack.repr(self.tcx()),\n-               candidates.repr(self.tcx()));\n+               stack.repr(),\n+               candidates.repr());\n \n         // At this point, we know that each of the entries in the\n         // candidate set is *individually* applicable. Now we have to\n@@ -736,11 +736,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                                           &candidates[j]));\n                 if is_dup {\n                     debug!(\"Dropping candidate #{}/{}: {}\",\n-                           i, candidates.len(), candidates[i].repr(self.tcx()));\n+                           i, candidates.len(), candidates[i].repr());\n                     candidates.swap_remove(i);\n                 } else {\n                     debug!(\"Retaining candidate #{}/{}: {}\",\n-                           i, candidates.len(), candidates[i].repr(self.tcx()));\n+                           i, candidates.len(), candidates[i].repr());\n                     i += 1;\n                 }\n             }\n@@ -907,7 +907,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n-                       obligation.predicate.0.self_ty().repr(self.tcx()));\n+                       obligation.predicate.0.self_ty().repr());\n \n                 // User-defined copy impls are permitted, but only for\n                 // structs and enums.\n@@ -958,8 +958,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n \n         debug!(\"assemble_candidates_for_projected_tys({},{})\",\n-               obligation.repr(self.tcx()),\n-               poly_trait_predicate.repr(self.tcx()));\n+               obligation.repr(),\n+               poly_trait_predicate.repr());\n \n         // FIXME(#20297) -- just examining the self-type is very simplistic\n \n@@ -982,7 +982,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         debug!(\"assemble_candidates_for_projected_tys: trait_def_id={}\",\n-               trait_def_id.repr(self.tcx()));\n+               trait_def_id.repr());\n \n         let result = self.infcx.probe(|snapshot| {\n             self.match_projection_obligation_against_bounds_from_trait(obligation,\n@@ -1006,8 +1006,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 skol_trait_predicate={} skol_map={}\",\n-               skol_trait_predicate.repr(self.tcx()),\n-               skol_map.repr(self.tcx()));\n+               skol_trait_predicate.repr(),\n+               skol_map.repr());\n \n         let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => &data.trait_ref,\n@@ -1016,18 +1016,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation.cause.span,\n                     &format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n                               but self-ty not a projection: {}\",\n-                             skol_trait_predicate.trait_ref.self_ty().repr(self.tcx())));\n+                             skol_trait_predicate.trait_ref.self_ty().repr()));\n             }\n         };\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 projection_trait_ref={}\",\n-               projection_trait_ref.repr(self.tcx()));\n+               projection_trait_ref.repr());\n \n         let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n         let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 bounds={}\",\n-               bounds.repr(self.tcx()));\n+               bounds.repr());\n \n         let matching_bound =\n             util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n@@ -1042,7 +1042,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 matching_bound={}\",\n-               matching_bound.repr(self.tcx()));\n+               matching_bound.repr());\n         match matching_bound {\n             None => false,\n             Some(bound) => {\n@@ -1089,7 +1089,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n-               stack.obligation.repr(self.tcx()));\n+               stack.obligation.repr());\n \n         let all_bounds =\n             self.param_env().caller_bounds\n@@ -1156,9 +1156,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         debug!(\"assemble_unboxed_candidates: self_ty={} kind={:?} obligation={}\",\n-               self_ty.repr(self.tcx()),\n+               self_ty.repr(),\n                kind,\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         match self.closure_typer.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n@@ -1221,7 +1221,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr());\n \n         let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n \n@@ -1247,7 +1247,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr());\n \n         let def_id = obligation.predicate.def_id();\n \n@@ -1317,7 +1317,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n         debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n-               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr(self.tcx()));\n+               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr());\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1363,7 +1363,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             };\n \n             debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n-                   poly_trait_ref.repr(self.tcx()));\n+                   poly_trait_ref.repr());\n \n             // see whether the object trait can be upcast to the trait we are looking for\n             let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n@@ -1407,7 +1407,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n         debug!(\"assemble_candidates_for_unsizing(source={}, target={})\",\n-               source.repr(self.tcx()), target.repr(self.tcx()));\n+               source.repr(), target.repr());\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n@@ -1473,7 +1473,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             candidate: &SelectionCandidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n+        debug!(\"winnow_candidate: candidate={}\", candidate.repr());\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n@@ -1566,7 +1566,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.builtin_bound(bound, stack.obligation) {\n             Ok(If(..)) => {\n                 debug!(\"builtin_bound: bound={}\",\n-                       bound.repr(self.tcx()));\n+                       bound.repr());\n                 candidates.vec.push(BuiltinCandidate(bound));\n                 Ok(())\n             }\n@@ -1775,7 +1775,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx())));\n+                        self_ty.repr()));\n             }\n         };\n \n@@ -1838,7 +1838,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble constituent types of unexpected type: {}\",\n-                        t.repr(self.tcx())));\n+                        t.repr()));\n             }\n \n             ty::TyBox(referent_ty) => {  // Box<T>\n@@ -1973,8 +1973,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                          -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({}, {})\",\n-               obligation.repr(self.tcx()),\n-               candidate.repr(self.tcx()));\n+               obligation.repr(),\n+               candidate.repr());\n \n         match candidate {\n             BuiltinCandidate(builtin_bound) => {\n@@ -2065,8 +2065,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                -> Vec<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n-               obligation.repr(self.tcx()),\n-               param.repr(self.tcx()));\n+               obligation.repr(),\n+               param.repr());\n \n         // During evaluation, we already checked that this\n         // where-clause trait-ref could be unified with the obligation\n@@ -2077,8 +2077,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Err(()) => {\n                 self.tcx().sess.bug(\n                     &format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n-                             param.repr(self.tcx()),\n-                             obligation.repr(self.tcx())));\n+                             param.repr(),\n+                             obligation.repr()));\n             }\n         }\n     }\n@@ -2090,15 +2090,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            SelectionError<'tcx>>\n     {\n         debug!(\"confirm_builtin_candidate({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         match try!(self.builtin_bound(bound, obligation)) {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     &format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx())));\n+                            obligation.repr()));\n             }\n         }\n     }\n@@ -2119,7 +2119,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let obligations = self.collect_predicates_for_types(obligation, trait_def, nested);\n \n         debug!(\"vtable_builtin_data: obligations={}\",\n-               obligations.repr(self.tcx()));\n+               obligations.repr());\n \n         VtableBuiltinData { nested: obligations }\n     }\n@@ -2135,8 +2135,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_default_impl_candidate({}, {})\",\n-               obligation.repr(self.tcx()),\n-               trait_def_id.repr(self.tcx()));\n+               obligation.repr(),\n+               trait_def_id.repr());\n \n         // binder is moved below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n@@ -2146,7 +2146,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to confirm default implementation for ambiguous type: {}\",\n-                        self_ty.repr(self.tcx())));\n+                        self_ty.repr()));\n             }\n         }\n     }\n@@ -2157,8 +2157,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_default_impl_object_candidate({}, {})\",\n-               obligation.repr(self.tcx()),\n-               trait_def_id.repr(self.tcx()));\n+               obligation.repr(),\n+               trait_def_id.repr());\n \n         assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n \n@@ -2185,7 +2185,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to confirm default object implementation for non-object type: {}\",\n-                        self_ty.repr(self.tcx())));\n+                        self_ty.repr()));\n             }\n         }\n     }\n@@ -2197,7 +2197,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n-        debug!(\"vtable_default_impl_data: nested={}\", nested.repr(self.tcx()));\n+        debug!(\"vtable_default_impl_data: nested={}\", nested.repr());\n \n         let mut obligations = self.collect_predicates_for_types(obligation,\n                                                                 trait_def_id,\n@@ -2218,7 +2218,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // no Errors in that code above\n         obligations.append(&mut trait_obligations.unwrap());\n \n-        debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr(self.tcx()));\n+        debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr());\n \n         VtableDefaultImplData {\n             trait_def_id: trait_def_id,\n@@ -2233,16 +2233,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                         SelectionError<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n-               obligation.repr(self.tcx()),\n-               impl_def_id.repr(self.tcx()));\n+               obligation.repr(),\n+               impl_def_id.repr());\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         self.infcx.commit_if_ok(|snapshot| {\n             let (substs, skol_map) =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n-            debug!(\"confirm_impl_candidate substs={}\", substs.repr(self.tcx()));\n+            debug!(\"confirm_impl_candidate substs={}\", substs.repr());\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n@@ -2258,10 +2258,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"vtable_impl(impl_def_id={}, substs={}, recursion_depth={}, skol_map={})\",\n-               impl_def_id.repr(self.tcx()),\n-               substs.repr(self.tcx()),\n+               impl_def_id.repr(),\n+               substs.repr(),\n                recursion_depth,\n-               skol_map.repr(self.tcx()));\n+               skol_map.repr());\n \n         let mut impl_obligations =\n             self.impl_or_trait_obligations(cause,\n@@ -2272,8 +2272,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            snapshot);\n \n         debug!(\"vtable_impl: impl_def_id={} impl_obligations={}\",\n-               impl_def_id.repr(self.tcx()),\n-               impl_obligations.repr(self.tcx()));\n+               impl_def_id.repr(),\n+               impl_obligations.repr());\n \n         impl_obligations.append(&mut substs.obligations);\n \n@@ -2287,7 +2287,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 -> VtableObjectData<'tcx>\n     {\n         debug!(\"confirm_object_candidate({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         // FIXME skipping binder here seems wrong -- we should\n         // probably flatten the binder from the obligation and the\n@@ -2329,7 +2329,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_fn_pointer_candidate({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n@@ -2356,19 +2356,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            SelectionError<'tcx>>\n     {\n         debug!(\"confirm_closure_candidate({},{},{})\",\n-               obligation.repr(self.tcx()),\n-               closure_def_id.repr(self.tcx()),\n-               substs.repr(self.tcx()));\n+               obligation.repr(),\n+               closure_def_id.repr(),\n+               substs.repr());\n \n         let Normalized {\n             value: trait_ref,\n             obligations\n         } = self.closure_trait_ref(obligation, closure_def_id, substs);\n \n         debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={}, obligations={})\",\n-               closure_def_id.repr(self.tcx()),\n-               trait_ref.repr(self.tcx()),\n-               obligations.repr(self.tcx()));\n+               closure_def_id.repr(),\n+               trait_ref.repr(),\n+               obligations.repr());\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -2437,7 +2437,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n         debug!(\"confirm_builtin_unsize_candidate(source={}, target={})\",\n-               source.repr(tcx), target.repr(tcx));\n+               source.repr(), target.repr());\n \n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n@@ -2614,8 +2614,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Err(()) => {\n                 self.tcx().sess.bug(\n                     &format!(\"Impl {} was matchable against {} but now is not\",\n-                            impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx())));\n+                            impl_def_id.repr(),\n+                            obligation.repr()));\n             }\n         }\n     }\n@@ -2656,10 +2656,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"match_impl(impl_def_id={}, obligation={}, \\\n                impl_trait_ref={}, skol_obligation_trait_ref={})\",\n-               impl_def_id.repr(self.tcx()),\n-               obligation.repr(self.tcx()),\n-               impl_trait_ref.repr(self.tcx()),\n-               skol_obligation_trait_ref.repr(self.tcx()));\n+               impl_def_id.repr(),\n+               obligation.repr(),\n+               impl_trait_ref.repr(),\n+               skol_obligation_trait_ref.repr());\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         if let Err(e) = self.infcx.sub_trait_refs(false,\n@@ -2677,7 +2677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n+        debug!(\"match_impl: success impl_substs={}\", impl_substs.repr());\n         Ok((Normalized {\n             value: impl_substs,\n             obligations: impl_trait_ref.obligations\n@@ -2729,8 +2729,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             -> Result<(),()>\n     {\n         debug!(\"match_poly_trait_ref: obligation={} poly_trait_ref={}\",\n-               obligation.repr(self.tcx()),\n-               poly_trait_ref.repr(self.tcx()));\n+               obligation.repr(),\n+               poly_trait_ref.repr());\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n@@ -2770,14 +2770,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n \n         debug!(\"match_impl_self_types(obligation_self_ty={}, impl_self_ty={})\",\n-               obligation_self_ty.repr(self.tcx()),\n-               impl_self_ty.repr(self.tcx()));\n+               obligation_self_ty.repr(),\n+               impl_self_ty.repr());\n \n         match self.match_self_types(obligation_cause,\n                                     impl_self_ty,\n                                     obligation_self_ty) {\n             Ok(()) => {\n-                debug!(\"Matched impl_substs={}\", impl_substs.repr(self.tcx()));\n+                debug!(\"Matched impl_substs={}\", impl_substs.repr());\n                 Ok(impl_substs)\n             }\n             Err(()) => {\n@@ -2889,7 +2889,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {\n-        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr(self.tcx()));\n+        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr());\n \n         let predicates = ty::lookup_predicates(self.tcx(), def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n@@ -2941,8 +2941,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n               -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n         debug!(\"upcast(obj_trait_ref={}, obligation={})\",\n-               obj_trait_ref.repr(self.tcx()),\n-               obligation.repr(self.tcx()));\n+               obj_trait_ref.repr(),\n+               obligation.repr());\n \n         let obligation_def_id = obligation.predicate.def_id();\n         let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n@@ -2958,28 +2958,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n         });\n \n-        debug!(\"upcast: upcast_trait_refs={}\", upcast_trait_refs.repr(self.tcx()));\n+        debug!(\"upcast: upcast_trait_refs={}\", upcast_trait_refs.repr());\n         upcast_trait_refs\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for SelectionCandidate<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n             BuiltinObjectCandidate => format!(\"BuiltinObjectCandidate\"),\n             BuiltinUnsizeCandidate => format!(\"BuiltinUnsizeCandidate\"),\n-            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n-            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n+            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr()),\n+            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr()),\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n             DefaultImplObjectCandidate(t) => format!(\"DefaultImplObjectCandidate({:?})\", t),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n             ObjectCandidate => format!(\"ObjectCandidate\"),\n             ClosureCandidate(c, ref s) => {\n-                format!(\"ClosureCandidate({:?},{})\", c, s.repr(tcx))\n+                format!(\"ClosureCandidate({:?},{})\", c, s.repr())\n             }\n         }\n     }\n@@ -3032,10 +3032,10 @@ impl<'o,'tcx> Iterator for TraitObligationStackList<'o,'tcx>{\n     }\n }\n \n-impl<'o,'tcx> Repr<'tcx> for TraitObligationStack<'o,'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'o,'tcx> Repr for TraitObligationStack<'o,'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TraitObligationStack({})\",\n-                self.obligation.repr(tcx))\n+                self.obligation.repr())\n     }\n }\n "}, {"sha": "a3ce5a90c2b04b38432bd353dab51611e2b40a9f", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -126,7 +126,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                               .collect();\n \n                 debug!(\"super_predicates: data={} predicates={}\",\n-                       data.repr(self.tcx), predicates.repr(self.tcx));\n+                       data.repr(), predicates.repr());\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n@@ -328,7 +328,7 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      -> Vec<PredicateObligation<'tcx>>\n {\n     debug!(\"predicates_for_generics(generic_bounds={})\",\n-           generic_bounds.repr(tcx));\n+           generic_bounds.repr());\n \n     generic_bounds.predicates.iter().map(|predicate| {\n         Obligation { cause: cause.clone(),\n@@ -486,116 +486,116 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n }\n \n-impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx,O:Repr> Repr for super::Obligation<'tcx, O> {\n+    fn repr(&self) -> String {\n         format!(\"Obligation(predicate={},depth={})\",\n-                self.predicate.repr(tcx),\n+                self.predicate.repr(),\n                 self.recursion_depth)\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, N:Repr> Repr for super::Vtable<'tcx, N> {\n+    fn repr(&self) -> String {\n         match *self {\n             super::VtableImpl(ref v) =>\n-                v.repr(tcx),\n+                v.repr(),\n \n             super::VtableDefaultImpl(ref t) =>\n-                t.repr(tcx),\n+                t.repr(),\n \n             super::VtableClosure(ref d) =>\n-                d.repr(tcx),\n+                d.repr(),\n \n             super::VtableFnPointer(ref d) =>\n                 format!(\"VtableFnPointer({})\",\n-                        d.repr(tcx)),\n+                        d.repr()),\n \n             super::VtableObject(ref d) =>\n                 format!(\"VtableObject({})\",\n-                        d.repr(tcx)),\n+                        d.repr()),\n \n             super::VtableParam(ref n) =>\n                 format!(\"VtableParam({})\",\n-                        n.repr(tcx)),\n+                        n.repr()),\n \n             super::VtableBuiltin(ref d) =>\n-                d.repr(tcx)\n+                d.repr()\n         }\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableImplData<'tcx, N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, N:Repr> Repr for super::VtableImplData<'tcx, N> {\n+    fn repr(&self) -> String {\n         format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n-                self.impl_def_id.repr(tcx),\n-                self.substs.repr(tcx),\n-                self.nested.repr(tcx))\n+                self.impl_def_id.repr(),\n+                self.substs.repr(),\n+                self.nested.repr())\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableClosureData<'tcx, N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, N:Repr> Repr for super::VtableClosureData<'tcx, N> {\n+    fn repr(&self) -> String {\n         format!(\"VtableClosure(closure_def_id={}, substs={}, nested={})\",\n-                self.closure_def_id.repr(tcx),\n-                self.substs.repr(tcx),\n-                self.nested.repr(tcx))\n+                self.closure_def_id.repr(),\n+                self.substs.repr(),\n+                self.nested.repr())\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, N:Repr> Repr for super::VtableBuiltinData<N> {\n+    fn repr(&self) -> String {\n         format!(\"VtableBuiltin(nested={})\",\n-                self.nested.repr(tcx))\n+                self.nested.repr())\n     }\n }\n \n-impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableDefaultImplData<N> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx, N:Repr> Repr for super::VtableDefaultImplData<N> {\n+    fn repr(&self) -> String {\n         format!(\"VtableDefaultImplData(trait_def_id={}, nested={})\",\n-                self.trait_def_id.repr(tcx),\n-                self.nested.repr(tcx))\n+                self.trait_def_id.repr(),\n+                self.nested.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for super::VtableObjectData<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"VtableObject(object_ty={})\",\n-                self.object_ty.repr(tcx))\n+                self.object_ty.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for super::SelectionError<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             super::Unimplemented =>\n                 format!(\"Unimplemented\"),\n \n             super::OutputTypeParameterMismatch(ref a, ref b, ref c) =>\n                 format!(\"OutputTypeParameterMismatch({},{},{})\",\n-                        a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx)),\n+                        a.repr(),\n+                        b.repr(),\n+                        c.repr()),\n \n             super::TraitNotObjectSafe(ref tr) =>\n                 format!(\"TraitNotObjectSafe({})\",\n-                        tr.repr(tcx))\n+                        tr.repr())\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::FulfillmentError<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for super::FulfillmentError<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"FulfillmentError({},{})\",\n-                self.obligation.repr(tcx),\n-                self.code.repr(tcx))\n+                self.obligation.repr(),\n+                self.code.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for super::FulfillmentErrorCode<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n-            super::CodeSelectionError(ref o) => o.repr(tcx),\n-            super::CodeProjectionError(ref o) => o.repr(tcx),\n+            super::CodeSelectionError(ref o) => o.repr(),\n+            super::CodeProjectionError(ref o) => o.repr(),\n             super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n@@ -611,9 +611,9 @@ impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::MismatchedProjectionTypes<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        self.err.repr(tcx)\n+impl<'tcx> Repr for super::MismatchedProjectionTypes<'tcx> {\n+    fn repr(&self) -> String {\n+        self.err.repr()\n     }\n }\n "}, {"sha": "e9f1fbeef90002ae5ae747c850954959bcff8ced", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -2786,7 +2786,7 @@ impl<'tcx> TraitDef<'tcx> {\n                        impl_def_id: DefId,\n                        impl_trait_ref: TraitRef<'tcx>) {\n         debug!(\"TraitDef::record_impl for {}, from {}\",\n-               self.repr(tcx), impl_trait_ref.repr(tcx));\n+               self.repr(), impl_trait_ref.repr());\n \n         // We don't want to borrow_mut after we already populated all impls,\n         // so check if an impl is present with an immutable borrow first.\n@@ -3710,7 +3710,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         TyArray(ty, _) | TySlice(ty) => ty,\n         TyStr => mk_mach_uint(cx, ast::TyU8),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                  ty.user_string(cx))),\n+                                  ty.user_string())),\n     }\n }\n \n@@ -4180,7 +4180,7 @@ fn type_impls_bound<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'tcx>>,\n     let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n     debug!(\"type_impls_bound({}, {:?}) = {:?}\",\n-           ty.repr(tcx),\n+           ty.repr(),\n            bound,\n            is_impld);\n \n@@ -4282,19 +4282,19 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n     fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                            r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n         debug!(\"type_requires({}, {})?\",\n-               r_ty.repr(cx), ty.repr(cx));\n+               r_ty.repr(), ty.repr());\n \n         let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n \n         debug!(\"type_requires({}, {})? {:?}\",\n-               r_ty.repr(cx), ty.repr(cx), r);\n+               r_ty.repr(), ty.repr(), r);\n         return r;\n     }\n \n     fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n                               r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n-               r_ty.repr(cx), ty.repr(cx));\n+               r_ty.repr(), ty.repr());\n \n         let r = match ty.sty {\n             // fixed length vectors need special treatment compared to\n@@ -4373,7 +4373,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n         };\n \n         debug!(\"subtypes_require({}, {})? {:?}\",\n-               r_ty.repr(cx), ty.repr(cx), r);\n+               r_ty.repr(), ty.repr(), r);\n \n         return r;\n     }\n@@ -4479,7 +4479,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n                                             seen: &mut Vec<Ty<'tcx>>,\n                                             ty: Ty<'tcx>) -> Representability {\n-        debug!(\"is_type_structurally_recursive: {}\", ty.repr(cx));\n+        debug!(\"is_type_structurally_recursive: {}\", ty.repr());\n \n         match ty.sty {\n             TyStruct(did, _) | TyEnum(did, _) => {\n@@ -4499,8 +4499,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                         Some(&seen_type) => {\n                             if same_struct_or_enum_def_id(seen_type, did) {\n                                 debug!(\"SelfRecursive: {} contains {}\",\n-                                       seen_type.repr(cx),\n-                                       ty.repr(cx));\n+                                       seen_type.repr(),\n+                                       ty.repr());\n                                 return SelfRecursive;\n                             }\n                         }\n@@ -4519,8 +4519,8 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                     for &seen_type in iter {\n                         if same_type(ty, seen_type) {\n                             debug!(\"ContainsRecursive: {} contains {}\",\n-                                   seen_type.repr(cx),\n-                                   ty.repr(cx));\n+                                   seen_type.repr(),\n+                                   ty.repr());\n                             return ContainsRecursive;\n                         }\n                     }\n@@ -4540,14 +4540,14 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n         }\n     }\n \n-    debug!(\"is_type_representable: {}\", ty.repr(cx));\n+    debug!(\"is_type_representable: {}\", ty.repr());\n \n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<Ty> = Vec::new();\n     let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n-    debug!(\"is_type_representable: {} is {:?}\", ty.repr(cx), r);\n+    debug!(\"is_type_representable: {} is {:?}\", ty.repr(), r);\n     r\n }\n \n@@ -4949,7 +4949,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         _ => {\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                          {}\", unadjusted_ty.repr(cx)));\n+                                          {}\", unadjusted_ty.repr()));\n                         }\n                     }\n                 }\n@@ -4990,7 +4990,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                         span,\n                                         &format!(\"the {}th autoderef failed: {}\",\n                                                 i,\n-                                                 adjusted_ty.user_string(cx))\n+                                                 adjusted_ty.user_string())\n                                         );\n                                 }\n                             }\n@@ -5232,11 +5232,11 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n     trait_items.iter().position(|m| m.name() == id)\n }\n \n-pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n+pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n     match ty.sty {\n         TyBool | TyChar | TyInt(_) |\n-        TyUint(_) | TyFloat(_) | TyStr => ty.user_string(cx),\n-        TyTuple(ref tys) if tys.is_empty() => ty.user_string(cx),\n+        TyUint(_) | TyFloat(_) | TyStr => ty.user_string(),\n+        TyTuple(ref tys) if tys.is_empty() => ty.user_string(),\n \n         TyEnum(id, _) => format!(\"enum `{}`\", item_path_str(cx, id)),\n         TyBox(_) => \"box\".to_string(),\n@@ -5272,17 +5272,17 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        ty::type_err_to_str(tcx, self)\n+impl<'tcx> Repr for ty::type_err<'tcx> {\n+    fn repr(&self) -> String {\n+        tls::with(|tcx| ty::type_err_to_str(tcx, self))\n     }\n }\n \n /// Explains the source of a type err in a short, human readable way. This is meant to be placed\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n-pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n+pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n     match *err {\n         terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n         terr_mismatch => \"types differ\".to_string(),\n@@ -5336,12 +5336,12 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n         terr_regions_insufficiently_polymorphic(br, _) => {\n             format!(\"expected bound lifetime parameter {}, \\\n                      found concrete lifetime\",\n-                    br.user_string(cx))\n+                    br.user_string())\n         }\n         terr_regions_overly_polymorphic(br, _) => {\n             format!(\"expected concrete lifetime, \\\n                      found bound lifetime parameter {}\",\n-                    br.user_string(cx))\n+                    br.user_string())\n         }\n         terr_sorts(values) => {\n             // A naive approach to making sure that we're not reporting silly errors such as:\n@@ -5362,14 +5362,14 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n         terr_builtin_bounds(values) => {\n             if values.expected.is_empty() {\n                 format!(\"expected no bounds, found `{}`\",\n-                        values.found.user_string(cx))\n+                        values.found.user_string())\n             } else if values.found.is_empty() {\n                 format!(\"expected bounds `{}`, found no bounds\",\n-                        values.expected.user_string(cx))\n+                        values.expected.user_string())\n             } else {\n                 format!(\"expected bounds `{}`, found bounds `{}`\",\n-                        values.expected.user_string(cx),\n-                        values.found.user_string(cx))\n+                        values.expected.user_string(),\n+                        values.found.user_string())\n             }\n         }\n         terr_integer_as_char => {\n@@ -6010,7 +6010,7 @@ fn report_discrim_overflow(cx: &ctxt,\n     let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n     let computed_value = repr_type.disr_string(computed_value);\n     let prev_val = repr_type.disr_string(prev_val);\n-    let repr_type = repr_type.to_ty(cx).user_string(cx);\n+    let repr_type = repr_type.to_ty(cx).user_string();\n     span_err!(cx.sess, variant_span, E0370,\n               \"enum discriminant overflowed on value after {}: {}; \\\n                set explicitly via {} = {} if that is desired outcome\",\n@@ -6503,8 +6503,8 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                                     -> Vec<ty::Region>\n {\n     debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-           erased_self_ty.repr(tcx),\n-           predicates.repr(tcx));\n+           erased_self_ty.repr(),\n+           predicates.repr());\n \n     assert!(!erased_self_ty.has_escaping_regions());\n \n@@ -6622,7 +6622,7 @@ pub fn populate_implementations_for_trait_if_necessary(tcx: &ctxt, trait_id: ast\n         return;\n     }\n \n-    debug!(\"populate_implementations_for_trait_if_necessary: searching for {}\", def.repr(tcx));\n+    debug!(\"populate_implementations_for_trait_if_necessary: searching for {}\", def.repr());\n \n     if csearch::is_defaulted_trait(&tcx.sess.cstore, trait_id) {\n         record_trait_has_default_impl(tcx, trait_id);\n@@ -6931,7 +6931,7 @@ pub fn construct_free_substs<'a,'tcx>(\n                                   defs: &[TypeParameterDef<'tcx>]) {\n         for def in defs {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                   def.repr(tcx));\n+                   def.repr());\n             let ty = ty::mk_param_from_def(tcx, def);\n             types.push(def.space, ty);\n        }\n@@ -6964,8 +6964,8 @@ pub fn construct_parameter_environment<'a,'tcx>(\n \n     debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n            free_id,\n-           free_substs.repr(tcx),\n-           predicates.repr(tcx));\n+           free_substs.repr(),\n+           predicates.repr());\n \n     //\n     // Finally, we have to normalize the bounds in the environment, in\n@@ -7221,7 +7221,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n     all_outlive_scope: region::DestructionScopeData,\n     value: &Binder<T>)\n     -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     ty_fold::replace_late_bound_regions(\n         tcx, value,\n@@ -7232,7 +7232,7 @@ pub fn count_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> usize\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     let (_, skol_map) = ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n     skol_map.len()\n@@ -7242,7 +7242,7 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> bool\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     count_late_bound_regions(tcx, value) > 0\n }\n@@ -7253,7 +7253,7 @@ pub fn flatten_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     bound2_value: &Binder<Binder<T>>)\n     -> Binder<T>\n-    where T: TypeFoldable<'tcx> + Repr<'tcx>\n+    where T: TypeFoldable<'tcx> + Repr\n {\n     let bound0_value = bound2_value.skip_binder().skip_binder();\n     let value = ty_fold::fold_regions(tcx, bound0_value, |region, current_depth| {\n@@ -7275,7 +7275,7 @@ pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> Option<T>\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+    where T : TypeFoldable<'tcx> + Repr + Clone\n {\n     if binds_late_bound_regions(tcx, value) {\n         None\n@@ -7290,7 +7290,7 @@ pub fn erase_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n     -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     ty_fold::replace_late_bound_regions(tcx, value, |_| ty::ReStatic).0\n }\n@@ -7307,7 +7307,7 @@ pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n     -> Binder<T>\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n+    where T : TypeFoldable<'tcx> + Repr,\n {\n     let mut counter = 0;\n     ty::Binder(ty_fold::replace_late_bound_regions(tcx, sig, |_| {\n@@ -7327,8 +7327,8 @@ impl DebruijnIndex {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for AutoAdjustment<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             AdjustReifyFnPointer => {\n                 format!(\"AdjustReifyFnPointer\")\n@@ -7337,24 +7337,24 @@ impl<'tcx> Repr<'tcx> for AutoAdjustment<'tcx> {\n                 format!(\"AdjustUnsafeFnPointer\")\n             }\n             AdjustDerefRef(ref data) => {\n-                data.repr(tcx)\n+                data.repr()\n             }\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for AutoDerefRef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for AutoDerefRef<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"AutoDerefRef({}, unsize={}, {})\",\n-                self.autoderefs, self.unsize.repr(tcx), self.autoref.repr(tcx))\n+                self.autoderefs, self.unsize.repr(), self.autoref.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for AutoRef<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             AutoPtr(a, b) => {\n-                format!(\"AutoPtr({},{:?})\", a.repr(tcx), b)\n+                format!(\"AutoPtr({},{:?})\", a.repr(), b)\n             }\n             AutoUnsafe(ref a) => {\n                 format!(\"AutoUnsafe({:?})\", a)\n@@ -7363,22 +7363,22 @@ impl<'tcx> Repr<'tcx> for AutoRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for TraitTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for TraitTy<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TraitTy({},{})\",\n-                self.principal.repr(tcx),\n-                self.bounds.repr(tcx))\n+                self.principal.repr(),\n+                self.bounds.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::Predicate<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n-            Predicate::Trait(ref a) => a.repr(tcx),\n-            Predicate::Equate(ref pair) => pair.repr(tcx),\n-            Predicate::RegionOutlives(ref pair) => pair.repr(tcx),\n-            Predicate::TypeOutlives(ref pair) => pair.repr(tcx),\n-            Predicate::Projection(ref pair) => pair.repr(tcx),\n+            Predicate::Trait(ref a) => a.repr(),\n+            Predicate::Equate(ref pair) => pair.repr(),\n+            Predicate::RegionOutlives(ref pair) => pair.repr(),\n+            Predicate::TypeOutlives(ref pair) => pair.repr(),\n+            Predicate::Projection(ref pair) => pair.repr(),\n         }\n     }\n }\n@@ -7584,11 +7584,11 @@ impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::ProjectionPredicate<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"ProjectionPredicate({}, {})\",\n-                self.projection_ty.repr(tcx),\n-                self.ty.repr(tcx))\n+                self.projection_ty.repr(),\n+                self.ty.repr())\n     }\n }\n \n@@ -7826,48 +7826,48 @@ impl ReferencesError for Region\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ClosureTy<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"ClosureTy({},{},{})\",\n                 self.unsafety,\n-                self.sig.repr(tcx),\n+                self.sig.repr(),\n                 self.abi)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ClosureUpvar<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ClosureUpvar<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"ClosureUpvar({},{})\",\n-                self.def.repr(tcx),\n-                self.ty.repr(tcx))\n+                self.def.repr(),\n+                self.ty.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for field<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for field<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"field({},{})\",\n-                self.name.repr(tcx),\n-                self.mt.repr(tcx))\n+                self.name.repr(),\n+                self.mt.repr())\n     }\n }\n \n-impl<'a, 'tcx> Repr<'tcx> for ParameterEnvironment<'a, 'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'a, 'tcx> Repr for ParameterEnvironment<'a, 'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"ParameterEnvironment(\\\n             free_substs={}, \\\n             implicit_region_bound={}, \\\n             caller_bounds={})\",\n-            self.free_substs.repr(tcx),\n-            self.implicit_region_bound.repr(tcx),\n-            self.caller_bounds.repr(tcx))\n+            self.free_substs.repr(),\n+            self.implicit_region_bound.repr(),\n+            self.caller_bounds.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ObjectLifetimeDefault {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ObjectLifetimeDefault {\n+    fn repr(&self) -> String {\n         match *self {\n             ObjectLifetimeDefault::Ambiguous => format!(\"Ambiguous\"),\n-            ObjectLifetimeDefault::Specific(ref r) => r.repr(tcx),\n+            ObjectLifetimeDefault::Specific(ref r) => r.repr(),\n         }\n     }\n }"}, {"sha": "00905eda1498e16b079bf26d66d4f95737de31af", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -50,7 +50,7 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable<'tcx>: Repr<'tcx> + Clone {\n+pub trait TypeFoldable<'tcx>: Repr + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n@@ -74,7 +74,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     fn exit_region_binder(&mut self) { }\n \n     fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+        where T : TypeFoldable<'tcx> + Repr + Clone\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n         super_fold_binder(self, t)\n@@ -197,7 +197,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>+Clone> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>+Repr+Clone> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.fold_binder(self)\n     }\n@@ -843,12 +843,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n         match r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({}) skipped bound region (current depth={})\",\n-                       r.repr(self.tcx()), self.current_depth);\n+                       r.repr(), self.current_depth);\n                 r\n             }\n             _ => {\n                 debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n-                       r.repr(self.tcx()), self.current_depth);\n+                       r.repr(), self.current_depth);\n                 (self.fld_r)(r, self.current_depth)\n             }\n         }\n@@ -885,9 +885,9 @@ pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n                                             mut f: F)\n                                             -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n     where F : FnMut(ty::BoundRegion) -> ty::Region,\n-          T : TypeFoldable<'tcx> + Repr<'tcx>,\n+          T : TypeFoldable<'tcx> + Repr,\n {\n-    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+    debug!(\"replace_late_bound_regions({})\", value.repr());\n     let mut replacer = RegionReplacer::new(tcx, &mut f);\n     let result = value.skip_binder().fold_with(&mut replacer);\n     (result, replacer.map)\n@@ -917,7 +917,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n         match r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 debug!(\"RegionReplacer.fold_region({}) folding region (current_depth={})\",\n-                       r.repr(self.tcx()), self.current_depth);\n+                       r.repr(), self.current_depth);\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n                 if let ty::ReLateBound(debruijn1, br) = region {\n@@ -994,10 +994,10 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>,\n+pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr>(tcx: &ty::ctxt<'tcx>,\n                                                             amount: u32, value: &T) -> T {\n     debug!(\"shift_regions(value={}, amount={})\",\n-           value.repr(tcx), amount);\n+           value.repr(), amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n         shift_region(region, amount)"}, {"sha": "3c9777935706f75714410bd8b922391aa1c02b33", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -55,14 +55,14 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a.repr(),\n+               b.repr());\n         Ok(a)\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+               a.repr(), b.repr());\n         if a == b { return Ok(a); }\n \n         match (&a.sty, &b.sty) {"}, {"sha": "a97f9d0b9f8a17ef21348c9e4693a36679b49496", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -81,8 +81,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n     {\n         debug!(\"{}.mts({}, {})\",\n                relation.tag(),\n-               a.repr(relation.tcx()),\n-               b.repr(relation.tcx()));\n+               a.repr(),\n+               b.repr());\n         if a.mutbl != b.mutbl {\n             Err(ty::terr_mutability)\n         } else {\n@@ -108,9 +108,9 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n     where R: TypeRelation<'a,'tcx>\n {\n     debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n-           item_def_id.repr(relation.tcx()),\n-           a_subst.repr(relation.tcx()),\n-           b_subst.repr(relation.tcx()));\n+           item_def_id.repr(),\n+           a_subst.repr(),\n+           b_subst.repr());\n \n     let variances;\n     let opt_variances = if relation.tcx().variance_computed.get() {\n@@ -196,9 +196,9 @@ fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n \n     debug!(\"relate_region_params(a_rs={}, \\\n             b_rs={}, variances={})\",\n-           a_rs.repr(tcx),\n-           b_rs.repr(tcx),\n-           variances.repr(tcx));\n+           a_rs.repr(),\n+           b_rs.repr(),\n+           variances.repr());\n \n     assert_eq!(num_region_params,\n                variances.map_or(num_region_params,"}, {"sha": "079741b0f2815aac40fc045c316202c2d0d59228", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 571, "deletions": 513, "changes": 1084, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -40,43 +40,46 @@ use syntax::{ast, ast_util};\n use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n-pub trait Repr<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String;\n+pub trait Repr {\n+    fn repr(&self) -> String;\n }\n \n /// Produces a string suitable for showing to the user.\n-pub trait UserString<'tcx> : Repr<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n+pub trait UserString: Repr {\n+    fn user_string(&self) -> String;\n }\n \n-fn parameterized<'tcx, GG>(cx: &ctxt<'tcx>,\n-                           substs: &subst::Substs<'tcx>,\n-                           did: ast::DefId,\n-                           projections: &[ty::ProjectionPredicate<'tcx>],\n-                           get_generics: GG)\n-                           -> String\n-    where GG : FnOnce() -> ty::Generics<'tcx>\n+pub fn verbose() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.verbose())\n+}\n+\n+fn parameterized<GG>(substs: &subst::Substs,\n+                     did: ast::DefId,\n+                     projections: &[ty::ProjectionPredicate],\n+                     get_generics: GG)\n+                     -> String\n+    where GG: for<'tcx> FnOnce(&ty::ctxt<'tcx>) -> ty::Generics<'tcx>\n {\n-    let base = ty::item_path_str(cx, did);\n-    if cx.sess.verbose() {\n+    let base = ty::tls::with(|tcx| ty::item_path_str(tcx, did));\n+    if verbose() {\n         let mut strings = vec![];\n         match substs.regions {\n             subst::ErasedRegions => {\n                 strings.push(format!(\"..\"));\n             }\n             subst::NonerasedRegions(ref regions) => {\n                 for region in regions {\n-                    strings.push(region.repr(cx));\n+                    strings.push(region.repr());\n                 }\n             }\n         }\n         for ty in &substs.types {\n-            strings.push(ty.repr(cx));\n+            strings.push(ty.repr());\n         }\n         for projection in projections {\n             strings.push(format!(\"{}={}\",\n-                                 projection.projection_ty.item_name.user_string(cx),\n-                                 projection.ty.user_string(cx)));\n+                                 projection.projection_ty.item_name.user_string(),\n+                                 projection.ty.user_string()));\n         }\n         return if strings.is_empty() {\n             format!(\"{}\", base)\n@@ -91,7 +94,7 @@ fn parameterized<'tcx, GG>(cx: &ctxt<'tcx>,\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions {\n-                let s = r.user_string(cx);\n+                let s = r.user_string();\n                 if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n@@ -111,52 +114,57 @@ fn parameterized<'tcx, GG>(cx: &ctxt<'tcx>,\n     // ICEs trying to fetch the generics early in the pipeline. This\n     // is kind of a hacky workaround in that -Z verbose is required to\n     // avoid those ICEs.\n-    let generics = get_generics();\n-\n-    let has_self = substs.self_ty().is_some();\n-    let tps = substs.types.get_slice(subst::TypeSpace);\n-    let ty_params = generics.types.get_slice(subst::TypeSpace);\n-    let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-    let num_defaults = if has_defaults {\n-        ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n-            match def.default {\n-                Some(default) => {\n-                    if !has_self && ty::type_has_self(default) {\n-                        // In an object type, there is no `Self`, and\n-                        // thus if the default value references Self,\n-                        // the user will be required to give an\n-                        // explicit value. We can't even do the\n-                        // substitution below to check without causing\n-                        // an ICE. (#18956).\n-                        false\n-                    } else {\n-                        default.subst(cx, substs) == actual\n+    ty::tls::with(|tcx| {\n+        let generics = get_generics(tcx);\n+\n+        let has_self = substs.self_ty().is_some();\n+        let tps = substs.types.get_slice(subst::TypeSpace);\n+        let ty_params = generics.types.get_slice(subst::TypeSpace);\n+        let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n+        let num_defaults = if has_defaults {\n+            let substs = tcx.lift(&substs);\n+            ty_params.iter().zip(tps).rev().take_while(|&(def, &actual)| {\n+                match def.default {\n+                    Some(default) => {\n+                        if !has_self && ty::type_has_self(default) {\n+                            // In an object type, there is no `Self`, and\n+                            // thus if the default value references Self,\n+                            // the user will be required to give an\n+                            // explicit value. We can't even do the\n+                            // substitution below to check without causing\n+                            // an ICE. (#18956).\n+                            false\n+                        } else {\n+                            let default = tcx.lift(&default);\n+                            substs.and_then(|substs| default.subst(tcx, substs)) == Some(actual)\n+                        }\n                     }\n+                    None => false\n                 }\n-                None => false\n-            }\n-        }).count()\n-    } else {\n-        0\n-    };\n+            }).count()\n+        } else {\n+            0\n+        };\n \n-    for t in &tps[..tps.len() - num_defaults] {\n-        strs.push(t.user_string(cx))\n-    }\n+        for t in &tps[..tps.len() - num_defaults] {\n+            strs.push(t.user_string())\n+        }\n+    });\n \n     for projection in projections {\n         strs.push(format!(\"{}={}\",\n-                          projection.projection_ty.item_name.user_string(cx),\n-                          projection.ty.user_string(cx)));\n+                          projection.projection_ty.item_name.user_string(),\n+                          projection.ty.user_string()));\n     }\n \n-    if cx.lang_items.fn_trait_kind(did).is_some() && projections.len() == 1 {\n+    let fn_trait_kind = ty::tls::with(|tcx| tcx.lang_items.fn_trait_kind(did));\n+    if fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n         let tail =\n             if ty::type_is_nil(projection_ty) {\n                 format!(\"\")\n             } else {\n-                format!(\" -> {}\", projection_ty.user_string(cx))\n+                format!(\" -> {}\", projection_ty.user_string())\n             };\n         format!(\"{}({}){}\",\n                 base,\n@@ -175,90 +183,129 @@ fn parameterized<'tcx, GG>(cx: &ctxt<'tcx>,\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+fn in_binder<'tcx, T, U>(tcx: &ty::ctxt<'tcx>,\n+                         original: &ty::Binder<T>,\n+                         lifted: Option<ty::Binder<U>>) -> String\n+    where T: UserString, U: UserString + TypeFoldable<'tcx>\n+{\n+    // Replace any anonymous late-bound regions with named\n+    // variants, using gensym'd identifiers, so that we can\n+    // clearly differentiate between named and unnamed regions in\n+    // the output. We'll probably want to tweak this over time to\n+    // decide just how much information to give.\n+    let value = if let Some(v) = lifted {\n+        v\n+    } else {\n+        return original.0.user_string();\n+    };\n+    let mut names = Vec::new();\n+    let value_str = ty_fold::replace_late_bound_regions(tcx, &value, |br| {\n+        ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n+            ty::BrNamed(_, name) => {\n+                names.push(token::get_name(name).to_string());\n+                br\n+            }\n+            ty::BrAnon(_) |\n+            ty::BrFresh(_) |\n+            ty::BrEnv => {\n+                let name = token::gensym(\"'r\");\n+                names.push(token::get_name(name).to_string());\n+                ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n+            }\n+        })\n+    }).0.user_string();\n+\n+    if names.is_empty() {\n+        value_str\n+    } else {\n+        format!(\"for<{}> {}\", names.connect(\",\"), value_str)\n+    }\n+}\n+\n+impl<T:Repr> Repr for Option<T> {\n+    fn repr(&self) -> String {\n         match self {\n             &None => \"None\".to_string(),\n-            &Some(ref t) => t.repr(tcx),\n+            &Some(ref t) => t.repr(),\n         }\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for P<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (**self).repr(tcx)\n+impl<T:Repr> Repr for P<T> {\n+    fn repr(&self) -> String {\n+        (**self).repr()\n     }\n }\n \n-impl<'tcx,T:Repr<'tcx>,U:Repr<'tcx>> Repr<'tcx> for Result<T,U> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<T:Repr,U:Repr> Repr for Result<T,U> {\n+    fn repr(&self) -> String {\n         match self {\n-            &Ok(ref t) => t.repr(tcx),\n-            &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n+            &Ok(ref t) => t.repr(),\n+            &Err(ref u) => format!(\"Err({})\", u.repr())\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for () {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for () {\n+    fn repr(&self) -> String {\n         \"()\".to_string()\n     }\n }\n \n-impl<'a, 'tcx, T: ?Sized +Repr<'tcx>> Repr<'tcx> for &'a T {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        Repr::repr(*self, tcx)\n+impl<'a, T: ?Sized +Repr> Repr for &'a T {\n+    fn repr(&self) -> String {\n+        (**self).repr()\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Rc<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (&**self).repr(tcx)\n+impl<T:Repr> Repr for Rc<T> {\n+    fn repr(&self) -> String {\n+        (&**self).repr()\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Box<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        (&**self).repr(tcx)\n+impl<T:Repr> Repr for Box<T> {\n+    fn repr(&self) -> String {\n+        (&**self).repr()\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"[{}]\", self.iter().map(|t| t.repr(tcx)).collect::<Vec<_>>().connect(\", \"))\n+impl<T:Repr> Repr for [T] {\n+    fn repr(&self) -> String {\n+        format!(\"[{}]\", self.iter().map(|t| t.repr()).collect::<Vec<_>>().connect(\", \"))\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        self[..].repr(tcx)\n+impl<T:Repr> Repr for OwnedSlice<T> {\n+    fn repr(&self) -> String {\n+        self[..].repr()\n     }\n }\n \n // This is necessary to handle types like Option<Vec<T>>, for which\n // autoderef cannot convert the &[T] handler\n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        self[..].repr(tcx)\n+impl<T:Repr> Repr for Vec<T> {\n+    fn repr(&self) -> String {\n+        self[..].repr()\n     }\n }\n \n-impl<'a, 'tcx, T: ?Sized +UserString<'tcx>> UserString<'tcx> for &'a T {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        UserString::user_string(*self, tcx)\n+impl<'a, T: ?Sized +UserString> UserString for &'a T {\n+    fn user_string(&self) -> String {\n+        (**self).user_string()\n     }\n }\n \n-impl<'tcx, T:UserString<'tcx>> UserString<'tcx> for Vec<T> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<T:UserString> UserString for Vec<T> {\n+    fn user_string(&self) -> String {\n         let strs: Vec<String> =\n-            self.iter().map(|t| t.user_string(tcx)).collect();\n+            self.iter().map(|t| t.user_string()).collect();\n         strs.connect(\", \")\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for def::Def {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for def::Def {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n@@ -277,19 +324,18 @@ impl<'tcx> Repr<'tcx> for def::Def {\n type TraitAndProjections<'tcx> =\n     (ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n-impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for TraitAndProjections<'tcx> {\n+    fn user_string(&self) -> String {\n         let &(ref trait_ref, ref projection_bounds) = self;\n-        parameterized(tcx,\n-                      trait_ref.substs,\n+        parameterized(trait_ref.substs,\n                       trait_ref.def_id,\n                       &projection_bounds[..],\n-                      || ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n+                      |tcx| ty::lookup_trait_def(tcx, trait_ref.def_id).generics.clone())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitTy<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::TraitTy<'tcx> {\n+    fn user_string(&self) -> String {\n         let &ty::TraitTy { ref principal, ref bounds } = self;\n \n         let mut components = vec![];\n@@ -299,17 +345,17 @@ impl<'tcx> UserString<'tcx> for ty::TraitTy<'tcx> {\n                         bounds.projection_bounds.iter().map(|x| x.0.clone()).collect()));\n \n         // Generate the main trait ref, including associated types.\n-        components.push(tap.user_string(tcx));\n+        components.push(tap.user_string());\n \n         // Builtin bounds.\n         for bound in &bounds.builtin_bounds {\n-            components.push(bound.user_string(tcx));\n+            components.push(bound.user_string());\n         }\n \n         // Region, if not obviously implied by builtin bounds.\n         if bounds.region_bound != ty::ReStatic {\n             // Region bound is implied by builtin bounds:\n-            components.push(bounds.region_bound.user_string(tcx));\n+            components.push(bounds.region_bound.user_string());\n         }\n \n         components.retain(|s| !s.is_empty());\n@@ -318,72 +364,72 @@ impl<'tcx> UserString<'tcx> for ty::TraitTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn repr(&self, _tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::TypeParameterDef<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TypeParameterDef({:?}, {:?}/{})\",\n                 self.def_id,\n                 self.space,\n                 self.index)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::RegionParameterDef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::RegionParameterDef {\n+    fn repr(&self) -> String {\n         format!(\"RegionParameterDef(name={}, def_id={}, bounds={})\",\n                 token::get_name(self.name),\n-                self.def_id.repr(tcx),\n-                self.bounds.repr(tcx))\n+                self.def_id.repr(),\n+                self.bounds.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TyS<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        self.user_string(tcx)\n+impl<'tcx> Repr for ty::TyS<'tcx> {\n+    fn repr(&self) -> String {\n+        self.user_string()\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::mt<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::mt<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"{}{}\",\n             if self.mutbl == ast::MutMutable { \"mut \" } else { \"\" },\n-            self.ty.user_string(tcx))\n+            self.ty.user_string())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for subst::Substs<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for subst::Substs<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"Substs[types={}, regions={}]\",\n-                       self.types.repr(tcx),\n-                       self.regions.repr(tcx))\n+                       self.types.repr(),\n+                       self.regions.repr())\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for subst::VecPerParamSpace<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n+    fn repr(&self) -> String {\n         format!(\"[{};{};{}]\",\n-                self.get_slice(subst::TypeSpace).repr(tcx),\n-                self.get_slice(subst::SelfSpace).repr(tcx),\n-                self.get_slice(subst::FnSpace).repr(tcx))\n+                self.get_slice(subst::TypeSpace).repr(),\n+                self.get_slice(subst::SelfSpace).repr(),\n+                self.get_slice(subst::FnSpace).repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ItemSubsts({})\", self.substs.repr(tcx))\n+impl<'tcx> Repr for ty::ItemSubsts<'tcx> {\n+    fn repr(&self) -> String {\n+        format!(\"ItemSubsts({})\", self.substs.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for subst::RegionSubsts {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for subst::RegionSubsts {\n+    fn repr(&self) -> String {\n         match *self {\n             subst::ErasedRegions => \"erased\".to_string(),\n-            subst::NonerasedRegions(ref regions) => regions.repr(tcx)\n+            subst::NonerasedRegions(ref regions) => regions.repr()\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::BuiltinBounds {\n+    fn repr(&self) -> String {\n         let mut res = Vec::new();\n         for b in self {\n             res.push(match b {\n@@ -397,40 +443,40 @@ impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::ParamBounds<'tcx> {\n+    fn repr(&self) -> String {\n         let mut res = Vec::new();\n-        res.push(self.builtin_bounds.repr(tcx));\n+        res.push(self.builtin_bounds.repr());\n         for t in &self.trait_bounds {\n-            res.push(t.repr(tcx));\n+            res.push(t.repr());\n         }\n         res.connect(\"+\")\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::TraitRef<'tcx> {\n+    fn repr(&self) -> String {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n-        let result = self.user_string(tcx);\n+        let result = self.user_string();\n         match self.substs.self_ty() {\n             None => result,\n-            Some(sty) => format!(\"<{} as {}>\", sty.repr(tcx), result)\n+            Some(sty) => format!(\"<{} as {}>\", sty.repr(), result)\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::TraitDef<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TraitDef(generics={}, trait_ref={})\",\n-                self.generics.repr(tcx),\n-                self.trait_ref.repr(tcx))\n+                self.generics.repr(),\n+                self.trait_ref.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::TraitItem {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::TraitItem {\n+    fn repr(&self) -> String {\n         let kind = match self.node {\n             ast::ConstTraitItem(..) => \"ConstTraitItem\",\n             ast::MethodTraitItem(..) => \"MethodTraitItem\",\n@@ -440,73 +486,73 @@ impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Expr {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Expr {\n+    fn repr(&self) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Path {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Path {\n+    fn repr(&self) -> String {\n         format!(\"path({})\", pprust::path_to_string(self))\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ast::Path {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n+impl UserString for ast::Path {\n+    fn user_string(&self) -> String {\n         pprust::path_to_string(self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Ty {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Ty {\n+    fn repr(&self) -> String {\n         format!(\"type({})\", pprust::ty_to_string(self))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Item {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"item({})\", tcx.map.node_to_string(self.id))\n+impl Repr for ast::Item {\n+    fn repr(&self) -> String {\n+        format!(\"item({})\", ty::tls::with(|tcx| tcx.map.node_to_string(self.id)))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Lifetime {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Lifetime {\n+    fn repr(&self) -> String {\n         format!(\"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Stmt {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Stmt {\n+    fn repr(&self) -> String {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n                 pprust::stmt_to_string(self))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Pat {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Pat {\n+    fn repr(&self) -> String {\n         format!(\"pat({}: {})\", self.id, pprust::pat_to_string(self))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BoundRegion {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::BoundRegion {\n+    fn repr(&self) -> String {\n         match *self {\n             ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n             ty::BrNamed(id, name) => {\n-                format!(\"BrNamed({}, {})\", id.repr(tcx), token::get_name(name))\n+                format!(\"BrNamed({}, {})\", id.repr(), token::get_name(name))\n             }\n             ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n             ty::BrEnv => \"BrEnv\".to_string()\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::BoundRegion {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n-        if tcx.sess.verbose() {\n-            return self.repr(tcx);\n+impl UserString for ty::BoundRegion {\n+    fn user_string(&self) -> String {\n+        if verbose() {\n+            return self.repr();\n         }\n \n         match *self {\n@@ -516,8 +562,8 @@ impl<'tcx> UserString<'tcx> for ty::BoundRegion {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Region {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::Region {\n+    fn repr(&self) -> String {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n                 format!(\"ReEarlyBound({}, {:?}, {}, {})\",\n@@ -530,10 +576,10 @@ impl<'tcx> Repr<'tcx> for ty::Region {\n             ty::ReLateBound(binder_id, ref bound_region) => {\n                 format!(\"ReLateBound({:?}, {})\",\n                         binder_id,\n-                        bound_region.repr(tcx))\n+                        bound_region.repr())\n             }\n \n-            ty::ReFree(ref fr) => fr.repr(tcx),\n+            ty::ReFree(ref fr) => fr.repr(),\n \n             ty::ReScope(id) => {\n                 format!(\"ReScope({:?})\", id)\n@@ -548,7 +594,7 @@ impl<'tcx> Repr<'tcx> for ty::Region {\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n-                format!(\"re_skolemized({}, {})\", id, bound_region.repr(tcx))\n+                format!(\"re_skolemized({}, {})\", id, bound_region.repr())\n             }\n \n             ty::ReEmpty => {\n@@ -558,10 +604,10 @@ impl<'tcx> Repr<'tcx> for ty::Region {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::Region {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n-        if tcx.sess.verbose() {\n-            return self.repr(tcx);\n+impl UserString for ty::Region {\n+    fn user_string(&self) -> String {\n+        if verbose() {\n+            return self.repr();\n         }\n \n         // These printouts are concise.  They do not contain all the information\n@@ -575,7 +621,7 @@ impl<'tcx> UserString<'tcx> for ty::Region {\n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::ReInfer(ReSkolemized(_, br)) => {\n-                br.user_string(tcx)\n+                br.user_string()\n             }\n             ty::ReScope(_) |\n             ty::ReInfer(ReVar(_)) => String::new(),\n@@ -585,16 +631,16 @@ impl<'tcx> UserString<'tcx> for ty::Region {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::FreeRegion {\n+    fn repr(&self) -> String {\n         format!(\"ReFree({}, {})\",\n-                self.scope.repr(tcx),\n-                self.bound_region.repr(tcx))\n+                self.scope.repr(),\n+                self.bound_region.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for region::CodeExtent {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for region::CodeExtent {\n+    fn repr(&self) -> String {\n         match *self {\n             region::CodeExtent::ParameterScope { fn_id, body_id } =>\n                 format!(\"ParameterScope({}, {})\", fn_id, body_id),\n@@ -608,81 +654,82 @@ impl<'tcx> Repr<'tcx> for region::CodeExtent {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for region::DestructionScopeData {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for region::DestructionScopeData {\n+    fn repr(&self) -> String {\n         match *self {\n             region::DestructionScopeData{ node_id } =>\n                 format!(\"DestructionScopeData {{ node_id: {} }}\", node_id),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::DefId {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ast::DefId {\n+    fn repr(&self) -> String {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n-        if self.krate == ast::LOCAL_CRATE {\n-            match tcx.map.find(self.node) {\n-                Some(ast_map::NodeItem(..)) |\n-                Some(ast_map::NodeForeignItem(..)) |\n-                Some(ast_map::NodeImplItem(..)) |\n-                Some(ast_map::NodeTraitItem(..)) |\n-                Some(ast_map::NodeVariant(..)) |\n-                Some(ast_map::NodeStructCtor(..)) => {\n-                    return format!(\n-                                \"{:?}:{}\",\n-                                *self,\n-                                ty::item_path_str(tcx, *self))\n+        ty::tls::with(|tcx| {\n+            if self.krate == ast::LOCAL_CRATE {\n+                match tcx.map.find(self.node) {\n+                    Some(ast_map::NodeItem(..)) |\n+                    Some(ast_map::NodeForeignItem(..)) |\n+                    Some(ast_map::NodeImplItem(..)) |\n+                    Some(ast_map::NodeTraitItem(..)) |\n+                    Some(ast_map::NodeVariant(..)) |\n+                    Some(ast_map::NodeStructCtor(..)) => {\n+                        return format!(\"{:?}:{}\",\n+                                       *self,\n+                                       ty::item_path_str(tcx, *self));\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n-        }\n-        return format!(\"{:?}\", *self)\n+            format!(\"{:?}\", *self)\n+        })\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TypeScheme<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::TypeScheme<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TypeScheme {{generics: {}, ty: {}}}\",\n-                self.generics.repr(tcx),\n-                self.ty.repr(tcx))\n+                self.generics.repr(),\n+                self.ty.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::Generics<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"Generics(types: {}, regions: {})\",\n-                self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+                self.types.repr(),\n+                self.regions.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::GenericPredicates<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"GenericPredicates(predicates: {})\",\n-                self.predicates.repr(tcx))\n+                self.predicates.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::InstantiatedPredicates<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"InstantiatedPredicates({})\",\n-                self.predicates.repr(tcx))\n+                self.predicates.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ItemVariances {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::ItemVariances {\n+    fn repr(&self) -> String {\n         format!(\"ItemVariances(types={}, \\\n                 regions={})\",\n-                self.types.repr(tcx),\n-                self.regions.repr(tcx))\n+                self.types.repr(),\n+                self.regions.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Variance {\n-    fn repr(&self, _: &ctxt) -> String {\n+impl Repr for ty::Variance {\n+    fn repr(&self) -> String {\n         // The first `.to_string()` returns a &'static str (it is not an implementation\n         // of the ToString trait). Because of that, we need to call `.to_string()` again\n         // if we want to have a `String`.\n@@ -691,160 +738,160 @@ impl<'tcx> Repr<'tcx> for ty::Variance {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ImplOrTraitItem<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::ImplOrTraitItem<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"ImplOrTraitItem({})\",\n                 match *self {\n-                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(tcx),\n-                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(tcx),\n-                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(),\n+                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(),\n+                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(),\n                 })\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::AssociatedConst<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::AssociatedConst<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"AssociatedConst(name: {}, ty: {}, vis: {}, def_id: {})\",\n-                self.name.repr(tcx),\n-                self.ty.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n+                self.name.repr(),\n+                self.ty.repr(),\n+                self.vis.repr(),\n+                self.def_id.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::AssociatedType<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::AssociatedType<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n-                self.name.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n+                self.name.repr(),\n+                self.vis.repr(),\n+                self.def_id.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::Method<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"Method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n-                self.name.repr(tcx),\n-                self.generics.repr(tcx),\n-                self.predicates.repr(tcx),\n-                self.fty.repr(tcx),\n-                self.explicit_self.repr(tcx),\n-                self.vis.repr(tcx),\n-                self.def_id.repr(tcx))\n+                self.name.repr(),\n+                self.generics.repr(),\n+                self.predicates.repr(),\n+                self.fty.repr(),\n+                self.explicit_self.repr(),\n+                self.vis.repr(),\n+                self.def_id.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Name {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Name {\n+    fn repr(&self) -> String {\n         token::get_name(*self).to_string()\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ast::Name {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n+impl UserString for ast::Name {\n+    fn user_string(&self) -> String {\n         token::get_name(*self).to_string()\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Ident {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Ident {\n+    fn repr(&self) -> String {\n         token::get_ident(*self).to_string()\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::ExplicitSelf_ {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::ExplicitSelf_ {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Visibility {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Visibility {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::BareFnTy<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"BareFnTy {{unsafety: {}, abi: {}, sig: {}}}\",\n                 self.unsafety,\n                 self.abi.to_string(),\n-                self.sig.repr(tcx))\n+                self.sig.repr())\n     }\n }\n \n \n-impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"fn{} -> {}\", self.inputs.repr(tcx), self.output.repr(tcx))\n+impl<'tcx> Repr for ty::FnSig<'tcx> {\n+    fn repr(&self) -> String {\n+        format!(\"fn{} -> {}\", self.inputs.repr(), self.output.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::FnOutput<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::FnOutput<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             ty::FnConverging(ty) =>\n-                format!(\"FnConverging({0})\", ty.repr(tcx)),\n+                format!(\"FnConverging({0})\", ty.repr()),\n             ty::FnDiverging =>\n                 \"FnDiverging\".to_string()\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::MethodCallee<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::MethodCallee<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\",\n-                self.origin.repr(tcx),\n-                self.ty.repr(tcx),\n-                self.substs.repr(tcx))\n+                self.origin.repr(),\n+                self.ty.repr(),\n+                self.substs.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::MethodOrigin<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::MethodOrigin<'tcx> {\n+    fn repr(&self) -> String {\n         match self {\n             &ty::MethodStatic(def_id) => {\n-                format!(\"MethodStatic({})\", def_id.repr(tcx))\n+                format!(\"MethodStatic({})\", def_id.repr())\n             }\n             &ty::MethodStaticClosure(def_id) => {\n-                format!(\"MethodStaticClosure({})\", def_id.repr(tcx))\n+                format!(\"MethodStaticClosure({})\", def_id.repr())\n             }\n             &ty::MethodTypeParam(ref p) => {\n-                p.repr(tcx)\n+                p.repr()\n             }\n             &ty::MethodTraitObject(ref p) => {\n-                p.repr(tcx)\n+                p.repr()\n             }\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::MethodParam<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::MethodParam<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"MethodParam({},{})\",\n-                self.trait_ref.repr(tcx),\n+                self.trait_ref.repr(),\n                 self.method_num)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::MethodObject<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"MethodObject({},{},{})\",\n-                self.trait_ref.repr(tcx),\n+                self.trait_ref.repr(),\n                 self.method_num,\n                 self.vtable_index)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::BuiltinBound {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::BuiltinBound {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n+impl UserString for ty::BuiltinBound {\n+    fn user_string(&self) -> String {\n         match *self {\n             ty::BoundSend => \"Send\".to_string(),\n             ty::BoundSized => \"Sized\".to_string(),\n@@ -854,116 +901,132 @@ impl<'tcx> UserString<'tcx> for ty::BuiltinBound {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Span {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        tcx.sess.codemap().span_to_string(*self).to_string()\n+impl Repr for Span {\n+    fn repr(&self) -> String {\n+        ty::tls::with(|tcx| tcx.sess.codemap().span_to_string(*self).to_string())\n     }\n }\n \n-impl<'tcx, A:UserString<'tcx>> UserString<'tcx> for Rc<A> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<A:UserString> UserString for Rc<A> {\n+    fn user_string(&self) -> String {\n         let this: &A = &**self;\n-        this.user_string(tcx)\n+        this.user_string()\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::ParamBounds<'tcx> {\n+    fn user_string(&self) -> String {\n         let mut result = Vec::new();\n-        let s = self.builtin_bounds.user_string(tcx);\n+        let s = self.builtin_bounds.user_string();\n         if !s.is_empty() {\n             result.push(s);\n         }\n         for n in &self.trait_bounds {\n-            result.push(n.user_string(tcx));\n+            result.push(n.user_string());\n         }\n         result.connect(\" + \")\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::ExistentialBounds<'tcx> {\n+    fn repr(&self) -> String {\n         let mut res = Vec::new();\n \n-        let region_str = self.region_bound.repr(tcx);\n+        let region_str = self.region_bound.repr();\n         if !region_str.is_empty() {\n             res.push(region_str);\n         }\n \n         for bound in &self.builtin_bounds {\n-            res.push(bound.repr(tcx));\n+            res.push(bound.repr());\n         }\n \n         for projection_bound in &self.projection_bounds {\n-            res.push(projection_bound.repr(tcx));\n+            res.push(projection_bound.repr());\n         }\n \n         res.connect(\"+\")\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl UserString for ty::BuiltinBounds {\n+    fn user_string(&self) -> String {\n         self.iter()\n-            .map(|bb| bb.user_string(tcx))\n+            .map(|bb| bb.user_string())\n             .collect::<Vec<String>>()\n             .connect(\"+\")\n             .to_string()\n     }\n }\n \n-impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n-    where T : UserString<'tcx> + TypeFoldable<'tcx>\n+// The generic impl doesn't work yet because projections are not\n+// normalized under HRTB.\n+/*impl<T> UserString for ty::Binder<T>\n+    where T: UserString + for<'a> ty::Lift<'a>,\n+          for<'a> <T as ty::Lift<'a>>::Lifted: UserString + TypeFoldable<'a>\n {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        // Replace any anonymous late-bound regions with named\n-        // variants, using gensym'd identifiers, so that we can\n-        // clearly differentiate between named and unnamed regions in\n-        // the output. We'll probably want to tweak this over time to\n-        // decide just how much information to give.\n-        let mut names = Vec::new();\n-        let (unbound_value, _) = ty_fold::replace_late_bound_regions(tcx, self, |br| {\n-            ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n-                ty::BrNamed(_, name) => {\n-                    names.push(token::get_name(name));\n-                    br\n-                }\n-                ty::BrAnon(_) |\n-                ty::BrFresh(_) |\n-                ty::BrEnv => {\n-                    let name = token::gensym(\"'r\");\n-                    names.push(token::get_name(name));\n-                    ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n-                }\n-            })\n-        });\n-        let names: Vec<_> = names.iter().map(|s| &s[..]).collect();\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    }\n+}*/\n \n-        let value_str = unbound_value.user_string(tcx);\n-        if names.is_empty() {\n-            value_str\n-        } else {\n-            format!(\"for<{}> {}\", names.connect(\",\"), value_str)\n-        }\n+impl<'tcx> UserString for ty::Binder<ty::TraitRef<'tcx>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n+impl<'tcx> UserString for ty::Binder<ty::TraitPredicate<'tcx>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        parameterized(tcx, self.substs, self.def_id, &[],\n-                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n+impl<'tcx> UserString for ty::Binder<ty::EquatePredicate<'tcx>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TyS<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                   opt_def_id: Option<ast::DefId>,\n-                                   unsafety: ast::Unsafety,\n-                                   abi: abi::Abi,\n-                                   ident: Option<ast::Ident>,\n-                                   sig: &ty::PolyFnSig<'tcx>)\n-                                   -> String {\n+impl<'tcx> UserString for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n+impl<'tcx> UserString for ty::Binder<TraitAndProjections<'tcx>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n+impl<'tcx> UserString for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n+impl UserString for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>> {\n+    fn user_string(&self) -> String {\n+        ty::tls::with(|tcx| in_binder(tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n+impl<'tcx> UserString for ty::TraitRef<'tcx> {\n+    fn user_string(&self) -> String {\n+        parameterized(self.substs, self.def_id, &[],\n+                      |tcx| ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n+    }\n+}\n+\n+impl<'tcx> UserString for ty::TyS<'tcx> {\n+    fn user_string(&self) -> String {\n+        fn bare_fn_to_string(opt_def_id: Option<ast::DefId>,\n+                             unsafety: ast::Unsafety,\n+                             abi: abi::Abi,\n+                             ident: Option<ast::Ident>,\n+                             sig: &ty::PolyFnSig)\n+                             -> String {\n             let mut s = String::new();\n \n             match unsafety {\n@@ -988,12 +1051,12 @@ impl<'tcx> UserString<'tcx> for ty::TyS<'tcx> {\n                 _ => { }\n             }\n \n-            push_sig_to_string(cx, &mut s, '(', ')', sig);\n+            push_sig_to_string(&mut s, '(', ')', sig);\n \n             match opt_def_id {\n                 Some(def_id) => {\n                     s.push_str(\" {\");\n-                    let path_str = ty::item_path_str(cx, def_id);\n+                    let path_str = ty::tls::with(|tcx| ty::item_path_str(tcx, def_id));\n                     s.push_str(&path_str[..]);\n                     s.push_str(\"}\");\n                 }\n@@ -1003,30 +1066,14 @@ impl<'tcx> UserString<'tcx> for ty::TyS<'tcx> {\n             s\n         }\n \n-        fn closure_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                   cty: &ty::ClosureTy<'tcx>,\n-                                   did: &ast::DefId)\n-                                   -> String {\n-            let mut s = String::new();\n-            s.push_str(\"[closure\");\n-            push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n-            if cx.sess.verbose() {\n-                s.push_str(&format!(\" id={:?}]\", did));\n-            } else {\n-                s.push(']');\n-            }\n-            s\n-        }\n-\n-        fn push_sig_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                    s: &mut String,\n-                                    bra: char,\n-                                    ket: char,\n-                                    sig: &ty::PolyFnSig<'tcx>) {\n+        fn push_sig_to_string(s: &mut String,\n+                              bra: char,\n+                              ket: char,\n+                              sig: &ty::PolyFnSig) {\n             s.push(bra);\n             let strs = sig.0.inputs\n                 .iter()\n-                .map(|a| a.user_string(cx))\n+                .map(|a| a.user_string())\n                 .collect::<Vec<_>>();\n             s.push_str(&strs.connect(\", \"));\n             if sig.0.variadic {\n@@ -1038,7 +1085,7 @@ impl<'tcx> UserString<'tcx> for ty::TyS<'tcx> {\n                 ty::FnConverging(t) => {\n                     if !ty::type_is_nil(t) {\n                         s.push_str(\" -> \");\n-                        s.push_str(& t.user_string(cx));\n+                        s.push_str(&t.user_string());\n                     }\n                 }\n                 ty::FnDiverging => {\n@@ -1047,208 +1094,219 @@ impl<'tcx> UserString<'tcx> for ty::TyS<'tcx> {\n             }\n         }\n \n-        fn infer_ty_to_string(cx: &ctxt, ty: ty::InferTy) -> String {\n-            let print_var_ids = cx.sess.verbose();\n-            match ty {\n-                ty::TyVar(ref vid) if print_var_ids => vid.repr(cx),\n-                ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n-                ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n-                ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n-                ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n-                ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n-                ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n-            }\n-        }\n-\n         // pretty print the structural type representation:\n         match self.sty {\n             TyBool => \"bool\".to_string(),\n             TyChar => \"char\".to_string(),\n             TyInt(t) => ast_util::int_ty_to_string(t, None).to_string(),\n             TyUint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n             TyFloat(t) => ast_util::float_ty_to_string(t).to_string(),\n-            TyBox(typ) => format!(\"Box<{}>\",  typ.user_string(tcx)),\n+            TyBox(typ) => format!(\"Box<{}>\",  typ.user_string()),\n             TyRawPtr(ref tm) => {\n                 format!(\"*{} {}\", match tm.mutbl {\n                     ast::MutMutable => \"mut\",\n                     ast::MutImmutable => \"const\",\n-                },  tm.ty.user_string(tcx))\n+                },  tm.ty.user_string())\n             }\n             TyRef(r, ref tm) => {\n                 let mut buf = \"&\".to_owned();\n-                buf.push_str(&r.user_string(tcx));\n-                if !buf.is_empty() {\n+                buf.push_str(&r.user_string());\n+                if buf.len() > 1 {\n                     buf.push_str(\" \");\n                 }\n-                buf.push_str(&tm.repr(tcx));\n+                buf.push_str(&tm.repr());\n                 buf\n             }\n             TyTuple(ref elems) => {\n                 let strs = elems\n                     .iter()\n-                    .map(|elem| elem.user_string(tcx))\n+                    .map(|elem| elem.user_string())\n                     .collect::<Vec<_>>();\n                 match &strs[..] {\n                     [ref string] => format!(\"({},)\", string),\n                     strs => format!(\"({})\", strs.connect(\", \"))\n                 }\n             }\n             TyBareFn(opt_def_id, ref f) => {\n-                bare_fn_to_string(tcx, opt_def_id, f.unsafety, f.abi, None, &f.sig)\n+                bare_fn_to_string(opt_def_id, f.unsafety, f.abi, None, &f.sig)\n             }\n-            TyInfer(infer_ty) => infer_ty_to_string(tcx, infer_ty),\n+            TyInfer(infer_ty) => infer_ty.repr(),\n             TyError => \"[type error]\".to_string(),\n-            TyParam(ref param_ty) => param_ty.user_string(tcx),\n+            TyParam(ref param_ty) => param_ty.user_string(),\n             TyEnum(did, substs) | TyStruct(did, substs) => {\n-                parameterized(tcx, substs, did, &[],\n-                              || ty::lookup_item_type(tcx, did).generics)\n+                parameterized(substs, did, &[],\n+                              |tcx| ty::lookup_item_type(tcx, did).generics)\n             }\n             TyTrait(ref data) => {\n-                data.user_string(tcx)\n+                data.user_string()\n             }\n             ty::TyProjection(ref data) => {\n                 format!(\"<{} as {}>::{}\",\n-                        data.trait_ref.self_ty().user_string(tcx),\n-                        data.trait_ref.user_string(tcx),\n-                        data.item_name.user_string(tcx))\n+                        data.trait_ref.self_ty().user_string(),\n+                        data.trait_ref.user_string(),\n+                        data.item_name.user_string())\n             }\n             TyStr => \"str\".to_string(),\n-            TyClosure(ref did, substs) => {\n+            TyClosure(ref did, substs) => ty::tls::with(|tcx| {\n                 let closure_tys = tcx.closure_tys.borrow();\n-                closure_tys.get(did).map(|closure_type| {\n-                    closure_to_string(tcx, &closure_type.subst(tcx, substs), did)\n+                closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n+                    tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n+                }).map(|sig| {\n+                    let mut s = String::new();\n+                    s.push_str(\"[closure\");\n+                    push_sig_to_string(&mut s, '(', ')', &sig);\n+                    if verbose() {\n+                        s.push_str(&format!(\" id={:?}]\", did));\n+                    } else {\n+                        s.push(']');\n+                    }\n+                    s\n                 }).unwrap_or_else(|| {\n-                    let id_str = if tcx.sess.verbose() {\n+                    let id_str = if verbose() {\n                         format!(\" id={:?}\", did)\n                     } else {\n                         \"\".to_owned()\n                     };\n \n-\n                     if did.krate == ast::LOCAL_CRATE {\n-                        let span = tcx.map.span(did.node);\n-                        format!(\"[closure {}{}]\", span.repr(tcx), id_str)\n+                        let span = ty::tls::with(|tcx| tcx.map.span(did.node));\n+                        format!(\"[closure {}{}]\", span.repr(), id_str)\n                     } else {\n                         format!(\"[closure{}]\", id_str)\n                     }\n                 })\n-            }\n+            }),\n             TyArray(t, sz) => {\n-                format!(\"[{}; {}]\",  t.user_string(tcx), sz)\n+                format!(\"[{}; {}]\",  t.user_string(), sz)\n             }\n             TySlice(t) => {\n-                format!(\"[{}]\",  t.user_string(tcx))\n+                format!(\"[{}]\",  t.user_string())\n             }\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ast::Ident {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n+impl UserString for ast::Ident {\n+    fn user_string(&self) -> String {\n         token::get_name(self.name).to_string()\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for abi::Abi {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for abi::Abi {\n+    fn repr(&self) -> String {\n         self.to_string()\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for abi::Abi {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n+impl UserString for abi::Abi {\n+    fn user_string(&self) -> String {\n         self.to_string()\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UpvarId {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::UpvarId {\n+    fn repr(&self) -> String {\n         format!(\"UpvarId({};`{}`;{})\",\n                 self.var_id,\n-                ty::local_var_name_str(tcx, self.var_id),\n+                ty::tls::with(|tcx| ty::local_var_name_str(tcx, self.var_id)),\n                 self.closure_expr_id)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Mutability {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::Mutability {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::BorrowKind {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::BorrowKind {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::UpvarBorrow {\n+    fn repr(&self) -> String {\n         format!(\"UpvarBorrow({}, {})\",\n-                self.kind.repr(tcx),\n-                self.region.repr(tcx))\n+                self.kind.repr(),\n+                self.region.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UpvarCapture {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl Repr for ty::UpvarCapture {\n+    fn repr(&self) -> String {\n         match *self {\n             ty::UpvarCapture::ByValue => format!(\"ByValue\"),\n-            ty::UpvarCapture::ByRef(ref data) => format!(\"ByRef({})\", data.repr(tcx)),\n+            ty::UpvarCapture::ByRef(ref data) => format!(\"ByRef({})\", data.repr()),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::IntVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::IntVid {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::FloatVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::FloatVid {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::RegionVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::RegionVid {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TyVid {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::TyVid {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::IntVarValue {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::IntVarValue {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::IntTy {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ty::InferTy {\n+    fn repr(&self) -> String {\n+        let print_var_ids = verbose();\n+        match *self {\n+            ty::TyVar(ref vid) if print_var_ids => vid.repr(),\n+            ty::IntVar(ref vid) if print_var_ids => vid.repr(),\n+            ty::FloatVar(ref vid) if print_var_ids => vid.repr(),\n+            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n+            ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n+            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n+            ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n+        }\n+    }\n+}\n+\n+impl Repr for ast::IntTy {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::UintTy {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::UintTy {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::FloatTy {\n-    fn repr(&self, _tcx: &ctxt) -> String {\n+impl Repr for ast::FloatTy {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n-    fn repr(&self, _: &ctxt) -> String {\n+impl Repr for ty::ExplicitSelfCategory {\n+    fn repr(&self) -> String {\n         match *self {\n             ty::StaticExplicitSelfCategory => \"static\",\n             ty::ByValueExplicitSelfCategory => \"self\",\n@@ -1261,138 +1319,138 @@ impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ParamTy {\n-    fn user_string(&self, _tcx: &ctxt) -> String {\n+impl UserString for ParamTy {\n+    fn user_string(&self) -> String {\n         format!(\"{}\", token::get_name(self.name))\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ParamTy {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        let ident = self.user_string(tcx);\n+impl Repr for ParamTy {\n+    fn repr(&self) -> String {\n+        let ident = self.user_string();\n         format!(\"{}/{:?}.{}\", ident, self.space, self.idx)\n     }\n }\n \n-impl<'tcx, A:Repr<'tcx>, B:Repr<'tcx>> Repr<'tcx> for (A,B) {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<A:Repr, B:Repr> Repr for (A,B) {\n+    fn repr(&self) -> String {\n         let &(ref a, ref b) = self;\n-        format!(\"({},{})\", a.repr(tcx), b.repr(tcx))\n+        format!(\"({},{})\", a.repr(), b.repr())\n     }\n }\n \n-impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Binder({})\", self.0.repr(tcx))\n+impl<T:Repr> Repr for ty::Binder<T> {\n+    fn repr(&self) -> String {\n+        format!(\"Binder({})\", self.0.repr())\n     }\n }\n \n-impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n-    where K: Hash + Eq + Repr<'tcx>,\n-          V: Repr<'tcx>,\n+impl<S, K, V> Repr for HashMap<K, V, S>\n+    where K: Hash + Eq + Repr,\n+          V: Repr,\n           S: HashState,\n {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+    fn repr(&self) -> String {\n         format!(\"HashMap({})\",\n                 self.iter()\n-                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n+                    .map(|(k,v)| format!(\"{} => {}\", k.repr(), v.repr()))\n                     .collect::<Vec<String>>()\n                     .connect(\", \"))\n     }\n }\n \n-impl<'tcx, T, U> Repr<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : Repr<'tcx> + TypeFoldable<'tcx>,\n-          U : Repr<'tcx> + TypeFoldable<'tcx>,\n+impl<'tcx, T, U> Repr for ty::OutlivesPredicate<T,U>\n+    where T : Repr + TypeFoldable<'tcx>,\n+          U : Repr + TypeFoldable<'tcx>,\n {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+    fn repr(&self) -> String {\n         format!(\"OutlivesPredicate({}, {})\",\n-                self.0.repr(tcx),\n-                self.1.repr(tcx))\n+                self.0.repr(),\n+                self.1.repr())\n     }\n }\n \n-impl<'tcx, T, U> UserString<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : UserString<'tcx> + TypeFoldable<'tcx>,\n-          U : UserString<'tcx> + TypeFoldable<'tcx>,\n+impl<'tcx, T, U> UserString for ty::OutlivesPredicate<T,U>\n+    where T : UserString + TypeFoldable<'tcx>,\n+          U : UserString + TypeFoldable<'tcx>,\n {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+    fn user_string(&self) -> String {\n         format!(\"{} : {}\",\n-                self.0.user_string(tcx),\n-                self.1.user_string(tcx))\n+                self.0.user_string(),\n+                self.1.user_string())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::EquatePredicate<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"EquatePredicate({}, {})\",\n-                self.0.repr(tcx),\n-                self.1.repr(tcx))\n+                self.0.repr(),\n+                self.1.repr())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::EquatePredicate<'tcx> {\n+    fn user_string(&self) -> String {\n         format!(\"{} == {}\",\n-                self.0.user_string(tcx),\n-                self.1.user_string(tcx))\n+                self.0.user_string(),\n+                self.1.user_string())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::TraitPredicate<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"TraitPredicate({})\",\n-                self.trait_ref.repr(tcx))\n+                self.trait_ref.repr())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::TraitPredicate<'tcx> {\n+    fn user_string(&self) -> String {\n         format!(\"{} : {}\",\n-                self.trait_ref.self_ty().user_string(tcx),\n-                self.trait_ref.user_string(tcx))\n+                self.trait_ref.self_ty().user_string(),\n+                self.trait_ref.user_string())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::ProjectionPredicate<'tcx> {\n+    fn user_string(&self) -> String {\n         format!(\"{} == {}\",\n-                self.projection_ty.user_string(tcx),\n-                self.ty.user_string(tcx))\n+                self.projection_ty.user_string(),\n+                self.ty.user_string())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for ty::ProjectionTy<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"{}::{}\",\n-                self.trait_ref.repr(tcx),\n-                self.item_name.repr(tcx))\n+                self.trait_ref.repr(),\n+                self.item_name.repr())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::ProjectionTy<'tcx> {\n+    fn user_string(&self) -> String {\n         format!(\"<{} as {}>::{}\",\n-                self.trait_ref.self_ty().user_string(tcx),\n-                self.trait_ref.user_string(tcx),\n-                self.item_name.user_string(tcx))\n+                self.trait_ref.self_ty().user_string(),\n+                self.trait_ref.user_string(),\n+                self.item_name.user_string())\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for ty::Predicate<'tcx> {\n+    fn user_string(&self) -> String {\n         match *self {\n-            ty::Predicate::Trait(ref data) => data.user_string(tcx),\n-            ty::Predicate::Equate(ref predicate) => predicate.user_string(tcx),\n-            ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(tcx),\n-            ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(tcx),\n-            ty::Predicate::Projection(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::Trait(ref data) => data.user_string(),\n+            ty::Predicate::Equate(ref predicate) => predicate.user_string(),\n+            ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(),\n+            ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(),\n+            ty::Predicate::Projection(ref predicate) => predicate.user_string(),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ast::Unsafety {\n-    fn repr(&self, _: &ctxt<'tcx>) -> String {\n+impl Repr for ast::Unsafety {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", *self)\n     }\n }"}, {"sha": "b15586cc2b455f5f196b1b4c6230f7fca68ed2b9", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n-               consume_id, cmt.repr(self.tcx()), mode);\n+               consume_id, cmt.repr(), mode);\n \n         self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n@@ -113,8 +113,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n-               consume_pat.repr(self.tcx()),\n-               cmt.repr(self.tcx()),\n+               consume_pat.repr(),\n+               cmt.repr(),\n                mode);\n \n         self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n                bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               borrow_id, cmt.repr(), loan_region,\n                bk, loan_cause);\n \n         match opt_loan_path(&cmt) {\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n-               assignment_id, assignee_cmt.repr(self.tcx()));\n+               assignment_id, assignee_cmt.repr());\n \n         match opt_loan_path(&assignee_cmt) {\n             Some(lp) => {\n@@ -385,8 +385,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! simultaneously.\n \n         debug!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n-               old_loan.repr(self.tcx()),\n-               new_loan.repr(self.tcx()));\n+               old_loan.repr(),\n+               new_loan.repr());\n \n         // Should only be called for loans that are in scope at the same time.\n         assert!(self.tcx().region_maps.scopes_intersect(old_loan.kill_scope,\n@@ -409,8 +409,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n                 loan1={}, loan2={})\",\n-               loan1.repr(self.tcx()),\n-               loan2.repr(self.tcx()));\n+               loan1.repr(),\n+               loan2.repr());\n \n         if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n             return true;\n@@ -674,7 +674,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        -> UseError<'tcx> {\n         debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n                self.tcx().map.node_to_string(expr_id),\n-               use_path.repr(self.tcx()));\n+               use_path.repr());\n \n         let mut ret = UseOk;\n \n@@ -699,7 +699,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n         debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={})\",\n-               id, use_kind, lp.repr(self.bccx.tcx));\n+               id, use_kind, lp.repr());\n \n         // FIXME (22079): if you find yourself tempted to cut and paste\n         // the body below and then specializing the error reporting,\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span: Span,\n                         assignee_cmt: mc::cmt<'tcx>,\n                         mode: euv::MutateMode) {\n-        debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n+        debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr());\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n@@ -884,7 +884,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //! `used_mut_nodes` table here.\n \n             loop {\n-                debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr(this.tcx()));\n+                debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr());\n                 match cmt.cat.clone() {\n                     mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: id, .. }, .. }) |\n                     mc::cat_local(id) => {\n@@ -930,7 +930,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             let guarantor = cmt.guarantor();\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n-                   cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n+                   cmt.repr(), guarantor.repr());\n             if let mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) = guarantor.cat {\n                 // Statically prohibit writes to `&mut` when aliasable\n                 check_for_aliasability_violation(this, span, b.clone());"}, {"sha": "75e9c09fb3da4394f40344fc9c0c7e36a7420eca", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -43,7 +43,7 @@ enum Fragment {\n \n impl Fragment {\n     fn loan_path_repr<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n-        let repr = |mpi| move_data.path_loan_path(mpi).repr(tcx);\n+        let repr = |mpi| move_data.path_loan_path(mpi).repr();\n         match *self {\n             Just(mpi) => repr(mpi),\n             AllButOneFrom(mpi) => format!(\"$(allbutone {})\", repr(mpi)),\n@@ -53,7 +53,7 @@ impl Fragment {\n     fn loan_path_user_string<'tcx>(&self,\n                                    move_data: &MoveData<'tcx>,\n                                    tcx: &ty::ctxt<'tcx>) -> String {\n-        let user_string = |mpi| move_data.path_loan_path(mpi).user_string(tcx);\n+        let user_string = |mpi| move_data.path_loan_path(mpi).user_string();\n         match *self {\n             Just(mpi) => user_string(mpi),\n             AllButOneFrom(mpi) => format!(\"$(allbutone {})\", user_string(mpi)),\n@@ -126,7 +126,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n \n     let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n         for (i, mpi) in vec_rc.iter().enumerate() {\n-            let render = || this.path_loan_path(*mpi).user_string(tcx);\n+            let render = || this.path_loan_path(*mpi).user_string();\n             if span_err {\n                 tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n             }\n@@ -172,7 +172,7 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n \n     let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n-        mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr(tcx)).collect()\n+        mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr()).collect()\n     };\n \n     let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n@@ -344,7 +344,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n                     panic!(\"tuple type {} should not have named fields.\",\n-                           parent_ty.repr(tcx)),\n+                           parent_ty.repr()),\n             };\n             let tuple_len = v.len();\n             for i in 0..tuple_len {\n@@ -419,7 +419,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n \n         ref sty_and_variant_info => {\n             let msg = format!(\"type {} ({:?}) is not fragmentable\",\n-                              parent_ty.repr(tcx), sty_and_variant_info);\n+                              parent_ty.repr(), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n             tcx.sess.opt_span_bug(opt_span, &msg[..])\n         }\n@@ -451,7 +451,7 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n     let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n     let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n     debug!(\"add_fragment_sibling_core(new_lp={}, origin_lp={})\",\n-           new_lp.repr(tcx), origin_lp.repr(tcx));\n+           new_lp.repr(), origin_lp.repr());\n     let mp = this.move_path(tcx, Rc::new(new_lp));\n \n     // Do not worry about checking for duplicates here; we will sort"}, {"sha": "e1410daf279fe3210d3cce724c8be8c224ffc07e", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -67,7 +67,7 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       mode: euv::MatchMode) {\n     let tcx = bccx.tcx;\n     debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={:?})\",\n-           move_pat.id, cmt.repr(tcx), mode);\n+           move_pat.id, cmt.repr(), mode);\n \n     let opt_lp = opt_loan_path(&cmt);\n     match opt_lp {\n@@ -116,13 +116,13 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_error_collector: &MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n     debug!(\"gather_move(move_id={}, cmt={})\",\n-           move_info.id, move_info.cmt.repr(bccx.tcx));\n+           move_info.id, move_info.cmt.repr());\n \n     let potentially_illegal_move =\n                 check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n     match potentially_illegal_move {\n         Some(illegal_move_origin) => {\n-            debug!(\"illegal_move_origin={}\", illegal_move_origin.repr(bccx.tcx));\n+            debug!(\"illegal_move_origin={}\", illegal_move_origin.repr());\n             let error = MoveError::with_move_info(illegal_move_origin,\n                                                   move_info.span_path_opt);\n             move_error_collector.add_error(error);"}, {"sha": "e4911543e6b54b19fda6153815a50bac5e0cece2", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -34,7 +34,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     //! where S is `item_scope` if `cmt` is an upvar,\n     //! and is scope of `cmt` otherwise.\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n-           cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n+           cmt.repr(), loan_region.repr());\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope: item_scope,\n                                          span: span,\n@@ -66,8 +66,8 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! \"guarantor\".  Reports an error if `self.loan_region` is\n         //! larger than scope of `cmt`.\n         debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n-               cmt.repr(self.bccx.tcx),\n-               self.loan_region.repr(self.bccx.tcx));\n+               cmt.repr(),\n+               self.loan_region.repr());\n \n         match cmt.cat {\n             mc::cat_rvalue(..) |"}, {"sha": "a33104bff70531374fa02d41e2926e114281a760", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={}, mode={:?})\",\n-               consume_id, cmt.repr(self.tcx()), mode);\n+               consume_id, cmt.repr(), mode);\n \n         match mode {\n             euv::Move(move_reason) => {\n@@ -94,8 +94,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::MatchMode) {\n         debug!(\"matched_pat(matched_pat={}, cmt={}, mode={:?})\",\n-               matched_pat.repr(self.tcx()),\n-               cmt.repr(self.tcx()),\n+               matched_pat.repr(),\n+               cmt.repr(),\n                mode);\n \n         if let mc::cat_downcast(..) = cmt.cat {\n@@ -110,8 +110,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={}, cmt={}, mode={:?})\",\n-               consume_pat.repr(self.tcx()),\n-               cmt.repr(self.tcx()),\n+               consume_pat.repr(),\n+               cmt.repr(),\n                mode);\n \n         match mode {\n@@ -134,7 +134,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, loan_region={:?}, \\\n                bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               borrow_id, cmt.repr(), loan_region,\n                bk, loan_cause);\n \n         self.guarantee_valid(borrow_id,\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     {\n         let opt_lp = opt_loan_path(&assignee_cmt);\n         debug!(\"mutate(assignment_id={}, assignee_cmt={}) opt_lp={:?}\",\n-               assignment_id, assignee_cmt.repr(self.tcx()), opt_lp);\n+               assignment_id, assignee_cmt.repr(), opt_lp);\n \n         match opt_lp {\n             Some(lp) => {\n@@ -237,7 +237,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n-               cmt.repr(self.tcx()),\n+               cmt.repr(),\n                req_kind,\n                loan_region);\n \n@@ -337,7 +337,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         };\n \n         debug!(\"guarantee_valid(borrow_id={}), loan={}\",\n-               borrow_id, loan.repr(self.tcx()));\n+               borrow_id, loan.repr());\n \n         // let loan_path = loan.loan_path;\n         // let loan_gen_scope = loan.gen_scope;\n@@ -377,7 +377,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       -> Result<(),()> {\n             //! Implements the M-* rules in README.md.\n             debug!(\"check_mutability(cause={:?} cmt={} req_kind={:?}\",\n-                   cause, cmt.repr(bccx.tcx), req_kind);\n+                   cause, cmt.repr(), req_kind);\n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {\n                     match cmt.mutbl {\n@@ -507,7 +507,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n \n pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n \n-    debug!(\"gather_loans_in_static_initializer(expr={})\", expr.repr(bccx.tcx));\n+    debug!(\"gather_loans_in_static_initializer(expr={})\", expr.repr());\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx"}, {"sha": "bc52fc7622cf1a127f5cd1ef71cea7f203beabea", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -130,7 +130,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 bccx.span_err(move_from.span,\n                               &format!(\"cannot move out of type `{}`, \\\n                                         a non-copy fixed-size array\",\n-                                       b.ty.user_string(bccx.tcx)));\n+                                       b.ty.user_string()));\n             }\n         }\n \n@@ -143,7 +143,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)));\n+                                b.ty.user_string()));\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")"}, {"sha": "274a08dfe1108535a13edee10fa1988f801db0d6", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -58,7 +58,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n                 cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n-        debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n+        debug!(\"restrict(cmt={})\", cmt.repr());\n \n         let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n "}, {"sha": "93b16795fe8d0f06cbeed85f18926160bd6be23e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -682,15 +682,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                   which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n-                                 expr_ty.user_string(self.tcx),\n+                                 expr_ty.user_string(),\n                                  suggestion));\n                 } else {\n                     self.tcx.sess.span_note(\n                         expr_span,\n                         &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n                                  ol,\n                                  moved_lp_msg,\n-                                 expr_ty.user_string(self.tcx),\n+                                 expr_ty.user_string(),\n                                  suggestion));\n                 }\n             }\n@@ -703,7 +703,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx)));\n+                            pat_ty.user_string()));\n                 self.tcx.sess.fileline_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n-                            expr_ty.user_string(self.tcx),\n+                            expr_ty.user_string(),\n                             suggestion));\n                 self.tcx.sess.fileline_help(expr_span, help);\n             }\n@@ -1148,8 +1148,8 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for InteriorKind {\n-    fn repr(&self, _tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for InteriorKind {\n+    fn repr(&self) -> String {\n         match *self {\n             InteriorField(mc::NamedField(fld)) =>\n                 format!(\"{}\", token::get_name(fld)),\n@@ -1159,77 +1159,77 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for Loan<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"Loan_{}({}, {:?}, {:?}-{:?}, {})\",\n                  self.index,\n-                 self.loan_path.repr(tcx),\n+                 self.loan_path.repr(),\n                  self.kind,\n                  self.gen_scope,\n                  self.kill_scope,\n-                 self.restricted_paths.repr(tcx))\n+                 self.restricted_paths.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for LoanPath<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for LoanPath<'tcx> {\n+    fn repr(&self) -> String {\n         match self.kind {\n             LpVar(id) => {\n-                format!(\"$({})\", tcx.map.node_to_string(id))\n+                format!(\"$({})\", ty::tls::with(|tcx| tcx.map.node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = tcx.map.node_to_string(var_id);\n+                let s = ty::tls::with(|tcx| tcx.map.node_to_string(var_id));\n                 format!(\"$({} captured by id={})\", s, closure_expr_id)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::item_path_str(tcx, variant_def_id)\n+                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n                 } else {\n-                    variant_def_id.repr(tcx)\n+                    variant_def_id.repr()\n                 };\n-                format!(\"({}{}{})\", lp.repr(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+                format!(\"({}{}{})\", lp.repr(), DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.repr(tcx))\n+                format!(\"{}.*\", lp.repr())\n             }\n \n             LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n+                format!(\"{}.{}\", lp.repr(), interior.repr())\n             }\n         }\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for LoanPath<'tcx> {\n-    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> UserString for LoanPath<'tcx> {\n+    fn user_string(&self) -> String {\n         match self.kind {\n             LpVar(id) => {\n-                format!(\"$({})\", tcx.map.node_to_user_string(id))\n+                format!(\"$({})\", ty::tls::with(|tcx| tcx.map.node_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                let s = tcx.map.node_to_user_string(var_id);\n+                let s = ty::tls::with(|tcx| tcx.map.node_to_user_string(var_id));\n                 format!(\"$({} captured by closure)\", s)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n                 let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n-                    ty::item_path_str(tcx, variant_def_id)\n+                    ty::tls::with(|tcx| ty::item_path_str(tcx, variant_def_id))\n                 } else {\n-                    variant_def_id.repr(tcx)\n+                    variant_def_id.repr()\n                 };\n-                format!(\"({}{}{})\", lp.user_string(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+                format!(\"({}{}{})\", lp.user_string(), DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n-                format!(\"{}.*\", lp.user_string(tcx))\n+                format!(\"{}.*\", lp.user_string())\n             }\n \n             LpExtend(ref lp, _, LpInterior(ref interior)) => {\n-                format!(\"{}.{}\", lp.user_string(tcx), interior.repr(tcx))\n+                format!(\"{}.{}\", lp.user_string(), interior.repr())\n             }\n         }\n     }"}, {"sha": "1b9b15a673aea6464d69dd2c2b8e85e1221dda58", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -314,7 +314,7 @@ impl<'tcx> MoveData<'tcx> {\n         };\n \n         debug!(\"move_path(lp={}, index={:?})\",\n-               lp.repr(tcx),\n+               lp.repr(),\n                index);\n \n         assert_eq!(index.get(), self.paths.borrow().len() - 1);\n@@ -365,7 +365,7 @@ impl<'tcx> MoveData<'tcx> {\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n         debug!(\"add_move(lp={}, id={}, kind={:?})\",\n-               lp.repr(tcx),\n+               lp.repr(),\n                id,\n                kind);\n \n@@ -395,7 +395,7 @@ impl<'tcx> MoveData<'tcx> {\n                           assignee_id: ast::NodeId,\n                           mode: euv::MutateMode) {\n         debug!(\"add_assignment(lp={}, assign_id={}, assignee_id={}\",\n-               lp.repr(tcx), assign_id, assignee_id);\n+               lp.repr(), assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n@@ -416,12 +416,12 @@ impl<'tcx> MoveData<'tcx> {\n \n         if self.is_var_path(path_index) {\n             debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n-                   lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n+                   lp.repr(), self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n             debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n-                   lp.repr(tcx), path_index);\n+                   lp.repr(), path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);\n         }\n@@ -438,7 +438,7 @@ impl<'tcx> MoveData<'tcx> {\n                              base_lp: Rc<LoanPath<'tcx>>,\n                              mode: euv::MatchMode) {\n         debug!(\"add_variant_match(lp={}, pattern_id={})\",\n-               lp.repr(tcx), pattern_id);\n+               lp.repr(), pattern_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n         let base_path_index = self.move_path(tcx, base_lp.clone());"}, {"sha": "7f079669911053a550f3eef60c46dff5e33f2c7c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -318,7 +318,7 @@ impl<'a, 'tcx> pprust::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              &ty::expr_ty(self.tcx, expr).user_string(self.tcx)));\n+                              &ty::expr_ty(self.tcx, expr).user_string()));\n                 s.pclose()\n             }\n             _ => Ok(())"}, {"sha": "16f35a8c10a8b4ddc27dd8b5d9ce9fc88e026197", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.items {\n-                if item.ident.user_string(this.infcx.tcx) == names[idx] {\n+                if item.ident.user_string() == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }\n@@ -253,7 +253,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, a: Ty<'tcx>) -> String {\n-         a.user_string(self.infcx.tcx)\n+         a.user_string()\n     }\n \n     pub fn t_fn(&self,\n@@ -388,8 +388,8 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             Ok(_) => { }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({},{}): {}\",\n-                       t1.repr(self.infcx.tcx),\n-                       t2.repr(self.infcx.tcx),\n+                       t1.repr(),\n+                       t2.repr(),\n                        ty::type_err_to_str(self.infcx.tcx, e));\n             }\n         }\n@@ -402,8 +402,8 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             Err(_) => { }\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({},{})\",\n-                       t1.repr(self.infcx.tcx),\n-                       t2.repr(self.infcx.tcx));\n+                       t1.repr(),\n+                       t2.repr());\n             }\n         }\n     }\n@@ -659,7 +659,7 @@ fn glb_bound_free_infer() {\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n             ty::TyRef(..) => { }\n-            _ => { panic!(\"t_resolve1={}\", t_resolve1.repr(env.infcx.tcx)); }\n+            _ => { panic!(\"t_resolve1={}\", t_resolve1.repr()); }\n         }\n     })\n }\n@@ -702,10 +702,10 @@ fn subst_ty_renumber_bound() {\n         };\n \n         debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(env.infcx.tcx),\n-               substs.repr(env.infcx.tcx),\n-               t_substituted.repr(env.infcx.tcx),\n-               t_expected.repr(env.infcx.tcx));\n+               t_source.repr(),\n+               substs.repr(),\n+               t_substituted.repr(),\n+               t_expected.repr());\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -739,10 +739,10 @@ fn subst_ty_renumber_some_bounds() {\n         };\n \n         debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(env.infcx.tcx),\n-               substs.repr(env.infcx.tcx),\n-               t_substituted.repr(env.infcx.tcx),\n-               t_expected.repr(env.infcx.tcx));\n+               t_source.repr(),\n+               substs.repr(),\n+               t_substituted.repr(),\n+               t_expected.repr());\n \n         assert_eq!(t_substituted, t_expected);\n     })\n@@ -800,10 +800,10 @@ fn subst_region_renumber_region() {\n         };\n \n         debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n-               t_source.repr(env.infcx.tcx),\n-               substs.repr(env.infcx.tcx),\n-               t_substituted.repr(env.infcx.tcx),\n-               t_expected.repr(env.infcx.tcx));\n+               t_source.repr(),\n+               substs.repr(),\n+               t_substituted.repr(),\n+               t_expected.repr());\n \n         assert_eq!(t_substituted, t_expected);\n     })"}, {"sha": "ed8f7372b660c20fc42d4e4d409785977e68d733", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -495,7 +495,7 @@ impl BoxPointers {\n         });\n \n         if n_uniq > 0 {\n-            let s =  ty.user_string(cx.tcx);\n+            let s =  ty.user_string();\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n             cx.span_lint(BOX_POINTERS, span, &m[..]);\n         }"}, {"sha": "eeebe03c21ba10af634e94d9688919e3d5b37e88", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -347,7 +347,7 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n-    let path = [PathName(token::intern(&t.user_string(ccx.tcx()))),\n+    let path = [PathName(token::intern(&t.user_string())),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n     mangle(path.iter().cloned(), Some(&hash[..]))"}, {"sha": "fb174d8ff276ea9193e5838f31ee6f94e0fb3f00", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -287,7 +287,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, _, _) in &collector.collected_paths {\n-                let typ = self.tcx.node_types().get(&id).unwrap().user_string(self.tcx);\n+                let typ = self.tcx.node_types().get(&id).unwrap().user_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -1392,7 +1392,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 \"<mutable>\".to_string()\n             };\n             let types = self.tcx.node_types();\n-            let typ = types.get(&id).unwrap().user_string(self.tcx);\n+            let typ = types.get(&id).unwrap().user_string();\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "efdc1195a952893dd47090a8f812941fc62e8437", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -293,7 +293,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                        self.tcx.map.path_to_string(parent),\n                                        name);\n                 let typ = self.tcx.node_types().get(&field.node.id).unwrap()\n-                                               .user_string(self.tcx);\n+                                               .user_string();\n                 let sub_span = self.span_utils.sub_span_before_token(field.span, token::Colon);\n                 Some(Data::VariableData(VariableData {\n                     id: field.node.id,"}, {"sha": "065aad96f7943b5700498a0579b05a4fdf44154e", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -217,7 +217,7 @@ use middle::ty::{self, Ty};\n use session::config::{NoDebugInfo, FullDebugInfo};\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::Repr;\n+use util::ppaux::{self, Repr};\n \n use std;\n use std::cmp::Ordering;\n@@ -371,11 +371,11 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n }\n \n-impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        if tcx.sess.verbose() {\n+impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n+    fn repr(&self) -> String {\n+        if ppaux::verbose() {\n             // for many programs, this just take too long to serialize\n-            self.pats.repr(tcx)\n+            self.pats.repr()\n         } else {\n             format!(\"{} pats\", self.pats.len())\n         }\n@@ -399,7 +399,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m.repr(),\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -439,7 +439,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m.repr(),\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -482,7 +482,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m.repr(),\n            col,\n            bcx.val_to_string(val));\n     let _indenter = indenter();\n@@ -539,7 +539,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m.repr(),\n            *opt,\n            col,\n            bcx.val_to_string(val));\n@@ -940,7 +940,7 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals=[{}])\",\n            bcx.to_str(),\n            bcx.expr_to_string(guard_expr),\n-           m.repr(bcx.tcx()),\n+           m.repr(),\n            vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n \n@@ -985,7 +985,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals=[{}])\",\n            bcx.to_str(),\n-           m.repr(bcx.tcx()),\n+           m.repr(),\n            vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().connect(\", \"));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n@@ -1698,11 +1698,11 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     -> Block<'blk, 'tcx> {\n     debug!(\"bind_irrefutable_pat(bcx={}, pat={})\",\n            bcx.to_str(),\n-           pat.repr(bcx.tcx()));\n+           pat.repr());\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx())));\n+                                 pat.repr()));\n     }\n \n     let _indenter = indenter();"}, {"sha": "dc5d3ea2f624890b90548302f9021f97ddc603b9", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -143,7 +143,7 @@ pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 t: Ty<'tcx>)\n                                 -> Rc<Repr<'tcx>> {\n-    debug!(\"Representing: {}\", t.repr(cx.tcx()));\n+    debug!(\"Representing: {}\", t.repr());\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n@@ -382,7 +382,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             General(ity, fields, dtor_to_init_u8(dtor))\n         }\n         _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           t.repr(cx.tcx())))\n+                           t.repr()))\n     }\n }\n "}, {"sha": "291541aa98ff88376d99050a006ae2ff71e7542a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -531,7 +531,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n-                                    t.repr(cx.tcx())))\n+                                    t.repr()))\n       }\n     }\n     return cx;\n@@ -641,7 +641,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n-                                   rhs_t.repr(cx.tcx())));\n+                                   rhs_t.repr()));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1193,7 +1193,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n            } else {\n                ccx.tcx().map.path_to_string(id).to_string()\n            },\n-           id, param_substs.repr(ccx.tcx()));\n+           id, param_substs.repr());\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n@@ -1511,7 +1511,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::emit_uwtable(llfndecl, true);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.repr(ccx.tcx()));\n+           param_substs.repr());\n \n     let has_env = match closure_env {\n         closure::ClosureEnv::Closure(_) => true,\n@@ -1554,7 +1554,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n     for monomorphized_arg_type in &monomorphized_arg_types {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n-               monomorphized_arg_type.repr(ccx.tcx()));\n+               monomorphized_arg_type.repr());\n     }\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n@@ -1636,7 +1636,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           id: ast::NodeId,\n                           attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n-    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n+    debug!(\"trans_fn(param_substs={})\", param_substs.repr());\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n     let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n@@ -1680,7 +1680,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx)))\n+                     ctor_ty.repr()))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -1758,7 +1758,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ctor_ty.repr(ccx.tcx())))\n+                    ctor_ty.repr()))\n     };\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "a06598a7cbe3318ff708f4c0eb260aa5e3ff91e3", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -89,7 +89,7 @@ pub struct Callee<'blk, 'tcx: 'blk> {\n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                      -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_callee\");\n-    debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n+    debug!(\"callee::trans(expr={})\", expr.repr());\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n@@ -134,7 +134,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                              def: def::Def,\n                              ref_expr: &ast::Expr)\n                              -> Callee<'blk, 'tcx> {\n-        debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n+        debug!(\"trans_def(def={}, ref_expr={})\", def.repr(), ref_expr.repr());\n         let expr_ty = common::node_id_type(bcx, ref_expr.id);\n         match def {\n             def::DefFn(did, _) if {\n@@ -229,9 +229,9 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = common::node_id_substs(ccx, node, param_substs);\n     debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n-           def_id.repr(ccx.tcx()),\n+           def_id.repr(),\n            node,\n-           substs.repr(ccx.tcx()));\n+           substs.repr());\n     trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n }\n \n@@ -292,7 +292,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     }\n \n     debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n-           bare_fn_ty.repr(tcx));\n+           bare_fn_ty.repr());\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n@@ -307,7 +307,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx)));\n+                                           bare_fn_ty.repr()));\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);\n@@ -323,7 +323,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                              output: sig.output,\n                                              variadic: false\n                                          })}));\n-    debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n+    debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr());\n \n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n@@ -403,10 +403,10 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n     debug!(\"trans_fn_ref_with_substs(def_id={}, node={:?}, \\\n             param_substs={}, substs={})\",\n-           def_id.repr(tcx),\n+           def_id.repr(),\n            node,\n-           param_substs.repr(tcx),\n-           substs.repr(tcx));\n+           param_substs.repr(),\n+           substs.repr());\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n     assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n@@ -459,8 +459,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n                             first_subst = {}, new_subst = {}\",\n-                           substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                           first_subst.repr(tcx), new_substs.repr(tcx));\n+                           substs.repr(), trait_ref.substs.repr(),\n+                           first_subst.repr(), new_substs.repr());\n \n                     (true, source_id, new_substs)\n                 }\n@@ -505,7 +505,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     };\n \n     debug!(\"trans_fn_ref_with_substs({}) must_monomorphise: {}\",\n-           def_id.repr(tcx), must_monomorphise);\n+           def_id.repr(), must_monomorphise);\n \n     // Create a monomorphic version of generic functions\n     if must_monomorphise {\n@@ -615,7 +615,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                          dest: expr::Dest)\n                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_expr={})\", call_expr.repr(bcx.tcx()));\n+    debug!(\"trans_method_call(call_expr={})\", call_expr.repr());\n     let method_call = MethodCall::expr(call_expr.id);\n     let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n         Some(method) => match method.origin {\n@@ -1126,7 +1126,7 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     debug!(\"trans_arg_datum({})\",\n-           formal_arg_ty.repr(bcx.tcx()));\n+           formal_arg_ty.repr());\n \n     let arg_datum_ty = arg_datum.ty;\n \n@@ -1165,8 +1165,8 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n         debug!(\"casting actual type ({}) to match formal ({})\",\n                bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n-        debug!(\"Rust types: {}; {}\", arg_datum_ty.repr(bcx.tcx()),\n-                                     formal_arg_ty.repr(bcx.tcx()));\n+        debug!(\"Rust types: {}; {}\", arg_datum_ty.repr(),\n+                                     formal_arg_ty.repr());\n         val = PointerCast(bcx, val, llformal_arg_ty);\n     }\n "}, {"sha": "97fe4dfb2a7a6d38448066e67b73461b1c3d6012", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -400,7 +400,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_drop_mem({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty.repr(),\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -426,7 +426,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={}, fill_on_drop={}, skip_dtor={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty.repr(),\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -458,7 +458,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty.repr(),\n                drop.fill_on_drop,\n                drop.skip_dtor);\n \n@@ -484,7 +484,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()),\n+               ty.repr(),\n                drop.fill_on_drop,\n                drop.skip_dtor);\n "}, {"sha": "ef8839c6d5d142d40a5fb6a0d20440f6cbbc3b36", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -354,8 +354,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     -> ValueRef\n {\n     debug!(\"trans_fn_once_adapter_shim(closure_def_id={}, substs={}, llreffn={})\",\n-           closure_def_id.repr(ccx.tcx()),\n-           substs.repr(ccx.tcx()),\n+           closure_def_id.repr(),\n+           substs.repr(),\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n@@ -375,7 +375,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                                                                sig: sig.clone() });\n     let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={}\",\n-           llref_fn_ty.repr(tcx));\n+           llref_fn_ty.repr());\n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n@@ -424,7 +424,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n         ty::TyTuple(ref tys) => &**tys,\n         _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n                                       closure_def_id={}\",\n-                                     closure_def_id.repr(tcx)))\n+                                     closure_def_id.repr()))\n     };\n     let llargs: Vec<_> =\n         input_tys.iter()"}, {"sha": "1f8e7e07568ebd19f47360932ad765f8b56b788f", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -64,11 +64,11 @@ pub use trans::context::CrateContext;\n /// subtyping, but they are anonymized and normalized as well). This\n /// is a stronger, caching version of `ty_fold::erase_regions`.\n pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     let value1 = value.fold_with(&mut RegionEraser(cx));\n     debug!(\"erase_regions({}) = {}\",\n-           value.repr(cx), value1.repr(cx));\n+           value.repr(), value1.repr());\n     return value1;\n \n     struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n@@ -88,7 +88,7 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n         }\n \n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-            where T : TypeFoldable<'tcx> + Repr<'tcx>\n+            where T : TypeFoldable<'tcx> + Repr\n         {\n             let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n             ty_fold::super_fold_binder(self, &u)\n@@ -212,7 +212,7 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n     // destructor (e.g. zero its memory on move).\n \n     let contents = ty::type_contents(cx, ty);\n-    debug!(\"type_needs_drop ty={} contents={:?}\", ty.repr(cx), contents);\n+    debug!(\"type_needs_drop ty={} contents={:?}\", ty.repr(), contents);\n     contents.needs_drop(cx)\n }\n \n@@ -518,7 +518,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+        where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -594,7 +594,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n-        e.repr(self.tcx())\n+        e.repr()\n     }\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n@@ -616,15 +616,15 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        t.repr(self.tcx())\n+        t.repr()\n     }\n \n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+        where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,\n@@ -994,14 +994,14 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // First check the cache.\n     match ccx.trait_cache().borrow().get(&trait_ref) {\n         Some(vtable) => {\n-            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+            info!(\"Cache hit: {}\", trait_ref.repr());\n             return (*vtable).clone();\n         }\n         None => { }\n     }\n \n     debug!(\"trans fulfill_obligation: trait_ref={} def_id={:?}\",\n-           trait_ref.repr(ccx.tcx()), trait_ref.def_id());\n+           trait_ref.repr(), trait_ref.def_id());\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n@@ -1024,7 +1024,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // where ambiguity can result.\n             debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n                     presuming due to overflow\",\n-                   trait_ref.repr(tcx));\n+                   trait_ref.repr());\n             ccx.sess().span_fatal(\n                 span,\n                 \"reached the recursion limit during monomorphization\");\n@@ -1033,8 +1033,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             tcx.sess.span_bug(\n                 span,\n                 &format!(\"Encountered error `{}` selecting `{}` during trans\",\n-                        e.repr(tcx),\n-                        trait_ref.repr(tcx)))\n+                        e.repr(),\n+                        trait_ref.repr()))\n         }\n     };\n \n@@ -1047,7 +1047,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     let vtable = drain_fulfillment_cx_or_panic(span, &infcx, &mut fulfill_cx, &vtable);\n \n-    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+    info!(\"Cache miss: {}\", trait_ref.repr());\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n                                           vtable.clone());\n \n@@ -1063,7 +1063,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                -> bool\n {\n     debug!(\"normalize_and_test_predicates(predicates={})\",\n-           predicates.repr(ccx.tcx()));\n+           predicates.repr());\n \n     let tcx = ccx.tcx();\n     let infcx = infer::new_infer_ctxt(tcx);\n@@ -1135,15 +1135,15 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                                 result: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n             infcx.tcx.sess.span_bug(\n                 span,\n                 &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                         errors.repr(infcx.tcx)));\n+                         errors.repr()));\n         }\n     }\n }\n@@ -1159,10 +1159,10 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr\n {\n     debug!(\"drain_fulfillment_cx(result={})\",\n-           result.repr(infcx.tcx));\n+           result.repr());\n \n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n@@ -1210,7 +1210,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                                 node, substs.repr(tcx)));\n+                                 node, substs.repr()));\n         }\n \n         monomorphize::apply_param_substs(tcx,"}, {"sha": "09f5509c5ac903262efe027c6bee0e6af53d0623", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -68,7 +68,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         &format!(\"integer literal has type {} (expected int \\\n                                  or usize)\",\n-                                lit_int_ty.repr(cx.tcx())))\n+                                lit_int_ty.repr()))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -161,7 +161,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         None => {\n             cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                   ty.repr(cx.tcx())))\n+                                   ty.repr()))\n         }\n     }\n }\n@@ -369,7 +369,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx()), ety_adjusted.repr(cx.tcx()),\n+                         e.repr(), ety_adjusted.repr(),\n                          csize, tsize));\n     }\n     (llconst, ety_adjusted)\n@@ -477,9 +477,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    -> ValueRef\n {\n     debug!(\"const_expr_unadjusted(e={}, ety={}, param_substs={})\",\n-           e.repr(cx.tcx()),\n-           ety.repr(cx.tcx()),\n-           param_substs.repr(cx.tcx()));\n+           e.repr(),\n+           ety.repr(),\n+           param_substs.repr());\n \n     let map_list = |exprs: &[P<ast::Expr>]| -> Vec<ValueRef> {\n         exprs.iter()\n@@ -498,7 +498,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n             debug!(\"const_expr_unadjusted: te1={}, ty={}\",\n                    cx.tn().val_to_string(te1),\n-                   ty.repr(cx.tcx()));\n+                   ty.repr());\n             let is_simd = ty::type_is_simd(cx.tcx(), ty);\n             let intype = if is_simd {\n                 ty::simd_type(cx.tcx(), ty)\n@@ -621,12 +621,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      bt.repr(cx.tcx())))\n+                                                      bt.repr()))\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           &format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  bt.repr(cx.tcx())))\n+                                                  bt.repr()))\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -654,7 +654,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n             let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n-            debug!(\"trans_const_cast({} as {})\", t_expr.repr(cx.tcx()), t_cast.repr(cx.tcx()));\n+            debug!(\"trans_const_cast({} as {})\", t_expr.repr(), t_cast.repr());\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n             }"}, {"sha": "ab76942ceee4b4e30db67de0d9ccdd10725ae99b", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -767,7 +767,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             &format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx())))\n+                    obj.repr()))\n     }\n \n     pub fn check_overflow(&self) -> bool {"}, {"sha": "b2cd99fc3ca89321202bb5598113d90a471cff90", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -36,14 +36,14 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt\");\n     let fcx = cx.fcx;\n-    debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n+    debug!(\"trans_stmt({})\", s.repr());\n \n     if cx.unreachable.get() {\n         return cx;\n     }\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, &s.repr(cx.tcx()));\n+        add_span_comment(cx, s.span, &s.repr());\n     }\n \n     let mut bcx = cx;"}, {"sha": "e6b47fdee7eec16a3246d6015f401bda79e8bdaf", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -616,7 +616,7 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"Datum({}, {}, {:?})\",\n                 ccx.tn().val_to_string(self.val),\n-                self.ty.repr(ccx.tcx()),\n+                self.ty.repr(),\n                 self.kind)\n     }\n "}, {"sha": "5ced8452b5f7060cf583738763f2c89e07fdde10", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   type_.repr(cx.tcx())));\n+                                   type_.repr()));\n         }\n     }\n \n@@ -298,7 +298,7 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             _ => {\n                 cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                       type_.repr(cx.tcx()), type_.sty))\n+                                       type_.repr(), type_.sty))\n             }\n         };\n \n@@ -489,7 +489,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n                         cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n-                                              unfinished_type.repr(cx.tcx()))\n+                                              unfinished_type.repr())\n                                       );\n                     }\n                 }\n@@ -677,7 +677,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         _ => {\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   trait_type.repr(cx.tcx())));\n+                                   trait_type.repr()));\n         }\n     };\n \n@@ -839,7 +839,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n                                                 &unique_type_id_str[..],\n-                                                t.user_string(cx.tcx()));\n+                                                t.user_string());\n                     cx.sess().span_bug(usage_site_span, &error_message[..]);\n                 }\n             };\n@@ -854,7 +854,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n                             &unique_type_id_str[..],\n-                            t.user_string(cx.tcx()));\n+                            t.user_string());\n                         cx.sess().span_bug(usage_site_span, &error_message[..]);\n                     }\n                 }"}, {"sha": "e33f059a94554458d806369dcee53657e319d058", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -163,7 +163,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", t.repr(cx.tcx())));\n+                unexpected type: {}\", t.repr()));\n         }\n     }\n "}, {"sha": "56daf7d570f21df677486c2a2379e4e71b8af61b", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -107,10 +107,10 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                  fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name,\n-           fn_type.repr(ccx.tcx()));\n+           fn_type.repr());\n     let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n     debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n-           fn_type.repr(ccx.tcx()));\n+           fn_type.repr());\n \n     let function_type; // placeholder so that the memory ownership works out ok\n     let (sig, abi, env) = match fn_type.sty {\n@@ -123,14 +123,14 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n             debug!(\"declare_rust_fn function_type={} self_type={}\",\n-                   function_type.repr(ccx.tcx()), self_type.repr(ccx.tcx()));\n+                   function_type.repr(), self_type.repr());\n             (&function_type.sig, abi::RustCall, Some(llenvironment_type))\n         }\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n     let sig = ty::Binder(ty::erase_late_bound_regions(ccx.tcx(), sig));\n-    debug!(\"declare_rust_fn (after region erasure) sig={}\", sig.repr(ccx.tcx()));\n+    debug!(\"declare_rust_fn (after region erasure) sig={}\", sig.repr());\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n "}, {"sha": "5a75a595b5c2114d5d6d36b3bfd266aed01bdb66", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -181,7 +181,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    debug!(\"trans_into() expr={}\", expr.repr(bcx.tcx()));\n+    debug!(\"trans_into() expr={}\", expr.repr());\n \n     let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n                                                                           expr.id,\n@@ -330,8 +330,8 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                             Type::vtable_ptr(ccx))\n         }\n         _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {} -> {}\",\n-                                     source.repr(ccx.tcx()),\n-                                     target.repr(ccx.tcx())))\n+                                     source.repr(),\n+                                     target.repr()))\n     }\n }\n \n@@ -351,7 +351,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Some(adj) => { adj }\n     };\n     debug!(\"unadjusted datum for expr {}: {} adjustment={:?}\",\n-           expr.repr(bcx.tcx()),\n+           expr.repr(),\n            datum.to_string(bcx.ccx()),\n            adjustment);\n     match adjustment {\n@@ -502,7 +502,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 vtable => {\n                     bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {}\",\n-                                                       vtable.repr(bcx.tcx())));\n+                                                       vtable.repr()));\n                 }\n             };\n \n@@ -546,8 +546,8 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {} -> {}\",\n-                                     source.ty.repr(bcx.tcx()),\n-                                     target.ty.repr(bcx.tcx())))\n+                                     source.ty.repr(),\n+                                     target.ty.repr()))\n     }\n     bcx\n }\n@@ -1283,7 +1283,7 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n                     \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx())));\n+                    ref_expr.repr()));\n         }\n     }\n }\n@@ -1356,7 +1356,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.bug(&format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx)));\n+                        ty.repr()));\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n@@ -1379,7 +1379,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         _ => {\n             tcx.sess.bug(&format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx)));\n+                ty.repr()));\n         }\n     }\n }\n@@ -2060,7 +2060,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let t_in = expr_ty_adjusted(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n \n-    debug!(\"trans_cast({} as {})\", t_in.repr(bcx.tcx()), t_out.repr(bcx.tcx()));\n+    debug!(\"trans_cast({} as {})\", t_in.repr(), t_out.repr());\n     let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n     let ll_t_out = type_of::arg_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n@@ -2124,8 +2124,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().span_bug(expr.span,\n                                   &format!(\"translating unsupported cast: \\\n                                             {} -> {}\",\n-                                           t_in.repr(bcx.tcx()),\n-                                           t_out.repr(bcx.tcx()))\n+                                           t_in.repr(),\n+                                           t_out.repr())\n                                  )\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n@@ -2211,7 +2211,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     debug!(\"deref_once(expr={}, datum={}, method_call={:?})\",\n-           expr.repr(bcx.tcx()),\n+           expr.repr(),\n            datum.to_string(ccx),\n            method_call);\n \n@@ -2296,7 +2296,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 &format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())));\n+                        datum.ty.repr()));\n         }\n     };\n "}, {"sha": "bfbcbd92734e5e668f53783ba3a5cee2d2c7e409", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -186,8 +186,8 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"register_foreign_item_fn(abi={}, \\\n             ty={}, \\\n             name={})\",\n-           abi.repr(ccx.tcx()),\n-           fty.repr(ccx.tcx()),\n+           abi.repr(),\n+           fty.repr(),\n            name);\n \n     let cc = llvm_calling_convention(ccx, abi);\n@@ -238,7 +238,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_native_call(callee_ty={}, \\\n             llfn={}, \\\n             llretptr={})\",\n-           callee_ty.repr(tcx),\n+           callee_ty.repr(),\n            ccx.tn().val_to_string(llfn),\n            ccx.tn().val_to_string(llretptr));\n \n@@ -613,13 +613,13 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx)));\n+                                       t.repr()));\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n                ccx.tcx().map.path_to_string(id),\n-               id, t.repr(tcx));\n+               id, t.repr());\n \n         let llfn = declare::define_internal_rust_fn(ccx, &ps[..], t).unwrap_or_else(||{\n             ccx.sess().bug(&format!(\"symbol `{}` already defined\", ps));\n@@ -641,7 +641,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={}, t={})\",\n                ccx.tn().val_to_string(llrustfn),\n                ccx.tn().val_to_string(llwrapfn),\n-               t.repr(ccx.tcx()));\n+               t.repr());\n \n         // Avoid all the Rust generation stuff and just generate raw\n         // LLVM here.\n@@ -726,7 +726,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             return_ty={}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.output.repr(tcx));\n+                           tys.fn_sig.output.repr());\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -818,7 +818,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         // Perform the call itself\n         debug!(\"calling llrustfn = {}, t = {}\",\n-               ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n+               ccx.tn().val_to_string(llrustfn), t.repr());\n         let attributes = attributes::from_fn_type(ccx, t);\n         let llrust_ret_val = builder.call(llrustfn, &llrust_args, Some(attributes));\n \n@@ -940,7 +940,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            llsig={} -> {}, \\\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n-           ty.repr(ccx.tcx()),\n+           ty.repr(),\n            ccx.tn().types_to_str(&llsig.llarg_tys),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),"}, {"sha": "05cc16c9b8887f173810c8ed365310501601a3b7", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -140,7 +140,7 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 debug_loc: DebugLoc,\n                                 skip_dtor: bool) -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(bcx.tcx()), skip_dtor);\n+    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(), skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n@@ -207,10 +207,10 @@ impl<'tcx> DropGlueKind<'tcx> {\n     fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         match *self {\n             DropGlueKind::Ty(ty) => {\n-                format!(\"DropGlueKind::Ty({})\", ty.repr(ccx.tcx()))\n+                format!(\"DropGlueKind::Ty({})\", ty.repr())\n             }\n             DropGlueKind::TyContents(ty) => {\n-                format!(\"DropGlueKind::TyContents({})\", ty.repr(ccx.tcx()))\n+                format!(\"DropGlueKind::TyContents({})\", ty.repr())\n             }\n         }\n     }\n@@ -249,7 +249,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     });\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n-    let _s = StatRecorder::new(ccx, format!(\"drop {}\", t.repr(ccx.tcx())));\n+    let _s = StatRecorder::new(ccx, format!(\"drop {}\", t.repr()));\n \n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);"}, {"sha": "c2b0d78ce1f88c588922d1e7dd4c136fd333770b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -102,7 +102,7 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n             continue;\n         }\n \n-        debug!(\"transmute_restriction: {}\", transmute_restriction.repr(ccx.tcx()));\n+        debug!(\"transmute_restriction: {}\", transmute_restriction.repr());\n \n         assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n         assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n@@ -121,21 +121,21 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with potentially different sizes: \\\n                               {} (could be {} bit{}) to {} (could be {} bit{})\",\n-                             transmute_restriction.original_from.user_string(ccx.tcx()),\n+                             transmute_restriction.original_from.user_string(),\n                              from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n-                             transmute_restriction.original_to.user_string(ccx.tcx()),\n+                             transmute_restriction.original_to.user_string(),\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with different sizes: \\\n                               {} ({} bit{}) to {} ({} bit{})\",\n-                             transmute_restriction.original_from.user_string(ccx.tcx()),\n+                             transmute_restriction.original_from.user_string(),\n                              from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n-                             transmute_restriction.original_to.user_string(ccx.tcx()),\n+                             transmute_restriction.original_to.user_string(),\n                              to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             }\n@@ -405,7 +405,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ty_name = token::intern_and_get_ident(&tp_ty.user_string(ccx.tcx()));\n+            let ty_name = token::intern_and_get_ident(&tp_ty.user_string());\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {"}, {"sha": "7229995048aa2f7c3e76a30862b6ec7c9ceb4171", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -62,7 +62,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_impl(name={}, id={})\", name.repr(tcx), id);\n+    debug!(\"trans_impl(name={}, id={})\", name.repr(), id);\n \n     let mut v = TransItemVisitor { ccx: ccx };\n \n@@ -138,13 +138,13 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={:?} trait_ref={} trait_ref id={:?} substs={:?}\",\n                    method_call,\n-                   trait_ref.repr(bcx.tcx()),\n+                   trait_ref.repr(),\n                    trait_ref.0.def_id,\n                    trait_ref.0.substs);\n             let origin = fulfill_obligation(bcx.ccx(),\n                                             span,\n                                             trait_ref.clone());\n-            debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n+            debug!(\"origin = {}\", origin.repr());\n             trans_monomorphized_callee(bcx,\n                                        method_call,\n                                        trait_ref.def_id(),\n@@ -234,7 +234,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              rcvr_self,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n-    debug!(\"trait_substs={}\", trait_substs.repr(tcx));\n+    debug!(\"trait_substs={}\", trait_substs.repr());\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n     let vtbl = fulfill_obligation(ccx,\n@@ -297,7 +297,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx)));\n+                                 vtbl.repr()));\n         }\n     }\n }\n@@ -391,7 +391,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 &format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx())));\n+                        vtable.repr()));\n         }\n     }\n }\n@@ -415,8 +415,8 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let node_substs = node_id_substs(ccx, node, bcx.fcx.param_substs);\n \n-    debug!(\"rcvr_substs={}\", rcvr_substs.repr(ccx.tcx()));\n-    debug!(\"node_substs={}\", node_substs.repr(ccx.tcx()));\n+    debug!(\"rcvr_substs={}\", rcvr_substs.repr());\n+    debug!(\"node_substs={}\", node_substs.repr());\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n@@ -484,7 +484,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Load the data pointer from the object.\n     debug!(\"trans_trait_callee_from_llval(callee_ty={}, vtable_index={}, llpair={})\",\n-           callee_ty.repr(ccx.tcx()),\n+           callee_ty.repr(),\n            vtable_index,\n            bcx.val_to_string(llpair));\n     let llboxptr = GEPi(bcx, llpair, &[0, abi::FAT_PTR_ADDR]);\n@@ -557,8 +557,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let trait_id = upcast_trait_ref.def_id();\n \n     debug!(\"trans_object_shim(object_ty={}, upcast_trait_ref={}, method_offset_in_trait={})\",\n-           object_ty.repr(tcx),\n-           upcast_trait_ref.repr(tcx),\n+           object_ty.repr(),\n+           upcast_trait_ref.repr(),\n            method_offset_in_trait);\n \n     let object_trait_ref =\n@@ -568,14 +568,14 @@ pub fn trans_object_shim<'a, 'tcx>(\n             }\n             _ => {\n                 tcx.sess.bug(&format!(\"trans_object_shim() called on non-object: {}\",\n-                                      object_ty.repr(tcx)));\n+                                      object_ty.repr()));\n             }\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n-    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n+    debug!(\"trans_object_shim: object_substs={}\", object_substs.repr());\n \n     // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n@@ -587,7 +587,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n     let method_ty = opaque_method_ty(tcx, fty);\n-    debug!(\"trans_object_shim: fty={} method_ty={}\", fty.repr(tcx), method_ty.repr(tcx));\n+    debug!(\"trans_object_shim: fty={} method_ty={}\", fty.repr(), method_ty.repr());\n \n     //\n     let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n@@ -628,7 +628,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                     _ => {\n                         bcx.sess().bug(\n                             &format!(\"rust-call expects a tuple not {}\",\n-                                     sig.inputs[1].repr(tcx)));\n+                                     sig.inputs[1].repr()));\n                     }\n                 }\n             }\n@@ -692,7 +692,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(trait_ref={})\", trait_ref.repr(tcx));\n+    debug!(\"get_vtable(trait_ref={})\", trait_ref.repr());\n \n     // Check the cache.\n     match ccx.vtables().borrow().get(&trait_ref) {\n@@ -740,13 +740,13 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // cannot cast an unsized type into a trait object\n                 tcx.sess.bug(\n                     &format!(\"cannot get vtable for an object type: {}\",\n-                            data.repr(tcx)));\n+                            data.repr()));\n             }\n             traits::VtableParam(..) => {\n                 tcx.sess.bug(\n                     &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n-                            trait_ref.repr(tcx),\n-                            vtable.repr(tcx)));\n+                            trait_ref.repr(),\n+                            vtable.repr()));\n             }\n         }\n     });\n@@ -777,9 +777,9 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n \n     debug!(\"emit_vtable_methods(impl_id={}, substs={}, param_substs={})\",\n-           impl_id.repr(tcx),\n-           substs.repr(tcx),\n-           param_substs.repr(tcx));\n+           impl_id.repr(),\n+           substs.repr(),\n+           param_substs.repr());\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n@@ -807,7 +807,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // null.\n         .map(|trait_method_def_id| {\n             debug!(\"emit_vtable_methods: trait_method_def_id={}\",\n-                   trait_method_def_id.repr(tcx));\n+                   trait_method_def_id.repr());\n \n             let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n@@ -822,7 +822,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n \n             debug!(\"emit_vtable_methods: trait_method_type={}\",\n-                   trait_method_type.repr(tcx));\n+                   trait_method_type.repr());\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n@@ -833,7 +833,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             };\n \n             debug!(\"emit_vtable_methods: impl_method_type={}\",\n-                   impl_method_type.repr(tcx));\n+                   impl_method_type.repr());\n \n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this"}, {"sha": "37447169600096b6993a1595256f12d9de67e749", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -44,8 +44,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             fn_id={}, \\\n             real_substs={}, \\\n             ref_id={:?})\",\n-           fn_id.repr(ccx.tcx()),\n-           psubsts.repr(ccx.tcx()),\n+           fn_id.repr(),\n+           psubsts.repr(),\n            ref_id);\n \n     assert!(psubsts.types.all(|t| {\n@@ -61,7 +61,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n \n-    debug!(\"monomorphic_fn about to subst into {}\", item_ty.repr(ccx.tcx()));\n+    debug!(\"monomorphic_fn about to subst into {}\", item_ty.repr());\n     let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n \n     match ccx.monomorphized().borrow().get(&hash_id) {\n@@ -77,8 +77,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             fn_id={}, \\\n             psubsts={}, \\\n             hash_id={:?})\",\n-           fn_id.repr(ccx.tcx()),\n-           psubsts.repr(ccx.tcx()),\n+           fn_id.repr(),\n+           psubsts.repr(),\n            hash_id);\n \n \n@@ -99,10 +99,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr(ccx.tcx()));\n+    debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr());\n \n     let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n-    debug!(\"mono_ty = {} (post-normalization)\", mono_ty.repr(ccx.tcx()));\n+    debug!(\"mono_ty = {} (post-normalization)\", mono_ty.repr());\n \n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n@@ -303,7 +303,7 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   param_substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n {\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)\n@@ -314,9 +314,9 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n /// and hence we can be sure that all associated types will be\n /// completely normalized away.\n pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    where T : TypeFoldable<'tcx> + Repr + HasProjectionTypes + Clone\n {\n-    debug!(\"normalize_associated_type(t={})\", value.repr(tcx));\n+    debug!(\"normalize_associated_type(t={})\", value.repr());\n \n     let value = erase_regions(tcx, value);\n \n@@ -334,8 +334,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n         traits::normalize(&mut selcx, cause, &value);\n \n     debug!(\"normalize_associated_type: result={} obligations={}\",\n-           result.repr(tcx),\n-           obligations.repr(tcx));\n+           result.repr(),\n+           obligations.repr());\n \n     let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     for obligation in obligations {"}, {"sha": "f2168d38c9e57c631f0c9c82bb33d5bd752f35d3", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -42,7 +42,7 @@ struct VecTypes<'tcx> {\n impl<'tcx> VecTypes<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n-                self.unit_ty.user_string(ccx.tcx()),\n+                self.unit_ty.user_string(),\n                 ccx.tn().type_to_string(self.llunit_ty))\n     }\n }"}, {"sha": "4ec6edcea714db5dcd9dab86c44f0930c18a25ff", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -100,7 +100,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  -> Type\n {\n     debug!(\"type_of_rust_fn(sig={},abi={:?})\",\n-           sig.repr(cx.tcx()),\n+           sig.repr(),\n            abi);\n \n     let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n@@ -229,7 +229,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError(..) => {\n             cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n-                                   t.repr(cx.tcx())))\n+                                   t.repr()))\n         }\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n     };\n@@ -298,7 +298,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t.sty);\n+    debug!(\"type_of {} {:?}\", t.repr(), t.sty);\n \n     assert!(!t.has_escaping_regions());\n \n@@ -312,9 +312,9 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     if t != t_norm {\n         let llty = in_memory_type_of(cx, t_norm);\n         debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n-                t.repr(cx.tcx()),\n+                t.repr(),\n                 t,\n-                t_norm.repr(cx.tcx()),\n+                t_norm.repr(),\n                 t_norm,\n                 cx.tn().type_to_string(llty));\n         cx.lltypes().borrow_mut().insert(t, llty);\n@@ -364,7 +364,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                       ty::TyTrait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\\n                                    struct_tail: {} for ty={}\",\n-                                  unsized_part.repr(cx.tcx()), ty.repr(cx.tcx()))\n+                                  unsized_part.repr(), ty.repr())\n                   };\n                   Type::struct_(cx, &[ptr_ty, info_ty], false)\n               }\n@@ -419,7 +419,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\",\n-            t.repr(cx.tcx()),\n+            t.repr(),\n             t,\n             cx.tn().type_to_string(llty));\n \n@@ -449,7 +449,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             tps: &[Ty<'tcx>])\n                             -> String {\n     let base = ty::item_path_str(cx.tcx(), did);\n-    let strings: Vec<String> = tps.iter().map(|t| t.repr(cx.tcx())).collect();\n+    let strings: Vec<String> = tps.iter().map(|t| t.repr()).collect();\n     let tstr = if strings.is_empty() {\n         base\n     } else {"}, {"sha": "b7516530e6f1885d94a52208599b56be71e97595", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -179,9 +179,9 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     };\n \n     debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n-           lifetime.repr(tcx),\n+           lifetime.repr(),\n            lifetime.id,\n-           r.repr(tcx));\n+           r.repr());\n \n     r\n }\n@@ -257,8 +257,8 @@ pub fn opt_ast_region_to_region<'tcx>(\n     };\n \n     debug!(\"opt_ast_region_to_region(opt_lifetime={}) yields {}\",\n-            opt_lifetime.repr(this.tcx()),\n-            r.repr(this.tcx()));\n+            opt_lifetime.repr(),\n+            r.repr());\n \n     r\n }\n@@ -375,8 +375,8 @@ fn create_substs_for_ast_path<'tcx>(\n \n     debug!(\"create_substs_for_ast_path(decl_generics={}, self_ty={}, \\\n            types_provided={}, region_substs={}\",\n-           decl_generics.repr(tcx), self_ty.repr(tcx), types_provided.repr(tcx),\n-           region_substs.repr(tcx));\n+           decl_generics.repr(), self_ty.repr(), types_provided.repr(),\n+           region_substs.repr());\n \n     assert_eq!(region_substs.regions().len(TypeSpace), decl_generics.regions.len(TypeSpace));\n     assert!(region_substs.types.is_empty());\n@@ -441,8 +441,8 @@ fn create_substs_for_ast_path<'tcx>(\n                           \"the type parameter `{}` must be explicitly specified \\\n                            in an object type because its default value `{}` references \\\n                            the type `Self`\",\n-                          param.name.user_string(tcx),\n-                          default.user_string(tcx));\n+                          param.name.user_string(),\n+                          default.user_string());\n                 substs.types.push(TypeSpace, tcx.types.err);\n             } else {\n                 // This is a default type parameter.\n@@ -649,7 +649,7 @@ fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::D\n         def::DefTrait(trait_def_id) => trait_def_id,\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                        path.user_string(this.tcx()));\n+                        path.user_string());\n         }\n     }\n }\n@@ -879,7 +879,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n \n     let candidate = try!(one_bound_for_assoc_type(tcx,\n                                                   candidates,\n-                                                  &trait_ref.user_string(tcx),\n+                                                  &trait_ref.user_string(),\n                                                   &token::get_name(binding.item_name),\n                                                   binding.span));\n \n@@ -1031,7 +1031,7 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n \n     let result = make_object_type(this, span, trait_ref, existential_bounds);\n     debug!(\"trait_ref_to_object_type: result={}\",\n-           result.repr(this.tcx()));\n+           result.repr());\n \n     result\n }\n@@ -1074,7 +1074,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     for (trait_def_id, name) in associated_types {\n         span_err!(tcx.sess, span, E0191,\n             \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                    name.user_string(tcx),\n+                    name.user_string(),\n                     ty::item_path_str(tcx, trait_def_id));\n     }\n \n@@ -1160,7 +1160,7 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n             span_note!(tcx.sess, span,\n                        \"associated type `{}` could derive from `{}`\",\n                        ty_param_name,\n-                       bound.user_string(tcx));\n+                       bound.user_string());\n         }\n     }\n \n@@ -1183,7 +1183,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let tcx = this.tcx();\n     let assoc_name = item_segment.identifier.name;\n \n-    debug!(\"associated_path_def_to_ty: {}::{}\", ty.repr(tcx), token::get_name(assoc_name));\n+    debug!(\"associated_path_def_to_ty: {}::{}\", ty.repr(), token::get_name(assoc_name));\n \n     check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n \n@@ -1239,7 +1239,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         _ => {\n             report_ambiguous_associated_type(tcx,\n                                              span,\n-                                             &ty.user_string(tcx),\n+                                             &ty.user_string(),\n                                              \"Trait\",\n                                              &token::get_name(assoc_name));\n             return (tcx.types.err, ty_path_def);\n@@ -1296,7 +1296,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return tcx.types.err;\n     };\n \n-    debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n+    debug!(\"qpath_to_ty: self_type={}\", self_ty.repr());\n \n     let trait_ref = ast_path_to_mono_trait_ref(this,\n                                                rscope,\n@@ -1306,7 +1306,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                Some(self_ty),\n                                                trait_segment);\n \n-    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr());\n \n     this.projected_ty(span, trait_ref, item_segment.identifier.name)\n }\n@@ -1496,7 +1496,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                           -> Ty<'tcx>\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n-           ast_ty.repr(this.tcx()));\n+           ast_ty.repr());\n \n     let tcx = this.tcx();\n \n@@ -1531,7 +1531,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         ast::TyRptr(ref region, ref mt) => {\n             let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-            debug!(\"TyRef r={}\", r.repr(this.tcx()));\n+            debug!(\"TyRef r={}\", r.repr());\n             let rscope1 =\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n@@ -1569,7 +1569,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 }\n             } else {\n                 tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n+                                  &format!(\"unbound path {}\", ast_ty.repr()))\n             };\n             let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n@@ -1846,8 +1846,8 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n             debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={} \\\n                    explicit_type={} \\\n                    modifiers=({},{})\",\n-                   self_info.untransformed_self_ty.repr(this.tcx()),\n-                   explicit_type.repr(this.tcx()),\n+                   self_info.untransformed_self_ty.repr(),\n+                   explicit_type.repr(),\n                    impl_modifiers,\n                    method_modifiers);\n \n@@ -1881,7 +1881,7 @@ pub fn ty_of_closure<'tcx>(\n     -> ty::ClosureTy<'tcx>\n {\n     debug!(\"ty_of_closure(expected_sig={})\",\n-           expected_sig.repr(this.tcx()));\n+           expected_sig.repr());\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -1919,8 +1919,8 @@ pub fn ty_of_closure<'tcx>(\n         ast::NoReturn(..) => ty::FnDiverging\n     };\n \n-    debug!(\"ty_of_closure: input_tys={}\", input_tys.repr(this.tcx()));\n-    debug!(\"ty_of_closure: output_ty={}\", output_ty.repr(this.tcx()));\n+    debug!(\"ty_of_closure: input_tys={}\", input_tys.repr());\n+    debug!(\"ty_of_closure: output_ty={}\", output_ty.repr());\n \n     ty::ClosureTy {\n         unsafety: unsafety,\n@@ -2039,8 +2039,8 @@ fn compute_object_lifetime_bound<'tcx>(\n     debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n            principal_trait_ref={}, builtin_bounds={})\",\n            explicit_region_bounds,\n-           principal_trait_ref.repr(tcx),\n-           builtin_bounds.repr(tcx));\n+           principal_trait_ref.repr(),\n+           builtin_bounds.repr());\n \n     if explicit_region_bounds.len() > 1 {\n         span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,"}, {"sha": "0f1498e2be7e2ea8bcb226cc1846a66ab8eca7d7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -41,8 +41,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     debug!(\"check_pat(pat={},expected={})\",\n-           pat.repr(tcx),\n-           expected.repr(tcx));\n+           pat.repr(),\n+           expected.repr());\n \n     match pat.node {\n         ast::PatWild(_) => {\n@@ -222,7 +222,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             } else {\n                 tcx.sess.span_bug(pat.span,\n-                                  &format!(\"unbound path {}\", pat.repr(tcx)))\n+                                  &format!(\"unbound path {}\", pat.repr()))\n             };\n             if let Some((opt_ty, segments, def)) =\n                     resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),"}, {"sha": "334fe2f54c03c24275bbf9f2663f6905098c52f7", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -24,15 +24,15 @@ pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 body_id: ast::NodeId,\n                                                 value: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr\n {\n-    debug!(\"normalize_associated_types_in(value={})\", value.repr(infcx.tcx));\n+    debug!(\"normalize_associated_types_in(value={})\", value.repr());\n     let mut selcx = SelectionContext::new(infcx, typer);\n     let cause = ObligationCause::new(span, body_id, MiscObligation);\n     let Normalized { value: result, obligations } = traits::normalize(&mut selcx, cause, value);\n     debug!(\"normalize_associated_types_in: result={} predicates={}\",\n-           result.repr(infcx.tcx),\n-           obligations.repr(infcx.tcx));\n+           result.repr(),\n+           obligations.repr());\n     for obligation in obligations {\n         fulfillment_cx.register_predicate_obligation(infcx, obligation);\n     }"}, {"sha": "a5422e1e58e57c7e83e3fa5c6735c625999873f0", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -121,8 +121,8 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       -> Option<CallStep<'tcx>>\n {\n     debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefs={})\",\n-           call_expr.repr(fcx.tcx()),\n-           adjusted_ty.repr(fcx.tcx()),\n+           call_expr.repr(),\n+           adjusted_ty.repr(),\n            autoderefs);\n \n     // If the callee is a bare function or a closure, then we're all set.\n@@ -337,23 +337,23 @@ struct CallResolution<'tcx> {\n     closure_def_id: ast::DefId,\n }\n \n-impl<'tcx> Repr<'tcx> for CallResolution<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for CallResolution<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"CallResolution(call_expr={}, callee_expr={}, adjusted_ty={}, \\\n                 autoderefs={}, fn_sig={}, closure_def_id={})\",\n-                self.call_expr.repr(tcx),\n-                self.callee_expr.repr(tcx),\n-                self.adjusted_ty.repr(tcx),\n+                self.call_expr.repr(),\n+                self.callee_expr.repr(),\n+                self.adjusted_ty.repr(),\n                 self.autoderefs,\n-                self.fn_sig.repr(tcx),\n-                self.closure_def_id.repr(tcx))\n+                self.fn_sig.repr(),\n+                self.closure_def_id.repr())\n     }\n }\n \n impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n     fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {}\",\n-               self.repr(fcx.tcx()));\n+               self.repr());\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n@@ -376,7 +376,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                                               ty::ty_fn_sig(method_callee.ty)).unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={}\",\n-                       method_callee.repr(fcx.tcx()));\n+                       method_callee.repr());\n \n                 for (&method_arg_ty, &self_arg_ty) in\n                     method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs)"}, {"sha": "14976bf95593fd6b4ea1e1fac00bb070a77e4f70", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -192,8 +192,8 @@ impl<'tcx> CastCheck<'tcx> {\n         self.expr_ty = structurally_resolved_type(fcx, self.span, self.expr_ty);\n         self.cast_ty = structurally_resolved_type(fcx, self.span, self.cast_ty);\n \n-        debug!(\"check_cast({}, {} as {})\", self.expr.id, self.expr_ty.repr(fcx.tcx()),\n-               self.cast_ty.repr(fcx.tcx()));\n+        debug!(\"check_cast({}, {} as {})\", self.expr.id, self.expr_ty.repr(),\n+               self.cast_ty.repr());\n \n         if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n             // No sense in giving duplicate error messages\n@@ -274,7 +274,7 @@ impl<'tcx> CastCheck<'tcx> {\n                               -> Result<CastKind, CastError>\n     {\n         debug!(\"check_ptr_ptr_cast m_expr={} m_cast={}\",\n-               m_expr.repr(fcx.tcx()), m_cast.repr(fcx.tcx()));\n+               m_expr.repr(), m_cast.repr());\n         // ptr-ptr cast. vtables must match.\n \n         // Cast to sized is OK"}, {"sha": "16d4c0f997ae16c67919d6acd78350108a897fe1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -29,8 +29,8 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={},expected={})\",\n-           expr.repr(fcx.tcx()),\n-           expected.repr(fcx.tcx()));\n+           expr.repr(),\n+           expected.repr());\n \n     // It's always helpful for inference if we know the kind of\n     // closure sooner rather than later, so first examine the expected\n@@ -52,7 +52,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={}\",\n            opt_kind,\n-           expected_sig.repr(fcx.tcx()));\n+           expected_sig.repr());\n \n     let mut fn_ty = astconv::ty_of_closure(\n         fcx,\n@@ -87,8 +87,8 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n     debug!(\"closure for {} --> sig={} opt_kind={:?}\",\n-           expr_def_id.repr(fcx.tcx()),\n-           fn_ty.sig.repr(fcx.tcx()),\n+           expr_def_id.repr(),\n+           fn_ty.sig.repr(),\n            opt_kind);\n \n     fcx.inh.closure_tys.borrow_mut().insert(expr_def_id, fn_ty);\n@@ -104,7 +104,7 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n     -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n {\n     debug!(\"deduce_expectations_from_expected_type(expected_ty={})\",\n-           expected_ty.repr(fcx.tcx()));\n+           expected_ty.repr());\n \n     match expected_ty.sty {\n         ty::TyTrait(ref object_type) => {\n@@ -139,7 +139,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         .iter()\n         .filter_map(|obligation| {\n             debug!(\"deduce_expectations_from_obligations: obligation.predicate={}\",\n-                   obligation.predicate.repr(fcx.tcx()));\n+                   obligation.predicate.repr());\n \n             match obligation.predicate {\n                 // Given a Projection predicate, we can potentially infer\n@@ -201,7 +201,7 @@ fn deduce_sig_from_projection<'a,'tcx>(\n     let tcx = fcx.tcx();\n \n     debug!(\"deduce_sig_from_projection({})\",\n-           projection.repr(tcx));\n+           projection.repr());\n \n     let trait_ref = projection.to_poly_trait_ref();\n \n@@ -211,24 +211,24 @@ fn deduce_sig_from_projection<'a,'tcx>(\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr());\n \n     let input_tys = match arg_param_ty.sty {\n         ty::TyTuple(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n-    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr());\n \n     let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr());\n \n     let fn_sig = ty::FnSig {\n         inputs: input_tys,\n         output: ty::FnConverging(ret_param_ty),\n         variadic: false\n     };\n-    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr());\n \n     Some(fn_sig)\n }\n@@ -241,8 +241,8 @@ fn self_type_matches_expected_vid<'a,'tcx>(\n {\n     let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n     debug!(\"self_type_matches_expected_vid(trait_ref={}, self_ty={})\",\n-           trait_ref.repr(fcx.tcx()),\n-           self_ty.repr(fcx.tcx()));\n+           trait_ref.repr(),\n+           self_ty.repr());\n     match self_ty.sty {\n         ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n         _ => None,"}, {"sha": "d10a605adb4270d8ddc02b3fba7e871f96ec6cb9", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -105,8 +105,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n               b: Ty<'tcx>)\n               -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a.repr(),\n+               b.repr());\n \n         // Consider coercing the subtype to a DST\n         let unsize = self.unpack_actual_value(a, |a| {\n@@ -167,8 +167,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                mutbl_b: ast::Mutability)\n                                -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a.repr(),\n+               b.repr());\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -239,8 +239,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       target: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(source={}, target={})\",\n-               source.repr(self.tcx()),\n-               target.repr(self.tcx()));\n+               source.repr(),\n+               target.repr());\n \n         let traits = (self.tcx().lang_items.unsize_trait(),\n                       self.tcx().lang_items.coerce_unsized_trait());\n@@ -294,7 +294,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n-            debug!(\"coerce_unsized resolve step: {}\", obligation.repr(self.tcx()));\n+            debug!(\"coerce_unsized resolve step: {}\", obligation.repr());\n             let trait_ref =  match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     tr.clone()\n@@ -336,7 +336,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             autoref: reborrow,\n             unsize: Some(target)\n         };\n-        debug!(\"Success, coerced with {}\", adjustment.repr(self.tcx()));\n+        debug!(\"Success, coerced with {}\", adjustment.repr());\n         Ok(Some(AdjustDerefRef(adjustment)))\n     }\n \n@@ -353,7 +353,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(b, |b| {\n             debug!(\"coerce_from_fn_pointer(a={}, b={})\",\n-                   a.repr(self.tcx()), b.repr(self.tcx()));\n+                   a.repr(), b.repr());\n \n             if let ty::TyBareFn(None, fn_ty_b) = b.sty {\n                 match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n@@ -381,7 +381,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         self.unpack_actual_value(b, |b| {\n             debug!(\"coerce_from_fn_item(a={}, b={})\",\n-                   a.repr(self.tcx()), b.repr(self.tcx()));\n+                   a.repr(), b.repr());\n \n             match b.sty {\n                 ty::TyBareFn(None, _) => {\n@@ -400,8 +400,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                          mutbl_b: ast::Mutability)\n                          -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n+               a.repr(),\n+               b.repr());\n \n         let (is_ref, mt_a) = match a.sty {\n             ty::TyRef(_, mt) => (true, mt),\n@@ -436,7 +436,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n                              -> RelateResult<'tcx, ()> {\n-    debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n+    debug!(\"mk_assignty({} -> {})\", a.repr(), b.repr());\n     let mut unsizing_obligations = vec![];\n     let adjustment = try!(indent(|| {\n         fcx.infcx().commit_if_ok(|_| {\n@@ -460,7 +460,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     if let Some(adjustment) = adjustment {\n-        debug!(\"Success, coerced with {}\", adjustment.repr(fcx.tcx()));\n+        debug!(\"Success, coerced with {}\", adjustment.repr());\n         fcx.write_adjustment(expr.id, adjustment);\n     }\n     Ok(())"}, {"sha": "eb50b231155bbc1de3cabfe087fa2eb5de1afd5a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -39,10 +39,10 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  trait_m: &ty::Method<'tcx>,\n                                  impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n-           impl_trait_ref.repr(tcx));\n+           impl_trait_ref.repr());\n \n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {}\",\n-           impl_trait_ref.repr(tcx));\n+           impl_trait_ref.repr());\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n@@ -64,15 +64,15 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n-                        impl_m.explicit_self.repr(tcx));\n+                        impl_m.explicit_self.repr());\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n             span_err!(tcx.sess, impl_m_span, E0186,\n                 \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n-                        trait_m.explicit_self.repr(tcx));\n+                        trait_m.explicit_self.repr());\n             return;\n         }\n         _ => {\n@@ -184,7 +184,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n     debug!(\"compare_impl_method: trait_to_skol_substs={}\",\n-           trait_to_skol_substs.repr(tcx));\n+           trait_to_skol_substs.repr());\n \n     // Check region bounds. FIXME(@jroesch) refactor this away when removing\n     // ParamBounds.\n@@ -212,7 +212,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             infer::HigherRankedType,\n             &ty::Binder(impl_bounds));\n     debug!(\"compare_impl_method: impl_bounds={}\",\n-           impl_bounds.repr(tcx));\n+           impl_bounds.repr());\n \n     // Normalize the associated types in the trait_bounds.\n     let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n@@ -243,7 +243,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                                normalize_cause.clone());\n \n     debug!(\"compare_impl_method: trait_bounds={}\",\n-        trait_param_env.caller_bounds.repr(tcx));\n+        trait_param_env.caller_bounds.repr());\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n@@ -304,7 +304,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                          abi: impl_m.fty.abi,\n                                                          sig: ty::Binder(impl_sig) }));\n         debug!(\"compare_impl_method: impl_fty={}\",\n-               impl_fty.repr(tcx));\n+               impl_fty.repr());\n \n         let (trait_sig, skol_map) =\n             infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n@@ -325,7 +325,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                          sig: ty::Binder(trait_sig) }));\n \n         debug!(\"compare_impl_method: trait_fty={}\",\n-               trait_fty.repr(tcx));\n+               trait_fty.repr());\n \n         try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n \n@@ -336,8 +336,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         Ok(()) => { }\n         Err(terr) => {\n             debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n-                   impl_fty.repr(tcx),\n-                   trait_fty.repr(tcx));\n+                   impl_fty.repr(),\n+                   trait_fty.repr());\n             span_err!(tcx.sess, impl_m_span, E0053,\n                       \"method `{}` has an incompatible type for trait: {}\",\n                       token::get_name(trait_m.name),\n@@ -385,10 +385,10 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                impl_generics={} \\\n                trait_to_skol_substs={} \\\n                impl_to_skol_substs={}\",\n-               trait_generics.repr(tcx),\n-               impl_generics.repr(tcx),\n-               trait_to_skol_substs.repr(tcx),\n-               impl_to_skol_substs.repr(tcx));\n+               trait_generics.repr(),\n+               impl_generics.repr(),\n+               trait_to_skol_substs.repr(),\n+               impl_to_skol_substs.repr());\n \n         // Must have same number of early-bound lifetime parameters.\n         // Unfortunately, if the user screws up the bounds, then this\n@@ -417,7 +417,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 trait_c: &ty::AssociatedConst<'tcx>,\n                                 impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={})\",\n-           impl_trait_ref.repr(tcx));\n+           impl_trait_ref.repr());\n \n     let infcx = infer::new_infer_ctxt(tcx);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n@@ -444,7 +444,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n                      impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n     debug!(\"compare_const_impl: trait_to_skol_substs={}\",\n-           trait_to_skol_substs.repr(tcx));\n+           trait_to_skol_substs.repr());\n \n     // Compute skolemized form of impl and trait const tys.\n     let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n@@ -462,7 +462,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  0,\n                                                  &impl_ty);\n         debug!(\"compare_const_impl: impl_ty={}\",\n-               impl_ty.repr(tcx));\n+               impl_ty.repr());\n \n         let trait_ty =\n             assoc::normalize_associated_types_in(&infcx,\n@@ -472,7 +472,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  0,\n                                                  &trait_ty);\n         debug!(\"compare_const_impl: trait_ty={}\",\n-               trait_ty.repr(tcx));\n+               trait_ty.repr());\n \n         infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n     });\n@@ -481,8 +481,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n         Ok(()) => { }\n         Err(terr) => {\n             debug!(\"checking associated const for compatibility: impl ty {}, trait ty {}\",\n-                   impl_ty.repr(tcx),\n-                   trait_ty.repr(tcx));\n+                   impl_ty.repr(),\n+                   trait_ty.repr());\n             span_err!(tcx.sess, impl_c_span, E0326,\n                       \"implemented const `{}` has an incompatible type for \\\n                       trait: {}\","}, {"sha": "3fc833034d221f2cf17542c5601519655d955901", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -60,8 +60,8 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n-           expected.repr(fcx.ccx.tcx),\n-           expr_ty.repr(fcx.ccx.tcx));\n+           expected.repr(),\n+           expr_ty.repr());\n     let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n     match coercion::mk_assignty(fcx, expr, expr_ty, expected) {"}, {"sha": "14238179f87c29d931c12d1a1468bd565e77a980", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -62,7 +62,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n             let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n             tcx.sess.span_bug(\n                 span, &format!(\"should have been rejected by coherence check: {}\",\n-                               dtor_self_type.repr(tcx)));\n+                               dtor_self_type.repr()));\n         }\n     }\n }\n@@ -212,7 +212,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n             let item_span = tcx.map.span(self_type_did.node);\n-            let req = predicate.user_string(tcx);\n+            let req = predicate.user_string();\n             span_err!(tcx.sess, drop_impl_span, E0367,\n                       \"The requirement `{}` is added only by the Drop impl.\", req);\n             tcx.sess.span_note(item_span,\n@@ -258,7 +258,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                                                      span: Span,\n                                                      scope: region::CodeExtent) {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {} scope: {:?}\",\n-           typ.repr(rcx.tcx()), scope);\n+           typ.repr(), scope);\n \n     // types that have been traversed so far by `traverse_type_if_unseen`\n     let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n@@ -278,7 +278,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n             let tcx = rcx.tcx();\n             span_err!(tcx.sess, span, E0320,\n                       \"overflow while adding drop-check rules for {}\",\n-                      typ.user_string(rcx.tcx()));\n+                      typ.user_string());\n             match *ctxt {\n                 TypeContext::Root => {\n                     // no need for an additional note if the overflow\n@@ -294,7 +294,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         ty::item_path_str(tcx, def_id),\n                         variant,\n                         arg_index,\n-                        detected_on_typ.user_string(rcx.tcx()));\n+                        detected_on_typ.user_string());\n                 }\n                 TypeContext::Struct { def_id, field } => {\n                     span_note!(\n@@ -303,7 +303,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                         \"overflowed on struct {} field {} type: {}\",\n                         ty::item_path_str(tcx, def_id),\n                         field,\n-                        detected_on_typ.user_string(rcx.tcx()));\n+                        detected_on_typ.user_string());\n                 }\n             }\n         }\n@@ -373,7 +373,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                         .opt_get(subst::TypeSpace, 0).unwrap();\n                     let new_typ = substs.type_for_def(tp_def);\n                     debug!(\"replacing phantom {} with {}\",\n-                           typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                           typ.repr(), new_typ.repr());\n                     (new_typ, xref_depth_orig + 1)\n                 } else {\n                     (typ, xref_depth_orig)\n@@ -385,7 +385,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             // puts us into the previous case.\n             ty::TyBox(new_typ) => {\n                 debug!(\"replacing TyBox {} with {}\",\n-                       typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                       typ.repr(), new_typ.repr());\n                 (new_typ, xref_depth_orig + 1)\n             }\n \n@@ -411,7 +411,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}typ: {} scope: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, xref_depth);\n+               typ.repr(), scope, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -468,7 +468,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             match typ.sty {\n                 ty::TyStruct(struct_did, substs) => {\n                     debug!(\"typ: {} is struct; traverse structure and not type-expression\",\n-                           typ.repr(rcx.tcx()));\n+                           typ.repr());\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -498,7 +498,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n                 ty::TyEnum(enum_did, substs) => {\n                     debug!(\"typ: {} is enum; traverse structure and not type-expression\",\n-                           typ.repr(rcx.tcx()));\n+                           typ.repr());\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -572,23 +572,23 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n         DtorKind::PureRecur => {\n             has_dtor_of_interest = false;\n             debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n-                   typ.repr(tcx));\n+                   typ.repr());\n         }\n         DtorKind::Unknown(bounds) => {\n             match bounds.region_bound {\n                 ty::ReStatic => {\n                     debug!(\"trait: {} has 'static bound, and thus is uninteresting\",\n-                           typ.repr(tcx));\n+                           typ.repr());\n                     has_dtor_of_interest = false;\n                 }\n                 ty::ReEmpty => {\n                     debug!(\"trait: {} has empty region bound, and thus is uninteresting\",\n-                           typ.repr(tcx));\n+                           typ.repr());\n                     has_dtor_of_interest = false;\n                 }\n                 r => {\n                     debug!(\"trait: {} has non-static bound: {}; assumed interesting\",\n-                           typ.repr(tcx), r.repr(tcx));\n+                           typ.repr(), r.repr());\n                     has_dtor_of_interest = true;\n                 }\n             }\n@@ -646,7 +646,7 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     if result {\n                         has_pred_of_interest = true;\n                         debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                               typ.repr(tcx), pred.repr(tcx));\n+                               typ.repr(), pred.repr());\n                         break 'items;\n                     }\n                 }\n@@ -672,12 +672,12 @@ fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if has_dtor_of_interest {\n                 debug!(\"typ: {} has interesting dtor, due to \\\n                         region params: {} or pred: {}\",\n-                       typ.repr(tcx),\n+                       typ.repr(),\n                        has_region_param_of_interest,\n                        has_pred_of_interest);\n             } else {\n                 debug!(\"typ: {} has dtor, but it is uninteresting\",\n-                       typ.repr(tcx));\n+                       typ.repr());\n             }\n         }\n     }"}, {"sha": "2b8394f2e1659abaeaa98a9b09da1ea0e3f99cc6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -57,9 +57,9 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          -> MethodCallee<'tcx>\n {\n     debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n-           unadjusted_self_ty.repr(fcx.tcx()),\n-           pick.repr(fcx.tcx()),\n-           supplied_method_types.repr(fcx.tcx()));\n+           unadjusted_self_ty.repr(),\n+           pick.repr(),\n+           supplied_method_types.repr());\n \n     let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr, call_expr);\n     confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n@@ -93,7 +93,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (method_types, method_regions) =\n             self.instantiate_method_substs(&pick, supplied_method_types);\n         let all_substs = rcvr_substs.with_method(method_types, method_regions);\n-        debug!(\"all_substs={}\", all_substs.repr(self.tcx()));\n+        debug!(\"all_substs={}\", all_substs.repr());\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n@@ -226,9 +226,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     let upcast_trait_ref =\n                         this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n-                           original_poly_trait_ref.repr(this.tcx()),\n-                           upcast_trait_ref.repr(this.tcx()),\n-                           trait_def_id.repr(this.tcx()));\n+                           original_poly_trait_ref.repr(),\n+                           upcast_trait_ref.repr(),\n+                           trait_def_id.repr());\n                     let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n                         trait_ref: upcast_trait_ref,\n@@ -322,7 +322,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx())))\n+                            self_ty.repr()))\n             }\n         }\n     }\n@@ -378,8 +378,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     self.span,\n                     &format!(\n                         \"{} was a subtype of {} but now is not?\",\n-                        self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx())));\n+                        self_ty.repr(),\n+                        method_self_ty.repr()));\n             }\n         }\n     }\n@@ -393,8 +393,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                               -> InstantiatedMethodSig<'tcx>\n     {\n         debug!(\"instantiate_method_sig(pick={}, all_substs={})\",\n-               pick.repr(self.tcx()),\n-               all_substs.repr(self.tcx()));\n+               pick.repr(),\n+               all_substs.repr());\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n@@ -405,7 +405,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                        &method_predicates);\n \n         debug!(\"method_predicates after subst = {}\",\n-               method_predicates.repr(self.tcx()));\n+               method_predicates.repr());\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -416,11 +416,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_sig = self.replace_late_bound_regions_with_fresh_var(\n             &pick.item.as_opt_method().unwrap().fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n-               method_sig.repr(self.tcx()));\n+               method_sig.repr());\n \n         let method_sig = self.fcx.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={}\",\n-               method_sig.repr(self.tcx()));\n+               method_sig.repr());\n \n         InstantiatedMethodSig {\n             method_sig: method_sig,\n@@ -434,9 +434,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                        all_substs: &subst::Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"add_obligations: pick={} all_substs={} method_predicates={}\",\n-               pick.repr(self.tcx()),\n-               all_substs.repr(self.tcx()),\n-               method_predicates.repr(self.tcx()));\n+               pick.repr(),\n+               all_substs.repr(),\n+               method_predicates.repr());\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n@@ -484,7 +484,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         }\n \n         debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n-               exprs.repr(self.tcx()));\n+               exprs.repr());\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n@@ -499,7 +499,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             };\n \n             debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n-                   i, expr.repr(self.tcx()), autoderef_count);\n+                   i, expr.repr(), autoderef_count);\n \n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n@@ -546,7 +546,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                     self.tcx().sess.span_bug(\n                                         base_expr.span,\n                                         &format!(\"unexpected adjustment autoref {}\",\n-                                                adr.repr(self.tcx())));\n+                                                adr.repr()));\n                                 }\n                             },\n                             None => (0, None),\n@@ -648,16 +648,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             self.tcx().sess.span_bug(\n                 self.span,\n                 &format!(\"cannot uniquely upcast `{}` to `{}`: `{}`\",\n-                         source_trait_ref.repr(self.tcx()),\n-                         target_trait_def_id.repr(self.tcx()),\n-                         upcast_trait_refs.repr(self.tcx())));\n+                         source_trait_ref.repr(),\n+                         target_trait_def_id.repr(),\n+                         upcast_trait_refs.repr()));\n         }\n \n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0"}, {"sha": "fd7695b1f0934cdcd0bf9cdaf861018d4c772f56", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -97,10 +97,10 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         -> Result<ty::MethodCallee<'tcx>, MethodError>\n {\n     debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\",\n-           method_name.repr(fcx.tcx()),\n-           self_ty.repr(fcx.tcx()),\n-           call_expr.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()));\n+           method_name.repr(),\n+           self_ty.repr(),\n+           call_expr.repr(),\n+           self_expr.repr());\n \n     let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n@@ -142,10 +142,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           -> Option<ty::MethodCallee<'tcx>>\n {\n     debug!(\"lookup_in_trait_adjusted(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n-           self_ty.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()),\n-           m_name.repr(fcx.tcx()),\n-           trait_def_id.repr(fcx.tcx()));\n+           self_ty.repr(),\n+           self_expr.repr(),\n+           m_name.repr(),\n+           trait_def_id.repr());\n \n     let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n \n@@ -191,7 +191,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n     debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n-           method_num, method_ty.repr(fcx.tcx()));\n+           method_num, method_ty.repr());\n \n     // Instantiate late-bound regions and substitute the trait\n     // parameters into the method type to get the actual method type.\n@@ -211,8 +211,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }));\n \n     debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\",\n-           fty.repr(fcx.tcx()),\n-           obligation.repr(fcx.tcx()));\n+           fty.repr(),\n+           obligation.repr());\n \n     // Register obligations for the parameters.  This will include the\n     // `Self` parameter, which in turn has a bound of the main trait,\n@@ -272,7 +272,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 span,\n                                 &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())));\n+                                    transformed_self_ty.repr()));\n                         }\n                     }\n                 }\n@@ -296,7 +296,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         substs: trait_ref.substs.clone()\n     };\n \n-    debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n+    debug!(\"callee = {}\", callee.repr());\n \n     Some(callee)\n }"}, {"sha": "daa2b95e07e80e7be709402e4f34011730dbff17", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -124,7 +124,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        -> PickResult<'tcx>\n {\n     debug!(\"probe(self_ty={}, item_name={}, scope_expr_id={})\",\n-           self_ty.repr(fcx.tcx()),\n+           self_ty.repr(),\n            item_name,\n            scope_expr_id);\n \n@@ -164,8 +164,8 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n     debug!(\"ProbeContext: steps for self_ty={} are {}\",\n-           self_ty.repr(fcx.tcx()),\n-           steps.repr(fcx.tcx()));\n+           self_ty.repr(),\n+           steps.repr());\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n@@ -269,7 +269,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n         debug!(\"assemble_probe: self_ty={}\",\n-               self_ty.repr(self.tcx()));\n+               self_ty.repr());\n \n         match self_ty.sty {\n             ty::TyTrait(box ref data) => {\n@@ -412,7 +412,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-               xform_self_ty.repr(self.tcx()));\n+               xform_self_ty.repr());\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n@@ -425,7 +425,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                 self_ty: Ty<'tcx>,\n                                                 data: &ty::TraitTy<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n-               self_ty.repr(self.tcx()));\n+               self_ty.repr());\n \n         let tcx = self.tcx();\n \n@@ -497,9 +497,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             if let Some(ref m) = item.as_opt_method() {\n                 debug!(\"found match: trait_ref={} substs={} m={}\",\n-                       trait_ref.repr(this.tcx()),\n-                       trait_ref.substs.repr(this.tcx()),\n-                       m.repr(this.tcx()));\n+                       trait_ref.repr(),\n+                       trait_ref.substs.repr(),\n+                       m.repr());\n                 assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n                            trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n@@ -539,7 +539,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             usize,\n         ),\n     {\n-        debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n+        debug!(\"elaborate_bounds(bounds={})\", bounds.repr());\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n@@ -589,7 +589,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                -> Result<(),MethodError>\n     {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx()));\n+               trait_def_id.repr());\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n@@ -639,23 +639,23 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n         trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n-                   trait_def_id.repr(self.tcx()),\n-                   impl_def_id.repr(self.tcx()));\n+                   trait_def_id.repr(),\n+                   impl_def_id.repr());\n \n             if !self.impl_can_possibly_match(impl_def_id) {\n                 return;\n             }\n \n             let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n \n-            debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n+            debug!(\"impl_substs={}\", impl_substs.repr());\n \n             let impl_trait_ref =\n                 ty::impl_trait_ref(self.tcx(), impl_def_id)\n                 .unwrap() // we know this is a trait impl\n                 .subst(self.tcx(), &impl_substs);\n \n-            debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(self.tcx()));\n+            debug!(\"impl_trait_ref={}\", impl_trait_ref.repr());\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n@@ -671,7 +671,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n-            debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n+            debug!(\"xform_self_ty={}\", xform_self_ty.repr());\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -772,28 +772,28 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                trait_def_id={}, \\\n                item={}, \\\n                item_index={})\",\n-               trait_def_id.repr(self.tcx()),\n-               item.repr(self.tcx()),\n+               trait_def_id.repr(),\n+               item.repr(),\n                item_index);\n \n         for step in self.steps.iter() {\n             debug!(\"assemble_projection_candidates: step={}\",\n-                   step.repr(self.tcx()));\n+                   step.repr());\n \n             let projection_trait_ref = match step.self_ty.sty {\n                 ty::TyProjection(ref data) => &data.trait_ref,\n                 _ => continue,\n             };\n \n             debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n-                   projection_trait_ref.repr(self.tcx()));\n+                   projection_trait_ref.repr());\n \n             let trait_predicates = ty::lookup_predicates(self.tcx(),\n                                                          projection_trait_ref.def_id);\n             let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={}\",\n-                   predicates.repr(self.tcx()));\n+                   predicates.repr());\n             for poly_bound in\n                 traits::elaborate_predicates(self.tcx(), predicates)\n                 .filter_map(|p| p.to_opt_poly_trait_ref())\n@@ -802,17 +802,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 let bound = self.erase_late_bound_regions(&poly_bound);\n \n                 debug!(\"assemble_projection_candidates: projection_trait_ref={} bound={}\",\n-                       projection_trait_ref.repr(self.tcx()),\n-                       bound.repr(self.tcx()));\n+                       projection_trait_ref.repr(),\n+                       bound.repr());\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n-                           bound.repr(self.tcx()),\n-                           xform_self_ty.repr(self.tcx()));\n+                           bound.repr(),\n+                           xform_self_ty.repr());\n \n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n@@ -830,7 +830,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                         item_index: usize)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx()));\n+               trait_def_id.repr());\n \n         let caller_predicates = self.fcx.inh.param_env.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n@@ -843,8 +843,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                    bound.substs);\n \n             debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n-                   bound.repr(self.tcx()),\n-                   xform_self_ty.repr(self.tcx()));\n+                   bound.repr(),\n+                   xform_self_ty.repr());\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -910,7 +910,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_step: step={}\", step.repr(self.tcx()));\n+        debug!(\"pick_step: step={}\", step.repr());\n \n         if ty::type_is_error(step.self_ty) {\n             return None;\n@@ -1008,7 +1008,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                   .filter(|&probe| self.consider_probe(self_ty, probe))\n                   .collect();\n \n-        debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n+        debug!(\"applicable_candidates: {}\", applicable_candidates.repr());\n \n         if applicable_candidates.len() > 1 {\n             match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n@@ -1030,8 +1030,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>) -> bool {\n         debug!(\"consider_probe: self_ty={} probe={}\",\n-               self_ty.repr(self.tcx()),\n-               probe.repr(self.tcx()));\n+               self_ty.repr(),\n+               probe.repr());\n \n         self.infcx().probe(|_| {\n             // First check that the self type can be related.\n@@ -1065,7 +1065,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                         traits::predicates_for_generics(self.tcx(),\n                                                         cause.clone(),\n                                                         &impl_bounds);\n-                    debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n+                    debug!(\"impl_obligations={}\", obligations.repr());\n \n                     // Evaluate those obligations to see if they might possibly hold.\n                     obligations.iter()\n@@ -1178,9 +1178,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                             -> Ty<'tcx>\n     {\n         debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n-               impl_ty.repr(self.tcx()),\n-               method.fty.sig.0.inputs.get(0).repr(self.tcx()),\n-               substs.repr(self.tcx()));\n+               impl_ty.repr(),\n+               method.fty.sig.0.inputs.get(0).repr(),\n+               substs.repr());\n \n         assert!(!substs.has_escaping_regions());\n \n@@ -1265,7 +1265,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///    and/or tracking the substitution and\n     ///    so forth.\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         ty::erase_late_bound_regions(self.tcx(), value)\n     }\n@@ -1372,58 +1372,58 @@ impl<'tcx> Candidate<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for Candidate<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"Candidate(xform_self_ty={}, kind={})\",\n-                self.xform_self_ty.repr(tcx),\n-                self.kind.repr(tcx))\n+                self.xform_self_ty.repr(),\n+                self.kind.repr())\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for CandidateKind<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             InherentImplCandidate(ref a, ref b, ref c) =>\n-                format!(\"InherentImplCandidate({},{},{})\", a.repr(tcx), b.repr(tcx),\n-                        c.repr(tcx)),\n+                format!(\"InherentImplCandidate({},{},{})\", a.repr(), b.repr(),\n+                        c.repr()),\n             ObjectCandidate(a, b, c) =>\n-                format!(\"ObjectCandidate({},{},{})\", a.repr(tcx), b, c),\n+                format!(\"ObjectCandidate({},{},{})\", a.repr(), b, c),\n             ExtensionImplCandidate(ref a, ref b, ref c, ref d, ref e) =>\n-                format!(\"ExtensionImplCandidate({},{},{},{},{})\", a.repr(tcx), b.repr(tcx),\n-                        c.repr(tcx), d, e.repr(tcx)),\n+                format!(\"ExtensionImplCandidate({},{},{},{},{})\", a.repr(), b.repr(),\n+                        c.repr(), d, e.repr()),\n             ClosureCandidate(ref a, ref b) =>\n-                format!(\"ClosureCandidate({},{})\", a.repr(tcx), b),\n+                format!(\"ClosureCandidate({},{})\", a.repr(), b),\n             WhereClauseCandidate(ref a, ref b) =>\n-                format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n+                format!(\"WhereClauseCandidate({},{})\", a.repr(), b),\n             ProjectionCandidate(ref a, ref b) =>\n-                format!(\"ProjectionCandidate({},{})\", a.repr(tcx), b),\n+                format!(\"ProjectionCandidate({},{})\", a.repr(), b),\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for CandidateStep<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for CandidateStep<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"CandidateStep({}, autoderefs={}, unsize={})\",\n-                self.self_ty.repr(tcx),\n+                self.self_ty.repr(),\n                 self.autoderefs,\n                 self.unsize)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n-    fn repr(&self, _tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr for PickKind<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for Pick<'tcx> {\n+    fn repr(&self) -> String {\n         format!(\"Pick(item={}, autoderefs={},\n                  autoref={}, unsize={}, kind={:?})\",\n-                self.item.repr(tcx),\n+                self.item.repr(),\n                 self.autoderefs,\n-                self.autoref.repr(tcx),\n-                self.unsize.repr(tcx),\n+                self.autoref.repr(),\n+                self.unsize.repr(),\n                 self.kind)\n     }\n }"}, {"sha": "52fdf52c35da7393101993f1284269440d60c372", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -45,7 +45,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match error {\n         MethodError::NoMatch(static_sources, out_of_scope_traits, mode) => {\n             let cx = fcx.tcx();\n-            let item_ustring = item_name.user_string(cx);\n+            let item_ustring = item_name.user_string();\n \n             fcx.type_error_message(\n                 span,\n@@ -93,7 +93,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n-                               item_name.user_string(fcx.tcx()),\n+                               item_name.user_string(),\n                                ty::item_path_str(fcx.tcx(), trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n@@ -134,7 +134,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n                                idx + 1,\n                                insertion,\n-                               impl_ty.user_string(fcx.tcx()));\n+                               impl_ty.user_string());\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n                     let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n@@ -160,7 +160,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n-    let item_ustring = item_name.user_string(tcx);\n+    let item_ustring = item_name.user_string();\n \n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;"}, {"sha": "34403b53fc6f0dbd8583c4e71d39e1289d398936", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                                         body_id: ast::NodeId,\n                                         value: &T)\n                                         -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         assoc::normalize_associated_types_in(&self.infcx,\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                        token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_string(\n                            self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n-                       var_ty.repr(self.fcx.tcx()));\n+                       var_ty.repr());\n             }\n         }\n         visit::walk_pat(self, p);\n@@ -642,8 +642,8 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n-           arg_tys.repr(tcx),\n-           ret_ty.repr(tcx),\n+           arg_tys.repr(),\n+           ret_ty.repr(),\n            fn_id);\n \n     // Create the function context.  This is either derived from scratch or,\n@@ -671,7 +671,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     debug!(\"fn-sig-map: fn_id={} fn_sig_tys={}\",\n            fn_id,\n-           fn_sig_tys.repr(tcx));\n+           fn_sig_tys.repr());\n \n     inherited.fn_sig_map.borrow_mut().insert(fn_id, fn_sig_tys);\n \n@@ -919,11 +919,11 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                body: &'tcx ast::Block,\n                                id: ast::NodeId, span: Span) {\n     debug!(\"check_method_body(item_generics={}, id={})\",\n-            item_generics.repr(ccx.tcx), id);\n+            item_generics.repr(), id);\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n+    debug!(\"check_method_body: fty={}\", fty.repr());\n \n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n@@ -965,7 +965,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           \"item `{}` is an associated const, \\\n                                           which doesn't match its trait `{}`\",\n                                           token::get_name(impl_const_ty.name()),\n-                                          impl_trait_ref.repr(tcx))\n+                                          impl_trait_ref.repr())\n                             }\n                         }\n                     }\n@@ -978,7 +978,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 \"associated const `{}` is not a member of \\\n                                  trait `{}`\",\n                                 token::get_name(impl_const_ty.name()),\n-                                impl_trait_ref.repr(tcx)));\n+                                impl_trait_ref.repr()));\n                     }\n                 }\n             }\n@@ -1011,7 +1011,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           \"item `{}` is an associated method, \\\n                                           which doesn't match its trait `{}`\",\n                                           token::get_name(impl_item_ty.name()),\n-                                          impl_trait_ref.repr(tcx))\n+                                          impl_trait_ref.repr())\n                             }\n                         }\n                     }\n@@ -1022,7 +1022,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             impl_item.span,\n                             &format!(\"method `{}` is not a member of trait `{}`\",\n                                      token::get_name(impl_item_ty.name()),\n-                                     impl_trait_ref.repr(tcx)));\n+                                     impl_trait_ref.repr()));\n                     }\n                 }\n             }\n@@ -1045,7 +1045,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           \"item `{}` is an associated type, \\\n                                           which doesn't match its trait `{}`\",\n                                           token::get_name(typedef_ty.name()),\n-                                          impl_trait_ref.repr(tcx))\n+                                          impl_trait_ref.repr())\n                             }\n                         }\n                     }\n@@ -1058,7 +1058,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n                                 token::get_name(typedef_ty.name()),\n-                                impl_trait_ref.repr(tcx)));\n+                                impl_trait_ref.repr()));\n                     }\n                 }\n             }\n@@ -1295,26 +1295,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// version, this version will also select obligations if it seems\n     /// useful, in an effort to get more type information.\n     fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type_vars_if_possible(ty={})\", ty.repr(self.tcx()));\n+        debug!(\"resolve_type_vars_if_possible(ty={})\", ty.repr());\n \n         // No ty::infer()? Nothing needs doing.\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n             return ty;\n         }\n \n         // If not, try resolving any new fcx obligations that have cropped up.\n         self.select_new_obligations();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n         if !ty::type_has_ty_infer(ty) {\n-            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+            debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n             return ty;\n         }\n \n@@ -1325,7 +1325,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.select_obligations_where_possible();\n         ty = self.infcx().resolve_type_vars_if_possible(&ty);\n \n-        debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr(self.tcx()));\n+        debug!(\"resolve_type_vars_if_possible: ty={}\", ty.repr());\n         ty\n     }\n \n@@ -1396,15 +1396,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n-               node_id, ty.repr(self.tcx()), self.tag());\n+               node_id, ty.repr(), self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n-                   substs.repr(self.tcx()),\n+                   substs.repr(),\n                    self.tag());\n \n             self.inh.item_substs.borrow_mut().insert(node_id, substs);\n@@ -1427,7 +1427,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             adj: ty::AutoAdjustment<'tcx>) {\n-        debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj.repr(self.tcx()));\n+        debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj.repr());\n \n         if adj.is_identity() {\n             return;\n@@ -1444,14 +1444,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                   substs: &Substs<'tcx>,\n                                   value: &T)\n                                   -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr\n     {\n         let value = value.subst(self.tcx(), substs);\n         let result = self.normalize_associated_types_in(span, &value);\n         debug!(\"instantiate_type_scheme(value={}, substs={}) = {}\",\n-               value.repr(self.tcx()),\n-               substs.repr(self.tcx()),\n-               result.repr(self.tcx()));\n+               value.repr(),\n+               substs.repr(),\n+               result.repr());\n         result\n     }\n \n@@ -1470,7 +1470,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n-        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr\n     {\n         self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n     }\n@@ -1616,7 +1616,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               obligation: traits::PredicateObligation<'tcx>)\n     {\n         debug!(\"register_predicate({})\",\n-               obligation.repr(self.tcx()));\n+               obligation.repr());\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self.infcx(), obligation);\n@@ -1634,7 +1634,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn pat_to_string(&self, pat: &ast::Pat) -> String {\n-        pat.repr(self.tcx())\n+        pat.repr()\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n@@ -1785,7 +1785,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert!(!predicates.has_escaping_regions());\n \n         debug!(\"add_obligations_for_parameters(predicates={})\",\n-               predicates.repr(self.tcx()));\n+               predicates.repr());\n \n         for obligation in traits::predicates_for_generics(self.tcx(),\n                                                           cause,\n@@ -1943,8 +1943,8 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n     debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n-           base_ty.repr(fcx.tcx()),\n-           opt_expr.repr(fcx.tcx()),\n+           base_ty.repr(),\n+           opt_expr.repr(),\n            lvalue_pref);\n \n     let mut t = base_ty;\n@@ -2005,7 +2005,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // We've reached the recursion limit, error gracefully.\n     span_err!(fcx.tcx().sess, sp, E0055,\n         \"reached the recursion limit while auto-dereferencing {}\",\n-        base_ty.repr(fcx.tcx()));\n+        base_ty.repr());\n     (fcx.tcx().types.err, 0, None)\n }\n \n@@ -2122,12 +2122,12 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.tcx();\n     debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, \\\n                            autoderefs={}, unsize={}, index_ty={})\",\n-           expr.repr(tcx),\n-           base_expr.repr(tcx),\n-           adjusted_ty.repr(tcx),\n+           expr.repr(),\n+           base_expr.repr(),\n+           adjusted_ty.repr(),\n            autoderefs,\n            unsize,\n-           index_ty.repr(tcx));\n+           index_ty.repr());\n \n     let input_ty = fcx.infcx().next_ty_var();\n \n@@ -2607,8 +2607,8 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }).unwrap_or(vec![]);\n     debug!(\"expected_types_for_fn_args(formal={} -> {}, expected={} -> {})\",\n-           formal_args.repr(fcx.tcx()), formal_ret.repr(fcx.tcx()),\n-           expected_args.repr(fcx.tcx()), expected_ret.repr(fcx.tcx()));\n+           formal_args.repr(), formal_ret.repr(),\n+           expected_args.repr(), expected_ret.repr());\n     expected_args\n }\n \n@@ -2630,7 +2630,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     F: FnOnce(),\n {\n     debug!(\">> typechecking: expr={} expected={}\",\n-           expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n+           expr.repr(), expected.repr());\n \n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2746,7 +2746,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   |base_t, _| {\n                 match base_t.sty {\n                     ty::TyStruct(base_id, substs) => {\n-                        debug!(\"struct named {}\",  base_t.repr(tcx));\n+                        debug!(\"struct named {}\",  base_t.repr());\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n                         fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n                                             field.node.name, &(*substs))\n@@ -2850,7 +2850,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::TyStruct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n-                            debug!(\"tuple struct named {}\",  base_t.repr(tcx));\n+                            debug!(\"tuple struct named {}\",  base_t.repr());\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n                             fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n                                                     idx.node, &(*substs))\n@@ -3276,7 +3276,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             } else {\n               tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {}\", expr.repr(tcx)))\n+                                &format!(\"unbound path {}\", expr.repr()))\n           };\n \n           if let Some((opt_ty, segments, def)) =\n@@ -3749,8 +3749,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"type of expr({}) {} is...\", expr.id,\n            syntax::print::pprust::expr_to_string(expr));\n     debug!(\"... {}, expected is {}\",\n-           fcx.expr_ty(expr).repr(tcx),\n-           expected.repr(tcx));\n+           fcx.expr_ty(expr).repr(),\n+           expected.repr());\n \n     unifier();\n }\n@@ -3909,16 +3909,16 @@ impl<'tcx> Expectation<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+impl<'tcx> Repr for Expectation<'tcx> {\n+    fn repr(&self) -> String {\n         match *self {\n             NoExpectation => format!(\"NoExpectation\"),\n             ExpectHasType(t) => format!(\"ExpectHasType({})\",\n-                                        t.repr(tcx)),\n+                                        t.repr()),\n             ExpectCastableToType(t) => format!(\"ExpectCastableToType({})\",\n-                                               t.repr(tcx)),\n+                                               t.repr()),\n             ExpectRvalueLikeUnsized(t) => format!(\"ExpectRvalueLikeUnsized({})\",\n-                                                  t.repr(tcx)),\n+                                                  t.repr()),\n         }\n     }\n }\n@@ -4198,7 +4198,7 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n             \"this type cannot be instantiated without an \\\n              instance of itself\");\n         fileline_help!(tcx.sess, sp, \"consider using `Option<{}>`\",\n-             item_ty.repr(tcx));\n+             item_ty.repr());\n         false\n     } else {\n         true\n@@ -4391,9 +4391,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   node_id: ast::NodeId) {\n     debug!(\"instantiate_path(path={:?}, def={}, node_id={}, type_scheme={})\",\n            segments,\n-           def.repr(fcx.tcx()),\n+           def.repr(),\n            node_id,\n-           type_scheme.repr(fcx.tcx()));\n+           type_scheme.repr());\n \n     // We need to extract the type parameters supplied by the user in\n     // the path `path`. Due to the current setup, this is a bit of a\n@@ -4634,8 +4634,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx.tcx().sess.span_bug(span,\n             &format!(\n                 \"instantiate_path: (UFCS) {} was a subtype of {} but now is not?\",\n-                self_ty.repr(fcx.tcx()),\n-                impl_ty.repr(fcx.tcx())));\n+                self_ty.repr(),\n+                impl_ty.repr()));\n         }\n     }\n \n@@ -4840,7 +4840,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         assert_eq!(substs.types.len(space), desired.len());\n \n-        debug!(\"Final substs: {}\", substs.repr(fcx.tcx()));\n+        debug!(\"Final substs: {}\", substs.repr());\n     }\n \n     fn adjust_region_parameters(\n@@ -4950,7 +4950,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        tps: &OwnedSlice<ast::TyParam>,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n-           tps.len(),  ty.repr(ccx.tcx));\n+           tps.len(),  ty.repr());\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.is_empty() { return; }\n@@ -5273,7 +5273,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                            fty,\n                            || {\n                 format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty.user_string(ccx.tcx))\n+                         fty.user_string())\n             });\n     }\n }"}, {"sha": "fbff7afb3e59c51c10e534043ff5ecab893118fb", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -51,8 +51,8 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         span_err!(tcx.sess, lhs_expr.span, E0368,\n                   \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n                   ast_util::binop_to_string(op.node),\n-                  lhs_ty.user_string(fcx.tcx()),\n-                  rhs_ty.user_string(fcx.tcx()));\n+                  lhs_ty.user_string(),\n+                  rhs_ty.user_string());\n         fcx.write_error(expr.id);\n     }\n \n@@ -75,10 +75,10 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     debug!(\"check_binop(expr.id={}, expr={}, op={:?}, lhs_expr={}, rhs_expr={})\",\n            expr.id,\n-           expr.repr(tcx),\n+           expr.repr(),\n            op,\n-           lhs_expr.repr(tcx),\n-           rhs_expr.repr(tcx));\n+           lhs_expr.repr(),\n+           rhs_expr.repr());\n \n     check_expr(fcx, lhs_expr);\n     let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n@@ -181,15 +181,15 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if ty::type_is_simd(tcx, lhs_ty) {\n                 let unit_ty = ty::simd_type(tcx, lhs_ty);\n                 debug!(\"enforce_builtin_binop_types: lhs_ty={} unit_ty={}\",\n-                       lhs_ty.repr(tcx),\n-                       unit_ty.repr(tcx));\n+                       lhs_ty.repr(),\n+                       unit_ty.repr());\n                 if !ty::type_is_integral(unit_ty) {\n                     tcx.sess.span_err(\n                         lhs_expr.span,\n                         &format!(\"binary comparison operation `{}` not supported \\\n                                   for floating point SIMD vector `{}`\",\n                                  ast_util::binop_to_string(op.node),\n-                                 lhs_ty.user_string(tcx)));\n+                                 lhs_ty.user_string()));\n                     tcx.types.err\n                 } else {\n                     lhs_ty\n@@ -211,7 +211,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={})\",\n            expr.id,\n-           lhs_ty.repr(fcx.tcx()));\n+           lhs_ty.repr());\n \n     let (name, trait_def_id) = name_and_trait_def_id(fcx, op);\n \n@@ -233,7 +233,7 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n                           \"binary operation `{}` cannot be applied to type `{}`\",\n                           ast_util::binop_to_string(op.node),\n-                          lhs_ty.user_string(fcx.tcx()));\n+                          lhs_ty.user_string());\n             }\n             fcx.tcx().types.err\n         }\n@@ -305,11 +305,11 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                               -> Result<Ty<'tcx>,()>\n {\n     debug!(\"lookup_op_method(expr={}, lhs_ty={}, opname={:?}, trait_did={}, lhs_expr={})\",\n-           expr.repr(fcx.tcx()),\n-           lhs_ty.repr(fcx.tcx()),\n+           expr.repr(),\n+           lhs_ty.repr(),\n            opname,\n-           trait_did.repr(fcx.tcx()),\n-           lhs_expr.repr(fcx.tcx()));\n+           trait_did.repr(),\n+           lhs_expr.repr());\n \n     let method = match trait_did {\n         Some(trait_did) => {"}, {"sha": "057b4de3f0d96ed9e922869101704fd92b0228a3", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         for r_o in &region_obligations {\n             debug!(\"visit_region_obligations: r_o={}\",\n-                   r_o.repr(self.tcx()));\n+                   r_o.repr());\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateParamBound(r_o.cause.span, sup_type);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n-            debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n+            debug!(\"relate_free_regions(t={})\", ty.repr());\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n             let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n@@ -365,7 +365,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             // that don't go into the free-region-map but which we use\n             // here.\n             for implication in implications {\n-                debug!(\"implication: {}\", implication.repr(tcx));\n+                debug!(\"implication: {}\", implication.repr());\n                 match implication {\n                     implicator::Implication::RegionSubRegion(_,\n                                                              ty::ReFree(free_a),\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                     }\n                     implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n                         debug!(\"RegionSubGeneric: {} <= {}\",\n-                               r_a.repr(tcx), generic_b.repr(tcx));\n+                               r_a.repr(), generic_b.repr());\n \n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n@@ -465,7 +465,7 @@ fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n \n fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n-    debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n+    debug!(\"regionck::visit_pat(pat={})\", pat.repr());\n     pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n@@ -503,7 +503,7 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n \n fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={})\",\n-           expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n+           expr.repr(), rcx.repeating_scope);\n \n     // No matter what, the type of each expression must outlive the\n     // scope of that expression. This also guarantees basic WF.\n@@ -746,8 +746,8 @@ fn constrain_cast(rcx: &mut Rcx,\n                   source_expr: &ast::Expr)\n {\n     debug!(\"constrain_cast(cast_expr={}, source_expr={})\",\n-           cast_expr.repr(rcx.tcx()),\n-           source_expr.repr(rcx.tcx()));\n+           cast_expr.repr(),\n+           source_expr.repr());\n \n     let source_ty = rcx.resolve_node_type(source_expr.id);\n     let target_ty = rcx.resolve_node_type(cast_expr.id);\n@@ -759,8 +759,8 @@ fn constrain_cast(rcx: &mut Rcx,\n                            from_ty: Ty<'tcx>,\n                            to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={}, to_ty={})\",\n-               from_ty.repr(rcx.tcx()),\n-               to_ty.repr(rcx.tcx()));\n+               from_ty.repr(),\n+               to_ty.repr());\n         match (&from_ty.sty, &to_ty.sty) {\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n@@ -808,7 +808,7 @@ fn constrain_callee(rcx: &mut Rcx,\n             //\n             // tcx.sess.span_bug(\n             //     callee_expr.span,\n-            //     format!(\"Calling non-function: {}\", callee_ty.repr(tcx)));\n+            //     format!(\"Calling non-function: {}\", callee_ty.repr()));\n         }\n     }\n }\n@@ -827,8 +827,8 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     debug!(\"constrain_call(call_expr={}, \\\n             receiver={}, \\\n             implicitly_ref_args={})\",\n-            call_expr.repr(tcx),\n-            receiver.repr(tcx),\n+            call_expr.repr(),\n+            receiver.repr(),\n             implicitly_ref_args);\n \n     // `callee_region` is the scope representing the time in which the\n@@ -838,10 +838,10 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     let callee_scope = CodeExtent::from_node_id(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n-    debug!(\"callee_region={}\", callee_region.repr(tcx));\n+    debug!(\"callee_region={}\", callee_region.repr());\n \n     for arg_expr in arg_exprs {\n-        debug!(\"Argument: {}\", arg_expr.repr(tcx));\n+        debug!(\"Argument: {}\", arg_expr.repr());\n \n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n@@ -860,7 +860,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n \n     // as loop above, but for receiver\n     if let Some(r) = receiver {\n-        debug!(\"receiver: {}\", r.repr(tcx));\n+        debug!(\"receiver: {}\", r.repr());\n         type_of_node_must_outlive(\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n@@ -878,9 +878,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   mut derefd_ty: Ty<'tcx>)\n {\n     debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n-           deref_expr.repr(rcx.tcx()),\n+           deref_expr.repr(),\n            derefs,\n-           derefd_ty.repr(rcx.tcx()));\n+           derefd_ty.repr());\n \n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in 0..derefs {\n@@ -890,7 +890,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n         derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n                 debug!(\"constrain_autoderefs: #{} is overloaded, method={}\",\n-                       i, method.repr(rcx.tcx()));\n+                       i, method.repr());\n \n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n@@ -904,18 +904,18 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                         rcx.tcx().sess.span_bug(\n                             deref_expr.span,\n                             &format!(\"bad overloaded deref type {}\",\n-                                     method.ty.repr(rcx.tcx())))\n+                                     method.ty.repr()))\n                     }\n                 };\n \n                 debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n-                       r.repr(rcx.tcx()), m);\n+                       r.repr(), m);\n \n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n-                           self_cmt.repr(rcx.tcx()));\n+                           self_cmt.repr());\n                     link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -977,7 +977,7 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n                        .span_bug(span,\n                                  &format!(\"unexpected rvalue region in rvalue \\\n                                            destructor safety checking: `{}`\",\n-                                          region.repr(rcx.tcx())));\n+                                          region.repr()));\n                 }\n             }\n         }\n@@ -1025,7 +1025,7 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n-            ty.user_string(tcx),  ty0.user_string(tcx),\n+            ty.user_string(),  ty0.user_string(),\n            id, minimum_lifetime);\n     type_must_outlive(rcx, origin, ty, minimum_lifetime);\n }\n@@ -1034,14 +1034,14 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n                 mutability: ast::Mutability, base: &ast::Expr) {\n-    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(rcx.tcx()), base.repr(rcx.tcx()));\n+    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(), base.repr());\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n \n-    debug!(\"link_addr_of: cmt={}\", cmt.repr(rcx.tcx()));\n+    debug!(\"link_addr_of: cmt={}\", cmt.repr());\n \n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1067,7 +1067,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n-    debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n+    debug!(\"discr_cmt={}\", discr_cmt.repr());\n     for arm in arms {\n         for root_pat in &arm.pats {\n             link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n@@ -1086,8 +1086,8 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n         debug!(\"arg_ty={} arg_cmt={}\",\n-               arg_ty.repr(rcx.tcx()),\n-               arg_cmt.repr(rcx.tcx()));\n+               arg_ty.repr(),\n+               arg_cmt.repr());\n         link_pattern(rcx, mc, arg_cmt, &*arg.pat);\n     }\n }\n@@ -1099,8 +1099,8 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n     debug!(\"link_pattern(discr_cmt={}, root_pat={})\",\n-           discr_cmt.repr(rcx.tcx()),\n-           root_pat.repr(rcx.tcx()));\n+           discr_cmt.repr(),\n+           root_pat.repr());\n     let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n             match sub_pat.node {\n                 // `ref x` pattern\n@@ -1136,7 +1136,7 @@ fn link_autoref(rcx: &Rcx,\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n-    debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n+    debug!(\"expr_cmt={}\", expr_cmt.repr());\n \n     match *autoref {\n         ty::AutoPtr(r, m) => {\n@@ -1158,7 +1158,7 @@ fn link_by_ref(rcx: &Rcx,\n                callee_scope: CodeExtent) {\n     let tcx = rcx.tcx();\n     debug!(\"link_by_ref(expr={}, callee_scope={:?})\",\n-           expr.repr(tcx), callee_scope);\n+           expr.repr(), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n@@ -1173,12 +1173,12 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                         mutbl: ast::Mutability,\n                                         cmt_borrowed: mc::cmt<'tcx>) {\n     debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={})\",\n-           id, mutbl, cmt_borrowed.repr(rcx.tcx()));\n+           id, mutbl, cmt_borrowed.repr());\n \n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"rptr_ty={}\",  rptr_ty.user_string(tcx));\n+        debug!(\"rptr_ty={}\",  rptr_ty.user_string());\n         let r = ty::ty_region(tcx, span, rptr_ty);\n         link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n                     cmt_borrowed);\n@@ -1198,9 +1198,9 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n     loop {\n         debug!(\"link_region(borrow_region={}, borrow_kind={}, borrow_cmt={})\",\n-               borrow_region.repr(rcx.tcx()),\n-               borrow_kind.repr(rcx.tcx()),\n-               borrow_cmt.repr(rcx.tcx()));\n+               borrow_region.repr(),\n+               borrow_kind.repr(),\n+               borrow_cmt.repr());\n         match borrow_cmt.cat.clone() {\n             mc::cat_deref(ref_cmt, _,\n                           mc::Implicit(ref_kind, ref_region)) |\n@@ -1311,7 +1311,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                     rcx.tcx().sess.span_bug(\n                         span,\n                         &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr(rcx.tcx())));\n+                                upvar_id.repr()));\n                 }\n             }\n         }\n@@ -1327,8 +1327,8 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     };\n \n     debug!(\"link_reborrowed_region: {} <= {}\",\n-           borrow_region.repr(rcx.tcx()),\n-           ref_region.repr(rcx.tcx()));\n+           borrow_region.repr(),\n+           ref_region.repr());\n     rcx.fcx.mk_subr(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n@@ -1402,13 +1402,13 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                region: ty::Region)\n {\n     debug!(\"type_must_outlive(ty={}, region={})\",\n-           ty.repr(rcx.tcx()),\n-           region.repr(rcx.tcx()));\n+           ty.repr(),\n+           region.repr());\n \n     let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n                                                 ty, region, origin.span());\n     for implication in implications {\n-        debug!(\"implication: {}\", implication.repr(rcx.tcx()));\n+        debug!(\"implication: {}\", implication.repr());\n         match implication {\n             implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n                 rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n@@ -1444,7 +1444,7 @@ fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   def_id: ast::DefId,\n                                   substs: &'tcx Substs<'tcx>) {\n     debug!(\"closure_must_outlive(region={}, def_id={}, substs={})\",\n-           region.repr(rcx.tcx()), def_id.repr(rcx.tcx()), substs.repr(rcx.tcx()));\n+           region.repr(), def_id.repr(), substs.repr());\n \n     let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n     for upvar in upvars {\n@@ -1462,8 +1462,8 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let param_env = &rcx.fcx.inh.param_env;\n \n     debug!(\"param_must_outlive(region={}, generic={})\",\n-           region.repr(rcx.tcx()),\n-           generic.repr(rcx.tcx()));\n+           region.repr(),\n+           generic.repr());\n \n     // To start, collect bounds from user:\n     let mut param_bounds =\n@@ -1497,8 +1497,8 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // don't know that this holds from first principles.\n     for &(ref r, ref p) in &rcx.region_bound_pairs {\n         debug!(\"generic={} p={}\",\n-               generic.repr(rcx.tcx()),\n-               p.repr(rcx.tcx()));\n+               generic.repr(),\n+               p.repr());\n         if generic == p {\n             param_bounds.push(*r);\n         }\n@@ -1522,7 +1522,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let infcx = fcx.infcx();\n \n     debug!(\"projection_bounds(projection_ty={})\",\n-           projection_ty.repr(tcx));\n+           projection_ty.repr());\n \n     let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n \n@@ -1547,15 +1547,15 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n             };\n \n             debug!(\"projection_bounds: outlives={} (1)\",\n-                   outlives.repr(tcx));\n+                   outlives.repr());\n \n             // apply the substitutions (and normalize any projected types)\n             let outlives = fcx.instantiate_type_scheme(span,\n                                                        projection_ty.trait_ref.substs,\n                                                        &outlives);\n \n             debug!(\"projection_bounds: outlives={} (2)\",\n-                   outlives.repr(tcx));\n+                   outlives.repr());\n \n             let region_result = infcx.commit_if_ok(|_| {\n                 let (outlives, _) =\n@@ -1565,7 +1565,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                         &outlives);\n \n                 debug!(\"projection_bounds: outlives={} (3)\",\n-                       outlives.repr(tcx));\n+                       outlives.repr());\n \n                 // check whether this predicate applies to our current projection\n                 match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n@@ -1575,7 +1575,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n             });\n \n             debug!(\"projection_bounds: region_result={}\",\n-                   region_result.repr(tcx));\n+                   region_result.repr());\n \n             region_result.ok()\n         })"}, {"sha": "f27985d741aeeeb05c9c3188a9b76d5ddd7742fd", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -134,7 +134,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n             self.closures_with_inferred_kinds.insert(expr.id);\n             self.fcx.inh.closure_kinds.borrow_mut().insert(closure_def_id, ty::FnClosureKind);\n             debug!(\"check_closure: adding closure_id={} to closures_with_inferred_kinds\",\n-                   closure_def_id.repr(self.tcx()));\n+                   closure_def_id.repr());\n         }\n \n         ty::with_freevars(self.tcx(), expr.id, |freevars| {\n@@ -246,7 +246,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                                             mode: euv::ConsumeMode)\n     {\n         debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={}, mode={:?})\",\n-               cmt.repr(self.tcx()), mode);\n+               cmt.repr(), mode);\n \n         // we only care about moves\n         match mode {\n@@ -259,7 +259,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         // by value instead\n         let guarantor = cmt.guarantor();\n         debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={}\",\n-               guarantor.repr(self.tcx()));\n+               guarantor.repr());\n         match guarantor.cat {\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(_, _, mc::Implicit(..)) => {\n@@ -297,7 +297,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     /// those upvars must be borrowed using an `&mut` borrow.\n     fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n-               cmt.repr(self.tcx()));\n+               cmt.repr());\n \n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::Unique) |\n@@ -331,7 +331,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n     fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n-               cmt.repr(self.tcx()));\n+               cmt.repr());\n \n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::Unique) |\n@@ -498,7 +498,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode)\n     {\n-        debug!(\"consume(cmt={},mode={:?})\", cmt.repr(self.tcx()), mode);\n+        debug!(\"consume(cmt={},mode={:?})\", cmt.repr(), mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n@@ -513,7 +513,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n                    cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode)\n     {\n-        debug!(\"consume_pat(cmt={},mode={:?})\", cmt.repr(self.tcx()), mode);\n+        debug!(\"consume_pat(cmt={},mode={:?})\", cmt.repr(), mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n@@ -526,7 +526,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               _loan_cause: euv::LoanCause)\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, bk={:?})\",\n-               borrow_id, cmt.repr(self.tcx()), bk);\n+               borrow_id, cmt.repr(), bk);\n \n         match bk {\n             ty::ImmBorrow => { }\n@@ -551,7 +551,7 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n               _mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignee_cmt={})\",\n-               assignee_cmt.repr(self.tcx()));\n+               assignee_cmt.repr());\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }"}, {"sha": "bd7b212d3206365f3aa57ed324241c120da94aa2", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -350,15 +350,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          param_name: ast::Name)\n     {\n         span_err!(self.tcx().sess, span, E0392,\n-            \"parameter `{}` is never used\", param_name.user_string(self.tcx()));\n+            \"parameter `{}` is never used\", param_name.user_string());\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 self.tcx().sess.fileline_help(\n                     span,\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                             param_name.user_string(self.tcx()),\n+                             param_name.user_string(),\n                              ty::item_path_str(self.tcx(), def_id)));\n             }\n             None => {\n@@ -395,7 +395,7 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n             \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr(tcx))\n+                bounded_ty.repr())\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -536,23 +536,23 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n     }\n \n     fn fold_binder<T>(&mut self, binder: &ty::Binder<T>) -> ty::Binder<T>\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         self.binding_count += 1;\n         let value = liberate_late_bound_regions(\n             self.fcx.tcx(),\n             region::DestructionScopeData::new(self.scope),\n             binder);\n         debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {} at scope: {:?}\",\n-               value.repr(self.tcx()), self.scope);\n+               value.repr(), self.scope);\n         let value = value.fold_with(self);\n         self.binding_count -= 1;\n         ty::Binder(value)\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"BoundsChecker t={}\",\n-               t.repr(self.tcx()));\n+               t.repr());\n \n         match self.cache {\n             Some(ref mut cache) => {"}, {"sha": "1be7e42b7170dc90d567611568cd1f1f6a47e8b5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -172,7 +172,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n                pat_to_string(p),\n                p.id,\n-               ty::node_id_to_type(self.tcx(), p.id).repr(self.tcx()));\n+               ty::node_id_to_type(self.tcx(), p.id).repr());\n \n         visit::walk_pat(self, p);\n     }\n@@ -216,8 +216,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             };\n             debug!(\"Upvar capture for {} resolved to {}\",\n-                   upvar_id.repr(self.tcx()),\n-                   new_upvar_capture.repr(self.tcx()));\n+                   upvar_id.repr(),\n+                   new_upvar_capture.repr());\n             self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n         }\n     }\n@@ -245,7 +245,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n         write_ty_to_tcx(self.tcx(), id, n_ty);\n-        debug!(\"Node {} has type {}\", id, n_ty.repr(self.tcx()));\n+        debug!(\"Node {} has type {}\", id, n_ty.repr());\n \n         // Resolve any substitutions\n         self.fcx.opt_node_ty_substs(id, |item_substs| {\n@@ -296,7 +296,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(method) => {\n                 debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n                        method_call,\n-                       method.repr(self.tcx()));\n+                       method.repr());\n                 let new_method = MethodCallee {\n                     origin: self.resolve(&method.origin, reason),\n                     ty: self.resolve(&method.ty, reason),\n@@ -428,7 +428,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n             Ok(t) => t,\n             Err(e) => {\n                 debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n-                       t.repr(self.tcx));\n+                       t.repr());\n                 self.report_error(e);\n                 self.tcx().types.err\n             }"}, {"sha": "59b57a492649196c9c45de761d174719a6303e42", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -82,7 +82,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             inference_context.tcx.sess.span_bug(\n                 span,\n                 &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx)));\n+                        ty.repr()));\n         }\n     }\n }\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n                                                     impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n-                   trait_ref.repr(self.crate_context.tcx),\n+                   trait_ref.repr(),\n                    token::get_ident(item.ident));\n \n             enforce_trait_manually_implementable(self.crate_context.tcx,\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n-               impl_id, trait_ref.repr(tcx));\n+               impl_id, trait_ref.repr());\n \n         let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n@@ -190,7 +190,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n+            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr());\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     &**trait_method,\n                     Some(trait_method.def_id)));\n \n-            debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n+            debug!(\"new_method_ty={}\", new_method_ty.repr());\n             all_impl_items.push(MethodTraitItemId(new_did));\n \n             // construct the polytype for the method based on the\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 ty: ty::mk_bare_fn(tcx, Some(new_did),\n                                    tcx.mk_bare_fn(new_method_ty.fty.clone()))\n             };\n-            debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n+            debug!(\"new_polytype={}\", new_polytype.repr());\n \n             tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n             tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_copy: impl_did={}\",\n-                   impl_did.repr(tcx));\n+                   impl_did.repr());\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n@@ -371,15 +371,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let self_type = ty::lookup_item_type(tcx, impl_did);\n             debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n-                   self_type.repr(tcx));\n+                   self_type.repr());\n \n             let span = tcx.map.span(impl_did.node);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n             debug!(\"check_implementations_of_copy: self_type={} (free)\",\n-                   self_type.repr(tcx));\n+                   self_type.repr());\n \n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         trait_def.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={}\",\n-                   impl_did.repr(tcx));\n+                   impl_did.repr());\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n@@ -443,7 +443,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n-                   source.repr(tcx), target.repr(tcx));\n+                   source.repr(), target.repr());\n \n             let span = tcx.map.span(impl_did.node);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             assert!(!source.has_escaping_regions());\n \n             debug!(\"check_implementations_of_coerce_unsized: {} -> {} (free)\",\n-                   source.repr(tcx), target.repr(tcx));\n+                   source.repr(), target.repr());\n \n             let infcx = new_infer_ctxt(tcx);\n \n@@ -520,8 +520,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                 } else {\n                                                     token::get_name(name).to_string()\n                                                 },\n-                                                a.repr(tcx),\n-                                                b.repr(tcx))\n+                                                a.repr(),\n+                                                b.repr())\n                                    }).collect::<Vec<_>>().connect(\", \"));\n                         return;\n                     }\n@@ -598,7 +598,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let combined_substs = ty::make_substs_for_receiver_types(tcx, trait_ref, method);\n \n     debug!(\"subst_receiver_types_in_method_ty: combined_substs={}\",\n-           combined_substs.repr(tcx));\n+           combined_substs.repr());\n \n     let method_predicates = method.predicates.subst(tcx, &combined_substs);\n     let mut method_generics = method.generics.subst(tcx, &combined_substs);\n@@ -615,12 +615,12 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     debug!(\"subst_receiver_types_in_method_ty: method_generics={}\",\n-           method_generics.repr(tcx));\n+           method_generics.repr());\n \n     let method_fty = method.fty.subst(tcx, &combined_substs);\n \n     debug!(\"subst_receiver_types_in_method_ty: method_ty={}\",\n-           method.fty.repr(tcx));\n+           method.fty.repr());\n \n     ty::Method::new(\n         method.name,"}, {"sha": "5c99998b95325256206f179bef6a3ed46fe5156b", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             ast::ItemImpl(_, _, _, None, _, _) => {\n                 // For inherent impls, self type must be a nominal type\n                 // defined in this crate.\n-                debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n+                debug!(\"coherence2::orphan check: inherent impl {}\", item.repr());\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n                 match self_ty.sty {\n                     ty::TyEnum(def_id, _) |\n@@ -208,7 +208,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             }\n             ast::ItemImpl(_, _, _, Some(_), _, _) => {\n                 // \"Trait\" impl\n-                debug!(\"coherence2::orphan check: trait impl {}\", item.repr(self.tcx));\n+                debug!(\"coherence2::orphan check: trait impl {}\", item.repr());\n                 let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n@@ -227,7 +227,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                 \"type parameter `{}` must be used as the type parameter for \\\n                                  some local type (e.g. `MyStruct<T>`); only traits defined in \\\n                                  the current crate can be implemented for a type parameter\",\n-                                param_ty.user_string(self.tcx));\n+                                param_ty.user_string());\n                         return;\n                     }\n                 }\n@@ -266,8 +266,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 // rules, but it invalidates the reasoning from\n                 // `two_foos` above.\n                 debug!(\"trait_ref={} trait_def_id={} trait_has_default_impl={}\",\n-                       trait_ref.repr(self.tcx),\n-                       trait_def_id.repr(self.tcx),\n+                       trait_ref.repr(),\n+                       trait_def_id.repr(),\n                        ty::trait_has_default_impl(self.tcx, trait_def_id));\n                 if\n                     ty::trait_has_default_impl(self.tcx, trait_def_id) &&\n@@ -305,7 +305,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                  can only be implemented for a struct/enum type, \\\n                                  not `{}`\",\n                                 ty::item_path_str(self.tcx, trait_def_id),\n-                                self_ty.user_string(self.tcx)))\n+                                self_ty.user_string()))\n                         }\n                     };\n \n@@ -329,7 +329,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n             }\n             ast::ItemDefaultImpl(..) => {\n                 // \"Trait\" impl\n-                debug!(\"coherence2::orphan check: default trait impl {}\", item.repr(self.tcx));\n+                debug!(\"coherence2::orphan check: default trait impl {}\", item.repr());\n                 let trait_ref = ty::impl_trait_ref(self.tcx, def_id).unwrap();\n                 if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n                     span_err!(self.tcx.sess, item.span, E0318,"}, {"sha": "74ce9ed540ecbabae4e8a323486fda6d64d22dff", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -62,7 +62,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                                             trait_def: &'tcx ty::TraitDef<'tcx>)\n     {\n         debug!(\"check_for_overlapping_impls_of_trait(trait_def={})\",\n-               trait_def.repr(self.tcx));\n+               trait_def.repr());\n \n         // We should already know all impls of this trait, so these\n         // borrows are safe.\n@@ -132,9 +132,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             impl1_def_id, impl2_def_id)\n         {\n             debug!(\"check_if_impls_overlap({}, {}, {})\",\n-                   trait_def_id.repr(self.tcx),\n-                   impl1_def_id.repr(self.tcx),\n-                   impl2_def_id.repr(self.tcx));\n+                   trait_def_id.repr(),\n+                   impl1_def_id.repr(),\n+                   impl2_def_id.repr());\n \n             let infcx = infer::new_infer_ctxt(self.tcx);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n@@ -217,7 +217,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                                 span_err!(self.tcx.sess, item.span, E0371,\n                                           \"the object type `{}` automatically \\\n                                            implements the trait `{}`\",\n-                                          trait_ref.self_ty().user_string(self.tcx),\n+                                          trait_ref.self_ty().user_string(),\n                                           ty::item_path_str(self.tcx, trait_def_id));\n                             }\n                         }"}, {"sha": "fe276b3d1bdedc1be15a519c942fc3ca6fdc8582", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -55,14 +55,14 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                     (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n                         span_err!(self.tcx.sess, item.span, E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n-                                  trait_ref.user_string(self.tcx));\n+                                  trait_ref.user_string());\n                     }\n \n                     (ast::Unsafety::Unsafe,\n                      ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess, item.span, E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n-                                  trait_ref.user_string(self.tcx));\n+                                  trait_ref.user_string());\n                     }\n \n                     (ast::Unsafety::Unsafe,"}, {"sha": "ff7c8e69a6b452becfb101194868050919c8eeff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -255,7 +255,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 tcx.sess.note(\n                     &format!(\"the cycle begins when computing the bounds \\\n                               for type parameter `{}`...\",\n-                             def.name.user_string(tcx)));\n+                             def.name.user_string()));\n             }\n         }\n \n@@ -277,7 +277,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     tcx.sess.note(\n                         &format!(\"...which then requires computing the bounds \\\n                                   for type parameter `{}`...\",\n-                                 def.name.user_string(tcx)));\n+                                 def.name.user_string()));\n                 }\n             }\n         }\n@@ -300,7 +300,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 tcx.sess.note(\n                     &format!(\"...which then again requires computing the bounds \\\n                               for type parameter `{}`, completing the cycle.\",\n-                             def.name.user_string(tcx)));\n+                             def.name.user_string()));\n             }\n         }\n     }\n@@ -317,7 +317,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n         let item = match tcx.map.get(trait_id.node) {\n             ast_map::NodeItem(item) => item,\n-            _ => tcx.sess.bug(&format!(\"get_trait_def({}): not an item\", trait_id.repr(tcx)))\n+            _ => tcx.sess.bug(&format!(\"get_trait_def({}): not an item\", trait_id.repr()))\n         };\n \n         trait_def_of_item(self, &*item)\n@@ -372,7 +372,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                                -> Result<(), ErrorReported>\n     {\n         debug!(\"ensure_super_predicates(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx()));\n+               trait_def_id.repr());\n \n         self.ccx.ensure_super_predicates(span, trait_def_id)\n     }\n@@ -635,7 +635,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n                              ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n     debug!(\"method {} (id {}) has type {}\",\n-            ident.repr(ccx.tcx), id, fty.repr(ccx.tcx));\n+            ident.repr(), id, fty.repr());\n     ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n         generics: ty_method.generics.clone(),\n         ty: fty\n@@ -645,7 +645,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, id, fty);\n \n     debug!(\"writing method type: def_id={:?} mty={}\",\n-            def_id, ty_method.repr(ccx.tcx));\n+            def_id, ty_method.repr());\n \n     ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n         ty::MethodTraitItem(Rc::new(ty_method)));\n@@ -743,9 +743,9 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n     where I: Iterator<Item=(&'i ast::MethodSig, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n-           untransformed_rcvr_ty.repr(ccx.tcx),\n-           rcvr_ty_generics.repr(ccx.tcx),\n-           rcvr_ty_predicates.repr(ccx.tcx));\n+           untransformed_rcvr_ty.repr(),\n+           rcvr_ty_generics.repr(),\n+           rcvr_ty_predicates.repr());\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n@@ -1139,7 +1139,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n \n-    debug!(\"ensure_super_predicates_step(trait_def_id={})\", trait_def_id.repr(tcx));\n+    debug!(\"ensure_super_predicates_step(trait_def_id={})\", trait_def_id.repr());\n \n     if trait_def_id.krate != ast::LOCAL_CRATE {\n         // If this trait comes from an external crate, then all of the\n@@ -1192,8 +1192,8 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n             predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n         };\n         debug!(\"superpredicates for trait {} = {}\",\n-               local_def(item.id).repr(ccx.tcx),\n-               superpredicates.repr(ccx.tcx));\n+               local_def(item.id).repr(),\n+               superpredicates.repr());\n \n         tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n \n@@ -1206,7 +1206,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                                          .map(|tr| tr.def_id())\n                                          .collect();\n \n-    debug!(\"ensure_super_predicates_step: def_ids={}\", def_ids.repr(tcx));\n+    debug!(\"ensure_super_predicates_step: def_ids={}\", def_ids.repr());\n \n     def_ids\n }\n@@ -1532,9 +1532,9 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             scheme.generics.types.iter()\n                                  .map(|t| match t.object_lifetime_default {\n                                      Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n-                                         r.user_string(tcx),\n+                                         r.user_string(),\n                                      d =>\n-                                         d.repr(ccx.tcx),\n+                                         d.repr(),\n                                  })\n                                  .collect::<Vec<String>>()\n                                  .connect(\",\");\n@@ -1621,7 +1621,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n-           local_def(trait_id).repr(ccx.tcx), substs.repr(ccx.tcx));\n+           local_def(trait_id).repr(), substs.repr());\n \n     let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n@@ -2202,10 +2202,10 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\",\n-               required_type.repr(tcx),\n-               required_type_free.repr(tcx),\n-               base_type.repr(tcx),\n-               base_type_free.repr(tcx));\n+               required_type.repr(),\n+               required_type_free.repr(),\n+               base_type.repr(),\n+               base_type_free.repr());\n \n         let infcx = infer::new_infer_ctxt(tcx);\n         drop(::require_same_types(tcx,\n@@ -2216,7 +2216,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                         required_type.user_string(tcx))\n+                         required_type.user_string())\n         }));\n \n         // We could conceviably add more free-region relations here,\n@@ -2235,7 +2235,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         scope: region::DestructionScopeData,\n         value: &T)\n         -> T\n-        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr\n     {\n         /*!\n          * Convert early-bound regions into free regions; normally this is done by\n@@ -2286,7 +2286,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      idx: index as u32,\n                                      name: ty_param.ident.name };\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n-            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.user_string(tcx));\n+            report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.user_string());\n         }\n     }\n \n@@ -2316,7 +2316,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n             !input_parameters.contains(&ctp::Parameter::Region(region))\n         {\n             report_unused_parameter(tcx, lifetime_def.lifetime.span,\n-                                    \"lifetime\", &region.name.user_string(tcx));\n+                                    \"lifetime\", &region.name.user_string());\n         }\n     }\n "}, {"sha": "3f779d679448295f1e2467fbf375e45159c96017", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -148,7 +148,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-    debug!(\"write_ty_to_tcx({}, {})\", node_id,  ty.repr(tcx));\n+    debug!(\"write_ty_to_tcx({}, {})\", node_id,  ty.repr());\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_type_insert(node_id, ty);\n }\n@@ -159,7 +159,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !item_substs.is_noop() {\n         debug!(\"write_substs_to_tcx({}, {})\",\n                node_id,\n-               item_substs.repr(tcx));\n+               item_substs.repr());\n \n         assert!(item_substs.substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n@@ -244,14 +244,14 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n                 || {\n                     format!(\"main function expects type: `{}`\",\n-                             se_ty.user_string(ccx.tcx))\n+                             se_ty.user_string())\n                 });\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n                               &format!(\"main has a non-function type: found \\\n                                        `{}`\",\n-                                      main_t.repr(tcx)));\n+                                      main_t.repr()));\n         }\n     }\n }\n@@ -294,15 +294,15 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n                 || {\n                     format!(\"start function expects type: `{}`\",\n-                             se_ty.user_string(ccx.tcx))\n+                             se_ty.user_string())\n                 });\n \n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n                               &format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                       start_t.repr(tcx)));\n+                                       start_t.repr()));\n         }\n     }\n }"}, {"sha": "3085598e4a3ae9a4ede23990dcd12cbb1834a939", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3727559c6eee465893f400ec4edad77be868f3c/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=a3727559c6eee465893f400ec4edad77be868f3c", "patch": "@@ -518,7 +518,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n+        debug!(\"add_inferreds for item {}\", item.repr());\n \n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n@@ -601,7 +601,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n \n         debug!(\"visit_item item={}\",\n-               item.repr(tcx));\n+               item.repr());\n \n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n@@ -847,7 +847,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                       trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n-               trait_ref.repr(self.tcx()),\n+               trait_ref.repr(),\n                variance);\n \n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n@@ -869,7 +869,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={}, variance={:?})\",\n-               ty.repr(self.tcx()),\n+               ty.repr(),\n                variance);\n \n         match ty.sty {\n@@ -983,7 +983,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx())));\n+                            ty.repr()));\n             }\n         }\n     }\n@@ -999,8 +999,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={}, substs={}, variance={:?})\",\n-               def_id.repr(self.tcx()),\n-               substs.repr(self.tcx()),\n+               def_id.repr(),\n+               substs.repr(),\n                variance);\n \n         for p in type_param_defs {\n@@ -1068,7 +1068,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     .sess\n                     .bug(&format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx())));\n+                                 region.repr()));\n             }\n         }\n     }\n@@ -1197,14 +1197,14 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             };\n             debug!(\"item_id={} item_variances={}\",\n                     item_id,\n-                    item_variances.repr(tcx));\n+                    item_variances.repr());\n \n             let item_def_id = ast_util::local_def(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n-                let found = item_variances.repr(tcx);\n+                let found = item_variances.repr();\n                 span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[..]);\n             }\n "}]}