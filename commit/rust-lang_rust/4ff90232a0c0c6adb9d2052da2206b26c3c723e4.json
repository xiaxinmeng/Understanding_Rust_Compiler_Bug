{"sha": "4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "node_id": "C_kwDOAAsO6NoAKDRmZjkwMjMyYTBjMGM2YWRiOWQyMDUyZGEyMjA2YjI2YzNjNzIzZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-03T21:10:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-03T21:10:22Z"}, "message": "Auto merge of #90475 - camelid:docvisitor, r=notriddle\n\nrustdoc: Add `DocVisitor` and use it where possible\n\n`DocFolder` allows transforming the docs, accomplished by making its methods take and return types by-value. However, several of the rustdoc `DocFolder` impls only *visit* the docs; they don't change anything. Passing around types by-value is thus unnecessary, confusing, and potentially inefficient for those impls.\n\n`DocVisitor` is very similar to `DocFolder`, except that its methods take shared references and return nothing (i.e., the unit type). This should both be more efficient and make the code clearer.\n\nThere is an additional reason to add `DocVisitor`, too. As part of my cleanup of `external_traits`, I'm planning to add a `fn cache(&mut self) -> &mut Cache` method to `DocFolder` so that `external_traits` can be retrieved explicitly from the `Cache`, rather than implicitly via `Crate.external_traits` (which is an `Rc<RefCell<...>>`). However, some of the `DocFolder` impls that could be turned into `DocVisitor` impls only have a shared reference to the `Cache`, because they are used during rendering. (They have to access the `Cache` via `html::render::Context.shared.cache`, which involves an `Rc`.)\n\nSince `DocVisitor` does not mutate any of the types it's visiting, its equivalent `cache()` method will only need a shared reference to the `Cache`, avoiding the problem described above.\n\nr? `@GuillaumeGomez`\ncc `@jyn514`", "tree": {"sha": "3dbec732404540d443efcd85604821982c2d2252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dbec732404540d443efcd85604821982c2d2252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "html_url": "https://github.com/rust-lang/rust/commit/4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baba6687df3e83fdb15cc6ec239b4a1c75a30505", "url": "https://api.github.com/repos/rust-lang/rust/commits/baba6687df3e83fdb15cc6ec239b4a1c75a30505", "html_url": "https://github.com/rust-lang/rust/commit/baba6687df3e83fdb15cc6ec239b4a1c75a30505"}, {"sha": "8e4bcdf84b2f07d0a3e0aac21b85b54b14031f33", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4bcdf84b2f07d0a3e0aac21b85b54b14031f33", "html_url": "https://github.com/rust-lang/rust/commit/8e4bcdf84b2f07d0a3e0aac21b85b54b14031f33"}], "stats": {"total": 343, "additions": 218, "deletions": 125}, "files": [{"sha": "65cd71307aa3f987be090d453666f395609fc37a", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -46,24 +46,40 @@ crate trait DocFolder: Sized {\n                 i.items = i.items.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                 ImplItem(i)\n             }\n-            VariantItem(i) => {\n-                let i2 = i.clone(); // this clone is small\n-                match i {\n-                    Variant::Struct(mut j) => {\n-                        let num_fields = j.fields.len();\n-                        j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                        j.fields_stripped |= num_fields != j.fields.len()\n-                            || j.fields.iter().any(|f| f.is_stripped());\n-                        VariantItem(Variant::Struct(j))\n-                    }\n-                    Variant::Tuple(fields) => {\n-                        let fields = fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                        VariantItem(Variant::Tuple(fields))\n-                    }\n-                    _ => VariantItem(i2),\n+            VariantItem(i) => match i {\n+                Variant::Struct(mut j) => {\n+                    let num_fields = j.fields.len();\n+                    j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n+                    j.fields_stripped |=\n+                        num_fields != j.fields.len() || j.fields.iter().any(|f| f.is_stripped());\n+                    VariantItem(Variant::Struct(j))\n                 }\n-            }\n-            x => x,\n+                Variant::Tuple(fields) => {\n+                    let fields = fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n+                    VariantItem(Variant::Tuple(fields))\n+                }\n+                Variant::CLike => VariantItem(Variant::CLike),\n+            },\n+            ExternCrateItem { src: _ }\n+            | ImportItem(_)\n+            | FunctionItem(_)\n+            | TypedefItem(_, _)\n+            | OpaqueTyItem(_)\n+            | StaticItem(_)\n+            | ConstantItem(_)\n+            | TraitAliasItem(_)\n+            | TyMethodItem(_)\n+            | MethodItem(_, _)\n+            | StructFieldItem(_)\n+            | ForeignFunctionItem(_)\n+            | ForeignStaticItem(_)\n+            | ForeignTypeItem\n+            | MacroItem(_)\n+            | ProcMacroItem(_)\n+            | PrimitiveItem(_)\n+            | AssocConstItem(_, _)\n+            | AssocTypeItem(_, _)\n+            | KeywordItem(_) => kind,\n         }\n     }\n \n@@ -86,14 +102,12 @@ crate trait DocFolder: Sized {\n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n         c.module = self.fold_item(c.module).unwrap();\n \n-        {\n-            let external_traits = { std::mem::take(&mut *c.external_traits.borrow_mut()) };\n-            for (k, mut v) in external_traits {\n-                v.trait_.items =\n-                    v.trait_.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n-                c.external_traits.borrow_mut().insert(k, v);\n-            }\n+        let external_traits = { std::mem::take(&mut *c.external_traits.borrow_mut()) };\n+        for (k, mut v) in external_traits {\n+            v.trait_.items = v.trait_.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n+            c.external_traits.borrow_mut().insert(k, v);\n         }\n+\n         c\n     }\n }"}, {"sha": "069862efde6409a0a49891cd32263b08b836a5c7", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -461,9 +461,9 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             }\n         }\n \n-        let (mut krate, local_sources, matches) = collect_spans_and_sources(\n+        let (local_sources, matches) = collect_spans_and_sources(\n             tcx,\n-            krate,\n+            &krate,\n             &src_root,\n             include_sources,\n             generate_link_to_definition,\n@@ -522,7 +522,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         };\n \n         if emit_crate {\n-            krate = sources::render(&mut cx, krate)?;\n+            sources::render(&mut cx, &krate)?;\n         }\n \n         // Build our search index"}, {"sha": "7803a779727c5b09e8ef033f6ecc343dd41b6c90", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -37,21 +37,21 @@ crate enum LinkFromSrc {\n /// only keep the `lo` and `hi`.\n crate fn collect_spans_and_sources(\n     tcx: TyCtxt<'_>,\n-    krate: clean::Crate,\n+    krate: &clean::Crate,\n     src_root: &Path,\n     include_sources: bool,\n     generate_link_to_definition: bool,\n-) -> (clean::Crate, FxHashMap<PathBuf, String>, FxHashMap<Span, LinkFromSrc>) {\n+) -> (FxHashMap<PathBuf, String>, FxHashMap<Span, LinkFromSrc>) {\n     let mut visitor = SpanMapVisitor { tcx, matches: FxHashMap::default() };\n \n     if include_sources {\n         if generate_link_to_definition {\n             tcx.hir().walk_toplevel_module(&mut visitor);\n         }\n-        let (krate, sources) = sources::collect_local_sources(tcx, src_root, krate);\n-        (krate, sources, visitor.matches)\n+        let sources = sources::collect_local_sources(tcx, src_root, &krate);\n+        (sources, visitor.matches)\n     } else {\n-        (krate, Default::default(), Default::default())\n+        (Default::default(), Default::default())\n     }\n }\n "}, {"sha": "c8e93374e63ccd7abf8827a15c5e03cf31ef363d", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -1,11 +1,11 @@\n use crate::clean;\n use crate::docfs::PathError;\n use crate::error::Error;\n-use crate::fold::DocFolder;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::{Context, BASIC_KEYWORDS};\n+use crate::visit::DocVisitor;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n@@ -16,23 +16,25 @@ use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n \n-crate fn render(cx: &mut Context<'_>, krate: clean::Crate) -> Result<clean::Crate, Error> {\n+crate fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error> {\n     info!(\"emitting source files\");\n+\n     let dst = cx.dst.join(\"src\").join(&*krate.name(cx.tcx()).as_str());\n     cx.shared.ensure_dir(&dst)?;\n-    let mut folder = SourceCollector { dst, cx, emitted_local_sources: FxHashSet::default() };\n-    Ok(folder.fold_crate(krate))\n+\n+    let mut collector = SourceCollector { dst, cx, emitted_local_sources: FxHashSet::default() };\n+    collector.visit_crate(krate);\n+    Ok(())\n }\n \n crate fn collect_local_sources<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     src_root: &Path,\n-    krate: clean::Crate,\n-) -> (clean::Crate, FxHashMap<PathBuf, String>) {\n+    krate: &clean::Crate,\n+) -> FxHashMap<PathBuf, String> {\n     let mut lsc = LocalSourcesCollector { tcx, local_sources: FxHashMap::default(), src_root };\n-\n-    let krate = lsc.fold_crate(krate);\n-    (krate, lsc.local_sources)\n+    lsc.visit_crate(krate);\n+    lsc.local_sources\n }\n \n struct LocalSourcesCollector<'a, 'tcx> {\n@@ -42,7 +44,7 @@ struct LocalSourcesCollector<'a, 'tcx> {\n }\n \n fn is_real_and_local(span: clean::Span, sess: &Session) -> bool {\n-    span.filename(sess).is_real() && span.cnum(sess) == LOCAL_CRATE\n+    span.cnum(sess) == LOCAL_CRATE && span.filename(sess).is_real()\n }\n \n impl LocalSourcesCollector<'_, '_> {\n@@ -54,12 +56,13 @@ impl LocalSourcesCollector<'_, '_> {\n             return;\n         }\n         let filename = span.filename(sess);\n-        let p = match filename {\n-            FileName::Real(ref file) => match file.local_path() {\n-                Some(p) => p.to_path_buf(),\n-                _ => return,\n-            },\n-            _ => return,\n+        let p = if let FileName::Real(file) = filename {\n+            match file.into_local_path() {\n+                Some(p) => p,\n+                None => return,\n+            }\n+        } else {\n+            return;\n         };\n         if self.local_sources.contains_key(&*p) {\n             // We've already emitted this source\n@@ -79,13 +82,11 @@ impl LocalSourcesCollector<'_, '_> {\n     }\n }\n \n-impl DocFolder for LocalSourcesCollector<'_, '_> {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        self.add_local_source(&item);\n+impl DocVisitor for LocalSourcesCollector<'_, '_> {\n+    fn visit_item(&mut self, item: &clean::Item) {\n+        self.add_local_source(item);\n \n-        // FIXME: if `include_sources` isn't set and DocFolder didn't require consuming the crate by value,\n-        // we could return None here without having to walk the rest of the crate.\n-        Some(self.fold_item_recur(item))\n+        self.visit_item_recur(item)\n     }\n }\n \n@@ -98,16 +99,20 @@ struct SourceCollector<'a, 'tcx> {\n     emitted_local_sources: FxHashSet<PathBuf>,\n }\n \n-impl DocFolder for SourceCollector<'_, '_> {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+impl DocVisitor for SourceCollector<'_, '_> {\n+    fn visit_item(&mut self, item: &clean::Item) {\n+        if !self.cx.include_sources {\n+            return;\n+        }\n+\n         let tcx = self.cx.tcx();\n         let span = item.span(tcx);\n         let sess = tcx.sess;\n \n         // If we're not rendering sources, there's nothing to do.\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem.\n-        if self.cx.include_sources && is_real_and_local(span, sess) {\n+        if is_real_and_local(span, sess) {\n             let filename = span.filename(sess);\n             let span = span.inner();\n             let pos = sess.source_map().lookup_source_file(span.lo());\n@@ -132,9 +137,8 @@ impl DocFolder for SourceCollector<'_, '_> {\n                 }\n             };\n         }\n-        // FIXME: if `include_sources` isn't set and DocFolder didn't require consuming the crate by value,\n-        // we could return None here without having to walk the rest of the crate.\n-        Some(self.fold_item_recur(item))\n+\n+        self.visit_item_recur(item)\n     }\n }\n "}, {"sha": "7eeb9d1fcaa55114b3b08c06320aa8345dd0e5fd", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -121,6 +121,7 @@ mod markdown;\n mod passes;\n mod scrape_examples;\n mod theme;\n+mod visit;\n mod visit_ast;\n mod visit_lib;\n "}, {"sha": "4e146a07d154a64b3f8d99eedd4b419d8f61d3db", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -1,8 +1,8 @@\n use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n-use crate::fold::DocFolder;\n use crate::html::markdown::main_body_opts;\n+use crate::visit::DocVisitor;\n use core::ops::Range;\n use pulldown_cmark::{Event, Parser, Tag};\n use regex::Regex;\n@@ -53,16 +53,17 @@ impl<'a, 'tcx> BareUrlsLinter<'a, 'tcx> {\n }\n \n crate fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    BareUrlsLinter { cx }.fold_crate(krate)\n+    BareUrlsLinter { cx }.visit_crate(&krate);\n+    krate\n }\n \n-impl<'a, 'tcx> DocFolder for BareUrlsLinter<'a, 'tcx> {\n-    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+impl<'a, 'tcx> DocVisitor for BareUrlsLinter<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n         let hir_id = match DocContext::as_local_hir_id(self.cx.tcx, item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n-                return Some(self.fold_item_recur(item));\n+                return;\n             }\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n@@ -106,6 +107,6 @@ impl<'a, 'tcx> DocFolder for BareUrlsLinter<'a, 'tcx> {\n             }\n         }\n \n-        Some(self.fold_item_recur(item))\n+        self.visit_item_recur(item)\n     }\n }"}, {"sha": "85542ebd9ac559f4c5ddcfc546bdc34b893bcac8", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -1,9 +1,9 @@\n use crate::clean;\n use crate::core::DocContext;\n-use crate::fold::{self, DocFolder};\n use crate::html::markdown::{find_testable_code, ErrorCodes};\n use crate::passes::check_doc_test_visibility::{should_have_doc_example, Tests};\n use crate::passes::Pass;\n+use crate::visit::DocVisitor;\n use rustc_hir as hir;\n use rustc_lint::builtin::MISSING_DOCS;\n use rustc_middle::lint::LintLevelSource;\n@@ -23,7 +23,7 @@ crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n \n fn calculate_doc_coverage(krate: clean::Crate, ctx: &mut DocContext<'_>) -> clean::Crate {\n     let mut calc = CoverageCalculator { items: Default::default(), ctx };\n-    let krate = calc.fold_crate(krate);\n+    calc.visit_crate(&krate);\n \n     calc.print_results();\n \n@@ -182,17 +182,18 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n-    fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n+impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n+    fn visit_item(&mut self, i: &clean::Item) {\n+        if !i.def_id.is_local() {\n+            // non-local items are skipped because they can be out of the users control,\n+            // especially in the case of trait impls, which rustdoc eagerly inlines\n+            return;\n+        }\n+\n         match *i.kind {\n-            _ if !i.def_id.is_local() => {\n-                // non-local items are skipped because they can be out of the users control,\n-                // especially in the case of trait impls, which rustdoc eagerly inlines\n-                return Some(i);\n-            }\n             clean::StrippedItem(..) => {\n                 // don't count items in stripped modules\n-                return Some(i);\n+                return;\n             }\n             // docs on `use` and `extern crate` statements are not displayed, so they're not\n             // worth counting\n@@ -269,6 +270,6 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n             }\n         }\n \n-        Some(self.fold_item_recur(i))\n+        self.visit_item_recur(i)\n     }\n }"}, {"sha": "fd2ab0dc97cb2230373a3cfb9832eb6400170336", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -8,9 +8,9 @@ use rustc_span::{hygiene::AstPass, ExpnData, ExpnKind, FileName, InnerSpan, DUMM\n \n use crate::clean;\n use crate::core::DocContext;\n-use crate::fold::DocFolder;\n use crate::html::markdown::{self, RustCodeBlock};\n use crate::passes::Pass;\n+use crate::visit::DocVisitor;\n \n crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n@@ -19,7 +19,8 @@ crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n };\n \n crate fn check_code_block_syntax(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n-    SyntaxChecker { cx }.fold_crate(krate)\n+    SyntaxChecker { cx }.visit_crate(&krate);\n+    krate\n }\n \n struct SyntaxChecker<'a, 'tcx> {\n@@ -141,8 +142,8 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+impl<'a, 'tcx> DocVisitor for SyntaxChecker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &clean::Item) {\n         if let Some(dox) = &item.attrs.collapsed_doc_value() {\n             let sp = item.attr_span(self.cx.tcx);\n             let extra = crate::html::markdown::ExtraInfo::new_did(\n@@ -155,7 +156,7 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n             }\n         }\n \n-        Some(self.fold_item_recur(item))\n+        self.visit_item_recur(item)\n     }\n }\n "}, {"sha": "7d3010cf3325b327c03f2b67b93d2c7190de34eb", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -7,8 +7,8 @@ use super::Pass;\n use crate::clean;\n use crate::clean::*;\n use crate::core::DocContext;\n-use crate::fold::DocFolder;\n use crate::html::markdown::{find_testable_code, ErrorCodes, Ignore, LangString};\n+use crate::visit::DocVisitor;\n use crate::visit_ast::inherits_doc_hidden;\n use rustc_hir as hir;\n use rustc_middle::lint::LintLevelSource;\n@@ -27,17 +27,17 @@ struct DocTestVisibilityLinter<'a, 'tcx> {\n \n crate fn check_doc_test_visibility(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     let mut coll = DocTestVisibilityLinter { cx };\n-\n-    coll.fold_crate(krate)\n+    coll.visit_crate(&krate);\n+    krate\n }\n \n-impl<'a, 'tcx> DocFolder for DocTestVisibilityLinter<'a, 'tcx> {\n-    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+impl<'a, 'tcx> DocVisitor for DocTestVisibilityLinter<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n \n         look_for_tests(self.cx, &dox, &item);\n \n-        Some(self.fold_item_recur(item))\n+        self.visit_item_recur(item)\n     }\n }\n "}, {"sha": "8541e6e18816f5c783800fbe23be99e5780cc1fc", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -32,10 +32,10 @@ use std::ops::Range;\n \n use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n-use crate::fold::DocFolder;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n use crate::passes::Pass;\n+use crate::visit::DocVisitor;\n \n mod early;\n crate use early::load_intra_link_crates;\n@@ -47,13 +47,14 @@ crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    LinkCollector {\n+    let mut collector = LinkCollector {\n         cx,\n         mod_ids: Vec::new(),\n         kind_side_channel: Cell::new(None),\n         visited_links: FxHashMap::default(),\n-    }\n-    .fold_crate(krate)\n+    };\n+    collector.visit_crate(&krate);\n+    krate\n }\n \n /// Top-level errors emitted by this pass.\n@@ -816,8 +817,8 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n     )\n }\n \n-impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n-    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n         use rustc_middle::ty::DefIdTree;\n \n         let parent_node =\n@@ -911,17 +912,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         }\n \n-        Some(if item.is_mod() {\n+        if item.is_mod() {\n             if !inner_docs {\n                 self.mod_ids.push(item.def_id.expect_def_id());\n             }\n \n-            let ret = self.fold_item_recur(item);\n+            self.visit_item_recur(item);\n             self.mod_ids.pop();\n-            ret\n         } else {\n-            self.fold_item_recur(item)\n-        })\n+            self.visit_item_recur(item)\n+        }\n     }\n }\n "}, {"sha": "77513b05ff2f94ca982b0649291ce9aab8c46667", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -1,7 +1,7 @@\n use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n-use crate::fold::DocFolder;\n+use crate::visit::DocVisitor;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefId;\n@@ -14,17 +14,18 @@ crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let (mut krate, synth_impls) = cx.sess().time(\"collect_synthetic_impls\", || {\n+crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let synth_impls = cx.sess().time(\"collect_synthetic_impls\", || {\n         let mut synth = SyntheticImplCollector { cx, impls: Vec::new() };\n-        (synth.fold_crate(krate), synth.impls)\n+        synth.visit_crate(&krate);\n+        synth.impls\n     });\n \n     let prims: FxHashSet<PrimitiveType> = krate.primitives.iter().map(|p| p.1).collect();\n \n     let crate_items = {\n         let mut coll = ItemCollector::new();\n-        krate = cx.sess().time(\"collect_items_for_trait_impls\", || coll.fold_crate(krate));\n+        cx.sess().time(\"collect_items_for_trait_impls\", || coll.visit_crate(&krate));\n         coll.items\n     };\n \n@@ -152,14 +153,13 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n         }\n     }\n \n-    let items = if let ModuleItem(Module { ref mut items, .. }) = *krate.module.kind {\n-        items\n+    if let ModuleItem(Module { items, .. }) = &mut *krate.module.kind {\n+        items.extend(synth_impls);\n+        items.extend(new_items);\n     } else {\n         panic!(\"collect-trait-impls can't run\");\n     };\n \n-    items.extend(synth_impls);\n-    items.extend(new_items);\n     krate\n }\n \n@@ -168,8 +168,8 @@ struct SyntheticImplCollector<'a, 'tcx> {\n     impls: Vec<Item>,\n }\n \n-impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+impl<'a, 'tcx> DocVisitor for SyntheticImplCollector<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &Item) {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n             if !self\n@@ -184,7 +184,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n             }\n         }\n \n-        Some(self.fold_item_recur(i))\n+        self.visit_item_recur(i)\n     }\n }\n \n@@ -199,11 +199,11 @@ impl ItemCollector {\n     }\n }\n \n-impl DocFolder for ItemCollector {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+impl DocVisitor for ItemCollector {\n+    fn visit_item(&mut self, i: &Item) {\n         self.items.insert(i.def_id);\n \n-        Some(self.fold_item_recur(i))\n+        self.visit_item_recur(i)\n     }\n }\n "}, {"sha": "56b222d893262148d94d4e9e794e37022fc90afd", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -1,11 +1,13 @@\n use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n-use crate::fold::DocFolder;\n use crate::html::markdown::main_body_opts;\n-use core::ops::Range;\n+use crate::visit::DocVisitor;\n+\n use pulldown_cmark::{Event, Parser, Tag};\n+\n use std::iter::Peekable;\n+use std::ops::Range;\n use std::str::CharIndices;\n \n crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n@@ -19,13 +21,11 @@ struct InvalidHtmlTagsLinter<'a, 'tcx> {\n }\n \n crate fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    if !cx.tcx.sess.is_nightly_build() {\n-        krate\n-    } else {\n+    if cx.tcx.sess.is_nightly_build() {\n         let mut coll = InvalidHtmlTagsLinter { cx };\n-\n-        coll.fold_crate(krate)\n+        coll.visit_crate(&krate);\n     }\n+    krate\n }\n \n const ALLOWED_UNCLOSED: &[&str] = &[\n@@ -165,14 +165,14 @@ fn extract_tags(\n     }\n }\n \n-impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n-    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+impl<'a, 'tcx> DocVisitor for InvalidHtmlTagsLinter<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n         let tcx = self.cx.tcx;\n         let hir_id = match DocContext::as_local_hir_id(tcx, item.def_id) {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n-                return Some(self.fold_item_recur(item));\n+                return;\n             }\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n@@ -217,6 +217,6 @@ impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n             }\n         }\n \n-        Some(self.fold_item_recur(item))\n+        self.visit_item_recur(item)\n     }\n }"}, {"sha": "df4d1558ebdf42f31cb9bfd15cf13fcffc4d7147", "filename": "src/librustdoc/visit.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff90232a0c0c6adb9d2052da2206b26c3c723e4/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=4ff90232a0c0c6adb9d2052da2206b26c3c723e4", "patch": "@@ -0,0 +1,71 @@\n+use crate::clean::*;\n+\n+crate trait DocVisitor: Sized {\n+    fn visit_item(&mut self, item: &Item) {\n+        self.visit_item_recur(item)\n+    }\n+\n+    /// don't override!\n+    fn visit_inner_recur(&mut self, kind: &ItemKind) {\n+        match kind {\n+            StrippedItem(..) => unreachable!(),\n+            ModuleItem(i) => {\n+                self.visit_mod(i);\n+                return;\n+            }\n+            StructItem(i) => i.fields.iter().for_each(|x| self.visit_item(x)),\n+            UnionItem(i) => i.fields.iter().for_each(|x| self.visit_item(x)),\n+            EnumItem(i) => i.variants.iter().for_each(|x| self.visit_item(x)),\n+            TraitItem(i) => i.items.iter().for_each(|x| self.visit_item(x)),\n+            ImplItem(i) => i.items.iter().for_each(|x| self.visit_item(x)),\n+            VariantItem(i) => match i {\n+                Variant::Struct(j) => j.fields.iter().for_each(|x| self.visit_item(x)),\n+                Variant::Tuple(fields) => fields.iter().for_each(|x| self.visit_item(x)),\n+                Variant::CLike => {}\n+            },\n+            ExternCrateItem { src: _ }\n+            | ImportItem(_)\n+            | FunctionItem(_)\n+            | TypedefItem(_, _)\n+            | OpaqueTyItem(_)\n+            | StaticItem(_)\n+            | ConstantItem(_)\n+            | TraitAliasItem(_)\n+            | TyMethodItem(_)\n+            | MethodItem(_, _)\n+            | StructFieldItem(_)\n+            | ForeignFunctionItem(_)\n+            | ForeignStaticItem(_)\n+            | ForeignTypeItem\n+            | MacroItem(_)\n+            | ProcMacroItem(_)\n+            | PrimitiveItem(_)\n+            | AssocConstItem(_, _)\n+            | AssocTypeItem(_, _)\n+            | KeywordItem(_) => {}\n+        }\n+    }\n+\n+    /// don't override!\n+    fn visit_item_recur(&mut self, item: &Item) {\n+        match &*item.kind {\n+            StrippedItem(i) => self.visit_inner_recur(i),\n+            _ => self.visit_inner_recur(&item.kind),\n+        }\n+    }\n+\n+    fn visit_mod(&mut self, m: &Module) {\n+        m.items.iter().for_each(|i| self.visit_item(i))\n+    }\n+\n+    fn visit_crate(&mut self, c: &Crate) {\n+        self.visit_item(&c.module);\n+\n+        // FIXME: make this a simple by-ref for loop once external_traits is cleaned up\n+        let external_traits = { std::mem::take(&mut *c.external_traits.borrow_mut()) };\n+        for (k, v) in external_traits {\n+            v.trait_.items.iter().for_each(|i| self.visit_item(i));\n+            c.external_traits.borrow_mut().insert(k, v);\n+        }\n+    }\n+}"}]}