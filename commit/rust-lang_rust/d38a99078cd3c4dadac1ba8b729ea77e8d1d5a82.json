{"sha": "d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "node_id": "C_kwDOAAsO6NoAKGQzOGE5OTA3OGNkM2M0ZGFkYWMxYmE4YjcyOWVhNzdlOGQxZDVhODI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-30T00:42:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-30T00:42:43Z"}, "message": "Auto merge of #105070 - matthiaskrgr:rollup-9b25khj, r=matthiaskrgr\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #103876 (type alias impl trait: add tests showing that hidden type only outlives lifetimes that occur in bounds)\n - #104427 (Explain why `rematch_impl` fails to be infallible)\n - #104436 (Add slice to the stack allocated string comment)\n - #104523 (Don't use periods in target names)\n - #104627 (Print all features with --print target-features)\n - #104911 (Make inferred_outlives_crate return Clause)\n - #105002 (Add `PathBuf::as_mut_os_string` and `Path::as_mut_os_str`)\n - #105023 (Statics used in reachable function's inline asm are reachable)\n - #105045 (`rustc_ast_{passes,pretty}`: remove `ref` patterns)\n - #105049 (Hermit: Minor build fixes)\n - #105051 (Replace a macro with a function)\n - #105062 (rustdoc: use shorthand background for rustdoc toggle CSS)\n - #105066 (move `candidate_from_obligation` out of assembly)\n - #105068 (Run patchelf also on rust-analyzer-proc-macro-srv.)\n\nFailed merges:\n\n - #105050 (Remove useless borrows and derefs)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6368485d2eeb91c5242b8264797afc8b9e584948", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6368485d2eeb91c5242b8264797afc8b9e584948"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "html_url": "https://github.com/rust-lang/rust/commit/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bddad597feb997a4e5d2cd174a76c3b07a84e4d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bddad597feb997a4e5d2cd174a76c3b07a84e4d6", "html_url": "https://github.com/rust-lang/rust/commit/bddad597feb997a4e5d2cd174a76c3b07a84e4d6"}, {"sha": "a5ca67b951df38347d09ffc309a048b5fb2d0e5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ca67b951df38347d09ffc309a048b5fb2d0e5c", "html_url": "https://github.com/rust-lang/rust/commit/a5ca67b951df38347d09ffc309a048b5fb2d0e5c"}], "stats": {"total": 1394, "additions": 805, "deletions": 589}, "files": [{"sha": "e47c434454602773d236a61ba7f1fb85e877fa83", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -209,15 +209,15 @@ impl<'a> AstValidator<'a> {\n \n     // Mirrors `visit::walk_ty`, but tracks relevant state.\n     fn walk_ty(&mut self, t: &'a Ty) {\n-        match t.kind {\n+        match &t.kind {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n             TyKind::TraitObject(..) => self\n                 .with_banned_tilde_const(DisallowTildeConstContext::TraitObject, |this| {\n                     visit::walk_ty(this, t)\n                 }),\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n@@ -231,7 +231,7 @@ impl<'a> AstValidator<'a> {\n                 // (for cases like `<impl Trait>::Foo>`)\n                 // but we allow `impl Trait` in `GenericArgs`\n                 // iff there are no more PathSegments.\n-                if let Some(ref qself) = *qself {\n+                if let Some(qself) = qself {\n                     // `impl Trait` in `qself` is always illegal\n                     self.with_banned_impl_trait(|this| this.visit_ty(&qself.ty));\n                 }\n@@ -738,8 +738,8 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n-        match ty.kind {\n-            TyKind::BareFn(ref bfty) => {\n+        match &ty.kind {\n+            TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n                     struct_span_err!(\n@@ -756,10 +756,10 @@ impl<'a> AstValidator<'a> {\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n                 }\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n-                    if let GenericBound::Outlives(ref lifetime) = *bound {\n+                    if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n                             struct_span_err!(\n                                 self.session,\n@@ -774,7 +774,7 @@ impl<'a> AstValidator<'a> {\n                     }\n                 }\n             }\n-            TyKind::ImplTrait(_, ref bounds) => {\n+            TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n                     struct_span_err!(\n                         self.session,\n@@ -842,8 +842,8 @@ fn validate_generic_param_order(\n         let (kind, bounds, span) = (&param.kind, &param.bounds, ident.span);\n         let (ord_kind, ident) = match &param.kind {\n             GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident.to_string()),\n-            GenericParamKind::Type { default: _ } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n-            GenericParamKind::Const { ref ty, kw_span: _, default: _ } => {\n+            GenericParamKind::Type { .. } => (ParamKindOrd::TypeOrConst, ident.to_string()),\n+            GenericParamKind::Const { ty, .. } => {\n                 let ty = pprust::ty_to_string(ty);\n                 (ParamKindOrd::TypeOrConst, format!(\"const {}: {}\", ident, ty))\n             }\n@@ -948,8 +948,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 ExprKind::Paren(local_expr) => {\n                     fn has_let_expr(expr: &Expr) -> bool {\n-                        match expr.kind {\n-                            ExprKind::Binary(_, ref lhs, ref rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                        match &expr.kind {\n+                            ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n                             ExprKind::Let(..) => true,\n                             _ => false,\n                         }\n@@ -1005,18 +1005,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n-        match item.kind {\n+        match &item.kind {\n             ItemKind::Impl(box Impl {\n                 unsafety,\n                 polarity,\n                 defaultness: _,\n                 constness,\n-                ref generics,\n-                of_trait: Some(ref t),\n-                ref self_ty,\n-                ref items,\n+                generics,\n+                of_trait: Some(t),\n+                self_ty,\n+                items,\n             }) => {\n-                self.with_in_trait_impl(true, Some(constness), |this| {\n+                self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n                         this.err_handler()\n@@ -1027,7 +1027,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             .help(\"use `auto trait Trait {}` instead\")\n                             .emit();\n                     }\n-                    if let (Unsafe::Yes(span), ImplPolarity::Negative(sp)) = (unsafety, polarity) {\n+                    if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n+                    {\n                         struct_span_err!(\n                             this.session,\n                             sp.to(t.path.span),\n@@ -1061,7 +1062,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 constness,\n                 generics: _,\n                 of_trait: None,\n-                ref self_ty,\n+                self_ty,\n                 items: _,\n             }) => {\n                 let error = |annotation_span, annotation| {\n@@ -1078,25 +1079,25 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     &item.vis,\n                     Some(InvalidVisibilityNote::IndividualImplItems),\n                 );\n-                if let Unsafe::Yes(span) = unsafety {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     error(span, \"unsafe\").code(error_code!(E0197)).emit();\n                 }\n-                if let ImplPolarity::Negative(span) = polarity {\n+                if let &ImplPolarity::Negative(span) = polarity {\n                     error(span, \"negative\").emit();\n                 }\n-                if let Defaultness::Default(def_span) = defaultness {\n+                if let &Defaultness::Default(def_span) = defaultness {\n                     error(def_span, \"`default`\")\n                         .note(\"only trait implementations may be annotated with `default`\")\n                         .emit();\n                 }\n-                if let Const::Yes(span) = constness {\n+                if let &Const::Yes(span) = constness {\n                     error(span, \"`const`\")\n                         .note(\"only trait implementations may be annotated with `const`\")\n                         .emit();\n                 }\n             }\n-            ItemKind::Fn(box Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                self.check_defaultness(item.span, defaultness);\n+            ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n+                self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n                     self.session.emit_err(FnWithoutBody {\n@@ -1132,7 +1133,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     &item.vis,\n                     Some(InvalidVisibilityNote::IndividualForeignItems),\n                 );\n-                if let Unsafe::Yes(span) = unsafety {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n                 }\n                 if abi.is_none() {\n@@ -1142,16 +1143,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.extern_mod = old_item;\n                 return; // Avoid visiting again.\n             }\n-            ItemKind::Enum(ref def, _) => {\n+            ItemKind::Enum(def, _) => {\n                 for variant in &def.variants {\n                     self.invalid_visibility(&variant.vis, None);\n                     for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n             }\n-            ItemKind::Trait(box Trait { is_auto, ref generics, ref bounds, ref items, .. }) => {\n-                if is_auto == IsAuto::Yes {\n+            ItemKind::Trait(box Trait { is_auto, generics, bounds, items, .. }) => {\n+                if *is_auto == IsAuto::Yes {\n                     // Auto traits cannot have generics, super traits nor contain items.\n                     self.deny_generic_params(generics, item.ident.span);\n                     self.deny_super_traits(bounds, item.ident.span);\n@@ -1171,8 +1172,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return; // Avoid visiting again\n             }\n-            ItemKind::Mod(unsafety, ref mod_kind) => {\n-                if let Unsafe::Yes(span) = unsafety {\n+            ItemKind::Mod(unsafety, mod_kind) => {\n+                if let &Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n@@ -1182,13 +1183,13 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Union(ref vdata, ..) => {\n+            ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n-                self.check_defaultness(item.span, def);\n+                self.check_defaultness(item.span, *def);\n                 self.session.emit_err(ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n@@ -1200,14 +1201,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n-            ItemKind::TyAlias(box TyAlias {\n-                defaultness,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n-                self.check_defaultness(item.span, defaultness);\n+            ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n+                self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n                     self.session.emit_err(TyAliasWithoutBody {\n                         span: item.span,\n@@ -1266,8 +1261,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     // Mirrors `visit::walk_generic_args`, but tracks relevant state.\n     fn visit_generic_args(&mut self, generic_args: &'a GenericArgs) {\n-        match *generic_args {\n-            GenericArgs::AngleBracketed(ref data) => {\n+        match generic_args {\n+            GenericArgs::AngleBracketed(data) => {\n                 self.check_generic_args_before_constraints(data);\n \n                 for arg in &data.args {\n@@ -1283,7 +1278,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n             }\n-            GenericArgs::Parenthesized(ref data) => {\n+            GenericArgs::Parenthesized(data) => {\n                 walk_list!(self, visit_ty, &data.inputs);\n                 if let FnRetTy::Ty(ty) = &data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n@@ -1319,7 +1314,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         validate_generic_param_order(self.err_handler(), &generics.params, generics.span);\n \n         for predicate in &generics.where_clause.predicates {\n-            if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n+            if let WherePredicate::EqPredicate(predicate) = predicate {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n@@ -1368,7 +1363,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_param_bound(&mut self, bound: &'a GenericBound, ctxt: BoundKind) {\n-        if let GenericBound::Trait(ref poly, modify) = *bound {\n+        if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n                     let mut err = self\n@@ -1573,8 +1568,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.check_item_named(item.ident, \"const\");\n         }\n \n-        match item.kind {\n-            AssocItemKind::Type(box TyAlias { ref generics, ref bounds, ref ty, .. })\n+        match &item.kind {\n+            AssocItemKind::Type(box TyAlias { generics, bounds, ty, .. })\n                 if ctxt == AssocCtxt::Trait =>\n             {\n                 self.visit_vis(&item.vis);\n@@ -1586,7 +1581,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n                 walk_list!(self, visit_ty, ty);\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, ref body, .. })\n+            AssocItemKind::Fn(box Fn { sig, generics, body, .. })\n                 if self.in_const_trait_impl\n                     || ctxt == AssocCtxt::Trait\n                     || matches!(sig.header.constness, Const::Yes(_)) =>"}, {"sha": "32f45f8b59e90a4050a7a41fb525d93ed9609ae5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -198,8 +198,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &'a ast::Item) {\n-        match i.kind {\n-            ast::ItemKind::ForeignMod(ref foreign_module) => {\n+        match &i.kind {\n+            ast::ItemKind::ForeignMod(foreign_module) => {\n                 if let Some(abi) = foreign_module.abi {\n                     self.check_abi(abi, ast::Const::No);\n                 }\n@@ -233,8 +233,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, ref of_trait, .. }) => {\n-                if let ast::ImplPolarity::Negative(span) = polarity {\n+            ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, of_trait, .. }) => {\n+                if let &ast::ImplPolarity::Negative(span) = polarity {\n                     gate_feature_post!(\n                         &self,\n                         negative_impls,\n@@ -267,7 +267,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }\n \n-            ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ref ty), .. }) => {\n+            ast::ItemKind::TyAlias(box ast::TyAlias { ty: Some(ty), .. }) => {\n                 self.check_impl_trait(&ty)\n             }\n \n@@ -302,8 +302,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-        match ty.kind {\n-            ast::TyKind::BareFn(ref bare_fn_ty) => {\n+        match &ty.kind {\n+            ast::TyKind::BareFn(bare_fn_ty) => {\n                 // Function pointers cannot be `const`\n                 self.check_extern(bare_fn_ty.ext, ast::Const::No);\n             }\n@@ -319,7 +319,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FnRetTy) {\n-        if let ast::FnRetTy::Ty(ref output_ty) = *ret_ty {\n+        if let ast::FnRetTy::Ty(output_ty) = ret_ty {\n             if let ast::TyKind::Never = output_ty.kind {\n                 // Do nothing.\n             } else {\n@@ -455,9 +455,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n-        let is_fn = match i.kind {\n+        let is_fn = match &i.kind {\n             ast::AssocItemKind::Fn(_) => true,\n-            ast::AssocItemKind::Type(box ast::TyAlias { ref ty, .. }) => {\n+            ast::AssocItemKind::Type(box ast::TyAlias { ty, .. }) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,"}, {"sha": "374e0a97063e3b4cc7fd131dd1901d5c24d71c95", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 88, "deletions": 87, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, Mutability, PatKind};\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, PatKind};\n use rustc_ast::{attr, BindingAnnotation, ByRef, DelimArgs, RangeEnd, RangeSyntax, Term};\n use rustc_ast::{GenericArg, GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n@@ -64,6 +64,7 @@ impl<'a> Comments<'a> {\n         Comments { sm, comments, current: 0 }\n     }\n \n+    // FIXME: This shouldn't probably clone lmao\n     pub fn next(&self) -> Option<Comment> {\n         self.comments.get(self.current).cloned()\n     }\n@@ -268,10 +269,10 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn maybe_print_comment(&mut self, pos: BytePos) -> bool {\n         let mut has_comment = false;\n-        while let Some(ref cmnt) = self.next_comment() {\n+        while let Some(cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n                 has_comment = true;\n-                self.print_comment(cmnt);\n+                self.print_comment(&cmnt);\n             } else {\n                 break;\n             }\n@@ -366,8 +367,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         if self.next_comment().is_none() {\n             self.hardbreak();\n         }\n-        while let Some(ref cmnt) = self.next_comment() {\n-            self.print_comment(cmnt)\n+        while let Some(cmnt) = self.next_comment() {\n+            self.print_comment(&cmnt)\n         }\n     }\n \n@@ -446,8 +447,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.hardbreak_if_not_bol();\n         }\n         self.maybe_print_comment(attr.span.lo());\n-        match attr.kind {\n-            ast::AttrKind::Normal(ref normal) => {\n+        match &attr.kind {\n+            ast::AttrKind::Normal(normal) => {\n                 match attr.style {\n                     ast::AttrStyle::Inner => self.word(\"#![\"),\n                     ast::AttrStyle::Outer => self.word(\"#[\"),\n@@ -456,7 +457,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.word(\"]\");\n             }\n             ast::AttrKind::DocComment(comment_kind, data) => {\n-                self.word(doc_comment_to_string(comment_kind, attr.style, data));\n+                self.word(doc_comment_to_string(*comment_kind, attr.style, *data));\n                 self.hardbreak()\n             }\n         }\n@@ -497,22 +498,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) {\n         match item {\n-            ast::NestedMetaItem::MetaItem(ref mi) => self.print_meta_item(mi),\n-            ast::NestedMetaItem::Lit(ref lit) => self.print_meta_item_lit(lit),\n+            ast::NestedMetaItem::MetaItem(mi) => self.print_meta_item(mi),\n+            ast::NestedMetaItem::Lit(lit) => self.print_meta_item_lit(lit),\n         }\n     }\n \n     fn print_meta_item(&mut self, item: &ast::MetaItem) {\n         self.ibox(INDENT_UNIT);\n-        match item.kind {\n+        match &item.kind {\n             ast::MetaItemKind::Word => self.print_path(&item.path, false, 0),\n-            ast::MetaItemKind::NameValue(ref value) => {\n+            ast::MetaItemKind::NameValue(value) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_meta_item_lit(value);\n             }\n-            ast::MetaItemKind::List(ref items) => {\n+            ast::MetaItemKind::List(items) => {\n                 self.print_path(&item.path, false, 0);\n                 self.popen();\n                 self.commasep(Consistent, &items, |s, i| s.print_meta_list_item(i));\n@@ -657,7 +658,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_path_segment(&mut self, segment: &ast::PathSegment, colons_before_params: bool) {\n         if segment.ident.name != kw::PathRoot {\n             self.print_ident(segment.ident);\n-            if let Some(ref args) = segment.args {\n+            if let Some(args) = &segment.args {\n                 self.print_generic_args(args, colons_before_params);\n             }\n         }\n@@ -712,19 +713,19 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn nonterminal_to_string(&self, nt: &Nonterminal) -> String {\n-        match *nt {\n-            token::NtExpr(ref e) => self.expr_to_string(e),\n-            token::NtMeta(ref e) => self.attr_item_to_string(e),\n-            token::NtTy(ref e) => self.ty_to_string(e),\n-            token::NtPath(ref e) => self.path_to_string(e),\n-            token::NtItem(ref e) => self.item_to_string(e),\n-            token::NtBlock(ref e) => self.block_to_string(e),\n-            token::NtStmt(ref e) => self.stmt_to_string(e),\n-            token::NtPat(ref e) => self.pat_to_string(e),\n-            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n+        match nt {\n+            token::NtExpr(e) => self.expr_to_string(e),\n+            token::NtMeta(e) => self.attr_item_to_string(e),\n+            token::NtTy(e) => self.ty_to_string(e),\n+            token::NtPath(e) => self.path_to_string(e),\n+            token::NtItem(e) => self.item_to_string(e),\n+            token::NtBlock(e) => self.block_to_string(e),\n+            token::NtStmt(e) => self.stmt_to_string(e),\n+            token::NtPat(e) => self.pat_to_string(e),\n+            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(*e, *is_raw).to_string(),\n             token::NtLifetime(e) => e.to_string(),\n-            token::NtLiteral(ref e) => self.expr_to_string(e),\n-            token::NtVis(ref e) => self.vis_to_string(e),\n+            token::NtLiteral(e) => self.expr_to_string(e),\n+            token::NtVis(e) => self.vis_to_string(e),\n         }\n     }\n \n@@ -917,8 +918,8 @@ impl<'a> PrintState<'a> for State<'a> {\n             self.word(\"::\")\n         }\n \n-        match *args {\n-            ast::GenericArgs::AngleBracketed(ref data) => {\n+        match args {\n+            ast::GenericArgs::AngleBracketed(data) => {\n                 self.word(\"<\");\n                 self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n                     ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n@@ -927,7 +928,7 @@ impl<'a> PrintState<'a> for State<'a> {\n                 self.word(\">\")\n             }\n \n-            ast::GenericArgs::Parenthesized(ref data) => {\n+            ast::GenericArgs::Parenthesized(data) => {\n                 self.word(\"(\");\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(ty));\n                 self.word(\")\");\n@@ -1011,62 +1012,62 @@ impl<'a> State<'a> {\n     pub fn print_type(&mut self, ty: &ast::Ty) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n-        match ty.kind {\n-            ast::TyKind::Slice(ref ty) => {\n+        match &ty.kind {\n+            ast::TyKind::Slice(ty) => {\n                 self.word(\"[\");\n                 self.print_type(ty);\n                 self.word(\"]\");\n             }\n-            ast::TyKind::Ptr(ref mt) => {\n+            ast::TyKind::Ptr(mt) => {\n                 self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n-            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Rptr(lifetime, mt) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n                 self.word(\"!\");\n             }\n-            ast::TyKind::Tup(ref elts) => {\n+            ast::TyKind::Tup(elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            ast::TyKind::Paren(ref typ) => {\n+            ast::TyKind::Paren(typ) => {\n                 self.popen();\n                 self.print_type(typ);\n                 self.pclose();\n             }\n-            ast::TyKind::BareFn(ref f) => {\n+            ast::TyKind::BareFn(f) => {\n                 self.print_ty_fn(f.ext, f.unsafety, &f.decl, None, &f.generic_params);\n             }\n-            ast::TyKind::Path(None, ref path) => {\n+            ast::TyKind::Path(None, path) => {\n                 self.print_path(path, false, 0);\n             }\n-            ast::TyKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, false),\n-            ast::TyKind::TraitObject(ref bounds, syntax) => {\n-                if syntax == ast::TraitObjectSyntax::Dyn {\n+            ast::TyKind::Path(Some(qself), path) => self.print_qpath(path, qself, false),\n+            ast::TyKind::TraitObject(bounds, syntax) => {\n+                if *syntax == ast::TraitObjectSyntax::Dyn {\n                     self.word_nbsp(\"dyn\");\n                 }\n                 self.print_type_bounds(bounds);\n             }\n-            ast::TyKind::ImplTrait(_, ref bounds) => {\n+            ast::TyKind::ImplTrait(_, bounds) => {\n                 self.word_nbsp(\"impl\");\n                 self.print_type_bounds(bounds);\n             }\n-            ast::TyKind::Array(ref ty, ref length) => {\n+            ast::TyKind::Array(ty, length) => {\n                 self.word(\"[\");\n                 self.print_type(ty);\n                 self.word(\"; \");\n                 self.print_expr(&length.value);\n                 self.word(\"]\");\n             }\n-            ast::TyKind::Typeof(ref e) => {\n+            ast::TyKind::Typeof(e) => {\n                 self.word(\"typeof(\");\n                 self.print_expr(&e.value);\n                 self.word(\")\");\n@@ -1082,7 +1083,7 @@ impl<'a> State<'a> {\n             ast::TyKind::ImplicitSelf => {\n                 self.word(\"Self\");\n             }\n-            ast::TyKind::MacCall(ref m) => {\n+            ast::TyKind::MacCall(m) => {\n                 self.print_mac(m);\n             }\n             ast::TyKind::CVarArgs => {\n@@ -1111,8 +1112,8 @@ impl<'a> State<'a> {\n \n     pub(crate) fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n-        match st.kind {\n-            ast::StmtKind::Local(ref loc) => {\n+        match &st.kind {\n+            ast::StmtKind::Local(loc) => {\n                 self.print_outer_attributes(&loc.attrs);\n                 self.space_if_not_bol();\n                 self.ibox(INDENT_UNIT);\n@@ -1135,15 +1136,15 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // `let` ibox\n             }\n-            ast::StmtKind::Item(ref item) => self.print_item(item),\n-            ast::StmtKind::Expr(ref expr) => {\n+            ast::StmtKind::Item(item) => self.print_item(item),\n+            ast::StmtKind::Expr(expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 if classify::expr_requires_semi_to_be_stmt(expr) {\n                     self.word(\";\");\n                 }\n             }\n-            ast::StmtKind::Semi(ref expr) => {\n+            ast::StmtKind::Semi(expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 self.word(\";\");\n@@ -1152,7 +1153,7 @@ impl<'a> State<'a> {\n                 self.space_if_not_bol();\n                 self.word(\";\");\n             }\n-            ast::StmtKind::MacCall(ref mac) => {\n+            ast::StmtKind::MacCall(mac) => {\n                 self.space_if_not_bol();\n                 self.print_outer_attributes(&mac.attrs);\n                 self.print_mac(&mac.mac);\n@@ -1193,8 +1194,8 @@ impl<'a> State<'a> {\n         let has_attrs = self.print_inner_attributes(attrs);\n \n         for (i, st) in blk.stmts.iter().enumerate() {\n-            match st.kind {\n-                ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n+            match &st.kind {\n+                ast::StmtKind::Expr(expr) if i == blk.stmts.len() - 1 => {\n                     self.maybe_print_comment(st.span.lo());\n                     self.space_if_not_bol();\n                     self.print_expr_outer_attr_style(expr, false);\n@@ -1362,7 +1363,7 @@ impl<'a> State<'a> {\n \n     pub(crate) fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n-        if let Some(ref ty) = loc.ty {\n+        if let Some(ty) = &loc.ty {\n             self.word_space(\":\");\n             self.print_type(ty);\n         }\n@@ -1386,7 +1387,7 @@ impl<'a> State<'a> {\n         for item_segment in &path.segments[qself.position..] {\n             self.word(\"::\");\n             self.print_ident(item_segment.ident);\n-            if let Some(ref args) = item_segment.args {\n+            if let Some(args) = &item_segment.args {\n                 self.print_generic_args(args, colons_before_params)\n             }\n         }\n@@ -1397,23 +1398,23 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n         is that it doesn't matter */\n-        match pat.kind {\n+        match &pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, ref sub) => {\n-                if by_ref == ByRef::Yes {\n+            PatKind::Ident(BindingAnnotation(by_ref, mutbl), ident, sub) => {\n+                if *by_ref == ByRef::Yes {\n                     self.word_nbsp(\"ref\");\n                 }\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word_nbsp(\"mut\");\n                 }\n-                self.print_ident(ident);\n-                if let Some(ref p) = *sub {\n+                self.print_ident(*ident);\n+                if let Some(p) = sub {\n                     self.space();\n                     self.word_space(\"@\");\n                     self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref qself, ref path, ref elts) => {\n+            PatKind::TupleStruct(qself, path, elts) => {\n                 if let Some(qself) = qself {\n                     self.print_qpath(path, qself, true);\n                 } else {\n@@ -1423,16 +1424,16 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n-            PatKind::Or(ref pats) => {\n+            PatKind::Or(pats) => {\n                 self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(p));\n             }\n-            PatKind::Path(None, ref path) => {\n+            PatKind::Path(None, path) => {\n                 self.print_path(path, true, 0);\n             }\n-            PatKind::Path(Some(ref qself), ref path) => {\n+            PatKind::Path(Some(qself), path) => {\n                 self.print_qpath(path, qself, false);\n             }\n-            PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+            PatKind::Struct(qself, path, fields, etc) => {\n                 if let Some(qself) = qself {\n                     self.print_qpath(path, qself, true);\n                 } else {\n@@ -1458,7 +1459,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.pat.span,\n                 );\n-                if etc {\n+                if *etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n@@ -1469,21 +1470,21 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"}\");\n             }\n-            PatKind::Tuple(ref elts) => {\n+            PatKind::Tuple(elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            PatKind::Box(ref inner) => {\n+            PatKind::Box(inner) => {\n                 self.word(\"box \");\n                 self.print_pat(inner);\n             }\n-            PatKind::Ref(ref inner, mutbl) => {\n+            PatKind::Ref(inner, mutbl) => {\n                 self.word(\"&\");\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word(\"mut \");\n                 }\n                 if let PatKind::Ident(ast::BindingAnnotation::MUT, ..) = inner.kind {\n@@ -1494,12 +1495,12 @@ impl<'a> State<'a> {\n                     self.print_pat(inner);\n                 }\n             }\n-            PatKind::Lit(ref e) => self.print_expr(&**e),\n-            PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n+            PatKind::Lit(e) => self.print_expr(&**e),\n+            PatKind::Range(begin, end, Spanned { node: end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n                 }\n-                match *end_kind {\n+                match end_kind {\n                     RangeEnd::Included(RangeSyntax::DotDotDot) => self.word(\"...\"),\n                     RangeEnd::Included(RangeSyntax::DotDotEq) => self.word(\"..=\"),\n                     RangeEnd::Excluded => self.word(\"..\"),\n@@ -1508,36 +1509,36 @@ impl<'a> State<'a> {\n                     self.print_expr(e);\n                 }\n             }\n-            PatKind::Slice(ref elts) => {\n+            PatKind::Slice(elts) => {\n                 self.word(\"[\");\n                 self.commasep(Inconsistent, &elts, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n             PatKind::Rest => self.word(\"..\"),\n-            PatKind::Paren(ref inner) => {\n+            PatKind::Paren(inner) => {\n                 self.popen();\n                 self.print_pat(inner);\n                 self.pclose();\n             }\n-            PatKind::MacCall(ref m) => self.print_mac(m),\n+            PatKind::MacCall(m) => self.print_mac(m),\n         }\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n-        match explicit_self.node {\n+        match &explicit_self.node {\n             SelfKind::Value(m) => {\n-                self.print_mutability(m, false);\n+                self.print_mutability(*m, false);\n                 self.word(\"self\")\n             }\n-            SelfKind::Region(ref lt, m) => {\n+            SelfKind::Region(lt, m) => {\n                 self.word(\"&\");\n                 self.print_opt_lifetime(lt);\n-                self.print_mutability(m, false);\n+                self.print_mutability(*m, false);\n                 self.word(\"self\")\n             }\n-            SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m, false);\n+            SelfKind::Explicit(typ, m) => {\n+                self.print_mutability(*m, false);\n                 self.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n@@ -1599,7 +1600,7 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n \n-            match param.kind {\n+            match &param.kind {\n                 ast::GenericParamKind::Lifetime => {\n                     let lt = ast::Lifetime { id: param.id, ident: param.ident };\n                     s.print_lifetime(lt);\n@@ -1608,19 +1609,19 @@ impl<'a> State<'a> {\n                         s.print_lifetime_bounds(&param.bounds)\n                     }\n                 }\n-                ast::GenericParamKind::Type { ref default } => {\n+                ast::GenericParamKind::Type { default } => {\n                     s.print_ident(param.ident);\n                     if !param.bounds.is_empty() {\n                         s.word_nbsp(\":\");\n                         s.print_type_bounds(&param.bounds);\n                     }\n-                    if let Some(ref default) = default {\n+                    if let Some(default) = default {\n                         s.space();\n                         s.word_space(\"=\");\n                         s.print_type(default)\n                     }\n                 }\n-                ast::GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+                ast::GenericParamKind::Const { ty, default, .. } => {\n                     s.word_space(\"const\");\n                     s.print_ident(param.ident);\n                     s.space();\n@@ -1630,7 +1631,7 @@ impl<'a> State<'a> {\n                         s.word_nbsp(\":\");\n                         s.print_type_bounds(&param.bounds);\n                     }\n-                    if let Some(ref default) = default {\n+                    if let Some(default) = default {\n                         s.space();\n                         s.word_space(\"=\");\n                         s.print_expr(&default.value);"}, {"sha": "81483ac30d1de21bc5c1355832aa394fb58629bc", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 68, "deletions": 76, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -8,9 +8,9 @@ use rustc_ast::{self as ast, BlockCheckMode};\n impl<'a> State<'a> {\n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n         if let Some(_else) = els {\n-            match _else.kind {\n+            match &_else.kind {\n                 // Another `else if` block.\n-                ast::ExprKind::If(ref i, ref then, ref e) => {\n+                ast::ExprKind::If(i, then, e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else if \");\n@@ -20,7 +20,7 @@ impl<'a> State<'a> {\n                     self.print_else(e.as_deref())\n                 }\n                 // Final `else` block.\n-                ast::ExprKind::Block(ref b, _) => {\n+                ast::ExprKind::Block(b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else \");\n@@ -202,7 +202,7 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(receiver, parser::PREC_POSTFIX);\n         self.word(\".\");\n         self.print_ident(segment.ident);\n-        if let Some(ref args) = segment.args {\n+        if let Some(args) = &segment.args {\n             self.print_generic_args(args, true);\n         }\n         self.print_call_post(base_args)\n@@ -284,73 +284,66 @@ impl<'a> State<'a> {\n \n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n-        match expr.kind {\n-            ast::ExprKind::Box(ref expr) => {\n+        match &expr.kind {\n+            ast::ExprKind::Box(expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n             }\n-            ast::ExprKind::Array(ref exprs) => {\n+            ast::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }\n-            ast::ExprKind::ConstBlock(ref anon_const) => {\n+            ast::ExprKind::ConstBlock(anon_const) => {\n                 self.print_expr_anon_const(anon_const, attrs);\n             }\n-            ast::ExprKind::Repeat(ref element, ref count) => {\n+            ast::ExprKind::Repeat(element, count) => {\n                 self.print_expr_repeat(element, count);\n             }\n-            ast::ExprKind::Struct(ref se) => {\n+            ast::ExprKind::Struct(se) => {\n                 self.print_expr_struct(&se.qself, &se.path, &se.fields, &se.rest);\n             }\n-            ast::ExprKind::Tup(ref exprs) => {\n+            ast::ExprKind::Tup(exprs) => {\n                 self.print_expr_tup(exprs);\n             }\n-            ast::ExprKind::Call(ref func, ref args) => {\n+            ast::ExprKind::Call(func, args) => {\n                 self.print_expr_call(func, &args);\n             }\n-            ast::ExprKind::MethodCall(box ast::MethodCall {\n-                ref seg,\n-                ref receiver,\n-                ref args,\n-                ..\n-            }) => {\n+            ast::ExprKind::MethodCall(box ast::MethodCall { seg, receiver, args, .. }) => {\n                 self.print_expr_method_call(seg, &receiver, &args);\n             }\n-            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, lhs, rhs);\n+            ast::ExprKind::Binary(op, lhs, rhs) => {\n+                self.print_expr_binary(*op, lhs, rhs);\n             }\n-            ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, expr);\n+            ast::ExprKind::Unary(op, expr) => {\n+                self.print_expr_unary(*op, expr);\n             }\n-            ast::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, expr);\n+            ast::ExprKind::AddrOf(k, m, expr) => {\n+                self.print_expr_addr_of(*k, *m, expr);\n             }\n             ast::ExprKind::Lit(token_lit) => {\n-                self.print_token_literal(token_lit, expr.span);\n+                self.print_token_literal(*token_lit, expr.span);\n             }\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n+            ast::ExprKind::IncludedBytes(bytes) => {\n                 let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n                 self.print_token_literal(lit, expr.span)\n             }\n-            ast::ExprKind::Cast(ref expr, ref ty) => {\n+            ast::ExprKind::Cast(expr, ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n                 self.space();\n                 self.word_space(\"as\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Type(ref expr, ref ty) => {\n+            ast::ExprKind::Type(expr, ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n                 self.word_space(\":\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Let(ref pat, ref scrutinee, _) => {\n+            ast::ExprKind::Let(pat, scrutinee, _) => {\n                 self.print_let(pat, scrutinee);\n             }\n-            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(test, blk, elseopt.as_deref())\n-            }\n-            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+            ast::ExprKind::If(test, blk, elseopt) => self.print_if(test, blk, elseopt.as_deref()),\n+            ast::ExprKind::While(test, blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -362,7 +355,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+            ast::ExprKind::ForLoop(pat, iter, blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -377,7 +370,7 @@ impl<'a> State<'a> {\n                 self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Loop(ref blk, opt_label, _) => {\n+            ast::ExprKind::Loop(blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -387,7 +380,7 @@ impl<'a> State<'a> {\n                 self.word_nbsp(\"loop\");\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Match(ref expr, ref arms) => {\n+            ast::ExprKind::Match(expr, arms) => {\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.word_nbsp(\"match\");\n@@ -402,18 +395,18 @@ impl<'a> State<'a> {\n                 self.bclose(expr.span, empty);\n             }\n             ast::ExprKind::Closure(box ast::Closure {\n-                ref binder,\n+                binder,\n                 capture_clause,\n                 asyncness,\n                 movability,\n-                ref fn_decl,\n-                ref body,\n+                fn_decl,\n+                body,\n                 fn_decl_span: _,\n             }) => {\n                 self.print_closure_binder(binder);\n-                self.print_movability(movability);\n-                self.print_asyncness(asyncness);\n-                self.print_capture_clause(capture_clause);\n+                self.print_movability(*movability);\n+                self.print_asyncness(*asyncness);\n+                self.print_capture_clause(*capture_clause);\n \n                 self.print_fn_params_and_ret(fn_decl, true);\n                 self.space();\n@@ -425,7 +418,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n             }\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n+            ast::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -436,72 +429,71 @@ impl<'a> State<'a> {\n                 self.ibox(0);\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+            ast::ExprKind::Async(capture_clause, _, blk) => {\n                 self.word_nbsp(\"async\");\n-                self.print_capture_clause(capture_clause);\n+                self.print_capture_clause(*capture_clause);\n                 // cbox/ibox in analogy to the `ExprKind::Block` arm above\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.print_block_with_attrs(blk, attrs);\n             }\n-            ast::ExprKind::Await(ref expr) => {\n+            ast::ExprKind::Await(expr) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".await\");\n             }\n-            ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            ast::ExprKind::Assign(lhs, rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n-            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(op, lhs, rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word(op.node.to_string());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n-            ast::ExprKind::Field(ref expr, ident) => {\n+            ast::ExprKind::Field(expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".\");\n-                self.print_ident(ident);\n+                self.print_ident(*ident);\n             }\n-            ast::ExprKind::Index(ref expr, ref index) => {\n+            ast::ExprKind::Index(expr, index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\"[\");\n                 self.print_expr(index);\n                 self.word(\"]\");\n             }\n-            ast::ExprKind::Range(ref start, ref end, limits) => {\n+            ast::ExprKind::Range(start, end, limits) => {\n                 // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n                 // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n                 // Here we use a fake precedence value so that any child with lower precedence than\n                 // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n                 let fake_prec = AssocOp::LOr.precedence() as i8;\n-                if let Some(ref e) = *start {\n+                if let Some(e) = start {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n-                if limits == ast::RangeLimits::HalfOpen {\n-                    self.word(\"..\");\n-                } else {\n-                    self.word(\"..=\");\n+                match limits {\n+                    ast::RangeLimits::HalfOpen => self.word(\"..\"),\n+                    ast::RangeLimits::Closed => self.word(\"..=\"),\n                 }\n-                if let Some(ref e) = *end {\n+                if let Some(e) = end {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n             }\n             ast::ExprKind::Underscore => self.word(\"_\"),\n-            ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n-            ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n-            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n+            ast::ExprKind::Path(None, path) => self.print_path(path, true, 0),\n+            ast::ExprKind::Path(Some(qself), path) => self.print_qpath(path, qself, true),\n+            ast::ExprKind::Break(opt_label, opt_expr) => {\n                 self.word(\"break\");\n                 if let Some(label) = opt_label {\n                     self.space();\n                     self.print_ident(label.ident);\n                 }\n-                if let Some(ref expr) = *opt_expr {\n+                if let Some(expr) = opt_expr {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n@@ -513,45 +505,45 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                 }\n             }\n-            ast::ExprKind::Ret(ref result) => {\n+            ast::ExprKind::Ret(result) => {\n                 self.word(\"return\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::Yeet(ref result) => {\n+            ast::ExprKind::Yeet(result) => {\n                 self.word(\"do\");\n                 self.word(\" \");\n                 self.word(\"yeet\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::InlineAsm(ref a) => {\n+            ast::ExprKind::InlineAsm(a) => {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n-            ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n-            ast::ExprKind::Paren(ref e) => {\n+            ast::ExprKind::MacCall(m) => self.print_mac(m),\n+            ast::ExprKind::Paren(e) => {\n                 self.popen();\n                 self.print_expr(e);\n                 self.pclose();\n             }\n-            ast::ExprKind::Yield(ref e) => {\n+            ast::ExprKind::Yield(e) => {\n                 self.word(\"yield\");\n \n-                if let Some(ref expr) = *e {\n+                if let Some(expr) = e {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            ast::ExprKind::Try(ref e) => {\n+            ast::ExprKind::Try(e) => {\n                 self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n                 self.word(\"?\")\n             }\n-            ast::ExprKind::TryBlock(ref blk) => {\n+            ast::ExprKind::TryBlock(blk) => {\n                 self.cbox(0);\n                 self.ibox(0);\n                 self.word_nbsp(\"try\");\n@@ -578,15 +570,15 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&arm.attrs);\n         self.print_pat(&arm.pat);\n         self.space();\n-        if let Some(ref e) = arm.guard {\n+        if let Some(e) = &arm.guard {\n             self.word_space(\"if\");\n             self.print_expr(e);\n             self.space();\n         }\n         self.word_space(\"=>\");\n \n-        match arm.body.kind {\n-            ast::ExprKind::Block(ref blk, opt_label) => {\n+        match &arm.body.kind {\n+            ast::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");"}, {"sha": "c52f15401abe3094b9e351344ae5e570bc5c0d6e", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -136,10 +136,10 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n-        match item.kind {\n+        match &item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n-                if let Some(orig_name) = orig_name {\n+                if let &Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n                     self.space();\n                     self.word(\"as\");\n@@ -150,35 +150,41 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::Use(ref tree) => {\n+            ast::ItemKind::Use(tree) => {\n                 self.print_visibility(&item.vis);\n                 self.word_nbsp(\"use\");\n                 self.print_use_tree(tree);\n                 self.word(\";\");\n             }\n-            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+            ast::ItemKind::Static(ty, mutbl, body) => {\n                 let def = ast::Defaultness::Final;\n-                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n+                self.print_item_const(\n+                    item.ident,\n+                    Some(*mutbl),\n+                    ty,\n+                    body.as_deref(),\n+                    &item.vis,\n+                    def,\n+                );\n             }\n-            ast::ItemKind::Const(def, ref ty, ref body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n+            ast::ItemKind::Const(def, ty, body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, *def);\n             }\n-            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                let body = body.as_deref();\n+            ast::ItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n                 self.print_fn_full(\n                     sig,\n                     item.ident,\n                     generics,\n                     &item.vis,\n-                    defaultness,\n-                    body,\n+                    *defaultness,\n+                    body.as_deref(),\n                     &item.attrs,\n                 );\n             }\n-            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n+            ast::ItemKind::Mod(unsafety, mod_kind) => {\n                 self.head(Self::to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(unsafety);\n+                    s.print_unsafety(*unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n@@ -201,7 +207,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n-            ast::ItemKind::ForeignMod(ref nmod) => {\n+            ast::ItemKind::ForeignMod(nmod) => {\n                 self.head(Self::to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n@@ -215,7 +221,7 @@ impl<'a> State<'a> {\n                 let empty = item.attrs.is_empty() && nmod.items.is_empty();\n                 self.bclose(item.span, empty);\n             }\n-            ast::ItemKind::GlobalAsm(ref asm) => {\n+            ast::ItemKind::GlobalAsm(asm) => {\n                 self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n                 self.print_inline_asm(asm);\n                 self.word(\";\");\n@@ -224,32 +230,31 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::TyAlias(box ast::TyAlias {\n                 defaultness,\n-                ref generics,\n+                generics,\n                 where_clauses,\n                 where_predicates_split,\n-                ref bounds,\n-                ref ty,\n+                bounds,\n+                ty,\n             }) => {\n-                let ty = ty.as_deref();\n                 self.print_associated_type(\n                     item.ident,\n                     generics,\n-                    where_clauses,\n-                    where_predicates_split,\n+                    *where_clauses,\n+                    *where_predicates_split,\n                     bounds,\n-                    ty,\n+                    ty.as_deref(),\n                     &item.vis,\n-                    defaultness,\n+                    *defaultness,\n                 );\n             }\n-            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n+            ast::ItemKind::Enum(enum_definition, params) => {\n                 self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n             }\n-            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n+            ast::ItemKind::Struct(struct_def, generics) => {\n                 self.head(visibility_qualified(&item.vis, \"struct\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n-            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+            ast::ItemKind::Union(struct_def, generics) => {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n@@ -258,15 +263,15 @@ impl<'a> State<'a> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                ref items,\n+                generics,\n+                of_trait,\n+                self_ty,\n+                items,\n             }) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n+                self.print_defaultness(*defaultness);\n+                self.print_unsafety(*unsafety);\n                 self.word(\"impl\");\n \n                 if generics.params.is_empty() {\n@@ -276,13 +281,13 @@ impl<'a> State<'a> {\n                     self.space();\n                 }\n \n-                self.print_constness(constness);\n+                self.print_constness(*constness);\n \n                 if let ast::ImplPolarity::Negative(_) = polarity {\n                     self.word(\"!\");\n                 }\n \n-                if let Some(ref t) = *of_trait {\n+                if let Some(t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.space();\n                     self.word_space(\"for\");\n@@ -303,21 +308,21 @@ impl<'a> State<'a> {\n             ast::ItemKind::Trait(box ast::Trait {\n                 is_auto,\n                 unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n+                generics,\n+                bounds,\n+                items,\n                 ..\n             }) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n-                self.print_unsafety(unsafety);\n-                self.print_is_auto(is_auto);\n+                self.print_unsafety(*unsafety);\n+                self.print_is_auto(*is_auto);\n                 self.word_nbsp(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -339,14 +344,14 @@ impl<'a> State<'a> {\n                 let empty = item.attrs.is_empty() && items.is_empty();\n                 self.bclose(item.span, empty);\n             }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ast::ItemKind::TraitAlias(generics, bounds) => {\n                 self.head(visibility_qualified(&item.vis, \"trait\"));\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                    if let GenericBound::Trait(ptr, ast::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -364,13 +369,13 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::MacCall(ref mac) => {\n+            ast::ItemKind::MacCall(mac) => {\n                 self.print_mac(mac);\n                 if mac.args.need_semicolon() {\n                     self.word(\";\");\n                 }\n             }\n-            ast::ItemKind::MacroDef(ref macro_def) => {\n+            ast::ItemKind::MacroDef(macro_def) => {\n                 self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n                     state.print_visibility(&item.vis)\n                 });\n@@ -412,11 +417,11 @@ impl<'a> State<'a> {\n     }\n \n     pub(crate) fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.kind {\n+        match &vis.kind {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            ast::VisibilityKind::Restricted { ref path, id: _, shorthand } => {\n+            ast::VisibilityKind::Restricted { path, shorthand, .. } => {\n                 let path = Self::to_string(|s| s.print_path(path, false, 0));\n-                if shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n+                if *shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n                     self.word_nbsp(format!(\"pub(in {})\", path))\n@@ -465,7 +470,7 @@ impl<'a> State<'a> {\n     ) {\n         self.print_ident(ident);\n         self.print_generic_params(&generics.params);\n-        match struct_def {\n+        match &struct_def {\n             ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n                 if let ast::VariantData::Tuple(..) = struct_def {\n                     self.popen();\n@@ -484,7 +489,7 @@ impl<'a> State<'a> {\n                 self.end();\n                 self.end(); // Close the outer-box.\n             }\n-            ast::VariantData::Struct(ref fields, ..) => {\n+            ast::VariantData::Struct(fields, ..) => {\n                 self.print_where_clause(&generics.where_clause);\n                 self.print_record_struct_body(fields, span);\n             }\n@@ -496,7 +501,7 @@ impl<'a> State<'a> {\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        if let Some(ref d) = v.disr_expr {\n+        if let Some(d) = &v.disr_expr {\n             self.space();\n             self.word_space(\"=\");\n             self.print_expr(&d.value)\n@@ -657,10 +662,10 @@ impl<'a> State<'a> {\n     }\n \n     fn print_use_tree(&mut self, tree: &ast::UseTree) {\n-        match tree.kind {\n+        match &tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 self.print_path(&tree.prefix, false, 0);\n-                if let Some(rename) = rename {\n+                if let &Some(rename) = rename {\n                     self.nbsp();\n                     self.word_nbsp(\"as\");\n                     self.print_ident(rename);\n@@ -673,7 +678,7 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"*\");\n             }\n-            ast::UseTreeKind::Nested(ref items) => {\n+            ast::UseTreeKind::Nested(items) => {\n                 if !tree.prefix.segments.is_empty() {\n                     self.print_path(&tree.prefix, false, 0);\n                     self.word(\"::\");"}, {"sha": "90e2b6b698cf832ec4a2d45e266e173369a3062f", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1705,29 +1705,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n     }\n \n+    #[instrument(level = \"debug\", skip(self, infcx, errors_buffer))]\n     fn check_member_constraints(\n         &self,\n         infcx: &InferCtxt<'tcx>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         let member_constraints = self.member_constraints.clone();\n         for m_c_i in member_constraints.all_indices() {\n-            debug!(\"check_member_constraint(m_c_i={:?})\", m_c_i);\n+            debug!(?m_c_i);\n             let m_c = &member_constraints[m_c_i];\n             let member_region_vid = m_c.member_region_vid;\n             debug!(\n-                \"check_member_constraint: member_region_vid={:?} with value {}\",\n-                member_region_vid,\n-                self.region_value_str(member_region_vid),\n+                ?member_region_vid,\n+                value = ?self.region_value_str(member_region_vid),\n             );\n             let choice_regions = member_constraints.choice_regions(m_c_i);\n-            debug!(\"check_member_constraint: choice_regions={:?}\", choice_regions);\n+            debug!(?choice_regions);\n \n             // Did the member region wind up equal to any of the option regions?\n             if let Some(o) =\n                 choice_regions.iter().find(|&&o_r| self.eval_equal(o_r, m_c.member_region_vid))\n             {\n-                debug!(\"check_member_constraint: evaluated as equal to {:?}\", o);\n+                debug!(\"evaluated as equal to {:?}\", o);\n                 continue;\n             }\n "}, {"sha": "c9f5dd0f2c68b86e3b13d4ac911fe8f1cf5edf44", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -292,30 +292,33 @@ fn llvm_target_features(tm: &llvm::TargetMachine) -> Vec<(&str, &str)> {\n }\n \n fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n-    let mut target_features = llvm_target_features(tm);\n+    let mut llvm_target_features = llvm_target_features(tm);\n+    let mut known_llvm_target_features = FxHashSet::<&'static str>::default();\n     let mut rustc_target_features = supported_target_features(sess)\n         .iter()\n-        .filter_map(|(feature, _gate)| {\n-            for llvm_feature in to_llvm_features(sess, *feature) {\n+        .map(|(feature, _gate)| {\n+            let desc = if let Some(llvm_feature) = to_llvm_features(sess, *feature).first() {\n                 // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n-                match target_features.binary_search_by_key(&llvm_feature, |(f, _d)| f).ok().map(\n-                    |index| {\n-                        let (_f, desc) = target_features.remove(index);\n-                        (*feature, desc)\n-                    },\n-                ) {\n-                    Some(v) => return Some(v),\n-                    None => {}\n+                match llvm_target_features.binary_search_by_key(&llvm_feature, |(f, _d)| f).ok() {\n+                    Some(index) => {\n+                        known_llvm_target_features.insert(llvm_feature);\n+                        llvm_target_features[index].1\n+                    }\n+                    None => \"\",\n                 }\n-            }\n-            None\n+            } else {\n+                \"\"\n+            };\n+            (*feature, desc)\n         })\n         .collect::<Vec<_>>();\n     rustc_target_features.extend_from_slice(&[(\n         \"crt-static\",\n         \"Enables C Run-time Libraries to be statically linked\",\n     )]);\n-    let max_feature_len = target_features\n+    llvm_target_features.retain(|(f, _d)| !known_llvm_target_features.contains(f));\n+\n+    let max_feature_len = llvm_target_features\n         .iter()\n         .chain(rustc_target_features.iter())\n         .map(|(feature, _desc)| feature.len())\n@@ -327,10 +330,10 @@ fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n         println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n     }\n     println!(\"\\nCode-generation features supported by LLVM for this target:\");\n-    for (feature, desc) in &target_features {\n+    for (feature, desc) in &llvm_target_features {\n         println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n     }\n-    if target_features.is_empty() {\n+    if llvm_target_features.is_empty() {\n         println!(\"    Target features listing is not supported by this LLVM version.\");\n     }\n     println!(\"\\nUse +feature to enable a feature, or -feature to disable it.\");"}, {"sha": "d623e726139442891d173b04829e287ede2cdc82", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -33,7 +33,7 @@ use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs}\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, ToPredicate, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -1366,12 +1366,14 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n             \"predicates_defined_on: inferred_outlives_of({:?}) = {:?}\",\n             def_id, inferred_outlives,\n         );\n+        let inferred_outlives_iter =\n+            inferred_outlives.iter().map(|(clause, span)| ((*clause).to_predicate(tcx), *span));\n         if result.predicates.is_empty() {\n-            result.predicates = inferred_outlives;\n+            result.predicates = tcx.arena.alloc_from_iter(inferred_outlives_iter);\n         } else {\n-            result.predicates = tcx\n-                .arena\n-                .alloc_from_iter(result.predicates.iter().chain(inferred_outlives).copied());\n+            result.predicates = tcx.arena.alloc_from_iter(\n+                result.predicates.into_iter().copied().chain(inferred_outlives_iter),\n+            );\n         }\n     }\n "}, {"sha": "81fe32000d3079450050b0937075c5f20bcdfae2", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -17,7 +17,7 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers { inferred_outlives_of, inferred_outlives_crate, ..*providers };\n }\n \n-fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate<'_>, Span)] {\n+fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Clause<'_>, Span)] {\n     let id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n \n     if matches!(tcx.def_kind(item_def_id), hir::def::DefKind::AnonConst) && tcx.lazy_normalization()\n@@ -50,12 +50,10 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|(out_pred, _)| match out_pred.kind().skip_binder() {\n-                            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(p)) => {\n-                                p.to_string()\n-                            }\n-                            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(p)) => p.to_string(),\n-                            err => bug!(\"unexpected predicate {:?}\", err),\n+                        .map(|(out_pred, _)| match out_pred {\n+                            ty::Clause::RegionOutlives(p) => p.to_string(),\n+                            ty::Clause::TypeOutlives(p) => p.to_string(),\n+                            err => bug!(\"unexpected clause {:?}\", err),\n                         })\n                         .collect();\n                     pred.sort();\n@@ -103,19 +101,11 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, (): ()) -> CratePredicatesMap<'_> {\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n-                                ty::OutlivesPredicate(ty1, *region2),\n-                            )))\n-                            .to_predicate(tcx),\n+                            ty::Clause::TypeOutlives(ty::OutlivesPredicate(ty1, *region2)),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::Clause(\n-                                ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                                    region1, *region2,\n-                                )),\n-                            ))\n-                            .to_predicate(tcx),\n+                            ty::Clause::RegionOutlives(ty::OutlivesPredicate(region1, *region2)),\n                             span,\n                         )),\n                         GenericArgKind::Const(_) => {"}, {"sha": "825093384fba7f4688948e4f1eb963decf7fc9e3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -2046,16 +2046,13 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n \n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n-        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n+        inferred_outlives: &'tcx [(ty::Clause<'tcx>, Span)],\n         def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                    a,\n-                    b,\n-                ))) => match *a {\n+            .filter_map(|(clause, _)| match *clause {\n+                ty::Clause::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n                     ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n@@ -2065,16 +2062,15 @@ impl ExplicitOutlivesRequirements {\n     }\n \n     fn lifetimes_outliving_type<'tcx>(\n-        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n+        inferred_outlives: &'tcx [(ty::Clause<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                    a,\n-                    b,\n-                ))) => a.is_param(index).then_some(b),\n+            .filter_map(|(clause, _)| match *clause {\n+                ty::Clause::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    a.is_param(index).then_some(b)\n+                }\n                 _ => None,\n             })\n             .collect()"}, {"sha": "6b60577c9023fff91ffa1fa29675a9523afa3be3", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -353,7 +353,7 @@ define_tables! {\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n     // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n+    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<Ty<'static>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,"}, {"sha": "e1220320eea1b5732808dea43d0644f1e48565e9", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -562,7 +562,7 @@ rustc_queries! {\n \n     /// Returns the inferred outlives predicates (e.g., for `struct\n     /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-    query inferred_outlives_of(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    query inferred_outlives_of(key: DefId) -> &'tcx [(ty::Clause<'tcx>, Span)] {\n         desc { |tcx| \"computing inferred outlives predicates of `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern"}, {"sha": "75f2d45eadb81dbdea74246cedd6188b6002b6eb", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -345,6 +345,14 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     }\n }\n \n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [(ty::Clause<'tcx>, Span)] {\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.interner().arena.alloc_from_iter(\n+            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        )\n+    }\n+}\n+\n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for ty::List<ty::BoundVariableKind>\n {"}, {"sha": "dd4ab3e8d30bf24dff563a8273a90eb6ee2e2e73", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -734,7 +734,7 @@ pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n-    pub predicates: FxHashMap<DefId, &'tcx [(Predicate<'tcx>, Span)]>,\n+    pub predicates: FxHashMap<DefId, &'tcx [(Clause<'tcx>, Span)]>,\n }\n \n impl<'tcx> Predicate<'tcx> {\n@@ -1167,6 +1167,13 @@ impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, PredicateKind<'tc\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Clause<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::Clause(self)))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {"}, {"sha": "c7d6c6abd1c22ebe153c37ae240e8f572058eee3", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -5,7 +5,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use crate::middle::exported_symbols::ExportedSymbol;\n use crate::mir::Body;\n use crate::ty::{\n-    self, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n+    self, Clause, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n };\n \n pub trait ParameterizedOverTcx: 'static {\n@@ -121,6 +121,7 @@ parameterized_over_tcx! {\n     TraitRef,\n     Const,\n     Predicate,\n+    Clause,\n     GeneratorDiagnosticData,\n     Body,\n     ExportedSymbol,"}, {"sha": "e7c3c712852ddc10b7993db636277a3eb3625cda", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -116,6 +116,17 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n \n         intravisit::walk_expr(self, expr)\n     }\n+\n+    fn visit_inline_asm(&mut self, asm: &'tcx hir::InlineAsm<'tcx>, id: hir::HirId) {\n+        for (op, _) in asm.operands {\n+            if let hir::InlineAsmOperand::SymStatic { def_id, .. } = op {\n+                if let Some(def_id) = def_id.as_local() {\n+                    self.reachable_symbols.insert(def_id);\n+                }\n+            }\n+        }\n+        intravisit::walk_inline_asm(self, asm, id);\n+    }\n }\n \n impl<'tcx> ReachableContext<'tcx> {"}, {"sha": "ac9653b90071cdacd01923cd3bb2c6c42479be14", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -818,6 +818,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>\n     }\n }\n \n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Clause<'tcx>, Span)] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [rustc_ast::InlineAsmTemplatePiece] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)"}, {"sha": "7dad9aa01fafdaac8525b54a8d7724b70b4c4f06", "filename": "compiler/rustc_serialize/src/leb128.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1,22 +1,19 @@\n-#![macro_use]\n-\n-macro_rules! max_leb128_len {\n-    ($int_ty:ty) => {\n-        // The longest LEB128 encoding for an integer uses 7 bits per byte.\n-        (std::mem::size_of::<$int_ty>() * 8 + 6) / 7\n-    };\n+/// Returns the length of the longest LEB128 encoding for `T`, assuming `T` is an integer type\n+pub const fn max_leb128_len<T>() -> usize {\n+    // The longest LEB128 encoding for an integer uses 7 bits per byte.\n+    (std::mem::size_of::<T>() * 8 + 6) / 7\n }\n \n-/// Returns the longest LEB128 encoding of all supported integer types.\n-pub const fn max_leb128_len() -> usize {\n-    max_leb128_len!(u128)\n+/// Returns the length of the longest LEB128 encoding of all supported integer types.\n+pub const fn largest_max_leb128_len() -> usize {\n+    max_leb128_len::<u128>()\n }\n \n macro_rules! impl_write_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n         pub fn $fn_name(\n-            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len!($int_ty)],\n+            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len::<$int_ty>()],\n             mut value: $int_ty,\n         ) -> &[u8] {\n             let mut i = 0;\n@@ -90,7 +87,7 @@ macro_rules! impl_write_signed_leb128 {\n     ($fn_name:ident, $int_ty:ty) => {\n         #[inline]\n         pub fn $fn_name(\n-            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len!($int_ty)],\n+            out: &mut [::std::mem::MaybeUninit<u8>; max_leb128_len::<$int_ty>()],\n             mut value: $int_ty,\n         ) -> &[u8] {\n             let mut i = 0;"}, {"sha": "0afeb86fceb241611867c67ee4820f4e810507ac", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1,4 +1,4 @@\n-use crate::leb128::{self, max_leb128_len};\n+use crate::leb128::{self, largest_max_leb128_len};\n use crate::serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::convert::TryInto;\n use std::fs::File;\n@@ -32,7 +32,7 @@ impl MemEncoder {\n \n macro_rules! write_leb128 {\n     ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);\n+        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n         let old_len = $enc.data.len();\n \n         if MAX_ENCODED_LEN > $enc.data.capacity() - old_len {\n@@ -186,12 +186,12 @@ impl FileEncoder {\n     pub fn with_capacity<P: AsRef<Path>>(path: P, capacity: usize) -> io::Result<Self> {\n         // Require capacity at least as large as the largest LEB128 encoding\n         // here, so that we don't have to check or handle this on every write.\n-        assert!(capacity >= max_leb128_len());\n+        assert!(capacity >= largest_max_leb128_len());\n \n         // Require capacity small enough such that some capacity checks can be\n         // done using guaranteed non-overflowing add rather than sub, which\n         // shaves an instruction off those code paths (on x86 at least).\n-        assert!(capacity <= usize::MAX - max_leb128_len());\n+        assert!(capacity <= usize::MAX - largest_max_leb128_len());\n \n         // Create the file for reading and writing, because some encoders do both\n         // (e.g. the metadata encoder when -Zmeta-stats is enabled)\n@@ -411,7 +411,7 @@ impl Drop for FileEncoder {\n \n macro_rules! file_encoder_write_leb128 {\n     ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = max_leb128_len!($int_ty);\n+        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n \n         // We ensure this during `FileEncoder` construction.\n         debug_assert!($enc.capacity() >= MAX_ENCODED_LEN);"}, {"sha": "0f8cfd7f5385cb9eee9f824a4546336e890995f8", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1250,8 +1250,8 @@ supported_targets! {\n \n     (\"mips64-openwrt-linux-musl\", mips64_openwrt_linux_musl),\n \n-    (\"aarch64-unknown-nto-qnx7.1.0\", aarch64_unknown_nto_qnx_710),\n-    (\"x86_64-pc-nto-qnx7.1.0\", x86_64_pc_nto_qnx710),\n+    (\"aarch64-unknown-nto-qnx710\", aarch64_unknown_nto_qnx_710),\n+    (\"x86_64-pc-nto-qnx710\", x86_64_pc_nto_qnx710),\n }\n \n /// Cow-Vec-Str: Cow<'static, [Cow<'static, str>]>"}, {"sha": "fe5135661b5f8f3996649ee9519849d747ad08e3", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 210, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -9,225 +9,18 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n use rustc_target::spec::abi::Abi;\n \n use crate::traits;\n-use crate::traits::coherence::Conflict;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::{util, SelectionResult};\n-use crate::traits::{ErrorReporting, Overflow, Unimplemented};\n+use crate::traits::util;\n \n use super::BuiltinImplConditions;\n-use super::IntercrateAmbiguityCause;\n-use super::OverflowError;\n-use super::SelectionCandidate::{self, *};\n-use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+use super::SelectionCandidate::*;\n+use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn candidate_from_obligation<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        // Watch out for overflow. This intentionally bypasses (and does\n-        // not update) the cache.\n-        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n-\n-        // Check the cache. Note that we freshen the trait-ref\n-        // separately rather than using `stack.fresh_trait_ref` --\n-        // this is because we want the unbound variables to be\n-        // replaced with fresh types starting from index 0.\n-        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n-        debug!(?cache_fresh_trait_pred);\n-        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n-\n-        if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n-        {\n-            debug!(\"CACHE HIT\");\n-            return c;\n-        }\n-\n-        // If no match, compute result and insert into cache.\n-        //\n-        // FIXME(nikomatsakis) -- this cache is not taking into\n-        // account cycles that may have occurred in forming the\n-        // candidate. I don't know of any specific problems that\n-        // result but it seems awfully suspicious.\n-        let (candidate, dep_node) =\n-            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n-\n-        debug!(\"CACHE MISS\");\n-        self.insert_candidate_cache(\n-            stack.obligation.param_env,\n-            cache_fresh_trait_pred,\n-            dep_node,\n-            candidate.clone(),\n-        );\n-        candidate\n-    }\n-\n-    fn candidate_from_obligation_no_cache<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        if let Err(conflict) = self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            if self.intercrate_ambiguity_causes.is_some() {\n-                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                // Heuristics: show the diagnostics when there are no candidates in crate.\n-                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                    let mut no_candidates_apply = true;\n-\n-                    for c in candidate_set.vec.iter() {\n-                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n-                            no_candidates_apply = false;\n-                            break;\n-                        }\n-                    }\n-\n-                    if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n-                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            };\n-                            (trait_desc, self_desc)\n-                        });\n-                        let cause = if let Conflict::Upstream = conflict {\n-                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                        } else {\n-                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                        };\n-                        debug!(?cause, \"evaluate_stack: pushing cause\");\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n-                    }\n-                }\n-            }\n-            return Ok(None);\n-        }\n-\n-        let candidate_set = self.assemble_candidates(stack)?;\n-\n-        if candidate_set.ambiguous {\n-            debug!(\"candidate set contains ambig\");\n-            return Ok(None);\n-        }\n-\n-        let candidates = candidate_set.vec;\n-\n-        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n-\n-        // At this point, we know that each of the entries in the\n-        // candidate set is *individually* applicable. Now we have to\n-        // figure out if they contain mutual incompatibilities. This\n-        // frequently arises if we have an unconstrained input type --\n-        // for example, we are looking for `$0: Eq` where `$0` is some\n-        // unconstrained type variable. In that case, we'll get a\n-        // candidate which assumes $0 == int, one that assumes `$0 ==\n-        // usize`, etc. This spells an ambiguity.\n-\n-        let mut candidates = self.filter_impls(candidates, stack.obligation);\n-\n-        // If there is more than one candidate, first winnow them down\n-        // by considering extra conditions (nested obligations and so\n-        // forth). We don't winnow if there is exactly one\n-        // candidate. This is a relatively minor distinction but it\n-        // can lead to better inference and error-reporting. An\n-        // example would be if there was an impl:\n-        //\n-        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n-        //\n-        // and we were to see some code `foo.push_clone()` where `boo`\n-        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n-        // we were to winnow, we'd wind up with zero candidates.\n-        // Instead, we select the right impl now but report \"`Bar` does\n-        // not implement `Clone`\".\n-        if candidates.len() == 1 {\n-            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n-        }\n-\n-        // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization. Propagate overflow if it occurs.\n-        let mut candidates = candidates\n-            .into_iter()\n-            .map(|c| match self.evaluate_candidate(stack, &c) {\n-                Ok(eval) if eval.may_apply() => {\n-                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n-                }\n-                Ok(_) => Ok(None),\n-                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n-                Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n-                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n-            })\n-            .flat_map(Result::transpose)\n-            .collect::<Result<Vec<_>, _>>()?;\n-\n-        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n-\n-        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n-\n-        // If there are STILL multiple candidates, we can further\n-        // reduce the list by dropping duplicates -- including\n-        // resolving specializations.\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                        needs_infer,\n-                    )\n-                });\n-                if is_dup {\n-                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                    candidates.swap_remove(i);\n-                } else {\n-                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                    i += 1;\n-\n-                    // If there are *STILL* multiple candidates, give up\n-                    // and report ambiguity.\n-                    if i > 1 {\n-                        debug!(\"multiple matches, ambig\");\n-                        return Ok(None);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If there are *NO* candidates, then there are no impls --\n-        // that we know of, anyway. Note that in the case where there\n-        // are unbound type variables within the obligation, it might\n-        // be the case that you could still satisfy the obligation\n-        // from another crate by instantiating the type variables with\n-        // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_stack` (and hence users\n-        // who might care about this case, like coherence, should use\n-        // that function).\n-        if candidates.is_empty() {\n-            // If there's an error type, 'downgrade' our result from\n-            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n-            // emitting additional spurious errors, since we're guaranteed\n-            // to have emitted at least one.\n-            if stack.obligation.predicate.references_error() {\n-                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n-                return Ok(None);\n-            }\n-            return Err(Unimplemented);\n-        }\n-\n-        // Just one candidate left.\n-        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n-    }\n-\n     #[instrument(skip(self, stack), level = \"debug\")]\n     pub(super) fn assemble_candidates<'o>(\n         &mut self,"}, {"sha": "515f3a34988869a77b50f5ccfa36619197032a47", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -30,6 +30,7 @@ use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n+use crate::traits::Unimplemented;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -55,6 +56,7 @@ use std::fmt::{self, Display};\n use std::iter;\n \n pub use rustc_middle::traits::select::*;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n \n mod candidate_assembly;\n mod confirmation;\n@@ -305,6 +307,208 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.candidate_from_obligation(&stack)\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn candidate_from_obligation<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        // Watch out for overflow. This intentionally bypasses (and does\n+        // not update) the cache.\n+        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n+\n+        // Check the cache. Note that we freshen the trait-ref\n+        // separately rather than using `stack.fresh_trait_ref` --\n+        // this is because we want the unbound variables to be\n+        // replaced with fresh types starting from index 0.\n+        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n+        debug!(?cache_fresh_trait_pred);\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n+\n+        if let Some(c) =\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n+        {\n+            debug!(\"CACHE HIT\");\n+            return c;\n+        }\n+\n+        // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n+        let (candidate, dep_node) =\n+            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n+\n+        debug!(\"CACHE MISS\");\n+        self.insert_candidate_cache(\n+            stack.obligation.param_env,\n+            cache_fresh_trait_pred,\n+            dep_node,\n+            candidate.clone(),\n+        );\n+        candidate\n+    }\n+\n+    fn candidate_from_obligation_no_cache<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let Err(conflict) = self.is_knowable(stack) {\n+            debug!(\"coherence stage: not knowable\");\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    let mut no_candidates_apply = true;\n+\n+                    for c in candidate_set.vec.iter() {\n+                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n+                            no_candidates_apply = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    if !candidate_set.ambiguous && no_candidates_apply {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n+                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n+                            let self_desc = if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            };\n+                            (trait_desc, self_desc)\n+                        });\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(?cause, \"evaluate_stack: pushing cause\");\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n+                    }\n+                }\n+            }\n+            return Ok(None);\n+        }\n+\n+        let candidate_set = self.assemble_candidates(stack)?;\n+\n+        if candidate_set.ambiguous {\n+            debug!(\"candidate set contains ambig\");\n+            return Ok(None);\n+        }\n+\n+        let candidates = candidate_set.vec;\n+\n+        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n+\n+        // At this point, we know that each of the entries in the\n+        // candidate set is *individually* applicable. Now we have to\n+        // figure out if they contain mutual incompatibilities. This\n+        // frequently arises if we have an unconstrained input type --\n+        // for example, we are looking for `$0: Eq` where `$0` is some\n+        // unconstrained type variable. In that case, we'll get a\n+        // candidate which assumes $0 == int, one that assumes `$0 ==\n+        // usize`, etc. This spells an ambiguity.\n+\n+        let mut candidates = self.filter_impls(candidates, stack.obligation);\n+\n+        // If there is more than one candidate, first winnow them down\n+        // by considering extra conditions (nested obligations and so\n+        // forth). We don't winnow if there is exactly one\n+        // candidate. This is a relatively minor distinction but it\n+        // can lead to better inference and error-reporting. An\n+        // example would be if there was an impl:\n+        //\n+        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n+        //\n+        // and we were to see some code `foo.push_clone()` where `boo`\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // we were to winnow, we'd wind up with zero candidates.\n+        // Instead, we select the right impl now but report \"`Bar` does\n+        // not implement `Clone`\".\n+        if candidates.len() == 1 {\n+            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let mut candidates = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => {\n+                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n+                }\n+                Ok(_) => Ok(None),\n+                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n+                Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n+                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n+            })\n+            .flat_map(Result::transpose)\n+            .collect::<Result<Vec<_>, _>>()?;\n+\n+        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n+\n+        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n+\n+        // If there are STILL multiple candidates, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            while i < candidates.len() {\n+                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n+                });\n+                if is_dup {\n+                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                    candidates.swap_remove(i);\n+                } else {\n+                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                    i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If there are *NO* candidates, then there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_stack` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n+        if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.predicate.references_error() {\n+                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n+                return Ok(None);\n+            }\n+            return Err(Unimplemented);\n+        }\n+\n+        // Just one candidate left.\n+        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -2140,6 +2344,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, impl_trait_ref, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n+                // FIXME: A rematch may fail when a candidate cache hit occurs\n+                // on thefreshened form of the trait predicate, but the match\n+                // fails for some reason that is not captured in the freshened\n+                // cache key. For example, equating an impl trait ref against\n+                // the placeholder trait ref may fail due the Generalizer relation\n+                // raising a CyclicalTy error due to a sub_root_var relation\n+                // for a variable being generalized...\n                 self.infcx.tcx.sess.delay_span_bug(\n                     obligation.cause.span,\n                     &format!("}, {"sha": "5f8748206d7645508b254bd01dd69e10e9dab1c5", "filename": "library/core/src/str/converts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -77,7 +77,7 @@ use super::Utf8Error;\n /// let sparkle_heart = [240, 159, 146, 150];\n ///\n /// // We know these bytes are valid, so just use `unwrap()`.\n-/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+/// let sparkle_heart: &str = str::from_utf8(&sparkle_heart).unwrap();\n ///\n /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n /// ```"}, {"sha": "6c957c2fa90eb517088f085687474dbc3b6d702a", "filename": "library/std/src/path.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1463,6 +1463,30 @@ impl PathBuf {\n         true\n     }\n \n+    /// Yields a mutable reference to the underlying [`OsString`] instance.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(path_as_mut_os_str)]\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let mut path = PathBuf::from(\"/foo\");\n+    ///\n+    /// path.push(\"bar\");\n+    /// assert_eq!(path, Path::new(\"/foo/bar\"));\n+    ///\n+    /// // OsString's `push` does not add a separator.\n+    /// path.as_mut_os_string().push(\"baz\");\n+    /// assert_eq!(path, Path::new(\"/foo/barbaz\"));\n+    /// ```\n+    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_mut_os_string(&mut self) -> &mut OsString {\n+        &mut self.inner\n+    }\n+\n     /// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.\n     ///\n     /// # Examples\n@@ -1993,6 +2017,28 @@ impl Path {\n         &self.inner\n     }\n \n+    /// Yields a mutable reference to the underlying [`OsStr`] slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(path_as_mut_os_str)]\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let mut path = PathBuf::from(\"/Foo.TXT\").into_boxed_path();\n+    ///\n+    /// assert_ne!(&*path, Path::new(\"/foo.txt\"));\n+    ///\n+    /// path.as_mut_os_str().make_ascii_lowercase();\n+    /// assert_eq!(&*path, Path::new(\"/foo.txt\"));\n+    /// ```\n+    #[unstable(feature = \"path_as_mut_os_str\", issue = \"105021\")]\n+    #[must_use]\n+    #[inline]\n+    pub fn as_mut_os_str(&mut self) -> &mut OsStr {\n+        &mut self.inner\n+    }\n+\n     /// Yields a [`&str`] slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity."}, {"sha": "6fb92c037ee4f4f3338411479bd699de8a38f68a", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1,10 +1,8 @@\n-use crate::convert::TryFrom;\n-use crate::ffi::{CStr, CString, OsString};\n+use crate::ffi::{CStr, OsString};\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::io::{self, Error, ErrorKind};\n use crate::io::{BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n-use crate::os::unix::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n use crate::sys::common::small_c_string::run_path_with_cstr;\n use crate::sys::cvt;"}, {"sha": "8f65544a9e894de0a21f897911fea2d688cead06", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -5,6 +5,7 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::num::NonZeroUsize;\n+use crate::ptr;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::thread_local_dtor::run_dtors;\n use crate::time::Duration;\n@@ -47,7 +48,7 @@ impl Thread {\n         extern \"C\" fn thread_start(main: usize) {\n             unsafe {\n                 // Finally, let's run some code.\n-                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n+                Box::from_raw(ptr::from_exposed_addr::<Box<dyn FnOnce()>>(main).cast_mut())();\n \n                 // run all destructors\n                 run_dtors();"}, {"sha": "2d5018d934e2e27023b8ea25122517ce0c3a16f4", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -441,6 +441,7 @@ def download_toolchain(self):\n \n             self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n             self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n+            self.fix_bin_or_dylib(\"{}/libexec/rust-analyzer-proc-macro-srv\".format(bin_root))\n             lib_dir = \"{}/lib\".format(bin_root)\n             for lib in os.listdir(lib_dir):\n                 if lib.endswith(\".so\"):"}, {"sha": "6ae283f32a5f3a9080edd104a4cf46bc01b3376d", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -360,6 +360,7 @@ impl Config {\n \n             self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustc\"));\n             self.fix_bin_or_dylib(&bin_root.join(\"bin\").join(\"rustdoc\"));\n+            self.fix_bin_or_dylib(&bin_root.join(\"libexec\").join(\"rust-analyzer-proc-macro-srv\"));\n             let lib_dir = bin_root.join(\"lib\");\n             for lib in t!(fs::read_dir(&lib_dir), lib_dir.display().to_string()) {\n                 let lib = t!(lib);"}, {"sha": "d0c3ddf2606245fb5acdc000e1e7de126dc881f8", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -214,7 +214,7 @@ target | std | host | notes\n [`aarch64-kmc-solid_asp3`](platform-support/kmc-solid.md) | \u2713 |  | ARM64 SOLID with TOPPERS/ASP3\n [`aarch64-nintendo-switch-freestanding`](platform-support/aarch64-nintendo-switch-freestanding.md) | * |  | ARM64 Nintendo Switch, Horizon\n [`aarch64-pc-windows-gnullvm`](platform-support/pc-windows-gnullvm.md) | \u2713 | \u2713 |\n-[`aarch64-unknown-nto-qnx7.1.0`](platform-support/nto-qnx.md) | ? |  | ARM64 QNX Neutrino 7.1 RTOS |\n+[`aarch64-unknown-nto-qnx710`](platform-support/nto-qnx.md) | ? |  | ARM64 QNX Neutrino 7.1 RTOS |\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | \u2713 |  | ARM64 HermitCore\n `aarch64-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (ILP32 ABI)\n@@ -305,7 +305,7 @@ target | std | host | notes\n `x86_64-apple-ios-macabi` | \u2713 |  | Apple Catalyst on x86_64\n `x86_64-apple-tvos` | * | | x86 64-bit tvOS\n [`x86_64-apple-watchos-sim`](platform-support/apple-watchos.md) | \u2713 | | x86 64-bit Apple WatchOS simulator\n-[`x86_64-pc-nto-qnx7.1.0`](platform-support/nto-qnx.md) | ? |  | x86 64-bit QNX Neutrino 7.1 RTOS |\n+[`x86_64-pc-nto-qnx710`](platform-support/nto-qnx.md) | ? |  | x86 64-bit QNX Neutrino 7.1 RTOS |\n [`x86_64-pc-windows-gnullvm`](platform-support/pc-windows-gnullvm.md) | \u2713 | \u2713 |\n `x86_64-pc-windows-msvc` | * |  | 64-bit Windows XP support\n `x86_64-sun-solaris` | ? |  | Deprecated target for 64-bit Solaris 10/11, illumos"}, {"sha": "37d0c31976c774a940ece3a5c119be2f31d74de3", "filename": "src/doc/rustc/src/platform-support/nto-qnx.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -93,15 +93,15 @@ Run the following:\n \n ```bash\n env \\\n-    CC_aarch64-unknown-nto-qnx7.1.0=\"qcc\" \\\n-    CFLAGS_aarch64-unknown-nto-qnx7.1.0=\"-Vgcc_ntoaarch64le_cxx\" \\\n-    CXX_aarch64-unknown-nto-qnx7.1.0=\"qcc\" \\\n-    AR_aarch64_unknown_nto_qnx7.1.0=\"ntoaarch64-ar\" \\\n-    CC_x86_64-pc-nto-qnx7.1.0=\"qcc\" \\\n-    CFLAGS_x86_64-pc-nto-qnx7.1.0=\"-Vgcc_ntox86_64_cxx\" \\\n-    CXX_x86_64-pc-nto-qnx7.1.0=\"qcc\" \\\n-    AR_x86_64_pc_nto_qnx7.1.0=\"ntox86_64-ar\" \\\n-        ./x.py build --target aarch64-unknown-nto-qnx7.1.0 --target x86_64-pc-nto-qnx7.1.0 --target x86_64-unknown-linux-gnu rustc library/core library/alloc/\n+    CC_aarch64-unknown-nto-qnx710=\"qcc\" \\\n+    CFLAGS_aarch64-unknown-nto-qnx710=\"-Vgcc_ntoaarch64le_cxx\" \\\n+    CXX_aarch64-unknown-nto-qnx710=\"qcc\" \\\n+    AR_aarch64_unknown_nto_qnx710=\"ntoaarch64-ar\" \\\n+    CC_x86_64-pc-nto-qnx710=\"qcc\" \\\n+    CFLAGS_x86_64-pc-nto-qnx710=\"-Vgcc_ntox86_64_cxx\" \\\n+    CXX_x86_64-pc-nto-qnx710=\"qcc\" \\\n+    AR_x86_64_pc_nto_qnx710=\"ntox86_64-ar\" \\\n+        ./x.py build --target aarch64-unknown-nto-qnx710 --target x86_64-pc-nto-qnx710 --target x86_64-unknown-linux-gnu rustc library/core library/alloc/\n ```\n \n ## Building Rust programs"}, {"sha": "95932db14e1f659ca86fd8dcbe5f02ad04940d24", "filename": "src/doc/rustc/src/target-tier-policy.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -158,6 +158,8 @@ approved by the appropriate team for that shared code before acceptance.\n     the name of the target makes people extremely likely to form incorrect\n     beliefs about what it targets, the name should be changed or augmented to\n     disambiguate it.\n+  - If possible, use only letters, numbers, dashes and underscores for the name.\n+    Periods (`.`) are known to cause issues in Cargo.\n - Tier 3 targets may have unusual requirements to build or use, but must not\n   create legal issues or impose onerous legal terms for the Rust project or for\n   Rust developers or users."}, {"sha": "de882e66f43de15d7fda79b4a1b912c8dd3986d9", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -1511,13 +1511,11 @@ details.rustdoc-toggle > summary.hideme > span {\n }\n \n details.rustdoc-toggle > summary::before {\n-\tbackground-image: url(\"toggle-plus-1092eb4930d581b0.svg\");\n+\tbackground: url(\"toggle-plus-1092eb4930d581b0.svg\") no-repeat top left;\n \tcontent: \"\";\n \tcursor: pointer;\n \twidth: 16px;\n \theight: 16px;\n-\tbackground-repeat: no-repeat;\n-\tbackground-position: top left;\n \tdisplay: inline-block;\n \tvertical-align: middle;\n \topacity: .5;\n@@ -1598,11 +1596,9 @@ details.rustdoc-toggle[open] > summary.hideme > span {\n \n details.rustdoc-toggle[open] > summary::before,\n details.rustdoc-toggle[open] > summary.hideme::before {\n-\tbackground-image: url(\"toggle-minus-31bbd6e4c77f5c96.svg\");\n+\tbackground: url(\"toggle-minus-31bbd6e4c77f5c96.svg\") no-repeat top left;\n \twidth: 16px;\n \theight: 16px;\n-\tbackground-repeat: no-repeat;\n-\tbackground-position: top left;\n \tdisplay: inline-block;\n \tcontent: \"\";\n }"}, {"sha": "8bafb95bc16d9e31a002f71fe0ed482f89166ecd", "filename": "src/test/codegen-units/item-collection/asm-sym.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fasm-sym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fasm-sym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fasm-sym.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -0,0 +1,20 @@\n+// needs-asm-support\n+// compile-flags: -Ccodegen-units=1 -Zprint-mono-items=lazy --crate-type=lib\n+\n+#[inline(always)]\n+pub unsafe fn f() {\n+    //~ MONO_ITEM static f::S @@ asm_sym-cgu.0[External]\n+    static S: usize = 1;\n+    //~ MONO_ITEM fn f::fun @@ asm_sym-cgu.0[External]\n+    fn fun() {}\n+    core::arch::asm!(\"/* {0} {1} */\", sym S, sym fun);\n+}\n+\n+//~ MONO_ITEM fn g @@ asm_sym-cgu.0[External]\n+pub unsafe fn g() {\n+    //~ MONO_ITEM static g::S @@ asm_sym-cgu.0[Internal]\n+    static S: usize = 2;\n+    //~ MONO_ITEM fn g::fun @@ asm_sym-cgu.0[Internal]\n+    fn fun() {}\n+    core::arch::asm!(\"/* {0} {1} */\", sym S, sym fun);\n+}"}, {"sha": "ee9bce15d3478e2e73c5b266a7d983f01383c5db", "filename": "src/test/ui/type-alias-impl-trait/imply_bounds_from_bounds.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Callable {\n+    type Output;\n+    fn call() -> Self::Output;\n+}\n+\n+impl<'a> Callable for &'a () {\n+    type Output = impl Sized;\n+    fn call() -> Self::Output {}\n+}\n+\n+fn test<'a>() -> impl Sized {\n+    <&'a () as Callable>::call()\n+}\n+\n+fn want_static<T: 'static>(_: T) {}\n+\n+fn test2<'a>() {\n+    want_static(<&'a () as Callable>::call());\n+}\n+\n+fn main() {}"}, {"sha": "ae21a9134a41662ced017662cb09323902481db4", "filename": "src/test/ui/type-alias-impl-trait/imply_bounds_from_bounds_param.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds_param.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -0,0 +1,38 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Callable {\n+    type Output;\n+    fn call(x: Self) -> Self::Output;\n+}\n+\n+trait PlusOne {\n+    fn plus_one(&mut self);\n+}\n+\n+impl<'a> PlusOne for &'a mut i32 {\n+    fn plus_one(&mut self) {\n+        **self += 1;\n+    }\n+}\n+\n+impl<T: PlusOne> Callable for T {\n+    type Output = impl PlusOne;\n+    fn call(t: T) -> Self::Output { t }\n+}\n+\n+fn test<'a>(y: &'a mut i32) -> impl PlusOne {\n+    <&'a mut i32 as Callable>::call(y)\n+    //~^ ERROR hidden type for `impl PlusOne` captures lifetime that does not appear in bounds\n+}\n+\n+fn main() {\n+    let mut z = 42;\n+    let mut thing = test(&mut z);\n+    let mut thing2 = test(&mut z);\n+    thing.plus_one();\n+    assert_eq!(z, 43);\n+    thing2.plus_one();\n+    assert_eq!(z, 44);\n+    thing.plus_one();\n+    assert_eq!(z, 45);\n+}"}, {"sha": "0ed8a703b6dc54cb8690a316b278e8f043315948", "filename": "src/test/ui/type-alias-impl-trait/imply_bounds_from_bounds_param.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimply_bounds_from_bounds_param.stderr?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -0,0 +1,16 @@\n+error[E0700]: hidden type for `impl PlusOne` captures lifetime that does not appear in bounds\n+  --> $DIR/imply_bounds_from_bounds_param.rs:24:5\n+   |\n+LL | fn test<'a>(y: &'a mut i32) -> impl PlusOne {\n+   |         -- hidden type `<&'a mut i32 as Callable>::Output` captures the lifetime `'a` as defined here\n+LL |     <&'a mut i32 as Callable>::call(y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: to declare that `impl PlusOne` captures `'a`, you can add an explicit `'a` lifetime bound\n+   |\n+LL | fn test<'a>(y: &'a mut i32) -> impl PlusOne + 'a {\n+   |                                             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "4e805ee308f4d9edb107019be39b995f5b414bcc", "filename": "src/test/ui/type-alias-impl-trait/self_implication.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself_implication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself_implication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself_implication.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -0,0 +1,38 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+fn foo() {\n+    struct Foo<'a> {\n+        x: &'a mut u8,\n+    }\n+    impl<'a> Foo<'a> {\n+        fn foo(&self) -> impl Sized {}\n+    }\n+    // use site\n+    let mut x = 5;\n+    let y = Foo { x: &mut x };\n+    let z = y.foo();\n+    let _a = &x; // invalidate the `&'a mut`in `y`\n+    let _b = z; // this should *not* check that `'a` in the type `Foo<'a>::foo::opaque` is live\n+}\n+\n+fn bar() {\n+    struct Foo<'a> {\n+        x: &'a mut u8,\n+    }\n+\n+    // desugared\n+    type FooX<'a> = impl Sized;\n+    impl<'a> Foo<'a> {\n+        fn foo(&self) -> FooX<'a> {}\n+    }\n+\n+    // use site\n+    let mut x = 5;\n+    let y = Foo { x: &mut x };\n+    let z = y.foo();\n+    let _a = &x; // invalidate the `&'a mut`in `y`\n+    let _b = z; // this should *not* check that `'a` in the type `Foo<'a>::foo::opaque` is live\n+}\n+\n+fn main() {}"}, {"sha": "c74d37c61e887bc3f30113490995c50c6bcb3700", "filename": "src/tools/tier-check/src/main.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftools%2Ftier-check%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82/src%2Ftools%2Ftier-check%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftier-check%2Fsrc%2Fmain.rs?ref=d38a99078cd3c4dadac1ba8b729ea77e8d1d5a82", "patch": "@@ -44,7 +44,23 @@ fn main() {\n             target, filename, src\n         );\n     }\n-    if !missing.is_empty() || !extra.is_empty() {\n+    // Check target names for unwanted characters like `.` that can cause problems e.g. in Cargo.\n+    // See also Tier 3 target policy.\n+    // If desired, target names can ignore this check.\n+    let ignore_target_names =\n+        vec![\"thumbv8m.base-none-eabi\", \"thumbv8m.main-none-eabi\", \"thumbv8m.main-none-eabihf\"];\n+    let mut invalid_target_name_found = false;\n+    for target in &target_list {\n+        if !ignore_target_names.contains(target)\n+            && !target.chars().all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')\n+        {\n+            invalid_target_name_found = true;\n+            eprintln!(\n+                \"error: Target name `{target}` contains other characters than ASCII alphanumeric (a-z, A-Z, 0-9), dash (-) or underscore (_).\"\n+            );\n+        }\n+    }\n+    if !missing.is_empty() || !extra.is_empty() || invalid_target_name_found {\n         std::process::exit(1);\n     }\n }"}]}