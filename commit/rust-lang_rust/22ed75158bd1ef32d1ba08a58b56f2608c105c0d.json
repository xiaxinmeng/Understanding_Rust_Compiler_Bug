{"sha": "22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZWQ3NTE1OGJkMWVmMzJkMWJhMDhhNThiNTZmMjYwOGMxMDVjMGQ=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-16T06:58:19Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-22T22:12:57Z"}, "message": "rustc_query_system: add more comments for dependency graph", "tree": {"sha": "926437e5004a701b397d1f033fb476b103179d5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/926437e5004a701b397d1f033fb476b103179d5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "html_url": "https://github.com/rust-lang/rust/commit/22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22ed75158bd1ef32d1ba08a58b56f2608c105c0d/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b2aaed7d67e0e24e9120830697196a847a0b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b2aaed7d67e0e24e9120830697196a847a0b43", "html_url": "https://github.com/rust-lang/rust/commit/d6b2aaed7d67e0e24e9120830697196a847a0b43"}], "stats": {"total": 34, "additions": 33, "deletions": 1}, "files": [{"sha": "8c7217dd32943a7bfe134715a32660bb3f50648f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/22ed75158bd1ef32d1ba08a58b56f2608c105c0d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22ed75158bd1ef32d1ba08a58b56f2608c105c0d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "patch": "@@ -136,16 +136,22 @@ impl<K: DepKind> DepGraph<K> {\n \n     pub fn query(&self) -> DepGraphQuery<K> {\n         // We call this before acquiring locks, since it also acquires them.\n+        // The extra locking is not a big deal, as this gets called rarely.\n         let edge_count = self.edge_count();\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n         let prev_index_to_index = data.current.prev_index_to_index.lock();\n         let data = data.current.data.lock();\n         let node_count = data.hybrid_indices.len();\n \n         let mut nodes = Vec::with_capacity(node_count);\n         let mut edge_list_indices = Vec::with_capacity(node_count);\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        // See `serialize` for notes on the approach used here.\n+\n         edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n \n         for &hybrid_index in data.hybrid_indices.iter() {\n@@ -285,6 +291,8 @@ impl<K: DepKind> DepGraph<K> {\n                             eprintln!(\"[task::green] {:?}\", key);\n                         }\n \n+                        // This is a light green node: it existed in the previous compilation,\n+                        // its query was re-executed, and it has the same result as before.\n                         let dep_node_index =\n                             data.current.intern_light_green_node(&data.previous, prev_index, edges);\n \n@@ -294,6 +302,8 @@ impl<K: DepKind> DepGraph<K> {\n                             eprintln!(\"[task::red] {:?}\", key);\n                         }\n \n+                        // This is a red node: it existed in the previous compilation, its query\n+                        // was re-executed, but it has a different result from before.\n                         let dep_node_index = data.current.intern_red_node(\n                             &data.previous,\n                             prev_index,\n@@ -308,14 +318,17 @@ impl<K: DepKind> DepGraph<K> {\n                         eprintln!(\"[task::unknown] {:?}\", key);\n                     }\n \n+                    // This is a red node, effectively: it existed in the previous compilation\n+                    // session, its query was re-executed, but it doesn't compute a result hash\n+                    // (i.e. it represents a `no_hash` query), so we have no way of determining\n+                    // whether or not the result was the same as before.\n                     let dep_node_index = data.current.intern_red_node(\n                         &data.previous,\n                         prev_index,\n                         edges,\n                         Fingerprint::ZERO,\n                     );\n \n-                    // Mark the node as Red if we can't hash the result\n                     (DepNodeColor::Red, dep_node_index)\n                 };\n \n@@ -333,6 +346,7 @@ impl<K: DepKind> DepGraph<K> {\n                     eprintln!(\"[task::new] {:?}\", key);\n                 }\n \n+                // This is a new node: it didn't exist in the previous compilation session.\n                 data.current.intern_new_node(\n                     &data.previous,\n                     key,\n@@ -343,6 +357,10 @@ impl<K: DepKind> DepGraph<K> {\n \n             (result, dep_node_index)\n         } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n             (task(cx, arg), self.next_virtual_depnode_index())\n         }\n     }\n@@ -568,9 +586,12 @@ impl<K: DepKind> DepGraph<K> {\n         type SDNI = SerializedDepNodeIndex;\n \n         // We call this before acquiring locks, since it also acquires them.\n+        // The extra locking is not a big deal, as this only gets called once.\n         let edge_count = self.edge_count();\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n+\n+        // Note locking order: `prev_index_to_index`, then `data`.\n         let prev_index_to_index = data.current.prev_index_to_index.lock();\n         let data = data.current.data.lock();\n         let node_count = data.hybrid_indices.len();\n@@ -579,6 +600,17 @@ impl<K: DepKind> DepGraph<K> {\n         let mut fingerprints = IndexVec::with_capacity(node_count);\n         let mut edge_list_indices = IndexVec::with_capacity(node_count);\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be in\n+        // `DepNodeIndex` order. The edges in `edge_list_data`, on the other\n+        // hand, don't need to be in a particular order, as long as each node\n+        // can reference its edges as a contiguous range within it. This is why\n+        // we're able to copy `unshared_edges` directly into `edge_list_data`.\n+        // It meets the above requirements, and each non-dark-green node already\n+        // knows the range of edges to reference within it, which they'll push\n+        // onto `edge_list_indices`. Dark green nodes, however, don't have their\n+        // edges in `unshared_edges`, so need to add them to `edge_list_data`.\n+\n         edge_list_data.extend(data.unshared_edges.iter().map(|i| SDNI::new(i.index())));\n \n         for &hybrid_index in data.hybrid_indices.iter() {"}]}