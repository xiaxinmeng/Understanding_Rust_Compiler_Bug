{"sha": "5a277822a536eff72d562e75fb6046add63d4926", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjc3ODIyYTUzNmVmZjcyZDU2MmU3NWZiNjA0NmFkZDYzZDQ5MjY=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-11T07:18:54Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-18T15:11:34Z"}, "message": "use newtype_index for abstract_const::NodeId", "tree": {"sha": "1296b0d1bdf5e1088c426c74570079746490a74a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1296b0d1bdf5e1088c426c74570079746490a74a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a277822a536eff72d562e75fb6046add63d4926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a277822a536eff72d562e75fb6046add63d4926", "html_url": "https://github.com/rust-lang/rust/commit/5a277822a536eff72d562e75fb6046add63d4926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a277822a536eff72d562e75fb6046add63d4926/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f24d532749674c41940120866937860c8d4abcc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f24d532749674c41940120866937860c8d4abcc8", "html_url": "https://github.com/rust-lang/rust/commit/f24d532749674c41940120866937860c8d4abcc8"}], "stats": {"total": 33, "additions": 17, "deletions": 16}, "files": [{"sha": "8d215c5a5215a551401e07cda896513ff1248527", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a277822a536eff72d562e75fb6046add63d4926/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a277822a536eff72d562e75fb6046add63d4926/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=5a277822a536eff72d562e75fb6046add63d4926", "patch": "@@ -2,8 +2,13 @@\n use crate::mir;\n use crate::ty;\n \n-/// An index into an `AbstractConst`.\n-pub type NodeId = usize;\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n \n /// A node of an `AbstractConst`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable)]"}, {"sha": "56886aae066693540d5798052850d39ea27cda91", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a277822a536eff72d562e75fb6046add63d4926/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a277822a536eff72d562e75fb6046add63d4926/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=5a277822a536eff72d562e75fb6046add63d4926", "patch": "@@ -95,8 +95,10 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n /// and should not leak any information about desugarings.\n #[derive(Clone, Copy)]\n pub struct AbstractConst<'tcx> {\n-    pub inner: &'tcx [Node<'tcx>],\n-    pub substs: SubstsRef<'tcx>,\n+    // FIXME: Consider adding something like `IndexSlice`\n+    // and use this here.\n+    inner: &'tcx [Node<'tcx>],\n+    substs: SubstsRef<'tcx>,\n }\n \n impl AbstractConst<'tcx> {\n@@ -117,7 +119,7 @@ impl AbstractConst<'tcx> {\n \n     #[inline]\n     pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n-        AbstractConst { inner: &self.inner[..=node], substs: self.substs }\n+        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n     }\n \n     #[inline]\n@@ -129,7 +131,7 @@ impl AbstractConst<'tcx> {\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n-    nodes: Vec<Node<'tcx>>,\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n     locals: IndexVec<mir::Local, NodeId>,\n     checked_op_locals: BitSet<mir::Local>,\n }\n@@ -143,18 +145,12 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Some(AbstractConstBuilder {\n             tcx,\n             body,\n-            nodes: vec![],\n+            nodes: IndexVec::new(),\n             locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n             checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n         })\n     }\n \n-    fn add_node(&mut self, n: Node<'tcx>) -> NodeId {\n-        let len = self.nodes.len();\n-        self.nodes.push(n);\n-        len\n-    }\n-\n     fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n         debug!(\"operand_to_node: op={:?}\", op);\n         const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n@@ -174,7 +170,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     None\n                 }\n             }\n-            mir::Operand::Constant(ct) => Some(self.add_node(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Some(self.nodes.push(Node::Leaf(ct.literal))),\n         }\n     }\n \n@@ -199,15 +195,15 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n                         let lhs = self.operand_to_node(lhs)?;\n                         let rhs = self.operand_to_node(rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n                         let lhs = self.operand_to_node(lhs)?;\n                         let rhs = self.operand_to_node(rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs));\n+                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         self.checked_op_locals.insert(local);\n                     }\n                     _ => return None,"}]}