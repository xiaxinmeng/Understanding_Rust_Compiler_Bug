{"sha": "74e5b7d96af721b98474f6d4982b5eb594cd022c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZTViN2Q5NmFmNzIxYjk4NDc0ZjZkNDk4MmI1ZWI1OTRjZDAyMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-05T13:05:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-05T13:05:30Z"}, "message": "Auto merge of #38152 - arielb1:special-copy, r=nikomatsakis\n\nFix associated types in copy implementations\n\nFixes an ICE and an error in checking copy implementations.\n\nr? @nikomatsakis", "tree": {"sha": "a43fc29e26dc47a80b0217ee7ec4f04a969ffe54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a43fc29e26dc47a80b0217ee7ec4f04a969ffe54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74e5b7d96af721b98474f6d4982b5eb594cd022c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74e5b7d96af721b98474f6d4982b5eb594cd022c", "html_url": "https://github.com/rust-lang/rust/commit/74e5b7d96af721b98474f6d4982b5eb594cd022c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74e5b7d96af721b98474f6d4982b5eb594cd022c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f56207b1283857de92537288893e8d428551a02", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f56207b1283857de92537288893e8d428551a02", "html_url": "https://github.com/rust-lang/rust/commit/2f56207b1283857de92537288893e8d428551a02"}, {"sha": "5fad51e7f42fc61d6e507dc3a17787534b4acbcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fad51e7f42fc61d6e507dc3a17787534b4acbcc", "html_url": "https://github.com/rust-lang/rust/commit/5fad51e7f42fc61d6e507dc3a17787534b4acbcc"}], "stats": {"total": 892, "additions": 455, "deletions": 437}, "files": [{"sha": "ed01b93f1335a3289c52e656ce105166b3e6b940", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -234,12 +234,10 @@ pub trait Unsize<T: ?Sized> {\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n-/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get a\n-/// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n-/// [E0205].\n+/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get\n+/// the error [E0204].\n ///\n /// [E0204]: ../../error-index.html#E0204\n-/// [E0205]: ../../error-index.html#E0205\n ///\n /// ## When *should* my type be `Copy`?\n ///"}, {"sha": "0b1030f74b0fdba305322b5eb87e57fd4e7cf1af", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -15,7 +15,7 @@ use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n use traits::{self, Reveal};\n-use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n@@ -120,9 +120,8 @@ impl IntTypeExt for attr::IntType {\n \n \n #[derive(Copy, Clone)]\n-pub enum CopyImplementationError {\n-    InfrigingField(Name),\n-    InfrigingVariant(Name),\n+pub enum CopyImplementationError<'tcx> {\n+    InfrigingField(&'tcx ty::FieldDef),\n     NotAnAdt,\n     HasDestructor\n }\n@@ -145,37 +144,30 @@ pub enum Representability {\n impl<'tcx> ParameterEnvironment<'tcx> {\n     pub fn can_type_implement_copy<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>, span: Span)\n-                                       -> Result<(),CopyImplementationError> {\n+                                       -> Result<(), CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(None, Some(self.clone()), Reveal::ExactMatch).enter(|infcx| {\n-            let adt = match self_type.sty {\n-                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        for field in adt.all_fields() {\n-                            let field_ty = field.ty(tcx, substs);\n-                            if infcx.type_moves_by_default(field_ty, span) {\n-                                return Err(CopyImplementationError::InfrigingField(\n-                                    field.name))\n-                            }\n-                        }\n-                        adt\n-                    }\n-                    AdtKind::Enum => {\n-                        for variant in &adt.variants {\n-                            for field in &variant.fields {\n-                                let field_ty = field.ty(tcx, substs);\n-                                if infcx.type_moves_by_default(field_ty, span) {\n-                                    return Err(CopyImplementationError::InfrigingVariant(\n-                                        variant.name))\n-                                }\n-                            }\n-                        }\n-                        adt\n-                    }\n-                },\n+        tcx.infer_ctxt(None, Some(self.clone()), Reveal::NotSpecializable).enter(|infcx| {\n+            let (adt, substs) = match self_type.sty {\n+                ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n             };\n \n+            let field_implements_copy = |field: &ty::FieldDef| {\n+                let cause = traits::ObligationCause::dummy();\n+                match traits::fully_normalize(&infcx, cause, &field.ty(tcx, substs)) {\n+                    Ok(ty) => !infcx.type_moves_by_default(ty, span),\n+                    Err(..) => false\n+                }\n+            };\n+\n+            for variant in &adt.variants {\n+                for field in &variant.fields {\n+                    if !field_implements_copy(field) {\n+                        return Err(CopyImplementationError::InfrigingField(field));\n+                    }\n+                }\n+            }\n+\n             if adt.has_dtor() {\n                 return Err(CopyImplementationError::HasDestructor);\n             }"}, {"sha": "ba95a17989165685724fa5e4a384a9dde48c125a", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -0,0 +1,349 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Check properties that are required by built-in traits and set\n+//! up data structures required by type-checking/translation.\n+\n+use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::lang_items::UnsizeTraitLangItem;\n+\n+use rustc::traits::{self, ObligationCause, Reveal};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::ParameterEnvironment;\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::util::CopyImplementationError;\n+use rustc::infer;\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map as hir_map;\n+use rustc::hir::{self, ItemImpl};\n+\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    check_trait(tcx, tcx.lang_items.drop_trait(), visit_implementation_of_drop);\n+    check_trait(tcx, tcx.lang_items.copy_trait(), visit_implementation_of_copy);\n+    check_trait(\n+        tcx,\n+        tcx.lang_items.coerce_unsized_trait(),\n+        visit_implementation_of_coerce_unsized);\n+}\n+\n+fn check_trait<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            trait_def_id: Option<DefId>,\n+                            mut f: F)\n+    where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId, DefId)\n+{\n+    if let Some(trait_def_id) = trait_def_id {\n+        let mut impls = vec![];\n+        tcx.lookup_trait_def(trait_def_id).for_each_impl(tcx, |did| {\n+            impls.push(did);\n+        });\n+        impls.sort();\n+        for impl_def_id in impls {\n+            f(tcx, trait_def_id, impl_def_id);\n+        }\n+    }\n+}\n+\n+fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          _drop_did: DefId,\n+                                          impl_did: DefId) {\n+    let items = tcx.associated_item_def_ids(impl_did);\n+    if items.is_empty() {\n+        // We'll error out later. For now, just don't ICE.\n+        return;\n+    }\n+    let method_def_id = items[0];\n+\n+    let self_type = tcx.item_type(impl_did);\n+    match self_type.sty {\n+        ty::TyAdt(type_def, _) => {\n+            type_def.set_destructor(method_def_id);\n+        }\n+        _ => {\n+            // Destructors only work on nominal types.\n+            if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n+                match tcx.map.find(impl_node_id) {\n+                    Some(hir_map::NodeItem(item)) => {\n+                        let span = match item.node {\n+                            ItemImpl(.., ref ty, _) => ty.span,\n+                            _ => item.span,\n+                        };\n+                        struct_span_err!(tcx.sess,\n+                                         span,\n+                                         E0120,\n+                                         \"the Drop trait may only be implemented on \\\n+                                         structures\")\n+                            .span_label(span, &format!(\"implementing Drop requires a struct\"))\n+                            .emit();\n+                    }\n+                    _ => {\n+                        bug!(\"didn't find impl in ast map\");\n+                    }\n+                }\n+            } else {\n+                bug!(\"found external impl of Drop trait on \\\n+                      something other than a struct\");\n+            }\n+        }\n+    }\n+}\n+\n+fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          _copy_did: DefId,\n+                                          impl_did: DefId) {\n+    debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n+\n+    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+        n\n+    } else {\n+        debug!(\"visit_implementation_of_copy(): impl not in this \\\n+                crate\");\n+        return;\n+    };\n+\n+    let self_type = tcx.item_type(impl_did);\n+    debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n+           self_type);\n+\n+    let span = tcx.map.span(impl_node_id);\n+    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+    let self_type = self_type.subst(tcx, &param_env.free_substs);\n+    assert!(!self_type.has_escaping_regions());\n+\n+    debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n+           self_type);\n+\n+    match param_env.can_type_implement_copy(tcx, self_type, span) {\n+        Ok(()) => {}\n+        Err(CopyImplementationError::InfrigingField(field)) => {\n+            let item = tcx.map.expect_item(impl_node_id);\n+            let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n+                tr.path.span\n+            } else {\n+                span\n+            };\n+\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0204,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(\n+                    tcx.def_span(field.did),\n+                    &\"this field does not implement `Copy`\")\n+                .emit()\n+        }\n+        Err(CopyImplementationError::NotAnAdt) => {\n+            let item = tcx.map.expect_item(impl_node_id);\n+            let span = if let ItemImpl(.., ref ty, _) = item.node {\n+                ty.span\n+            } else {\n+                span\n+            };\n+\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0206,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(span, &format!(\"type is not a structure or enumeration\"))\n+                .emit();\n+        }\n+        Err(CopyImplementationError::HasDestructor) => {\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0184,\n+                             \"the trait `Copy` may not be implemented for this type; the \\\n+                              type has a destructor\")\n+                .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                .emit();\n+        }\n+    }\n+}\n+\n+fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                    coerce_unsized_trait: DefId,\n+                                                    impl_did: DefId) {\n+    debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n+           impl_did);\n+\n+    let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+        Ok(id) => id,\n+        Err(err) => {\n+            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+        }\n+    };\n+\n+    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+        n\n+    } else {\n+        debug!(\"visit_implementation_of_coerce_unsized(): impl not \\\n+                in this crate\");\n+        return;\n+    };\n+\n+    let source = tcx.item_type(impl_did);\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let target = trait_ref.substs.type_at(1);\n+    debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n+           source,\n+           target);\n+\n+    let span = tcx.map.span(impl_node_id);\n+    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+    let source = source.subst(tcx, &param_env.free_substs);\n+    let target = target.subst(tcx, &param_env.free_substs);\n+    assert!(!source.has_escaping_regions());\n+\n+    debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\",\n+           source,\n+           target);\n+\n+    tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n+        let cause = ObligationCause::misc(span, impl_node_id);\n+        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n+                           mt_b: ty::TypeAndMut<'tcx>,\n+                           mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+            if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n+                infcx.report_mismatched_types(&cause,\n+                                             mk_ptr(mt_b.ty),\n+                                             target,\n+                                             ty::error::TypeError::Mutability)\n+                    .emit();\n+            }\n+            (mt_a.ty, mt_b.ty, unsize_trait, None)\n+        };\n+        let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+            (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n+\n+            (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+                infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+            }\n+\n+            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+            (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+            }\n+\n+            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n+                                                                          def_b.is_struct() => {\n+                if def_a != def_b {\n+                    let source_path = tcx.item_path_str(def_a.did);\n+                    let target_path = tcx.item_path_str(def_b.did);\n+                    span_err!(tcx.sess,\n+                              span,\n+                              E0377,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures with the same \\\n+                               definition; expected {}, found {}\",\n+                              source_path,\n+                              target_path);\n+                    return;\n+                }\n+\n+                let fields = &def_a.struct_variant().fields;\n+                let diff_fields = fields.iter()\n+                    .enumerate()\n+                    .filter_map(|(i, f)| {\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                        if tcx.item_type(f.did).is_phantom_data() {\n+                            // Ignore PhantomData fields\n+                            return None;\n+                        }\n+\n+                        // Ignore fields that aren't significantly changed\n+                        if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                            if ok.obligations.is_empty() {\n+                                return None;\n+                            }\n+                        }\n+\n+                        // Collect up all fields that were significantly changed\n+                        // i.e. those that contain T in coerce_unsized T -> U\n+                        Some((i, a, b))\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if diff_fields.is_empty() {\n+                    span_err!(tcx.sess,\n+                              span,\n+                              E0374,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures with one field \\\n+                               being coerced, none found\");\n+                    return;\n+                } else if diff_fields.len() > 1 {\n+                    let item = tcx.map.expect_item(impl_node_id);\n+                    let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n+                        t.path.span\n+                    } else {\n+                        tcx.map.span(impl_node_id)\n+                    };\n+\n+                    let mut err = struct_span_err!(tcx.sess,\n+                                                   span,\n+                                                   E0375,\n+                                                   \"implementing the trait \\\n+                                                    `CoerceUnsized` requires multiple \\\n+                                                    coercions\");\n+                    err.note(\"`CoerceUnsized` may only be implemented for \\\n+                              a coercion between structures with one field being coerced\");\n+                    err.note(&format!(\"currently, {} fields need coercions: {}\",\n+                                      diff_fields.len(),\n+                                      diff_fields.iter()\n+                                          .map(|&(i, a, b)| {\n+                                              format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                          })\n+                                          .collect::<Vec<_>>()\n+                                          .join(\", \")));\n+                    err.span_label(span, &format!(\"requires multiple coercions\"));\n+                    err.emit();\n+                    return;\n+                }\n+\n+                let (i, a, b) = diff_fields[0];\n+                let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+                (a, b, coerce_unsized_trait, Some(kind))\n+            }\n+\n+            _ => {\n+                span_err!(tcx.sess,\n+                          span,\n+                          E0376,\n+                          \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures\");\n+                return;\n+            }\n+        };\n+\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+        // Register an obligation for `A: Trait<B>`.\n+        let cause = traits::ObligationCause::misc(span, impl_node_id);\n+        let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+\n+        // Check that all transitive obligations are satisfied.\n+        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(&errors);\n+        }\n+\n+        // Finally, resolve all regions.\n+        let mut free_regions = FreeRegionMap::new();\n+        free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+            .caller_bounds);\n+        infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+\n+        if let Some(kind) = kind {\n+            tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+        }\n+    });\n+}"}, {"sha": "6cf752dd69fcadea7d82f05ab89999e0c817c87a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 18, "deletions": 384, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -16,45 +16,33 @@\n // mappings. That mapping code resides here.\n \n use hir::def_id::DefId;\n-use middle::lang_items::UnsizeTraitLangItem;\n-use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::traits::{self, ObligationCause, Reveal};\n-use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n-use rustc::ty::util::CopyImplementationError;\n-use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use rustc::infer::{self, InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n+mod builtin;\n mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    crate_context: &'a CrateCtxt<'a, 'gcx>,\n-    inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n+struct CoherenceChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceChecker<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n-            self.cc.check_implementation(item)\n+            self.check_implementation(item)\n         }\n     }\n \n@@ -65,15 +53,15 @@ impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx,\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n             TyAdt(def, _) => Some(def.did),\n \n             TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n \n-            TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n+            TyBox(_) => self.tcx.lang_items.owned_box(),\n \n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n             TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n@@ -89,36 +77,22 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check(&self) {\n+    fn check(&mut self) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_item_likes_in_krate(\n-            DepNode::CoherenceCheckImpl,\n-            &mut CoherenceCheckVisitor { cc: self });\n-\n-        // Populate the table of destructors. It might seem a bit strange to\n-        // do this here, but it's actually the most convenient place, since\n-        // the coherence tables contain the trait -> type mappings.\n-        self.populate_destructors();\n-\n-        // Check to make sure implementations of `Copy` are legal.\n-        self.check_implementations_of_copy();\n-\n-        // Check to make sure implementations of `CoerceUnsized` are legal\n-        // and collect the necessary information from them.\n-        self.check_implementations_of_coerce_unsized();\n+        self.tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, self);\n     }\n \n     fn check_implementation(&self, item: &Item) {\n-        let tcx = self.crate_context.tcx;\n+        let tcx = self.tcx;\n         let impl_did = tcx.map.local_def_id(item.id);\n         let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n                    item.name);\n@@ -129,9 +103,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             }\n \n-            enforce_trait_manually_implementable(self.crate_context.tcx,\n-                                                 item.span,\n-                                                 trait_ref.def_id);\n+            enforce_trait_manually_implementable(self.tcx, item.span, trait_ref.def_id);\n             self.add_trait_impl(trait_ref, impl_did);\n         } else {\n             // Skip inherent impls where the self type is an error\n@@ -150,348 +122,15 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n+        self.tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n     }\n \n-    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref,\n                impl_def_id);\n-        let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n-    }\n-\n-    // Destructors\n-    //\n-\n-    fn populate_destructors(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let drop_trait = match tcx.lang_items.drop_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n-        let drop_trait = tcx.lookup_trait_def(drop_trait);\n-\n-        drop_trait.for_each_impl(tcx, |impl_did| {\n-            let items = tcx.associated_item_def_ids(impl_did);\n-            if items.is_empty() {\n-                // We'll error out later. For now, just don't ICE.\n-                return;\n-            }\n-            let method_def_id = items[0];\n-\n-            let self_type = tcx.item_type(impl_did);\n-            match self_type.sty {\n-                ty::TyAdt(type_def, _) => {\n-                    type_def.set_destructor(method_def_id);\n-                }\n-                _ => {\n-                    // Destructors only work on nominal types.\n-                    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n-                        match tcx.map.find(impl_node_id) {\n-                            Some(hir_map::NodeItem(item)) => {\n-                                let span = match item.node {\n-                                    ItemImpl(.., ref ty, _) => ty.span,\n-                                    _ => item.span,\n-                                };\n-                                struct_span_err!(tcx.sess,\n-                                                 span,\n-                                                 E0120,\n-                                                 \"the Drop trait may only be implemented on \\\n-                                                  structures\")\n-                                    .span_label(span,\n-                                                &format!(\"implementing Drop requires a struct\"))\n-                                    .emit();\n-                            }\n-                            _ => {\n-                                bug!(\"didn't find impl in ast map\");\n-                            }\n-                        }\n-                    } else {\n-                        bug!(\"found external impl of Drop trait on \\\n-                              something other than a struct\");\n-                    }\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Ensures that implementations of the built-in trait `Copy` are legal.\n-    fn check_implementations_of_copy(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let copy_trait = match tcx.lang_items.copy_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n-        let copy_trait = tcx.lookup_trait_def(copy_trait);\n-\n-        copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n-\n-            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-                n\n-            } else {\n-                debug!(\"check_implementations_of_copy(): impl not in this \\\n-                        crate\");\n-                return;\n-            };\n-\n-            let self_type = tcx.item_type(impl_did);\n-            debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n-                   self_type);\n-\n-            let span = tcx.map.span(impl_node_id);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let self_type = self_type.subst(tcx, &param_env.free_substs);\n-            assert!(!self_type.has_escaping_regions());\n-\n-            debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n-                   self_type);\n-\n-            match param_env.can_type_implement_copy(tcx, self_type, span) {\n-                Ok(()) => {}\n-                Err(CopyImplementationError::InfrigingField(name)) => {\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0204,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n-                        .emit()\n-                }\n-                Err(CopyImplementationError::InfrigingVariant(name)) => {\n-                    let item = tcx.map.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n-                        tr.path.span\n-                    } else {\n-                        span\n-                    };\n-\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0205,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span,\n-                                    &format!(\"variant `{}` does not implement `Copy`\", name))\n-                        .emit()\n-                }\n-                Err(CopyImplementationError::NotAnAdt) => {\n-                    let item = tcx.map.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., ref ty, _) = item.node {\n-                        ty.span\n-                    } else {\n-                        span\n-                    };\n-\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0206,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"type is not a structure or enumeration\"))\n-                        .emit();\n-                }\n-                Err(CopyImplementationError::HasDestructor) => {\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0184,\n-                                     \"the trait `Copy` may not be implemented for this type; the \\\n-                                      type has a destructor\")\n-                        .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n-                        .emit();\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Process implementations of the built-in trait `CoerceUnsized`.\n-    fn check_implementations_of_coerce_unsized(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n-            Ok(id) => id,\n-            Err(err) => {\n-                tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n-            }\n-        };\n-\n-        let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n-\n-        trait_def.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n-                   impl_did);\n-\n-            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-                n\n-            } else {\n-                debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n-                        in this crate\");\n-                return;\n-            };\n-\n-            let source = tcx.item_type(impl_did);\n-            let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = trait_ref.substs.type_at(1);\n-            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n-                   source,\n-                   target);\n-\n-            let span = tcx.map.span(impl_node_id);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let source = source.subst(tcx, &param_env.free_substs);\n-            let target = target.subst(tcx, &param_env.free_substs);\n-            assert!(!source.has_escaping_regions());\n-\n-            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n-                   source,\n-                   target);\n-\n-            tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n-                let cause = ObligationCause::misc(span, impl_node_id);\n-                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n-                                   mt_b: ty::TypeAndMut<'gcx>,\n-                                   mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n-                    if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(&cause,\n-                                                      mk_ptr(mt_b.ty),\n-                                                      target,\n-                                                      ty::error::TypeError::Mutability).emit();\n-                    }\n-                    (mt_a.ty, mt_b.ty, unsize_trait, None)\n-                };\n-                let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-                    (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n-\n-                    (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                        infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-                    }\n-\n-                    (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n-                    (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n-                    }\n-\n-                    (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n-                        if def_a.is_struct() && def_b.is_struct() => {\n-                        if def_a != def_b {\n-                            let source_path = tcx.item_path_str(def_a.did);\n-                            let target_path = tcx.item_path_str(def_b.did);\n-                            span_err!(tcx.sess,\n-                                      span,\n-                                      E0377,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with the same \\\n-                                       definition; expected {}, found {}\",\n-                                      source_path,\n-                                      target_path);\n-                            return;\n-                        }\n-\n-                        let fields = &def_a.struct_variant().fields;\n-                        let diff_fields = fields.iter()\n-                            .enumerate()\n-                            .filter_map(|(i, f)| {\n-                                let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                                if tcx.item_type(f.did).is_phantom_data() {\n-                                    // Ignore PhantomData fields\n-                                    return None;\n-                                }\n-\n-                                // Ignore fields that aren't significantly changed\n-                                if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n-                                    if ok.obligations.is_empty() {\n-                                        return None;\n-                                    }\n-                                }\n-\n-                                // Collect up all fields that were significantly changed\n-                                // i.e. those that contain T in coerce_unsized T -> U\n-                                Some((i, a, b))\n-                            })\n-                            .collect::<Vec<_>>();\n-\n-                        if diff_fields.is_empty() {\n-                            span_err!(tcx.sess,\n-                                      span,\n-                                      E0374,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with one field \\\n-                                       being coerced, none found\");\n-                            return;\n-                        } else if diff_fields.len() > 1 {\n-                            let item = tcx.map.expect_item(impl_node_id);\n-                            let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n-                                t.path.span\n-                            } else {\n-                                tcx.map.span(impl_node_id)\n-                            };\n-\n-                            let mut err = struct_span_err!(tcx.sess,\n-                                                           span,\n-                                                           E0375,\n-                                                           \"implementing the trait \\\n-                                                            `CoerceUnsized` requires multiple \\\n-                                                            coercions\");\n-                            err.note(\"`CoerceUnsized` may only be implemented for \\\n-                                      a coercion between structures with one field being coerced\");\n-                            err.note(&format!(\"currently, {} fields need coercions: {}\",\n-                                              diff_fields.len(),\n-                                              diff_fields.iter()\n-                                                  .map(|&(i, a, b)| {\n-                                                      format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                                  })\n-                                                  .collect::<Vec<_>>()\n-                                                  .join(\", \")));\n-                            err.span_label(span, &format!(\"requires multiple coercions\"));\n-                            err.emit();\n-                            return;\n-                        }\n-\n-                        let (i, a, b) = diff_fields[0];\n-                        let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                        (a, b, coerce_unsized_trait, Some(kind))\n-                    }\n-\n-                    _ => {\n-                        span_err!(tcx.sess,\n-                                  span,\n-                                  E0376,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures\");\n-                        return;\n-                    }\n-                };\n-\n-                let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-                // Register an obligation for `A: Trait<B>`.\n-                let cause = traits::ObligationCause::misc(span, impl_node_id);\n-                let predicate =\n-                    tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-\n-                // Check that all transitive obligations are satisfied.\n-                if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&errors);\n-                }\n-\n-                // Finally, resolve all regions.\n-                let mut free_regions = FreeRegionMap::new();\n-                free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n-                    .caller_bounds);\n-                infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n-\n-                if let Some(kind) = kind {\n-                    tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n-                }\n-            });\n-        });\n+        let trait_def = self.tcx.lookup_trait_def(impl_trait_ref.def_id);\n+        trait_def.record_local_impl(self.tcx, impl_def_id, impl_trait_ref);\n     }\n }\n \n@@ -524,14 +163,9 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    ccx.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n-        CoherenceChecker {\n-                crate_context: ccx,\n-                inference_context: infcx,\n-            }\n-            .check();\n-    });\n+    CoherenceChecker { tcx: ccx.tcx }.check();\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);\n     overlap::check(ccx.tcx);\n+    builtin::check(ccx.tcx);\n }"}, {"sha": "1a971be64d81923d528313df3b01b0d892c7f251", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -2300,6 +2300,7 @@ This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n \n+/*\n E0205: r##\"\n An attempt to implement the `Copy` trait for an enum failed because one of the\n variants does not implement `Copy`. To fix this, you must implement `Copy` for\n@@ -2329,6 +2330,7 @@ enum Foo<'a> {\n This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n+*/\n \n E0206: r##\"\n You can only implement `Copy` for a struct or enum. Both of the following"}, {"sha": "477112ab3c5ab289585c5433e6fb1d5a0d52f866", "filename": "src/test/run-pass/issue-33187.rs", "status": "renamed", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Ftest%2Frun-pass%2Fissue-33187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Ftest%2Frun-pass%2Fissue-33187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-33187.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -8,22 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo {\n-    Bar(Vec<u32>),\n-    Baz,\n+struct Foo<A: Repr>(<A as Repr>::Data);\n+\n+impl<A> Copy for Foo<A> where <A as Repr>::Data: Copy { }\n+impl<A> Clone for Foo<A> where <A as Repr>::Data: Clone {\n+    fn clone(&self) -> Self { Foo(self.0.clone()) }\n }\n \n-impl Copy for Foo { }\n-//~^ ERROR the trait `Copy` may not be implemented for this type\n-//~| NOTE variant `Bar` does not implement `Copy`\n+trait Repr {\n+    type Data;\n+}\n \n-#[derive(Copy)]\n-//~^ ERROR the trait `Copy` may not be implemented for this type\n-//~| NOTE variant `Bar` does not implement `Copy`\n-//~| NOTE in this expansion of #[derive(Copy)]\n-enum Foo2<'a> {\n-    Bar(&'a mut bool),\n-    Baz,\n+impl<A> Repr for A {\n+    type Data = u32;\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/E0205.rs"}, {"sha": "9fb37607c7da7a1ac5cbbb5ea796e73a9ff7572c", "filename": "src/test/ui/span/E0204.rs", "status": "renamed", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Ftest%2Fui%2Fspan%2FE0204.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Ftest%2Fui%2Fspan%2FE0204.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0204.rs?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -13,16 +13,24 @@ struct Foo {\n }\n \n impl Copy for Foo { }\n-//~^ ERROR E0204\n-//~| NOTE field `foo` does not implement `Copy`\n \n #[derive(Copy)]\n-//~^ ERROR E0204\n-//~| NOTE field `ty` does not implement `Copy`\n-//~| NOTE in this expansion of #[derive(Copy)]\n struct Foo2<'a> {\n     ty: &'a mut bool,\n }\n \n+enum EFoo {\n+    Bar { x: Vec<u32> },\n+    Baz,\n+}\n+\n+impl Copy for EFoo { }\n+\n+#[derive(Copy)]\n+enum EFoo2<'a> {\n+    Bar(&'a mut bool),\n+    Baz,\n+}\n+\n fn main() {\n }", "previous_filename": "src/test/compile-fail/E0204.rs"}, {"sha": "81a60a9dd3099ad0aedfb3d4014788f8f77fc49f", "filename": "src/test/ui/span/E0204.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e5b7d96af721b98474f6d4982b5eb594cd022c/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0204.stderr?ref=74e5b7d96af721b98474f6d4982b5eb594cd022c", "patch": "@@ -0,0 +1,38 @@\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/E0204.rs:15:6\n+   |\n+12 |     foo: Vec<u32>,\n+   |     ------------- this field does not implement `Copy`\n+...\n+15 | impl Copy for Foo { }\n+   |      ^^^^\n+\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/E0204.rs:27:6\n+   |\n+23 |     Bar { x: Vec<u32> },\n+   |           ----------- this field does not implement `Copy`\n+...\n+27 | impl Copy for EFoo { }\n+   |      ^^^^\n+\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/E0204.rs:17:10\n+   |\n+17 | #[derive(Copy)]\n+   |          ^^^^\n+18 | struct Foo2<'a> {\n+19 |     ty: &'a mut bool,\n+   |     ---------------- this field does not implement `Copy`\n+\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/E0204.rs:29:10\n+   |\n+29 | #[derive(Copy)]\n+   |          ^^^^\n+30 | enum EFoo2<'a> {\n+31 |     Bar(&'a mut bool),\n+   |         ------------- this field does not implement `Copy`\n+\n+error: aborting due to 4 previous errors\n+"}]}