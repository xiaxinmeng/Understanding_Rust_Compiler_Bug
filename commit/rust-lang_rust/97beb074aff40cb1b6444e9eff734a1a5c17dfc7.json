{"sha": "97beb074aff40cb1b6444e9eff734a1a5c17dfc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YmViMDc0YWZmNDBjYjFiNjQ0NGU5ZWZmNzM0YTFhNWMxN2RmYzc=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-03T13:44:19Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-05T11:23:38Z"}, "message": "BTreeMap: derive type-specific variants of node_as_mut and cast_unchecked", "tree": {"sha": "19a59859e4be9abfe83dbe36cc250f9922066630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19a59859e4be9abfe83dbe36cc250f9922066630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97beb074aff40cb1b6444e9eff734a1a5c17dfc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97beb074aff40cb1b6444e9eff734a1a5c17dfc7", "html_url": "https://github.com/rust-lang/rust/commit/97beb074aff40cb1b6444e9eff734a1a5c17dfc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97beb074aff40cb1b6444e9eff734a1a5c17dfc7/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efbaa413061c2a6e52f06f00a60ee7830fcf3ea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5", "html_url": "https://github.com/rust-lang/rust/commit/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5"}], "stats": {"total": 52, "additions": 28, "deletions": 24}, "files": [{"sha": "4fa97ff053e6011f862e293f3fa22b70b6d019c2", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/97beb074aff40cb1b6444e9eff734a1a5c17dfc7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97beb074aff40cb1b6444e9eff734a1a5c17dfc7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=97beb074aff40cb1b6444e9eff734a1a5c17dfc7", "patch": "@@ -170,6 +170,22 @@ impl<K, V> Root<K, V> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n+    /// Borrows and returns a mutable reference to the leaf node owned by the root.\n+    /// # Safety\n+    /// The root node is a leaf.\n+    unsafe fn leaf_node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Leaf> {\n+        debug_assert!(self.height == 0);\n+        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+    }\n+\n+    /// Borrows and returns a mutable reference to the internal node owned by the root.\n+    /// # Safety\n+    /// The root node is not a leaf.\n+    unsafe fn internal_node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+        debug_assert!(self.height > 0);\n+        NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n+    }\n+\n     pub fn node_as_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n@@ -188,14 +204,11 @@ impl<K, V> Root<K, V> {\n         self.node = BoxedNode::from_internal(new_node);\n         self.height += 1;\n \n-        let mut ret =\n-            NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData };\n-\n         unsafe {\n+            let mut ret = self.internal_node_as_mut();\n             ret.reborrow_mut().first_edge().correct_parent_link();\n+            ret\n         }\n-\n-        ret\n     }\n \n     /// Removes the internal root node, using its first child as the new root node.\n@@ -212,11 +225,8 @@ impl<K, V> Root<K, V> {\n \n         let top = self.node.ptr;\n \n-        self.node = unsafe {\n-            BoxedNode::from_ptr(\n-                self.node_as_mut().cast_unchecked::<marker::Internal>().first_edge().descend().node,\n-            )\n-        };\n+        let internal_node = unsafe { self.internal_node_as_mut() };\n+        self.node = unsafe { BoxedNode::from_ptr(internal_node.first_edge().descend().node) };\n         self.height -= 1;\n         self.node_as_mut().as_leaf_mut().parent = None;\n \n@@ -443,9 +453,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n }\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Unsafely asserts to the compiler some static information about whether this\n-    /// node is a `Leaf` or an `Internal`.\n-    unsafe fn cast_unchecked<NewType>(self) -> NodeRef<marker::Mut<'a>, K, V, NewType> {\n+    /// Unsafely asserts to the compiler the static information that this node is an `Internal`.\n+    unsafe fn cast_to_internal_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+        debug_assert!(self.height > 0);\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n@@ -943,10 +953,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n                     Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n                 InsertionPlace::Right(insert_idx) => unsafe {\n-                    Handle::new_edge(\n-                        right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n-                        insert_idx,\n-                    )\n+                    Handle::new_edge(right.leaf_node_as_mut(), insert_idx)\n                 },\n             };\n             let val_ptr = insertion_edge.insert_fit(key, val);\n@@ -1006,10 +1013,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n                 InsertionPlace::Right(insert_idx) => unsafe {\n-                    Handle::new_edge(\n-                        right.node_as_mut().cast_unchecked::<marker::Internal>(),\n-                        insert_idx,\n-                    )\n+                    Handle::new_edge(right.internal_node_as_mut(), insert_idx)\n                 },\n             };\n             insertion_edge.insert_fit(key, val, edge);\n@@ -1205,7 +1209,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n \n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n-            new_root.node_as_mut().cast_unchecked().correct_childrens_parent_links(0..=new_len);\n+            new_root.internal_node_as_mut().correct_childrens_parent_links(0..=new_len);\n \n             (self.node, k, v, new_root)\n         }\n@@ -1258,8 +1262,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             if self.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n-                let mut left_node = left_node.cast_unchecked::<marker::Internal>();\n-                let right_node = right_node.cast_unchecked::<marker::Internal>();\n+                let mut left_node = left_node.cast_to_internal_unchecked();\n+                let right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n                     right_node.edge_at(0),\n                     left_node.edges_mut().as_mut_ptr().add(left_len + 1),"}]}