{"sha": "dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZjNkYjQ3YzczODJkMDU0MGE4MWYwMWJkMDkxNWY1YzdhNmU0MTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-13T04:19:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-13T04:19:26Z"}, "message": "Auto merge of #46616 - cramertj:impl-trait-elision, r=nikomatsakis\n\nImplement impl Trait lifetime elision\n\nFixes #43396.\n\nThere's one weird ICE in the interaction with argument-position `impl Trait`. I'm still debugging it-- I've left a test for it commented out with a FIXME.\n\nAlso included a FIXME to ensure that `impl Trait` traits are caught under the lint in https://github.com/rust-lang/rust/issues/45992.\n\nr? @nikomatsakis", "tree": {"sha": "d00aea19cc0ea6fa13fdccc6f89b84bd9a02ac8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d00aea19cc0ea6fa13fdccc6f89b84bd9a02ac8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "html_url": "https://github.com/rust-lang/rust/commit/dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "691f022767aa5dec36635ab17bb767d5a80407db", "url": "https://api.github.com/repos/rust-lang/rust/commits/691f022767aa5dec36635ab17bb767d5a80407db", "html_url": "https://github.com/rust-lang/rust/commit/691f022767aa5dec36635ab17bb767d5a80407db"}, {"sha": "018c4038c79820e418e600df64cf36a88712652b", "url": "https://api.github.com/repos/rust-lang/rust/commits/018c4038c79820e418e600df64cf36a88712652b", "html_url": "https://github.com/rust-lang/rust/commit/018c4038c79820e418e600df64cf36a88712652b"}], "stats": {"total": 191, "additions": 135, "deletions": 56}, "files": [{"sha": "de69fad6dd7edb48e8d61093af52a554b34abf35", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "patch": "@@ -990,8 +990,9 @@ impl<'a> LoweringContext<'a> {\n         struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n-            currently_bound_lifetimes: Vec<Name>,\n-            already_defined_lifetimes: HashSet<Name>,\n+            collect_elided_lifetimes: bool,\n+            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n+            already_defined_lifetimes: HashSet<hir::LifetimeName>,\n             output_lifetimes: Vec<hir::Lifetime>,\n             output_lifetime_defs: Vec<hir::LifetimeDef>,\n         }\n@@ -1002,6 +1003,30 @@ impl<'a> LoweringContext<'a> {\n                 hir::intravisit::NestedVisitorMap::None\n             }\n \n+            fn visit_path_parameters(&mut self, span: Span, parameters: &'v hir::PathParameters) {\n+                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n+                if parameters.parenthesized {\n+                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                    self.collect_elided_lifetimes = false;\n+                    hir::intravisit::walk_path_parameters(self, span, parameters);\n+                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+                } else {\n+                    hir::intravisit::walk_path_parameters(self, span, parameters);\n+                }\n+            }\n+\n+            fn visit_ty(&mut self, t: &'v hir::Ty) {\n+                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                if let &hir::Ty_::TyBareFn(_) = &t.node {\n+                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                    self.collect_elided_lifetimes = false;\n+                    hir::intravisit::walk_ty(self, t);\n+                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+                } else {\n+                    hir::intravisit::walk_ty(self, t);\n+                }\n+            }\n+\n             fn visit_poly_trait_ref(&mut self,\n                                     polytr: &'v hir::PolyTraitRef,\n                                     _: hir::TraitBoundModifier) {\n@@ -1010,10 +1035,8 @@ impl<'a> LoweringContext<'a> {\n                 // Record the introduction of 'a in `for<'a> ...`\n                 for lt_def in &polytr.bound_lifetimes {\n                     // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd> ...`\n-                    if let hir::LifetimeName::Name(name) = lt_def.lifetime.name {\n-                        self.currently_bound_lifetimes.push(name);\n-                    }\n+                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                    self.currently_bound_lifetimes.push(lt_def.lifetime.name);\n \n                     // Visit the lifetime bounds\n                     for lt_bound in &lt_def.bounds {\n@@ -1027,47 +1050,58 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-                // Exclude '_, 'static, and elided lifetimes (there should be no elided lifetimes)\n-                if let hir::LifetimeName::Name(lifetime_name) = lifetime.name {\n-                    if !self.currently_bound_lifetimes.contains(&lifetime_name) &&\n-                       !self.already_defined_lifetimes.contains(&lifetime_name)\n-                    {\n-                        self.already_defined_lifetimes.insert(lifetime_name);\n-                        let name = hir::LifetimeName::Name(lifetime_name);\n-\n-                        self.output_lifetimes.push(hir::Lifetime {\n-                            id: self.context.next_id().node_id,\n-                            span: lifetime.span,\n-                            name,\n-                        });\n+                let name = match lifetime.name {\n+                    hir::LifetimeName::Implicit |\n+                    hir::LifetimeName::Underscore =>\n+                        if self.collect_elided_lifetimes {\n+                            // Use `'_` for both implicit and underscore lifetimes in\n+                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n+                            hir::LifetimeName::Underscore\n+                        } else {\n+                            return\n+                        }\n+                    name @ hir::LifetimeName::Name(_) => name,\n+                    hir::LifetimeName::Static => return,\n+                };\n \n-                        let def_node_id = self.context.next_id().node_id;\n-                        self.context.resolver.definitions().create_def_with_parent(\n-                            self.parent,\n-                            def_node_id,\n-                            DefPathData::LifetimeDef(lifetime_name.as_str()),\n-                            DefIndexAddressSpace::High,\n-                            Mark::root()\n-                        );\n-                        let def_lifetime = hir::Lifetime {\n-                            id: def_node_id,\n-                            span: lifetime.span,\n-                            name,\n-                        };\n-                        self.output_lifetime_defs.push(hir::LifetimeDef {\n-                            lifetime: def_lifetime,\n-                            bounds: Vec::new().into(),\n-                            pure_wrt_drop: false,\n-                            in_band: false,\n-                        });\n-                    }\n+                if !self.currently_bound_lifetimes.contains(&name) &&\n+                   !self.already_defined_lifetimes.contains(&name)\n+                {\n+                    self.already_defined_lifetimes.insert(name);\n+\n+                    self.output_lifetimes.push(hir::Lifetime {\n+                        id: self.context.next_id().node_id,\n+                        span: lifetime.span,\n+                        name,\n+                    });\n+\n+                    let def_node_id = self.context.next_id().node_id;\n+                    self.context.resolver.definitions().create_def_with_parent(\n+                        self.parent,\n+                        def_node_id,\n+                        DefPathData::LifetimeDef(name.name().as_str()),\n+                        DefIndexAddressSpace::High,\n+                        Mark::root()\n+                    );\n+                    let def_lifetime = hir::Lifetime {\n+                        id: def_node_id,\n+                        span: lifetime.span,\n+                        name: name,\n+                    };\n+                    self.output_lifetime_defs.push(hir::LifetimeDef {\n+                        lifetime: def_lifetime,\n+                        bounds: Vec::new().into(),\n+                        pure_wrt_drop: false,\n+                        in_band: false,\n+                    });\n                 }\n             }\n         }\n \n         let mut lifetime_collector = ImplTraitLifetimeCollector {\n             context: self,\n             parent: parent_index,\n+            collect_elided_lifetimes: true,\n             currently_bound_lifetimes: Vec::new(),\n             already_defined_lifetimes: HashSet::new(),\n             output_lifetimes: Vec::new(),"}, {"sha": "d9b2bf62841f10dd83cf5aaea0370d6b6a69d999", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "patch": "@@ -600,24 +600,45 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } = *exist_ty;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .lifetimes\n-                    .iter()\n-                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n-                    .collect();\n \n-                let next_early_index = index + generics.ty_params.len() as u32;\n-                let scope = Scope::Binder {\n-                    lifetimes,\n-                    next_early_index,\n-                    s: self.scope,\n-                };\n-                self.with(scope, |_old_scope, this| {\n-                    this.visit_generics(generics);\n-                    for bound in bounds {\n-                        this.visit_ty_param_bound(bound);\n+                let mut elision = None;\n+                let mut lifetimes = FxHashMap();\n+                for lt_def in &generics.lifetimes {\n+                    let (lt_name, region) = Region::early(&self.tcx.hir, &mut index, &lt_def);\n+                    if let hir::LifetimeName::Underscore = lt_name {\n+                        // Pick the elided lifetime \"definition\" if one exists and use it to make an\n+                        // elision scope.\n+                        elision = Some(region);\n+                    } else {\n+                        lifetimes.insert(lt_name, region);\n                     }\n-                });\n+                }\n+\n+                let next_early_index = index + generics.ty_params.len() as u32;\n+\n+                if let Some(elision_region) = elision {\n+                    let scope = Scope::Elision {\n+                        elide: Elide::Exact(elision_region),\n+                        s: self.scope\n+                    };\n+                    self.with(scope, |_old_scope, this| {\n+                        let scope = Scope::Binder { lifetimes, next_early_index, s: this.scope };\n+                        this.with(scope, |_old_scope, this| {\n+                            this.visit_generics(generics);\n+                            for bound in bounds {\n+                                this.visit_ty_param_bound(bound);\n+                            }\n+                        });\n+                    });\n+                } else {\n+                    let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                    self.with(scope, |_old_scope, this| {\n+                        this.visit_generics(generics);\n+                        for bound in bounds {\n+                            this.visit_ty_param_bound(bound);\n+                        }\n+                    });\n+                }\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }"}, {"sha": "0f2f67fd89a12baf7965e0b383296cebca1139e2", "filename": "src/test/run-pass/impl-trait/lifetimes.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf3db47c7382d0540a81f01bd0915f5c7a6e411/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs?ref=dcf3db47c7382d0540a81f01bd0915f5c7a6e411", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(conservative_impl_trait)]\n+#![feature(conservative_impl_trait, underscore_lifetimes, universal_impl_trait)]\n #![allow(warnings)]\n \n use std::fmt::Debug;\n@@ -32,12 +32,36 @@ fn no_params_or_lifetimes_is_static() -> impl Debug + 'static {\n fn static_input_type_is_static<T: Debug + 'static>(x: T) -> impl Debug + 'static { x }\n \n fn type_outlives_reference_lifetime<'a, T: Debug>(x: &'a T) -> impl Debug + 'a { x }\n+fn type_outlives_reference_lifetime_elided<T: Debug>(x: &T) -> impl Debug + '_ { x }\n \n trait SingleRegionTrait<'a> {}\n impl<'a> SingleRegionTrait<'a> for u32 {}\n+impl<'a> SingleRegionTrait<'a> for &'a u32 {}\n+struct SingleRegionStruct<'a>(&'a u32);\n \n fn simple_type_hrtb<'b>() -> impl for<'a> SingleRegionTrait<'a> { 5 }\n+// FIXME(cramertj) add test after #45992 lands to ensure lint is triggered\n+fn elision_single_region_trait(x: &u32) -> impl SingleRegionTrait { x }\n+fn elision_single_region_struct(x: SingleRegionStruct) -> impl Into<SingleRegionStruct> { x }\n+\n fn closure_hrtb() -> impl for<'a> Fn(&'a u32) { |_| () }\n+fn closure_hr_elided() -> impl Fn(&u32) { |_| () }\n+fn closure_hr_elided_return() -> impl Fn(&u32) -> &u32 { |x| x }\n+fn closure_pass_through_elided_return(x: impl Fn(&u32) -> &u32) -> impl Fn(&u32) -> &u32 { x }\n+fn closure_pass_through_reference_elided(x: &impl Fn(&u32) -> &u32) -> &impl Fn(&u32) -> &u32 { x }\n+\n+fn pass_through_elision(x: &u32) -> impl Into<&u32> { x }\n+fn pass_through_elision_with_fn_ptr(x: &fn(&u32) -> &u32) -> impl Into<&fn(&u32) -> &u32> { x }\n+\n+fn pass_through_elision_with_fn_path<T: Fn(&u32) -> &u32>(\n+    x: &T\n+) -> impl Into<&impl Fn(&u32) -> &u32> { x }\n+\n+// FIXME(cramertj) Currently ICEing, part of issue #46685:\n+// fn foo(x: &impl Debug) -> impl Into<&impl Debug> { x }\n+// Works:\n+fn foo_no_outer_impl(x: &impl Debug) -> &impl Debug { x }\n+fn foo_explicit_arg<T: Debug>(x: &T) -> impl Into<&impl Debug> { x }\n \n fn mixed_lifetimes<'a>() -> impl for<'b: 'a> Fn(&'b u32) { |_| () }\n fn mixed_as_static() -> impl Fn(&'static u32) { mixed_lifetimes() }"}]}