{"sha": "522f66545ffe709527dc2102aefe738ffe9ecc17", "node_id": "C_kwDOAAsO6NoAKDUyMmY2NjU0NWZmZTcwOTUyN2RjMjEwMmFlZmU3MzhmZmU5ZWNjMTc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-03T14:25:37Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-03T14:25:37Z"}, "message": "Remove prev-sibling completion machinery", "tree": {"sha": "061a7575165e6bbf8f5d35b7889b3aedd6114429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061a7575165e6bbf8f5d35b7889b3aedd6114429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/522f66545ffe709527dc2102aefe738ffe9ecc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/522f66545ffe709527dc2102aefe738ffe9ecc17", "html_url": "https://github.com/rust-lang/rust/commit/522f66545ffe709527dc2102aefe738ffe9ecc17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/522f66545ffe709527dc2102aefe738ffe9ecc17/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6550a241fb370d21c8a3fc31053ceb823628d42e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6550a241fb370d21c8a3fc31053ceb823628d42e", "html_url": "https://github.com/rust-lang/rust/commit/6550a241fb370d21c8a3fc31053ceb823628d42e"}], "stats": {"total": 97, "additions": 21, "deletions": 76}, "files": [{"sha": "780869bb8c20603362cf6094b7414505056925ff", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/522f66545ffe709527dc2102aefe738ffe9ecc17/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522f66545ffe709527dc2102aefe738ffe9ecc17/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=522f66545ffe709527dc2102aefe738ffe9ecc17", "patch": "@@ -15,12 +15,12 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         return;\n     }\n \n-    let (is_absolute_path, qualifier, in_block_expr, in_loop_body, is_func_update) =\n+    let (is_absolute_path, qualifier, in_block_expr, in_loop_body, is_func_update, after_if_expr) =\n         match ctx.nameref_ctx() {\n             Some(NameRefContext {\n                 path_ctx:\n                     Some(PathCompletionCtx {\n-                        kind: PathKind::Expr { in_block_expr, in_loop_body },\n+                        kind: PathKind::Expr { in_block_expr, in_loop_body, after_if_expr },\n                         is_absolute_path,\n                         qualifier,\n                         ..\n@@ -33,6 +33,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                 *in_block_expr,\n                 *in_loop_body,\n                 record_expr.as_ref().map_or(false, |&(_, it)| it),\n+                *after_if_expr,\n             ),\n             _ => return,\n         };\n@@ -202,7 +203,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                     add_keyword(\"let\", \"let\");\n                 }\n \n-                if ctx.after_if() {\n+                if after_if_expr {\n                     add_keyword(\"else\", \"else {\\n    $0\\n}\");\n                     add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n                 }"}, {"sha": "6068a9eb32c47e30b15ba4714ef2c165f05f8ec2", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/522f66545ffe709527dc2102aefe738ffe9ecc17/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522f66545ffe709527dc2102aefe738ffe9ecc17/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=522f66545ffe709527dc2102aefe738ffe9ecc17", "patch": "@@ -15,16 +15,16 @@ use ide_db::{\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n     ast::{self, AttrKind, HasArgList, HasName, NameOrNameRef},\n-    match_ast, AstNode, AstToken, NodeOrToken,\n+    match_ast, AstNode, AstToken, Direction, NodeOrToken,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n use text_edit::Indel;\n \n use crate::{\n     patterns::{\n-        determine_location, determine_prev_sibling, is_in_loop_body, is_in_token_of_for_loop,\n-        previous_token, ImmediateLocation, ImmediatePrevSibling,\n+        determine_location, is_in_loop_body, is_in_token_of_for_loop, previous_token,\n+        ImmediateLocation,\n     },\n     CompletionConfig,\n };\n@@ -48,6 +48,7 @@ pub(super) enum PathKind {\n     Expr {\n         in_block_expr: bool,\n         in_loop_body: bool,\n+        after_if_expr: bool,\n     },\n     Type {\n         in_tuple_struct: bool,\n@@ -264,7 +265,6 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) incomplete_let: bool,\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n-    pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n     pub(super) previous_token: Option<SyntaxToken>,\n \n     pub(super) ident_ctx: IdentContext,\n@@ -345,10 +345,6 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::RefExpr))\n     }\n \n-    pub(crate) fn after_if(&self) -> bool {\n-        matches!(self.prev_sibling, Some(ImmediatePrevSibling::IfExpr))\n-    }\n-\n     // FIXME: This shouldn't exist\n     pub(crate) fn is_path_disallowed(&self) -> bool {\n         !self.qualifier_ctx.none()\n@@ -527,7 +523,6 @@ impl<'a> CompletionContext<'a> {\n             impl_def: None,\n             incomplete_let: false,\n             completion_location: None,\n-            prev_sibling: None,\n             previous_token: None,\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n@@ -922,7 +917,6 @@ impl<'a> CompletionContext<'a> {\n         };\n         self.completion_location =\n             determine_location(&self.sema, original_file, offset, &name_like);\n-        self.prev_sibling = determine_prev_sibling(&name_like);\n         self.impl_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n@@ -1169,6 +1163,13 @@ impl<'a> CompletionContext<'a> {\n                     find_node_in_file_compensated(original_file, &record_expr).zip(Some(true));\n             }\n         };\n+        let after_if_expr = |node: SyntaxNode| {\n+            let prev_expr = (|| {\n+                let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n+                ast::ExprStmt::cast(prev_sibling)?.expr()\n+            })();\n+            matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n+        };\n \n         // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n         // ex. trait Foo $0 {}\n@@ -1226,7 +1227,9 @@ impl<'a> CompletionContext<'a> {\n                         path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n                         let in_block_expr = is_in_block(it.syntax());\n                         let in_loop_body = is_in_loop_body(it.syntax());\n-                        Some(PathKind::Expr { in_block_expr, in_loop_body })\n+                        let after_if_expr = after_if_expr(it.syntax().clone());\n+\n+                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr })\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n@@ -1274,8 +1277,9 @@ impl<'a> CompletionContext<'a> {\n                                return Some(parent.and_then(ast::MacroExpr::cast).map(|it| {\n                                     let in_loop_body = is_in_loop_body(it.syntax());\n                                     let in_block_expr = is_in_block(it.syntax());\n+                                    let after_if_expr = after_if_expr(it.syntax().clone());\n                                     fill_record_expr(it.syntax());\n-                                    PathKind::Expr { in_block_expr, in_loop_body }\n+                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr }\n                                 }));\n                             },\n                         }"}, {"sha": "9abbfaa40729bfba61f873cea259dae05289023f", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/522f66545ffe709527dc2102aefe738ffe9ecc17/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522f66545ffe709527dc2102aefe738ffe9ecc17/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=522f66545ffe709527dc2102aefe738ffe9ecc17", "patch": "@@ -7,22 +7,15 @@\n use hir::Semantics;\n use ide_db::RootDatabase;\n use syntax::{\n-    algo::non_trivia_sibling,\n     ast::{self, HasLoopBody, HasName},\n-    match_ast, AstNode, Direction, SyntaxElement,\n+    match_ast, AstNode, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n #[cfg(test)]\n use crate::tests::check_pattern_is_applicable;\n \n-/// Immediate previous node to what we are completing.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum ImmediatePrevSibling {\n-    IfExpr,\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum TypeAnnotation {\n     Let(Option<ast::Pat>),\n@@ -46,45 +39,6 @@ pub(crate) enum ImmediateLocation {\n     GenericArgList(ast::GenericArgList),\n }\n \n-pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<ImmediatePrevSibling> {\n-    let node = match name_like {\n-        ast::NameLike::NameRef(name_ref) => maximize_name_ref(name_ref),\n-        ast::NameLike::Name(n) => n.syntax().clone(),\n-        ast::NameLike::Lifetime(lt) => lt.syntax().clone(),\n-    };\n-    let node = match node.parent().and_then(ast::MacroCall::cast) {\n-        // When a path is being typed after the name of a trait/type of an impl it is being\n-        // parsed as a macro, so when the trait/impl has a block following it an we are between the\n-        // name and block the macro will attach the block to itself so maximizing fails to take\n-        // that into account\n-        // FIXME path expr and statement have a similar problem with attrs\n-        Some(call)\n-            if call.excl_token().is_none()\n-                && call.token_tree().map_or(false, |t| t.l_curly_token().is_some())\n-                && call.semicolon_token().is_none() =>\n-        {\n-            call.syntax().clone()\n-        }\n-        _ => node,\n-    };\n-    let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-    let res = match_ast! {\n-        match prev_sibling {\n-            ast::ExprStmt(it) => {\n-                let node = it.expr().filter(|_| it.semicolon_token().is_none())?.syntax().clone();\n-                match_ast! {\n-                    match node {\n-                        ast::IfExpr(_) => ImmediatePrevSibling::IfExpr,\n-                        _ => return None,\n-                    }\n-                }\n-            },\n-            _ => return None,\n-        }\n-    };\n-    Some(res)\n-}\n-\n pub(crate) fn determine_location(\n     sema: &Semantics<RootDatabase>,\n     original_file: &SyntaxNode,\n@@ -316,22 +270,8 @@ mod tests {\n         );\n     }\n \n-    fn check_prev_sibling(code: &str, sibling: impl Into<Option<ImmediatePrevSibling>>) {\n-        check_pattern_is_applicable(code, |e| {\n-            let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n-            assert_eq!(determine_prev_sibling(name), sibling.into());\n-            true\n-        });\n-    }\n-\n     #[test]\n     fn test_ref_expr_loc() {\n         check_location(r\"fn my_fn() { let x = &m$0 foo; }\", ImmediateLocation::RefExpr);\n     }\n-\n-    #[test]\n-    fn test_if_expr_prev_sibling() {\n-        check_prev_sibling(r\"fn foo() { if true {} w$0\", ImmediatePrevSibling::IfExpr);\n-        check_prev_sibling(r\"fn foo() { if true {}; w$0\", None);\n-    }\n }"}]}