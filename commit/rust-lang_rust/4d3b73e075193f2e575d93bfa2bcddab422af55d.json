{"sha": "4d3b73e075193f2e575d93bfa2bcddab422af55d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkM2I3M2UwNzUxOTNmMmU1NzVkOTNiZmEyYmNkZGFiNDIyYWY1NWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-02-24T23:46:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-24T23:46:07Z"}, "message": "Merge pull request #2483 from topecongiro/error-on-unknown-config-name-in-configurations\n\nError on outdated Configurations.md", "tree": {"sha": "6b0cde34d7718c3ae323b251bdd76ce3c4eb5d4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b0cde34d7718c3ae323b251bdd76ce3c4eb5d4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d3b73e075193f2e575d93bfa2bcddab422af55d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakfk/CRBK7hj4Ov3rIwAAdHIIAI9SzvONYlZYi/E+rZybFSs3\n74rU4UsaKQYOQR7tW1QuQVC5vSpFMf/fUdEQjol3IbvFiAmylKDoa92ADmx3ZVk/\n1G/K16miDY8yCDcAm+YgZmoYkVchfTykr2r0ELG1vuJ+Kh2Rk1n0PNFbZBy7BJVf\nKAWPyrWQ0YLux6XYaZbbDcie1TKnssnTYtpD9AhC3k1knEoCmu1K/drEqCzDyilE\nhUU0ucJndDHGPPIuVCIA4HftBKYhKCoA5rcwBP2k1cW/P8QqrLOJf3tOgVY6hqhv\n/aky0lftJhZTiDHyPoZwCf9zgRdvMXATZ7LBAlhtQf3ckVosR+ys320wK+87WiE=\n=mPKr\n-----END PGP SIGNATURE-----\n", "payload": "tree 6b0cde34d7718c3ae323b251bdd76ce3c4eb5d4d\nparent eea5dcac4661877dc5e1921eb201102c903f21e6\nparent 34f6408ea2f0cf0b66eea083169217399b77ff96\nauthor Nick Cameron <nrc@ncameron.org> 1519515967 +1300\ncommitter GitHub <noreply@github.com> 1519515967 +1300\n\nMerge pull request #2483 from topecongiro/error-on-unknown-config-name-in-configurations\n\nError on outdated Configurations.md"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3b73e075193f2e575d93bfa2bcddab422af55d", "html_url": "https://github.com/rust-lang/rust/commit/4d3b73e075193f2e575d93bfa2bcddab422af55d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d3b73e075193f2e575d93bfa2bcddab422af55d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea5dcac4661877dc5e1921eb201102c903f21e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea5dcac4661877dc5e1921eb201102c903f21e6", "html_url": "https://github.com/rust-lang/rust/commit/eea5dcac4661877dc5e1921eb201102c903f21e6"}, {"sha": "34f6408ea2f0cf0b66eea083169217399b77ff96", "url": "https://api.github.com/repos/rust-lang/rust/commits/34f6408ea2f0cf0b66eea083169217399b77ff96", "html_url": "https://github.com/rust-lang/rust/commit/34f6408ea2f0cf0b66eea083169217399b77ff96"}], "stats": {"total": 182, "additions": 163, "deletions": 19}, "files": [{"sha": "324546f5a0d58a4c5d5ea903e28f11256c91d45c", "filename": "Configurations.md", "status": "modified", "additions": 113, "deletions": 6, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4d3b73e075193f2e575d93bfa2bcddab422af55d/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d3b73e075193f2e575d93bfa2bcddab422af55d/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=4d3b73e075193f2e575d93bfa2bcddab422af55d", "patch": "@@ -579,24 +579,23 @@ Don't reformat anything\n \n ## `error_on_line_overflow`\n \n-Error if unable to get all lines within `max_width`\n+Error if unable to get all lines within `max_width`, except for comments and string literals.\n \n - **Default value**: `true`\n - **Possible values**: `true`, `false`\n - **Stable**: No\n \n See also [`max_width`](#max_width).\n \n-## `error_on_line_overflow_comments`\n+## `error_on_unformatted`\n \n-Error if unable to get all comment lines within `comment_width`.\n+Error if unable to get comments or string literals within `max_width`, or they are left with\n+trailing whitespaces.\n \n-- **Default value**: `true`\n+- **Default value**: `false`\n - **Possible values**: `true`, `false`\n - **Stable**: No\n \n-See also [`comment_width`](#comment_width).\n-\n ## `fn_args_density`\n \n Argument density in functions\n@@ -1379,6 +1378,41 @@ extern crate sit;\n \n This value has no influence beyond the effect of the [`reorder_extern_crates`](#reorder_extern_crates) option. Set [`reorder_extern_crates`](#reorder_extern_crates) to `false` if you do not want `extern crate` groups to be collapsed and ordered.\n \n+## `reorder_modules`\n+\n+Reorder `mod` declarations alphabetically in group.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No\n+\n+#### `true`\n+\n+```rust\n+mod a;\n+mod b;\n+\n+mod dolor;\n+mod ipsum;\n+mod lorem;\n+mod sit;\n+```\n+\n+#### `false`\n+\n+```rust\n+mod b;\n+mod a;\n+\n+mod lorem;\n+mod ipsum;\n+mod dolor;\n+mod sit;\n+```\n+\n+**Note** `mod` with `#[macro_export]` will not be reordered since that could change the semantic\n+of the original source code.\n+\n ## `report_todo`\n \n Report `TODO` items in comments.\n@@ -2008,3 +2042,76 @@ fn bar() {\n     println!(\"c\");\n }\n ```\n+\n+## `remove_blank_lines_at_start_or_end_of_block`\n+\n+Remove blank lines at the start or the end of a block.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No\n+\n+#### `true`\n+\n+```rust\n+fn foo() {\n+    let msg = {\n+        let mut str = String::new();\n+        str.push_str(\"hello, \");\n+        str.push_str(\"world!\");\n+        str\n+    };\n+    println!(\"{}\", msg);\n+}\n+```\n+\n+#### `false`\n+\n+```rust\n+fn foo() {\n+\n+    let msg = {\n+\n+        let mut str = String::new();\n+        str.push_str(\"hello, \");\n+        str.push_str(\"world!\");\n+        str\n+\n+    };\n+    println!(\"{}\", msg);\n+\n+}\n+```\n+\n+## `required_version`\n+\n+Require a specific version of rustfmt. If you want to make sure that the \n+specific version of rustfmt is used in your CI, use this option.\n+\n+- **Default value**: `CARGO_PKG_VERSION`\n+- **Possible values**: any published version (e.g. `\"0.3.8\"`)\n+- **Stable**: No\n+\n+## `hide_parse_errors`\n+\n+Do not show parse errors if the parser failed to parse files.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No\n+\n+## `color`\n+\n+Whether to use colored output or not.\n+\n+- **Default value**: `\"Auto\"`\n+- **Possible values**: \"Auto\", \"Always\", \"Never\"\n+- **Stable**: No\n+\n+## `unstable_features`\n+\n+Enable unstable featuers on stable channel.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes"}, {"sha": "bace9dba8ff17965e56e6702c7c5ddcd803dd798", "filename": "rustfmt-config/src/config_type.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4d3b73e075193f2e575d93bfa2bcddab422af55d/rustfmt-config%2Fsrc%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3b73e075193f2e575d93bfa2bcddab422af55d/rustfmt-config%2Fsrc%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Fconfig_type.rs?ref=4d3b73e075193f2e575d93bfa2bcddab422af55d", "patch": "@@ -74,6 +74,8 @@ macro_rules! is_nightly_channel {\n \n macro_rules! create_config {\n     ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n+        use std::collections::HashSet;\n+\n         #[derive(Clone)]\n         pub struct Config {\n             // For each config item, we store a bool indicating whether it has\n@@ -190,6 +192,24 @@ macro_rules! create_config {\n                 self\n             }\n \n+            /// Returns a hash set initialized with every user-facing config option name.\n+            pub fn hash_set() -> HashSet<String> {\n+                let mut hash_set = HashSet::new();\n+                $(\n+                    hash_set.insert(stringify!($i).to_owned());\n+                )+\n+                hash_set\n+            }\n+\n+            pub fn is_valid_name(name: &str) -> bool {\n+                match name {\n+                    $(\n+                        stringify!($i) => true,\n+                    )+\n+                        _ => false,\n+                }\n+            }\n+\n             pub fn from_toml(toml: &str) -> Result<Config, String> {\n                 let parsed: toml::Value =\n                     toml.parse().map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n@@ -199,15 +219,9 @@ macro_rules! create_config {\n                         .as_table()\n                         .ok_or(String::from(\"Parsed config was not table\"))?;\n                     for key in table.keys() {\n-                        match &**key {\n-                            $(\n-                                stringify!($i) => (),\n-                            )+\n-                            _ => {\n-                                let msg =\n-                                    &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n-                                err.push_str(msg)\n-                            }\n+                        if !Config::is_valid_name(key) {\n+                            let msg = &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n+                            err.push_str(msg)\n                         }\n                     }\n                 }\n@@ -324,10 +338,13 @@ macro_rules! create_config {\n                 }\n             }\n \n+            pub fn is_hidden_option(name: &str) -> bool {\n+                const HIDE_OPTIONS: [&str; 3] = [\"verbose\", \"file_lines\", \"width_heuristics\"];\n+                HIDE_OPTIONS.contains(&name)\n+            }\n \n             pub fn print_docs() {\n                 use std::cmp;\n-                const HIDE_OPTIONS: [&str; 3] = [\"verbose\", \"file_lines\", \"width_heuristics\"];\n                 let max = 0;\n                 $( let max = cmp::max(max, stringify!($i).len()+1); )+\n                 let mut space_str = String::with_capacity(max);\n@@ -338,7 +355,7 @@ macro_rules! create_config {\n                 $(\n                     let name_raw = stringify!($i);\n \n-                    if !HIDE_OPTIONS.contains(&name_raw) {\n+                    if !Config::is_hidden_option(name_raw) {\n                         let mut name_out = String::with_capacity(max);\n                         for _ in name_raw.len()..max-1 {\n                             name_out.push(' ')"}, {"sha": "00988dc6fc5ce40d4e9d466770790c5e4b7fd773", "filename": "rustfmt-core/tests/lib.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4d3b73e075193f2e575d93bfa2bcddab422af55d/rustfmt-core%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3b73e075193f2e575d93bfa2bcddab422af55d/rustfmt-core%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Flib.rs?ref=4d3b73e075193f2e575d93bfa2bcddab422af55d", "patch": "@@ -17,7 +17,7 @@ extern crate rustfmt_config as config;\n extern crate rustfmt_core as rustfmt;\n extern crate term;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::fs;\n use std::io::{self, BufRead, BufReader, Read};\n use std::iter::{Enumerate, Peekable};\n@@ -795,6 +795,7 @@ impl ConfigCodeBlock {\n     fn extract<I: Iterator<Item = String>>(\n         file: &mut Enumerate<I>,\n         prev: Option<&ConfigCodeBlock>,\n+        hash_set: &mut HashSet<String>,\n     ) -> Option<ConfigCodeBlock> {\n         let mut code_block = ConfigCodeBlock::new();\n         code_block.config_name = prev.and_then(|cb| cb.config_name.clone());\n@@ -806,6 +807,16 @@ impl ConfigCodeBlock {\n                     break;\n                 }\n                 Some(ConfigurationSection::ConfigName(name)) => {\n+                    assert!(\n+                        Config::is_valid_name(&name),\n+                        \"an unknown configuration option was found: {}\",\n+                        name\n+                    );\n+                    assert!(\n+                        hash_set.remove(&name),\n+                        \"multiple configuration guides found for option {}\",\n+                        name\n+                    );\n                     code_block.set_config_name(Some(name));\n                 }\n                 Some(ConfigurationSection::ConfigValue(value)) => {\n@@ -831,11 +842,20 @@ fn configuration_snippet_tests() {\n             .map(|l| l.unwrap())\n             .enumerate();\n         let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n+        let mut hash_set = Config::hash_set();\n \n-        while let Some(cb) = ConfigCodeBlock::extract(&mut file_iter, code_blocks.last()) {\n+        while let Some(cb) =\n+            ConfigCodeBlock::extract(&mut file_iter, code_blocks.last(), &mut hash_set)\n+        {\n             code_blocks.push(cb);\n         }\n \n+        for name in hash_set {\n+            if !Config::is_hidden_option(&name) {\n+                panic!(\"{} does not have a configuration guide\", name);\n+            }\n+        }\n+\n         code_blocks\n     }\n "}]}