{"sha": "6bd80d11163771293ea7bf75a4513af76b754a41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZDgwZDExMTYzNzcxMjkzZWE3YmY3NWE0NTEzYWY3NmI3NTRhNDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-19T11:23:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-20T11:26:14Z"}, "message": "compute and cache HIR hashes at beginning\n\nThis avoids the compile-time overhead of computing them twice.  It also fixes\nan issue where the hash computed after typeck is differen than the hash before,\nbecause typeck mutates the def-map in place.\n\nFixes #35549.\nFixes #35593.", "tree": {"sha": "552a117382ccf2c8cc7d1d40b12618e3c4f72e5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/552a117382ccf2c8cc7d1d40b12618e3c4f72e5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bd80d11163771293ea7bf75a4513af76b754a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd80d11163771293ea7bf75a4513af76b754a41", "html_url": "https://github.com/rust-lang/rust/commit/6bd80d11163771293ea7bf75a4513af76b754a41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bd80d11163771293ea7bf75a4513af76b754a41/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "413ada30402f823a86a75578afc63d07179f6a23", "url": "https://api.github.com/repos/rust-lang/rust/commits/413ada30402f823a86a75578afc63d07179f6a23", "html_url": "https://github.com/rust-lang/rust/commit/413ada30402f823a86a75578afc63d07179f6a23"}], "stats": {"total": 339, "additions": 182, "deletions": 157}, "files": [{"sha": "99fb2d6a44905bc1eb23d00ef57b6d0f5e34488b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -1621,7 +1621,7 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_id: Option<NodeId>,"}, {"sha": "825a84d075bb5cb052748aa8cbdecb967f0df68e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -26,7 +26,7 @@ use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n-use rustc_incremental;\n+use rustc_incremental::{self, HashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::macro_import;\n use rustc_metadata::creader::read_local_crates;\n@@ -172,7 +172,7 @@ pub fn compile_input(sess: &Session,\n                                     resolutions,\n                                     &arenas,\n                                     &crate_name,\n-                                    |tcx, mir_map, analysis, result| {\n+                                    |tcx, mir_map, analysis, hashes_map, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -202,7 +202,8 @@ pub fn compile_input(sess: &Session,\n             }\n             let trans = phase_4_translate_to_llvm(tcx,\n                                                   mir_map.unwrap(),\n-                                                  analysis);\n+                                                  analysis,\n+                                                  &hashes_map);\n \n             if log_enabled!(::log::INFO) {\n                 println!(\"Post-trans\");\n@@ -797,14 +798,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             Option<MirMap<'tcx>>,\n                             ty::CrateAnalysis,\n+                            HashesMap,\n                             CompileResult) -> R\n {\n     macro_rules! try_with_f {\n-        ($e: expr, ($t: expr, $m: expr, $a: expr)) => {\n+        ($e: expr, ($t: expr, $m: expr, $a: expr, $h: expr)) => {\n             match $e {\n                 Ok(x) => x,\n                 Err(x) => {\n-                    f($t, $m, $a, Err(x));\n+                    f($t, $m, $a, $h, Err(x));\n                     return Err(x);\n                 }\n             }\n@@ -860,12 +862,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              index,\n                              name,\n                              |tcx| {\n+        let hashes_map =\n+            time(time_passes,\n+                 \"compute_hashes_map\",\n+                 || rustc_incremental::compute_hashes_map(tcx));\n         time(time_passes,\n              \"load_dep_graph\",\n-             || rustc_incremental::load_dep_graph(tcx));\n+             || rustc_incremental::load_dep_graph(tcx, &hashes_map));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis, hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -935,7 +941,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+            return Ok(f(tcx, Some(mir_map), analysis, hashes_map, Err(sess.err_count())));\n         }\n \n         analysis.reachable =\n@@ -963,17 +969,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         // The above three passes generate errors w/o aborting\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+            return Ok(f(tcx, Some(mir_map), analysis, hashes_map, Err(sess.err_count())));\n         }\n \n-        Ok(f(tcx, Some(mir_map), analysis, Ok(())))\n+        Ok(f(tcx, Some(mir_map), analysis, hashes_map, Ok(())))\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            mut mir_map: MirMap<'tcx>,\n-                                           analysis: ty::CrateAnalysis)\n+                                           analysis: ty::CrateAnalysis,\n+                                           hashes_map: &HashesMap)\n                                            -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n@@ -1007,15 +1014,15 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let translation =\n         time(time_passes,\n              \"translation\",\n-             move || trans::trans_crate(tcx, &mir_map, analysis));\n+             move || trans::trans_crate(tcx, &mir_map, analysis, &hashes_map));\n \n     time(time_passes,\n          \"assert dep graph\",\n          move || rustc_incremental::assert_dep_graph(tcx));\n \n     time(time_passes,\n          \"serialize dep graph\",\n-         move || rustc_incremental::save_dep_graph(tcx));\n+         move || rustc_incremental::save_dep_graph(tcx, &hashes_map));\n \n     translation\n }"}, {"sha": "1ffeaf322bf5715c678b30729170ac30c138df87", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -234,7 +234,7 @@ impl PpSourceMode {\n                                                                  resolutions.clone(),\n                                                                  arenas,\n                                                                  id,\n-                                                                 |tcx, _, _, _| {\n+                                                                 |tcx, _, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                     };\n@@ -951,7 +951,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      resolutions.clone(),\n                                                      arenas,\n                                                      crate_name,\n-                                                     |tcx, mir_map, _, _| {\n+                                                     |tcx, mir_map, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(mir_map) = mir_map {"}, {"sha": "7b1b0ce4cf14d5192c3c9c02639455567eff9a0c", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 88, "deletions": 72, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -8,106 +8,122 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Calculation of a Strict Version Hash for crates.  For a length\n-//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n-\n+//! Calculation of the (misnamed) \"strict version hash\" for crates and\n+//! items. This hash is used to tell when the HIR changed in such a\n+//! way that results from previous compilations may no longer be\n+//! applicable and hence must be recomputed. It should probably be\n+//! renamed to the ICH (incremental compilation hash).\n+//!\n+//! The hashes for all items are computed once at the beginning of\n+//! compilation and stored into a map. In addition, a hash is computed\n+//! of the **entire crate**.\n+//!\n+//! Storing the hashes in a map avoids the need to compute them twice\n+//! (once when loading prior incremental results and once when\n+//! saving), but it is also important for correctness: at least as of\n+//! the time of this writing, the typeck passes rewrites entries in\n+//! the dep-map in-place to accommodate UFCS resolutions. Since name\n+//! resolution is part of the hash, the result is that hashes computed\n+//! at the end of compilation would be different from those computed\n+//! at the beginning.\n+\n+use syntax::ast;\n use syntax::attr::AttributeMethods;\n use std::hash::{Hash, SipHasher, Hasher};\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::map::{NodeItem, NodeForeignItem};\n-use rustc::hir::svh::Svh;\n+use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use self::svh_visitor::StrictVersionHashVisitor;\n \n mod svh_visitor;\n \n-pub trait SvhCalculate {\n-    /// Calculate the SVH for an entire krate.\n-    fn calculate_krate_hash(self) -> Svh;\n+pub type HashesMap = FnvHashMap<DepNode<DefId>, u64>;\n \n-    /// Calculate the SVH for a particular item.\n-    fn calculate_item_hash(self, def_id: DefId) -> u64;\n+pub fn compute_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> HashesMap {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let krate = tcx.map.krate();\n+    let mut visitor = HashItemsVisitor { tcx: tcx, hashes: FnvHashMap() };\n+    visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| visit::walk_crate(v, krate));\n+    krate.visit_all_items(&mut visitor);\n+    visitor.compute_crate_hash();\n+    visitor.hashes\n }\n \n-impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n-    fn calculate_krate_hash(self) -> Svh {\n-        // FIXME (#14132): This is better than it used to be, but it still not\n-        // ideal. We now attempt to hash only the relevant portions of the\n-        // Crate AST as well as the top-level crate attributes. (However,\n-        // the hashing of the crate attributes should be double-checked\n-        // to ensure it is not incorporating implementation artifacts into\n-        // the hash that are not otherwise visible.)\n+struct HashItemsVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    hashes: HashesMap,\n+}\n \n-        let crate_disambiguator = self.sess.local_crate_disambiguator();\n-        let krate = self.map.krate();\n+impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n+    fn calculate_node_id<W>(&mut self, id: ast::NodeId, walk_op: W)\n+        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'tcx>)\n+    {\n+        let def_id = self.tcx.map.local_def_id(id);\n+        self.calculate_def_id(def_id, walk_op)\n+    }\n \n-        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n-        //        avoid collisions.\n+    fn calculate_def_id<W>(&mut self, def_id: DefId, mut walk_op: W)\n+        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'tcx>)\n+    {\n+        assert!(def_id.is_local());\n+        debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not\n+        // built to avoid collisions.\n         let mut state = SipHasher::new();\n-        debug!(\"state: {:?}\", state);\n+        walk_op(&mut StrictVersionHashVisitor::new(&mut state, self.tcx));\n+        let item_hash = state.finish();\n+        self.hashes.insert(DepNode::Hir(def_id), item_hash);\n+        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n+    }\n+\n+    fn compute_crate_hash(&mut self) {\n+        let krate = self.tcx.map.krate();\n \n-        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n-        // this enough, and does it matter anyway?\n-        \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n-        crate_disambiguator.hash(&mut state);\n+        let mut crate_state = SipHasher::new();\n \n-        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n-        debug!(\"state: {:?}\", state);\n+        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n+        \"crate_disambiguator\".hash(&mut crate_state);\n+        crate_disambiguator.len().hash(&mut crate_state);\n+        crate_disambiguator.hash(&mut crate_state);\n \n+        // add each item (in some deterministic order) to the overall\n+        // crate hash.\n+        //\n+        // FIXME -- it'd be better to sort by the hash of the def-path,\n+        // so that reordering items would not affect the crate hash.\n         {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            krate.visit_all_items(&mut visit);\n+            let mut keys: Vec<_> = self.hashes.keys().collect();\n+            keys.sort();\n+            for key in keys {\n+                self.hashes[key].hash(&mut crate_state);\n+            }\n         }\n \n-        // FIXME (#14132): This hash is still sensitive to e.g. the\n-        // spans of the crate Attributes and their underlying\n-        // MetaItems; we should make ContentHashable impl for those\n-        // types and then use hash_content.  But, since all crate\n-        // attributes should appear near beginning of the file, it is\n-        // not such a big deal to be sensitive to their spans for now.\n-        //\n-        // We hash only the MetaItems instead of the entire Attribute\n-        // to avoid hashing the AttrId\n         for attr in &krate.attrs {\n             debug!(\"krate attr {:?}\", attr);\n-            attr.meta().hash(&mut state);\n+            attr.meta().hash(&mut crate_state);\n         }\n \n-        Svh::new(state.finish())\n+        let crate_hash = crate_state.finish();\n+        self.hashes.insert(DepNode::Krate, crate_hash);\n+        debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n     }\n+}\n \n-    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local());\n-\n-        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n-\n-        let mut state = SipHasher::new();\n-\n-        {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            if def_id.index == CRATE_DEF_INDEX {\n-                // the crate root itself is not registered in the map\n-                // as an item, so we have to fetch it this way\n-                let krate = self.map.krate();\n-                intravisit::walk_crate(&mut visit, krate);\n-            } else {\n-                let node_id = self.map.as_local_node_id(def_id).unwrap();\n-                match self.map.find(node_id) {\n-                    Some(NodeItem(item)) => visit.visit_item(item),\n-                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n-                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n-                              node_id, r),\n-                }\n-            }\n-        }\n-\n-        let hash = state.finish();\n \n-        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n+impl<'a, 'tcx> visit::Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.calculate_node_id(item.id, |v| v.visit_item(item));\n+        visit::walk_item(self, item);\n+    }\n \n-        hash\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n+        self.calculate_node_id(item.id, |v| v.visit_foreign_item(item));\n+        visit::walk_foreign_item(self, item);\n     }\n }\n+"}, {"sha": "c06b223ce211af78e126609ed9cd6ead3c97d320", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -187,20 +187,20 @@ pub enum SawStmtComponent {\n     SawStmtSemi,\n }\n \n-impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'tcx> {\n     fn visit_nested_item(&mut self, _: ItemId) {\n         // Each item is hashed independently; ignore nested items.\n     }\n \n-    fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n-                          g: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &'tcx VariantData, name: Name,\n+                          g: &'tcx Generics, _: NodeId, _: Span) {\n         debug!(\"visit_variant_data: st={:?}\", self.st);\n         SawStructDef(name.as_str()).hash(self.st);\n         visit::walk_generics(self, g);\n         visit::walk_struct_def(self, s)\n     }\n \n-    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n         debug!(\"visit_variant: st={:?}\", self.st);\n         SawVariant.hash(self.st);\n         // walk_variant does not call walk_generics, so do it here.\n@@ -227,12 +227,12 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         SawIdent(name.as_str()).hash(self.st);\n     }\n \n-    fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+    fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n         debug!(\"visit_lifetime: st={:?}\", self.st);\n         SawLifetime(l.name.as_str()).hash(self.st);\n     }\n \n-    fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n         debug!(\"visit_lifetime_def: st={:?}\", self.st);\n         SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n     }\n@@ -242,12 +242,12 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n     // monomorphization and cross-crate inlining generally implies\n     // that a change to a crate body will require downstream\n     // crates to be recompiled.\n-    fn visit_expr(&mut self, ex: &'a Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n         SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n     }\n \n-    fn visit_stmt(&mut self, s: &'a Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n         debug!(\"visit_stmt: st={:?}\", self.st);\n \n         // We don't want to modify the hash for decls, because\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         visit::walk_stmt(self, s)\n     }\n \n-    fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n         debug!(\"visit_foreign_item: st={:?}\", self.st);\n \n         // FIXME (#14132) ideally we would incorporate privacy (or\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_item(&mut self, i: &'a Item) {\n+    fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n \n         // FIXME (#14132) ideally would incorporate reachability\n@@ -285,63 +285,63 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         SawItem.hash(self.st); visit::walk_item(self, i)\n     }\n \n-    fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, n: NodeId) {\n         debug!(\"visit_mod: st={:?}\", self.st);\n         SawMod.hash(self.st); visit::walk_mod(self, m, n)\n     }\n \n-    fn visit_ty(&mut self, t: &'a Ty) {\n+    fn visit_ty(&mut self, t: &'tcx Ty) {\n         debug!(\"visit_ty: st={:?}\", self.st);\n         SawTy.hash(self.st); visit::walk_ty(self, t)\n     }\n \n-    fn visit_generics(&mut self, g: &'a Generics) {\n+    fn visit_generics(&mut self, g: &'tcx Generics) {\n         debug!(\"visit_generics: st={:?}\", self.st);\n         SawGenerics.hash(self.st); visit::walk_generics(self, g)\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                b: &'a Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n+                b: &'tcx Block, s: Span, n: NodeId) {\n         debug!(\"visit_fn: st={:?}\", self.st);\n         SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n         SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n         SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_struct_field(&mut self, s: &'a StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         debug!(\"visit_struct_field: st={:?}\", self.st);\n         SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n     }\n \n-    fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n         SawPath.hash(self.st); visit::walk_path(self, path)\n     }\n \n-    fn visit_block(&mut self, b: &'a Block) {\n+    fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n         SawBlock.hash(self.st); visit::walk_block(self, b)\n     }\n \n-    fn visit_pat(&mut self, p: &'a Pat) {\n+    fn visit_pat(&mut self, p: &'tcx Pat) {\n         debug!(\"visit_pat: st={:?}\", self.st);\n         SawPat.hash(self.st); visit::walk_pat(self, p)\n     }\n \n-    fn visit_local(&mut self, l: &'a Local) {\n+    fn visit_local(&mut self, l: &'tcx Local) {\n         debug!(\"visit_local: st={:?}\", self.st);\n         SawLocal.hash(self.st); visit::walk_local(self, l)\n     }\n \n-    fn visit_arm(&mut self, a: &'a Arm) {\n+    fn visit_arm(&mut self, a: &'tcx Arm) {\n         debug!(\"visit_arm: st={:?}\", self.st);\n         SawArm.hash(self.st); visit::walk_arm(self, a)\n     }\n@@ -369,10 +369,12 @@ impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n         // variant it is above when we visit the HIR).\n \n         if let Some(def) = self.tcx.def_map.borrow().get(&id) {\n+            debug!(\"hash_resolve: id={:?} def={:?} st={:?}\", id, def, self.st);\n             self.hash_partial_def(def);\n         }\n \n         if let Some(traits) = self.tcx.trait_map.get(&id) {\n+            debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n             traits.len().hash(self.st);\n             for candidate in traits {\n                 self.hash_def_id(candidate.def_id);"}, {"sha": "b9c56c45386c4983162083c699c0a75001412f68", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -38,7 +38,8 @@ mod calculate_svh;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use calculate_svh::SvhCalculate;\n+pub use calculate_svh::compute_hashes_map;\n+pub use calculate_svh::HashesMap;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;"}, {"sha": "49ad6c36804e210ff29a6cdf456e3e920be536ff", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use calculate_svh::SvhCalculate;\n use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n@@ -21,19 +20,22 @@ use std::io::{ErrorKind, Read};\n use std::fs::File;\n use syntax::ast;\n \n+use HashesMap;\n use super::data::*;\n use super::util::*;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    hashes_map: &'a HashesMap,\n     item_metadata_hashes: FnvHashMap<DefId, u64>,\n     crate_hashes: FnvHashMap<ast::CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, hashes_map: &'a HashesMap) -> Self {\n         HashContext {\n             tcx: tcx,\n+            hashes_map: hashes_map,\n             item_metadata_hashes: FnvHashMap(),\n             crate_hashes: FnvHashMap(),\n         }\n@@ -51,7 +53,17 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n-                Some((def_id, self.hir_hash(def_id)))\n+                assert!(def_id.is_local(),\n+                        \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n+                        def_id,\n+                        self.tcx.item_path_str(def_id));\n+\n+                assert!(!self.tcx.map.is_inlined_def_id(def_id),\n+                        \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n+                        def_id,\n+                        self.tcx.item_path_str(def_id));\n+\n+                Some((def_id, self.hashes_map[dep_node]))\n             }\n \n             // MetaData from other crates is an *input* to us.\n@@ -72,21 +84,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn hir_hash(&mut self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local(),\n-                \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n-                def_id,\n-                self.tcx.item_path_str(def_id));\n-\n-        assert!(!self.tcx.map.is_inlined_def_id(def_id),\n-                \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n-                def_id,\n-                self.tcx.item_path_str(def_id));\n-\n-        // FIXME(#32753) -- should we use a distinct hash here\n-        self.tcx.calculate_item_hash(def_id)\n-    }\n-\n     fn metadata_hash(&mut self, def_id: DefId) -> u64 {\n         debug!(\"metadata_hash(def_id={:?})\", def_id);\n "}, {"sha": "a2ba566f75e0e29211deed54ed81bbb11621cf8c", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -22,6 +22,7 @@ use std::io::Read;\n use std::fs::{self, File};\n use std::path::{Path};\n \n+use HashesMap;\n use super::data::*;\n use super::directory::*;\n use super::dirty_clean;\n@@ -38,16 +39,18 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                hashes: &HashesMap) {\n     if tcx.sess.opts.incremental.is_none() {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    load_dep_graph_if_exists(tcx);\n+    load_dep_graph_if_exists(tcx, hashes);\n }\n \n-fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      hashes: &HashesMap) {\n     let dep_graph_path = dep_graph_path(tcx).unwrap();\n     let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n         Some(p) => p,\n@@ -60,7 +63,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         None => return // no file\n     };\n \n-    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n+    match decode_dep_graph(tcx, hashes, &dep_graph_data, &work_products_data) {\n         Ok(dirty_nodes) => dirty_nodes,\n         Err(err) => {\n             tcx.sess.warn(\n@@ -97,6 +100,7 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n /// Decode the dep graph and load the edges/nodes that are still clean\n /// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  hashes: &HashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n                                   -> Result<(), Error>\n@@ -133,7 +137,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // reason for this is that this way we can include nodes that have\n     // been removed (which no longer have a `DefId` in the current\n     // compilation).\n-    let dirty_raw_source_nodes = dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n+    let dirty_raw_source_nodes = dirty_nodes(tcx, hashes, &serialized_dep_graph.hashes, &retraced);\n \n     // Create a list of (raw-source-node ->\n     // retracted-target-node) edges. In the process of retracing the\n@@ -206,13 +210,14 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Computes which of the original set of def-ids are dirty. Stored in\n /// a bit vector where the index is the DefPathIndex.\n fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         hashes: &[SerializedHash],\n+                         hashes: &HashesMap,\n+                         serialized_hashes: &[SerializedHash],\n                          retraced: &RetracedDefIdDirectory)\n                          -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx);\n+    let mut hcx = HashContext::new(tcx, hashes);\n     let mut dirty_nodes = FnvHashSet();\n \n-    for hash in hashes {\n+    for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n             let (_, current_hash) = hcx.hash(&dep_node).unwrap();\n             if current_hash == hash.hash {"}, {"sha": "b81afe44f60e7791018dc3c2b756ece12d85cc3a", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -21,20 +21,21 @@ use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n \n+use HashesMap;\n use super::data::*;\n use super::directory::*;\n use super::hash::*;\n use super::preds::*;\n use super::util::*;\n \n-pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hashes_map: &HashesMap) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n     let sess = tcx.sess;\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n-    let mut hcx = HashContext::new(tcx);\n+    let mut hcx = HashContext::new(tcx, hashes_map);\n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n     let query = tcx.dep_graph.query();\n     let preds = Predecessors::new(&query, &mut hcx);"}, {"sha": "d47a5ddb22456afcedeb94171455432be528e47f", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -26,10 +26,10 @@ use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::DepNode;\n-use rustc::ty::TyCtxt;\n+use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n+use rustc_incremental::HashesMap;\n \n-use rustc_incremental::SvhCalculate;\n use std::ascii;\n use std::char;\n use std::env;\n@@ -125,12 +125,12 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n }\n \n-pub fn build_link_meta<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 name: &str)\n-                                 -> LinkMeta {\n+pub fn build_link_meta(hashes_map: &HashesMap,\n+                       name: &str)\n+                       -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: tcx.calculate_krate_hash(),\n+        crate_hash: Svh::new(hashes_map[&DepNode::Krate]),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "f2d0bbae942d2ea00081fdb6b2ccd8a267031465", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -48,6 +48,7 @@ use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n use rustc_data_structures::graph::OUTGOING;\n+use rustc_incremental::HashesMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use _match;\n@@ -2481,7 +2482,8 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              mir_map: &MirMap<'tcx>,\n-                             analysis: ty::CrateAnalysis)\n+                             analysis: ty::CrateAnalysis,\n+                             hashes_map: &HashesMap)\n                              -> CrateTranslation {\n     let _task = tcx.dep_graph.in_task(DepNode::TransCrate);\n \n@@ -2506,7 +2508,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.sess.opts.debug_assertions\n     };\n \n-    let link_meta = link::build_link_meta(tcx, name);\n+    let link_meta = link::build_link_meta(hashes_map, name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              &mir_map,"}, {"sha": "8032b5c31046e0dec58a720642fa036e590479c6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -159,7 +159,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      resolutions,\n                                                      &arenas,\n                                                      &name,\n-                                                     |tcx, _, analysis, result| {\n+                                                     |tcx, _, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "ba8d3cc934bfc253e6f23651c57ded089f5a66e4", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd80d11163771293ea7bf75a4513af76b754a41/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=6bd80d11163771293ea7bf75a4513af76b754a41", "patch": "@@ -17,10 +17,6 @@\n // Here the only thing which changes is the string constant in `x`.\n // Therefore, the compiler deduces (correctly) that typeck is not\n // needed even for callers of `x`.\n-//\n-// It is not entirely clear why `TransCrateItem` invalidates `y` and\n-// `z`, actually, I think it's because of the structure of\n-// trans. -nmatsakis\n \n fn main() { }\n \n@@ -41,10 +37,8 @@ mod x {\n mod y {\n     use x;\n \n-    // FIXME(#35078) -- when body of `x` changes, we treat it as\n-    // though signature changed.\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n     pub fn y() {\n         x::x();\n     }"}]}