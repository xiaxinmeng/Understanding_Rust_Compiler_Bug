{"sha": "6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYzIxYjcxY2ZkOGU1MjQ2ZTc5NTNjZjY0ZWE1ZWU2YTE5Y2ViM2Q=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T01:14:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-15T22:31:37Z"}, "message": "rustc: use monomorphic const_eval for cross-crate enum discriminants.", "tree": {"sha": "c1719d4b3991f2b9ee3033596f8557a1d554d223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1719d4b3991f2b9ee3033596f8557a1d554d223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "html_url": "https://github.com/rust-lang/rust/commit/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63064ec190fef7947c3eabfcdfeaeb293c9a91dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/63064ec190fef7947c3eabfcdfeaeb293c9a91dd", "html_url": "https://github.com/rust-lang/rust/commit/63064ec190fef7947c3eabfcdfeaeb293c9a91dd"}], "stats": {"total": 288, "additions": 139, "deletions": 149}, "files": [{"sha": "0b5434f50e83076514ac0ab8e05ffa4f3803088a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -1660,7 +1660,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().map(move |v| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n+                match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n@@ -1673,6 +1673,51 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         })\n     }\n \n+    /// Compute the discriminant value used by a specific variant.\n+    /// Unlike `discriminants`, this is (amortized) constant-time,\n+    /// only doing at most one query for evaluating an explicit\n+    /// discriminant (the last one before the requested variant),\n+    /// assuming there are no constant-evaluation errors there.\n+    pub fn discriminant_for_variant(&self,\n+                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    variant_index: usize)\n+                                    -> ConstInt {\n+        let repr_type = self.repr.discr_type();\n+        let mut explicit_value = repr_type.initial_discriminant(tcx.global_tcx());\n+        let mut explicit_index = variant_index;\n+        loop {\n+            match self.variants[explicit_index].discr {\n+                ty::VariantDiscr::Relative(0) => break,\n+                ty::VariantDiscr::Relative(distance) => {\n+                    explicit_index -= distance;\n+                }\n+                ty::VariantDiscr::Explicit(expr_did) => {\n+                    match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                        Ok(ConstVal::Integral(v)) => {\n+                            explicit_value = v;\n+                            break;\n+                        }\n+                        _ => {\n+                            explicit_index -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let discr = explicit_value.to_u128_unchecked()\n+            .wrapping_add((variant_index - explicit_index) as u128);\n+        match repr_type {\n+            attr::UnsignedInt(ty) => {\n+                ConstInt::new_unsigned_truncating(discr, ty,\n+                                                  tcx.sess.target.uint_type)\n+            }\n+            attr::SignedInt(ty) => {\n+                ConstInt::new_signed_truncating(discr as i128, ty,\n+                                                tcx.sess.target.int_type)\n+            }\n+        }\n+    }\n+\n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {\n         queries::adt_destructor::get(tcx, DUMMY_SP, self.did)\n     }"}, {"sha": "9c5a669bef0d92623aeb12488802a49f321c6cfe", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -804,10 +804,13 @@ pub fn provide(providers: &mut Providers) {\n fn monomorphic_const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     def_id: DefId)\n                                     -> EvalResult<'tcx> {\n-    ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n     let cx = ConstContext::with_tables(tcx, tcx.item_tables(def_id));\n \n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let body = tcx.hir.body_owned_by(id);\n-    cx.eval(&tcx.hir.body(body).value)\n+    let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+        ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+        tcx.hir.body(tcx.hir.body_owned_by(id))\n+    } else {\n+        tcx.sess.cstore.maybe_get_item_body(tcx, def_id).unwrap()\n+    };\n+    cx.eval(&body.value)\n }"}, {"sha": "7632b40ab4f9ead935148a64514c5ec9147268a7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -900,6 +900,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n+    // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n+    rustc_const_eval::provide(&mut extern_providers);\n \n     TyCtxt::create_and_enter(sess,\n                              local_providers,"}, {"sha": "b73b3e161f9b547fcfb0ef6f0b26090ad794d31d", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -266,6 +266,17 @@ impl<'a, 'tcx, 'm> intravisit::Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, '\n         intravisit::walk_item(self, item);\n     }\n \n+    fn visit_variant(&mut self,\n+                     variant: &'tcx hir::Variant,\n+                     generics: &'tcx hir::Generics,\n+                     parent_id: ast::NodeId) {\n+        if let Some(e) = variant.node.disr_expr {\n+            self.check_item(e.node_id, variant.span);\n+        }\n+\n+        intravisit::walk_variant(self, variant, generics, parent_id);\n+    }\n+\n     fn visit_variant_data(&mut self,\n                           variant_data: &'tcx hir::VariantData,\n                           _: ast::Name,"}, {"sha": "fac6079529e30187af8c4830be5d44876fbaffab", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -511,25 +511,15 @@ impl<'a, 'tcx> CrateMetadata {\n         def\n     }\n \n-    fn get_variant(&self,\n-                   item: &Entry<'tcx>,\n-                   index: DefIndex,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                   -> (ty::VariantDef, Option<DefIndex>) {\n+    fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        if let ty::VariantDiscr::Explicit(def_id) = data.discr {\n-            // The original crate wouldn't have compiled if this is missing.\n-            let result = Ok(data.evaluated_discr.unwrap());\n-            tcx.maps.monomorphic_const_eval.borrow_mut().insert(def_id, result);\n-        }\n-\n-        (ty::VariantDef {\n+        ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n             name: self.item_name(index),\n             fields: item.children.decode(self).map(|index| {\n@@ -542,7 +532,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }).collect(),\n             discr: data.discr,\n             ctor_kind: data.ctor_kind,\n-        }, data.struct_ctor)\n+        }\n     }\n \n     pub fn get_adt_def(&self,\n@@ -561,15 +551,11 @@ impl<'a, 'tcx> CrateMetadata {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    let (variant, struct_ctor) =\n-                        self.get_variant(&self.entry(index), index, tcx);\n-                    assert_eq!(struct_ctor, None);\n-                    variant\n+                    self.get_variant(&self.entry(index), index)\n                 })\n                 .collect()\n         } else {\n-            let (variant, _struct_ctor) = self.get_variant(&item, item_id, tcx);\n-            vec![variant]\n+            vec![self.get_variant(&item, item_id)]\n         };\n         let (kind, repr) = match item.kind {\n             EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),"}, {"sha": "ce9f0a73fe2b85cf47f3cd7a7936a79fc5f54be2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -269,12 +269,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            evaluated_discr: match variant.discr {\n-                ty::VariantDiscr::Explicit(def_id) => {\n-                    ty::queries::monomorphic_const_eval::get(tcx, DUMMY_SP, def_id).ok()\n-                }\n-                ty::VariantDiscr::Relative(_) => None\n-            },\n             struct_ctor: None,\n         };\n \n@@ -408,7 +402,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            evaluated_discr: None,\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -697,7 +690,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    evaluated_discr: None,\n                     struct_ctor: struct_ctor,\n                 }), repr_options)\n             }\n@@ -708,7 +700,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    evaluated_discr: None,\n                     struct_ctor: None,\n                 }), repr_options)\n             }\n@@ -1037,6 +1028,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n                           EntryBuilder::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n+        intravisit::walk_variant(self, v, g, id);\n+\n+        if let Some(discr) = v.node.disr_expr {\n+            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n+            self.index.record(def_id, EntryBuilder::encode_info_for_embedded_const, def_id);\n+        }\n+    }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n         self.index.encode_info_for_generics(generics);\n@@ -1160,6 +1162,32 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         }\n     }\n \n+    fn encode_info_for_embedded_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_embedded_const({:?})\", def_id);\n+        let tcx = self.tcx;\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let body = tcx.hir.body_owned_by(id);\n+\n+        Entry {\n+            kind: EntryKind::Const(ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id)),\n+            visibility: self.lazy(&ty::Visibility::Public),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: Some(self.encode_body(body)),\n+            mir: self.encode_mir(def_id),\n+        }\n+    }\n+\n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n         // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n         //       we really on the HashStable specialization for [Attribute]"}, {"sha": "2f2e0e125aea5673959122f19bd3c89d55b360b0", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -15,7 +15,6 @@ use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::ich::StableHashingContext;\n-use rustc::middle::const_val::ConstVal;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -271,9 +270,9 @@ pub enum EntryKind<'tcx> {\n     Type,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData<'tcx>>),\n-    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n-    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n@@ -374,20 +373,18 @@ pub struct FnData {\n impl_stable_hash_for!(struct FnData { constness, arg_names });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData<'tcx> {\n+pub struct VariantData {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n-    pub evaluated_discr: Option<ConstVal<'tcx>>,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n     pub struct_ctor: Option<DefIndex>,\n }\n \n-impl_stable_hash_for!(struct VariantData<'tcx> {\n+impl_stable_hash_for!(struct VariantData {\n     ctor_kind,\n     discr,\n-    evaluated_discr,\n     struct_ctor\n });\n "}, {"sha": "87ca410dece0dcee116b43653044c586653712f5", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -41,8 +41,6 @@\n //!   used unboxed and any field can have pointers (including mutable)\n //!   taken to it, implementing them for Rust seems difficult.\n \n-use super::Disr;\n-\n use std;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n@@ -347,31 +345,31 @@ fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {\n+pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: u64) {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n-            assert_discr_in_range(Disr(min), Disr(max), to);\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n+            assert_discr_in_range(min, max, to);\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n                   val, None);\n         }\n         layout::General{ discr, .. } => {\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n                   bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n         | layout::UntaggedUnion { .. }\n         | layout::Vector { .. } => {\n-            assert_eq!(to, Disr(0));\n+            assert_eq!(to, 0);\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            if to.0 != nndiscr {\n+            if to != nndiscr {\n                 let llptrty = val_ty(val).element_type();\n                 bcx.store(C_null(llptrty), val, None);\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n-            if to.0 != nndiscr {\n+            if to != nndiscr {\n                 if target_sets_discr_via_memset(bcx) {\n                     // Issue #34427: As workaround for LLVM bug on\n                     // ARM, use memset of 0 on whole struct rather\n@@ -397,7 +395,7 @@ fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n-pub fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n+pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n     if min <= max {\n         assert!(min <= discr && discr <= max)\n     } else {\n@@ -415,7 +413,7 @@ fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                       val: ValueRef, _discr: Disr,\n+                       val: ValueRef,\n                        ix: usize) -> ValueRef {\n     let l = ccx.layout_of(t);\n     match *l {"}, {"sha": "a940faac8387735a7288f915564ea3b1dc0f88a0", "filename": "src/librustc_trans/disr.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/63064ec190fef7947c3eabfcdfeaeb293c9a91dd/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63064ec190fef7947c3eabfcdfeaeb293c9a91dd/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=63064ec190fef7947c3eabfcdfeaeb293c9a91dd", "patch": "@@ -1,82 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::{self, TyCtxt};\n-use rustc_const_math::ConstInt;\n-\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub struct Disr(pub u64);\n-\n-impl Disr {\n-    pub fn for_variant(tcx: TyCtxt,\n-                       def: &ty::AdtDef,\n-                       variant_index: usize) -> Self {\n-        let mut explicit_index = variant_index;\n-        let mut explicit_value = Disr(0);\n-        loop {\n-            match def.variants[explicit_index].discr {\n-                ty::VariantDiscr::Relative(0) => break,\n-                ty::VariantDiscr::Relative(distance) => {\n-                    explicit_index -= distance;\n-                }\n-                ty::VariantDiscr::Explicit(expr_did) => {\n-                    match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n-                        Ok(ConstVal::Integral(v)) => {\n-                            explicit_value = Disr::from(v);\n-                            break;\n-                        }\n-                        _ => {\n-                            explicit_index -= 1;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        let distance = variant_index - explicit_index;\n-        explicit_value.wrapping_add(Disr::from(distance))\n-    }\n-\n-    pub fn wrapping_add(self, other: Self) -> Self {\n-        Disr(self.0.wrapping_add(other.0))\n-    }\n-}\n-\n-impl ::std::ops::BitAnd for Disr {\n-    type Output = Disr;\n-    fn bitand(self, other: Self) -> Self {\n-        Disr(self.0 & other.0)\n-    }\n-}\n-\n-impl From<ConstInt> for Disr {\n-    fn from(i: ConstInt) -> Disr {\n-        // FIXME: what if discr has 128 bit discr?\n-        Disr(i.to_u128_unchecked() as u64)\n-    }\n-}\n-\n-impl From<usize> for Disr {\n-    fn from(i: usize) -> Disr {\n-        Disr(i as u64)\n-    }\n-}\n-\n-impl PartialOrd for Disr {\n-    fn partial_cmp(&self, other: &Disr) -> Option<::std::cmp::Ordering> {\n-        self.0.partial_cmp(&other.0)\n-    }\n-}\n-\n-impl Ord for Disr {\n-    fn cmp(&self, other: &Disr) -> ::std::cmp::Ordering {\n-        self.0.cmp(&other.0)\n-    }\n-}"}, {"sha": "be214a0f6143cdb5b751fdddd9fbc3e851d6c127", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -67,7 +67,6 @@ pub use rustc::lint;\n pub use rustc::util;\n \n pub use base::trans_crate;\n-pub use disr::Disr;\n \n pub mod back {\n     pub use rustc::hir::svh;\n@@ -118,7 +117,6 @@ mod consts;\n mod context;\n mod debuginfo;\n mod declare;\n-mod disr;\n mod glue;\n mod intrinsic;\n mod machine;"}, {"sha": "8bce0cf85c08bf57184704e1ea55a88fc69c489a", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use {abi, adt, base, Disr, machine};\n+use {abi, adt, base, machine};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n@@ -428,7 +428,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let llprojected = adt::const_get_field(self.ccx, tr_base.ty, base.llval,\n-                                                               Disr(0), field.index());\n+                                                               field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()\n                         } else {\n@@ -987,13 +987,14 @@ fn trans_const<'a, 'tcx>(\n         layout::CEnum { discr: d, min, max, .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    Disr::for_variant(ccx.tcx(), adt_def, variant_index)\n+                    adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n+                           .to_u128_unchecked() as u64\n                 },\n-                _ => Disr(0),\n+                _ => 0,\n             };\n             assert_eq!(vals.len(), 0);\n-            adt::assert_discr_in_range(Disr(min), Disr(max), discr);\n-            C_integral(Type::from_integer(ccx, d), discr.0, true)\n+            adt::assert_discr_in_range(min, max, discr);\n+            C_integral(Type::from_integer(ccx, d), discr, true)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];"}, {"sha": "98e9008f829f683fbbcea1e6b9f63e9ad8a6dd41", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -28,7 +28,6 @@ use type_::Type;\n use type_of;\n use tvec;\n use value::Value;\n-use Disr;\n \n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n@@ -107,9 +106,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n-                        let disr = Disr::for_variant(bcx.tcx(), adt_def, variant_index);\n+                        let discr = adt_def.discriminant_for_variant(bcx.tcx(), variant_index)\n+                           .to_u128_unchecked() as u64;\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, disr);\n+                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, discr);\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields."}, {"sha": "52c2afca4748bda2566c91a0370737eab75e9663", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -18,7 +18,6 @@ use builder::Builder;\n use super::MirContext;\n use super::LocalRef;\n use super::super::adt;\n-use super::super::disr::Disr;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n@@ -65,7 +64,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 adt::trans_set_discr(&bcx,\n                     ty,\n                     lvalue_transed.llval,\n-                    Disr::from(variant_index));\n+                    variant_index as u64);\n                 bcx\n             }\n             mir::StatementKind::StorageLive(ref lvalue) => {"}, {"sha": "0f734683b60e58490286f961a7c1b711545f8227", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "patch": "@@ -27,6 +27,7 @@\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n #![crate_type=\"rlib\"]\n \n \n@@ -125,9 +126,12 @@ enum EnumChangeValueCStyleVariant0 {\n enum EnumChangeValueCStyleVariant0 {\n     Variant1,\n \n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n-    Variant2 = 22,\n+    Variant2 =\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        22,\n }\n \n #[cfg(cfail1)]"}]}