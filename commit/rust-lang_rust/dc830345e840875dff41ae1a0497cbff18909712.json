{"sha": "dc830345e840875dff41ae1a0497cbff18909712", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjODMwMzQ1ZTg0MDg3NWRmZjQxYWUxYTA0OTdjYmZmMTg5MDk3MTI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-29T05:35:38Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-30T07:41:09Z"}, "message": "Remove @muts from ExtCtxt", "tree": {"sha": "6729666735de195425ee3bf45e35a8a1d471de9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6729666735de195425ee3bf45e35a8a1d471de9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc830345e840875dff41ae1a0497cbff18909712", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc830345e840875dff41ae1a0497cbff18909712", "html_url": "https://github.com/rust-lang/rust/commit/dc830345e840875dff41ae1a0497cbff18909712", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc830345e840875dff41ae1a0497cbff18909712/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8143662836ccecca0b1f177f0c12528a4aa74c0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8143662836ccecca0b1f177f0c12528a4aa74c0d", "html_url": "https://github.com/rust-lang/rust/commit/8143662836ccecca0b1f177f0c12528a4aa74c0d"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "6193e5e8fa1f68330856064265b97a267fd734f6", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc830345e840875dff41ae1a0497cbff18909712/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc830345e840875dff41ae1a0497cbff18909712/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=dc830345e840875dff41ae1a0497cbff18909712", "patch": "@@ -63,7 +63,7 @@ pub fn modify_for_testing(sess: session::Session,\n }\n \n struct TestHarnessGenerator {\n-    cx: @TestCtxt,\n+    cx: TestCtxt,\n }\n \n impl fold::ast_fold for TestHarnessGenerator {\n@@ -73,7 +73,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n         ast::Crate {\n-            module: add_test_module(self.cx, &folded.module),\n+            module: add_test_module(&self.cx, &folded.module),\n             .. folded\n         }\n     }\n@@ -86,7 +86,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.get()));\n \n-        if is_test_fn(self.cx, i) || is_bench_fn(i) {\n+        if is_test_fn(&self.cx, i) || is_bench_fn(i) {\n             match i.node {\n                 ast::item_fn(_, purity, _, _, _)\n                     if purity == ast::unsafe_fn => {\n@@ -101,7 +101,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                         span: i.span,\n                         path: self.cx.path.get(),\n                         bench: is_bench_fn(i),\n-                        ignore: is_ignored(self.cx, i),\n+                        ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)\n                     };\n                     {\n@@ -126,7 +126,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(cx: @TestCtxt, item: @ast::item) -> @ast::item {\n+        fn nomain(cx: &TestCtxt, item: @ast::item) -> @ast::item {\n             if !cx.sess.building_library.get() {\n                 @ast::item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n@@ -145,7 +145,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n         let mod_nomain = ast::_mod {\n             view_items: m.view_items.clone(),\n-            items: m.items.iter().map(|i| nomain(self.cx, *i)).collect(),\n+            items: m.items.iter().map(|i| nomain(&self.cx, *i)).collect(),\n         };\n \n         fold::noop_fold_mod(&mod_nomain, self)\n@@ -154,7 +154,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n                          -> ast::Crate {\n-    let cx: @TestCtxt = @TestCtxt {\n+    let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone()),\n         path: RefCell::new(~[]),\n@@ -176,7 +176,7 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n         cx: cx\n     };\n     let res = fold.fold_crate(crate);\n-    cx.ext_cx.bt_pop();\n+    fold.cx.ext_cx.bt_pop();\n     return res;\n }\n \n@@ -189,7 +189,7 @@ fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: @TestCtxt, i: @ast::item) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs, \"test\");\n \n     fn has_test_signature(i: @ast::item) -> bool {\n@@ -242,7 +242,7 @@ fn is_bench_fn(i: @ast::item) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: @TestCtxt, i: @ast::item) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: @ast::item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {"}, {"sha": "ccbc533fbcc72ead619e10bca7c3ae4b8fc74d4d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dc830345e840875dff41ae1a0497cbff18909712/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc830345e840875dff41ae1a0497cbff18909712/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dc830345e840875dff41ae1a0497cbff18909712", "patch": "@@ -297,15 +297,15 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt {\n     parse_sess: @mut parse::ParseSess,\n     cfg: ast::CrateConfig,\n-    backtrace: @mut Option<@ExpnInfo>,\n+    backtrace: Option<@ExpnInfo>,\n \n     // These two @mut's should really not be here,\n     // but the self types for CtxtRepr are all wrong\n     // and there are bugs in the code for object\n     // types that make this hard to get right at the\n     // moment. - nmatsakis\n-    mod_path: @mut ~[ast::Ident],\n-    trace_mac: @mut bool\n+    mod_path: ~[ast::Ident],\n+    trace_mac: bool\n }\n \n impl ExtCtxt {\n@@ -314,9 +314,9 @@ impl ExtCtxt {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: @mut None,\n-            mod_path: @mut ~[],\n-            trace_mac: @mut false\n+            backtrace: None,\n+            mod_path: ~[],\n+            trace_mac: false\n         }\n     }\n \n@@ -339,32 +339,32 @@ impl ExtCtxt {\n     pub fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        match *self.backtrace {\n+        match self.backtrace {\n             Some(@ExpnInfo {call_site: cs, ..}) => cs,\n             None => self.bug(\"missing top span\")\n         }\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n-    pub fn mod_push(&self, i: ast::Ident) { self.mod_path.push(i); }\n-    pub fn mod_pop(&self) { self.mod_path.pop(); }\n-    pub fn mod_path(&self) -> ~[ast::Ident] { (*self.mod_path).clone() }\n-    pub fn bt_push(&self, ei: codemap::ExpnInfo) {\n+    pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n+    pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n+    pub fn mod_pop(&mut self) { self.mod_path.pop(); }\n+    pub fn mod_path(&self) -> ~[ast::Ident] { self.mod_path.clone() }\n+    pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n-                *self.backtrace =\n+                self.backtrace =\n                     Some(@ExpnInfo {\n                         call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: *self.backtrace},\n+                                         expn_info: self.backtrace},\n                         callee: *callee});\n             }\n         }\n     }\n-    pub fn bt_pop(&self) {\n-        match *self.backtrace {\n+    pub fn bt_pop(&mut self) {\n+        match self.backtrace {\n             Some(@ExpnInfo {\n                 call_site: Span {expn_info: prev, ..}, ..}) => {\n-                *self.backtrace = prev\n+                self.backtrace = prev\n             }\n             _ => self.bug(\"tried to pop without a push\")\n         }\n@@ -394,10 +394,10 @@ impl ExtCtxt {\n         self.parse_sess.span_diagnostic.handler().bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n-        *self.trace_mac\n+        self.trace_mac\n     }\n-    pub fn set_trace_macros(&self, x: bool) {\n-        *self.trace_mac = x\n+    pub fn set_trace_macros(&mut self, x: bool) {\n+        self.trace_mac = x\n     }\n     pub fn str_of(&self, id: ast::Ident) -> @str {\n         ident_to_str(&id)"}]}