{"sha": "fc0fb0328b8d38e7e6d7f719555c990e0842820d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMGZiMDMyOGI4ZDM4ZTdlNmQ3ZjcxOTU1NWM5OTBlMDg0MjgyMGQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-06-30T20:44:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-30T20:44:43Z"}, "message": "Rollup merge of #42669 - gaurikholkar:master, r=nikomatsakis\n\nAdding diagnostic code 0611 for lifetime errors with one named, one anonymous lifetime parameter\n\nThis is a fix for #42517\nNote that this only handles the above case for **function declarations** and **traits**.\n`impl items` and `closures` will be handled in a later PR.\nExample\n```\nfn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n    if x > y { x } else { y }\n}\n```\nnow displays the following error message. ui tests have been added for the same.\n```\nerror[E0611]: explicit lifetime required in the type of `x`\n11 | fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n   |                     ^ consider changing the type of `x` to `&'a i32`\n12 |     if x > y { x } else { y }\n   |                  - lifetime `'a` required\n```\n#42516\nr? @nikomatsakis", "tree": {"sha": "2e09a2cf1abe76f311aa9056714e3c1e58c739a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e09a2cf1abe76f311aa9056714e3c1e58c739a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc0fb0328b8d38e7e6d7f719555c990e0842820d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc0fb0328b8d38e7e6d7f719555c990e0842820d", "html_url": "https://github.com/rust-lang/rust/commit/fc0fb0328b8d38e7e6d7f719555c990e0842820d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc0fb0328b8d38e7e6d7f719555c990e0842820d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e72580cf091190c6258648e4cfbca083f20ece3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72580cf091190c6258648e4cfbca083f20ece3d", "html_url": "https://github.com/rust-lang/rust/commit/e72580cf091190c6258648e4cfbca083f20ece3d"}, {"sha": "37a88f478dd80404b7b8c3890db96f5850ecd7bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a88f478dd80404b7b8c3890db96f5850ecd7bf", "html_url": "https://github.com/rust-lang/rust/commit/37a88f478dd80404b7b8c3890db96f5850ecd7bf"}], "stats": {"total": 666, "additions": 615, "deletions": 51}, "files": [{"sha": "035640b9710e27302007af8ef3d286f6e267c7a4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -1946,6 +1946,44 @@ Maybe you just misspelled the lint name or the lint doesn't exist anymore.\n Either way, try to update/remove it in order to fix the error.\n \"##,\n \n+E0621: r##\"\n+This error code indicates a mismatch between the function signature (i.e.,\n+the parameter types and the return type) and the function body. Most of\n+the time, this indicates that the function signature needs to be changed to\n+match the body, but it may be that the body needs to be changed to match\n+the signature.\n+\n+Specifically, one or more of the parameters contain borrowed data that\n+needs to have a named lifetime in order for the body to type-check. Most of\n+the time, this is because the borrowed data is being returned from the\n+function, as in this example:\n+\n+```compile_fail,E0621\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // explicit lifetime required\n+                                             // in the type of `y`\n+    if x > y { x } else { y }\n+}\n+```\n+\n+Here, the function is returning data borrowed from either x or y, but the\n+'a annotation indicates that it is returning data only from x. We can make\n+the signature match the body by changing the type of y to &'a i32, like so:\n+\n+```\n+fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+```\n+\n+Alternatively, you could change the body not to return data from y:\n+\n+```\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+    x\n+}\n+```\n+\"##,\n+\n }\n \n "}, {"sha": "82bbb4a1bf5159db048cf4d43fc2af7309ed3fc6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -72,9 +72,11 @@ use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n-\n mod note;\n+\n mod need_type_info;\n+mod named_anon_conflict;\n+\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -255,34 +257,48 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_region_errors(&self,\n-                                errors: &Vec<RegionResolutionError<'tcx>>) {\n+\n+    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);\n \n-        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+        debug!(\"report_region_errors: {} errors after preprocessing\",\n+               errors.len());\n \n         for error in errors {\n+\n             debug!(\"report_region_errors: error = {:?}\", error);\n-            match error.clone() {\n-                ConcreteFailure(origin, sub, sup) => {\n-                    self.report_concrete_failure(origin, sub, sup).emit();\n-                }\n \n-                GenericBoundFailure(kind, param_ty, sub) => {\n-                    self.report_generic_bound_failure(kind, param_ty, sub);\n-                }\n+            if !self.try_report_named_anon_conflict(&error){\n+\n+               match error.clone() {\n+                  // These errors could indicate all manner of different\n+                  // problems with many different solutions. Rather\n+                  // than generate a \"one size fits all\" error, what we\n+                  // attempt to do is go through a number of specific\n+                  // scenarios and try to find the best way to present\n+                  // the error. If all of these fails, we fall back to a rather\n+                  // general bit of code that displays the error information\n+                  ConcreteFailure(origin, sub, sup) => {\n+\n+                      self.report_concrete_failure(origin, sub, sup).emit();\n+                  }\n \n-                SubSupConflict(var_origin,\n+                  GenericBoundFailure(kind, param_ty, sub) => {\n+                      self.report_generic_bound_failure(kind, param_ty, sub);\n+                  }\n+\n+                  SubSupConflict(var_origin,\n                                sub_origin, sub_r,\n                                sup_origin, sup_r) => {\n-                    self.report_sub_sup_conflict(var_origin,\n+                      self.report_sub_sup_conflict(var_origin,\n                                                  sub_origin, sub_r,\n                                                  sup_origin, sup_r);\n-                }\n+                  }\n+               }\n             }\n         }\n     }"}, {"sha": "ccbc5cdb862f98eb96f26880a857b7091d3cbef9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error Reporting for Anonymous Region Lifetime Errors.\n+use hir;\n+use infer::InferCtxt;\n+use ty::{self, Region};\n+use infer::region_inference::RegionResolutionError::*;\n+use infer::region_inference::RegionResolutionError;\n+use hir::map as hir_map;\n+use hir::def_id::DefId;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    // This method walks the Type of the function body arguments using\n+    // `fold_regions()` function and returns the\n+    // &hir::Arg of the function argument corresponding to the anonymous\n+    // region and the Ty corresponding to the named region.\n+    // Currently only the case where the function declaration consists of\n+    // one named region and one anonymous region is handled.\n+    // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n+    // Here, we would return the hir::Arg for y, we return the type &'a\n+    // i32, which is the type of y but with the anonymous region replaced\n+    // with 'a, the corresponding bound region and is_first which is true if\n+    // the hir::Arg is the first argument in the function declaration.\n+    fn find_arg_with_anonymous_region\n+        (&self,\n+         anon_region: Region<'tcx>,\n+         named_region: Region<'tcx>)\n+         -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion, bool)> {\n+\n+        match *anon_region {\n+            ty::ReFree(ref free_region) => {\n+\n+                let id = free_region.scope;\n+                let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n+                let body_id = self.tcx.hir.maybe_body_owned_by(node_id).unwrap();\n+                let body = self.tcx.hir.body(body_id);\n+                if let Some(tables) = self.in_progress_tables {\n+                    body.arguments\n+                        .iter()\n+                        .enumerate()\n+                        .filter_map(|(index, arg)| {\n+                            let ty = tables.borrow().node_id_to_type(arg.id);\n+                            let mut found_anon_region = false;\n+                            let new_arg_ty = self.tcx\n+                                .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n+                                    found_anon_region = true;\n+                                    named_region\n+                                } else {\n+                                    r\n+                                });\n+                            if found_anon_region {\n+                                let is_first = index == 0;\n+                                Some((arg, new_arg_ty, free_region.bound_region, is_first))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .next()\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+\n+        }\n+    }\n+\n+    // This method generates the error message for the case when\n+    // the function arguments consist of a named region and an anonymous\n+    // region and corresponds to `ConcreteFailure(..)`\n+    pub fn try_report_named_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n+\n+        let (span, sub, sup) = match *error {\n+            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n+            _ => return false, // inapplicable\n+        };\n+\n+        // Determine whether the sub and sup consist of one named region ('a)\n+        // and one anonymous (elided) region. If so, find the parameter arg\n+        // where the anonymous region appears (there must always be one; we\n+        // only introduced anonymous regions in parameters) as well as a\n+        // version new_ty of its type where the anonymous region is replaced\n+        // with the named one.\n+        let (named, (arg, new_ty, br, is_first), scope_def_id) =\n+            if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n+                (sub,\n+                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n+                 self.is_suitable_anonymous_region(sup).unwrap())\n+            } else if sup.is_named_region() && self.is_suitable_anonymous_region(sub).is_some() {\n+                (sup,\n+                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n+                 self.is_suitable_anonymous_region(sub).unwrap())\n+            } else {\n+                return false; // inapplicable\n+            };\n+\n+        // Here, we check for the case where the anonymous region\n+        // is in the return type.\n+        // FIXME(#42703) - Need to handle certain cases here.\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(self.tcx);\n+                let late_bound_regions = self.tcx\n+                    .collect_referenced_late_bound_regions(&sig.output());\n+                if late_bound_regions.iter().any(|r| *r == br) {\n+                    return false;\n+                } else {\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // Here we check for the case where anonymous region\n+        // corresponds to self and if yes, we display E0312.\n+        // FIXME(#42700) - Need to format self properly to\n+        // enable E0621 for it.\n+        if is_first &&\n+           self.tcx\n+               .opt_associated_item(scope_def_id)\n+               .map(|i| i.method_has_self_argument)\n+               .unwrap_or(false) {\n+            return false;\n+        }\n+\n+        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n+        } else {\n+            (format!(\"parameter type\"), format!(\"type\"))\n+        };\n+\n+\n+        struct_span_err!(self.tcx.sess,\n+                         span,\n+                         E0621,\n+                         \"explicit lifetime required in {}\",\n+                         error_var)\n+                .span_label(arg.pat.span,\n+                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                .span_label(span, format!(\"lifetime `{}` required\", named))\n+                .emit();\n+\n+        return true;\n+\n+    }\n+\n+    // This method returns whether the given Region is Anonymous\n+    // and returns the DefId corresponding to the region.\n+    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<DefId> {\n+\n+        match *region {\n+            ty::ReFree(ref free_region) => {\n+                match free_region.bound_region {\n+                    ty::BrAnon(..) => {\n+                        let anonymous_region_binding_scope = free_region.scope;\n+                        let node_id = self.tcx\n+                            .hir\n+                            .as_local_node_id(anonymous_region_binding_scope)\n+                            .unwrap();\n+                        match self.tcx.hir.find(node_id) {\n+                            Some(hir_map::NodeItem(..)) |\n+                            Some(hir_map::NodeTraitItem(..)) => {\n+                                // proceed ahead //\n+                            }\n+                            Some(hir_map::NodeImplItem(..)) => {\n+                                let container_id = self.tcx\n+                                    .associated_item(anonymous_region_binding_scope)\n+                                    .container\n+                                    .id();\n+                                if self.tcx.impl_trait_ref(container_id).is_some() {\n+                                    // For now, we do not try to target impls of traits. This is\n+                                    // because this message is going to suggest that the user\n+                                    // change the fn signature, but they may not be free to do so,\n+                                    // since the signature must match the trait.\n+                                    //\n+                                    // FIXME(#42706) -- in some cases, we could do better here.\n+                                    return None;\n+                                }\n+                            }\n+                            _ => return None, // inapplicable\n+                            // we target only top-level functions\n+                        }\n+                        return Some(anonymous_region_binding_scope);\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "5cb1606da6708bac132f6ea39d5ec936f2df412c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -38,7 +38,6 @@ use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n use util::nodemap::FxHashMap;\n use arena::DroplessArena;\n-\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -1077,6 +1076,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                region_map,\n                                                free_regions);\n         let errors = self.region_vars.resolve_regions(&region_rels);\n+\n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while"}, {"sha": "452775e9e13379f45c0c74ffbfde85ad42b2ba51", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -990,6 +990,20 @@ impl RegionKind {\n \n         flags\n     }\n+\n+    // This method returns whether the given Region is Named\n+    pub fn is_named_region(&self) -> bool {\n+\n+        match *self {\n+            ty::ReFree(ref free_region) => {\n+                match free_region.bound_region {\n+                    ty::BrNamed(..) => true,\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n }\n \n /// Type utilities"}, {"sha": "980461bedae55446604d8c635416d466aa1faf00", "filename": "src/test/compile-fail/E0621-does-not-trigger-for-closures.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fcompile-fail%2FE0621-does-not-trigger-for-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fcompile-fail%2FE0621-does-not-trigger-for-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0621-does-not-trigger-for-closures.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we give the generic E0495 when one of the free regions is\n+// bound in a closure (rather than suggesting a change to the signature\n+// of the closure, which is not specified in `foo` but rather in `invoke`).\n+\n+// FIXME - This might be better as a UI test, but the finer details\n+// of the error seem to vary on different machines.\n+fn invoke<'a, F>(x: &'a i32, f: F) -> &'a i32\n+where F: FnOnce(&'a i32, &i32) -> &'a i32\n+{\n+    let y = 22;\n+    f(x, &y)\n+}\n+\n+fn foo<'a>(x: &'a i32) {\n+    invoke(&x, |a, b| if a > b { a } else { b }); //~ ERROR E0495\n+}\n+\n+fn main() {}"}, {"sha": "a1716c4e797922d00a34bfa3b59499a7e185137f", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-2.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "4d8c5e039af418846ed2476fe098e08ce4ddc445", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-2.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,10 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/ex1-return-one-existing-name-if-else-2.rs:12:16\n+   |\n+11 | fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+   |            - consider changing the type of `x` to `&'a i32`\n+12 |     if x > y { x } else { y }\n+   |                ^ lifetime `'a` required\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "7bd32d8761705d073c4859cd8922350227a26dc4", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a>((x, y): (&'a i32, &i32)) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main () { }"}, {"sha": "07b276601f47cef82517949e2908b28265b3f0ea", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,10 @@\n+error[E0621]: explicit lifetime required in parameter type\n+  --> $DIR/ex1-return-one-existing-name-if-else-3.rs:12:27\n+   |\n+11 | fn foo<'a>((x, y): (&'a i32, &i32)) -> &'a i32 {\n+   |            ------ consider changing type to `(&'a i32, &'a i32)`\n+12 |     if x > y { x } else { y }\n+   |                           ^ lifetime `'a` required\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "8849f7084b3cde174c71cd38664f968048849e1d", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-2.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+\n+fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+   if x > y { x } else { y }\n+   }\n+}\n+\n+fn main() { }"}, {"sha": "2adf0cd762c59b342f855438fbe5b3310b256f61", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-2.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,10 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/ex1-return-one-existing-name-if-else-using-impl-2.rs:14:15\n+   |\n+13 | fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+   |            - consider changing the type of `x` to `&'a i32`\n+14 |    if x > y { x } else { y }\n+   |               ^ lifetime `'a` required\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "362290ff3fa7d9cd5f7e52229e3648ca0939d67c", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl-3.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  field: i32\n+}\n+\n+impl Foo {\n+  fn foo<'a>(&'a self, x: &i32) -> &i32 {\n+\n+    if true { &self.field } else { x }\n+\n+  }\n+\n+}\n+\n+fn main() { }"}, {"sha": "15825017d15c3edd9aada9447f00ee275a5435e9", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl-3.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,11 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/ex1-return-one-existing-name-if-else-using-impl-3.rs:18:36\n+   |\n+16 |   fn foo<'a>(&'a self, x: &i32) -> &i32 {\n+   |                        - consider changing the type of `x` to `&'a i32`\n+17 | \n+18 |     if true { &self.field } else { x }\n+   |                                    ^ lifetime `'a` required\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "36d956a39966f53a88721bcf2014ac0ec9dcb76c", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+\n+    fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32;\n+\n+}\n+\n+impl Foo for () {\n+\n+    fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+\n+        if x > y { x } else { y }\n+\n+    }\n+\n+}\n+\n+fn main() {}"}, {"sha": "15ecca618052e25ce49b1b907b04dbda29e0a7c8", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,27 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-if-else-using-impl.rs:21:20\n+   |\n+21 |         if x > y { x } else { y }\n+   |                    ^\n+   |\n+note: ...the reference is valid for the lifetime 'a as defined on the method body at 19:5...\n+  --> $DIR/ex1-return-one-existing-name-if-else-using-impl.rs:19:5\n+   |\n+19 | /     fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+20 | |\n+21 | |         if x > y { x } else { y }\n+22 | |\n+23 | |     }\n+   | |_____^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body at 19:5\n+  --> $DIR/ex1-return-one-existing-name-if-else-using-impl.rs:19:5\n+   |\n+19 | /     fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32 {\n+20 | |\n+21 | |         if x > y { x } else { y }\n+22 | |\n+23 | |     }\n+   | |_____^\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "892a6dcd1e9346bf414746f577dac32d9ea6ec40", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -1,23 +1,10 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0621]: explicit lifetime required in the type of `y`\n   --> $DIR/ex1-return-one-existing-name-if-else.rs:12:27\n    |\n+11 | fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |                        - consider changing the type of `y` to `&'a i32`\n 12 |     if x > y { x } else { y }\n-   |                           ^\n-   |\n-note: ...the reference is valid for the lifetime 'a as defined on the function body at 11:1...\n-  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:1\n-   |\n-11 | / fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-12 | |     if x > y { x } else { y }\n-13 | | }\n-   | |_^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the function body at 11:1\n-  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:1\n-   |\n-11 | / fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-12 | |     if x > y { x } else { y }\n-13 | | }\n-   | |_^\n+   |                           ^ lifetime `'a` required\n \n error: aborting due to previous error(s)\n "}, {"sha": "96b733be9b4eb5c4adf22a89f4cf6846ad561f04", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  field: i32\n+}\n+\n+impl Foo {\n+  fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+\n+    x\n+\n+  }\n+\n+}\n+\n+fn main() { }"}, {"sha": "471b3401827d8106050281770a56350fa5b091d4", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,27 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:18:5\n+   |\n+18 |     x\n+   |     ^\n+   |\n+note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n+  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+17 | |\n+18 | |     x\n+19 | |\n+20 | |   }\n+   | |___^\n+note: ...but the borrowed content is only valid for the lifetime 'a as defined on the method body at 16:3\n+  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n+   |\n+16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+17 | |\n+18 | |     x\n+19 | |\n+20 | |   }\n+   | |___^\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "a8ce60c47b6f528ed26e096339080a584af5f600", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-self-is-anon.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    field: i32,\n+}\n+\n+impl Foo {\n+    fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+\n+        if true { x } else { self }\n+\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "46fc43eaf5756fa0524dca41aab65e33f554f38b", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-self-is-anon.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,27 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:18:30\n+   |\n+18 |         if true { x } else { self }\n+   |                              ^^^^\n+   |\n+note: ...the reference is valid for the lifetime 'a as defined on the method body at 16:5...\n+  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+17 | |\n+18 | |         if true { x } else { self }\n+19 | |\n+20 | |     }\n+   | |_____^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body at 16:5\n+  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+17 | |\n+18 | |         if true { x } else { self }\n+19 | |\n+20 | |     }\n+   | |_____^\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "dd34e1aa6d9d227e7377d4d58dd850eeeeea87c9", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.rs?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a>(x: Ref<i32>, y: &mut Vec<Ref<'a, i32>>) {\n+    y.push(x);\n+}\n+\n+fn main() { }"}, {"sha": "ea696c51d62188ece63e4d106e3b6f612d02e005", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name-2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -0,0 +1,10 @@\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/ex2a-push-one-existing-name-2.rs:16:12\n+   |\n+15 | fn foo<'a>(x: Ref<i32>, y: &mut Vec<Ref<'a, i32>>) {\n+   |            - consider changing the type of `x` to `Ref<'a, i32>`\n+16 |     y.push(x);\n+   |            ^ lifetime `'a` required\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "1630ae32ba6bf65d7f48bbfac1e4e726a70ba66a", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc0fb0328b8d38e7e6d7f719555c990e0842820d/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=fc0fb0328b8d38e7e6d7f719555c990e0842820d", "patch": "@@ -1,25 +1,10 @@\n-error[E0308]: mismatched types\n+error[E0621]: explicit lifetime required in the type of `y`\n   --> $DIR/ex2a-push-one-existing-name.rs:16:12\n    |\n+15 | fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |                                       - consider changing the type of `y` to `Ref<'a, i32>`\n 16 |     x.push(y);\n-   |            ^ lifetime mismatch\n-   |\n-   = note: expected type `Ref<'a, _>`\n-              found type `Ref<'_, _>`\n-note: the anonymous lifetime #2 defined on the function body at 15:1...\n-  --> $DIR/ex2a-push-one-existing-name.rs:15:1\n-   |\n-15 | / fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-16 | |     x.push(y);\n-17 | | }\n-   | |_^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the function body at 15:1\n-  --> $DIR/ex2a-push-one-existing-name.rs:15:1\n-   |\n-15 | / fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-16 | |     x.push(y);\n-17 | | }\n-   | |_^\n+   |            ^ lifetime `'a` required\n \n error: aborting due to previous error(s)\n "}]}