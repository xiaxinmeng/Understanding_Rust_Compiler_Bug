{"sha": "e034a43a8b1b77e76f90fe60692faf694c75c9e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMzRhNDNhOGIxYjc3ZTc2ZjkwZmU2MDY5MmZhZjY5NGM3NWM5ZTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-23T23:43:23Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-23T23:43:23Z"}, "message": "Merge remote-tracking branch 'brson/iodoc'", "tree": {"sha": "839d55b7d541b3a14a85af45a1a96e51deca2a38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/839d55b7d541b3a14a85af45a1a96e51deca2a38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e034a43a8b1b77e76f90fe60692faf694c75c9e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e034a43a8b1b77e76f90fe60692faf694c75c9e5", "html_url": "https://github.com/rust-lang/rust/commit/e034a43a8b1b77e76f90fe60692faf694c75c9e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e034a43a8b1b77e76f90fe60692faf694c75c9e5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feac422dd4c3bee437a53938c896cd1da45aff04", "url": "https://api.github.com/repos/rust-lang/rust/commits/feac422dd4c3bee437a53938c896cd1da45aff04", "html_url": "https://github.com/rust-lang/rust/commit/feac422dd4c3bee437a53938c896cd1da45aff04"}, {"sha": "a8941c3e04fc7900c3e9a4e82b6a63bc9018c769", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8941c3e04fc7900c3e9a4e82b6a63bc9018c769", "html_url": "https://github.com/rust-lang/rust/commit/a8941c3e04fc7900c3e9a4e82b6a63bc9018c769"}], "stats": {"total": 167, "additions": 41, "deletions": 126}, "files": [{"sha": "91a8d59932689b2dfcb6212e6f0be997b5ff17ef", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 41, "deletions": 126, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e034a43a8b1b77e76f90fe60692faf694c75c9e5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e034a43a8b1b77e76f90fe60692faf694c75c9e5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e034a43a8b1b77e76f90fe60692faf694c75c9e5", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Synchronous I/O\n+// FIXME: cover these topics:\n+//        path, reader, writer, stream, raii (close not needed),\n+//        stdio, print!, println!, file access, process spawning,\n+//        error handling\n \n-This module defines the Rust interface for synchronous I/O.\n-It models byte-oriented input and output with the Reader and Writer traits.\n-Types that implement both `Reader` and `Writer` are called 'streams',\n-and automatically implement the `Stream` trait.\n-Implementations are provided for common I/O streams like\n-file, TCP, UDP, Unix domain sockets.\n-Readers and Writers may be composed to add capabilities like string\n-parsing, encoding, and compression.\n+\n+/*! I/O, including files, networking, timers, and processes\n+\n+`std::io` provides Rust's basic I/O types,\n+for reading and writing to files, TCP, UDP,\n+and other types of sockets and pipes,\n+manipulating the file system, spawning processes and signal handling.\n \n # Examples\n \n@@ -77,9 +79,7 @@ Some examples of obvious things you might want to do\n     let lines: ~[~str] = file.lines().collect();\n     ```\n \n-* Make a simple HTTP request\n-  FIXME This needs more improvement: TcpStream constructor taking &str,\n-  `write_str` and `write_line` methods.\n+* Make a simple TCP client connection and request\n \n     ```rust,should_fail\n     # #[allow(unused_must_use)];\n@@ -92,72 +92,35 @@ Some examples of obvious things you might want to do\n     let response = socket.read_to_end();\n     ```\n \n-* Connect based on URL? Requires thinking about where the URL type lives\n-  and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n-  yields a `TcpStream`.\n-  FIXME this is not implemented now.\n+* Make a simple TCP server\n \n     ```rust\n-    // connect(\"tcp://localhost:8080\");\n+    # fn main() { }\n+    # fn foo() {\n+    # #[allow(unused_must_use, dead_code)];\n+    use std::io::net::tcp::TcpListener;\n+    use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+    use std::io::{Acceptor, Listener};\n+\n+    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n+    let listener = TcpListener::bind(addr);\n+\n+    // bind the listener to the specified address\n+    let mut acceptor = listener.listen();\n+\n+    // accept connections and process them\n+    # fn handle_client<T>(_: T) {}\n+    for stream in acceptor.incoming() {\n+        spawn(proc() {\n+            handle_client(stream);\n+        });\n+    }\n+\n+    // close the socket server\n+    drop(acceptor);\n+    # }\n     ```\n \n-# Terms\n-\n-* Reader - An I/O source, reads bytes into a buffer\n-* Writer - An I/O sink, writes bytes from a buffer\n-* Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n-  and are collectively referred to a `streams`.\n-  such as encoding or decoding\n-\n-# Blocking and synchrony\n-\n-When discussing I/O you often hear the terms 'synchronous' and\n-'asynchronous', along with 'blocking' and 'non-blocking' compared and\n-contrasted. A synchronous I/O interface performs each I/O operation to\n-completion before proceeding to the next. Synchronous interfaces are\n-usually used in imperative style as a sequence of commands. An\n-asynchronous interface allows multiple I/O requests to be issued\n-simultaneously, without waiting for each to complete before proceeding\n-to the next.\n-\n-Asynchronous interfaces are used to achieve 'non-blocking' I/O. In\n-traditional single-threaded systems, performing a synchronous I/O\n-operation means that the program stops all activity (it 'blocks')\n-until the I/O is complete. Blocking is bad for performance when\n-there are other computations that could be done.\n-\n-Asynchronous interfaces are most often associated with the callback\n-(continuation-passing) style popularised by node.js. Such systems rely\n-on all computations being run inside an event loop which maintains a\n-list of all pending I/O events; when one completes the registered\n-callback is run and the code that made the I/O request continues.\n-Such interfaces achieve non-blocking at the expense of being more\n-difficult to reason about.\n-\n-Rust's I/O interface is synchronous - easy to read - and non-blocking by default.\n-\n-Remember that Rust tasks are 'green threads', lightweight threads that\n-are multiplexed onto a single operating system thread. If that system\n-thread blocks then no other task may proceed. Rust tasks are\n-relatively cheap to create, so as long as other tasks are free to\n-execute then non-blocking code may be written by simply creating a new\n-task.\n-\n-When discussing blocking in regards to Rust's I/O model, we are\n-concerned with whether performing I/O blocks other Rust tasks from\n-proceeding. In other words, when a task calls `read`, it must then\n-wait (or 'sleep', or 'block') until the call to `read` is complete.\n-During this time, other tasks may or may not be executed, depending on\n-how `read` is implemented.\n-\n-\n-Rust's default I/O implementation is non-blocking; by cooperating\n-directly with the task scheduler it arranges to never block progress\n-of *other* tasks. Under the hood, Rust uses asynchronous I/O via a\n-per-scheduler (and hence per-thread) event loop. Synchronous I/O\n-requests are implemented by descheduling the running task and\n-performing an asynchronous request; the task is only resumed once the\n-asynchronous request completes.\n \n # Error Handling\n \n@@ -170,10 +133,11 @@ Rust's I/O employs a combination of techniques to reduce boilerplate\n while still providing feedback about errors. The basic strategy:\n \n * All I/O operations return `IoResult<T>` which is equivalent to\n-  `Result<T, IoError>`. The core `Result` type is defined in the `std::result`\n+  `Result<T, IoError>`. The `Result` type is defined in the `std::result`\n   module.\n * If the `Result` type goes unused, then the compiler will by default emit a\n-  warning about the unused result.\n+  warning about the unused result. This is because `Result` has the\n+  `#[must_use]` attribute.\n * Common traits are implemented for `IoResult`, e.g.\n   `impl<R: Reader> Reader for IoResult<R>`, so that error values do not have\n   to be 'unwrapped' before use.\n@@ -192,7 +156,7 @@ If you wanted to handle the error though you might write:\n use std::io::File;\n \n match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n-    Ok(()) => { /* succeeded */ }\n+    Ok(()) => (), // succeeded\n     Err(e) => println!(\"failed to write to my diary: {}\", e),\n }\n \n@@ -208,55 +172,6 @@ need to inspect or unwrap the `IoResult<File>` and we simply call `write_line`\n on it. If `new` returned an `Err(..)` then the followup call to `write_line`\n will also return an error.\n \n-# Issues with i/o scheduler affinity, work stealing, task pinning\n-\n-# Resource management\n-\n-* `close` vs. RAII\n-\n-# Paths, URLs and overloaded constructors\n-\n-\n-\n-# Scope\n-\n-In scope for core\n-\n-* Url?\n-\n-Some I/O things don't belong in core\n-\n-  - url\n-  - net - `fn connect`\n-    - http\n-  - flate\n-\n-Out of scope\n-\n-* Async I/O. We'll probably want it eventually\n-\n-\n-# FIXME Questions and issues\n-\n-* Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n-  Overloading would be nice.\n-* Add overloading for Path and &str and Url &str\n-* stdin/err/out\n-* print, println, etc.\n-* fsync\n-* relationship with filesystem querying, Directory, File types etc.\n-* Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n-* Can Port and Chan be implementations of a generic Reader<T>/Writer<T>?\n-* Trait for things that are both readers and writers, Stream?\n-* How to handle newline conversion\n-* String conversion\n-* open vs. connect for generic stream opening\n-* Do we need `close` at all? dtors might be good enough\n-* How does I/O relate to the Iterator trait?\n-* std::base64 filters\n-* Using conditions is a big unknown since we don't have much experience with them\n-* Too many uses of OtherIoError\n-\n */\n \n #[allow(missing_doc)];"}]}