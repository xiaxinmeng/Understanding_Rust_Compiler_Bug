{"sha": "792899587647f5aa0293c2588173677682187c0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5Mjg5OTU4NzY0N2Y1YWEwMjkzYzI1ODgxNzM2Nzc2ODIxODdjMGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-28T18:34:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-28T18:34:58Z"}, "message": "nameify structs&enums", "tree": {"sha": "616bcd980ac69eb5070c1e7a6d90ebee71cb7348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/616bcd980ac69eb5070c1e7a6d90ebee71cb7348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/792899587647f5aa0293c2588173677682187c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/792899587647f5aa0293c2588173677682187c0a", "html_url": "https://github.com/rust-lang/rust/commit/792899587647f5aa0293c2588173677682187c0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/792899587647f5aa0293c2588173677682187c0a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11122e29b7ec5bc2e08822deaa6fdf9a1cc8ffca", "url": "https://api.github.com/repos/rust-lang/rust/commits/11122e29b7ec5bc2e08822deaa6fdf9a1cc8ffca", "html_url": "https://github.com/rust-lang/rust/commit/11122e29b7ec5bc2e08822deaa6fdf9a1cc8ffca"}], "stats": {"total": 100, "additions": 43, "deletions": 57}, "files": [{"sha": "e839a5a90d2e2bf1a4b96475fa410ed1fffad3a4", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=792899587647f5aa0293c2588173677682187c0a", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n-use ra_syntax::{SmolStr, ast::{self, NameOwner, StructFlavor}};\n+use ra_syntax::ast::{self, NameOwner, StructFlavor};\n \n use crate::{\n-    DefId, Cancelable,\n-    db::{HirDatabase},\n+    DefId, Cancelable, Name, AsName,\n+    db::HirDatabase,\n     type_ref::TypeRef,\n };\n \n@@ -29,26 +29,26 @@ impl Struct {\n         Ok(db.struct_data(self.def_id)?)\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<SmolStr>> {\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n         Ok(db.struct_data(self.def_id)?.name.clone())\n     }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n-    name: Option<SmolStr>,\n+    name: Option<Name>,\n     variant_data: Arc<VariantData>,\n }\n \n impl StructData {\n     pub(crate) fn new(struct_def: ast::StructDef) -> StructData {\n-        let name = struct_def.name().map(|n| n.text());\n+        let name = struct_def.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(struct_def.flavor());\n         let variant_data = Arc::new(variant_data);\n         StructData { name, variant_data }\n     }\n \n-    pub fn name(&self) -> Option<&SmolStr> {\n+    pub fn name(&self) -> Option<&Name> {\n         self.name.as_ref()\n     }\n \n@@ -70,31 +70,29 @@ impl Enum {\n         self.def_id\n     }\n \n-    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<SmolStr>> {\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n         Ok(db.enum_data(self.def_id)?.name.clone())\n     }\n \n-    pub fn variants(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SmolStr, Arc<VariantData>)>> {\n+    pub fn variants(&self, db: &impl HirDatabase) -> Cancelable<Vec<(Name, Arc<VariantData>)>> {\n         Ok(db.enum_data(self.def_id)?.variants.clone())\n     }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n-    name: Option<SmolStr>,\n-    variants: Vec<(SmolStr, Arc<VariantData>)>,\n+    name: Option<Name>,\n+    variants: Vec<(Name, Arc<VariantData>)>,\n }\n \n impl EnumData {\n     pub(crate) fn new(enum_def: ast::EnumDef) -> Self {\n-        let name = enum_def.name().map(|n| n.text());\n+        let name = enum_def.name().map(|n| n.as_name());\n         let variants = if let Some(evl) = enum_def.variant_list() {\n             evl.variants()\n                 .map(|v| {\n                     (\n-                        v.name()\n-                            .map(|n| n.text())\n-                            .unwrap_or_else(|| SmolStr::new(\"[error]\")),\n+                        v.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         Arc::new(VariantData::new(v.flavor())),\n                     )\n                 })\n@@ -109,12 +107,12 @@ impl EnumData {\n /// A single field of an enum variant or struct\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructField {\n-    name: SmolStr,\n+    name: Name,\n     type_ref: TypeRef,\n }\n \n impl StructField {\n-    pub fn name(&self) -> SmolStr {\n+    pub fn name(&self) -> Name {\n         self.name.clone()\n     }\n     pub fn type_ref(&self) -> &TypeRef {\n@@ -138,7 +136,7 @@ impl VariantData {\n                     .fields()\n                     .enumerate()\n                     .map(|(i, fd)| StructField {\n-                        name: SmolStr::new(i.to_string()),\n+                        name: Name::tuple_field_name(i),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();\n@@ -148,10 +146,7 @@ impl VariantData {\n                 let fields = fl\n                     .fields()\n                     .map(|fd| StructField {\n-                        name: fd\n-                            .name()\n-                            .map(|n| n.text())\n-                            .unwrap_or_else(|| SmolStr::new(\"[error]\")),\n+                        name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n                         type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n                     })\n                     .collect();\n@@ -161,10 +156,10 @@ impl VariantData {\n         }\n     }\n \n-    pub(crate) fn get_field_type_ref(&self, field_name: &str) -> Option<&TypeRef> {\n+    pub(crate) fn get_field_type_ref(&self, field_name: &Name) -> Option<&TypeRef> {\n         self.fields()\n             .iter()\n-            .find(|f| f.name == field_name)\n+            .find(|f| f.name == *field_name)\n             .map(|f| &f.type_ref)\n     }\n "}, {"sha": "b41a7429a7d1ccce3baf8d9864a200af0e0781bb", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=792899587647f5aa0293c2588173677682187c0a", "patch": "@@ -1,13 +1,10 @@\n use std::sync::Arc;\n \n-use ra_syntax::{\n-    SmolStr,\n-    SyntaxNode,\n-};\n+use ra_syntax::SyntaxNode;\n use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, FileId, Cancelable};\n \n use crate::{\n-    DefLoc, DefId,\n+    DefLoc, DefId, Name,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n     FnScopes,\n@@ -47,7 +44,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::type_for_def;\n     }\n \n-    fn type_for_field(def_id: DefId, field: SmolStr) -> Cancelable<Ty> {\n+    fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Ty> {\n         type TypeForFieldQuery;\n         use fn query_definitions::type_for_field;\n     }"}, {"sha": "51e8b3da86f4a58e31af945c46b964b95f360d45", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=792899587647f5aa0293c2588173677682187c0a", "patch": "@@ -23,6 +23,18 @@ impl fmt::Debug for Name {\n }\n \n impl Name {\n+    fn new(text: SmolStr) -> Name {\n+        Name { text }\n+    }\n+\n+    pub(crate) fn missing() -> Name {\n+        Name::new(\"[missing name]\".into())\n+    }\n+\n+    pub(crate) fn tuple_field_name(idx: usize) -> Name {\n+        Name::new(idx.to_string().into())\n+    }\n+\n     pub(crate) fn as_known_name(&self) -> Option<KnownName> {\n         let name = match self.text.as_str() {\n             \"isize\" => KnownName::Isize,\n@@ -43,10 +55,6 @@ impl Name {\n         };\n         Some(name)\n     }\n-\n-    fn new(text: SmolStr) -> Name {\n-        Name { text }\n-    }\n }\n \n pub(crate) trait AsName {"}, {"sha": "016d86ee6d47474874f69275c6cfd2a1e570d687", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=792899587647f5aa0293c2588173677682187c0a", "patch": "@@ -5,7 +5,7 @@ use std::{\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n-    AstNode, SyntaxNode, SmolStr,\n+    AstNode, SyntaxNode,\n     ast::{self, NameOwner, ModuleItemOwner}\n };\n use ra_db::{SourceRootId, FileId, Cancelable,};\n@@ -39,11 +39,7 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n     ty::type_for_def(db, def_id)\n }\n \n-pub(super) fn type_for_field(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-    field: SmolStr,\n-) -> Cancelable<Ty> {\n+pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Cancelable<Ty> {\n     ty::type_for_field(db, def_id, field)\n }\n "}, {"sha": "38720b7b56bfeed20fd22a9ed069295628c72201", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792899587647f5aa0293c2588173677682187c0a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=792899587647f5aa0293c2588173677682187c0a", "patch": "@@ -10,13 +10,12 @@ use rustc_hash::{FxHashMap};\n \n use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::{\n-    SmolStr,\n     ast::{self, AstNode, LoopBodyOwner, ArgListOwner, PrefixOp},\n     SyntaxNodeRef\n };\n \n use crate::{\n-    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path,\n+    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName,\n     db::HirDatabase,\n     adt::VariantData,\n     type_ref::{TypeRef, Mutability},\n@@ -45,7 +44,7 @@ pub enum Ty {\n         /// The DefId of the struct/enum.\n         def_id: DefId,\n         /// The name, for displaying.\n-        name: SmolStr,\n+        name: Name,\n         // later we'll need generic substitutions here\n     },\n \n@@ -276,18 +275,14 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n pub fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n-        name: s\n-            .name(db)?\n-            .unwrap_or_else(|| SmolStr::new(\"[unnamed struct]\")),\n+        name: s.name(db)?.unwrap_or_else(Name::missing),\n     })\n }\n \n pub fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n-        name: s\n-            .name(db)?\n-            .unwrap_or_else(|| SmolStr::new(\"[unnamed enum]\")),\n+        name: s.name(db)?.unwrap_or_else(Name::missing),\n     })\n }\n \n@@ -308,11 +303,7 @@ pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n     }\n }\n \n-pub(super) fn type_for_field(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-    field: SmolStr,\n-) -> Cancelable<Ty> {\n+pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Cancelable<Ty> {\n     let def = def_id.resolve(db)?;\n     let variant_data = match def {\n         Def::Struct(s) => {\n@@ -559,14 +550,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::FieldExpr(e) => {\n                 let receiver_ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(nr) = e.name_ref() {\n-                    let text = nr.text();\n                     match receiver_ty {\n                         Ty::Tuple(fields) => {\n-                            let i = text.parse::<usize>().ok();\n+                            let i = nr.text().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n                                 .unwrap_or(Ty::Unknown)\n                         }\n-                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, text)?,\n+                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, nr.as_name())?,\n                         _ => Ty::Unknown,\n                     }\n                 } else {"}]}