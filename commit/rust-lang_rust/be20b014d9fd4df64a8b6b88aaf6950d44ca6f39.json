{"sha": "be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMjBiMDE0ZDlmZDRkZjY0YThiNmI4OGFhZjY5NTBkNDRjYTZmMzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-02-02T20:23:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-02-02T20:23:39Z"}, "message": "Move type parameter parsing to a separate file", "tree": {"sha": "c15234d193badb99117c3f4a4b53a4d76c243f90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c15234d193badb99117c3f4a4b53a4d76c243f90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "html_url": "https://github.com/rust-lang/rust/commit/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cdf990c40e932a466e8799ca3fa582467d32c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cdf990c40e932a466e8799ca3fa582467d32c91", "html_url": "https://github.com/rust-lang/rust/commit/7cdf990c40e932a466e8799ca3fa582467d32c91"}], "stats": {"total": 154, "additions": 80, "deletions": 74}, "files": [{"sha": "35825e7c4d861d05adb836472eadb089bf0d77ce", "filename": "src/parser/event_parser/grammar/items/mod.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fmod.rs?ref=be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "patch": "@@ -83,76 +83,6 @@ fn item(p: &mut Parser) {\n     item.complete(p, item_kind);\n }\n \n-fn type_param_list(p: &mut Parser) {\n-    if !p.at(L_ANGLE) {\n-        return;\n-    }\n-    let m = p.start();\n-    p.bump();\n-\n-    while !p.at(EOF) && !p.at(R_ANGLE) {\n-        match p.current() {\n-            LIFETIME => lifetime_param(p),\n-            IDENT => type_param(p),\n-            _ => p.err_and_bump(\"expected type parameter\"),\n-        }\n-        if !p.at(R_ANGLE) && !p.expect(COMMA) {\n-            break;\n-        }\n-    }\n-    p.expect(R_ANGLE);\n-    m.complete(p, TYPE_PARAM_LIST);\n-\n-    fn lifetime_param(p: &mut Parser) {\n-        assert!(p.at(LIFETIME));\n-        let m = p.start();\n-        p.bump();\n-        if p.eat(COLON) {\n-            while p.at(LIFETIME) {\n-                p.bump();\n-                if !p.eat(PLUS) {\n-                    break;\n-                }\n-            }\n-        }\n-        m.complete(p, LIFETIME_PARAM);\n-    }\n-\n-    fn type_param(p: &mut Parser) {\n-        assert!(p.at(IDENT));\n-        let m = p.start();\n-        p.bump();\n-        if p.eat(COLON) {\n-            loop {\n-                let has_paren = p.eat(L_PAREN);\n-                p.eat(QUESTION);\n-                if p.at(FOR_KW) {\n-                    //TODO\n-                }\n-                if p.at(LIFETIME) {\n-                    p.bump();\n-                } else if paths::is_path_start(p) {\n-                    paths::type_path(p);\n-                } else {\n-                    break;\n-                }\n-                if has_paren {\n-                    p.expect(R_PAREN);\n-                }\n-                if !p.eat(PLUS) {\n-                    break;\n-                }\n-            }\n-        }\n-        if p.at(EQ) {\n-            types::type_ref(p)\n-        }\n-        m.complete(p, TYPE_PARAM);\n-    }\n-}\n-\n-fn where_clause(_: &mut Parser) {}\n-\n fn extern_crate_item(p: &mut Parser) {\n     assert!(p.at(EXTERN_KW));\n     p.bump();"}, {"sha": "69d95c698f0ff0dbc5398b72959b31af11dd3750", "filename": "src/parser/event_parser/grammar/items/structs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fstructs.rs?ref=be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "patch": "@@ -7,10 +7,10 @@ pub(super) fn struct_item(p: &mut Parser) {\n     if !p.expect(IDENT) {\n         return;\n     }\n-    type_param_list(p);\n+    type_params::list(p);\n     match p.current() {\n         WHERE_KW => {\n-            where_clause(p);\n+            type_params::where_clause(p);\n             match p.current() {\n                 SEMI => {\n                     p.bump();\n@@ -44,8 +44,8 @@ pub(super) fn enum_item(p: &mut Parser) {\n     assert!(p.at(ENUM_KW));\n     p.bump();\n     p.expect(IDENT);\n-    type_param_list(p);\n-    where_clause(p);\n+    type_params::list(p);\n+    type_params::where_clause(p);\n     if p.expect(L_CURLY) {\n         while !p.at(EOF) && !p.at(R_CURLY) {\n             let var = p.start();"}, {"sha": "afce308d0ce9e137ebc1a19184b4d68cc5e04c6e", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "patch": "@@ -7,6 +7,7 @@ mod attributes;\n mod expressions;\n mod types;\n mod paths;\n+mod type_params;\n \n pub(crate) fn file(p: &mut Parser) {\n     let file = p.start();"}, {"sha": "12c9a53627e827f34bdd46eb80c5e09bbd383630", "filename": "src/parser/event_parser/grammar/type_params.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftype_params.rs?ref=be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "patch": "@@ -0,0 +1,75 @@\n+use super::*;\n+\n+pub(super) fn list(p: &mut Parser) {\n+    if !p.at(L_ANGLE) {\n+        return;\n+    }\n+    let m = p.start();\n+    p.bump();\n+\n+    while !p.at(EOF) && !p.at(R_ANGLE) {\n+        match p.current() {\n+            LIFETIME => lifetime_param(p),\n+            IDENT => type_param(p),\n+            _ => p.err_and_bump(\"expected type parameter\"),\n+        }\n+        if !p.at(R_ANGLE) && !p.expect(COMMA) {\n+            break;\n+        }\n+    }\n+    p.expect(R_ANGLE);\n+    m.complete(p, TYPE_PARAM_LIST);\n+\n+    fn lifetime_param(p: &mut Parser) {\n+        assert!(p.at(LIFETIME));\n+        let m = p.start();\n+        p.bump();\n+        if p.eat(COLON) {\n+            while p.at(LIFETIME) {\n+                p.bump();\n+                if !p.eat(PLUS) {\n+                    break;\n+                }\n+            }\n+        }\n+        m.complete(p, LIFETIME_PARAM);\n+    }\n+\n+    fn type_param(p: &mut Parser) {\n+        assert!(p.at(IDENT));\n+        let m = p.start();\n+        p.bump();\n+        if p.eat(COLON) {\n+            loop {\n+                let has_paren = p.eat(L_PAREN);\n+                p.eat(QUESTION);\n+                if p.at(FOR_KW) {\n+                    //TODO\n+                }\n+                if p.at(LIFETIME) {\n+                    p.bump();\n+                } else if paths::is_path_start(p) {\n+                    paths::type_path(p);\n+                } else {\n+                    break;\n+                }\n+                if has_paren {\n+                    p.expect(R_PAREN);\n+                }\n+                if !p.eat(PLUS) {\n+                    break;\n+                }\n+            }\n+        }\n+        if p.at(EQ) {\n+            types::type_ref(p)\n+        }\n+        m.complete(p, TYPE_PARAM);\n+    }\n+}\n+\n+pub(super) fn where_clause(p: &mut Parser) {\n+    if p.at(WHERE_KW) {\n+        p.bump();\n+    }\n+}"}]}