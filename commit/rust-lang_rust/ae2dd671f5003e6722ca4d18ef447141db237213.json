{"sha": "ae2dd671f5003e6722ca4d18ef447141db237213", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMmRkNjcxZjUwMDNlNjcyMmNhNGQxOGVmNDQ3MTQxZGIyMzcyMTM=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-10-16T11:25:38Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-02-10T10:57:28Z"}, "message": "Rewrite use_self lint one more time\n\nThis rewrite gets rid of complicated visitors, by using the lint infrastructure as much as possible", "tree": {"sha": "af27af439fc4d34ade940d8c946655414248951c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af27af439fc4d34ade940d8c946655414248951c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae2dd671f5003e6722ca4d18ef447141db237213", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmAjvBgACgkQHKDfKvWd\naKUglRAAyug2ZOqUrRAZ5wzaNpF9ftzEjVojPQyyUzoSct3QrsxgDiIYn2UtJArt\nXUjw4f7n+qkLF7++aWymf5LBDPJcVHkABqkHhYfOgWz1DM7u7l+jrQrj0vDok2Ab\nbcg1HfhpDOr3+zUrzfjOa1ndjFS/q7t5Jqhc0vn6+22W6YgPAkHxEyjIJT7/g2ut\nycY4Gk1LSfzf547Uf122eQG9LvRP5S5N2ydvtSXXmrBBe9/iHG0NMLx8rSqqkhKQ\nwN0YaQulRoKM6c7c2zGeYzU7q3us53kt9FHEsl85m+Yi1W3Y4FfREQzXXHAaNQzI\n034Hdw2cyPCGfASiQfXp0+MsmeVKf207nyEq0LIiae5g+DjAlqokUzrk/lxDze9G\nnQCAi5LnUCS2GMdHpClytYNFk02amwsSqYDtHbB09HQUNeg1UQtoHSV0bWk7Oima\nKP6Fcd3mEZh3l99qm4e6rQ4g+KHetVLEC0rlhaX58LMS915IF4PrWCZj6736E0gj\nedXpgJmIP55JpHglmQKVT6LCZERz/1eHha8e/u+rkI+5XqjVAOmVXaM1svkpLcSM\nHc7cJlS7l/XqExTacNN1VmufjziuVL7yb3rkDIhtznJRvKXCMAk4A1sQnyHk+2hx\n6Z5ZIZTjfkYhwrmP5f1rtFwl5n2I1Uaml849K3SpKQDkEir+HH8=\n=PS5u\n-----END PGP SIGNATURE-----", "payload": "tree af27af439fc4d34ade940d8c946655414248951c\nparent fc334fb8f4cc7e6513578d88f52b2899f624a1de\nauthor flip1995 <hello@philkrones.com> 1602847538 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1612954648 +0100\n\nRewrite use_self lint one more time\n\nThis rewrite gets rid of complicated visitors, by using the lint infrastructure as much as possible\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2dd671f5003e6722ca4d18ef447141db237213", "html_url": "https://github.com/rust-lang/rust/commit/ae2dd671f5003e6722ca4d18ef447141db237213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae2dd671f5003e6722ca4d18ef447141db237213/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc334fb8f4cc7e6513578d88f52b2899f624a1de", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc334fb8f4cc7e6513578d88f52b2899f624a1de", "html_url": "https://github.com/rust-lang/rust/commit/fc334fb8f4cc7e6513578d88f52b2899f624a1de"}], "stats": {"total": 604, "additions": 344, "deletions": 260}, "files": [{"sha": "fbd996ad0e94db83ca670b90b2a7c080fbdaf38a", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 344, "deletions": 260, "changes": 604, "blob_url": "https://github.com/rust-lang/rust/blob/ae2dd671f5003e6722ca4d18ef447141db237213/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2dd671f5003e6722ca4d18ef447141db237213/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=ae2dd671f5003e6722ca4d18ef447141db237213", "patch": "@@ -1,21 +1,22 @@\n-use crate::utils;\n-use crate::utils::snippet_opt;\n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::{meets_msrv, qpath_res, snippet_opt, span_lint_and_sugg};\n use if_chain::if_chain;\n+\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::intravisit::{walk_expr, walk_impl_item, walk_ty, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    def, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, ImplItem, ImplItemKind, ItemKind, Node, Path, PathSegment,\n+    def,\n+    def_id::LocalDefId,\n+    intravisit::{walk_ty, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n     QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty;\n-use rustc_middle::ty::Ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_middle::ty::{AssocKind, Ty};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -28,9 +29,11 @@ declare_clippy_lint! {\n     /// feels inconsistent.\n     ///\n     /// **Known problems:**\n-    /// Unaddressed false negatives related to unresolved internal compiler errors.\n+    /// - Unaddressed false negative in fn bodies of trait implementations\n+    /// - False positive with assotiated types in traits (#4140)\n     ///\n     /// **Example:**\n+    ///\n     /// ```rust\n     /// struct Foo {}\n     /// impl Foo {\n@@ -53,319 +56,400 @@ declare_clippy_lint! {\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n-declare_lint_pass!(UseSelf => [USE_SELF]);\n+#[derive(Default)]\n+pub struct UseSelf {\n+    msrv: Option<RustcVersion>,\n+    stack: Vec<StackItem>,\n+    types_to_skip: Vec<HirId>,\n+    types_to_lint: Vec<HirId>,\n+}\n \n-const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n+const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n \n-fn span_lint(cx: &LateContext<'_>, span: Span) {\n-    span_lint_and_sugg(\n-        cx,\n-        USE_SELF,\n-        span,\n-        \"unnecessary structure name repetition\",\n-        \"use the applicable keyword\",\n-        \"Self\".to_owned(),\n-        Applicability::MachineApplicable,\n-    );\n+impl UseSelf {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Self::default()\n+        }\n+    }\n }\n \n-#[allow(clippy::cast_possible_truncation)]\n-fn span_lint_until_last_segment<'tcx>(cx: &LateContext<'tcx>, span: Span, segment: &'tcx PathSegment<'tcx>) {\n-    let sp = span.with_hi(segment.ident.span.lo());\n-    // remove the trailing ::\n-    let span_without_last_segment = match snippet_opt(cx, sp) {\n-        Some(snippet) => match snippet.rfind(\"::\") {\n-            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n-            None => sp,\n-        },\n-        None => sp,\n-    };\n-    span_lint(cx, span_without_last_segment);\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum StackItem {\n+    Check {\n+        hir_id: HirId,\n+        impl_trait_ref_def_id: Option<LocalDefId>,\n+    },\n+    NoCheck,\n }\n \n-fn span_lint_on_path_until_last_segment<'tcx>(cx: &LateContext<'tcx>, path: &'tcx Path<'tcx>) {\n-    if path.segments.len() > 1 {\n-        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n+impl_lint_pass!(UseSelf => [USE_SELF]);\n+\n+const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n+\n+impl<'tcx> LateLintPass<'tcx> for UseSelf {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // We push the self types of `impl`s on a stack here. Only the top type on the stack is\n+        // relevant for linting, since this is the self type of the `impl` we're currently in. To\n+        // avoid linting on nested items, we push `StackItem::NoCheck` on the stack to signal, that\n+        // we're in an `impl` or nested item, that we don't want to lint\n+        //\n+        // NB: If you push something on the stack in this method, remember to also pop it in the\n+        // `check_item_post` method.\n+        match &item.kind {\n+            ItemKind::Impl(Impl {\n+                self_ty: hir_self_ty,\n+                of_trait,\n+                ..\n+            }) => {\n+                let should_check = if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind {\n+                    let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n+                    parameters.as_ref().map_or(true, |params| {\n+                        !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n+                    })\n+                } else {\n+                    false\n+                };\n+                let impl_trait_ref_def_id = of_trait.as_ref().map(|_| cx.tcx.hir().local_def_id(item.hir_id));\n+                if should_check {\n+                    self.stack.push(StackItem::Check {\n+                        hir_id: hir_self_ty.hir_id,\n+                        impl_trait_ref_def_id,\n+                    });\n+                } else {\n+                    self.stack.push(StackItem::NoCheck);\n+                }\n+            },\n+            ItemKind::Static(..)\n+            | ItemKind::Const(..)\n+            | ItemKind::Fn(..)\n+            | ItemKind::Enum(..)\n+            | ItemKind::Struct(..)\n+            | ItemKind::Union(..)\n+            | ItemKind::Trait(..) => {\n+                self.stack.push(StackItem::NoCheck);\n+            },\n+            _ => (),\n+        }\n     }\n-}\n \n-fn span_lint_on_qpath_resolved<'tcx>(cx: &LateContext<'tcx>, qpath: &'tcx QPath<'tcx>, until_last_segment: bool) {\n-    if let QPath::Resolved(_, path) = qpath {\n-        if until_last_segment {\n-            span_lint_on_path_until_last_segment(cx, path);\n-        } else {\n-            span_lint(cx, path.span);\n+    fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n+        use ItemKind::{Const, Enum, Fn, Impl, Static, Struct, Trait, Union};\n+        match item.kind {\n+            Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..) => {\n+                self.stack.pop();\n+            },\n+            _ => (),\n         }\n     }\n-}\n \n-struct BodyVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    self_ty: Ty<'tcx>,\n-}\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n+        // We want to skip types in trait `impl`s that aren't declared as `Self` in the trait\n+        // declaration. The collection of those types is all this method implementation does.\n+        if_chain! {\n+            if let ImplItemKind::Fn(FnSig { decl, .. }, ..) = impl_item.kind;\n+            if let Some(StackItem::Check { impl_trait_ref_def_id: Some(def_id), .. }) = self.stack.last().copied();\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(def_id);\n+            then {\n+                // `self_ty` is the semantic self type of `impl <trait> for <type>`. This cannot be\n+                // `Self`.\n+                let self_ty = impl_trait_ref.self_ty();\n+\n+                // `trait_method_sig` is the signature of the function, how it is declared in the\n+                // trait, not in the impl of the trait.\n+                let trait_method = cx\n+                    .tcx\n+                    .associated_items(impl_trait_ref.def_id)\n+                    .find_by_name_and_kind(cx.tcx, impl_item.ident, AssocKind::Fn, impl_trait_ref.def_id)\n+                    .expect(\"impl method matches a trait method\");\n+                let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n+                let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n+\n+                // `impl_inputs_outputs` is an iterator over the types (`hir::Ty`) declared in the\n+                // implementation of the trait.\n+                let output_hir_ty = if let FnRetTy::Return(ty) = &decl.output {\n+                    Some(&**ty)\n+                } else {\n+                    None\n+                };\n+                let impl_inputs_outputs = decl.inputs.iter().chain(output_hir_ty);\n+\n+                // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n+                //\n+                // `trait_sem_ty` (of type `ty::Ty`) is the semantic type for the signature in the\n+                // trait declaration. This is used to check if `Self` was used in the trait\n+                // declaration.\n+                //\n+                // If `any`where in the `trait_sem_ty` the `self_ty` was used verbatim (as opposed\n+                // to `Self`), we want to skip linting that type and all subtypes of it. This\n+                // avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`, in an `impl Trait\n+                // for u8`, when the trait always uses `Vec<u8>`.\n+                //\n+                // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n+                for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n+                    if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n+                        let mut visitor = SkipTyCollector::default();\n+                        visitor.visit_ty(&impl_hir_ty);\n+                        self.types_to_skip.extend(visitor.types_to_skip);\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n-impl<'a, 'tcx> BodyVisitor<'a, 'tcx> {\n-    fn check_trait_method_impl_decl(\n-        &mut self,\n-        impl_item: &ImplItem<'tcx>,\n-        impl_decl: &'tcx FnDecl<'tcx>,\n-        impl_trait_ref: ty::TraitRef<'tcx>,\n-    ) {\n-        let tcx = self.cx.tcx;\n-        let trait_method = tcx\n-            .associated_items(impl_trait_ref.def_id)\n-            .find_by_name_and_kind(tcx, impl_item.ident, ty::AssocKind::Fn, impl_trait_ref.def_id)\n-            .expect(\"impl method matches a trait method\");\n-\n-        let trait_method_sig = tcx.fn_sig(trait_method.def_id);\n-        let trait_method_sig = tcx.erase_late_bound_regions(&trait_method_sig);\n-\n-        let output_hir_ty = if let FnRetTy::Return(ty) = &impl_decl.output {\n-            Some(&**ty)\n-        } else {\n-            None\n-        };\n+    fn check_impl_item_post(&mut self, _: &LateContext<'_>, _: &hir::ImplItem<'_>) {\n+        self.types_to_skip.clear();\n+    }\n \n-        // `impl_hir_ty` (of type `hir::Ty`) represents the type written in the signature.\n-        // `trait_ty` (of type `ty::Ty`) is the semantic type for the signature in the trait.\n-        // We use `impl_hir_ty` to see if the type was written as `Self`,\n-        // `hir_ty_to_ty(...)` to check semantic types of paths, and\n-        // `trait_ty` to determine which parts of the signature in the trait, mention\n-        // the type being implemented verbatim (as opposed to `Self`).\n-        for (impl_hir_ty, trait_ty) in impl_decl\n-            .inputs\n-            .iter()\n-            .chain(output_hir_ty)\n-            .zip(trait_method_sig.inputs_and_output)\n-        {\n-            // Check if the input/output type in the trait method specifies the implemented\n-            // type verbatim, and only suggest `Self` if that isn't the case.\n-            // This avoids suggestions to e.g. replace `Vec<u8>` with `Vec<Self>`,\n-            // in an `impl Trait for u8`, when the trait always uses `Vec<u8>`.\n-            // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n-            let self_ty = impl_trait_ref.self_ty();\n-            if !trait_ty.walk().any(|inner| inner == self_ty.into()) {\n-                self.visit_ty(&impl_hir_ty);\n-            }\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) {\n+        // `hir_ty_to_ty` cannot be called in `Body`s or it will panic (sometimes). But in bodies\n+        // we can use `cx.typeck_results.node_type(..)` to get the `ty::Ty` from a `hir::Ty`.\n+        // However the `node_type()` method can *only* be called in bodies.\n+        //\n+        // This method implementation determines which types should get linted in a `Body` and\n+        // which shouldn't, with a visitor. We could directly lint in the visitor, but then we\n+        // could only allow this lint on item scope. And we would have to check if those types are\n+        // already dealt with in `check_ty` anyway.\n+        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            let mut visitor = LintTyCollector {\n+                cx,\n+                self_ty,\n+                types_to_lint: vec![],\n+                types_to_skip: vec![],\n+            };\n+            visitor.visit_expr(&body.value);\n+            self.types_to_lint.extend(visitor.types_to_lint);\n+            self.types_to_skip.extend(visitor.types_to_skip);\n         }\n     }\n-}\n \n-impl<'a, 'tcx> Visitor<'tcx> for BodyVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n+    fn check_body_post(&mut self, _: &LateContext<'_>, _: &hir::Body<'_>) {\n+        self.types_to_lint.clear();\n+    }\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n+        if in_external_macro(cx.sess(), hir_ty.span)\n+            | in_impl(cx, hir_ty)\n+            | self.types_to_skip.contains(&hir_ty.hir_id)\n+            | !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV)\n+        {\n+            return;\n+        }\n+\n+        let lint_dependend_on_expr_kind = || {\n+            // FIXME: this span manipulation should not be necessary\n+            // @flip1995 found an ast lowering issue in\n+            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+            match cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_ty.hir_id)) {\n+                Some(Node::Expr(Expr {\n+                    kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n+                    ..\n+                })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n+                _ => span_lint(cx, hir_ty.span),\n+            }\n+        };\n+\n+        if self.types_to_lint.contains(&hir_ty.hir_id) {\n+            lint_dependend_on_expr_kind();\n+        } else if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            if should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty) {\n+                lint_dependend_on_expr_kind();\n+            }\n+        }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        fn expr_ty_matches<'tcx>(expr: &'tcx Expr<'tcx>, self_ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n             let def_id = expr.hir_id.owner;\n             if cx.tcx.has_typeck_results(def_id) {\n                 cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n             } else {\n                 false\n             }\n         }\n-        match expr.kind {\n-            ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n-                if expr_ty_matches(expr, self.self_ty, self.cx) {\n-                    match path.res {\n-                        def::Res::SelfTy(..) => (),\n-                        def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(self.cx, path),\n-                        _ => {\n-                            span_lint(self.cx, path.span);\n-                        },\n+\n+        if in_external_macro(cx.sess(), expr.span) | !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n+            return;\n+        }\n+\n+        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n+            let self_ty = ty_from_hir_id(cx, *hir_id);\n+\n+            match &expr.kind {\n+                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n+                    if expr_ty_matches(cx, expr, self_ty) {\n+                        match path.res {\n+                            def::Res::SelfTy(..) => (),\n+                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n+                            _ => {\n+                                span_lint(cx, path.span);\n+                            },\n+                        }\n                     }\n-                }\n-            },\n-            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n-            ExprKind::Call(fun, _) => {\n-                if let Expr {\n-                    kind: ExprKind::Path(ref qpath),\n-                    ..\n-                } = fun\n-                {\n-                    if expr_ty_matches(expr, self.self_ty, self.cx) {\n-                        let res = utils::qpath_res(self.cx, qpath, fun.hir_id);\n-\n-                        if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n-                            match ctor_of {\n-                                def::CtorOf::Variant => {\n-                                    span_lint_on_qpath_resolved(self.cx, qpath, true);\n-                                },\n-                                def::CtorOf::Struct => {\n-                                    span_lint_on_qpath_resolved(self.cx, qpath, false);\n-                                },\n+                },\n+                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+                ExprKind::Call(fun, _) => {\n+                    if let Expr {\n+                        kind: ExprKind::Path(ref qpath),\n+                        ..\n+                    } = fun\n+                    {\n+                        if expr_ty_matches(cx, expr, self_ty) {\n+                            let res = qpath_res(cx, qpath, fun.hir_id);\n+\n+                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n+                                match ctor_of {\n+                                    def::CtorOf::Variant => {\n+                                        span_lint_on_qpath_resolved(cx, qpath, true);\n+                                    },\n+                                    def::CtorOf::Struct => {\n+                                        span_lint_on_qpath_resolved(cx, qpath, false);\n+                                    },\n+                                }\n                             }\n                         }\n                     }\n-                }\n-            },\n-            // unit enum variants (`Enum::A`)\n-            ExprKind::Path(ref qpath) => {\n-                if expr_ty_matches(expr, self.self_ty, self.cx) {\n-                    span_lint_on_qpath_resolved(self.cx, qpath, true);\n-                }\n-            },\n-            _ => (),\n+                },\n+                // unit enum variants (`Enum::A`)\n+                ExprKind::Path(qpath) => {\n+                    if expr_ty_matches(cx, expr, self_ty) {\n+                        span_lint_on_qpath_resolved(cx, &qpath, true);\n+                    }\n+                },\n+                _ => (),\n+            }\n         }\n-        walk_expr(self, expr);\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n-struct FnSigVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    self_ty: Ty<'tcx>,\n+#[derive(Default)]\n+struct SkipTyCollector {\n+    types_to_skip: Vec<HirId>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for FnSigVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for SkipTyCollector {\n     type Map = Map<'tcx>;\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n+    fn visit_ty(&mut self, hir_ty: &hir::Ty<'_>) {\n+        self.types_to_skip.push(hir_ty.hir_id);\n \n-    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind {\n-            match path.res {\n-                def::Res::SelfTy(..) => {},\n-                _ => {\n-                    match self.cx.tcx.hir().find(self.cx.tcx.hir().get_parent_node(hir_ty.hir_id)) {\n-                        Some(Node::Expr(Expr {\n-                            kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                            ..\n-                        })) => {\n-                            // The following block correctly identifies applicable lint locations\n-                            // but `hir_ty_to_ty` calls cause odd ICEs.\n-                            //\n-                            if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n-                                // fixme: this span manipulation should not be necessary\n-                                // @flip1995 found an ast lowering issue in\n-                                // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n-                                span_lint_until_last_segment(self.cx, hir_ty.span, segment);\n-                            }\n-                        },\n-                        _ => {\n-                            if hir_ty_to_ty(self.cx.tcx, hir_ty) == self.self_ty {\n-                                span_lint(self.cx, hir_ty.span)\n-                            }\n-                        },\n-                    }\n-                },\n-            }\n-        }\n+        walk_ty(self, hir_ty)\n+    }\n \n-        walk_ty(self, hir_ty);\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n     }\n }\n \n-impl<'tcx> LateLintPass<'tcx> for UseSelf {\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n-        if in_external_macro(cx.sess(), impl_item.span) {\n-            return;\n-        }\n+struct LintTyCollector<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    types_to_lint: Vec<HirId>,\n+    types_to_skip: Vec<HirId>,\n+}\n \n-        let parent_id = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n-        let imp = cx.tcx.hir().expect_item(parent_id);\n+impl<'a, 'tcx> Visitor<'tcx> for LintTyCollector<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n \n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'_>) {\n         if_chain! {\n-            if let ItemKind::Impl { self_ty: hir_self_ty, .. } = imp.kind;\n-            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind;\n+            if let Some(ty) = self.cx.typeck_results().node_type_opt(hir_ty.hir_id);\n+            if should_lint_ty(hir_ty, ty, self.self_ty);\n             then {\n-                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                let should_check = parameters.as_ref().map_or(\n-                    true,\n-                    |params| !params.parenthesized\n-                        &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n-                );\n-\n-                // TODO: don't short-circuit upon lifetime parameters\n-                if should_check {\n-                    let self_ty = hir_ty_to_ty(cx.tcx, hir_self_ty);\n-                    let body_visitor = &mut BodyVisitor { cx, self_ty };\n-                    let fn_sig_visitor = &mut FnSigVisitor { cx, self_ty };\n-\n-                    let tcx = cx.tcx;\n-                    let impl_def_id = tcx.hir().local_def_id(imp.hir_id);\n-                    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n-                    if_chain! {\n-                        if let Some(impl_trait_ref) = impl_trait_ref;\n-                        if let ImplItemKind::Fn(FnSig { decl: impl_decl, .. }, impl_body_id) = &impl_item.kind;\n-                        then {\n-                            body_visitor.check_trait_method_impl_decl(impl_item, impl_decl, impl_trait_ref);\n-                            let body = tcx.hir().body(*impl_body_id);\n-                            body_visitor.visit_body(body);\n-                        } else {\n-                            walk_impl_item(body_visitor, impl_item);\n-                            walk_impl_item(fn_sig_visitor, impl_item);\n-                        }\n-                    }\n-                }\n+                self.types_to_lint.push(hir_ty.hir_id);\n+            } else {\n+                self.types_to_skip.push(hir_ty.hir_id);\n             }\n         }\n+\n+        walk_ty(self, hir_ty)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n     }\n-    extract_msrv_attr!(LateContext);\n }\n \n-struct UseSelfVisitor<'a, 'tcx> {\n-    item_path: &'a Path<'a>,\n-    cx: &'a LateContext<'tcx>,\n+fn span_lint(cx: &LateContext<'_>, span: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        USE_SELF,\n+        span,\n+        \"unnecessary structure name repetition\",\n+        \"use the applicable keyword\",\n+        \"Self\".to_owned(),\n+        Applicability::MachineApplicable,\n+    );\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n+#[allow(clippy::cast_possible_truncation)]\n+fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n+    let sp = span.with_hi(segment.ident.span.lo());\n+    // remove the trailing ::\n+    let span_without_last_segment = match snippet_opt(cx, sp) {\n+        Some(snippet) => match snippet.rfind(\"::\") {\n+            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n+            None => sp,\n+        },\n+        None => sp,\n+    };\n+    span_lint(cx, span_without_last_segment);\n+}\n \n-    fn visit_path(&mut self, path: &'tcx Path<'_>, _id: HirId) {\n-        if !path.segments.iter().any(|p| p.ident.span.is_dummy()) {\n-            if path.segments.len() >= 2 {\n-                let last_but_one = &path.segments[path.segments.len() - 2];\n-                if last_but_one.ident.name != kw::SelfUpper {\n-                    let enum_def_id = match path.res {\n-                        Res::Def(DefKind::Variant, variant_def_id) => self.cx.tcx.parent(variant_def_id),\n-                        Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), ctor_def_id) => {\n-                            let variant_def_id = self.cx.tcx.parent(ctor_def_id);\n-                            variant_def_id.and_then(|def_id| self.cx.tcx.parent(def_id))\n-                        },\n-                        _ => None,\n-                    };\n-\n-                    if self.item_path.res.opt_def_id() == enum_def_id {\n-                        span_use_self_lint(self.cx, path, Some(last_but_one));\n-                    }\n-                }\n-            }\n+fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if path.segments.len() > 1 {\n+        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n+    }\n+}\n \n-            if path.segments.last().expect(SEGMENTS_MSG).ident.name != kw::SelfUpper {\n-                if self.item_path.res == path.res {\n-                    span_use_self_lint(self.cx, path, None);\n-                } else if let Res::Def(DefKind::Ctor(def::CtorOf::Struct, _), ctor_def_id) = path.res {\n-                    if self.item_path.res.opt_def_id() == self.cx.tcx.parent(ctor_def_id) {\n-                        span_use_self_lint(self.cx, path, None);\n-                    }\n-                }\n-            }\n+fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if until_last_segment {\n+            span_lint_on_path_until_last_segment(cx, path);\n+        } else {\n+            span_lint(cx, path.span);\n         }\n+    }\n+}\n \n-        walk_path(self, path);\n+fn ty_from_hir_id<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Ty<'tcx> {\n+    if let Some(Node::Ty(hir_ty)) = cx.tcx.hir().find(hir_id) {\n+        hir_ty_to_ty(cx.tcx, hir_ty)\n+    } else {\n+        unreachable!(\"This function should only be called with `HirId`s that are for sure `Node::Ty`\")\n     }\n+}\n \n-    fn visit_item(&mut self, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Use(..)\n-            | ItemKind::Static(..)\n-            | ItemKind::Enum(..)\n-            | ItemKind::Struct(..)\n-            | ItemKind::Union(..)\n-            | ItemKind::Impl { .. }\n-            | ItemKind::Fn(..) => {\n-                // Don't check statements that shadow `Self` or where `Self` can't be used\n-            },\n-            _ => walk_item(self, item),\n+fn in_impl(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    let parent = map.get_parent_node(hir_ty.hir_id);\n+    if_chain! {\n+        if let Some(Node::Item(item)) = map.find(parent);\n+        if let ItemKind::Impl { .. } = item.kind;\n+        then {\n+            true\n+        } else {\n+            false\n         }\n     }\n+}\n \n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::All(self.cx.tcx.hir())\n+fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n+    if_chain! {\n+        if ty == self_ty;\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        then {\n+            !matches!(path.res, def::Res::SelfTy(..))\n+        } else {\n+            false\n+        }\n     }\n }"}]}