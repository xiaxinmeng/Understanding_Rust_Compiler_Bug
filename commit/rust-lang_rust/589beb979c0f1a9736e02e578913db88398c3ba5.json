{"sha": "589beb979c0f1a9736e02e578913db88398c3ba5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OWJlYjk3OWMwZjFhOTczNmUwMmU1Nzg5MTNkYjg4Mzk4YzNiYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T08:30:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-20T08:30:17Z"}, "message": "Auto merge of #60921 - cuviper:remove-mpsc_select, r=SimonSapin\n\nRemove the unstable and deprecated mpsc_select\n\nThis removes macro `select!` and `std::sync::mpsc::{Handle, Select}`,\nwhich were all unstable and have been deprecated since 1.32.\n\nCloses #27800\nr? @SimonSapin", "tree": {"sha": "d9cbcad9c389969a81311e14b90617f0c0d6aef0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9cbcad9c389969a81311e14b90617f0c0d6aef0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/589beb979c0f1a9736e02e578913db88398c3ba5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/589beb979c0f1a9736e02e578913db88398c3ba5", "html_url": "https://github.com/rust-lang/rust/commit/589beb979c0f1a9736e02e578913db88398c3ba5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/589beb979c0f1a9736e02e578913db88398c3ba5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caef1e833fbd9de740d521114d716a11a29b71cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/caef1e833fbd9de740d521114d716a11a29b71cb", "html_url": "https://github.com/rust-lang/rust/commit/caef1e833fbd9de740d521114d716a11a29b71cb"}, {"sha": "f950193d74d13628537a04728eef25cec642e41b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f950193d74d13628537a04728eef25cec642e41b", "html_url": "https://github.com/rust-lang/rust/commit/f950193d74d13628537a04728eef25cec642e41b"}], "stats": {"total": 1139, "additions": 9, "deletions": 1130}, "files": [{"sha": "9af7bba97aa58de06daab2106874f17909a16cd6", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -357,61 +357,6 @@ macro_rules! dbg {\n     };\n }\n \n-/// Selects the first successful receive event from a number of receivers.\n-///\n-/// This macro is used to wait for the first event to occur on a number of\n-/// receivers. It places no restrictions on the types of receivers given to\n-/// this macro, this can be viewed as a heterogeneous select.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(mpsc_select)]\n-///\n-/// use std::thread;\n-/// use std::sync::mpsc;\n-///\n-/// // two placeholder functions for now\n-/// fn long_running_thread() {}\n-/// fn calculate_the_answer() -> u32 { 42 }\n-///\n-/// let (tx1, rx1) = mpsc::channel();\n-/// let (tx2, rx2) = mpsc::channel();\n-///\n-/// thread::spawn(move|| { long_running_thread(); tx1.send(()).unwrap(); });\n-/// thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n-///\n-/// select! {\n-///     _ = rx1.recv() => println!(\"the long running thread finished first\"),\n-///     answer = rx2.recv() => {\n-///         println!(\"the answer was: {}\", answer.unwrap());\n-///     }\n-/// }\n-/// # drop(rx1.recv());\n-/// # drop(rx2.recv());\n-/// ```\n-///\n-/// For more information about select, see the `std::sync::mpsc::Select` structure.\n-#[macro_export]\n-#[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n-#[rustc_deprecated(since = \"1.32.0\",\n-                   reason = \"channel selection will be removed in a future release\")]\n-macro_rules! select {\n-    (\n-        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-    ) => ({\n-        use $crate::sync::mpsc::Select;\n-        let sel = Select::new();\n-        $( let mut $rx = sel.handle(&$rx); )+\n-        unsafe {\n-            $( $rx.add(); )+\n-        }\n-        let ret = sel.wait();\n-        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-        { unreachable!() }\n-    })\n-}\n-\n #[cfg(test)]\n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({"}, {"sha": "69ecd201063b034baf0f8d5df0074823a89ecda6", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 83, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -116,7 +116,6 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![allow(deprecated)] // for mpsc_select\n \n // A description of how Rust's channel implementation works\n //\n@@ -263,6 +262,8 @@\n // believe that there is anything fundamental that needs to change about these\n // channels, however, in order to support a more efficient select().\n //\n+// FIXME: Select is now removed, so these factors are ready to be cleaned up!\n+//\n // # Conclusion\n //\n // And now that you've seen all the races that I found and attempted to fix,\n@@ -275,18 +276,8 @@ use crate::mem;\n use crate::cell::UnsafeCell;\n use crate::time::{Duration, Instant};\n \n-#[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n-pub use self::select::{Select, Handle};\n-use self::select::StartResult;\n-use self::select::StartResult::*;\n-use self::blocking::SignalToken;\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod select_tests;\n-\n mod blocking;\n mod oneshot;\n-mod select;\n mod shared;\n mod stream;\n mod sync;\n@@ -1514,78 +1505,6 @@ impl<T> Receiver<T> {\n \n }\n \n-impl<T> select::Packet for Receiver<T> {\n-    fn can_recv(&self) -> bool {\n-        loop {\n-            let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.can_recv() {\n-                        Ok(ret) => return ret,\n-                        Err(upgrade) => upgrade,\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.can_recv() {\n-                        Ok(ret) => return ret,\n-                        Err(upgrade) => upgrade,\n-                    }\n-                }\n-                Flavor::Shared(ref p) => return p.can_recv(),\n-                Flavor::Sync(ref p) => return p.can_recv(),\n-            };\n-            unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n-            }\n-        }\n-    }\n-\n-    fn start_selection(&self, mut token: SignalToken) -> StartResult {\n-        loop {\n-            let (t, new_port) = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.start_selection(token) {\n-                        oneshot::SelSuccess => return Installed,\n-                        oneshot::SelCanceled => return Abort,\n-                        oneshot::SelUpgraded(t, rx) => (t, rx),\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.start_selection(token) {\n-                        stream::SelSuccess => return Installed,\n-                        stream::SelCanceled => return Abort,\n-                        stream::SelUpgraded(t, rx) => (t, rx),\n-                    }\n-                }\n-                Flavor::Shared(ref p) => return p.start_selection(token),\n-                Flavor::Sync(ref p) => return p.start_selection(token),\n-            };\n-            token = t;\n-            unsafe {\n-                mem::swap(self.inner_mut(), new_port.inner_mut());\n-            }\n-        }\n-    }\n-\n-    fn abort_selection(&self) -> bool {\n-        let mut was_upgrade = false;\n-        loop {\n-            let result = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => p.abort_selection(),\n-                Flavor::Stream(ref p) => p.abort_selection(was_upgrade),\n-                Flavor::Shared(ref p) => return p.abort_selection(was_upgrade),\n-                Flavor::Sync(ref p) => return p.abort_selection(),\n-            };\n-            let new_port = match result { Ok(b) => return b, Err(p) => p };\n-            was_upgrade = true;\n-            unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n-            }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = T;"}, {"sha": "e7a5cc46b31a857912e23bc880fac2c97d4580e2", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -24,7 +24,6 @@\n \n pub use self::Failure::*;\n pub use self::UpgradeResult::*;\n-pub use self::SelectionResult::*;\n use self::MyUpgrade::*;\n \n use crate::sync::mpsc::Receiver;\n@@ -66,12 +65,6 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n-    SelCanceled,\n-    SelUpgraded(SignalToken, Receiver<T>),\n-    SelSuccess,\n-}\n-\n enum MyUpgrade<T> {\n     NothingSent,\n     SendUsed,\n@@ -264,71 +257,6 @@ impl<T> Packet<T> {\n     // select implementation\n     ////////////////////////////////////////////////////////////////////////////\n \n-    // If Ok, the value is whether this port has data, if Err, then the upgraded\n-    // port needs to be checked instead of this one.\n-    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n-        unsafe {\n-            match self.state.load(Ordering::SeqCst) {\n-                EMPTY => Ok(false), // Welp, we tried\n-                DATA => Ok(true),   // we have some un-acquired data\n-                DISCONNECTED if (*self.data.get()).is_some() => Ok(true), // we have data\n-                DISCONNECTED => {\n-                    match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        // The other end sent us an upgrade, so we need to\n-                        // propagate upwards whether the upgrade can receive\n-                        // data\n-                        GoUp(upgrade) => Err(upgrade),\n-\n-                        // If the other end disconnected without sending an\n-                        // upgrade, then we have data to receive (the channel is\n-                        // disconnected).\n-                        up => { ptr::write(self.upgrade.get(), up); Ok(true) }\n-                    }\n-                }\n-                _ => unreachable!(), // we're the \"one blocker\"\n-            }\n-        }\n-    }\n-\n-    // Attempts to start selection on this port. This can either succeed, fail\n-    // because there is data, or fail because there is an upgrade pending.\n-    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n-        unsafe {\n-            let ptr = token.cast_to_usize();\n-            match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n-                EMPTY => SelSuccess,\n-                DATA => {\n-                    drop(SignalToken::cast_from_usize(ptr));\n-                    SelCanceled\n-                }\n-                DISCONNECTED if (*self.data.get()).is_some() => {\n-                    drop(SignalToken::cast_from_usize(ptr));\n-                    SelCanceled\n-                }\n-                DISCONNECTED => {\n-                    match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        // The other end sent us an upgrade, so we need to\n-                        // propagate upwards whether the upgrade can receive\n-                        // data\n-                        GoUp(upgrade) => {\n-                            SelUpgraded(SignalToken::cast_from_usize(ptr), upgrade)\n-                        }\n-\n-                        // If the other end disconnected without sending an\n-                        // upgrade, then we have data to receive (the channel is\n-                        // disconnected).\n-                        up => {\n-                            ptr::write(self.upgrade.get(), up);\n-                            drop(SignalToken::cast_from_usize(ptr));\n-                            SelCanceled\n-                        }\n-                    }\n-                }\n-                _ => unreachable!(), // we're the \"one blocker\"\n-            }\n-        }\n-    }\n-\n     // Remove a previous selecting thread from this port. This ensures that the\n     // blocked thread will no longer be visible to any other threads.\n     //"}, {"sha": "d1b5f2deccc1c40e7194eeea8a509fa18e6c6f03", "filename": "src/libstd/sync/mpsc/select.rs", "status": "removed", "additions": 0, "deletions": 352, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/caef1e833fbd9de740d521114d716a11a29b71cb/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef1e833fbd9de740d521114d716a11a29b71cb/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=caef1e833fbd9de740d521114d716a11a29b71cb", "patch": "@@ -1,352 +0,0 @@\n-//! Selection over an array of receivers\n-//!\n-//! This module contains the implementation machinery necessary for selecting\n-//! over a number of receivers. One large goal of this module is to provide an\n-//! efficient interface to selecting over any receiver of any type.\n-//!\n-//! This is achieved through an architecture of a \"receiver set\" in which\n-//! receivers are added to a set and then the entire set is waited on at once.\n-//! The set can be waited on multiple times to prevent re-adding each receiver\n-//! to the set.\n-//!\n-//! Usage of this module is currently encouraged to go through the use of the\n-//! `select!` macro. This macro allows naturally binding of variables to the\n-//! received values of receivers in a much more natural syntax then usage of the\n-//! `Select` structure directly.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! #![feature(mpsc_select)]\n-//!\n-//! use std::sync::mpsc::channel;\n-//!\n-//! let (tx1, rx1) = channel();\n-//! let (tx2, rx2) = channel();\n-//!\n-//! tx1.send(1).unwrap();\n-//! tx2.send(2).unwrap();\n-//!\n-//! select! {\n-//!     val = rx1.recv() => {\n-//!         assert_eq!(val.unwrap(), 1);\n-//!     },\n-//!     val = rx2.recv() => {\n-//!         assert_eq!(val.unwrap(), 2);\n-//!     }\n-//! }\n-//! ```\n-\n-#![allow(dead_code)]\n-#![unstable(feature = \"mpsc_select\",\n-            reason = \"This implementation, while likely sufficient, is unsafe and \\\n-                      likely to be error prone. At some point in the future this \\\n-                      module will be removed.\",\n-            issue = \"27800\")]\n-#![rustc_deprecated(since = \"1.32.0\",\n-                    reason = \"channel selection will be removed in a future release\")]\n-\n-use core::cell::{Cell, UnsafeCell};\n-use core::marker;\n-use core::ptr;\n-use core::usize;\n-\n-use crate::fmt;\n-use crate::sync::mpsc::{Receiver, RecvError};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-\n-/// The \"receiver set\" of the select interface. This structure is used to manage\n-/// a set of receivers which are being selected over.\n-pub struct Select {\n-    inner: UnsafeCell<SelectInner>,\n-    next_id: Cell<usize>,\n-}\n-\n-struct SelectInner {\n-    head: *mut Handle<'static, ()>,\n-    tail: *mut Handle<'static, ()>,\n-}\n-\n-impl !marker::Send for Select {}\n-\n-/// A handle to a receiver which is currently a member of a `Select` set of\n-/// receivers. This handle is used to keep the receiver in the set as well as\n-/// interact with the underlying receiver.\n-pub struct Handle<'rx, T:Send+'rx> {\n-    /// The ID of this handle, used to compare against the return value of\n-    /// `Select::wait()`.\n-    id: usize,\n-    selector: *mut SelectInner,\n-    next: *mut Handle<'static, ()>,\n-    prev: *mut Handle<'static, ()>,\n-    added: bool,\n-    packet: &'rx (dyn Packet+'rx),\n-\n-    // due to our fun transmutes, we be sure to place this at the end. (nothing\n-    // previous relies on T)\n-    rx: &'rx Receiver<T>,\n-}\n-\n-struct Packets { cur: *mut Handle<'static, ()> }\n-\n-#[doc(hidden)]\n-#[derive(PartialEq, Eq)]\n-pub enum StartResult {\n-    Installed,\n-    Abort,\n-}\n-\n-#[doc(hidden)]\n-pub trait Packet {\n-    fn can_recv(&self) -> bool;\n-    fn start_selection(&self, token: SignalToken) -> StartResult;\n-    fn abort_selection(&self) -> bool;\n-}\n-\n-impl Select {\n-    /// Creates a new selection structure. This set is initially empty.\n-    ///\n-    /// Usage of this struct directly can sometimes be burdensome, and usage is much easier through\n-    /// the `select!` macro.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(mpsc_select)]\n-    ///\n-    /// use std::sync::mpsc::Select;\n-    ///\n-    /// let select = Select::new();\n-    /// ```\n-    pub fn new() -> Select {\n-        Select {\n-            inner: UnsafeCell::new(SelectInner {\n-                head: ptr::null_mut(),\n-                tail: ptr::null_mut(),\n-            }),\n-            next_id: Cell::new(1),\n-        }\n-    }\n-\n-    /// Creates a new handle into this receiver set for a new receiver. Note\n-    /// that this does *not* add the receiver to the receiver set, for that you\n-    /// must call the `add` method on the handle itself.\n-    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n-        let id = self.next_id.get();\n-        self.next_id.set(id + 1);\n-        Handle {\n-            id,\n-            selector: self.inner.get(),\n-            next: ptr::null_mut(),\n-            prev: ptr::null_mut(),\n-            added: false,\n-            rx,\n-            packet: rx,\n-        }\n-    }\n-\n-    /// Waits for an event on this receiver set. The returned value is *not* an\n-    /// index, but rather an ID. This ID can be queried against any active\n-    /// `Handle` structures (each one has an `id` method). The handle with\n-    /// the matching `id` will have some sort of event available on it. The\n-    /// event could either be that data is available or the corresponding\n-    /// channel has been closed.\n-    pub fn wait(&self) -> usize {\n-        self.wait2(true)\n-    }\n-\n-    /// Helper method for skipping the preflight checks during testing\n-    pub(super) fn wait2(&self, do_preflight_checks: bool) -> usize {\n-        // Note that this is currently an inefficient implementation. We in\n-        // theory have knowledge about all receivers in the set ahead of time,\n-        // so this method shouldn't really have to iterate over all of them yet\n-        // again. The idea with this \"receiver set\" interface is to get the\n-        // interface right this time around, and later this implementation can\n-        // be optimized.\n-        //\n-        // This implementation can be summarized by:\n-        //\n-        //      fn select(receivers) {\n-        //          if any receiver ready { return ready index }\n-        //          deschedule {\n-        //              block on all receivers\n-        //          }\n-        //          unblock on all receivers\n-        //          return ready index\n-        //      }\n-        //\n-        // Most notably, the iterations over all of the receivers shouldn't be\n-        // necessary.\n-        unsafe {\n-            // Stage 1: preflight checks. Look for any packets ready to receive\n-            if do_preflight_checks {\n-                for handle in self.iter() {\n-                    if (*handle).packet.can_recv() {\n-                        return (*handle).id();\n-                    }\n-                }\n-            }\n-\n-            // Stage 2: begin the blocking process\n-            //\n-            // Create a number of signal tokens, and install each one\n-            // sequentially until one fails. If one fails, then abort the\n-            // selection on the already-installed tokens.\n-            let (wait_token, signal_token) = blocking::tokens();\n-            for (i, handle) in self.iter().enumerate() {\n-                match (*handle).packet.start_selection(signal_token.clone()) {\n-                    StartResult::Installed => {}\n-                    StartResult::Abort => {\n-                        // Go back and abort the already-begun selections\n-                        for handle in self.iter().take(i) {\n-                            (*handle).packet.abort_selection();\n-                        }\n-                        return (*handle).id;\n-                    }\n-                }\n-            }\n-\n-            // Stage 3: no messages available, actually block\n-            wait_token.wait();\n-\n-            // Stage 4: there *must* be message available; find it.\n-            //\n-            // Abort the selection process on each receiver. If the abort\n-            // process returns `true`, then that means that the receiver is\n-            // ready to receive some data. Note that this also means that the\n-            // receiver may have yet to have fully read the `to_wake` field and\n-            // woken us up (although the wakeup is guaranteed to fail).\n-            //\n-            // This situation happens in the window of where a sender invokes\n-            // increment(), sees -1, and then decides to wake up the thread. After\n-            // all this is done, the sending thread will set `selecting` to\n-            // `false`. Until this is done, we cannot return. If we were to\n-            // return, then a sender could wake up a receiver which has gone\n-            // back to sleep after this call to `select`.\n-            //\n-            // Note that it is a \"fairly small window\" in which an increment()\n-            // views that it should wake a thread up until the `selecting` bit\n-            // is set to false. For now, the implementation currently just spins\n-            // in a yield loop. This is very distasteful, but this\n-            // implementation is already nowhere near what it should ideally be.\n-            // A rewrite should focus on avoiding a yield loop, and for now this\n-            // implementation is tying us over to a more efficient \"don't\n-            // iterate over everything every time\" implementation.\n-            let mut ready_id = usize::MAX;\n-            for handle in self.iter() {\n-                if (*handle).packet.abort_selection() {\n-                    ready_id = (*handle).id;\n-                }\n-            }\n-\n-            // We must have found a ready receiver\n-            assert!(ready_id != usize::MAX);\n-            return ready_id;\n-        }\n-    }\n-\n-    fn iter(&self) -> Packets { Packets { cur: unsafe { &*self.inner.get() }.head } }\n-}\n-\n-impl<'rx, T: Send> Handle<'rx, T> {\n-    /// Retrieves the ID of this handle.\n-    #[inline]\n-    pub fn id(&self) -> usize { self.id }\n-\n-    /// Blocks to receive a value on the underlying receiver, returning `Some` on\n-    /// success or `None` if the channel disconnects. This function has the same\n-    /// semantics as `Receiver.recv`\n-    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }\n-\n-    /// Adds this handle to the receiver set that the handle was created from. This\n-    /// method can be called multiple times, but it has no effect if `add` was\n-    /// called previously.\n-    ///\n-    /// This method is unsafe because it requires that the `Handle` is not moved\n-    /// while it is added to the `Select` set.\n-    pub unsafe fn add(&mut self) {\n-        if self.added { return }\n-        let selector = &mut *self.selector;\n-        let me = self as *mut Handle<'rx, T> as *mut Handle<'static, ()>;\n-\n-        if selector.head.is_null() {\n-            selector.head = me;\n-            selector.tail = me;\n-        } else {\n-            (*me).prev = selector.tail;\n-            assert!((*me).next.is_null());\n-            (*selector.tail).next = me;\n-            selector.tail = me;\n-        }\n-        self.added = true;\n-    }\n-\n-    /// Removes this handle from the `Select` set. This method is unsafe because\n-    /// it has no guarantee that the `Handle` was not moved since `add` was\n-    /// called.\n-    pub unsafe fn remove(&mut self) {\n-        if !self.added { return }\n-\n-        let selector = &mut *self.selector;\n-        let me = self as *mut Handle<'rx, T> as *mut Handle<'static, ()>;\n-\n-        if self.prev.is_null() {\n-            assert_eq!(selector.head, me);\n-            selector.head = self.next;\n-        } else {\n-            (*self.prev).next = self.next;\n-        }\n-        if self.next.is_null() {\n-            assert_eq!(selector.tail, me);\n-            selector.tail = self.prev;\n-        } else {\n-            (*self.next).prev = self.prev;\n-        }\n-\n-        self.next = ptr::null_mut();\n-        self.prev = ptr::null_mut();\n-\n-        self.added = false;\n-    }\n-}\n-\n-impl Drop for Select {\n-    fn drop(&mut self) {\n-        unsafe {\n-            assert!((&*self.inner.get()).head.is_null());\n-            assert!((&*self.inner.get()).tail.is_null());\n-        }\n-    }\n-}\n-\n-impl<T: Send> Drop for Handle<'_, T> {\n-    fn drop(&mut self) {\n-        unsafe { self.remove() }\n-    }\n-}\n-\n-impl Iterator for Packets {\n-    type Item = *mut Handle<'static, ()>;\n-\n-    fn next(&mut self) -> Option<*mut Handle<'static, ()>> {\n-        if self.cur.is_null() {\n-            None\n-        } else {\n-            let ret = Some(self.cur);\n-            unsafe { self.cur = (*self.cur).next; }\n-            ret\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Select {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Select\").finish()\n-    }\n-}\n-\n-impl<T: Send> fmt::Debug for Handle<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Handle\").finish()\n-    }\n-}"}, {"sha": "18d93462c78db4b6d789eac898c40d2aea631784", "filename": "src/libstd/sync/mpsc/select_tests.rs", "status": "removed", "additions": 0, "deletions": 413, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/caef1e833fbd9de740d521114d716a11a29b71cb/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef1e833fbd9de740d521114d716a11a29b71cb/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect_tests.rs?ref=caef1e833fbd9de740d521114d716a11a29b71cb", "patch": "@@ -1,413 +0,0 @@\n-#![allow(unused_imports)]\n-\n-/// This file exists to hack around https://github.com/rust-lang/rust/issues/47238\n-\n-use crate::thread;\n-use crate::sync::mpsc::*;\n-\n-// Don't use the libstd version so we can pull in the right Select structure\n-// (std::comm points at the wrong one)\n-macro_rules! select {\n-    (\n-        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-    ) => ({\n-        let sel = Select::new();\n-        $( let mut $rx = sel.handle(&$rx); )+\n-        unsafe {\n-            $( $rx.add(); )+\n-        }\n-        let ret = sel.wait();\n-        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-        { unreachable!() }\n-    })\n-}\n-\n-#[test]\n-fn smoke() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    tx1.send(1).unwrap();\n-    select! {\n-        foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n-        _bar = rx2.recv() => { panic!() }\n-    }\n-    tx2.send(2).unwrap();\n-    select! {\n-        _foo = rx1.recv() => { panic!() },\n-        bar = rx2.recv() => { assert_eq!(bar.unwrap(), 2) }\n-    }\n-    drop(tx1);\n-    select! {\n-        foo = rx1.recv() => { assert!(foo.is_err()); },\n-        _bar = rx2.recv() => { panic!() }\n-    }\n-    drop(tx2);\n-    select! {\n-        bar = rx2.recv() => { assert!(bar.is_err()); }\n-    }\n-}\n-\n-#[test]\n-fn smoke2() {\n-    let (_tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (_tx3, rx3) = channel::<i32>();\n-    let (_tx4, rx4) = channel::<i32>();\n-    let (tx5, rx5) = channel::<i32>();\n-    tx5.send(4).unwrap();\n-    select! {\n-        _foo = rx1.recv() => { panic!(\"1\") },\n-        _foo = rx2.recv() => { panic!(\"2\") },\n-        _foo = rx3.recv() => { panic!(\"3\") },\n-        _foo = rx4.recv() => { panic!(\"4\") },\n-        foo = rx5.recv() => { assert_eq!(foo.unwrap(), 4); }\n-    }\n-}\n-\n-#[test]\n-fn closed() {\n-    let (_tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    drop(tx2);\n-\n-    select! {\n-        _a1 = rx1.recv() => { panic!() },\n-        a2 = rx2.recv() => { assert!(a2.is_err()); }\n-    }\n-}\n-\n-#[test]\n-fn unblocks() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<i32>();\n-\n-    let _t = thread::spawn(move|| {\n-        for _ in 0..20 { thread::yield_now(); }\n-        tx1.send(1).unwrap();\n-        rx3.recv().unwrap();\n-        for _ in 0..20 { thread::yield_now(); }\n-    });\n-\n-    select! {\n-        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-        _b = rx2.recv() => { panic!() }\n-    }\n-    tx3.send(1).unwrap();\n-    select! {\n-        a = rx1.recv() => { assert!(a.is_err()) },\n-        _b = rx2.recv() => { panic!() }\n-    }\n-}\n-\n-#[test]\n-fn both_ready() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        for _ in 0..20 { thread::yield_now(); }\n-        tx1.send(1).unwrap();\n-        tx2.send(2).unwrap();\n-        rx3.recv().unwrap();\n-    });\n-\n-    select! {\n-        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-    }\n-    select! {\n-        a = rx1.recv() => { assert_eq!(a.unwrap(), 1); },\n-        a = rx2.recv() => { assert_eq!(a.unwrap(), 2); }\n-    }\n-    assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-    assert_eq!(rx2.try_recv(), Err(TryRecvError::Empty));\n-    tx3.send(()).unwrap();\n-}\n-\n-#[test]\n-fn stress() {\n-    const AMT: i32 = 10000;\n-    let (tx1, rx1) = channel::<i32>();\n-    let (tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        for i in 0..AMT {\n-            if i % 2 == 0 {\n-                tx1.send(i).unwrap();\n-            } else {\n-                tx2.send(i).unwrap();\n-            }\n-            rx3.recv().unwrap();\n-        }\n-    });\n-\n-    for i in 0..AMT {\n-        select! {\n-            i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n-            i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n-        }\n-        tx3.send(()).unwrap();\n-    }\n-}\n-\n-#[allow(unused_must_use)]\n-#[test]\n-fn cloning() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        rx3.recv().unwrap();\n-        tx1.clone();\n-        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-        tx1.send(2).unwrap();\n-        rx3.recv().unwrap();\n-    });\n-\n-    tx3.send(()).unwrap();\n-    select! {\n-        _i1 = rx1.recv() => {},\n-        _i2 = rx2.recv() => panic!()\n-    }\n-    tx3.send(()).unwrap();\n-}\n-\n-#[allow(unused_must_use)]\n-#[test]\n-fn cloning2() {\n-    let (tx1, rx1) = channel::<i32>();\n-    let (_tx2, rx2) = channel::<i32>();\n-    let (tx3, rx3) = channel::<()>();\n-\n-    let _t = thread::spawn(move|| {\n-        rx3.recv().unwrap();\n-        tx1.clone();\n-        assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n-        tx1.send(2).unwrap();\n-        rx3.recv().unwrap();\n-    });\n-\n-    tx3.send(()).unwrap();\n-    select! {\n-        _i1 = rx1.recv() => {},\n-        _i2 = rx2.recv() => panic!()\n-    }\n-    tx3.send(()).unwrap();\n-}\n-\n-#[test]\n-fn cloning3() {\n-    let (tx1, rx1) = channel::<()>();\n-    let (tx2, rx2) = channel::<()>();\n-    let (tx3, rx3) = channel::<()>();\n-    let _t = thread::spawn(move|| {\n-        let s = Select::new();\n-        let mut h1 = s.handle(&rx1);\n-        let mut h2 = s.handle(&rx2);\n-        unsafe { h2.add(); }\n-        unsafe { h1.add(); }\n-        assert_eq!(s.wait(), h2.id());\n-        tx3.send(()).unwrap();\n-    });\n-\n-    for _ in 0..1000 { thread::yield_now(); }\n-    drop(tx1.clone());\n-    tx2.send(()).unwrap();\n-    rx3.recv().unwrap();\n-}\n-\n-#[test]\n-fn preflight1() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    select! {\n-        _n = rx.recv() => {}\n-    }\n-}\n-\n-#[test]\n-fn preflight2() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    tx.send(()).unwrap();\n-    select! {\n-        _n = rx.recv() => {}\n-    }\n-}\n-\n-#[test]\n-fn preflight3() {\n-    let (tx, rx) = channel();\n-    drop(tx.clone());\n-    tx.send(()).unwrap();\n-    select! {\n-        _n = rx.recv() => {}\n-    }\n-}\n-\n-#[test]\n-fn preflight4() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight5() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    tx.send(()).unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight6() {\n-    let (tx, rx) = channel();\n-    drop(tx.clone());\n-    tx.send(()).unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight7() {\n-    let (tx, rx) = channel::<()>();\n-    drop(tx);\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight8() {\n-    let (tx, rx) = channel();\n-    tx.send(()).unwrap();\n-    drop(tx);\n-    rx.recv().unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn preflight9() {\n-    let (tx, rx) = channel();\n-    drop(tx.clone());\n-    tx.send(()).unwrap();\n-    drop(tx);\n-    rx.recv().unwrap();\n-    let s = Select::new();\n-    let mut h = s.handle(&rx);\n-    unsafe { h.add(); }\n-    assert_eq!(s.wait2(false), h.id());\n-}\n-\n-#[test]\n-fn oneshot_data_waiting() {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    let _t = thread::spawn(move|| {\n-        select! {\n-            _n = rx1.recv() => {}\n-        }\n-        tx2.send(()).unwrap();\n-    });\n-\n-    for _ in 0..100 { thread::yield_now() }\n-    tx1.send(()).unwrap();\n-    rx2.recv().unwrap();\n-}\n-\n-#[test]\n-fn stream_data_waiting() {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    tx1.send(()).unwrap();\n-    tx1.send(()).unwrap();\n-    rx1.recv().unwrap();\n-    rx1.recv().unwrap();\n-    let _t = thread::spawn(move|| {\n-        select! {\n-            _n = rx1.recv() => {}\n-        }\n-        tx2.send(()).unwrap();\n-    });\n-\n-    for _ in 0..100 { thread::yield_now() }\n-    tx1.send(()).unwrap();\n-    rx2.recv().unwrap();\n-}\n-\n-#[test]\n-fn shared_data_waiting() {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    drop(tx1.clone());\n-    tx1.send(()).unwrap();\n-    rx1.recv().unwrap();\n-    let _t = thread::spawn(move|| {\n-        select! {\n-            _n = rx1.recv() => {}\n-        }\n-        tx2.send(()).unwrap();\n-    });\n-\n-    for _ in 0..100 { thread::yield_now() }\n-    tx1.send(()).unwrap();\n-    rx2.recv().unwrap();\n-}\n-\n-#[test]\n-fn sync1() {\n-    let (tx, rx) = sync_channel::<i32>(1);\n-    tx.send(1).unwrap();\n-    select! {\n-        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-    }\n-}\n-\n-#[test]\n-fn sync2() {\n-    let (tx, rx) = sync_channel::<i32>(0);\n-    let _t = thread::spawn(move|| {\n-        for _ in 0..100 { thread::yield_now() }\n-        tx.send(1).unwrap();\n-    });\n-    select! {\n-        n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n-    }\n-}\n-\n-#[test]\n-fn sync3() {\n-    let (tx1, rx1) = sync_channel::<i32>(0);\n-    let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n-    let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n-    let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n-    select! {\n-        n = rx1.recv() => {\n-            let n = n.unwrap();\n-            assert_eq!(n, 1);\n-            assert_eq!(rx2.recv().unwrap(), 2);\n-        },\n-        n = rx2.recv() => {\n-            let n = n.unwrap();\n-            assert_eq!(n, 2);\n-            assert_eq!(rx1.recv().unwrap(), 1);\n-        }\n-    }\n-}"}, {"sha": "dbcdcdac9326855330847013db2d442e233e5623", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -9,6 +9,7 @@\n /// channels are quite similar, and this is no coincidence!\n \n pub use self::Failure::*;\n+use self::StartResult::*;\n \n use core::cmp;\n use core::intrinsics::abort;\n@@ -19,8 +20,6 @@ use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::mpsc_queue as mpsc;\n-use crate::sync::mpsc::select::StartResult::*;\n-use crate::sync::mpsc::select::StartResult;\n use crate::sync::{Mutex, MutexGuard};\n use crate::thread;\n use crate::time::Instant;\n@@ -57,6 +56,12 @@ pub enum Failure {\n     Disconnected,\n }\n \n+#[derive(PartialEq, Eq)]\n+enum StartResult {\n+    Installed,\n+    Abort,\n+}\n+\n impl<T> Packet<T> {\n     // Creation of a packet *must* be followed by a call to postinit_lock\n     // and later by inherit_blocker\n@@ -394,16 +399,6 @@ impl<T> Packet<T> {\n     // select implementation\n     ////////////////////////////////////////////////////////////////////////////\n \n-    // Helper function for select, tests whether this port can receive without\n-    // blocking (obviously not an atomic decision).\n-    //\n-    // This is different than the stream version because there's no need to peek\n-    // at the queue, we can just look at the local count.\n-    pub fn can_recv(&self) -> bool {\n-        let cnt = self.cnt.load(Ordering::SeqCst);\n-        cnt == DISCONNECTED || cnt - unsafe { *self.steals.get() } > 0\n-    }\n-\n     // increment the count on the channel (used for selection)\n     fn bump(&self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n@@ -415,22 +410,6 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Inserts the signal token for selection on this port, returning true if\n-    // blocking should proceed.\n-    //\n-    // The code here is the same as in stream.rs, except that it doesn't need to\n-    // peek at the channel to see if an upgrade is pending.\n-    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        match self.decrement(token) {\n-            Installed => Installed,\n-            Abort => {\n-                let prev = self.bump(1);\n-                assert!(prev == DISCONNECTED || prev >= 0);\n-                Abort\n-            }\n-        }\n-    }\n-\n     // Cancels a previous thread waiting on this port, returning whether there's\n     // data on the port.\n     //"}, {"sha": "40877282761790cd78c989d9eb37fad0cd92c181", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -9,7 +9,6 @@\n \n pub use self::Failure::*;\n pub use self::UpgradeResult::*;\n-pub use self::SelectionResult::*;\n use self::Message::*;\n \n use core::cmp;\n@@ -60,12 +59,6 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n-    SelSuccess,\n-    SelCanceled,\n-    SelUpgraded(SignalToken, Receiver<T>),\n-}\n-\n // Any message could contain an \"upgrade request\" to a new shared port, so the\n // internal queue it's a queue of T, but rather Message<T>\n enum Message<T> {\n@@ -338,27 +331,6 @@ impl<T> Packet<T> {\n     // select implementation\n     ////////////////////////////////////////////////////////////////////////////\n \n-    // Tests to see whether this port can receive without blocking. If Ok is\n-    // returned, then that's the answer. If Err is returned, then the returned\n-    // port needs to be queried instead (an upgrade happened)\n-    pub fn can_recv(&self) -> Result<bool, Receiver<T>> {\n-        // We peek at the queue to see if there's anything on it, and we use\n-        // this return value to determine if we should pop from the queue and\n-        // upgrade this channel immediately. If it looks like we've got an\n-        // upgrade pending, then go through the whole recv rigamarole to update\n-        // the internal state.\n-        match self.queue.peek() {\n-            Some(&mut GoUp(..)) => {\n-                match self.recv(None) {\n-                    Err(Upgraded(port)) => Err(port),\n-                    _ => unreachable!(),\n-                }\n-            }\n-            Some(..) => Ok(true),\n-            None => Ok(false)\n-        }\n-    }\n-\n     // increment the count on the channel (used for selection)\n     fn bump(&self, amt: isize) -> isize {\n         match self.queue.producer_addition().cnt.fetch_add(amt, Ordering::SeqCst) {\n@@ -370,31 +342,6 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Attempts to start selecting on this port. Like a oneshot, this can fail\n-    // immediately because of an upgrade.\n-    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> {\n-        match self.decrement(token) {\n-            Ok(()) => SelSuccess,\n-            Err(token) => {\n-                let ret = match self.queue.peek() {\n-                    Some(&mut GoUp(..)) => {\n-                        match self.queue.pop() {\n-                            Some(GoUp(port)) => SelUpgraded(token, port),\n-                            _ => unreachable!(),\n-                        }\n-                    }\n-                    Some(..) => SelCanceled,\n-                    None => SelCanceled,\n-                };\n-                // Undo our decrement above, and we should be guaranteed that the\n-                // previous value is positive because we're not going to sleep\n-                let prev = self.bump(1);\n-                assert!(prev == DISCONNECTED || prev >= 0);\n-                ret\n-            }\n-        }\n-    }\n-\n     // Removes a previous thread from being blocked in this port\n     pub fn abort_selection(&self,\n                            was_upgrade: bool) -> Result<bool, Receiver<T>> {"}, {"sha": "3c4f8e077c922ee536340b607fc3e2c2b29179cc", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -33,7 +33,6 @@ use core::ptr;\n \n use crate::sync::atomic::{Ordering, AtomicUsize};\n use crate::sync::mpsc::blocking::{self, WaitToken, SignalToken};\n-use crate::sync::mpsc::select::StartResult::{self, Installed, Abort};\n use crate::sync::{Mutex, MutexGuard};\n use crate::time::Instant;\n \n@@ -406,42 +405,6 @@ impl<T> Packet<T> {\n         while let Some(token) = queue.dequeue() { token.signal(); }\n         waiter.map(|t| t.signal());\n     }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // If Ok, the value is whether this port has data, if Err, then the upgraded\n-    // port needs to be checked instead of this one.\n-    pub fn can_recv(&self) -> bool {\n-        let guard = self.lock.lock().unwrap();\n-        guard.disconnected || guard.buf.size() > 0\n-    }\n-\n-    // Attempts to start selection on this port. This can either succeed or fail\n-    // because there is data waiting.\n-    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n-        let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected || guard.buf.size() > 0 {\n-            Abort\n-        } else {\n-            match mem::replace(&mut guard.blocker, BlockedReceiver(token)) {\n-                NoneBlocked => {}\n-                BlockedSender(..) => unreachable!(),\n-                BlockedReceiver(..) => unreachable!(),\n-            }\n-            Installed\n-        }\n-    }\n-\n-    // Remove a previous selecting thread from this port. This ensures that the\n-    // blocked thread will no longer be visible to any other threads.\n-    //\n-    // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&self) -> bool {\n-        let mut guard = self.lock.lock().unwrap();\n-        abort_selection(&mut guard)\n-    }\n }\n \n impl<T> Drop for Packet<T> {"}, {"sha": "12be97702a9f4cfb2f2adf1e1c810db2ddb8f553", "filename": "src/test/run-pass/issues/issue-13494.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/caef1e833fbd9de740d521114d716a11a29b71cb/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef1e833fbd9de740d521114d716a11a29b71cb/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13494.rs?ref=caef1e833fbd9de740d521114d716a11a29b71cb", "patch": "@@ -1,35 +0,0 @@\n-// run-pass\n-#![allow(unused_must_use)]\n-// ignore-emscripten no threads support\n-\n-// This test may not always fail, but it can be flaky if the race it used to\n-// expose is still present.\n-\n-#![feature(mpsc_select)]\n-#![allow(deprecated)]\n-\n-use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread;\n-\n-fn helper(rx: Receiver<Sender<()>>) {\n-    for tx in rx.iter() {\n-        let _ = tx.send(());\n-    }\n-}\n-\n-fn main() {\n-    let (tx, rx) = channel();\n-    let t = thread::spawn(move|| { helper(rx) });\n-    let (snd, rcv) = channel::<isize>();\n-    for _ in 1..100000 {\n-        snd.send(1).unwrap();\n-        let (tx2, rx2) = channel();\n-        tx.send(tx2).unwrap();\n-        select! {\n-            _ = rx2.recv() => (),\n-            _ = rcv.recv() => ()\n-        }\n-    }\n-    drop(tx);\n-    t.join();\n-}"}, {"sha": "12a612c153ad62f085884b66c058e350a9dbeeb0", "filename": "src/test/run-pass/macros/macro-comma-support.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-comma-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589beb979c0f1a9736e02e578913db88398c3ba5/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-comma-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-comma-support.rs?ref=589beb979c0f1a9736e02e578913db88398c3ba5", "patch": "@@ -233,8 +233,6 @@ fn println() {\n     println!(\"hello {}\", \"world\",);\n }\n \n-// select! is too troublesome and unlikely to be stabilized\n-\n // stringify! is N/A\n \n #[cfg(std)]"}]}