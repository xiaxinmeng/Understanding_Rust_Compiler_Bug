{"sha": "f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ODdiOWQ3NzFmY2UzOWQxMTAyZmYxMzA0MmE2ZGZjNDVmNGJmOGQ=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T20:03:40Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T20:45:54Z"}, "message": "Use `///` style doc-comments and add missing headings", "tree": {"sha": "382b6cfaa5693179a654cfd7ec384a3041e881ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382b6cfaa5693179a654cfd7ec384a3041e881ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "html_url": "https://github.com/rust-lang/rust/commit/f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f687b9d771fce39d1102ff13042a6dfc45f4bf8d/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efe6564a0e650e5a784e8883c8836068e0a13e15", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe6564a0e650e5a784e8883c8836068e0a13e15", "html_url": "https://github.com/rust-lang/rust/commit/efe6564a0e650e5a784e8883c8836068e0a13e15"}], "stats": {"total": 155, "additions": 83, "deletions": 72}, "files": [{"sha": "f977845eb8a58da0c00d31058a8f75279ff7f885", "filename": "src/libcore/char.rs", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f687b9d771fce39d1102ff13042a6dfc45f4bf8d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f687b9d771fce39d1102ff13042a6dfc45f4bf8d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f687b9d771fce39d1102ff13042a6dfc45f4bf8d", "patch": "@@ -60,25 +60,25 @@ pub fn is_alphabetic(c: char) -> bool   { derived_property::Alphabetic(c) }\n pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n \n-/**\n- * Indicates whether a character is in lower case, defined\n- * in terms of the Unicode General Category 'Ll'\n- */\n+///\n+/// Indicates whether a character is in lower case, defined\n+/// in terms of the Unicode General Category 'Ll'\n+///\n #[inline(always)]\n pub fn is_lowercase(c: char) -> bool { general_category::Ll(c) }\n \n-/**\n- * Indicates whether a character is in upper case, defined\n- * in terms of the Unicode General Category 'Lu'.\n- */\n+///\n+/// Indicates whether a character is in upper case, defined\n+/// in terms of the Unicode General Category 'Lu'.\n+///\n #[inline(always)]\n pub fn is_uppercase(c: char) -> bool { general_category::Lu(c) }\n \n-/**\n- * Indicates whether a character is whitespace. Whitespace is defined in\n- * terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n- * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n- */\n+///\n+/// Indicates whether a character is whitespace. Whitespace is defined in\n+/// terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n+/// additional 'Cc'-category control codes in the range [0x09, 0x0d]\n+///\n #[inline(always)]\n pub fn is_whitespace(c: char) -> bool {\n     ('\\x09' <= c && c <= '\\x0d')\n@@ -87,11 +87,11 @@ pub fn is_whitespace(c: char) -> bool {\n         || general_category::Zp(c)\n }\n \n-/**\n- * Indicates whether a character is alphanumeric. Alphanumericness is\n- * defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n- * and the Derived Core Property 'Alphabetic'.\n- */\n+///\n+/// Indicates whether a character is alphanumeric. Alphanumericness is\n+/// defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n+/// and the Derived Core Property 'Alphabetic'.\n+///\n #[inline(always)]\n pub fn is_alphanumeric(c: char) -> bool {\n     derived_property::Alphabetic(c)\n@@ -108,18 +108,24 @@ pub fn is_digit(c: char) -> bool {\n         || general_category::No(c)\n }\n \n-/**\n- * Checks if a character parses as a numeric digit in the given radix.\n- * Compared to `is_digit()`, this function only recognizes the\n- * characters `0-9`, `a-z` and `A-Z`.\n- *\n- * Returns `true` if `c` is a valid digit under `radix`, and `false`\n- * otherwise.\n- *\n- * Fails if given a `radix` > 36.\n- *\n- * Note: This just wraps `to_digit()`.\n- */\n+///\n+/// Checks if a character parses as a numeric digit in the given radix.\n+/// Compared to `is_digit()`, this function only recognizes the\n+/// characters `0-9`, `a-z` and `A-Z`.\n+///\n+/// # Return value\n+///\n+/// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+/// otherwise.\n+///\n+/// # Failure\n+///\n+/// Fails if given a `radix` > 36.\n+///\n+/// # Note\n+///\n+/// This just wraps `to_digit()`.\n+///\n #[inline(always)]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     match to_digit(c, radix) {\n@@ -128,19 +134,20 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n     }\n }\n \n-/**\n- * Convert a char to the corresponding digit.\n- *\n- * # Return value\n- *\n- * If `c` is between '0' and '9', the corresponding value\n- * between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n- * 'b' or 'B', 11, etc. Returns none if the char does not\n- * refer to a digit in the given radix.\n- *\n- * # Failure\n- * Fails if given a `radix` outside the range `[0..36]`.\n- */\n+///\n+/// Convert a char to the corresponding digit.\n+///\n+/// # Return value\n+///\n+/// If `c` is between '0' and '9', the corresponding value\n+/// between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n+/// 'b' or 'B', 11, etc. Returns none if the char does not\n+/// refer to a digit in the given radix.\n+///\n+/// # Failure\n+///\n+/// Fails if given a `radix` outside the range `[0..36]`.\n+///\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n@@ -156,14 +163,18 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     else { None }\n }\n \n-/**\n- * Converts a number to the character representing it.\n- *\n- * Returns `Some(char)` if `num` represents one digit under `radix`,\n- * using one character of `0-9` or `a-z`, or `None` if it doesn't.\n- *\n- * Fails if given an `radix` > 36.\n- */\n+///\n+/// Converts a number to the character representing it.\n+///\n+/// # Return value\n+///\n+/// Returns `Some(char)` if `num` represents one digit under `radix`,\n+/// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n+///\n+/// # Failure\n+///\n+/// Fails if given an `radix` > 36.\n+///\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n@@ -195,15 +206,15 @@ pub fn escape_unicode(c: char) -> ~str {\n     out\n }\n \n-/**\n- * Return the hexadecimal unicode escape of a char.\n- *\n- * The rules are as follows:\n- *\n- *   - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n- *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n- *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n- */\n+///\n+/// Return the hexadecimal unicode escape of a char.\n+///\n+/// The rules are as follows:\n+///\n+/// - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n+/// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n+/// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n+///\n #[cfg(not(stage0))]\n pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str_radix(c as u32, 16u);\n@@ -222,18 +233,18 @@ pub fn escape_unicode(c: char) -> ~str {\n     out\n }\n \n-/**\n- * Return a 'default' ASCII and C++11-like char-literal escape of a char.\n- *\n- * The default is chosen with a bias toward producing literals that are\n- * legal in a variety of languages, including C++11 and similar C-family\n- * languages. The exact rules are:\n- *\n- *   - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n- *   - Single-quote, double-quote and backslash chars are backslash-escaped.\n- *   - Any other chars in the range [0x20,0x7e] are not escaped.\n- *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n- */\n+///\n+/// Return a 'default' ASCII and C++11-like char-literal escape of a char.\n+///\n+/// The default is chosen with a bias toward producing literals that are\n+/// legal in a variety of languages, including C++11 and similar C-family\n+/// languages. The exact rules are:\n+///\n+/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n+/// - Any other chars in the range [0x20,0x7e] are not escaped.\n+/// - Any other chars are given hex unicode escapes; see `escape_unicode`.\n+///\n pub fn escape_default(c: char) -> ~str {\n     match c {\n         '\\t' => ~\"\\\\t\","}]}