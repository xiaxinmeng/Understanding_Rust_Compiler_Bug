{"sha": "ec70387a4cac131f34847c94e9fe7de66acc241e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNzAzODdhNGNhYzEzMWYzNDg0N2M5NGU5ZmU3ZGU2NmFjYzI0MWU=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2021-03-12T18:12:17Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2021-03-12T18:12:17Z"}, "message": "Use Chalk Environment more directly", "tree": {"sha": "eba9f9c4fe5c807b3ac27f0bc9d841f693843226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eba9f9c4fe5c807b3ac27f0bc9d841f693843226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec70387a4cac131f34847c94e9fe7de66acc241e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec70387a4cac131f34847c94e9fe7de66acc241e", "html_url": "https://github.com/rust-lang/rust/commit/ec70387a4cac131f34847c94e9fe7de66acc241e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec70387a4cac131f34847c94e9fe7de66acc241e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0459c53572f90fa9134192e432562af3daba5fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0459c53572f90fa9134192e432562af3daba5fa", "html_url": "https://github.com/rust-lang/rust/commit/c0459c53572f90fa9134192e432562af3daba5fa"}], "stats": {"total": 99, "additions": 44, "deletions": 55}, "files": [{"sha": "d84ec9b7a7a03a3a1c22595425b4d5f647585541", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=ec70387a4cac131f34847c94e9fe7de66acc241e", "patch": "@@ -8,7 +8,7 @@\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n-use chalk_ir::Mutability;\n+use chalk_ir::{cast::Cast, Mutability};\n use hir_def::{\n     adt::StructKind,\n     builtin_type::BuiltinType,\n@@ -27,6 +27,7 @@ use stdx::impl_from;\n \n use crate::{\n     db::HirDatabase,\n+    traits::chalk::{Interner, ToChalk},\n     utils::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n         make_mut_slice, variant_data,\n@@ -914,10 +915,21 @@ impl TraitEnvironment {\n     pub fn lower(db: &dyn HirDatabase, resolver: &Resolver) -> Arc<TraitEnvironment> {\n         let ctx = TyLoweringContext::new(db, &resolver)\n             .with_type_param_mode(TypeParamLoweringMode::Placeholder);\n-        let mut predicates = resolver\n-            .where_predicates_in_scope()\n-            .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n-            .collect::<Vec<_>>();\n+        let mut traits_in_scope = Vec::new();\n+        let mut clauses = Vec::new();\n+        for pred in resolver.where_predicates_in_scope() {\n+            for pred in GenericPredicate::from_where_predicate(&ctx, pred) {\n+                if pred.is_error() {\n+                    continue;\n+                }\n+                if let GenericPredicate::Implemented(tr) = &pred {\n+                    traits_in_scope.push((tr.self_ty().clone(), tr.trait_));\n+                }\n+                let program_clause: chalk_ir::ProgramClause<Interner> =\n+                    pred.clone().to_chalk(db).cast(&Interner);\n+                clauses.push(program_clause.into_from_env_clause(&Interner));\n+            }\n+        }\n \n         if let Some(def) = resolver.generic_def() {\n             let container: Option<AssocContainerId> = match def {\n@@ -938,12 +950,15 @@ impl TraitEnvironment {\n                 let substs = Substs::type_params(db, trait_id);\n                 let trait_ref = TraitRef { trait_: trait_id, substs };\n                 let pred = GenericPredicate::Implemented(trait_ref);\n-\n-                predicates.push(pred);\n+                let program_clause: chalk_ir::ProgramClause<Interner> =\n+                    pred.clone().to_chalk(db).cast(&Interner);\n+                clauses.push(program_clause.into_from_env_clause(&Interner));\n             }\n         }\n \n-        Arc::new(TraitEnvironment { predicates })\n+        let env = chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses);\n+\n+        Arc::new(TraitEnvironment { traits_from_clauses: traits_in_scope, env })\n     }\n }\n "}, {"sha": "d57c6de70ea54134b50c12be8edcc6a5b29c955e", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=ec70387a4cac131f34847c94e9fe7de66acc241e", "patch": "@@ -528,8 +528,7 @@ fn iterate_trait_method_candidates(\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n     let env_traits = if let Ty::Placeholder(_) = self_ty.value {\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-        env.trait_predicates_for_self_ty(&self_ty.value)\n-            .map(|tr| tr.trait_)\n+        env.traits_in_scope_from_clauses(&self_ty.value)\n             .flat_map(|t| all_super_traits(db.upcast(), t))\n             .collect()\n     } else {"}, {"sha": "27f350f70b33aba7f56b9ada291b18401c17c23a", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=ec70387a4cac131f34847c94e9fe7de66acc241e", "patch": "@@ -38,22 +38,25 @@ fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n /// fn foo<T: Default>(t: T) {}\n /// ```\n /// we assume that `T: Default`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitEnvironment {\n-    pub predicates: Vec<GenericPredicate>,\n+    // When we're using Chalk's Ty we can make this a BTreeMap since it's Ord,\n+    // but for now it's too annoying...\n+    pub(crate) traits_from_clauses: Vec<(Ty, TraitId)>,\n+    pub(crate) env: chalk_ir::Environment<Interner>,\n }\n \n impl TraitEnvironment {\n-    /// Returns trait refs with the given self type which are supposed to hold\n-    /// in this trait env. E.g. if we are in `foo<T: SomeTrait>()`, this will\n-    /// find that `T: SomeTrait` if we call it for `T`.\n-    pub(crate) fn trait_predicates_for_self_ty<'a>(\n+    pub(crate) fn traits_in_scope_from_clauses<'a>(\n         &'a self,\n         ty: &'a Ty,\n-    ) -> impl Iterator<Item = &'a TraitRef> + 'a {\n-        self.predicates.iter().filter_map(move |pred| match pred {\n-            GenericPredicate::Implemented(tr) if tr.self_ty() == ty => Some(tr),\n-            _ => None,\n+    ) -> impl Iterator<Item = TraitId> + 'a {\n+        self.traits_from_clauses.iter().filter_map(move |(self_ty, trait_id)| {\n+            if self_ty == ty {\n+                Some(*trait_id)\n+            } else {\n+                None\n+            }\n         })\n     }\n }"}, {"sha": "4e7d43f7eadb1090c20dcf377f68f7c330d81e25", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=ec70387a4cac131f34847c94e9fe7de66acc241e", "patch": "@@ -33,13 +33,13 @@ pub(super) mod tls;\n mod interner;\n mod mapping;\n \n-pub(super) trait ToChalk {\n+pub(crate) trait ToChalk {\n     type Chalk;\n     fn to_chalk(self, db: &dyn HirDatabase) -> Self::Chalk;\n     fn from_chalk(db: &dyn HirDatabase, chalk: Self::Chalk) -> Self;\n }\n \n-pub(super) fn from_chalk<T, ChalkT>(db: &dyn HirDatabase, chalk: ChalkT) -> T\n+pub(crate) fn from_chalk<T, ChalkT>(db: &dyn HirDatabase, chalk: ChalkT) -> T\n where\n     T: ToChalk<Chalk = ChalkT>,\n {"}, {"sha": "b0415e8b03f72880995614b66a1573dd85215b51", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec70387a4cac131f34847c94e9fe7de66acc241e/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=ec70387a4cac131f34847c94e9fe7de66acc241e", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     primitive::UintTy,\n     traits::{Canonical, Obligation},\n     AliasTy, CallableDefId, FnPointer, FnSig, GenericPredicate, InEnvironment, OpaqueTy,\n-    OpaqueTyId, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty,\n+    OpaqueTyId, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitRef, Ty,\n };\n \n use super::interner::*;\n@@ -536,31 +536,6 @@ where\n     }\n }\n \n-impl ToChalk for Arc<TraitEnvironment> {\n-    type Chalk = chalk_ir::Environment<Interner>;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Environment<Interner> {\n-        let mut clauses = Vec::new();\n-        for pred in &self.predicates {\n-            if pred.is_error() {\n-                // for env, we just ignore errors\n-                continue;\n-            }\n-            let program_clause: chalk_ir::ProgramClause<Interner> =\n-                pred.clone().to_chalk(db).cast(&Interner);\n-            clauses.push(program_clause.into_from_env_clause(&Interner));\n-        }\n-        chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses)\n-    }\n-\n-    fn from_chalk(\n-        _db: &dyn HirDatabase,\n-        _env: chalk_ir::Environment<Interner>,\n-    ) -> Arc<TraitEnvironment> {\n-        unimplemented!()\n-    }\n-}\n-\n impl<T: ToChalk> ToChalk for InEnvironment<T>\n where\n     T::Chalk: chalk_ir::interner::HasInterner<Interner = Interner>,\n@@ -569,19 +544,16 @@ where\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n         chalk_ir::InEnvironment {\n-            environment: self.environment.to_chalk(db),\n+            environment: self.environment.env.clone(),\n             goal: self.value.to_chalk(db),\n         }\n     }\n \n     fn from_chalk(\n-        db: &dyn HirDatabase,\n-        in_env: chalk_ir::InEnvironment<T::Chalk>,\n+        _db: &dyn HirDatabase,\n+        _in_env: chalk_ir::InEnvironment<T::Chalk>,\n     ) -> InEnvironment<T> {\n-        InEnvironment {\n-            environment: from_chalk(db, in_env.environment),\n-            value: from_chalk(db, in_env.goal),\n-        }\n+        unimplemented!()\n     }\n }\n "}]}