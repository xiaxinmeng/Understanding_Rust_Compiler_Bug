{"sha": "ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmY2ZkY2ZlNGM3M2ZkZDVmZjc0NDFhOGY4ZTZhNWQ3N2I0ZTk0ZWU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-06T16:37:58Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-08T21:23:21Z"}, "message": "Inline the function `with_lvalue_ref` into `trans_transmute`\n\nThe function was a footgun because it created `undef` references to\nZSTs, which could cause trouble were they to leak to user code.", "tree": {"sha": "b70bce0641f1b826af58bc89e489b16a4c9453af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b70bce0641f1b826af58bc89e489b16a4c9453af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee", "html_url": "https://github.com/rust-lang/rust/commit/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ce1f5194c13cfbd90a40a19b93df3a2383b3b9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ce1f5194c13cfbd90a40a19b93df3a2383b3b9d", "html_url": "https://github.com/rust-lang/rust/commit/7ce1f5194c13cfbd90a40a19b93df3a2383b3b9d"}], "stats": {"total": 80, "additions": 31, "deletions": 49}, "files": [{"sha": "9a4cfb6f984856a297075e9cfd29b5af44a5cbc6", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n-use rustc::ty::{self, layout};\n+use rustc::ty::{self, layout, TypeFoldable};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n@@ -435,10 +435,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n-                    self.with_lvalue_ref(&bcx, dest, |this, dest| {\n-                        this.trans_transmute(&bcx, &args[0], dest);\n-                    });\n-\n+                    self.trans_transmute(&bcx, &args[0], dest);\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n@@ -877,7 +874,34 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_transmute(&mut self, bcx: &Builder<'a, 'tcx>,\n-                       src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n+                       src: &mir::Operand<'tcx>,\n+                       dst: &mir::Lvalue<'tcx>) {\n+        if let mir::Lvalue::Local(index) = *dst {\n+            match self.locals[index] {\n+                LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, &lvalue),\n+                LocalRef::Operand(None) => {\n+                    let lvalue_ty = self.monomorphized_lvalue_ty(dst);\n+                    assert!(!lvalue_ty.has_erasable_regions());\n+                    let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"transmute_temp\");\n+                    self.trans_transmute_into(bcx, src, &lvalue);\n+                    let op = self.trans_load(bcx, lvalue.llval, lvalue.alignment, lvalue_ty);\n+                    self.locals[index] = LocalRef::Operand(Some(op));\n+                }\n+                LocalRef::Operand(Some(_)) => {\n+                    let ty = self.monomorphized_lvalue_ty(dst);\n+                    assert!(common::type_is_zero_size(bcx.ccx, ty),\n+                            \"assigning to initialized SSAtemp\");\n+                }\n+            }\n+        } else {\n+            let dst = self.trans_lvalue(bcx, dst);\n+            self.trans_transmute_into(bcx, src, &dst);\n+        }\n+    }\n+\n+    fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n+                            src: &mir::Operand<'tcx>,\n+                            dst: &LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n             let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.tcx()));"}, {"sha": "2538f32031fdb2e9f719bcee93f9c4ac34d6e41e", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ffcfdcfe4c73fdd5ff7441a8f8e6a5d77b4e94ee", "patch": "@@ -15,10 +15,9 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n use builder::Builder;\n-use common::{self, CrateContext, C_uint, C_undef};\n+use common::{self, CrateContext, C_uint};\n use consts;\n use machine;\n-use type_of::type_of;\n use type_of;\n use type_::Type;\n use value::Value;\n@@ -416,47 +415,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         result\n     }\n \n-    // Perform an action using the given Lvalue.\n-    // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n-    // is created first, then used as an operand to update the Lvalue.\n-    //\n-    // FIXME: this is only called from transmute; please remove it.\n-    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &Builder<'a, 'tcx>,\n-                                 lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n-    where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n-    {\n-        if let mir::Lvalue::Local(index) = *lvalue {\n-            match self.locals[index] {\n-                LocalRef::Lvalue(lvalue) => f(self, lvalue),\n-                LocalRef::Operand(None) => {\n-                    let lvalue_ty = self.monomorphized_lvalue_ty(lvalue);\n-                    assert!(!lvalue_ty.has_erasable_regions());\n-                    let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"lvalue_temp\");\n-                    let ret = f(self, lvalue);\n-                    let op = self.trans_load(bcx, lvalue.llval, lvalue.alignment, lvalue_ty);\n-                    self.locals[index] = LocalRef::Operand(Some(op));\n-                    ret\n-                }\n-                LocalRef::Operand(Some(_)) => {\n-                    // See comments in LocalRef::new_operand as to why\n-                    // we always have Some in a ZST LocalRef::Operand.\n-                    let ty = self.monomorphized_lvalue_ty(lvalue);\n-                    if common::type_is_zero_size(bcx.ccx, ty) {\n-                        // Pass an undef pointer as no stores can actually occur.\n-                        let llptr = C_undef(type_of(bcx.ccx, ty).ptr_to());\n-                        f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty),\n-                                                     Alignment::AbiAligned))\n-                    } else {\n-                        bug!(\"Lvalue local already set\");\n-                    }\n-                }\n-            }\n-        } else {\n-            let lvalue = self.trans_lvalue(bcx, lvalue);\n-            f(self, lvalue)\n-        }\n-    }\n-\n     /// Adjust the bitwidth of an index since LLVM is less forgiving\n     /// than we are.\n     ///"}]}