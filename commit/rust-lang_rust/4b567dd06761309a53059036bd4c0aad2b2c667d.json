{"sha": "4b567dd06761309a53059036bd4c0aad2b2c667d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNTY3ZGQwNjc2MTMwOWE1MzA1OTAzNmJkNGMwYWFkMmIyYzY2N2Q=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-15T19:25:37Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-01-18T00:54:12Z"}, "message": "add TreeSetIterator", "tree": {"sha": "666854a6ba58dbb6c3ad8f9c5546e3ad8020f7d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/666854a6ba58dbb6c3ad8f9c5546e3ad8020f7d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b567dd06761309a53059036bd4c0aad2b2c667d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b567dd06761309a53059036bd4c0aad2b2c667d", "html_url": "https://github.com/rust-lang/rust/commit/4b567dd06761309a53059036bd4c0aad2b2c667d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b567dd06761309a53059036bd4c0aad2b2c667d/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b17e2fc18caaeb83b2a18ba9cbb9d53b92cfd54", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b17e2fc18caaeb83b2a18ba9cbb9d53b92cfd54", "html_url": "https://github.com/rust-lang/rust/commit/2b17e2fc18caaeb83b2a18ba9cbb9d53b92cfd54"}], "stats": {"total": 83, "additions": 46, "deletions": 37}, "files": [{"sha": "7e75b600bd76d7282737c6a4a3f096cb2d99a932", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4b567dd06761309a53059036bd4c0aad2b2c667d/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b567dd06761309a53059036bd4c0aad2b2c667d/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=4b567dd06761309a53059036bd4c0aad2b2c667d", "patch": "@@ -47,10 +47,10 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n     pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n-        } else unsafe { // unsafe used as a purity workaround\n+        } else {\n             let mut x = self.iter();\n             let mut y = other.iter();\n-            for self.len().times {\n+            for self.len().times unsafe { // unsafe used as a purity workaround\n                 // ICE: x.next() != y.next()\n \n                 let (x1, x2) = x.next().unwrap();\n@@ -149,7 +149,7 @@ impl <K: Ord, V> TreeMap<K, V> {\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    fn iter(&self) -> TreeMapIterator/&self<K, V> {\n+    pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n@@ -226,6 +226,12 @@ impl <T: Ord> TreeSet<T> {\n     /// present in the set.\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n \n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    pure fn iter(&self) -> TreeSetIterator/&self<T> {\n+        TreeSetIterator{iter: self.map.iter()}\n+    }\n+\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     pure fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n@@ -246,25 +252,22 @@ impl <T: Ord> TreeSet<T> {\n \n     /// Visit the values (in-order) representing the difference\n     pure fn difference(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n-        unsafe { // purity workaround\n-            let mut x = self.map.iter();\n-            let mut y = other.map.iter();\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n \n+        unsafe { // purity workaround\n             let mut a = x.next();\n             let mut b = y.next();\n \n             while a.is_some() {\n                 if b.is_none() {\n-                    while a.is_some() {\n-                        let (a1, _) = a.unwrap();\n-                        if !f(a1) { return }\n-                        a = x.next();\n+                    return do a.while_some() |a1| {\n+                        if f(a1) { x.next() } else { None }\n                     }\n-                    return\n                 }\n \n-                let (a1, _) = a.unwrap();\n-                let (b1, _) = b.unwrap();\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n@@ -280,25 +283,22 @@ impl <T: Ord> TreeSet<T> {\n     /// Visit the values (in-order) representing the symmetric difference\n     pure fn symmetric_difference(&self, other: &TreeSet<T>,\n                                  f: fn(&T) -> bool) {\n-        unsafe { // purity workaround\n-            let mut x = self.map.iter();\n-            let mut y = other.map.iter();\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n \n+        unsafe { // purity workaround\n             let mut a = x.next();\n             let mut b = y.next();\n \n             while a.is_some() {\n                 if b.is_none() {\n-                    while a.is_some() {\n-                        let (a1, _) = a.unwrap();\n-                        if !f(a1) { return }\n-                        a = x.next();\n+                    return do a.while_some() |a1| {\n+                        if f(a1) { x.next() } else { None }\n                     }\n-                    return\n                 }\n \n-                let (a1, _) = a.unwrap();\n-                let (b1, _) = b.unwrap();\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n@@ -312,10 +312,8 @@ impl <T: Ord> TreeSet<T> {\n                     b = y.next();\n                 }\n             }\n-            while b.is_some() {\n-                let (b1, _) = b.unwrap();\n-                if !f(b1) { return }\n-                b = y.next();\n+            do b.while_some |b1| {\n+                if f(b1) { y.next() } else { None }\n             }\n         }\n     }\n@@ -332,25 +330,22 @@ impl <T: Ord> TreeSet<T> {\n \n     /// Visit the values (in-order) representing the union\n     pure fn union(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n-        unsafe { // purity workaround\n-            let mut x = self.map.iter();\n-            let mut y = other.map.iter();\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n \n+        unsafe { // purity workaround\n             let mut a = x.next();\n             let mut b = y.next();\n \n             while a.is_some() {\n                 if b.is_none() {\n-                    while a.is_some() {\n-                        let (a1, _) = a.unwrap();\n-                        if !f(a1) { return }\n-                        a = x.next();\n+                    return do a.while_some() |a1| {\n+                        if f(a1) { x.next() } else { None }\n                     }\n-                    return\n                 }\n \n-                let (a1, _) = a.unwrap();\n-                let (b1, _) = b.unwrap();\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n@@ -367,6 +362,20 @@ impl <T: Ord> TreeSet<T> {\n     }\n }\n \n+/// Lazy forward iterator over a set\n+pub struct TreeSetIterator<T: Ord> {\n+    priv iter: TreeMapIterator<T, ()>\n+}\n+\n+impl <T: Ord> TreeSetIterator<T> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the value. If there are no more nodes,\n+    /// return `None`.\n+    fn next(&mut self) -> Option<&self/T> {\n+        self.iter.next().map_consume(|(x, _)| x)\n+    }\n+}\n+\n // Nodes keep track of their level in the tree, starting at 1 in the\n // leaves and with a red child sharing the level of the parent.\n struct TreeNode<K: Ord, V> {"}]}