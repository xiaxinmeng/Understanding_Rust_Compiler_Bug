{"sha": "bda328e26ab638b54d8f11ff967becf7f574f98e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYTMyOGUyNmFiNjM4YjU0ZDhmMTFmZjk2N2JlY2Y3ZjU3NGY5OGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-04-11T11:23:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-04-11T11:32:47Z"}, "message": "only check timeouts when a thread yields", "tree": {"sha": "fd4877aa18b7cfd24c59c4ddd31d5ee1e9a6882e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd4877aa18b7cfd24c59c4ddd31d5ee1e9a6882e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bda328e26ab638b54d8f11ff967becf7f574f98e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bda328e26ab638b54d8f11ff967becf7f574f98e", "html_url": "https://github.com/rust-lang/rust/commit/bda328e26ab638b54d8f11ff967becf7f574f98e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bda328e26ab638b54d8f11ff967becf7f574f98e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ae7bfc6c6b4c04fa5f6205812281d6e32e194dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae7bfc6c6b4c04fa5f6205812281d6e32e194dd", "html_url": "https://github.com/rust-lang/rust/commit/1ae7bfc6c6b4c04fa5f6205812281d6e32e194dd"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "0f373e4cd31eb15cd25e38b1de365fce152776a7", "filename": "src/thread.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bda328e26ab638b54d8f11ff967becf7f574f98e/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bda328e26ab638b54d8f11ff967becf7f574f98e/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=bda328e26ab638b54d8f11ff967becf7f574f98e", "patch": "@@ -477,6 +477,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         if self.threads[self.active_thread].check_terminated() {\n             return Ok(SchedulingAction::ExecuteDtors);\n         }\n+        // If we get here again and the thread is *still* terminated, there are no more dtors to run.\n         if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n             // The main thread terminated; stop the program.\n             if self.threads.iter().any(|thread| thread.state != ThreadState::Terminated) {\n@@ -490,26 +491,25 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             }\n             return Ok(SchedulingAction::Stop);\n         }\n-        // At least for `pthread_cond_timedwait` we need to report timeout when\n-        // the function is called already after the specified time even if a\n-        // signal is received before the thread gets scheduled. Therefore, we\n-        // need to schedule all timeout callbacks before we continue regular\n-        // execution.\n-        //\n-        // Documentation:\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html#\n-        let potential_sleep_time =\n-            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n-        if potential_sleep_time == Some(Duration::new(0, 0)) {\n-            return Ok(SchedulingAction::ExecuteTimeoutCallback);\n-        }\n-        // No callbacks scheduled, pick a regular thread to execute.\n+        // This thread and the program can keep going.\n         if self.threads[self.active_thread].state == ThreadState::Enabled\n             && !self.yield_active_thread\n         {\n             // The currently active thread is still enabled, just continue with it.\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n+        // The active thread yielded. Let's see if there are any timeouts to take care of. We do\n+        // this *before* running any other thread, to ensure that timeouts \"in the past\" fire before\n+        // any other thread can take an action. This ensures that for `pthread_cond_timedwait`, \"an\n+        // error is returned if [...] the absolute time specified by abstime has already been passed\n+        // at the time of the call\".\n+        // <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html>\n+        let potential_sleep_time =\n+            self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n+        if potential_sleep_time == Some(Duration::new(0, 0)) {\n+            return Ok(SchedulingAction::ExecuteTimeoutCallback);\n+        }\n+        // No callbacks scheduled, pick a regular thread to execute.\n         // We need to pick a new thread for execution.\n         for (id, thread) in self.threads.iter_enumerated() {\n             if thread.state == ThreadState::Enabled {"}]}