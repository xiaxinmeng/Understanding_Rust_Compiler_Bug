{"sha": "ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMmNlMDM2Y2NkNTNkOGMxOTY4OWQ4NmNmOGIzYmQ1Y2YzN2Y0MGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-29T23:09:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-29T23:09:50Z"}, "message": "Camel case more std types", "tree": {"sha": "701e66b3c5e2d6c74d018a6234381434ebbf7842", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/701e66b3c5e2d6c74d018a6234381434ebbf7842"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "html_url": "https://github.com/rust-lang/rust/commit/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aab4d6b8d73f029d178c3ac055152f57c7233995", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab4d6b8d73f029d178c3ac055152f57c7233995", "html_url": "https://github.com/rust-lang/rust/commit/aab4d6b8d73f029d178c3ac055152f57c7233995"}], "stats": {"total": 96, "additions": 55, "deletions": 41}, "files": [{"sha": "8b91f54be99a73121788c87786a3fa23c063add4", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "patch": "@@ -23,7 +23,7 @@\n export sha1;\n \n /// The SHA-1 interface\n-trait sha1 {\n+trait Sha1 {\n     /// Provide message input as bytes\n     fn input((&[u8]));\n     /// Provide message input as string\n@@ -53,8 +53,8 @@ const k3: u32 = 0xCA62C1D6u32;\n \n \n /// Construct a `sha` object\n-fn sha1() -> sha1 {\n-    type sha1state =\n+fn sha1() -> Sha1 {\n+    type Sha1State =\n         {h: ~[mut u32],\n          mut len_low: u32,\n          mut len_high: u32,\n@@ -63,7 +63,7 @@ fn sha1() -> sha1 {\n          mut computed: bool,\n          work_buf: @~[mut u32]};\n \n-    fn add_input(st: &sha1state, msg: &[u8]) {\n+    fn add_input(st: &Sha1State, msg: &[u8]) {\n         assert (!st.computed);\n         for vec::each(msg) |element| {\n             st.msg_block[st.msg_block_idx] = element;\n@@ -79,7 +79,7 @@ fn sha1() -> sha1 {\n             if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n         }\n     }\n-    fn process_msg_block(st: &sha1state) {\n+    fn process_msg_block(st: &Sha1State) {\n         assert (vec::len(st.h) == digest_buf_len);\n         assert (vec::len(*st.work_buf) == work_buf_len);\n         let mut t: int; // Loop counter\n@@ -158,7 +158,7 @@ fn sha1() -> sha1 {\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         return word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(st: &sha1state) -> ~[u8] {\n+    fn mk_result(st: &Sha1State) -> ~[u8] {\n         if !(*st).computed { pad_msg(st); (*st).computed = true; }\n         let mut rs: ~[u8] = ~[];\n         for vec::each_mut((*st).h) |ptr_hpart| {\n@@ -181,7 +181,7 @@ fn sha1() -> sha1 {\n      * call process_msg_block() appropriately.  When it returns, it\n      * can be assumed that the message digest has been computed.\n      */\n-    fn pad_msg(st: &sha1state) {\n+    fn pad_msg(st: &Sha1State) {\n         assert (vec::len((*st).msg_block) == msg_block_len);\n \n         /*\n@@ -218,7 +218,7 @@ fn sha1() -> sha1 {\n         process_msg_block(st);\n     }\n \n-    impl sha1state: sha1 {\n+    impl Sha1State: Sha1 {\n         fn reset() {\n             assert (vec::len(self.h) == digest_buf_len);\n             self.len_low = 0u32;\n@@ -253,7 +253,7 @@ fn sha1() -> sha1 {\n         mut computed: false,\n         work_buf: @vec::to_mut(vec::from_elem(work_buf_len, 0u32))\n     };\n-    let sh = st as sha1;\n+    let sh = st as Sha1;\n     sh.reset();\n     return sh;\n }\n@@ -263,7 +263,7 @@ mod tests {\n \n     #[test]\n     fn test() unsafe {\n-        type test = {input: ~str, output: ~[u8]};\n+        type Test = {input: ~str, output: ~[u8]};\n \n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n@@ -273,7 +273,7 @@ mod tests {\n         }\n         // Test messages from FIPS 180-1\n \n-        let fips_180_1_tests: ~[test] =\n+        let fips_180_1_tests: ~[Test] =\n             ~[{input: ~\"abc\",\n               output:\n                   ~[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n@@ -299,7 +299,7 @@ mod tests {\n                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n         // Examples from wikipedia\n \n-        let wikipedia_tests: ~[test] =\n+        let wikipedia_tests: ~[Test] =\n             ~[{input: ~\"The quick brown fox jumps over the lazy dog\",\n               output:\n                   ~[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,"}, {"sha": "7af5d68d648053cd1dbf3a8dc59135d7a1243864", "filename": "src/libstd/std.rc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "patch": "@@ -70,19 +70,33 @@ mod treemap;\n \n // And ... other stuff\n \n+#[warn(non_camel_case_types)]\n mod ebml;\n+#[warn(non_camel_case_types)]\n mod dbg;\n+#[warn(non_camel_case_types)]\n mod getopts;\n+#[warn(non_camel_case_types)]\n mod json;\n+#[warn(non_camel_case_types)]\n mod sha1;\n+#[warn(non_camel_case_types)]\n mod md4;\n+#[warn(non_camel_case_types)]\n mod tempfile;\n+#[warn(non_camel_case_types)]\n mod term;\n+#[warn(non_camel_case_types)]\n mod time;\n+#[warn(non_camel_case_types)]\n mod prettyprint;\n+#[warn(non_camel_case_types)]\n mod arena;\n+#[warn(non_camel_case_types)]\n mod par;\n+#[warn(non_camel_case_types)]\n mod cmp;\n+#[warn(non_camel_case_types)]\n mod base64;\n \n #[cfg(unicode)]"}, {"sha": "fec45cfc17880af7ecaeba30d8659c83f8b595a9", "filename": "src/libstd/time.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "patch": "@@ -6,12 +6,12 @@ import io::Reader;\n import result::{Result, Ok, Err};\n \n export\n-    timespec,\n+    Timespec,\n     get_time,\n     precise_time_ns,\n     precise_time_s,\n     tzset,\n-    tm,\n+    Tm,\n     empty_tm,\n     now,\n     at,\n@@ -26,20 +26,20 @@ extern mod rustrt {\n \n     fn rust_tzset();\n     // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n-    fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: tm);\n-    fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: tm);\n-    fn rust_timegm(&&tm: tm, &sec: i64);\n-    fn rust_mktime(&&tm: tm, &sec: i64);\n+    fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n+    fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n+    fn rust_timegm(&&tm: Tm, &sec: i64);\n+    fn rust_mktime(&&tm: Tm, &sec: i64);\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-type timespec = {sec: i64, nsec: i32};\n+type Timespec = {sec: i64, nsec: i32};\n \n /**\n  * Returns the current time as a `timespec` containing the seconds and\n  * nanoseconds since 1970-01-01T00:00:00Z.\n  */\n-fn get_time() -> timespec {\n+fn get_time() -> Timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n     rustrt::get_time(sec, nsec);\n@@ -68,7 +68,7 @@ fn tzset() {\n     rustrt::rust_tzset();\n }\n \n-type tm_ = {\n+type Tm_ = {\n     tm_sec: i32, // seconds after the minute ~[0-60]\n     tm_min: i32, // minutes after the hour ~[0-59]\n     tm_hour: i32, // hours after midnight ~[0-23]\n@@ -83,12 +83,12 @@ type tm_ = {\n     tm_nsec: i32, // nanoseconds\n };\n \n-enum tm {\n-    tm_(tm_)\n+enum Tm {\n+    Tm_(Tm_)\n }\n \n-fn empty_tm() -> tm {\n-    tm_({\n+fn empty_tm() -> Tm {\n+    Tm_({\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n         tm_hour: 0_i32,\n@@ -105,34 +105,34 @@ fn empty_tm() -> tm {\n }\n \n /// Returns the specified time in UTC\n-fn at_utc(clock: timespec) -> tm {\n+fn at_utc(clock: Timespec) -> Tm {\n     let mut {sec, nsec} = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_gmtime(sec, nsec, tm);\n     tm\n }\n \n /// Returns the current time in UTC\n-fn now_utc() -> tm {\n+fn now_utc() -> Tm {\n     at_utc(get_time())\n }\n \n /// Returns the specified time in the local timezone\n-fn at(clock: timespec) -> tm {\n+fn at(clock: Timespec) -> Tm {\n     let mut {sec, nsec} = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_localtime(sec, nsec, tm);\n     tm\n }\n \n /// Returns the current time in the local timezone\n-fn now() -> tm {\n+fn now() -> Tm {\n     at(get_time())\n }\n \n /// Parses the time from the string according to the format string.\n-fn strptime(s: &str, format: &str) -> Result<tm, ~str> {\n-    type tm_mut = {\n+fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n+    type TmMut = {\n        mut tm_sec: i32,\n        mut tm_min: i32,\n        mut tm_hour: i32,\n@@ -209,7 +209,7 @@ fn strptime(s: &str, format: &str) -> Result<tm, ~str> {\n         }\n     }\n \n-    fn parse_type(s: &str, pos: uint, ch: char, tm: &tm_mut)\n+    fn parse_type(s: &str, pos: uint, ch: char, tm: &TmMut)\n       -> Result<uint, ~str> {\n         match ch {\n           'A' => match match_strs(s, pos, ~[\n@@ -554,7 +554,7 @@ fn strptime(s: &str, format: &str) -> Result<tm, ~str> {\n         }\n \n         if pos == len && rdr.eof() {\n-            Ok(tm_({\n+            Ok(Tm_({\n                 tm_sec: tm.tm_sec,\n                 tm_min: tm.tm_min,\n                 tm_hour: tm.tm_hour,\n@@ -572,8 +572,8 @@ fn strptime(s: &str, format: &str) -> Result<tm, ~str> {\n     }\n }\n \n-fn strftime(format: &str, +tm: tm) -> ~str {\n-    fn parse_type(ch: char, tm: &tm) -> ~str {\n+fn strftime(format: &str, +tm: Tm) -> ~str {\n+    fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || #fmt(\"strftime: can't understand this format %c \",\n                              ch);\n@@ -740,9 +740,9 @@ fn strftime(format: &str, +tm: tm) -> ~str {\n     buf\n }\n \n-impl tm {\n+impl Tm {\n     /// Convert time to the seconds from January 1, 1970\n-    fn to_timespec() -> timespec {\n+    fn to_timespec() -> Timespec {\n         let mut sec = 0i64;\n         if self.tm_gmtoff == 0_i32 {\n             rustrt::rust_timegm(self, sec);\n@@ -753,12 +753,12 @@ impl tm {\n     }\n \n     /// Convert time to the local timezone\n-    fn to_local() -> tm {\n+    fn to_local() -> Tm {\n         at(self.to_timespec())\n     }\n \n     /// Convert time to the UTC\n-    fn to_utc() -> tm {\n+    fn to_utc() -> Tm {\n         at_utc(self.to_timespec())\n     }\n "}, {"sha": "a624f470378d6ce6c982004f4bdfda373a8be46e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ee2ce036ccd53d8c19689d86cf8b3bd5cf37f40f", "patch": "@@ -168,8 +168,8 @@ fn get_dest_addr(dest: dest) -> ValueRef {\n     }\n }\n \n-fn log_fn_time(ccx: @crate_ctxt, name: ~str, start: time::timespec,\n-               end: time::timespec) {\n+fn log_fn_time(ccx: @crate_ctxt, name: ~str, start: time::Timespec,\n+               end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n     vec::push(*ccx.stats.fn_times, {ident: name, time: elapsed});"}]}