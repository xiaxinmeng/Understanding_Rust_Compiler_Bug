{"sha": "fa6480e43d3b9195fdc2077e32a3ee653409ee89", "node_id": "C_kwDOAAsO6NoAKGZhNjQ4MGU0M2QzYjkxOTVmZGMyMDc3ZTMyYTNlZTY1MzQwOWVlODk", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-09T12:27:34Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-09T12:27:34Z"}, "message": "Remove most trap functions and remove all trapnz usages", "tree": {"sha": "380d6f162066e12724a568299a6cf0b5619d1626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/380d6f162066e12724a568299a6cf0b5619d1626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa6480e43d3b9195fdc2077e32a3ee653409ee89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6480e43d3b9195fdc2077e32a3ee653409ee89", "html_url": "https://github.com/rust-lang/rust/commit/fa6480e43d3b9195fdc2077e32a3ee653409ee89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa6480e43d3b9195fdc2077e32a3ee653409ee89/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "526553e4a35926f0a06dbdd48fec904db6483b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/526553e4a35926f0a06dbdd48fec904db6483b03", "html_url": "https://github.com/rust-lang/rust/commit/526553e4a35926f0a06dbdd48fec904db6483b03"}], "stats": {"total": 105, "additions": 45, "deletions": 60}, "files": [{"sha": "2c04cf47268254b434a62ac0d20220e6c9c720be", "filename": "src/base.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -90,7 +90,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     if !crate::constant::check_constants(&mut fx) {\n         fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n+        // compilation should have been aborted\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n     } else if arg_uninhabited {\n         fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n@@ -457,17 +458,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     template,\n                     operands,\n                     *options,\n+                    *destination,\n                 );\n-\n-                match *destination {\n-                    Some(destination) => {\n-                        let destination_block = fx.get_block(destination);\n-                        fx.bcx.ins().jump(destination_block, &[]);\n-                    }\n-                    None => {\n-                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-                    }\n-                }\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 // FIXME implement unwinding\n@@ -711,9 +703,7 @@ fn codegen_stmt<'tcx>(\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);\n-                    let discr =\n-                        crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n-                    lval.write_cvalue(fx, discr);\n+                    crate::discriminant::codegen_get_discriminant(fx, lval, value, dest_layout);\n                 }\n                 Rvalue::Repeat(ref operand, times) => {\n                     let operand = codegen_operand(fx, operand);"}, {"sha": "e41ae1fbdbac54cd9a58bb80f4d8c9905e1738dc", "filename": "src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -62,16 +62,14 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    dest: CPlace<'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n-) -> CValue<'tcx> {\n+) {\n     let layout = value.layout();\n \n-    if layout.abi == Abi::Uninhabited {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::UnreachableCodeReached);\n-        // Return a dummy value\n-        return CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout);\n+    if layout.abi.is_uninhabited() {\n+        return;\n     }\n \n     let (tag_scalar, tag_field, tag_encoding) = match &layout.variants {\n@@ -89,7 +87,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             } else {\n                 ty::ScalarInt::try_from_uint(discr_val, dest_layout.size).unwrap()\n             };\n-            return CValue::const_val(fx, dest_layout, discr_val);\n+            let res = CValue::const_val(fx, dest_layout, discr_val);\n+            dest.write_cvalue(fx, res);\n+            return;\n         }\n         Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n             (tag, *tag_field, tag_encoding)\n@@ -110,7 +110,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 _ => false,\n             };\n             let val = clif_intcast(fx, tag, cast_to, signed);\n-            CValue::by_val(val, dest_layout)\n+            let res = CValue::by_val(val, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n@@ -170,7 +171,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n \n             let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n-            CValue::by_val(discr, dest_layout)\n+            let res = CValue::by_val(discr, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n     }\n }"}, {"sha": "7b1a39c675cde67c37d17eee05b14cbb9e9237cf", "filename": "src/inline_asm.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -15,13 +15,13 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n+    destination: Option<mir::BasicBlock>,\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n     if !template.is_empty() {\n         if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            fx.bcx.ins().trap(TrapCode::User(1));\n             return;\n         } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n             && matches!(\n@@ -101,12 +101,16 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n             ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n             edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n             return;\n         } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n             // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n             crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+            return;\n         } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n             crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+            return;\n         }\n     }\n \n@@ -175,6 +179,16 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     }\n \n     call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n+\n+    match destination {\n+        Some(destination) => {\n+            let destination_block = fx.get_block(destination);\n+            fx.bcx.ins().jump(destination_block, &[]);\n+        }\n+        None => {\n+            fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        }\n+    }\n }\n \n struct InlineAssemblyGenerator<'a, 'tcx> {"}, {"sha": "5120b89c4e8b0b28dba764aac67ed47cbfac3f1a", "filename": "src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fcpuid.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n-    crate::trap::trap_unreachable(\n+    crate::trap::trap_unimplemented(\n         fx,\n         \"__cpuid_count arch intrinsic doesn't yet support specified leaf\",\n     );"}, {"sha": "a799dca938e21bb4ef79027aaf408263aa961389", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -139,6 +139,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 .sess\n                 .warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n         }\n     }\n "}, {"sha": "cb620822f2d6177e972a6c88f38b2ffed7778f1a", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -44,7 +44,7 @@ fn report_atomic_type_validation_error<'tcx>(\n         ),\n     );\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n@@ -849,8 +849,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx\n@@ -882,8 +880,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx"}, {"sha": "c7efdb392b75e1077c843353b2d2933a656f25e9", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -14,7 +14,7 @@ fn report_simd_type_validation_error(\n ) {\n     fx.tcx.sess.span_err(span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n@@ -157,7 +157,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                             ),\n                         );\n                         // Prevent verifier error\n-                        crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n                         return;\n                     }\n                 }\n@@ -274,12 +274,17 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 idx_const\n             } else {\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n-                let res = crate::trap::trap_unimplemented_ret_value(\n+                let trap_block = fx.bcx.create_block();\n+                let dummy_block = fx.bcx.create_block();\n+                let true_ = fx.bcx.ins().iconst(types::I8, 1);\n+                fx.bcx.ins().brnz(true_, trap_block, &[]);\n+                fx.bcx.ins().jump(dummy_block, &[]);\n+                fx.bcx.switch_to_block(trap_block);\n+                crate::trap::trap_unimplemented(\n                     fx,\n-                    ret.layout(),\n                     \"Index argument for `simd_extract` is not a constant\",\n                 );\n-                ret.write_cvalue(fx, res);\n+                fx.bcx.switch_to_block(dummy_block);\n                 return;\n             };\n "}, {"sha": "82a2ec579549669afca23f19c1fac2e0eba12936", "filename": "src/trap.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6480e43d3b9195fdc2077e32a3ee653409ee89/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=fa6480e43d3b9195fdc2077e32a3ee653409ee89", "patch": "@@ -25,33 +25,10 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }\n \n-/// Use this for example when a function call should never return. This will fill the current block,\n-/// so you can **not** add instructions to it afterwards.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n-    codegen_print(fx, msg.as_ref());\n-    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-}\n /// Use this when something is unimplemented, but `libcore` or `libstd` requires it to codegen.\n-/// Unlike `trap_unreachable` this will not fill the current block, so you **must** add instructions\n-/// to it afterwards.\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n-    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-    fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n-}\n-\n-/// Like `trap_unimplemented` but returns a fake value of the specified type.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n-    msg: impl AsRef<str>,\n-) -> CValue<'tcx> {\n-    trap_unimplemented(fx, msg);\n-    CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n+    fx.bcx.ins().trap(TrapCode::User(!0));\n }"}]}