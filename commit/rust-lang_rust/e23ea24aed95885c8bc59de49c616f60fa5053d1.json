{"sha": "e23ea24aed95885c8bc59de49c616f60fa5053d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyM2VhMjRhZWQ5NTg4NWM4YmM1OWRlNDljNjE2ZjYwZmE1MDUzZDE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-06T03:01:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-06T03:01:14Z"}, "message": "librustc: Move the \"legality of move bindings\" check from typechecking to alt checking. rs=refactoring", "tree": {"sha": "143de84189312dac49254673d4f0a7c6fd995d50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/143de84189312dac49254673d4f0a7c6fd995d50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e23ea24aed95885c8bc59de49c616f60fa5053d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e23ea24aed95885c8bc59de49c616f60fa5053d1", "html_url": "https://github.com/rust-lang/rust/commit/e23ea24aed95885c8bc59de49c616f60fa5053d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e23ea24aed95885c8bc59de49c616f60fa5053d1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/16506c0250a35cc9cd330465cb2999c5f3ab6f0f", "html_url": "https://github.com/rust-lang/rust/commit/16506c0250a35cc9cd330465cb2999c5f3ab6f0f"}], "stats": {"total": 156, "additions": 79, "deletions": 77}, "files": [{"sha": "f5a57c520d5ff80fc92761b91b8050a98af06251", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e23ea24aed95885c8bc59de49c616f60fa5053d1/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e23ea24aed95885c8bc59de49c616f60fa5053d1/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=e23ea24aed95885c8bc59de49c616f60fa5053d1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use syntax::ast::*;\n-use syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat};\n+use syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat, walk_pat};\n use const_eval::{eval_const_expr, const_val, const_int, const_bool,\n                  compare_const_vals, lookup_const_by_id};\n use syntax::codemap::span;\n@@ -43,6 +43,15 @@ fn check_expr(cx: @AltCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n+        // First, check legality of move bindings.\n+        let is_lvalue = ty::expr_is_lval(cx.tcx, cx.method_map, scrut);\n+        for arms.each |arm| {\n+            check_legality_of_move_bindings(cx,\n+                                            is_lvalue,\n+                                            arm.guard.is_some(),\n+                                            arm.pats);\n+        }\n+\n         check_arms(cx, (*arms));\n         /* Check for exhaustiveness */\n          // Check for empty enum, because is_useful only works on inhabited\n@@ -511,6 +520,13 @@ fn check_local(cx: @AltCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n         cx.tcx.sess.span_err(loc.node.pat.span,\n                           ~\"refutable pattern in local binding\");\n     }\n+\n+    // Check legality of move bindings.\n+    let is_lvalue = match loc.node.init {\n+        Some(init) => ty::expr_is_lval(cx.tcx, cx.method_map, init),\n+        None => true\n+    };\n+    check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n }\n \n fn check_fn(cx: @AltCheckCtxt,\n@@ -565,6 +581,67 @@ fn is_refutable(cx: @AltCheckCtxt, pat: &pat) -> bool {\n     }\n }\n \n+// Legality of move bindings checking\n+\n+fn check_legality_of_move_bindings(cx: @AltCheckCtxt,\n+                                   is_lvalue: bool,\n+                                   has_guard: bool,\n+                                   pats: &[@pat]) {\n+    let tcx = cx.tcx;\n+    let def_map = tcx.def_map;\n+    let mut by_ref_span = None;\n+    let mut any_by_move = false;\n+    for pats.each |pat| {\n+        do pat_bindings(def_map, *pat) |bm, _id, span, _path| {\n+            match bm {\n+                bind_by_ref(_) | bind_by_implicit_ref => {\n+                    by_ref_span = Some(span);\n+                }\n+                bind_by_move => {\n+                    any_by_move = true;\n+                }\n+                _ => { }\n+            }\n+        }\n+    }\n+\n+    if !any_by_move { return; } // pointless micro-optimization\n+    for pats.each |pat| {\n+        do walk_pat(*pat) |p| {\n+            if pat_is_binding(def_map, p) {\n+                match p.node {\n+                    pat_ident(bind_by_move, _, sub) => {\n+                        // check legality of moving out of the enum\n+                        if sub.is_some() {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move with sub-bindings\");\n+                        } else if has_guard {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move into a pattern guard\");\n+                        } else if by_ref_span.is_some() {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move and by-ref \\\n+                                  in the same pattern\");\n+                            tcx.sess.span_note(\n+                                by_ref_span.get(),\n+                                ~\"by-ref binding occurs here\");\n+                        } else if is_lvalue {\n+                            tcx.sess.span_err(\n+                                p.span,\n+                                ~\"cannot bind by-move when \\\n+                                  matching an lvalue\");\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "46d618aeb505a0befca145e68672a0944e76f0d9", "filename": "src/librustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e23ea24aed95885c8bc59de49c616f60fa5053d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e23ea24aed95885c8bc59de49c616f60fa5053d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=e23ea24aed95885c8bc59de49c616f60fa5053d1", "patch": "@@ -21,7 +21,6 @@ fn check_alt(fcx: @fn_ctxt,\n \n     let pattern_ty = fcx.infcx().next_ty_var();\n     bot = check_expr_with(fcx, discrim, pattern_ty);\n-    let is_lvalue = ty::expr_is_lval(tcx, fcx.ccx.method_map, discrim);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -34,10 +33,6 @@ fn check_alt(fcx: @fn_ctxt,\n         };\n \n         for arm.pats.each |p| { check_pat(pcx, *p, pattern_ty);}\n-        check_legality_of_move_bindings(fcx,\n-                                        is_lvalue,\n-                                        arm.guard.is_some(),\n-                                        arm.pats);\n     }\n \n     // Now typecheck the blocks.\n@@ -58,67 +53,6 @@ fn check_alt(fcx: @fn_ctxt,\n     return bot;\n }\n \n-fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n-                                   is_lvalue: bool,\n-                                   has_guard: bool,\n-                                   pats: &[@ast::pat])\n-{\n-    let tcx = fcx.tcx();\n-    let def_map = tcx.def_map;\n-    let mut by_ref = None;\n-    let mut any_by_move = false;\n-    for pats.each |pat| {\n-        do pat_util::pat_bindings(def_map, *pat) |bm, _id, span, _path| {\n-            match bm {\n-                ast::bind_by_ref(_) | ast::bind_by_implicit_ref => {\n-                    by_ref = Some(span);\n-                }\n-                ast::bind_by_move => {\n-                    any_by_move = true;\n-                }\n-                _ => { }\n-            }\n-        }\n-    }\n-\n-    if !any_by_move { return; } // pointless micro-optimization\n-    for pats.each |pat| {\n-        do walk_pat(*pat) |p| {\n-            if pat_is_binding(def_map, p) {\n-                match p.node {\n-                    ast::pat_ident(ast::bind_by_move, _, sub) => {\n-                        // check legality of moving out of the enum\n-                        if sub.is_some() {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move with sub-bindings\");\n-                        } else if has_guard {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move into a pattern guard\");\n-                        } else if by_ref.is_some() {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move and by-ref \\\n-                                  in the same pattern\");\n-                            tcx.sess.span_note(\n-                                by_ref.get(),\n-                                ~\"by-ref binding occurs here\");\n-                        } else if is_lvalue {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move when \\\n-                                  matching an lvalue\");\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\n type pat_ctxt = {\n     fcx: @fn_ctxt,\n     map: PatIdMap,"}, {"sha": "3b9ad6e7184d619d8a848bd620080973ea30c654", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e23ea24aed95885c8bc59de49c616f60fa5053d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e23ea24aed95885c8bc59de49c616f60fa5053d1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e23ea24aed95885c8bc59de49c616f60fa5053d1", "patch": "@@ -2399,15 +2399,11 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let t = ty::mk_var(tcx, fcx.inh.locals.get(local.node.id));\n     fcx.write_ty(local.node.id, t);\n \n-    let is_lvalue;\n     match local.node.init {\n         Some(init) => {\n             bot = check_decl_initializer(fcx, local.node.id, init);\n-            is_lvalue = ty::expr_is_lval(tcx, fcx.ccx.method_map, init);\n-        }\n-        _ => {\n-            is_lvalue = true;\n         }\n+        _ => {}\n     }\n \n     let region =\n@@ -2419,11 +2415,6 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n         block_region: region,\n     };\n     alt::check_pat(pcx, local.node.pat, t);\n-    let has_guard = false;\n-    alt::check_legality_of_move_bindings(fcx,\n-                                         is_lvalue,\n-                                         has_guard,\n-                                         [local.node.pat]);\n     return bot;\n }\n "}]}