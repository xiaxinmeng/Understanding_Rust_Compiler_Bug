{"sha": "3bd1f32cd945fab63777b71ef76f23d758e2904c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZDFmMzJjZDk0NWZhYjYzNzc3YjcxZWY3NmYyM2Q3NThlMjkwNGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-07T21:52:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-08T01:10:11Z"}, "message": "Convert all kind bounds to camel case. Remove send, owned keywords.", "tree": {"sha": "8035a0aa8bf9fa926484604074427146ec295b1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8035a0aa8bf9fa926484604074427146ec295b1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bd1f32cd945fab63777b71ef76f23d758e2904c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd1f32cd945fab63777b71ef76f23d758e2904c", "html_url": "https://github.com/rust-lang/rust/commit/3bd1f32cd945fab63777b71ef76f23d758e2904c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bd1f32cd945fab63777b71ef76f23d758e2904c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07fe5611ade0e02109a5fa72881c6cd43bacbb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/07fe5611ade0e02109a5fa72881c6cd43bacbb29", "html_url": "https://github.com/rust-lang/rust/commit/07fe5611ade0e02109a5fa72881c6cd43bacbb29"}], "stats": {"total": 1235, "additions": 613, "deletions": 622}, "files": [{"sha": "eeedc7473a0a91569bd7fc9fa9fefa8441a199ac", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -449,7 +449,7 @@ Two examples of paths with type arguments:\n ~~~~\n # use std::map;\n # fn f() {\n-# fn id<T:copy>(t: T) -> T { t }\n+# fn id<T:Copy>(t: T) -> T { t }\n type t = map::hashmap<int,~str>;  // Type arguments used in a type expression\n let x = id::<int>(10);           // Type arguments used in a call expression\n # }\n@@ -1056,7 +1056,7 @@ An example of a pure function that uses an unchecked block:\n ~~~~\n # use std::list::*;\n \n-fn pure_foldl<T, U: copy>(ls: List<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n+fn pure_foldl<T, U: Copy>(ls: List<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n     match ls {\n       Nil => u,\n       Cons(hd, tl) => f(hd, pure_foldl(*tl, f(hd, u), f))\n@@ -1110,7 +1110,7 @@ type can always be moved, but they can only be copied when the\n parameter is given a [`copy` bound](#type-kinds).\n \n ~~~~\n-fn id<T: copy>(x: T) -> T { x }\n+fn id<T: Copy>(x: T) -> T { x }\n ~~~~\n \n Similarly, [trait](#traits) bounds can be specified for type\n@@ -2638,7 +2638,7 @@ Every struct item defines a type.\n Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n \n ~~~~~~~\n-fn map<A: copy, B: copy>(f: fn(A) -> B, xs: ~[A]) -> ~[B] {\n+fn map<A: Copy, B: Copy>(f: fn(A) -> B, xs: ~[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n    let first: B = f(xs[0]);\n    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n@@ -2706,7 +2706,7 @@ Putting `x` into a shared box involves copying, and the `T` parameter\n is assumed to be noncopyable. To change that, a bound is declared:\n \n ~~~~\n-fn box<T: copy>(x: T) -> @T { @x }\n+fn box<T: Copy>(x: T) -> @T { @x }\n ~~~~\n \n Calling this second version of `box` on a noncopyable type is not"}, {"sha": "25531e5975913ac94549ca768bab0919e237bc4f", "filename": "doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1583,20 +1583,20 @@ unless you explicitly declare that type parameter to have copyable\n // This does not compile\n fn head_bad<T>(v: ~[T]) -> T { v[0] }\n // This does\n-fn head<T: copy>(v: ~[T]) -> T { v[0] }\n+fn head<T: Copy>(v: ~[T]) -> T { v[0] }\n ~~~~\n \n When instantiating a generic function, you can only instantiate it\n with types that fit its kinds. So you could not apply `head` to a\n resource type. Rust has several kinds that can be used as type bounds:\n \n-* `copy` - Copyable types. All types are copyable unless they\n+* `Copy` - Copyable types. All types are copyable unless they\n   are classes with destructors or otherwise contain\n   classes with destructors.\n-* `send` - Sendable types. All types are sendable unless they\n+* `Send` - Sendable types. All types are sendable unless they\n   contain shared boxes, closures, or other local-heap-allocated\n   types.\n-* `const` - Constant types. These are types that do not contain\n+* `Const` - Constant types. These are types that do not contain\n   mutable fields nor shared boxes.\n \n > ***Note:*** Rust type kinds are syntactically very similar to\n@@ -2002,7 +2002,7 @@ and one for values. This means that this code is valid:\n ~~~~\n mod buffalo {\n     type buffalo = int;\n-    fn buffalo<buffalo: copy>(buffalo: buffalo) -> buffalo { buffalo }\n+    fn buffalo<buffalo>(+buffalo: buffalo) -> buffalo { buffalo }\n }\n fn main() {\n     let buffalo: buffalo::buffalo = 1;"}, {"sha": "c4dd4bcf4bc3f133eb5b07359de9ee07a0b7dafb", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -239,7 +239,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n                      pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n-fn check_variants_T<T: copy>(\n+fn check_variants_T<T: Copy>(\n   crate: ast::crate,\n   codemap: codemap::codemap,\n   filename: &Path,"}, {"sha": "717993e78c1256ea8306d35bac6915c07aa4d4a3", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -89,7 +89,7 @@ pure fn build_sized_opt<A>(size: Option<uint>,\n \n // Appending\n #[inline(always)]\n-pure fn append<T: copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n+pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for vec::each(lhs) |x| { push(x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n@@ -125,15 +125,15 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: copy>(n_elts: uint, t: T) -> @[T] {\n+pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(t); i += 1u; }\n     }\n }\n \n #[cfg(notest)]\n-impl<T: copy> @[T]: Add<&[const T],@[T]> {\n+impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n     #[inline(always)]\n     pure fn add(rhs: &[const T]) -> @[T] {\n         append(self, rhs)"}, {"sha": "177ecdca9a2da8c82e0490b0c528b0ff0912796e", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -48,7 +48,7 @@ export listen;\n  * transmitted. If a port value is copied, both copies refer to the same\n  * port.  Ports may be associated with multiple `chan`s.\n  */\n-enum Port<T: send> {\n+enum Port<T: Send> {\n     Port_(@PortPtr<T>)\n }\n \n@@ -64,16 +64,16 @@ enum Port<T: send> {\n  * data will be silently dropped.  Channels may be duplicated and\n  * themselves transmitted over other channels.\n  */\n-enum Chan<T: send> {\n+enum Chan<T: Send> {\n     Chan_(port_id)\n }\n \n /// Constructs a port\n-fn Port<T: send>() -> Port<T> {\n+fn Port<T: Send>() -> Port<T> {\n     Port_(@PortPtr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n \n-impl<T: send> Port<T> {\n+impl<T: Send> Port<T> {\n \n     fn chan() -> Chan<T> { Chan(self) }\n     fn send(+v: T) { self.chan().send(v) }\n@@ -82,7 +82,7 @@ impl<T: send> Port<T> {\n \n }\n \n-impl<T: send> Chan<T> {\n+impl<T: Send> Chan<T> {\n \n     fn chan() -> Chan<T> { self }\n     fn send(+v: T) { send(self, v) }\n@@ -92,12 +92,12 @@ impl<T: send> Chan<T> {\n }\n \n /// Open a new receiving channel for the duration of a function\n-fn listen<T: send, U>(f: fn(Chan<T>) -> U) -> U {\n+fn listen<T: Send, U>(f: fn(Chan<T>) -> U) -> U {\n     let po = Port();\n     f(po.chan())\n }\n \n-struct PortPtr<T:send> {\n+struct PortPtr<T:Send> {\n     po: *rust_port,\n   drop unsafe {\n       do task::unkillable {\n@@ -121,7 +121,7 @@ struct PortPtr<T:send> {\n   }\n }\n \n-fn PortPtr<T: send>(po: *rust_port) -> PortPtr<T> {\n+fn PortPtr<T: Send>(po: *rust_port) -> PortPtr<T> {\n     PortPtr {\n         po: po\n     }\n@@ -135,7 +135,7 @@ fn PortPtr<T: send>(po: *rust_port) -> PortPtr<T> {\n  * Fails if the port is detached or dead. Fails if the port\n  * is owned by a different task.\n  */\n-fn as_raw_port<T: send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n+fn as_raw_port<T: Send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n \n     struct PortRef {\n         p: *rust_port,\n@@ -167,15 +167,15 @@ fn as_raw_port<T: send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n  * Constructs a channel. The channel is bound to the port used to\n  * construct it.\n  */\n-fn Chan<T: send>(p: Port<T>) -> Chan<T> {\n+fn Chan<T: Send>(p: Port<T>) -> Chan<T> {\n     Chan_(rustrt::get_port_id((**p).po))\n }\n \n /**\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n-fn send<T: send>(ch: Chan<T>, +data: T) {\n+fn send<T: Send>(ch: Chan<T>, +data: T) {\n     let Chan_(p) = ch;\n     let data_ptr = ptr::addr_of(data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n@@ -190,22 +190,22 @@ fn send<T: send>(ch: Chan<T>, +data: T) {\n  * Receive from a port.  If no data is available on the port then the\n  * task will block until data becomes available.\n  */\n-fn recv<T: send>(p: Port<T>) -> T { recv_((**p).po) }\n+fn recv<T: Send>(p: Port<T>) -> T { recv_((**p).po) }\n \n /// Returns true if there are messages available\n-fn peek<T: send>(p: Port<T>) -> bool { peek_((**p).po) }\n+fn peek<T: Send>(p: Port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n-fn recv_chan<T: send>(ch: comm::Chan<T>) -> T {\n+fn recv_chan<T: Send>(ch: comm::Chan<T>) -> T {\n     as_raw_port(ch, |x|recv_(x))\n }\n \n-fn peek_chan<T: send>(ch: comm::Chan<T>) -> bool {\n+fn peek_chan<T: Send>(ch: comm::Chan<T>) -> bool {\n     as_raw_port(ch, |x|peek_(x))\n }\n \n /// Receive on a raw port pointer\n-fn recv_<T: send>(p: *rust_port) -> T {\n+fn recv_<T: Send>(p: *rust_port) -> T {\n     let yield = 0u;\n     let yieldp = ptr::addr_of(yield);\n     let mut res;\n@@ -231,7 +231,7 @@ fn peek_(p: *rust_port) -> bool {\n }\n \n /// Receive on one of two ports\n-fn select2<A: send, B: send>(p_a: Port<A>, p_b: Port<B>)\n+fn select2<A: Send, B: Send>(p_a: Port<A>, p_b: Port<B>)\n     -> Either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n     let yield = 0u, yieldp = ptr::addr_of(yield);"}, {"sha": "a1973c1d6ef76d09e22debef5481b9b3542ec222", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -96,7 +96,7 @@ pure fn from_elem<T>(+data: T) -> DList<T> {\n     list\n }\n \n-fn from_vec<T: copy>(+vec: &[T]) -> DList<T> {\n+fn from_vec<T: Copy>(+vec: &[T]) -> DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n         list.push(data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -417,7 +417,7 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T: copy> DList<T> {\n+impl<T: Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n     fn pop()       -> Option<T> { self.pop_n().map       (|nobe| nobe.data) }\n     /// Remove data from the tail of the list. O(1)."}, {"sha": "41f88b72ca1dcdcafcb58a08919cf49c256b8522", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -210,7 +210,7 @@ impl<A> DVec<A> {\n     }\n }\n \n-impl<A: copy> DVec<A> {\n+impl<A: Copy> DVec<A> {\n     /**\n      * Append all elements of a vector to the end of the list\n      *\n@@ -327,7 +327,7 @@ impl<A: copy> DVec<A> {\n     }\n }\n \n-impl<A:copy> DVec<A>: Index<uint,A> {\n+impl<A:Copy> DVec<A>: Index<uint,A> {\n     pure fn index(&&idx: uint) -> A {\n         self.get_elt(idx)\n     }"}, {"sha": "bd68fab3b8e3cd1a82f13574f5415c62ae6e871e", "filename": "src/libcore/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -29,7 +29,7 @@ fn either<T, U, V>(f_left: fn((&T)) -> V,\n     }\n }\n \n-fn lefts<T: copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n+fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n     let mut result: ~[T] = ~[];\n@@ -42,7 +42,7 @@ fn lefts<T: copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n     return result;\n }\n \n-fn rights<T, U: copy>(eithers: &[Either<T, U>]) -> ~[U] {\n+fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     //! Extracts from a vector of either all the right values\n \n     let mut result: ~[U] = ~[];\n@@ -55,7 +55,7 @@ fn rights<T, U: copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     return result;\n }\n \n-fn partition<T: copy, U: copy>(eithers: &[Either<T, U>])\n+fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n     -> {lefts: ~[T], rights: ~[U]} {\n     /*!\n      * Extracts from a vector of either all the left values and right values\n@@ -75,7 +75,7 @@ fn partition<T: copy, U: copy>(eithers: &[Either<T, U>])\n     return {lefts: lefts, rights: rights};\n }\n \n-pure fn flip<T: copy, U: copy>(eith: &Either<T, U>) -> Either<U, T> {\n+pure fn flip<T: Copy, U: Copy>(eith: &Either<T, U>) -> Either<U, T> {\n     //! Flips between left and right of a given either\n \n     match *eith {\n@@ -84,7 +84,7 @@ pure fn flip<T: copy, U: copy>(eith: &Either<T, U>) -> Either<U, T> {\n     }\n }\n \n-pure fn to_result<T: copy, U: copy>(eith: &Either<T, U>) -> Result<U, T> {\n+pure fn to_result<T: Copy, U: Copy>(eith: &Either<T, U>) -> Result<U, T> {\n     /*!\n      * Converts either::t to a result::t\n      *"}, {"sha": "141fafcf7d7af4a843252eb288eaf0f52e77a678", "filename": "src/libcore/future.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -43,7 +43,7 @@ priv enum FutureState<A> {\n }\n \n /// Methods on the `future` type\n-impl<A:copy> Future<A> {\n+impl<A:Copy> Future<A> {\n     fn get() -> A {\n         //! Get the value of the future\n \n@@ -74,7 +74,7 @@ fn from_value<A>(+val: A) -> Future<A> {\n     Future {state: Forced(val)}\n }\n \n-fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n+fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -105,7 +105,7 @@ fn from_fn<A>(+f: @fn() -> A) -> Future<A> {\n     Future {state: Pending(f)}\n }\n \n-fn spawn<A:send>(+blk: fn~() -> A) -> Future<A> {\n+fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *\n@@ -156,7 +156,7 @@ fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n     }\n }\n \n-fn get<A:copy>(future: &Future<A>) -> A {\n+fn get<A:Copy>(future: &Future<A>) -> A {\n     //! Get the value of the future\n \n     *get_ref(future)\n@@ -169,7 +169,7 @@ fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n }\n \n proto! future_pipe (\n-    waiting:recv<T:send> {\n+    waiting:recv<T:Send> {\n         completed(T) -> !\n     }\n )"}, {"sha": "d9e5f3a0aee5f724afadbf8a88f1ea2acf3a0a23", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -28,7 +28,7 @@ impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n     }\n }\n \n-impl<A: copy> IMPL_T<A>: iter::CopyableIter<A> {\n+impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -45,7 +45,7 @@ impl<A: copy> IMPL_T<A>: iter::CopyableIter<A> {\n     pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n }\n \n-impl<A: copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n+impl<A: Copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n     pure fn min() -> A { iter::min(self) }\n     pure fn max() -> A { iter::max(self) }\n }"}, {"sha": "30bd66bf9f8367c448b261338196e0677908c321", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -28,14 +28,14 @@ trait TimesIx{\n     pure fn timesi(it: fn(uint) -> bool);\n }\n \n-trait CopyableIter<A:copy> {\n+trait CopyableIter<A:Copy> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n     pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n     pure fn to_vec() -> ~[A];\n     pure fn find(p: fn(A) -> bool) -> Option<A>;\n }\n \n-trait CopyableOrderedIter<A:copy Ord> {\n+trait CopyableOrderedIter<A:Copy Ord> {\n     pure fn min() -> A;\n     pure fn max() -> A;\n }\n@@ -82,7 +82,7 @@ pure fn any<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n     return false;\n }\n \n-pure fn filter_to_vec<A:copy,IA:BaseIter<A>>(self: IA,\n+pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: IA,\n                                          prd: fn(A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n@@ -91,7 +91,7 @@ pure fn filter_to_vec<A:copy,IA:BaseIter<A>>(self: IA,\n     }\n }\n \n-pure fn map_to_vec<A:copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B)\n+pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n@@ -100,7 +100,7 @@ pure fn map_to_vec<A:copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B)\n     }\n }\n \n-pure fn flat_map_to_vec<A:copy,B:copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n+pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     self: IA, op: fn(A) -> IB) -> ~[B] {\n \n     do vec::build |push| {\n@@ -120,7 +120,7 @@ pure fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     return b;\n }\n \n-pure fn to_vec<A:copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n+pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n     foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy r, ~[a]))\n }\n \n@@ -163,7 +163,7 @@ pure fn repeat(times: uint, blk: fn() -> bool) {\n     }\n }\n \n-pure fn min<A:copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n+pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           Some(a_) if a_ < b => {\n@@ -179,7 +179,7 @@ pure fn min<A:copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n     }\n }\n \n-pure fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n+pure fn max<A:Copy,IA:BaseIter<A>>(self: IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           Some(a_) if a_ > b => {\n@@ -195,7 +195,7 @@ pure fn max<A:copy,IA:BaseIter<A>>(self: IA) -> A {\n     }\n }\n \n-pure fn find<A: copy,IA:BaseIter<A>>(self: IA,\n+pure fn find<A: Copy,IA:BaseIter<A>>(self: IA,\n                                      p: fn(A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if p(i) { return Some(i) }\n@@ -271,7 +271,7 @@ pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: copy,BT: Buildable<T>>(n_elts: uint, t: T) -> BT {\n+pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint, t: T) -> BT {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(t); i += 1u; }\n@@ -280,7 +280,7 @@ pure fn from_elem<T: copy,BT: Buildable<T>>(n_elts: uint, t: T) -> BT {\n \n /// Appending two generic sequences\n #[inline(always)]\n-pure fn append<T: copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     lhs: IT, rhs: IT) -> BT {\n     let size_opt = lhs.size_hint().chain(\n         |sz1| rhs.size_hint().map(|sz2| sz1+sz2));\n@@ -293,7 +293,7 @@ pure fn append<T: copy,IT: BaseIter<T>,BT: Buildable<T>>(\n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n #[inline(always)]\n-pure fn copy_seq<T: copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n     v: IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(x); }"}, {"sha": "980f1899566302e0ea98caa19d1ee26664364d4b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -16,7 +16,7 @@ enum Option<T> {\n     Some(T),\n }\n \n-pure fn get<T: copy>(opt: Option<T>) -> T {\n+pure fn get<T: Copy>(opt: Option<T>) -> T {\n     /*!\n      * Gets the value out of an option\n      *\n@@ -45,7 +45,7 @@ pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pure fn expect<T: copy>(opt: Option<T>, reason: ~str) -> T {\n+pure fn expect<T: Copy>(opt: Option<T>, reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -128,7 +128,7 @@ pure fn is_some<T>(opt: Option<T>) -> bool {\n     !is_none(opt)\n }\n \n-pure fn get_default<T: copy>(opt: Option<T>, def: T) -> T {\n+pure fn get_default<T: Copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n     match opt { Some(x) => x, None => def }\n@@ -226,7 +226,7 @@ impl<T> &Option<T> {\n     pure fn get_ref() -> &self/T { get_ref(self) }\n }\n \n-impl<T: copy> Option<T> {\n+impl<T: Copy> Option<T> {\n     /**\n      * Gets the value out of an option\n      *"}, {"sha": "27baf3d931e9dd52f770672e170c3676541efce6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -152,7 +152,7 @@ fn buffer_header() -> BufferHeader { BufferHeader() }\n \n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n-type Buffer<T: send> = {\n+type Buffer<T: Send> = {\n     header: BufferHeader,\n     data: T,\n };\n@@ -191,7 +191,7 @@ struct PacketHeader {\n         reinterpret_cast(&self.buffer)\n     }\n \n-    fn set_buffer<T: send>(b: ~Buffer<T>) unsafe {\n+    fn set_buffer<T: Send>(b: ~Buffer<T>) unsafe {\n         self.buffer = reinterpret_cast(&b);\n     }\n }\n@@ -205,23 +205,23 @@ fn PacketHeader() -> PacketHeader {\n }\n \n #[doc(hidden)]\n-type Packet<T: send> = {\n+type Packet<T: Send> = {\n     header: PacketHeader,\n     mut payload: Option<T>,\n };\n \n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n-type packet<T: send> = Packet<T>;\n+type packet<T: Send> = Packet<T>;\n \n #[doc(hidden)]\n trait HasBuffer {\n     // XXX This should not have a trailing underscore\n     fn set_buffer_(b: *libc::c_void);\n }\n \n-impl<T: send> Packet<T>: HasBuffer {\n+impl<T: Send> Packet<T>: HasBuffer {\n     fn set_buffer_(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n@@ -235,22 +235,22 @@ trait has_buffer {\n }\n \n #[cfg(stage0)] // XXX remove me\n-impl<T: send> packet<T>: has_buffer {\n+impl<T: Send> packet<T>: has_buffer {\n     fn set_buffer(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n \n #[doc(hidden)]\n-fn mk_packet<T: send>() -> Packet<T> {\n+fn mk_packet<T: Send>() -> Packet<T> {\n     {\n         header: PacketHeader(),\n         mut payload: None\n     }\n }\n \n #[doc(hidden)]\n-fn unibuffer<T: send>() -> ~Buffer<Packet<T>> {\n+fn unibuffer<T: Send>() -> ~Buffer<Packet<T>> {\n     let b = ~{\n         header: BufferHeader(),\n         data: {\n@@ -267,7 +267,7 @@ fn unibuffer<T: send>() -> ~Buffer<Packet<T>> {\n }\n \n #[doc(hidden)]\n-fn packet<T: send>() -> *Packet<T> {\n+fn packet<T: Send>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(b.data);\n     // We'll take over memory management from here.\n@@ -276,7 +276,7 @@ fn packet<T: send>() -> *Packet<T> {\n }\n \n #[doc(hidden)]\n-fn entangle_buffer<T: send, Tstart: send>(\n+fn entangle_buffer<T: Send, Tstart: Send>(\n     +buffer: ~Buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n@@ -368,12 +368,12 @@ fn swap_state_rel(+dst: &mut State, src: State) -> State {\n }\n \n #[doc(hidden)]\n-unsafe fn get_buffer<T: send>(p: *PacketHeader) -> ~Buffer<T> {\n+unsafe fn get_buffer<T: Send>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n // This could probably be done with SharedMutableState to avoid move_it!().\n-struct BufferResource<T: send> {\n+struct BufferResource<T: Send> {\n     buffer: ~Buffer<T>,\n \n     drop unsafe {\n@@ -393,7 +393,7 @@ struct BufferResource<T: send> {\n     }\n }\n \n-fn BufferResource<T: send>(+b: ~Buffer<T>) -> BufferResource<T> {\n+fn BufferResource<T: Send>(+b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n     atomic_add_acq(&mut b.header.ref_count, 1);\n@@ -404,7 +404,7 @@ fn BufferResource<T: send>(+b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-fn send<T: send, Tbuffer: send>(+p: SendPacketBuffered<T, Tbuffer>,\n+fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n                                 +payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n@@ -448,7 +448,7 @@ fn send<T: send, Tbuffer: send>(+p: SendPacketBuffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-fn recv<T: send, Tbuffer: send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n+fn recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(p), \"connection closed\")\n }\n \n@@ -458,7 +458,7 @@ Returns `none` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-fn try_recv<T: send, Tbuffer: send>(+p: RecvPacketBuffered<T, Tbuffer>)\n+fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n@@ -552,22 +552,22 @@ fn try_recv<T: send, Tbuffer: send>(+p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pure fn peek<T: send, Tb: send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty => false,\n       Blocked => fail ~\"peeking on blocked packet\",\n       Full | Terminated => true\n     }\n }\n \n-impl<T: send, Tb: send> RecvPacketBuffered<T, Tb> {\n+impl<T: Send, Tb: Send> RecvPacketBuffered<T, Tb> {\n     pure fn peek() -> bool {\n         peek(&self)\n     }\n }\n \n #[doc(hidden)]\n-fn sender_terminate<T: send>(p: *Packet<T>) {\n+fn sender_terminate<T: Send>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n@@ -596,7 +596,7 @@ fn sender_terminate<T: send>(p: *Packet<T>) {\n }\n \n #[doc(hidden)]\n-fn receiver_terminate<T: send>(p: *Packet<T>) {\n+fn receiver_terminate<T: Send>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n@@ -704,7 +704,7 @@ Sometimes messages will be available on both endpoints at once. In\n this case, `select2` may return either `left` or `right`.\n \n */\n-fn select2<A: send, Ab: send, B: send, Bb: send>(\n+fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n     +a: RecvPacketBuffered<A, Ab>,\n     +b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n@@ -746,7 +746,7 @@ fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) -> Either<(), ()> {\n  list of the remaining endpoints.\n \n */\n-fn select<T: send, Tb: send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n+fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n@@ -760,25 +760,25 @@ fn select<T: send, Tb: send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n message.\n \n */\n-type SendPacket<T: send> = SendPacketBuffered<T, Packet<T>>;\n+type SendPacket<T: Send> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn SendPacket<T: send>(p: *Packet<T>) -> SendPacket<T> {\n+fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n-type send_packet<T: send> = SendPacket<T>;\n+type send_packet<T: Send> = SendPacket<T>;\n \n // XXX remove me\n #[cfg(stage0)]\n-fn send_packet<T: send>(p: *packet<T>) -> SendPacket<T> {\n+fn send_packet<T: Send>(p: *packet<T>) -> SendPacket<T> {\n     SendPacket(p)\n }\n \n-struct SendPacketBuffered<T: send, Tbuffer: send> {\n+struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -821,7 +821,7 @@ struct SendPacketBuffered<T: send, Tbuffer: send> {\n     }\n }\n \n-fn SendPacketBuffered<T: send, Tbuffer: send>(p: *Packet<T>)\n+fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     -> SendPacketBuffered<T, Tbuffer> {\n         //debug!(\"take send %?\", p);\n     SendPacketBuffered {\n@@ -836,30 +836,30 @@ fn SendPacketBuffered<T: send, Tbuffer: send>(p: *Packet<T>)\n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n-type send_packet_buffered<T: send, Tbuffer: send> =\n+type send_packet_buffered<T: Send, Tbuffer: Send> =\n     SendPacketBuffered<T, Tbuffer>;\n \n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-type RecvPacket<T: send> = RecvPacketBuffered<T, Packet<T>>;\n+type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn RecvPacket<T: send>(p: *Packet<T>) -> RecvPacket<T> {\n+fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n \n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n-type recv_packet<T: send> = RecvPacket<T>;\n+type recv_packet<T: Send> = RecvPacket<T>;\n \n // XXX remove me\n #[cfg(stage0)]\n-fn recv_packet<T: send>(p: *packet<T>) -> RecvPacket<T> {\n+fn recv_packet<T: Send>(p: *packet<T>) -> RecvPacket<T> {\n     RecvPacket(p)\n }\n \n-struct RecvPacketBuffered<T: send, Tbuffer: send> : Selectable {\n+struct RecvPacketBuffered<T: Send, Tbuffer: Send> : Selectable {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -902,7 +902,7 @@ struct RecvPacketBuffered<T: send, Tbuffer: send> : Selectable {\n     }\n }\n \n-fn RecvPacketBuffered<T: send, Tbuffer: send>(p: *Packet<T>)\n+fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     -> RecvPacketBuffered<T, Tbuffer> {\n     //debug!(\"take recv %?\", p);\n     RecvPacketBuffered {\n@@ -917,11 +917,11 @@ fn RecvPacketBuffered<T: send, Tbuffer: send>(p: *Packet<T>)\n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n-type recv_packet_buffered<T: send, Tbuffer: send> =\n+type recv_packet_buffered<T: Send, Tbuffer: Send> =\n     RecvPacketBuffered<T, Tbuffer>;\n \n #[doc(hidden)]\n-fn entangle<T: send>() -> (SendPacket<T>, RecvPacket<T>) {\n+fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n }\n@@ -933,7 +933,7 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-fn spawn_service<T: send, Tb: send>(\n+fn spawn_service<T: Send, Tb: Send>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n     +service: fn~(+RecvPacketBuffered<T, Tb>))\n@@ -957,7 +957,7 @@ fn spawn_service<T: send, Tb: send>(\n receive state.\n \n */\n-fn spawn_service_recv<T: send, Tb: send>(\n+fn spawn_service_recv<T: Send, Tb: Send>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n     +service: fn~(+SendPacketBuffered<T, Tb>))\n@@ -980,13 +980,13 @@ fn spawn_service_recv<T: send, Tb: send>(\n // Streams - Make pipes a little easier in general.\n \n proto! streamp (\n-    Open:send<T: send> {\n+    Open:send<T: Send> {\n         data(T) -> Open<T>\n     }\n )\n \n /// A trait for things that can send multiple messages.\n-trait Channel<T: send> {\n+trait Channel<T: Send> {\n     // It'd be nice to call this send, but it'd conflict with the\n     // built in send kind.\n \n@@ -998,7 +998,7 @@ trait Channel<T: send> {\n }\n \n /// A trait for things that can receive multiple messages.\n-trait Recv<T: send> {\n+trait Recv<T: Send> {\n     /// Receives a message, or fails if the connection closes.\n     fn recv() -> T;\n \n@@ -1016,18 +1016,18 @@ trait Recv<T: send> {\n }\n \n #[doc(hidden)]\n-type Chan_<T:send> = { mut endp: Option<streamp::client::Open<T>> };\n+type Chan_<T:Send> = { mut endp: Option<streamp::client::Open<T>> };\n \n /// An endpoint that can send many messages.\n-enum Chan<T:send> {\n+enum Chan<T:Send> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n-type Port_<T:send> = { mut endp: Option<streamp::server::Open<T>> };\n+type Port_<T:Send> = { mut endp: Option<streamp::server::Open<T>> };\n \n /// An endpoint that can receive many messages.\n-enum Port<T:send> {\n+enum Port<T:Send> {\n     Port_(Port_<T>)\n }\n \n@@ -1036,13 +1036,13 @@ enum Port<T:send> {\n These allow sending or receiving an unlimited number of messages.\n \n */\n-fn stream<T:send>() -> (Chan<T>, Port<T>) {\n+fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n     let (c, s) = streamp::init();\n \n     (Chan_({ mut endp: Some(c) }), Port_({ mut endp: Some(s) }))\n }\n \n-impl<T: send> Chan<T>: Channel<T> {\n+impl<T: Send> Chan<T>: Channel<T> {\n     fn send(+x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1063,7 +1063,7 @@ impl<T: send> Chan<T>: Channel<T> {\n     }\n }\n \n-impl<T: send> Port<T>: Recv<T> {\n+impl<T: Send> Port<T>: Recv<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1097,7 +1097,7 @@ impl<T: send> Port<T>: Recv<T> {\n }\n \n /// Treat many ports as one.\n-struct PortSet<T: send> : Recv<T> {\n+struct PortSet<T: Send> : Recv<T> {\n     mut ports: ~[pipes::Port<T>],\n \n     fn add(+port: pipes::Port<T>) {\n@@ -1146,13 +1146,13 @@ struct PortSet<T: send> : Recv<T> {\n     }\n }\n \n-fn PortSet<T: send>() -> PortSet<T>{\n+fn PortSet<T: Send>() -> PortSet<T>{\n     PortSet {\n         ports: ~[]\n     }\n }\n \n-impl<T: send> Port<T>: Selectable {\n+impl<T: Send> Port<T>: Selectable {\n     pure fn header() -> *PacketHeader unchecked {\n         match self.endp {\n           Some(endp) => endp.header(),\n@@ -1162,9 +1162,9 @@ impl<T: send> Port<T>: Selectable {\n }\n \n /// A channel that can be shared between many senders.\n-type SharedChan<T: send> = unsafe::Exclusive<Chan<T>>;\n+type SharedChan<T: Send> = unsafe::Exclusive<Chan<T>>;\n \n-impl<T: send> SharedChan<T>: Channel<T> {\n+impl<T: Send> SharedChan<T>: Channel<T> {\n     fn send(+x: T) {\n         let mut xx = Some(x);\n         do self.with |chan| {\n@@ -1185,19 +1185,19 @@ impl<T: send> SharedChan<T>: Channel<T> {\n }\n \n /// Converts a `chan` into a `shared_chan`.\n-fn SharedChan<T:send>(+c: Chan<T>) -> SharedChan<T> {\n+fn SharedChan<T:Send>(+c: Chan<T>) -> SharedChan<T> {\n     unsafe::exclusive(c)\n }\n \n /// Receive a message from one of two endpoints.\n-trait Select2<T: send, U: send> {\n+trait Select2<T: Send, U: Send> {\n     /// Receive a message or return `none` if a connection closes.\n     fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n     fn select() -> Either<T, U>;\n }\n \n-impl<T: send, U: send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n+impl<T: Send, U: Send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n     (Left, Right): Select2<T, U> {\n \n     fn select() -> Either<T, U> {\n@@ -1220,32 +1220,32 @@ impl<T: send, U: send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n }\n \n proto! oneshot (\n-    Oneshot:send<T:send> {\n+    Oneshot:send<T:Send> {\n         send(T) -> !\n     }\n )\n \n /// The send end of a oneshot pipe.\n-type ChanOne<T: send> = oneshot::client::Oneshot<T>;\n+type ChanOne<T: Send> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-type PortOne<T: send> = oneshot::server::Oneshot<T>;\n+type PortOne<T: Send> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-fn oneshot<T: send>() -> (ChanOne<T>, PortOne<T>) {\n+fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n     oneshot::init()\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-fn recv_one<T: send>(+port: PortOne<T>) -> T {\n+fn recv_one<T: Send>(+port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(port);\n     message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-fn try_recv_one<T: send> (+port: PortOne<T>) -> Option<T> {\n+fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n     let message = try_recv(port);\n \n     if message.is_none() { None }\n@@ -1256,15 +1256,15 @@ fn try_recv_one<T: send> (+port: PortOne<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-fn send_one<T: send>(+chan: ChanOne<T>, +data: T) {\n+fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n     oneshot::client::send(chan, data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-fn try_send_one<T: send>(+chan: ChanOne<T>, +data: T)\n+fn try_send_one<T: Send>(+chan: ChanOne<T>, +data: T)\n         -> bool {\n     oneshot::client::try_send(chan, data).is_some()\n }"}, {"sha": "046621897f8fce977fd7864b43bf466df9f1633a", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -27,7 +27,7 @@ type GlobalPtr = *libc::uintptr_t;\n  * or, if no channel exists creates and installs a new channel and sets up a\n  * new task to receive from it.\n  */\n-unsafe fn chan_from_global_ptr<T: send>(\n+unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n     +f: fn~(comm::Port<T>)"}, {"sha": "77a5dbbc31006280b744cf2398e9875f811d56d0", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -165,12 +165,12 @@ impl Rng {\n     }\n \n     /// Choose an item randomly, failing if values is empty\n-    fn choose<T:copy>(values: &[T]) -> T {\n+    fn choose<T:Copy>(values: &[T]) -> T {\n         self.choose_option(values).get()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:copy>(values: &[T]) -> Option<T> {\n+    fn choose_option<T:Copy>(values: &[T]) -> Option<T> {\n         if values.is_empty() {\n             None\n         } else {\n@@ -182,15 +182,15 @@ impl Rng {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T: copy>(v : &[Weighted<T>]) -> T {\n+    fn choose_weighted<T: Copy>(v : &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:copy>(v: &[Weighted<T>]) -> Option<T> {\n+    fn choose_weighted_option<T:Copy>(v: &[Weighted<T>]) -> Option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n             total += item.weight;\n@@ -213,7 +213,7 @@ impl Rng {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      */\n-    fn weighted_vec<T:copy>(v: &[Weighted<T>]) -> ~[T] {\n+    fn weighted_vec<T:Copy>(v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n@@ -224,7 +224,7 @@ impl Rng {\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:copy>(values: &[T]) -> ~[T] {\n+    fn shuffle<T:Copy>(values: &[T]) -> ~[T] {\n         let mut m = vec::from_slice(values);\n         self.shuffle_mut(m);\n         return m;"}, {"sha": "7f3f35acc903546572dda8ac8e8f4ca6624b6c86", "filename": "src/libcore/result.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -18,7 +18,7 @@ enum Result<T, U> {\n  *\n  * If the result is an error\n  */\n-pure fn get<T: copy, U>(res: Result<T, U>) -> T {\n+pure fn get<T: Copy, U>(res: Result<T, U>) -> T {\n     match res {\n       Ok(t) => t,\n       Err(the_err) => unchecked {\n@@ -50,7 +50,7 @@ pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n  *\n  * If the result is not an error\n  */\n-pure fn get_err<T, U: copy>(res: Result<T, U>) -> U {\n+pure fn get_err<T, U: Copy>(res: Result<T, U>) -> U {\n     match res {\n       Err(u) => u,\n       Ok(_) => fail ~\"get_err called on ok result\"\n@@ -76,7 +76,7 @@ pure fn is_err<T, U>(res: Result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-pure fn to_either<T: copy, U: copy>(res: Result<U, T>) -> Either<T, U> {\n+pure fn to_either<T: Copy, U: Copy>(res: Result<U, T>) -> Either<T, U> {\n     match res {\n       Ok(res) => either::Right(res),\n       Err(fail_) => either::Left(fail_)\n@@ -97,7 +97,7 @@ pure fn to_either<T: copy, U: copy>(res: Result<U, T>) -> Either<T, U> {\n  *         ok(parse_buf(buf))\n  *     }\n  */\n-fn chain<T, U: copy, V: copy>(res: Result<T, V>, op: fn(T) -> Result<U, V>)\n+fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(T) -> Result<U, V>)\n     -> Result<U, V> {\n     match res {\n       Ok(t) => op(t),\n@@ -113,7 +113,7 @@ fn chain<T, U: copy, V: copy>(res: Result<T, V>, op: fn(T) -> Result<U, V>)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn chain_err<T: copy, U: copy, V: copy>(\n+fn chain_err<T: Copy, U: Copy, V: Copy>(\n     res: Result<T, V>,\n     op: fn(V) -> Result<T, U>)\n     -> Result<T, U> {\n@@ -173,7 +173,7 @@ fn iter_err<T, E>(res: Result<T, E>, f: fn(E)) {\n  *         parse_buf(buf)\n  *     }\n  */\n-fn map<T, E: copy, U: copy>(res: Result<T, E>, op: fn(T) -> U)\n+fn map<T, E: Copy, U: Copy>(res: Result<T, E>, op: fn(T) -> U)\n   -> Result<U, E> {\n     match res {\n       Ok(t) => Ok(op(t)),\n@@ -189,7 +189,7 @@ fn map<T, E: copy, U: copy>(res: Result<T, E>, op: fn(T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn map_err<T: copy, E, F: copy>(res: Result<T, E>, op: fn(E) -> F)\n+fn map_err<T: Copy, E, F: Copy>(res: Result<T, E>, op: fn(E) -> F)\n   -> Result<T, F> {\n     match res {\n       Ok(t) => Ok(t),\n@@ -217,34 +217,34 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-impl<T: copy, E> Result<T, E> {\n+impl<T: Copy, E> Result<T, E> {\n     fn get() -> T { get(self) }\n \n-    fn map_err<F:copy>(op: fn(E) -> F) -> Result<T,F> {\n+    fn map_err<F:Copy>(op: fn(E) -> F) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n         }\n     }\n }\n \n-impl<T, E: copy> Result<T, E> {\n+impl<T, E: Copy> Result<T, E> {\n     fn get_err() -> E { get_err(self) }\n \n-    fn map<U:copy>(op: fn(T) -> U) -> Result<U,E> {\n+    fn map<U:Copy>(op: fn(T) -> U) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n           Err(e) => Err(e)\n         }\n     }\n }\n \n-impl<T: copy, E: copy> Result<T, E> {\n-    fn chain<U:copy>(op: fn(T) -> Result<U,E>) -> Result<U,E> {\n+impl<T: Copy, E: Copy> Result<T, E> {\n+    fn chain<U:Copy>(op: fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n-    fn chain_err<F:copy>(op: fn(E) -> Result<T,F>) -> Result<T,F> {\n+    fn chain_err<F:Copy>(op: fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n@@ -266,7 +266,7 @@ impl<T: copy, E: copy> Result<T, E> {\n  *         assert incd == ~[2u, 3u, 4u];\n  *     }\n  */\n-fn map_vec<T,U:copy,V:copy>(\n+fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: fn(T) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = ~[];\n@@ -280,7 +280,7 @@ fn map_vec<T,U:copy,V:copy>(\n     return Ok(vs);\n }\n \n-fn map_opt<T,U:copy,V:copy>(\n+fn map_opt<T,U:Copy,V:Copy>(\n     o_t: Option<T>, op: fn(T) -> Result<V,U>) -> Result<Option<V>,U> {\n \n     match o_t {\n@@ -301,7 +301,7 @@ fn map_opt<T,U:copy,V:copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n-fn map_vec2<S,T,U:copy,V:copy>(ss: &[S], ts: &[T],\n+fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                                op: fn(S,T) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert vec::same_length(ss, ts);\n@@ -324,7 +324,7 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: &[S], ts: &[T],\n  * error.  This could be implemented using `map2()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n-fn iter_vec2<S,T,U:copy>(ss: &[S], ts: &[T],\n+fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: fn(S,T) -> Result<(),U>) -> Result<(),U> {\n \n     assert vec::same_length(ss, ts);"}, {"sha": "a292d011644139df4312251d07774b4b81fbbf67", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -8,7 +8,7 @@ use cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n-trait SendMap<K:Eq Hash, V: copy> {\n+trait SendMap<K:Eq Hash, V: Copy> {\n     // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n \n     fn insert(&mut self, +k: K, +v: V) -> bool;\n@@ -315,7 +315,7 @@ mod linear {\n         }\n     }\n \n-    impl<K:Hash IterBytes Eq, V: copy> LinearMap<K,V> {\n+    impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n         fn find(&const self, k: &K) -> Option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n               FoundEntry(idx) => {\n@@ -342,17 +342,17 @@ mod linear {\n \n     }\n \n-    impl<K: Hash IterBytes Eq copy, V: copy> LinearMap<K,V> {\n+    impl<K: Hash IterBytes Eq Copy, V: Copy> LinearMap<K,V> {\n         fn each(&self, blk: fn(+K,+V) -> bool) {\n             self.each_ref(|k,v| blk(copy *k, copy *v));\n         }\n     }\n-    impl<K: Hash IterBytes Eq copy, V> LinearMap<K,V> {\n+    impl<K: Hash IterBytes Eq Copy, V> LinearMap<K,V> {\n         fn each_key(&self, blk: fn(+K) -> bool) {\n             self.each_key_ref(|k| blk(copy *k));\n         }\n     }\n-    impl<K: Hash IterBytes Eq, V: copy> LinearMap<K,V> {\n+    impl<K: Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n         fn each_value(&self, blk: fn(+V) -> bool) {\n             self.each_value_ref(|v| blk(copy *v));\n         }"}, {"sha": "32ce963ebbb33aee7b2a56690dd9fa9d02ac0480", "filename": "src/libcore/task.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -380,7 +380,7 @@ impl TaskBuilder {\n         spawn_raw(x.opts, x.gen_body(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: send>(+arg: A, +f: fn~(+A)) {\n+    fn spawn_with<A: Send>(+arg: A, +f: fn~(+A)) {\n         let arg = ~mut Some(arg);\n         do self.spawn {\n             f(option::swap_unwrap(arg))\n@@ -398,7 +398,7 @@ impl TaskBuilder {\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n-    fn spawn_listener<A: send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+    fn spawn_listener<A: Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n         let setup_po = comm::Port();\n         let setup_ch = comm::Chan(setup_po);\n         do self.spawn {\n@@ -413,7 +413,7 @@ impl TaskBuilder {\n     /**\n      * Runs a new task, setting up communication in both directions\n      */\n-    fn spawn_conversation<A: send, B: send>\n+    fn spawn_conversation<A: Send, B: Send>\n         (+f: fn~(comm::Port<A>, comm::Chan<B>))\n         -> (comm::Port<B>, comm::Chan<A>) {\n         let from_child = comm::Port();\n@@ -437,7 +437,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T: send>(+f: fn~() -> T) -> Result<T,()> {\n+    fn try<T: Send>(+f: fn~() -> T) -> Result<T,()> {\n         let po = comm::Port();\n         let ch = comm::Chan(po);\n         let mut result = None;\n@@ -504,7 +504,7 @@ fn spawn_supervised(+f: fn~()) {\n     task().supervised().spawn(f)\n }\n \n-fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n+fn spawn_with<A:Send>(+arg: A, +f: fn~(+A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -518,7 +518,7 @@ fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n     task().spawn_with(arg, f)\n }\n \n-fn spawn_listener<A:send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n@@ -528,7 +528,7 @@ fn spawn_listener<A:send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     task().spawn_listener(f)\n }\n \n-fn spawn_conversation<A: send, B: send>\n+fn spawn_conversation<A: Send, B: Send>\n     (+f: fn~(comm::Port<A>, comm::Chan<B>))\n     -> (comm::Port<B>, comm::Chan<A>) {\n     /*!\n@@ -557,7 +557,7 @@ fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     task().sched_mode(mode).spawn(f)\n }\n \n-fn try<T:send>(+f: fn~() -> T) -> Result<T,()> {\n+fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -1314,10 +1314,10 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n  *\n  * These two cases aside, the interface is safe.\n  */\n-type LocalDataKey<T: owned> = &fn(+@T);\n+type LocalDataKey<T: Owned> = &fn(+@T);\n \n trait LocalData { }\n-impl<T: owned> @T: LocalData { }\n+impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n     pure fn eq(&&other: LocalData) -> bool unsafe {\n@@ -1365,7 +1365,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T: owned>(\n+unsafe fn key_to_key_value<T: Owned>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n@@ -1375,7 +1375,7 @@ unsafe fn key_to_key_value<T: owned>(\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: owned>(\n+unsafe fn local_data_lookup<T: Owned>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n@@ -1393,7 +1393,7 @@ unsafe fn local_data_lookup<T: owned>(\n     }\n }\n \n-unsafe fn local_get_helper<T: owned>(\n+unsafe fn local_get_helper<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n@@ -1414,21 +1414,21 @@ unsafe fn local_get_helper<T: owned>(\n     }\n }\n \n-unsafe fn local_pop<T: owned>(\n+unsafe fn local_pop<T: Owned>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, true)\n }\n \n-unsafe fn local_get<T: owned>(\n+unsafe fn local_get<T: Owned>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, false)\n }\n \n-unsafe fn local_set<T: owned>(\n+unsafe fn local_set<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n \n     let map = get_task_local_map(task);\n@@ -1460,7 +1460,7 @@ unsafe fn local_set<T: owned>(\n     }\n }\n \n-unsafe fn local_modify<T: owned>(\n+unsafe fn local_modify<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n \n@@ -1476,7 +1476,7 @@ unsafe fn local_modify<T: owned>(\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-unsafe fn local_data_pop<T: owned>(\n+unsafe fn local_data_pop<T: Owned>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_pop(rustrt::rust_get_task(), key)\n@@ -1485,7 +1485,7 @@ unsafe fn local_data_pop<T: owned>(\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-unsafe fn local_data_get<T: owned>(\n+unsafe fn local_data_get<T: Owned>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get(rustrt::rust_get_task(), key)\n@@ -1494,7 +1494,7 @@ unsafe fn local_data_get<T: owned>(\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-unsafe fn local_data_set<T: owned>(\n+unsafe fn local_data_set<T: Owned>(\n     key: LocalDataKey<T>, +data: @T) {\n \n     local_set(rustrt::rust_get_task(), key, data)\n@@ -1503,7 +1503,7 @@ unsafe fn local_data_set<T: owned>(\n  * Modify a task-local data value. If the function returns 'none', the\n  * data is removed (and its reference dropped).\n  */\n-unsafe fn local_data_modify<T: owned>(\n+unsafe fn local_data_modify<T: Owned>(\n     key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n "}, {"sha": "76d684a16cd97a6669597f180ea12ba74b74494b", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -50,13 +50,13 @@ impl &str: ToStr {\n     fn to_str() -> ~str { str::from_slice(self) }\n }\n \n-impl<A: ToStr copy, B: ToStr copy> (A, B): ToStr {\n+impl<A: ToStr Copy, B: ToStr Copy> (A, B): ToStr {\n     fn to_str() -> ~str {\n         let (a, b) = self;\n         ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\")\"\n     }\n }\n-impl<A: ToStr copy, B: ToStr copy, C: ToStr copy> (A, B, C): ToStr {\n+impl<A: ToStr Copy, B: ToStr Copy, C: ToStr Copy> (A, B, C): ToStr {\n     fn to_str() -> ~str {\n         let (a, b, c) = self;\n         ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\", \" + c.to_str() + ~\")\""}, {"sha": "4114adef8f0bfe7f7d4aef9c639487dab79a4d6e", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -12,7 +12,7 @@ trait TupleOps<T,U> {\n     pure fn swap() -> (U, T);\n }\n \n-impl<T: copy, U: copy> (T, U): TupleOps<T,U> {\n+impl<T: Copy, U: Copy> (T, U): TupleOps<T,U> {\n \n     /// Return the first element of self\n     pure fn first() -> T {\n@@ -39,7 +39,7 @@ trait ExtendedTupleOps<A,B> {\n     fn map<C>(f: fn(A, B) -> C) -> ~[C];\n }\n \n-impl<A: copy, B: copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n+impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n \n     fn zip() -> ~[(A, B)] {\n         let (a, b) = self;\n@@ -52,7 +52,7 @@ impl<A: copy, B: copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n     }\n }\n \n-impl<A: copy, B: copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n+impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n \n     fn zip() -> ~[(A, B)] {\n         // XXX: Bad copy"}, {"sha": "5539aa7d89e4133e123ba7b8db2a48b954e8be54", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -137,7 +137,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n+unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n@@ -207,9 +207,9 @@ unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n  * Data races between tasks can result in crashes and, with sufficient\n  * cleverness, arbitrary type coercion.\n  */\n-type SharedMutableState<T: send> = ArcDestruct<T>;\n+type SharedMutableState<T: Send> = ArcDestruct<T>;\n \n-unsafe fn shared_mutable_state<T: send>(+data: T) -> SharedMutableState<T> {\n+unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(data) };\n     unsafe {\n         let ptr = unsafe::transmute(data);\n@@ -218,7 +218,7 @@ unsafe fn shared_mutable_state<T: send>(+data: T) -> SharedMutableState<T> {\n }\n \n #[inline(always)]\n-unsafe fn get_shared_mutable_state<T: send>(rc: &a/SharedMutableState<T>)\n+unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         -> &a/mut T {\n     unsafe {\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n@@ -230,7 +230,7 @@ unsafe fn get_shared_mutable_state<T: send>(rc: &a/SharedMutableState<T>)\n     }\n }\n #[inline(always)]\n-unsafe fn get_shared_immutable_state<T: send>(rc: &a/SharedMutableState<T>)\n+unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n@@ -242,7 +242,7 @@ unsafe fn get_shared_immutable_state<T: send>(rc: &a/SharedMutableState<T>)\n     }\n }\n \n-unsafe fn clone_shared_mutable_state<T: send>(rc: &SharedMutableState<T>)\n+unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n@@ -312,20 +312,20 @@ impl LittleLock {\n     }\n }\n \n-struct ExData<T: send> { lock: LittleLock, mut failed: bool, mut data: T, }\n+struct ExData<T: Send> { lock: LittleLock, mut failed: bool, mut data: T, }\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n-struct Exclusive<T: send> { x: SharedMutableState<ExData<T>> }\n+struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n \n-fn exclusive<T:send >(+user_data: T) -> Exclusive<T> {\n+fn exclusive<T:Send >(+user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(data) } }\n }\n \n-impl<T: send> Exclusive<T> {\n+impl<T: Send> Exclusive<T> {\n     // Duplicate an exclusive ARC, as std::arc::clone.\n     fn clone() -> Exclusive<T> {\n         Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n@@ -353,7 +353,7 @@ impl<T: send> Exclusive<T> {\n }\n \n // FIXME(#2585) make this a by-move method on the exclusive\n-fn unwrap_exclusive<T: send>(+arc: Exclusive<T>) -> T {\n+fn unwrap_exclusive<T: Send>(+arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n     let ExData { data: data, _ } = inner;"}, {"sha": "e2128693ace837befc52db571be851d374e8de05", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -17,7 +17,7 @@ pure fn ignore<T>(+_x: T) { }\n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`.\n #[inline(always)]\n-fn with<T: copy, R>(\n+fn with<T: Copy, R>(\n     ptr: &mut T,\n     +new_value: T,\n     op: &fn() -> R) -> R"}, {"sha": "2ae6a7b2780ce6155fa7f432e1df30716185a45d", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -199,7 +199,7 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n+pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n@@ -211,7 +211,7 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n }\n \n /// Creates a new unique vector with the same contents as the slice\n-pure fn from_slice<T: copy>(t: &[T]) -> ~[T] {\n+pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n@@ -281,29 +281,29 @@ pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n // Accessors\n \n /// Returns the first element of a vector\n-pure fn head<T: copy>(v: &[const T]) -> T { v[0] }\n+pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n \n /// Returns a vector containing all but the first element of a slice\n-pure fn tail<T: copy>(v: &[const T]) -> ~[T] {\n+pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n     return slice(v, 1u, len(v));\n }\n \n /**\n  * Returns a vector containing all but the first `n` \\\n  * elements of a slice\n  */\n-pure fn tailn<T: copy>(v: &[const T], n: uint) -> ~[T] {\n+pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n     slice(v, n, len(v))\n }\n \n /// Returns a vector containing all but the last element of a slice\n-pure fn init<T: copy>(v: &[const T]) -> ~[T] {\n+pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pure fn last<T: copy>(v: &[const T]) -> T {\n+pure fn last<T: Copy>(v: &[const T]) -> T {\n     if len(v) == 0u { fail ~\"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n@@ -312,13 +312,13 @@ pure fn last<T: copy>(v: &[const T]) -> T {\n  * Returns `Some(x)` where `x` is the last element of the slice `v`,\n  * or `none` if the vector is empty.\n  */\n-pure fn last_opt<T: copy>(v: &[const T]) -> Option<T> {\n+pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n     if len(v) == 0u { return None; }\n     Some(v[len(v) - 1u])\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n+pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let mut result = ~[];\n@@ -365,7 +365,7 @@ pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n }\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n+fn split<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -388,7 +388,7 @@ fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n+fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -414,7 +414,7 @@ fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n+fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -438,7 +438,7 @@ fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n+fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -589,7 +589,7 @@ fn push_slow<T>(&v: ~[const T], +initval: T) {\n }\n \n #[inline(always)]\n-fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n+fn push_all<T: Copy>(&v: ~[const T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n@@ -627,7 +627,7 @@ fn truncate<T>(&v: ~[const T], newlen: uint) {\n \n // Appending\n #[inline(always)]\n-pure fn append<T: copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v <- lhs;\n     unchecked {\n         push_all(v, rhs);\n@@ -643,7 +643,7 @@ pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n }\n \n #[inline(always)]\n-pure fn append_mut<T: copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n+pure fn append_mut<T: Copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n     let mut v = ~[mut];\n     let mut i = 0u;\n     while i < lhs.len() {\n@@ -671,7 +671,7 @@ pure fn append_mut<T: copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * n - The number of elements to add\n  * * initval - The value for the new elements\n  */\n-fn grow<T: copy>(&v: ~[const T], n: uint, initval: T) {\n+fn grow<T: Copy>(&v: ~[const T], n: uint, initval: T) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n \n@@ -705,7 +705,7 @@ fn grow_fn<T>(&v: ~[const T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-fn grow_set<T: copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n+fn grow_set<T: Copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n@@ -747,7 +747,7 @@ pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n }\n \n /// Apply a function to each pair of elements and return the results\n-pure fn map2<T: copy, U: copy, V>(v0: &[T], v1: &[U],\n+pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n                                   f: fn(T, U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n@@ -766,7 +766,7 @@ pure fn map2<T: copy, U: copy, V>(v0: &[T], v1: &[U],\n  * If function `f` returns `none` then that element is excluded from\n  * the resulting vector.\n  */\n-pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> Option<U>)\n+pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n@@ -785,7 +785,7 @@ pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> Option<U>)\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n+pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { push(result, elem); } }\n@@ -798,14 +798,14 @@ pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pure fn concat<T: copy>(v: &[~[T]]) -> ~[T] {\n+pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { push_all(r, inner); } }\n     return r;\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pure fn connect<T: copy>(v: &[~[T]], sep: T) -> ~[T] {\n+pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n@@ -816,7 +816,7 @@ pure fn connect<T: copy>(v: &[~[T]], sep: T) -> ~[T] {\n }\n \n /// Reduce a vector from left to right\n-pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n+pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n     do iter(v) |elt| {\n         accum = p(accum, elt);\n@@ -825,7 +825,7 @@ pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n }\n \n /// Reduce a vector from right to left\n-pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n+pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n     do riter(v) |elt| {\n         accum = p(elt, accum);\n@@ -914,7 +914,7 @@ pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find<T: copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n+pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -925,7 +925,7 @@ pure fn find<T: copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n+pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> Option<T> {\n     option::map(position_between(v, start, end, f), |i| v[i])\n }\n@@ -937,7 +937,7 @@ pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rfind<T: copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n+pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -948,7 +948,7 @@ pure fn rfind<T: copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn rfind_between<T: copy>(v: &[T], start: uint, end: uint,\n+pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n                                f: fn(T) -> bool) -> Option<T> {\n     option::map(rposition_between(v, start, end, f), |i| v[i])\n }\n@@ -1028,7 +1028,7 @@ pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n /**\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n-pure fn unzip_slice<T: copy, U: copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n+pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut as = ~[], bs = ~[];\n     for each(v) |p| {\n         let (a, b) = p;\n@@ -1063,7 +1063,7 @@ pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pure fn zip_slice<T: copy, U: copy>(v: &[const T], u: &[const U])\n+pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -1113,7 +1113,7 @@ fn reverse<T>(v: ~[mut T]) {\n \n \n /// Returns a vector with the order of elements reversed\n-pure fn reversed<T: copy>(v: &[const T]) -> ~[T] {\n+pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0u { return rs; } else { i -= 1u; }\n@@ -1317,7 +1317,7 @@ pure fn riteri<T>(v: &[T], f: fn(uint, T)) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pure fn permute<T: copy>(v: &[const T], put: fn(~[T])) {\n+pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n     let ln = len(v);\n     if ln == 0u {\n         put(~[]);\n@@ -1337,7 +1337,7 @@ pure fn permute<T: copy>(v: &[const T], put: fn(~[T])) {\n     }\n }\n \n-pure fn windowed<TT: copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n+pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n     vec::iteri (xx, |ii, _x| {\n@@ -1480,14 +1480,14 @@ impl<T: Ord> @[T]: Ord {\n }\n \n #[cfg(notest)]\n-impl<T: copy> ~[T]: Add<&[const T],~[T]> {\n+impl<T: Copy> ~[T]: Add<&[const T],~[T]> {\n     #[inline(always)]\n     pure fn add(rhs: &[const T]) -> ~[T] {\n         append(copy self, rhs)\n     }\n }\n \n-impl<T: copy> ~[mut T]: Add<&[const T],~[mut T]> {\n+impl<T: Copy> ~[mut T]: Add<&[const T],~[mut T]> {\n     #[inline(always)]\n     pure fn add(rhs: &[const T]) -> ~[mut T] {\n         append_mut(self, rhs)\n@@ -1522,7 +1522,7 @@ trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: copy> &[const T]: CopyableVector<T> {\n+impl<T: Copy> &[const T]: CopyableVector<T> {\n     /// Returns the first element of a vector\n     #[inline]\n     pure fn head() -> T { head(self) }\n@@ -1541,7 +1541,7 @@ impl<T: copy> &[const T]: CopyableVector<T> {\n }\n \n trait ImmutableVector<T> {\n-    pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U;\n+    pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U;\n     pure fn iter(f: fn(T));\n     pure fn iteri(f: fn(uint, T));\n     pure fn riter(f: fn(T));\n@@ -1551,7 +1551,7 @@ trait ImmutableVector<T> {\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(f: fn(uint, T) -> bool) -> bool;\n     pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: copy>(f: fn(T) -> Option<U>) -> ~[U];\n+    pure fn filter_map<U: Copy>(f: fn(T) -> Option<U>) -> ~[U];\n }\n \n trait ImmutableEqVector<T: Eq> {\n@@ -1565,7 +1565,7 @@ trait ImmutableEqVector<T: Eq> {\n impl<T> &[T]: ImmutableVector<T> {\n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+    pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n     /**\n      * Iterates over a vector\n      *\n@@ -1641,7 +1641,7 @@ impl<T> &[T]: ImmutableVector<T> {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: copy>(f: fn(T) -> Option<U>) -> ~[U] {\n+    pure fn filter_map<U: Copy>(f: fn(T) -> Option<U>) -> ~[U] {\n         filter_map(self, f)\n     }\n }\n@@ -1679,7 +1679,7 @@ trait ImmutableCopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: copy> &[T]: ImmutableCopyableVector<T> {\n+impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n     /**\n      * Construct a new vector from the elements of a vector for which some\n      * predicate holds.\n@@ -1785,7 +1785,7 @@ mod unsafe {\n      * Unchecked vector indexing.\n      */\n     #[inline(always)]\n-    unsafe fn get<T: copy>(v: &[const T], i: uint) -> T {\n+    unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n         as_buf(v, |p, _len| *ptr::offset(p, i))\n     }\n \n@@ -1938,7 +1938,7 @@ impl<A: Eq> &[A]: iter::EqIter<A> {\n     }\n }\n \n-impl<A: copy> &[A]: iter::CopyableIter<A> {\n+impl<A: Copy> &[A]: iter::CopyableIter<A> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -1955,7 +1955,7 @@ impl<A: copy> &[A]: iter::CopyableIter<A> {\n     pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n }\n \n-impl<A: copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n+impl<A: Copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n     pure fn min() -> A { iter::min(self) }\n     pure fn max() -> A { iter::max(self) }\n }"}, {"sha": "fb9a7e7e489c1de3ea5e7c0836e144a0f80c6e61", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -69,18 +69,18 @@ impl &Condvar {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-struct ARC<T: const send> { x: SharedMutableState<T> }\n+struct ARC<T: Const Send> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n-fn ARC<T: const send>(+data: T) -> ARC<T> {\n+fn ARC<T: Const Send>(+data: T) -> ARC<T> {\n     ARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-fn get<T: const send>(rc: &a/ARC<T>) -> &a/T {\n+fn get<T: Const Send>(rc: &a/ARC<T>) -> &a/T {\n     unsafe { get_shared_immutable_state(&rc.x) }\n }\n \n@@ -91,7 +91,7 @@ fn get<T: const send>(rc: &a/ARC<T>) -> &a/T {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-fn clone<T: const send>(rc: &ARC<T>) -> ARC<T> {\n+fn clone<T: Const Send>(rc: &ARC<T>) -> ARC<T> {\n     ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n }\n \n@@ -104,7 +104,7 @@ fn clone<T: const send>(rc: &ARC<T>) -> ARC<T> {\n  * unwrap from a task that holds another reference to the same ARC; it is\n  * guaranteed to deadlock.\n  */\n-fn unwrap<T: const send>(+rc: ARC<T>) -> T {\n+fn unwrap<T: Const Send>(+rc: ARC<T>) -> T {\n     let ARC { x: x } = rc;\n     unsafe { unwrap_shared_mutable_state(x) }\n }\n@@ -114,27 +114,27 @@ fn unwrap<T: const send>(+rc: ARC<T>) -> T {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct MutexARCInner<T: send> { lock: Mutex, failed: bool, data: T }\n+struct MutexARCInner<T: Send> { lock: Mutex, failed: bool, data: T }\n /// An ARC with mutable data protected by a blocking mutex.\n-struct MutexARC<T: send> { x: SharedMutableState<MutexARCInner<T>> }\n+struct MutexARC<T: Send> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-fn MutexARC<T: send>(+user_data: T) -> MutexARC<T> {\n+fn MutexARC<T: Send>(+user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-fn mutex_arc_with_condvars<T: send>(+user_data: T,\n+fn mutex_arc_with_condvars<T: Send>(+user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n     MutexARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n-impl<T: send> &MutexARC<T> {\n+impl<T: Send> &MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone() -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n@@ -197,7 +197,7 @@ impl<T: send> &MutexARC<T> {\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-fn unwrap_mutex_arc<T: send>(+arc: MutexARC<T>) -> T {\n+fn unwrap_mutex_arc<T: Send>(+arc: MutexARC<T>) -> T {\n     let MutexARC { x: x } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n     let MutexARCInner { failed: failed, data: data, _ } = inner;\n@@ -240,35 +240,35 @@ fn PoisonOnFail(failed: &r/mut bool) -> PoisonOnFail/&r {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct RWARCInner<T: const send> { lock: RWlock, failed: bool, data: T }\n+struct RWARCInner<T: Const Send> { lock: RWlock, failed: bool, data: T }\n /**\n  * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n  * mutably or immutably, and immutably-accessing tasks may run concurrently.\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n-struct RWARC<T: const send> {\n+struct RWARC<T: Const Send> {\n     x: SharedMutableState<RWARCInner<T>>,\n     mut cant_nest: ()\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-fn RWARC<T: const send>(+user_data: T) -> RWARC<T> {\n+fn RWARC<T: Const Send>(+user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-fn rw_arc_with_condvars<T: const send>(+user_data: T,\n+fn rw_arc_with_condvars<T: Const Send>(+user_data: T,\n                                        num_condvars: uint) -> RWARC<T> {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n                      failed: false, data: user_data };\n     RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n }\n \n-impl<T: const send> &RWARC<T> {\n+impl<T: Const Send> &RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     fn clone() -> RWARC<T> {\n         RWARC { x: unsafe { clone_shared_mutable_state(&self.x) },\n@@ -375,7 +375,7 @@ impl<T: const send> &RWARC<T> {\n  * in write mode.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-fn unwrap_rw_arc<T: const send>(+arc: RWARC<T>) -> T {\n+fn unwrap_rw_arc<T: Const Send>(+arc: RWARC<T>) -> T {\n     let RWARC { x: x, _ } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n     let RWARCInner { failed: failed, data: data, _ } = inner;\n@@ -389,19 +389,19 @@ fn unwrap_rw_arc<T: const send>(+arc: RWARC<T>) -> T {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T: const send>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n+fn borrow_rwlock<T: Const Send>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n     unsafe { unsafe::transmute_immut(&mut state.lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n \n /// The \"write permission\" token used for RWARC.write_downgrade().\n-enum RWWriteMode<T: const send> =\n+enum RWWriteMode<T: Const Send> =\n     (&mut T, sync::RWlockWriteMode, PoisonOnFail);\n /// The \"read permission\" token used for RWARC.write_downgrade().\n-enum RWReadMode<T:const send> = (&T, sync::RWlockReadMode);\n+enum RWReadMode<T:Const Send> = (&T, sync::RWlockReadMode);\n \n-impl<T: const send> &RWWriteMode<T> {\n+impl<T: Const Send> &RWWriteMode<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n         match *self {\n@@ -427,7 +427,7 @@ impl<T: const send> &RWWriteMode<T> {\n     }\n }\n \n-impl<T: const send> &RWReadMode<T> {\n+impl<T: Const Send> &RWReadMode<T> {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn(x: &T) -> U) -> U {\n         match *self {"}, {"sha": "53964fb0ddb56e9a6a6457b0a954e8daa724e6e1", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -107,7 +107,7 @@ unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-fn get<T: copy>(t: CVec<T>, ofs: uint) -> T {\n+fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n     return unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n@@ -117,7 +117,7 @@ fn get<T: copy>(t: CVec<T>, ofs: uint) -> T {\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-fn set<T: copy>(t: CVec<T>, ofs: uint, v: T) {\n+fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }"}, {"sha": "d78e11452bcb861559fae3327a84d35051226554", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -13,7 +13,7 @@ use pipes::{Channel, Recv, Chan, Port, Selectable};\n export DuplexStream;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n-struct DuplexStream<T: send, U: send> : Channel<T>, Recv<U>, Selectable {\n+struct DuplexStream<T: Send, U: Send> : Channel<T>, Recv<U>, Selectable {\n     priv chan: Chan<T>,\n     priv port: Port <U>,\n \n@@ -43,7 +43,7 @@ struct DuplexStream<T: send, U: send> : Channel<T>, Recv<U>, Selectable {\n }\n \n /// Creates a bidirectional stream.\n-fn DuplexStream<T: send, U: send>()\n+fn DuplexStream<T: Send, U: Send>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)\n {\n     let (c2, p1) = pipes::stream();"}, {"sha": "f9def4b2332f5c6d421f06501541cf270ffccb8d", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -16,15 +16,15 @@ trait Deque<T> {\n \n // FIXME (#2343) eventually, a proper datatype plus an exported impl would\n // be preferrable.\n-fn create<T: copy>() -> Deque<T> {\n+fn create<T: Copy>() -> Deque<T> {\n     type Cell<T> = Option<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: copy>(nelts: uint, lo: uint, -elts: ~[mut Cell<T>]) ->\n+    fn grow<T: Copy>(nelts: uint, lo: uint, -elts: ~[mut Cell<T>]) ->\n        ~[mut Cell<T>] {\n         assert (nelts == vec::len(elts));\n         let mut rv = ~[mut];\n@@ -40,7 +40,7 @@ fn create<T: copy>() -> Deque<T> {\n \n         return rv;\n     }\n-    fn get<T: copy>(elts: DVec<Cell<T>>, i: uint) -> T {\n+    fn get<T: Copy>(elts: DVec<Cell<T>>, i: uint) -> T {\n         match elts.get_elt(i) { Some(t) => t, _ => fail }\n     }\n \n@@ -49,7 +49,7 @@ fn create<T: copy>() -> Deque<T> {\n                     mut hi: uint,\n                     elts: DVec<Cell<T>>};\n \n-    impl <T: copy> Repr<T>: Deque<T> {\n+    impl <T: Copy> Repr<T>: Deque<T> {\n         fn size() -> uint { return self.nelts; }\n         fn add_front(t: T) {\n             let oldlo: uint = self.lo;\n@@ -193,7 +193,7 @@ mod tests {\n \n     type EqFn<T> = fn@(T, T) -> bool;\n \n-    fn test_parameterized<T: copy owned>(\n+    fn test_parameterized<T: Copy Owned>(\n         e: EqFn<T>, a: T, b: T, c: T, d: T) {\n \n         let deq: deque::Deque<T> = deque::create::<T>();"}, {"sha": "3761b51140283a735e44ef9504b6d8c62b89bcec", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -33,7 +33,7 @@ enum TreeNode<K, V> {\n fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-fn insert<K: copy Eq Ord, V: copy>(m: Treemap<K, V>, +k: K, +v: V)\n+fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n   -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n@@ -48,7 +48,7 @@ fn insert<K: copy Eq Ord, V: copy>(m: Treemap<K, V>, +k: K, +v: V)\n }\n \n /// Find a value based on the key\n-fn find<K: Eq Ord, V: copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n+fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@kk, @v, left, right) => {\n@@ -60,7 +60,7 @@ fn find<K: Eq Ord, V: copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n }\n \n /// Visit all pairs in the map in order.\n-fn traverse<K, V: copy>(m: Treemap<K, V>, f: fn(K, V)) {\n+fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn(K, V)) {\n     match *m {\n       Empty => (),\n       /*"}, {"sha": "1adb41e8d10b8562888f78b4918d0640160b58c7", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -720,7 +720,7 @@ impl <A: ToJson> ~[A]: ToJson {\n     fn to_json() -> Json { List(@self.map(|elt| elt.to_json())) }\n }\n \n-impl <A: ToJson copy> hashmap<~str, A>: ToJson {\n+impl <A: ToJson Copy> hashmap<~str, A>: ToJson {\n     fn to_json() -> Json {\n         let d = map::str_hash();\n         for self.each() |key, value| {"}, {"sha": "96d4e32d02befa368f6869683840938c966a7e27", "filename": "src/libstd/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -13,7 +13,7 @@ enum List<T> {\n }\n \n /// Cregate a list from a vector\n-fn from_vec<T: copy>(v: &[T]) -> @List<T> {\n+fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(h, t))\n }\n \n@@ -30,7 +30,7 @@ fn from_vec<T: copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-fn foldl<T: copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n+fn foldl<T: Copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, &elt);}\n     accum\n@@ -43,7 +43,7 @@ fn foldl<T: copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-fn find<T: copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n+fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -57,23 +57,23 @@ fn find<T: copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-fn has<T: copy Eq>(ls: @List<T>, +elt: T) -> bool {\n+fn has<T: Copy Eq>(ls: @List<T>, +elt: T) -> bool {\n     for each(ls) |e| {\n         if e == elt { return true; }\n     }\n     return false;\n }\n \n /// Returns true if the list is empty\n-pure fn is_empty<T: copy>(ls: @List<T>) -> bool {\n+pure fn is_empty<T: Copy>(ls: @List<T>) -> bool {\n     match *ls {\n         Nil => true,\n         _ => false\n     }\n }\n \n /// Returns true if the list is not empty\n-pure fn is_not_empty<T: copy>(ls: @List<T>) -> bool {\n+pure fn is_not_empty<T: Copy>(ls: @List<T>) -> bool {\n     return !is_empty(ls);\n }\n \n@@ -85,15 +85,15 @@ fn len<T>(ls: @List<T>) -> uint {\n }\n \n /// Returns all but the first element of a list\n-pure fn tail<T: copy>(ls: @List<T>) -> @List<T> {\n+pure fn tail<T: Copy>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n         Nil => fail ~\"list empty\"\n     }\n }\n \n /// Returns the first element of a list\n-pure fn head<T: copy>(ls: @List<T>) -> T {\n+pure fn head<T: Copy>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(hd, _) => hd,\n       // makes me sad\n@@ -102,7 +102,7 @@ pure fn head<T: copy>(ls: @List<T>) -> T {\n }\n \n /// Appends one list to another\n-pure fn append<T: copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n+pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n       Cons(x, xs) => {\n@@ -115,7 +115,7 @@ pure fn append<T: copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-pure fn push<T: copy>(ll: &mut @list<T>, +vv: T) {\n+pure fn push<T: Copy>(ll: &mut @list<T>, +vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */"}, {"sha": "5436ea1a8033035a8c39cb7c6e6a49052615dedd", "filename": "src/libstd/map.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -24,7 +24,7 @@ type set<K:Eq IterBytes Hash> = hashmap<K, ()>;\n \n type hashmap<K:Eq IterBytes Hash, V> = chained::t<K, V>;\n \n-trait map<K:Eq IterBytes Hash copy, V: copy> {\n+trait map<K:Eq IterBytes Hash Copy, V: Copy> {\n     /// Return the number of elements in the map\n     pure fn size() -> uint;\n \n@@ -123,7 +123,7 @@ mod chained {\n         found_after(@entry<K,V>, @entry<K,V>)\n     }\n \n-    priv impl<K:Eq IterBytes Hash, V: copy> t<K, V> {\n+    priv impl<K:Eq IterBytes Hash, V: Copy> t<K, V> {\n         pure fn search_rem(k: &K, h: uint, idx: uint,\n                            e_root: @entry<K,V>) -> search_result<K,V> {\n             let mut e0 = e_root;\n@@ -207,7 +207,7 @@ mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash copy, V: copy> t<K, V>: map<K, V> {\n+    impl<K:Eq IterBytes Hash Copy, V: Copy> t<K, V>: map<K, V> {\n         pure fn size() -> uint { self.count }\n \n         fn contains_key(+k: K) -> bool {\n@@ -330,7 +330,7 @@ mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash copy ToStr, V: ToStr copy> t<K, V>: ToStr {\n+    impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> t<K, V>: ToStr {\n         fn to_writer(wr: io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n@@ -356,7 +356,7 @@ mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash copy, V: copy> t<K, V>: ops::Index<K, V> {\n+    impl<K:Eq IterBytes Hash Copy, V: Copy> t<K, V>: ops::Index<K, V> {\n         pure fn index(&&k: K) -> V {\n             unchecked {\n                 self.get(k)\n@@ -368,7 +368,7 @@ mod chained {\n         vec::to_mut(vec::from_elem(nchains, None))\n     }\n \n-    fn mk<K:Eq IterBytes Hash, V: copy>() -> t<K,V> {\n+    fn mk<K:Eq IterBytes Hash, V: Copy>() -> t<K,V> {\n         let slf: t<K, V> = @hashmap_ {count: 0u,\n                                       chains: chains(initial_capacity)};\n         slf\n@@ -380,48 +380,48 @@ Function: hashmap\n \n Construct a hashmap.\n */\n-fn hashmap<K:Eq IterBytes Hash const, V: copy>()\n+fn hashmap<K:Eq IterBytes Hash Const, V: Copy>()\n         -> hashmap<K, V> {\n     chained::mk()\n }\n \n /// Construct a hashmap for string-slice keys\n-fn str_slice_hash<V: copy>() -> hashmap<&str, V> {\n+fn str_slice_hash<V: Copy>() -> hashmap<&str, V> {\n     return hashmap();\n }\n \n /// Construct a hashmap for string keys\n-fn str_hash<V: copy>() -> hashmap<~str, V> {\n+fn str_hash<V: Copy>() -> hashmap<~str, V> {\n     return hashmap();\n }\n \n /// Construct a hashmap for boxed string keys\n-fn box_str_hash<V: copy>() -> hashmap<@~str, V> {\n+fn box_str_hash<V: Copy>() -> hashmap<@~str, V> {\n     hashmap()\n }\n \n /// Construct a hashmap for byte string keys\n-fn bytes_hash<V: copy>() -> hashmap<~[u8], V> {\n+fn bytes_hash<V: Copy>() -> hashmap<~[u8], V> {\n     return hashmap();\n }\n \n /// Construct a hashmap for int keys\n-fn int_hash<V: copy>() -> hashmap<int, V> {\n+fn int_hash<V: Copy>() -> hashmap<int, V> {\n     return hashmap();\n }\n \n /// Construct a hashmap for uint keys\n-fn uint_hash<V: copy>() -> hashmap<uint, V> {\n+fn uint_hash<V: Copy>() -> hashmap<uint, V> {\n     return hashmap();\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n-fn set_add<K:Eq IterBytes Hash const copy>(set: set<K>, +key: K) -> bool {\n+fn set_add<K:Eq IterBytes Hash Const Copy>(set: set<K>, +key: K) -> bool {\n     set.insert(key, ())\n }\n \n /// Convert a set into a vector.\n-fn vec_from_set<T:Eq IterBytes Hash copy>(s: set<T>) -> ~[T] {\n+fn vec_from_set<T:Eq IterBytes Hash Copy>(s: set<T>) -> ~[T] {\n     let mut v = ~[];\n     vec::reserve(v, s.size());\n     do s.each_key() |k| {\n@@ -432,7 +432,7 @@ fn vec_from_set<T:Eq IterBytes Hash copy>(s: set<T>) -> ~[T] {\n }\n \n /// Construct a hashmap from a vector\n-fn hash_from_vec<K: Eq IterBytes Hash const copy, V: copy>(\n+fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n     items: &[(K, V)]) -> hashmap<K, V> {\n     let map = hashmap();\n     do vec::iter(items) |item| {\n@@ -443,27 +443,27 @@ fn hash_from_vec<K: Eq IterBytes Hash const copy, V: copy>(\n }\n \n /// Construct a hashmap from a vector with string keys\n-fn hash_from_strs<V: copy>(items: &[(~str, V)]) -> hashmap<~str, V> {\n+fn hash_from_strs<V: Copy>(items: &[(~str, V)]) -> hashmap<~str, V> {\n     hash_from_vec(items)\n }\n \n /// Construct a hashmap from a vector with byte keys\n-fn hash_from_bytes<V: copy>(items: &[(~[u8], V)]) -> hashmap<~[u8], V> {\n+fn hash_from_bytes<V: Copy>(items: &[(~[u8], V)]) -> hashmap<~[u8], V> {\n     hash_from_vec(items)\n }\n \n /// Construct a hashmap from a vector with int keys\n-fn hash_from_ints<V: copy>(items: &[(int, V)]) -> hashmap<int, V> {\n+fn hash_from_ints<V: Copy>(items: &[(int, V)]) -> hashmap<int, V> {\n     hash_from_vec(items)\n }\n \n /// Construct a hashmap from a vector with uint keys\n-fn hash_from_uints<V: copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n+fn hash_from_uints<V: Copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n     hash_from_vec(items)\n }\n \n // XXX Transitional\n-impl<K: Eq IterBytes Hash copy, V: copy> Managed<LinearMap<K, V>>:\n+impl<K: Eq IterBytes Hash Copy, V: Copy> Managed<LinearMap<K, V>>:\n     map<K, V> {\n     pure fn size() -> uint {\n         unchecked {"}, {"sha": "d6e498c0a236253c73abbd9cabc9fc0ceb4c6acc", "filename": "src/libstd/par.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -18,7 +18,7 @@ const min_granularity : uint = 1024u;\n  * This is used to build most of the other parallel vector functions,\n  * like map or alli.\n  */\n-fn map_slices<A: copy send, B: copy send>(\n+fn map_slices<A: Copy Send, B: Copy Send>(\n     xs: &[A],\n     f: fn() -> fn~(uint, v: &[A]) -> B)\n     -> ~[B] {\n@@ -73,7 +73,7 @@ fn map_slices<A: copy send, B: copy send>(\n }\n \n /// A parallel version of map.\n-fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n+fn map<A: Copy Send, B: Copy Send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::map(slice, |x| f(x))\n@@ -82,7 +82,7 @@ fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n }\n \n /// A parallel version of mapi.\n-fn mapi<A: copy send, B: copy send>(xs: ~[A],\n+fn mapi<A: Copy Send, B: Copy Send>(xs: ~[A],\n                                     f: fn~(uint, A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n@@ -103,7 +103,7 @@ fn mapi<A: copy send, B: copy send>(xs: ~[A],\n  * In this case, f is a function that creates functions to run over the\n  * inner elements. This is to skirt the need for copy constructors.\n  */\n-fn mapi_factory<A: copy send, B: copy send>(\n+fn mapi_factory<A: Copy Send, B: Copy Send>(\n     xs: &[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         let f = f();\n@@ -120,7 +120,7 @@ fn mapi_factory<A: copy send, B: copy send>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-fn alli<A: copy send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n+fn alli<A: Copy Send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n@@ -131,7 +131,7 @@ fn alli<A: copy send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-fn any<A: copy send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n+fn any<A: Copy Send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))"}, {"sha": "743e2fc2bf14a4c2017959960249b0069c756910", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -93,7 +93,7 @@ fn emit_from_vec<S: serializer, T>(s: S, v: ~[T], f: fn(T)) {\n     }\n }\n \n-fn read_to_vec<D: deserializer, T: copy>(d: D, f: fn() -> T) -> ~[T] {\n+fn read_to_vec<D: deserializer, T: Copy>(d: D, f: fn() -> T) -> ~[T] {\n     do d.read_vec |len| {\n         do vec::from_fn(len) |i| {\n             d.read_vec_elt(i, || f())\n@@ -112,11 +112,11 @@ impl<S: serializer> S: serializer_helpers {\n }\n \n trait deserializer_helpers {\n-    fn read_to_vec<T: copy>(f: fn() -> T) -> ~[T];\n+    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T];\n }\n \n impl<D: deserializer> D: deserializer_helpers {\n-    fn read_to_vec<T: copy>(f: fn() -> T) -> ~[T] {\n+    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T] {\n         read_to_vec(self, f)\n     }\n }\n@@ -256,7 +256,7 @@ fn serialize_Option<S: serializer,T>(s: S, v: Option<T>, st: fn(T)) {\n     }\n }\n \n-fn deserialize_Option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n+fn deserialize_Option<D: deserializer,T: Copy>(d: D, st: fn() -> T)\n     -> Option<T> {\n     do d.read_enum(~\"option\") {\n         do d.read_enum_variant |i| {"}, {"sha": "a65d41a2d3240752cf14cbb971b84c15eb243600", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -12,14 +12,14 @@ use map::map;\n \n // FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n // requires this to be.\n-type SmallIntMap_<T: copy> = {v: DVec<Option<T>>};\n+type SmallIntMap_<T: Copy> = {v: DVec<Option<T>>};\n \n-enum SmallIntMap<T:copy> {\n+enum SmallIntMap<T:Copy> {\n     SmallIntMap_(@SmallIntMap_<T>)\n }\n \n /// Create a smallintmap\n-fn mk<T: copy>() -> SmallIntMap<T> {\n+fn mk<T: Copy>() -> SmallIntMap<T> {\n     let v = DVec();\n     return SmallIntMap_(@{v: v});\n }\n@@ -29,7 +29,7 @@ fn mk<T: copy>() -> SmallIntMap<T> {\n  * the specified key then the original value is replaced.\n  */\n #[inline(always)]\n-fn insert<T: copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n+fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n     //io::println(fmt!(\"%?\", key));\n     self.v.grow_set_elt(key, None, Some(val));\n }\n@@ -38,7 +38,7 @@ fn insert<T: copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n  * Get the value for the specified key. If the key does not exist\n  * in the map then returns none\n  */\n-pure fn find<T: copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n+pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n     if key < self.v.len() { return self.v.get_elt(key); }\n     return None::<T>;\n }\n@@ -50,7 +50,7 @@ pure fn find<T: copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n  *\n  * If the key does not exist in the map\n  */\n-pure fn get<T: copy>(self: SmallIntMap<T>, key: uint) -> T {\n+pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n     match find(self, key) {\n       None => {\n         error!(\"smallintmap::get(): key not present\");\n@@ -61,12 +61,12 @@ pure fn get<T: copy>(self: SmallIntMap<T>, key: uint) -> T {\n }\n \n /// Returns true if the map contains a value for the specified key\n-fn contains_key<T: copy>(self: SmallIntMap<T>, key: uint) -> bool {\n+fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n     return !option::is_none(find(self, key));\n }\n \n /// Implements the map::map interface for smallintmap\n-impl<V: copy> SmallIntMap<V>: map::map<uint, V> {\n+impl<V: Copy> SmallIntMap<V>: map::map<uint, V> {\n     pure fn size() -> uint {\n         let mut sz = 0u;\n         for self.v.each |item| {\n@@ -137,7 +137,7 @@ impl<V: copy> SmallIntMap<V>: map::map<uint, V> {\n     }\n }\n \n-impl<V: copy> SmallIntMap<V>: ops::Index<uint, V> {\n+impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n     pure fn index(&&key: uint) -> V {\n         unchecked {\n             get(self, key)\n@@ -146,6 +146,6 @@ impl<V: copy> SmallIntMap<V>: ops::Index<uint, V> {\n }\n \n /// Cast the given smallintmap to a map::map\n-fn as_map<V: copy>(s: SmallIntMap<V>) -> map::map<uint, V> {\n+fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::map<uint, V> {\n     s as map::map::<uint, V>\n }"}, {"sha": "488ae16c751f30cb0b44a758261a32557b4efb13", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -19,12 +19,12 @@ type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-fn merge_sort<T: copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n+fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n     type Slice = (uint, uint);\n \n     return merge_sort_(le, v, (0u, len(v)));\n \n-    fn merge_sort_<T: copy>(le: Le<T>, v: &[const T], slice: Slice)\n+    fn merge_sort_<T: Copy>(le: Le<T>, v: &[const T], slice: Slice)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -39,7 +39,7 @@ fn merge_sort<T: copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n         return merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n     }\n \n-    fn merge<T: copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n+    fn merge<T: Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n         let mut rs = ~[];\n         vec::reserve(rs, len(a) + len(b));\n         let a_len = len(a);\n@@ -58,7 +58,7 @@ fn merge_sort<T: copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n     }\n }\n \n-fn part<T: copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n+fn part<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n                 right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -75,7 +75,7 @@ fn part<T: copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n+fn qsort<T: Copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -94,12 +94,12 @@ fn qsort<T: copy>(compare_func: Le<T>, arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-fn quick_sort<T: copy>(compare_func: Le<T>, arr: &[mut T]) {\n+fn quick_sort<T: Copy>(compare_func: Le<T>, arr: &[mut T]) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n-fn qsort3<T: copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n+fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -156,7 +156,7 @@ fn qsort3<T: copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-fn quick_sort3<T: copy Ord Eq>(arr: &[mut T]) {\n+fn quick_sort3<T: Copy Ord Eq>(arr: &[mut T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n@@ -165,7 +165,7 @@ trait Sort {\n     fn qsort(self);\n }\n \n-impl<T: copy Ord Eq> &[mut T] : Sort {\n+impl<T: Copy Ord Eq> &[mut T] : Sort {\n     fn qsort(self) { quick_sort3(self); }\n }\n "}, {"sha": "986a6e0522577a10feb084c816ab4eb75739003a", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -70,10 +70,10 @@ struct SemInner<Q> {\n     blocked:   Q\n }\n #[doc(hidden)]\n-enum Sem<Q: send> = Exclusive<SemInner<Q>>;\n+enum Sem<Q: Send> = Exclusive<SemInner<Q>>;\n \n #[doc(hidden)]\n-fn new_sem<Q: send>(count: int, +q: Q) -> Sem<Q> {\n+fn new_sem<Q: Send>(count: int, +q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n         mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n@@ -88,7 +88,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-impl<Q: send> &Sem<Q> {\n+impl<Q: Send> &Sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = None;\n         unsafe {"}, {"sha": "bda489c3ba7eef283f23f973ff8257533753e7af", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -26,7 +26,7 @@ export delayed_send, sleep, recv_timeout;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-fn delayed_send<T: copy send>(iotask: IoTask,\n+fn delayed_send<T: Copy Send>(iotask: IoTask,\n                               msecs: uint, ch: comm::Chan<T>, +val: T) {\n         unsafe {\n             let timer_done_po = core::comm::Port::<()>();\n@@ -102,7 +102,7 @@ fn sleep(iotask: IoTask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `some(T)`. If not, then `none` will be returned.\n  */\n-fn recv_timeout<T: copy send>(iotask: IoTask,\n+fn recv_timeout<T: Copy Send>(iotask: IoTask,\n                               msecs: uint,\n                               wait_po: comm::Port<T>) -> Option<T> {\n     let timeout_po = comm::Port::<()>();"}, {"sha": "a43821a0d37a09b4321904d356c334dffd8bc4a0", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -32,7 +32,7 @@ enum TreeNode<K, V> = {\n fn TreeMap<K, V>() -> TreeMap<K, V> { @mut None }\n \n /// Insert a value into the map\n-fn insert<K: copy Eq Ord, V: copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n+fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n     match copy *m {\n       None => {\n         *m = Some(@TreeNode({key: k,\n@@ -54,7 +54,7 @@ fn insert<K: copy Eq Ord, V: copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n }\n \n /// Find a value based on the key\n-fn find<K: copy Eq Ord, V: copy>(m: &const TreeEdge<K, V>, +k: K)\n+fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, +k: K)\n                               -> Option<V> {\n     match copy *m {\n       None => None,\n@@ -73,7 +73,7 @@ fn find<K: copy Eq Ord, V: copy>(m: &const TreeEdge<K, V>, +k: K)\n }\n \n /// Visit all pairs in the map in order.\n-fn traverse<K, V: copy>(m: &const TreeEdge<K, V>, f: fn(K, V)) {\n+fn traverse<K, V: Copy>(m: &const TreeEdge<K, V>, f: fn(K, V)) {\n     match copy *m {\n       None => (),\n       Some(node) => {"}, {"sha": "474f0ede1091a01c790d0b69fbc0c3b1455fd55a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -259,7 +259,7 @@ impl def_id : core::to_bytes::IterBytes {\n     }\n }\n \n-fn new_def_hash<V: copy>() -> std::map::hashmap<ast::def_id, V> {\n+fn new_def_hash<V: Copy>() -> std::map::hashmap<ast::def_id, V> {\n     return std::map::hashmap::<ast::def_id, V>();\n }\n "}, {"sha": "66553162b252054e84741d0d8415286eedbd0a58", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -271,7 +271,7 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n     }\n }\n \n-fn expect<T: copy>(diag: span_handler,\n+fn expect<T: Copy>(diag: span_handler,\n                    opt: Option<T>, msg: fn() -> ~str) -> T {\n     match opt {\n        Some(t) => t,"}, {"sha": "bb5af8402dfe4cd17b5c2579989cca3ad6943809", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -88,7 +88,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n     }\n }\n \n-fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n+fn option_flatten_map<T: Copy, U: Copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n    Option<~[U]> {\n     let mut res = ~[];\n     for v.each |elem| {"}, {"sha": "478288ba4cd44f6a2d71fd3a4570c3d587647063", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -41,21 +41,21 @@ trait parser_common {\n     fn check_restricted_keywords();\n     fn check_restricted_keywords_(w: ~str);\n     fn expect_gt();\n-    fn parse_seq_to_before_gt<T: copy>(sep: Option<token::token>,\n+    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::token>,\n                                        f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_to_gt<T: copy>(sep: Option<token::token>,\n+    fn parse_seq_to_gt<T: Copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_lt_gt<T: copy>(sep: Option<token::token>,\n+    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> spanned<~[T]>;\n-    fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n+    fn parse_seq_to_end<T: Copy>(ket: token::token, sep: seq_sep,\n                                  f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_to_before_end<T: copy>(ket: token::token, sep: seq_sep,\n+    fn parse_seq_to_before_end<T: Copy>(ket: token::token, sep: seq_sep,\n                                         f: fn(parser) -> T) -> ~[T];\n-    fn parse_unspanned_seq<T: copy>(bra: token::token,\n+    fn parse_unspanned_seq<T: Copy>(bra: token::token,\n                                     ket: token::token,\n                                     sep: seq_sep,\n                                     f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n+    fn parse_seq<T: Copy>(bra: token::token, ket: token::token, sep: seq_sep,\n                           f: fn(parser) -> T) -> spanned<~[T]>;\n }\n \n@@ -198,7 +198,7 @@ impl parser: parser_common {\n         }\n     }\n \n-    fn parse_seq_to_before_gt<T: copy>(sep: Option<token::token>,\n+    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::token>,\n                                        f: fn(parser) -> T) -> ~[T] {\n         let mut first = true;\n         let mut v = ~[];\n@@ -217,15 +217,15 @@ impl parser: parser_common {\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T: copy>(sep: Option<token::token>,\n+    fn parse_seq_to_gt<T: Copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n \n         return v;\n     }\n \n-    fn parse_seq_lt_gt<T: copy>(sep: Option<token::token>,\n+    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::token>,\n                                 f: fn(parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n@@ -235,15 +235,15 @@ impl parser: parser_common {\n         return spanned(lo, hi, result);\n     }\n \n-    fn parse_seq_to_end<T: copy>(ket: token::token, sep: seq_sep,\n+    fn parse_seq_to_end<T: Copy>(ket: token::token, sep: seq_sep,\n                                  f: fn(parser) -> T) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         return val;\n     }\n \n \n-    fn parse_seq_to_before_end<T: copy>(ket: token::token, sep: seq_sep,\n+    fn parse_seq_to_before_end<T: Copy>(ket: token::token, sep: seq_sep,\n                                         f: fn(parser) -> T) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -261,7 +261,7 @@ impl parser: parser_common {\n         return v;\n     }\n \n-    fn parse_unspanned_seq<T: copy>(bra: token::token,\n+    fn parse_unspanned_seq<T: Copy>(bra: token::token,\n                                     ket: token::token,\n                                     sep: seq_sep,\n                                     f: fn(parser) -> T) -> ~[T] {\n@@ -273,7 +273,7 @@ impl parser: parser_common {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T: copy>(bra: token::token, ket: token::token, sep: seq_sep,\n+    fn parse_seq<T: Copy>(bra: token::token, ket: token::token, sep: seq_sep,\n                           f: fn(parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);"}, {"sha": "a38cc701dc3d96a7c605b5c7876e78816f688a3e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2278,15 +2278,7 @@ struct parser {\n         let mut bounds = ~[];\n         if self.eat(token::COLON) {\n             while is_ident(self.token) {\n-                if self.eat_keyword(~\"send\") {\n-                    push(bounds, bound_send); }\n-                else if self.eat_keyword(~\"copy\") {\n-                    push(bounds, bound_copy) }\n-                else if self.eat_keyword(~\"const\") {\n-                    push(bounds, bound_const);\n-                } else if self.eat_keyword(~\"owned\") {\n-                    push(bounds, bound_owned);\n-                } else if is_ident(self.token) {\n+                if is_ident(self.token) {\n                     // XXX: temporary until kinds become traits\n                     let maybe_bound = match self.token {\n                       token::IDENT(sid, _) => {"}, {"sha": "cd7f75b15be804cfac440c3d8de1d4d00a770149", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -386,7 +386,7 @@ fn contextual_keyword_table() -> hashmap<~str, ()> {\n         ~\"else\",\n         ~\"move\",\n         ~\"priv\", ~\"pub\",\n-        ~\"self\", ~\"send\", ~\"static\",\n+        ~\"self\", ~\"static\",\n         ~\"use\"\n     ];\n     for keys.each |word| {\n@@ -421,7 +421,6 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n         ~\"if\", ~\"impl\", ~\"import\",\n         ~\"let\", ~\"log\", ~\"loop\",\n         ~\"match\", ~\"mod\", ~\"move\", ~\"mut\",\n-        ~\"owned\",\n         ~\"pure\",\n         ~\"ref\", ~\"return\",\n         ~\"struct\","}, {"sha": "942963797cb3dfd1f06297da60ec2d927a8c8796", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1658,10 +1658,10 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n         for vec::each(*bounds) |bound| {\n             nbsp(s);\n             match bound {\n-              ast::bound_copy => word(s.s, ~\"copy\"),\n-              ast::bound_send => word(s.s, ~\"send\"),\n-              ast::bound_const => word(s.s, ~\"const\"),\n-              ast::bound_owned => word(s.s, ~\"owned\"),\n+              ast::bound_copy => word(s.s, ~\"Copy\"),\n+              ast::bound_send => word(s.s, ~\"Send\"),\n+              ast::bound_const => word(s.s, ~\"Const\"),\n+              ast::bound_owned => word(s.s, ~\"Owned\"),\n               ast::bound_trait(t) => print_type(s, t)\n             }\n         }"}, {"sha": "ac2af21d087b0019bc628782d4d1639f45f5df7d", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -8,33 +8,33 @@ use cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n-type hash_interner<T: const> =\n+type hash_interner<T: Const> =\n     {map: hashmap<T, uint>,\n      vect: DVec<T>};\n \n-fn mk<T:Eq IterBytes Hash const copy>() -> interner<T> {\n+fn mk<T:Eq IterBytes Hash Const Copy>() -> interner<T> {\n     let m = map::hashmap::<T, uint>();\n     let hi: hash_interner<T> =\n         {map: m, vect: DVec()};\n     return hi as interner::<T>;\n }\n \n-fn mk_prefill<T:Eq IterBytes Hash const copy>(init: ~[T]) -> interner<T> {\n+fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: ~[T]) -> interner<T> {\n     let rv = mk();\n     for init.each() |v| { rv.intern(v); }\n     return rv;\n }\n \n \n /* when traits can extend traits, we should extend index<uint,T> to get [] */\n-trait interner<T:Eq IterBytes Hash const copy> {\n+trait interner<T:Eq IterBytes Hash Const Copy> {\n     fn intern(T) -> uint;\n     fn gensym(T) -> uint;\n     pure fn get(uint) -> T;\n     fn len() -> uint;\n }\n \n-impl <T:Eq IterBytes Hash const copy> hash_interner<T>: interner<T> {\n+impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: interner<T> {\n     fn intern(val: T) -> uint {\n         match self.map.find(val) {\n           Some(idx) => return idx,"}, {"sha": "0665c73137c0d938348104a15c981eddce2b0855", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -271,7 +271,7 @@ fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-fn expect<T: copy>(sess: session, opt: Option<T>, msg: fn() -> ~str) -> T {\n+fn expect<T: Copy>(sess: session, opt: Option<T>, msg: fn() -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "f198a2ca79dc3b5bfa00dc69c83d0cfc1025a542", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -22,7 +22,7 @@ fn use_core(crate: @ast::crate) -> bool {\n fn inject_libcore_ref(sess: session,\n                       crate: @ast::crate) -> @ast::crate {\n \n-    fn spanned<T: copy>(x: T) -> @ast::spanned<T> {\n+    fn spanned<T: Copy>(x: T) -> @ast::spanned<T> {\n         return @{node: x,\n             span: dummy_sp()};\n     }"}, {"sha": "5ac62379e763c0515def528b4ecfbc4ed7e8a88b", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -212,7 +212,7 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     return @item;\n }\n \n-fn nospan<T: copy>(t: T) -> ast::spanned<T> {\n+fn nospan<T: Copy>(t: T) -> ast::spanned<T> {\n     return {node: t, span: dummy_sp()};\n }\n "}, {"sha": "560dc384299aafd1c696087d28050828b496ed20", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -866,7 +866,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n \n // Path and definition ID indexing\n \n-fn create_index<T: copy>(index: ~[entry<T>], hash_fn: fn@(T) -> uint) ->\n+fn create_index<T: Copy>(index: ~[entry<T>], hash_fn: fn@(T) -> uint) ->\n    ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n     for uint::range(0u, 256u) |_i| { vec::push(buckets, @mut ~[]); };"}, {"sha": "0384225de1215385f9d20901c3732fa73605f811", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -67,7 +67,7 @@ fn mk_filesearch(maybe_sysroot: Option<Path>,\n      target_triple: str::from_slice(target_triple)} as filesearch\n }\n \n-fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> Option<T> {\n+fn search<T: Copy>(filesearch: filesearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());"}, {"sha": "1286a95aa02a92fdb297c971e1dc8daf32743fd8", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -396,7 +396,7 @@ type req_maps = {\n     pure_map: hashmap<ast::node_id, bckerr>\n };\n \n-fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n+fn save_and_restore<T:Copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n     let old_save_and_restore_t = save_and_restore_t;\n     let u <- f();\n     save_and_restore_t = old_save_and_restore_t;"}, {"sha": "94786aa8a8928d4416e4f1149154c9aa1c8b1e01", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -308,7 +308,7 @@ fn Atom(n: uint) -> Atom {\n }\n \n /// Creates a hash table of atoms.\n-fn atom_hashmap<V:copy>() -> hashmap<Atom,V> {\n+fn atom_hashmap<V:Copy>() -> hashmap<Atom,V> {\n   hashmap::<Atom,V>()\n }\n "}, {"sha": "056d3598a32f9bca5ec6c589ed1531cb8024d79e", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -129,7 +129,7 @@ enum debug_metadata {\n     retval_metadata(@metadata<retval_md>),\n }\n \n-fn cast_safely<T: copy, U>(val: T) -> U unsafe {\n+fn cast_safely<T: Copy, U>(val: T) -> U unsafe {\n     let val2 = val;\n     return unsafe::transmute(val2);\n }\n@@ -147,7 +147,7 @@ fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {\n     }\n }\n \n-fn cached_metadata<T: copy>(cache: metadata_cache, mdtag: int,\n+fn cached_metadata<T: Copy>(cache: metadata_cache, mdtag: int,\n                            eq: fn(md: T) -> bool) -> Option<T> unsafe {\n     if cache.contains_key(mdtag) {\n         let items = cache.get(mdtag);"}, {"sha": "d65b0e1978c14d01655b562a4a5df13f68bdde47", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -58,7 +58,7 @@ fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n \n-fn new_nominal_id_hash<T: copy>() -> hashmap<nominal_id, T> {\n+fn new_nominal_id_hash<T: Copy>() -> hashmap<nominal_id, T> {\n     return hashmap();\n }\n "}, {"sha": "e6476b57e70d4f501ad1da5a0a81272bb17e223c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -799,7 +799,7 @@ fn mk_rcache() -> creader_cache {\n     return map::hashmap();\n }\n \n-fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n+fn new_ty_hash<V: Copy>() -> map::hashmap<t, V> {\n     map::hashmap()\n }\n \n@@ -2568,7 +2568,7 @@ pure fn hash_bound_region(br: &bound_region) -> uint {\n     }\n }\n \n-fn br_hashmap<V:copy>() -> hashmap<bound_region, V> {\n+fn br_hashmap<V:Copy>() -> hashmap<bound_region, V> {\n     map::hashmap()\n }\n \n@@ -3081,7 +3081,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n \n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n-fn canon<T:copy>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n+fn canon<T:Copy>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n                  +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n       ast::infer(id) => match tbl.find(id) {"}, {"sha": "2ac872117e3c4318f083e4d5b11c1e0a7a0c1510", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -69,7 +69,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n     }\n }\n \n-fn ast_region_to_region<AC: ast_conv, RS: region_scope copy owned>(\n+fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n \n     let res = match a_r.node {\n@@ -80,7 +80,7 @@ fn ast_region_to_region<AC: ast_conv, RS: region_scope copy owned>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n+fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS, did: ast::def_id,\n     path: @ast::path) -> ty_param_substs_and_ty {\n \n@@ -129,7 +129,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     {substs: substs, ty: ty::subst(tcx, &substs, decl_ty)}\n }\n \n-fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n+fn ast_path_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC,\n     rscope: RS,\n     did: ast::def_id,\n@@ -152,10 +152,10 @@ const NO_TPS: uint = 2u;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n+fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy owned>(\n+    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope Copy Owned>(\n         self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n \n         return {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n@@ -164,7 +164,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle function sigils and first-class trait types.\n-    fn mk_maybe_vstore<AC: ast_conv, RS: region_scope copy owned>(\n+    fn mk_maybe_vstore<AC: ast_conv, RS: region_scope Copy Owned>(\n         self: AC, rscope: RS, a_seq_ty: ast::mt, vst: ty::vstore,\n         span: span, constr: fn(ty::mt) -> ty::t) -> ty::t {\n \n@@ -400,7 +400,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n     return typ;\n }\n \n-fn ty_of_arg<AC: ast_conv, RS: region_scope copy owned>(\n+fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS, a: ast::arg,\n     expected_ty: Option<ty::arg>) -> ty::arg {\n \n@@ -445,7 +445,7 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope copy owned>(\n     {mode: mode, ty: ty}\n }\n \n-fn ast_proto_to_proto<AC: ast_conv, RS: region_scope copy owned>(\n+fn ast_proto_to_proto<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS, span: span, ast_proto: ast::proto) -> ty::fn_proto {\n     match ast_proto {\n         ast::proto_bare =>\n@@ -465,7 +465,7 @@ fn ast_proto_to_proto<AC: ast_conv, RS: region_scope copy owned>(\n type expected_tys = Option<{inputs: ~[ty::arg],\n                             output: ty::t}>;\n \n-fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n+fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Owned>(\n     self: AC, rscope: RS,\n     ast_proto: ast::proto,\n     purity: ast::purity,"}, {"sha": "f63f6f2e1258984a98bc4d5985979b8c42cc29bb", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1203,7 +1203,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // through the `unpack` function.  It there is no expected type or\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n-    fn unpack_expected<O: copy>(fcx: @fn_ctxt, expected: Option<ty::t>,\n+    fn unpack_expected<O: Copy>(fcx: @fn_ctxt, expected: Option<ty::t>,\n                                 unpack: fn(ty::sty) -> Option<O>)\n         -> Option<O> {\n         match expected {"}, {"sha": "0a06e55472460ed0e7fb73ae7eaf118e2aa21b22", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -75,7 +75,7 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n }\n \n impl @crate_ctxt {\n-    fn to_ty<RS: region_scope copy owned>(\n+    fn to_ty<RS: region_scope Copy Owned>(\n         rs: RS, ast_ty: @ast::ty) -> ty::t {\n \n         ast_ty_to_ty(self, rs, ast_ty)"}, {"sha": "2aef5ff6b5bae571a7cb2694f430f1f11535416a", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -298,8 +298,8 @@ export assignment;\n export root, to_str;\n export int_ty_set_all;\n \n-type bound<T:copy> = Option<T>;\n-type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n+type bound<T:Copy> = Option<T>;\n+type bounds<T:Copy> = {lb: bound<T>, ub: bound<T>};\n \n type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n type ures = cres<()>; // \"unify result\"\n@@ -348,7 +348,7 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n     }\n }\n \n-fn new_vals_and_bindings<V:copy, T:copy>() -> vals_and_bindings<V, T> {\n+fn new_vals_and_bindings<V:Copy, T:Copy>() -> vals_and_bindings<V, T> {\n     vals_and_bindings {\n         vals: smallintmap::mk(),\n         mut bindings: ~[]\n@@ -458,12 +458,12 @@ fn resolve_borrowings(cx: infer_ctxt) {\n */\n \n trait then {\n-    fn then<T:copy>(f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl ures: then {\n-    fn then<T:copy>(f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n@@ -474,7 +474,7 @@ trait cres_helpers<T> {\n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n }\n \n-impl<T:copy Eq> cres<T>: cres_helpers<T> {\n+impl<T:Copy Eq> cres<T>: cres_helpers<T> {\n     fn to_ures() -> ures {\n         match self {\n           Ok(_v) => Ok(()),\n@@ -497,7 +497,7 @@ fn uok() -> ures {\n     Ok(())\n }\n \n-fn rollback_to<V:copy vid, T:copy>(\n+fn rollback_to<V:Copy vid, T:Copy>(\n     vb: &vals_and_bindings<V, T>, len: uint) {\n \n     while vb.bindings.len() != len {"}, {"sha": "7acfdcac424de47b23dba14ca9d8ceaf179c8eaa", "filename": "src/rustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -23,7 +23,7 @@ impl ty::region: to_str {\n     }\n }\n \n-impl<V:copy to_str> bound<V>: to_str {\n+impl<V:Copy to_str> bound<V>: to_str {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n           Some(v) => v.to_str(cx),\n@@ -32,7 +32,7 @@ impl<V:copy to_str> bound<V>: to_str {\n     }\n }\n \n-impl<T:copy to_str> bounds<T>: to_str {\n+impl<T:Copy to_str> bounds<T>: to_str {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         fmt!(\"{%s <: %s}\",\n              self.lb.to_str(cx),\n@@ -48,7 +48,7 @@ impl int_ty_set: to_str {\n     }\n }\n \n-impl<V:copy vid, T:copy to_str> var_value<V, T>: to_str {\n+impl<V:Copy vid, T:Copy to_str> var_value<V, T>: to_str {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n           redirect(vid) => fmt!(\"redirect(%s)\", vid.to_str()),"}, {"sha": "2793d0e4f5ad126cd30f89394389af140ff497de", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,24 +3,24 @@ use integral::*;\n use to_str::to_str;\n use std::smallintmap::SmallIntMap;\n \n-enum var_value<V:copy, T:copy> {\n+enum var_value<V:Copy, T:Copy> {\n     redirect(V),\n     root(T, uint),\n }\n \n-struct vals_and_bindings<V:copy, T:copy> {\n+struct vals_and_bindings<V:Copy, T:Copy> {\n     vals: SmallIntMap<var_value<V, T>>,\n     mut bindings: ~[(V, var_value<V, T>)],\n }\n \n-struct node<V:copy, T:copy> {\n+struct node<V:Copy, T:Copy> {\n     root: V,\n     possible_types: T,\n     rank: uint,\n }\n \n impl infer_ctxt {\n-    fn get<V:copy vid, T:copy>(\n+    fn get<V:Copy vid, T:Copy>(\n         vb: &vals_and_bindings<V, T>, vid: V) -> node<V, T> {\n \n         let vid_u = vid.to_uint();\n@@ -46,7 +46,7 @@ impl infer_ctxt {\n         }\n     }\n \n-    fn set<V:copy vid, T:copy to_str>(\n+    fn set<V:Copy vid, T:Copy to_str>(\n         vb: &vals_and_bindings<V, T>, vid: V,\n         +new_v: var_value<V, T>) {\n "}, {"sha": "0224d6933a7a8dd53b04f26240d20cbb54d35e14", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -46,7 +46,7 @@ fn bound_self_region(rp: Option<ty::region_variance>) -> Option<ty::region> {\n }\n \n enum anon_rscope = {anon: ty::region, base: region_scope};\n-fn in_anon_rscope<RS: region_scope copy owned>(self: RS, r: ty::region)\n+fn in_anon_rscope<RS: region_scope Copy Owned>(self: RS, r: ty::region)\n     -> @anon_rscope {\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n@@ -63,7 +63,7 @@ struct binding_rscope {\n     base: region_scope,\n     mut anon_bindings: uint,\n }\n-fn in_binding_rscope<RS: region_scope copy owned>(self: RS)\n+fn in_binding_rscope<RS: region_scope Copy Owned>(self: RS)\n     -> @binding_rscope {\n     let base = self as region_scope;\n     @binding_rscope { base: base, anon_bindings: 0 }"}, {"sha": "385f76873b36d3ae660927fb80c53fc637a0587e", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -88,7 +88,7 @@ fn act(po: comm::Port<msg>, source: ~str, parse: parser) {\n     }\n }\n \n-fn exec<T:send>(\n+fn exec<T:Send>(\n     srv: srv,\n     +f: fn~(ctxt: ctxt) -> T\n ) -> T {"}, {"sha": "6244d52c897a6ef9475fae248fac1ff6dc7b5d2b", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -89,7 +89,7 @@ fn fold_item(\n     }\n }\n \n-fn parse_item_attrs<T:send>(\n+fn parse_item_attrs<T:Send>(\n     srv: astsrv::srv,\n     id: doc::ast_id,\n     +parse_attrs: fn~(~[ast::attribute]) -> T) -> T {"}, {"sha": "a3a8fa5d6aebad5418d80ef336e6b066371536d4", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -50,7 +50,7 @@ type t<T> = {\n \n // This exists because fn types don't infer correctly as record\n // initializers, but they do as function arguments\n-fn mk_fold<T:copy>(\n+fn mk_fold<T:Copy>(\n     ctxt: T,\n     +fold_doc: fold_doc<T>,\n     +fold_crate: fold_crate<T>,\n@@ -80,7 +80,7 @@ fn mk_fold<T:copy>(\n     })\n }\n \n-fn default_any_fold<T:send copy>(ctxt: T) -> fold<T> {\n+fn default_any_fold<T:Send Copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -97,7 +97,7 @@ fn default_any_fold<T:send copy>(ctxt: T) -> fold<T> {\n     )\n }\n \n-fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n+fn default_seq_fold<T:Copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -114,7 +114,7 @@ fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n     )\n }\n \n-fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n+fn default_par_fold<T:Send Copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -163,7 +163,7 @@ fn default_seq_fold_item<T>(\n     doc\n }\n \n-fn default_any_fold_mod<T:send copy>(\n+fn default_any_fold_mod<T:Send Copy>(\n     fold: fold<T>,\n     doc: doc::moddoc\n ) -> doc::moddoc {\n@@ -189,7 +189,7 @@ fn default_seq_fold_mod<T>(\n     })\n }\n \n-fn default_par_fold_mod<T:send copy>(\n+fn default_par_fold_mod<T:Send Copy>(\n     fold: fold<T>,\n     doc: doc::moddoc\n ) -> doc::moddoc {\n@@ -202,7 +202,7 @@ fn default_par_fold_mod<T:send copy>(\n     })\n }\n \n-fn default_any_fold_nmod<T:send copy>(\n+fn default_any_fold_nmod<T:Send Copy>(\n     fold: fold<T>,\n     doc: doc::nmoddoc\n ) -> doc::nmoddoc {\n@@ -228,7 +228,7 @@ fn default_seq_fold_nmod<T>(\n     }\n }\n \n-fn default_par_fold_nmod<T:send copy>(\n+fn default_par_fold_nmod<T:Send Copy>(\n     fold: fold<T>,\n     doc: doc::nmoddoc\n ) -> doc::nmoddoc {"}, {"sha": "68d24ed28cbd6847cdce0805f3f884364d9f5c8a", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,7 +2,7 @@ export foo;\n \n use comm::*;\n \n-fn foo<T: send copy>(x: T) -> Port<T> {\n+fn foo<T: Send Copy>(x: T) -> Port<T> {\n     let p = Port();\n     let c = Chan(p);\n     do task::spawn() |copy c, copy x| {"}, {"sha": "6ead738753e504ff8ca67a445aba53df5dda96ef", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,11 +3,11 @@ use dvec::DVec;\n type entry<A,B> = {key: A, value: B};\n type alist<A,B> = { eq_fn: fn@(A,A) -> bool, data: DVec<entry<A,B>> };\n \n-fn alist_add<A: copy, B: copy>(lst: alist<A,B>, k: A, v: B) {\n+fn alist_add<A: Copy, B: Copy>(lst: alist<A,B>, k: A, v: B) {\n     lst.data.push({key:k, value:v});\n }\n \n-fn alist_get<A: copy, B: copy>(lst: alist<A,B>, k: A) -> B {\n+fn alist_get<A: Copy, B: Copy>(lst: alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n     for lst.data.each |entry| {\n         if eq_fn(entry.key, k) { return entry.value; }\n@@ -16,13 +16,13 @@ fn alist_get<A: copy, B: copy>(lst: alist<A,B>, k: A) -> B {\n }\n \n #[inline]\n-fn new_int_alist<B: copy>() -> alist<int, B> {\n+fn new_int_alist<B: Copy>() -> alist<int, B> {\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n     return {eq_fn: eq_int, data: DVec()};\n }\n \n #[inline]\n-fn new_int_alist_2<B: copy>() -> alist<int, B> {\n+fn new_int_alist_2<B: Copy>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n     return {eq_fn: eq_int, data: DVec()};"}, {"sha": "ef977507dd21d840271690b26e366b27530e7a2a", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -7,18 +7,18 @@ use std;\n \n export context;\n \n-struct arc_destruct<T:const> {\n+struct arc_destruct<T:Const> {\n   _data: int,\n   drop {}\n }\n \n-fn arc_destruct<T: const>(data: int) -> arc_destruct<T> {\n+fn arc_destruct<T: Const>(data: int) -> arc_destruct<T> {\n     arc_destruct {\n         _data: data\n     }\n }\n \n-fn arc<T: const>(_data: T) -> arc_destruct<T> {\n+fn arc<T: Const>(_data: T) -> arc_destruct<T> {\n     arc_destruct(0)\n }\n "}, {"sha": "4c3a6ea61210ffdb3aea6858c0bff165bc11486f", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -10,6 +10,6 @@ use std::map::hashmap;\n type header_map = hashmap<~str, @DVec<@~str>>;\n \n // the unused ty param is necessary so this gets monomorphized\n-fn request<T: copy>(req: header_map) {\n+fn request<T: Copy>(req: header_map) {\n   let _x = *(*req.get(~\"METHOD\"))[0u];\n }"}, {"sha": "cd011227c840580cd1484f5deb7b302b58e57905", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -25,7 +25,7 @@ impl bool: read {\n     }\n }\n \n-fn read<T: read copy>(s: ~str) -> T {\n+fn read<T: read Copy>(s: ~str) -> T {\n     match readMaybe(s) {\n       Some(x) => x,\n       _ => fail ~\"read failed!\""}, {"sha": "fed01e6a30e36db50364d08701a7f2fd5e8aa088", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -18,16 +18,16 @@ export recv;\n  * transmitted. If a port value is copied, both copies refer to the same\n  * port.  Ports may be associated with multiple `chan`s.\n  */\n-enum port<T: send> {\n+enum port<T: Send> {\n     port_t(@port_ptr<T>)\n }\n \n /// Constructs a port\n-fn port<T: send>() -> port<T> {\n+fn port<T: Send>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n \n-struct port_ptr<T:send> {\n+struct port_ptr<T:Send> {\n    po: *rust_port,\n    drop unsafe {\n     debug!(\"in the port_ptr destructor\");\n@@ -48,7 +48,7 @@ struct port_ptr<T:send> {\n   }\n }\n \n-fn port_ptr<T: send>(po: *rust_port) -> port_ptr<T> {\n+fn port_ptr<T: Send>(po: *rust_port) -> port_ptr<T> {\n     debug!(\"in the port_ptr constructor\");\n     port_ptr {\n         po: po\n@@ -59,11 +59,11 @@ fn port_ptr<T: send>(po: *rust_port) -> port_ptr<T> {\n  * Receive from a port.  If no data is available on the port then the\n  * task will block until data becomes available.\n  */\n-fn recv<T: send>(p: port<T>) -> T { recv_((**p).po) }\n+fn recv<T: Send>(p: port<T>) -> T { recv_((**p).po) }\n \n \n /// Receive on a raw port pointer\n-fn recv_<T: send>(p: *rust_port) -> T {\n+fn recv_<T: Send>(p: *rust_port) -> T {\n     let yield = 0u;\n     let yieldp = ptr::addr_of(yield);\n     let mut res;"}, {"sha": "5e0f9072f6cb64f6a0ae108a8666ec51209a17b0", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -64,7 +64,7 @@ macro_rules! follow (\n     )\n )\n \n-fn switch<T: send, Tb: send, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n+fn switch<T: Send, Tb: Send, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n                       f: fn(+Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }"}, {"sha": "5437de9643ab9651ae469c565c4dff9849cebb57", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -15,22 +15,22 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   pure fn le_by_val<TT: copy, UU: copy>(kv0: &(TT,UU),\n+   pure fn le_by_val<TT: Copy, UU: Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (_, v0) = *kv0;\n       let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   pure fn le_by_key<TT: copy, UU: copy>(kv0: &(TT,UU),\n+   pure fn le_by_key<TT: Copy, UU: Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (k0, _) = *kv0;\n       let (k1, _) = *kv1;\n       return k0 <= k1;\n    }\n \n    // sort by key, then by value\n-   fn sortKV<TT: copy, UU: copy>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+   fn sortKV<TT: Copy, UU: Copy>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n       return sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n    }\n "}, {"sha": "5f907e55a1fc49843e5ac530b89aa7024dc19a0f", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -14,22 +14,22 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   pure fn le_by_val<TT: copy, UU: copy>(kv0: &(TT,UU),\n+   pure fn le_by_val<TT: Copy, UU: Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (_, v0) = *kv0;\n       let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   pure fn le_by_key<TT: copy, UU: copy>(kv0: &(TT,UU),\n+   pure fn le_by_key<TT: Copy, UU: Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (k0, _) = *kv0;\n       let (k1, _) = *kv1;\n       return k0 <= k1;\n    }\n \n    // sort by key, then by value\n-   fn sortKV<TT: copy, UU: copy>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+   fn sortKV<TT: Copy, UU: Copy>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n       return sort::merge_sort(le_by_val, sort::merge_sort(le_by_key, orig));\n    }\n "}, {"sha": "0469e7e40bf06678d228e953c1e5796149dfd3f8", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -39,9 +39,9 @@ trait hash_key {\n     pure fn eq(&&k: self) -> bool;\n }\n \n-fn mk_hash<K: const hash_key, V: copy>() -> map::hashmap<K, V> {\n-    pure fn hashfn<K: const hash_key>(k: &K) -> uint { k.hash() }\n-    pure fn hasheq<K: const hash_key>(k1: &K, k2: &K) -> bool { k1.eq(*k2) }\n+fn mk_hash<K: Const hash_key, V: Copy>() -> map::hashmap<K, V> {\n+    pure fn hashfn<K: Const hash_key>(k: &K) -> uint { k.hash() }\n+    pure fn hasheq<K: Const hash_key>(k1: &K, k2: &K) -> bool { k1.eq(*k2) }\n \n     map::hashmap(hashfn, hasheq)\n }\n@@ -125,35 +125,35 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<K: send, V: send> = fn(K, V);\n+    type putter<K: Send, V: Send> = fn(K, V);\n \n-    type mapper<K1: send, K2: send, V: send> = fn~(K1, putter<K2, V>);\n+    type mapper<K1: Send, K2: Send, V: Send> = fn~(K1, putter<K2, V>);\n \n-    type getter<V: send> = fn() -> Option<V>;\n+    type getter<V: Send> = fn() -> Option<V>;\n \n-    type reducer<K: copy send, V: copy send> = fn~(K, getter<V>);\n+    type reducer<K: Copy Send, V: Copy Send> = fn~(K, getter<V>);\n \n-    enum ctrl_proto<K: copy send, V: copy send> {\n+    enum ctrl_proto<K: Copy Send, V: Copy Send> {\n         find_reducer(K, Chan<Chan<reduce_proto<V>>>),\n         mapper_done\n     }\n \n \n     proto! ctrl_proto (\n-        open: send<K: copy send, V: copy send> {\n+        open: send<K: Copy Send, V: Copy Send> {\n             find_reducer(K) -> reducer_response<K, V>,\n             mapper_done -> !\n         }\n \n-        reducer_response: recv<K: copy send, V: copy send> {\n+        reducer_response: recv<K: Copy Send, V: Copy Send> {\n             reducer(Chan<reduce_proto<V>>) -> open<K, V>\n         }\n     )\n \n-    enum reduce_proto<V: copy send> { emit_val(V), done, addref, release }\n+    enum reduce_proto<V: Copy Send> { emit_val(V), done, addref, release }\n \n-    fn start_mappers<K1: copy send, K2: const copy send hash_key,\n-                     V: copy send>(\n+    fn start_mappers<K1: Copy Send, K2: Const Copy Send hash_key,\n+                     V: Copy Send>(\n         map: mapper<K1, K2, V>,\n         &ctrls: ~[ctrl_proto::server::open<K2, V>],\n         inputs: ~[K1])\n@@ -169,7 +169,7 @@ mod map_reduce {\n         return tasks;\n     }\n \n-    fn map_task<K1: copy send, K2: const copy send hash_key, V: copy send>(\n+    fn map_task<K1: Copy Send, K2: Const Copy Send hash_key, V: Copy Send>(\n         map: mapper<K1, K2, V>,\n         ctrl: box<ctrl_proto::client::open<K2, V>>,\n         input: K1)\n@@ -198,15 +198,15 @@ mod map_reduce {\n             send(c.get(), emit_val(val));\n         }\n \n-        fn finish<K: copy send, V: copy send>(_k: K, v: Chan<reduce_proto<V>>)\n+        fn finish<K: Copy Send, V: Copy Send>(_k: K, v: Chan<reduce_proto<V>>)\n         {\n             send(v, release);\n         }\n         for intermediates.each_value |v| { send(v, release) }\n         ctrl_proto::client::mapper_done(ctrl.unwrap());\n     }\n \n-    fn reduce_task<K: copy send, V: copy send>(\n+    fn reduce_task<K: Copy Send, V: Copy Send>(\n         reduce: reducer<K, V>, \n         key: K,\n         out: Chan<Chan<reduce_proto<V>>>)\n@@ -218,7 +218,7 @@ mod map_reduce {\n         let mut ref_count = 0;\n         let mut is_done = false;\n \n-        fn get<V: copy send>(p: Port<reduce_proto<V>>,\n+        fn get<V: Copy Send>(p: Port<reduce_proto<V>>,\n                              &ref_count: int, &is_done: bool)\n            -> Option<V> {\n             while !is_done || ref_count > 0 {\n@@ -241,7 +241,7 @@ mod map_reduce {\n         reduce(key, || get(p, ref_count, is_done) );\n     }\n \n-    fn map_reduce<K1: copy send, K2: const copy send hash_key, V: copy send>(\n+    fn map_reduce<K1: Copy Send, K2: Const Copy Send hash_key, V: Copy Send>(\n         map: mapper<K1, K2, V>,\n         reduce: reducer<K2, V>,\n         inputs: ~[K1])"}, {"sha": "8983d42a90bb9c568fe897fb516955e40b953f75", "filename": "src/test/compile-fail/bad-method-typaram-kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,11 +3,11 @@ fn foo<T>() {\n }\n \n trait bar {\n-    fn bar<T:copy>();\n+    fn bar<T:Copy>();\n }\n \n impl uint: bar {\n-    fn bar<T:copy>() {\n+    fn bar<T:Copy>() {\n     }\n }\n "}, {"sha": "487860c01b1f5f7cbf1bed2da41ea12d4351f202", "filename": "src/test/compile-fail/fn-variance-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ffn-variance-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ffn-variance-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn reproduce<T:copy>(t: T) -> fn@() -> T {\n+fn reproduce<T:Copy>(t: T) -> fn@() -> T {\n     fn@() -> T { t }\n }\n "}, {"sha": "576a9ba7675001604deb2035b528bca79ab34ad5", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn mk_identity<T:copy>() -> fn@(T) -> T {\n+fn mk_identity<T:Copy>() -> fn@(T) -> T {\n     fn@(t: T) -> T { t }\n }\n "}, {"sha": "682b856afd0b12379ff1d5a4fb66a33382d7be40", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -11,7 +11,7 @@ impl uint: to_opt {\n     }\n }\n \n-impl<T:copy> Option<T>: to_opt {\n+impl<T:Copy> Option<T>: to_opt {\n     fn to_option() -> Option<Option<T>> {\n         Some(self)\n     }"}, {"sha": "36cf99b321c73defde669ecbe3d64a6b2f32c937", "filename": "src/test/compile-fail/issue-2587-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2587-2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn foo<T: copy>(+_t: T) { fail; }\n+fn foo<T: Copy>(+_t: T) { fail; }\n \n fn bar<T>(+_t: T) { fail; }\n "}, {"sha": "5545c0b2a133d9e277ee0374cf94eae592dcd21e", "filename": "src/test/compile-fail/issue-2611-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -7,15 +7,15 @@ import iter;\n import iter::BaseIter;\n \n trait A {\n-  fn b<C:copy const, D>(x: C) -> C;\n+  fn b<C:Copy Const, D>(x: C) -> C;\n }\n \n struct E {\n  f: int\n }\n \n impl E: A {\n-  fn b<F:copy, G>(_x: F) -> F { fail } //~ ERROR in method `b`, type parameter 0 has 1 bound, but\n+  fn b<F:Copy, G>(_x: F) -> F { fail } //~ ERROR in method `b`, type parameter 0 has 1 bound, but\n }\n \n fn main() {}\n\\ No newline at end of file"}, {"sha": "22674c0659503153a13dc5ad071633b00accaaa0", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,15 +4,15 @@ import iter;\n import iter::BaseIter;\n \n trait A {\n-  fn b<C:copy, D>(x: C) -> C;\n+  fn b<C:Copy, D>(x: C) -> C;\n }\n \n struct E {\n  f: int\n }\n \n impl E: A {\n-  fn b<F:copy const, G>(_x: F) -> F { fail } //~ ERROR in method `b`, type parameter 0 has 2 bounds, but\n+  fn b<F:Copy Const, G>(_x: F) -> F { fail } //~ ERROR in method `b`, type parameter 0 has 2 bounds, but\n }\n \n fn main() {}\n\\ No newline at end of file"}, {"sha": "b01342282b22bb1a751253a05f8cff01d43e1e39", "filename": "src/test/compile-fail/issue-2611-5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@ import iter;\n import iter::BaseIter;\n \n trait A {\n-  fn b<C:copy, D>(x: C) -> C;\n+  fn b<C:Copy, D>(x: C) -> C;\n }\n \n struct E {\n@@ -13,7 +13,7 @@ struct E {\n \n impl E: A {\n   // n.b. The error message is awful -- see #3404\n-  fn b<F:copy, G>(_x: G) -> G { fail } //~ ERROR method `b` has an incompatible type\n+  fn b<F:Copy, G>(_x: G) -> G { fail } //~ ERROR method `b` has an incompatible type\n }\n \n fn main() {}\n\\ No newline at end of file"}, {"sha": "b857af4e2f36070b5feaf5e7e7c208c1033dd2e5", "filename": "src/test/compile-fail/issue-2718-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-struct send_packet<T: copy> {\n+struct send_packet<T: Copy> {\n   p: T\n }\n "}, {"sha": "78225ba15ecb5b22bbc3ba121dd9b2ba93462256", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,7 +1,7 @@\n mod stream {\n-    enum stream<T: send> { send(T, server::stream<T>), }\n+    enum stream<T: Send> { send(T, server::stream<T>), }\n     mod server {\n-        impl<T: send> stream<T> {\n+        impl<T: Send> stream<T> {\n             fn recv() -> extern fn(+stream<T>) -> stream::stream<T> {\n               // resolve really should report just one error here.\n               // Change the test case when it changes.\n@@ -14,7 +14,7 @@ mod stream {\n                 recv\n             }\n         }\n-        type stream<T: send> = pipes::RecvPacket<stream::stream<T>>;\n+        type stream<T: Send> = pipes::RecvPacket<stream::stream<T>>;\n     }\n }\n "}, {"sha": "c916bcba7c85cff79edbdee9b26c0c79a8adb6d9", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,10 +1,10 @@\n trait repeat<A> { fn get() -> A; }\n \n-impl<A:copy> @A: repeat<A> {\n+impl<A:Copy> @A: repeat<A> {\n     fn get() -> A { *self }\n }\n \n-fn repeater<A:copy>(v: @A) -> repeat<A> {\n+fn repeater<A:Copy>(v: @A) -> repeat<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n     v as repeat::<A> // No\n }"}, {"sha": "5b39d3e46511e44749379b9af3dce436097e30af", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -5,11 +5,11 @@ trait foo {\n     fn foo(i: &self/int) -> int;\n }\n \n-impl<T:copy> T: foo {\n+impl<T:Copy> T: foo {\n     fn foo(i: &self/int) -> int {*i}\n }\n \n-fn to_foo<T:copy>(t: T) {\n+fn to_foo<T:Copy>(t: T) {\n     // This version is ok because, although T may contain borrowed\n     // pointers, it never escapes the fn body.  We know this because\n     // the type of foo includes a region which will be resolved to\n@@ -19,13 +19,13 @@ fn to_foo<T:copy>(t: T) {\n     assert x.foo(v) == 3;\n }\n \n-fn to_foo_2<T:copy>(t: T) -> foo {\n+fn to_foo_2<T:Copy>(t: T) -> foo {\n     // Not OK---T may contain borrowed ptrs and it is going to escape\n     // as part of the returned foo value\n     {f:t} as foo //~ ERROR value may contain borrowed pointers; use `owned` bound\n }\n \n-fn to_foo_3<T:copy owned>(t: T) -> foo {\n+fn to_foo_3<T:Copy Owned>(t: T) -> foo {\n     // OK---T may escape as part of the returned foo value, but it is\n     // owned and hence does not contain borrowed ptrs\n     {f:t} as foo"}, {"sha": "ea57fe5a6cf934a10b54b148d785ef9ce2bfda0e", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,10 +1,10 @@\n trait foo { fn foo(); }\n \n-fn to_foo<T: copy foo>(t: T) -> foo {\n+fn to_foo<T: Copy foo>(t: T) -> foo {\n     t as foo //~ ERROR value may contain borrowed pointers; use `owned` bound\n }\n \n-fn to_foo2<T: copy foo owned>(t: T) -> foo {\n+fn to_foo2<T: Copy foo Owned>(t: T) -> foo {\n     t as foo\n }\n "}, {"sha": "3e6a2f2946db83b26494bccd367e78e35d001e28", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,8 +1,8 @@\n-fn copy1<T: copy>(t: T) -> fn@() -> T {\n+fn copy1<T: Copy>(t: T) -> fn@() -> T {\n     fn@() -> T { t } //~ ERROR value may contain borrowed pointers\n }\n \n-fn copy2<T: copy owned>(t: T) -> fn@() -> T {\n+fn copy2<T: Copy Owned>(t: T) -> fn@() -> T {\n     fn@() -> T { t }\n }\n "}, {"sha": "5447c88e56768bbf4f4db11f849fb0f2b4a613ce", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn send<T: send>(ch: _chan<T>, -data: T) {\n+fn send<T: Send>(ch: _chan<T>, -data: T) {\n     log(debug, ch);\n     log(debug, data);\n     fail;"}, {"sha": "d2cf08fc8471b6939a8d9c8f2475fd0da1715e4a", "filename": "src/test/compile-fail/non-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-const.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n // Test that various non const things are rejected.\n \n-fn foo<T: const>(_x: T) { }\n+fn foo<T: Const>(_x: T) { }\n \n struct r {\n   x:int,"}, {"sha": "bd65fa41fd56705066906984a34d1cb27f22c9d2", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -5,7 +5,7 @@\n \n use core;\n \n-fn last<T: copy>(v: ~[const T]) -> core::Option<T> {\n+fn last<T: Copy>(v: ~[const T]) -> core::Option<T> {\n     fail;\n }\n "}, {"sha": "b1525229658c3a19fade4de7509e6fdddd1333c6", "filename": "src/test/compile-fail/tps-invariant-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -7,7 +7,7 @@ enum box_impl<T> = {\n     mut f: T\n };\n \n-impl<T:copy> box_impl<T>: box_trait<T> {\n+impl<T:Copy> box_impl<T>: box_trait<T> {\n     fn get() -> T { return self.f; }\n     fn set(t: T) { self.f = t; }\n }"}, {"sha": "eea832c91a474957773bd6fe79f39d11c3ac367a", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn f<T: send>(_i: T) {\n+fn f<T: Send>(_i: T) {\n }\n \n fn main() {"}, {"sha": "c21e337af60e8efff2a25deb60723540c85a31cc", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn concat<T: copy>(v: ~[const ~[const T]]) -> ~[T] {\n+fn concat<T: Copy>(v: ~[const ~[const T]]) -> ~[T] {\n     let mut r = ~[];\n \n     // Earlier versions of our type checker accepted this:"}, {"sha": "a657514376569ed8ae8b37ddd4bb711c0cde6de1", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,8 +4,8 @@ fn test00_start(ch: chan_t<int>, message: int) { send(ch, message); }\n type task_id = int;\n type port_id = int;\n \n-enum chan_t<T: send> = {task: task_id, port: port_id};\n+enum chan_t<T: Send> = {task: task_id, port: port_id};\n \n-fn send<T: send>(ch: chan_t<T>, data: T) { fail; }\n+fn send<T: Send>(ch: chan_t<T>, data: T) { fail; }\n \n fn main() { fail ~\"quux\"; }"}, {"sha": "20620ac62e8e8a31fc19c5e05cf011efa0a21525", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,7 +3,7 @@\n use std;\n use std::arc;\n \n-enum e<T: const send> { e(arc::ARC<T>) }\n+enum e<T: Const Send> { e(arc::ARC<T>) }\n \n fn foo() -> e<int> {fail;}\n "}, {"sha": "44ce6e524cafedf2d3c982c982e11e28f3702ec3", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -5,7 +5,7 @@ use comm::Port;\n use comm::send;\n use comm::recv;\n \n-fn echo<T: send>(c: Chan<T>, oc: Chan<Chan<T>>) {\n+fn echo<T: Send>(c: Chan<T>, oc: Chan<Chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = Port::<T>();"}, {"sha": "23cc80233fe220c93c524f67457a1826c31a788d", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,7 +2,7 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n+fn f<A:Copy Owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n     fn@() -> (A, u16) { (a, b) }\n }\n "}, {"sha": "098c82b18d492580314d595cf5920d50d85ef828", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -8,12 +8,12 @@ type _rec<A> = {\n     mut rec: Option<@rec<A>>\n };\n \n-fn make_cycle<A:copy>(a: A) {\n+fn make_cycle<A:Copy>(a: A) {\n     let g: @rec<A> = @rec({val: a, mut rec: None});\n     g.rec = Some(g);\n }\n \n-fn f<A:send copy, B:send copy>(a: A, b: B) -> fn@() -> (A, B) {\n+fn f<A:Send Copy, B:Send Copy>(a: A, b: B) -> fn@() -> (A, B) {\n     fn@() -> (A, B) { (a, b) }\n }\n "}, {"sha": "941a20f85e07a02eeb34d5e9f330fa03d3279a44", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,7 +2,7 @@\n \n \n // -*- rust -*-\n-fn f<T: copy, U: copy>(x: T, y: U) -> {a: T, b: U} { return {a: x, b: y}; }\n+fn f<T: Copy, U: Copy>(x: T, y: U) -> {a: T, b: U} { return {a: x, b: y}; }\n \n fn main() {\n     log(debug, f({x: 3, y: 4, z: 5}, 4).a.x);"}, {"sha": "70e513a879d6598f454dc6f817e7c0fb901706fe", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn f<T: copy>(x: ~[T]) -> T { return x[0]; }\n+fn f<T: Copy>(x: ~[T]) -> T { return x[0]; }\n \n fn g(act: fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n "}, {"sha": "09f05d86d078d72e4d411d9aba8eead575aa074c", "filename": "src/test/run-pass/bounded-fn-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbounded-fn-type.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,7 +1,7 @@\n fn ignore<T>(_x: T) {}\n \n fn main() {\n-    let f: fn@:send() = ||();\n+    let f: fn@:Send() = ||();\n     ignore(f);\n }\n "}, {"sha": "27cb9846b3d9e5dfd923759498480e34e6878cb3", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,8 +1,8 @@\n \n \n-type box<T: copy> = {c: @T};\n+type box<T: Copy> = {c: @T};\n \n-fn unbox<T: copy>(b: box<T>) -> T { return *b.c; }\n+fn unbox<T: Copy>(b: box<T>) -> T { return *b.c; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "665ee3cfe25a82d8bfa83927e904cd6dd803f24e", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -14,7 +14,7 @@ impl cat_type : cmp::Eq {\n // for any int value that's less than the meows field\n \n // ok: T should be in scope when resolving the trait ref for map\n-struct cat<T: copy> : map<int, T> {\n+struct cat<T: Copy> : map<int, T> {\n   priv {\n     // Yes, you can have negative meows\n     mut meows : int,\n@@ -94,7 +94,7 @@ struct cat<T: copy> : map<int, T> {\n   fn clear() { }\n }\n \n-fn cat<T: copy>(in_x : int, in_y : int, in_name: T) -> cat<T> {\n+fn cat<T: Copy>(in_x : int, in_y : int, in_name: T) -> cat<T> {\n     cat {\n         meows: in_x,\n         how_hungry: in_y,"}, {"sha": "2ffd41229a5373f9dc7ace9e65bc6a6e139ad491", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,7 +3,7 @@\n use std;\n use std::map::{map, hashmap, int_hash};\n \n-class keys<K: copy, V: copy, M: copy map<K,V>>\n+class keys<K: Copy, V: Copy, M: Copy map<K,V>>\n     : iter::base_iter<K> {\n \n     let map: M;"}, {"sha": "83f92e7a72ddf70e96e42434adfeac665b160e5f", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -6,7 +6,7 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n+fn f<A:Copy Owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n     fn@() -> (A, u16) { (a, b) }\n }\n "}, {"sha": "9d0d33524ef29dad590c1aedf15b5a680a522caa", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,7 +2,7 @@\n // are const.\n \n \n-fn foo<T: copy const>(x: T) -> T { x }\n+fn foo<T: Copy Const>(x: T) -> T { x }\n \n fn main() {\n     foo(1);"}, {"sha": "ef0b2c2078d83b09623afa9b59350ac51cdd7a13", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n     let actual: T = match true { true => { expected }, _ => fail ~\"wat\" };\n     assert (eq(expected, actual));\n }"}, {"sha": "264f03ee2c3eb3bd72681a2c809c127e8e786e36", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<T: copy>(expected: ~T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = match true { true => { expected }, _ => fail ~\"wat\" };\n     assert (eq(expected, actual));\n }"}, {"sha": "e5c8d2acd874d240b6b7f05a7515b9d5cf5f68c2", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n     let actual: T = match true { true => expected, _ => fail ~\"wat\" };\n     assert (eq(expected, actual));\n }"}, {"sha": "d17d7db90384d03b803e93dcf7fd913d4fe039fc", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n   let actual: T = match true { true => { expected }, _ => fail ~\"wat\" };\n     assert (eq(expected, actual));\n }"}, {"sha": "8fc566d5843fa67d3cb31edb4658406e04676b69", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "0ccabb2c0814aca36a9a31cb4c9ebe2c983e7724", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<T: copy>(expected: ~T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "cda0148cfe8f157576c1ef1659ce9770d855a8a3", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "adb49f3142d5b0eb8d2e6c48418931f411312032", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -6,7 +6,7 @@\n // Tests for standalone blocks as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "c2d27cf696c8809b562013f658190e443fff1ea5", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -9,7 +9,7 @@ fn test_vec() {\n }\n \n fn test_generic() {\n-    fn f<T: copy>(t: T) -> T { t }\n+    fn f<T: Copy>(t: T) -> T { t }\n     assert (f(10) == 10);\n }\n "}, {"sha": "e5370db83d1d3f66b3f220f96cd751b1aaaabfcd", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "5d7730809d5f4e09ff85d8ad896eb0f041c7309f", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -6,7 +6,7 @@\n // Tests for if as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: copy>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<T: Copy>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "2c7ef7fb12556991403eec23db9d9c7b000c84e7", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,8 +1,8 @@\n-fn fix_help<A: owned, B: send>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A: Owned, B: Send>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     return f({|a|fix_help(f, a)}, x);\n }\n \n-fn fix<A: owned, B: send>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A: Owned, B: Send>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     return {|a|fix_help(f, a)};\n }\n "}, {"sha": "cc57ba6a9afd2bb2ff57655e6908a9514ade9e8b", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n // This is what the signature to spawn should look like with bare functions\n \n-fn spawn<T: send>(val: T, f: extern fn(T)) {\n+fn spawn<T: Send>(val: T, f: extern fn(T)) {\n     f(val);\n }\n "}, {"sha": "f140ad1b9941762cbc462e4c161cf7a46aa8730d", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<T: copy>(t: T) -> T { return t; }\n+fn id<T: Copy>(t: T) -> T { return t; }\n \n fn main() {\n     let expected = @100;"}, {"sha": "9d3ac09de7c0cd1b017e90861713b4dc83a9e9d6", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<T: copy send>(t: T) -> T { return t; }\n+fn id<T: Copy Send>(t: T) -> T { return t; }\n \n fn main() {\n     let expected = ~100;"}, {"sha": "fed97b99f8eab3025fc57e52ed9c5c97cde5e93e", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn box<T: copy>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { return @x; }\n+fn box<T: Copy>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { return @x; }\n \n fn main() {\n     let x: @{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "f190e72b648119041f7969f992933186c9f53de3", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,8 +1,8 @@\n \n \n-fn g<X: copy>(x: X) -> X { return x; }\n+fn g<X: Copy>(x: X) -> X { return x; }\n \n-fn f<T: copy>(t: T) -> {a: T, b: T} {\n+fn f<T: Copy>(t: T) -> {a: T, b: T} {\n     type pair = {a: T, b: T};\n \n     let x: pair = {a: t, b: t};"}, {"sha": "c6d16a4127cc1fa476ba2d8d575a0fd21e0f0543", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn f<T: copy>(t: T) { let t1: T = t; }\n+fn f<T: Copy>(t: T) { let t1: T = t; }\n \n fn main() { let x = {x: @10, y: @12}; f(x); }"}, {"sha": "ff2221aeefbb2dbc6a83a5ac9375b16f46b45890", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,8 +1,8 @@\n \n \n-type recbox<T: copy> = {x: @T};\n+type recbox<T: Copy> = {x: @T};\n \n-fn reclift<T: copy>(t: T) -> recbox<T> { return {x: @t}; }\n+fn reclift<T: Copy>(t: T) -> recbox<T> { return {x: @t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "61860d36b5e93972faf4cab3c27b08605ff41dfc", "filename": "src/test/run-pass/generic-exterior-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n-type recbox<T: copy> = {x: ~T};\n+type recbox<T: Copy> = {x: ~T};\n \n-fn reclift<T: copy>(t: T) -> recbox<T> { return {x: ~t}; }\n+fn reclift<T: Copy>(t: T) -> recbox<T> { return {x: ~t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "c7696259ec2e94e0f8a78f495f5f378c0ec0ff07", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,6 +4,6 @@\n // -*- rust -*-\n \n // Issue #45: infer type parameters in function applications\n-fn id<T: copy>(x: T) -> T { return x; }\n+fn id<T: Copy>(x: T) -> T { return x; }\n \n fn main() { let x: int = 42; let y: int = id(x); assert (x == y); }"}, {"sha": "81fbd307d2a87fcb2a90da9e4b544f47c1ef4858", "filename": "src/test/run-pass/generic-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n \n-fn f<T: copy>(x: ~T) -> ~T { return x; }\n+fn f<T: Copy>(x: ~T) -> ~T { return x; }\n \n fn main() { let x = f(~3); log(debug, *x); }"}, {"sha": "c7a38940caf70c791b780ed6108c804783385b08", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,7 +2,7 @@\n \n \n // -*- rust -*-\n-fn id<T: copy>(x: T) -> T { return x; }\n+fn id<T: Copy>(x: T) -> T { return x; }\n \n type triple = {x: int, y: int, z: int};\n "}, {"sha": "1d37565be315efa99df13d383c3a731e5390462a", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn get_third<T: copy>(t: (T, T, T)) -> T { let (_, _, x) = t; return x; }\n+fn get_third<T: Copy>(t: (T, T, T)) -> T { let (_, _, x) = t; return x; }\n \n fn main() {\n     log(debug, get_third((1, 2, 3)));"}, {"sha": "21daeac2ef7c30248e1217e9fa5485481abe120a", "filename": "src/test/run-pass/generic-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,5 +1,5 @@\n \n-fn box<T: copy>(x: {x: T, y: T, z: T}) -> ~{x: T, y: T, z: T} { return ~x; }\n+fn box<T: Copy>(x: {x: T, y: T, z: T}) -> ~{x: T, y: T, z: T} { return ~x; }\n \n fn main() {\n     let x: ~{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "f4d045bb44417a124a74f21c3cc41744f51948a5", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,19 +1,19 @@\n-trait clam<A: copy> {\n+trait clam<A: Copy> {\n   fn chowder(y: A);\n }\n-struct foo<A: copy> : clam<A> {\n+struct foo<A: Copy> : clam<A> {\n   x: A,\n   fn chowder(y: A) {\n   }\n }\n \n-fn foo<A: copy>(b: A) -> foo<A> {\n+fn foo<A: Copy>(b: A) -> foo<A> {\n     foo {\n         x: b\n     }\n }\n \n-fn f<A: copy>(x: clam<A>, a: A) {\n+fn f<A: Copy>(x: clam<A>, a: A) {\n   x.chowder(a);\n }\n "}, {"sha": "ef3752d5fa741772a7d38ea8101d91149fc71398", "filename": "src/test/run-pass/issue-2311-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,12 +1,12 @@\n-trait clam<A: copy> { }\n-struct foo<A: copy> {\n+trait clam<A: Copy> { }\n+struct foo<A: Copy> {\n     x: A,\n    fn bar<B,C:clam<A>>(c: C) -> B {\n      fail;\n    }\n }\n \n-fn foo<A: copy>(b: A) -> foo<A> {\n+fn foo<A: Copy>(b: A) -> foo<A> {\n     foo {\n         x: b\n     }"}, {"sha": "0b6502860204b2b571fdde4348c782648ebe097d", "filename": "src/test/run-pass/issue-2445-b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,16 +1,16 @@\n-struct c1<T: copy> {\n+struct c1<T: Copy> {\n     x: T,\n     fn f1(x: int) {\n     }\n }\n \n-fn c1<T: copy>(x: T) -> c1<T> {\n+fn c1<T: Copy>(x: T) -> c1<T> {\n     c1 {\n         x: x\n     }\n }\n \n-impl<T: copy> c1<T> {\n+impl<T: Copy> c1<T> {\n     fn f2(x: int) {\n     }\n }"}, {"sha": "ae6cdf34e4d329ff367cd3ab08fb4e197697536a", "filename": "src/test/run-pass/issue-2445.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2445.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,17 +1,17 @@\n use dvec::DVec;\n \n-struct c1<T: copy> {\n+struct c1<T: Copy> {\n     x: T,\n     fn f1(x: T) {}\n }\n \n-fn c1<T: copy>(x: T) -> c1<T> {\n+fn c1<T: Copy>(x: T) -> c1<T> {\n     c1 {\n         x: x\n     }\n }\n \n-impl<T: copy> c1<T> {\n+impl<T: Copy> c1<T> {\n     fn f2(x: T) {}\n }\n "}, {"sha": "496fe3a4798ee300ae7b6240095ff3d3dd52dd39", "filename": "src/test/run-pass/issue-2550.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2550.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -8,7 +8,7 @@ fn C(x: uint) -> C {\n     }\n }\n \n-fn f<T:copy>(_x: T) {\n+fn f<T:Copy>(_x: T) {\n }\n \n #[deny(non_implicitly_copyable_typarams)]"}, {"sha": "0d5c244abcbdbbb1ae055c792dea06179846eab9", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,11 +1,11 @@\n use iter::BaseIter;\n \n trait FlatMapToVec<A> {\n-  fn flat_map_to_vec<B:copy, IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B];\n+  fn flat_map_to_vec<B:Copy, IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B];\n }\n \n-impl<A:copy> BaseIter<A>: FlatMapToVec<A> {\n-   fn flat_map_to_vec<B:copy, IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B] {\n+impl<A:Copy> BaseIter<A>: FlatMapToVec<A> {\n+   fn flat_map_to_vec<B:Copy, IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B] {\n      iter::flat_map_to_vec(self, op)\n    }\n }"}, {"sha": "d878d3fcf4b63533197dd936ead360f92531dc9c", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -15,13 +15,13 @@ mod pipes {\n         pure fn ne(&&other: state) -> bool { !self.eq(other) }\n     }\n \n-    type packet<T: send> = {\n+    type packet<T: Send> = {\n         mut state: state,\n         mut blocked_task: Option<task::Task>,\n         mut payload: Option<T>\n     };\n \n-    fn packet<T: send>() -> *packet<T> unsafe {\n+    fn packet<T: Send>() -> *packet<T> unsafe {\n         let p: *packet<T> = unsafe::transmute(~{\n             mut state: empty,\n             mut blocked_task: None::<task::Task>,\n@@ -55,7 +55,7 @@ mod pipes {\n         }\n     }\n \n-    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+    fn send<T: Send>(-p: send_packet<T>, -payload: T) {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         assert (*p).payload.is_none();\n@@ -81,7 +81,7 @@ mod pipes {\n         }\n     }\n \n-    fn recv<T: send>(-p: recv_packet<T>) -> Option<T> {\n+    fn recv<T: Send>(-p: recv_packet<T>) -> Option<T> {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         loop {\n@@ -102,7 +102,7 @@ mod pipes {\n         }\n     }\n \n-    fn sender_terminate<T: send>(p: *packet<T>) {\n+    fn sender_terminate<T: Send>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n@@ -119,7 +119,7 @@ mod pipes {\n         }\n     }\n \n-    fn receiver_terminate<T: send>(p: *packet<T>) {\n+    fn receiver_terminate<T: Send>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n@@ -136,7 +136,7 @@ mod pipes {\n         }\n     }\n \n-    struct send_packet<T: send> {\n+    struct send_packet<T: Send> {\n         mut p: Option<*packet<T>>,\n         drop {\n             if self.p != None {\n@@ -152,13 +152,13 @@ mod pipes {\n         }\n     }\n \n-    fn send_packet<T: send>(p: *packet<T>) -> send_packet<T> {\n+    fn send_packet<T: Send>(p: *packet<T>) -> send_packet<T> {\n         send_packet {\n             p: Some(p)\n         }\n     }\n \n-    struct recv_packet<T: send> {\n+    struct recv_packet<T: Send> {\n         mut p: Option<*packet<T>>,\n         drop {\n             if self.p != None {\n@@ -174,13 +174,13 @@ mod pipes {\n         }\n     }\n \n-    fn recv_packet<T: send>(p: *packet<T>) -> recv_packet<T> {\n+    fn recv_packet<T: Send>(p: *packet<T>) -> recv_packet<T> {\n         recv_packet {\n             p: Some(p)\n         }\n     }\n \n-    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n+    fn entangle<T: Send>() -> (send_packet<T>, recv_packet<T>) {\n         let p = packet();\n         (send_packet(p), recv_packet(p))\n     }"}, {"sha": "30a806d165d087df23d95682db7a11a27f7fc312", "filename": "src/test/run-pass/issue-2734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2734.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,7 +1,7 @@\n trait hax { } \n impl <A> A: hax { } \n \n-fn perform_hax<T: owned>(x: @T) -> hax {\n+fn perform_hax<T: Owned>(x: @T) -> hax {\n     x as hax \n }\n "}, {"sha": "0c9795cc5c37246f59d43023de2e4cd65516995e", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,7 +1,7 @@\n trait hax { } \n impl <A> A: hax { } \n \n-fn perform_hax<T: owned>(x: @T) -> hax {\n+fn perform_hax<T: Owned>(x: @T) -> hax {\n     x as hax \n }\n "}, {"sha": "741235554acad1d5e6f850eb54398664fb342b09", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -45,7 +45,7 @@ fn square_from_char(c: char) -> square {\n     }\n }\n \n-fn read_board_grid<rdr: owned io::Reader>(+in: rdr) -> ~[~[square]] {\n+fn read_board_grid<rdr: Owned io::Reader>(+in: rdr) -> ~[~[square]] {\n     let in = in as io::Reader;\n     let mut grid = ~[];\n     for in.each_line |line| {"}, {"sha": "98cfaded04a985cd1c52cf1252ead72fc4a9ffc8", "filename": "src/test/run-pass/issue-2930.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2930.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,5 +1,5 @@\n proto! stream (\n-    stream:send<T:send> {\n+    stream:send<T:Send> {\n         send(T) -> stream<T>\n     }\n )"}, {"sha": "47d72c53e3bdb06cf619056fc36cf97d091f8838", "filename": "src/test/run-pass/issue-3149.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-3149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-3149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3149.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-pure fn Matrix4<T:copy Num>(m11: T, m12: T, m13: T, m14: T,\n+pure fn Matrix4<T:Copy Num>(m11: T, m12: T, m13: T, m14: T,\n                                      m21: T, m22: T, m23: T, m24: T,\n                                      m31: T, m32: T, m33: T, m34: T,\n                                      m41: T, m42: T, m43: T, m44: T)\n@@ -12,7 +12,7 @@ pure fn Matrix4<T:copy Num>(m11: T, m12: T, m13: T, m14: T,\n     }\n }\n \n-struct Matrix4<T:copy Num> {\n+struct Matrix4<T:Copy Num> {\n     m11: T, m12: T, m13: T, m14: T,\n     m21: T, m22: T, m23: T, m24: T,\n     m31: T, m32: T, m33: T, m34: T,"}, {"sha": "94829fdb7a85cd2f2ce7c150747276e24985c760", "filename": "src/test/run-pass/issue-333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fissue-333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-333.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,5 +1,5 @@\n-fn quux<T: copy>(x: T) -> T { let f = id::<T>; return f(x); }\n+fn quux<T: Copy>(x: T) -> T { let f = id::<T>; return f(x); }\n \n-fn id<T: copy>(x: T) -> T { return x; }\n+fn id<T: Copy>(x: T) -> T { return x; }\n \n fn main() { assert (quux(10) == 10); }"}, {"sha": "9464b6923a943b4d838fa8164a171ce71d5087bd", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn double<T: copy>(a: T) -> ~[T] { return ~[a] + ~[a]; }\n+fn double<T: Copy>(a: T) -> ~[T] { return ~[a] + ~[a]; }\n \n fn double_int(a: int) -> ~[int] { return ~[a] + ~[a]; }\n "}, {"sha": "afbc2561d15f682474203dc0aa89a38bae8530d0", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,10 +1,10 @@\n trait repeat<A> { fn get() -> A; }\n \n-impl<A:copy> @A: repeat<A> {\n+impl<A:Copy> @A: repeat<A> {\n     fn get() -> A { *self }\n }\n \n-fn repeater<A:copy>(v: @A) -> repeat<A> {\n+fn repeater<A:Copy>(v: @A) -> repeat<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n     v as repeat::<A> // No\n }"}, {"sha": "36eea6e89d51be98a014615f8161acf01a1ab703", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,9 +1,9 @@\n trait vec_monad<A> {\n-    fn bind<B: copy>(f: fn(A) -> ~[B]) -> ~[B];\n+    fn bind<B: Copy>(f: fn(A) -> ~[B]) -> ~[B];\n }\n \n impl<A> ~[A]: vec_monad<A> {\n-    fn bind<B: copy>(f: fn(A) -> ~[B]) -> ~[B] {\n+    fn bind<B: Copy>(f: fn(A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n         for self.each |elt| { r += f(elt); }\n         r"}, {"sha": "18f6557fdac0afc62c554d406874d208ba350193", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,8 +1,8 @@\n enum myvec<X> = ~[X];\n \n-fn myvec_deref<X: copy>(mv: myvec<X>) -> ~[X] { return *mv; }\n+fn myvec_deref<X: Copy>(mv: myvec<X>) -> ~[X] { return *mv; }\n \n-fn myvec_elt<X: copy>(mv: myvec<X>) -> X { return mv[0]; }\n+fn myvec_elt<X: Copy>(mv: myvec<X>) -> X { return mv[0]; }\n \n fn main() {\n     let mv = myvec(~[1, 2, 3]);"}, {"sha": "9b8bbfd9438d3a8c9e2f445f793e9422ee0d2840", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,15 +2,15 @@ use std;\n \n use std::list::*;\n \n-pure fn pure_length_go<T: copy>(ls: @List<T>, acc: uint) -> uint {\n+pure fn pure_length_go<T: Copy>(ls: @List<T>, acc: uint) -> uint {\n     match *ls { Nil => { acc } Cons(_, tl) => { pure_length_go(tl, acc + 1u) } }\n }\n \n-pure fn pure_length<T: copy>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n+pure fn pure_length<T: Copy>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<T: copy>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T: Copy>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n \n-fn safe_head<T: copy>(ls: @List<T>) -> T {\n+fn safe_head<T: Copy>(ls: @List<T>) -> T {\n     assert is_not_empty(ls);\n     return head(ls);\n }"}, {"sha": "f484e635e495cc285467fcc654d48e08a1f1c64b", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -36,7 +36,7 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n )\n \n-fn switch<T: send, U>(+endp: pipes::RecvPacket<T>,\n+fn switch<T: Send, U>(+endp: pipes::RecvPacket<T>,\n                       f: fn(+Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }"}, {"sha": "783febf942c1b5df8682744817d6f885ac0a53d0", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -14,7 +14,7 @@ proto! oneshot (\n )\n \n proto! stream (\n-    stream:send<T:send> {\n+    stream:send<T:Send> {\n         send(T) -> stream<T>\n     }\n )"}, {"sha": "392d68d8763ad1df723370fe806253a82cbef40a", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,9 +1,9 @@\n-struct finish<T: copy> {\n+struct finish<T: Copy> {\n   arg: {val: T, fin: extern fn(T)},\n   drop { self.arg.fin(self.arg.val); }\n }\n \n-fn finish<T: copy>(arg: {val: T, fin: extern fn(T)}) -> finish<T> {\n+fn finish<T: Copy>(arg: {val: T, fin: extern fn(T)}) -> finish<T> {\n     finish {\n         arg: arg\n     }"}, {"sha": "069618aaa054c82d4b2d7844c87c78e53961ec9d", "filename": "src/test/run-pass/ret-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fret-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fret-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-none.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,6 +2,6 @@\n \n enum option<T> { none, some(T), }\n \n-fn f<T: copy>() -> option<T> { return none; }\n+fn f<T: Copy>() -> option<T> { return none; }\n \n fn main() { f::<int>(); }"}, {"sha": "c642670afbccbab9c3b526c5bbfd3f2d41dc3174", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -4,9 +4,9 @@ use comm::send;\n use comm::Port;\n \n // tests that ctrl's type gets inferred properly\n-type command<K: send, V: send> = {key: K, val: V};\n+type command<K: Send, V: Send> = {key: K, val: V};\n \n-fn cache_server<K: send, V: send>(c: Chan<Chan<command<K, V>>>) {\n+fn cache_server<K: Send, V: Send>(c: Chan<Chan<command<K, V>>>) {\n     let ctrl = Port();\n     send(c, Chan(ctrl));\n }"}, {"sha": "d089eb873bdf7417b9d3c1b114623c380905bbec", "filename": "src/test/run-pass/sendfn-deep-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -5,7 +5,7 @@ use comm::send;\n \n fn main() { test05(); }\n \n-fn mk_counter<A:copy>() -> fn~(A) -> (A,uint) {\n+fn mk_counter<A:Copy>() -> fn~(A) -> (A,uint) {\n     // The only reason that the counter is generic is so that it closes\n     // over both a type descriptor and some data.\n     let v = ~[mut 0u];"}, {"sha": "2fcc6adfce38810302a76bc373feb72149e76678", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -7,7 +7,7 @@ fn main() { test05(); }\n \n type pair<A,B> = { a: A, b: B };\n \n-fn make_generic_record<A: copy, B: copy>(a: A, b: B) -> pair<A,B> {\n+fn make_generic_record<A: Copy, B: Copy>(a: A, b: B) -> pair<A,B> {\n     return {a: a, b: b};\n }\n \n@@ -23,7 +23,7 @@ fn test05_start(&&f: fn~(&&float, &&~str) -> pair<float, ~str>) {\n     assert q.b == ~\"Ho\";\n }\n \n-fn spawn<A: copy, B: copy>(f: extern fn(fn~(A,B)->pair<A,B>)) {\n+fn spawn<A: Copy, B: Copy>(f: extern fn(fn~(A,B)->pair<A,B>)) {\n     let arg = fn~(a: A, b: B) -> pair<A,B> {\n         return make_generic_record(a, b);\n     };"}, {"sha": "e29f3fdd5e4f2908a523d0c02751d24657294228", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -28,13 +28,13 @@ impl uint: uint_utils {\n trait vec_utils<T> {\n     fn length_() -> uint;\n     fn iter_(f: fn(T));\n-    fn map_<U: copy>(f: fn(T) -> U) -> ~[U];\n+    fn map_<U: Copy>(f: fn(T) -> U) -> ~[U];\n }\n \n impl<T> ~[T]: vec_utils<T> {\n     fn length_() -> uint { vec::len(self) }\n     fn iter_(f: fn(T)) { for self.each |x| { f(x); } }\n-    fn map_<U: copy>(f: fn(T) -> U) -> ~[U] {\n+    fn map_<U: Copy>(f: fn(T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |elt| { r += ~[f(elt)]; }\n         r"}, {"sha": "1fc930a688ef0f2b2d111a3c348590becfc1c7a9", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -5,7 +5,7 @@ trait bool_like {\n     static fn select<A>(b: self, +x1: A, +x2: A) -> A;\n }\n \n-fn andand<T: bool_like copy>(x1: T, x2: T) -> T {\n+fn andand<T: bool_like Copy>(x1: T, x2: T) -> T {\n     select(x1, x2, x1)\n }\n "}, {"sha": "4c7d0415d85897c0478cb603b5da668de608c878", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -12,10 +12,10 @@ impl (): to_str {\n }\n \n trait map<T> {\n-    fn map<U: copy>(f: fn(T) -> U) -> ~[U];\n+    fn map<U: Copy>(f: fn(T) -> U) -> ~[U];\n }\n impl<T> ~[T]: map<T> {\n-    fn map<U: copy>(f: fn(T) -> U) -> ~[U] {\n+    fn map<U: Copy>(f: fn(T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |x| { r += ~[f(x)]; }\n         r"}, {"sha": "f96c2bede61a699c111c13b4deb7b57d12e09d3b", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n fn p_foo<T>(pinned: T) { }\n-fn s_foo<T: copy>(shared: T) { }\n-fn u_foo<T: send>(unique: T) { }\n+fn s_foo<T: Copy>(shared: T) { }\n+fn u_foo<T: Send>(unique: T) { }\n \n struct r {\n   i: int,"}, {"sha": "18c3db591f6534a7842852ca8f63b3338b70f680", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -8,7 +8,7 @@ type pointy = {\n     d : fn~() -> uint,\n };\n \n-fn make_uniq_closure<A:send copy>(a: A) -> fn~() -> uint {\n+fn make_uniq_closure<A:Send Copy>(a: A) -> fn~() -> uint {\n     fn~() -> uint { ptr::addr_of(a) as uint }\n }\n "}, {"sha": "8a36cbd7c7d3e3f498b53c9cbcac8bcedb97bf50", "filename": "src/test/run-pass/unique-assign-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,4 +1,4 @@\n-fn f<T: copy>(t: T) -> T {\n+fn f<T: Copy>(t: T) -> T {\n     let t1 = t;\n     t1\n }"}, {"sha": "a299e88c344b66a61f1d96c3f60a16b4fde8b022", "filename": "src/test/run-pass/unique-generic-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -1,6 +1,6 @@\n // Issue #976\n \n-fn f<T: copy>(x: ~T) {\n+fn f<T: Copy>(x: ~T) {\n     let _x2 = x;\n }\n fn main() { }"}, {"sha": "2f6c94f3f34fc9f99398b9917dcddbe1168d5bee", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd1f32cd945fab63777b71ef76f23d758e2904c/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=3bd1f32cd945fab63777b71ef76f23d758e2904c", "patch": "@@ -2,11 +2,11 @@ use cmp::Eq;\n \n fn sendable() {\n \n-    fn f<T: send Eq>(i: T, j: T) {\n+    fn f<T: Send Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: send Eq>(i: T, j: T) {\n+    fn g<T: Send Eq>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -20,11 +20,11 @@ fn sendable() {\n \n fn copyable() {\n \n-    fn f<T: copy Eq>(i: T, j: T) {\n+    fn f<T: Copy Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: copy Eq>(i: T, j: T) {\n+    fn g<T: Copy Eq>(i: T, j: T) {\n         assert i != j;\n     }\n "}]}