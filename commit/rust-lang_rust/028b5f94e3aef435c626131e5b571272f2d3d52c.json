{"sha": "028b5f94e3aef435c626131e5b571272f2d3d52c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOGI1Zjk0ZTNhZWY0MzVjNjI2MTMxZTViNTcxMjcyZjJkM2Q1MmM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-06-13T23:26:20Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-06-15T05:09:32Z"}, "message": "Report error for assignment in `if` condition\n\nFor code like `if x = 3 {}`, output:\n\n```\nerror[E0308]: mismatched types\n  --> $DIR/issue-17283.rs:25:8\n   |\n25 |     if x = x {\n   |        ^^^^^\n   |        |\n   |        help: did you mean to compare equality? `x == x`\n   |        expected bool, found ()\n   |\n   = note: expected type `bool`\n              found type `()`\n```", "tree": {"sha": "a73fb4260dc9acafd5ed2ecfa74c57394123ac2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a73fb4260dc9acafd5ed2ecfa74c57394123ac2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/028b5f94e3aef435c626131e5b571272f2d3d52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/028b5f94e3aef435c626131e5b571272f2d3d52c", "html_url": "https://github.com/rust-lang/rust/commit/028b5f94e3aef435c626131e5b571272f2d3d52c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/028b5f94e3aef435c626131e5b571272f2d3d52c/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/554c685b0b3b25b7aa752717edf50b8d6bcab7a0", "html_url": "https://github.com/rust-lang/rust/commit/554c685b0b3b25b7aa752717edf50b8d6bcab7a0"}], "stats": {"total": 145, "additions": 118, "deletions": 27}, "files": [{"sha": "732b9be81a3980d02e6bdd5a1d3aaf6d15cc1dca", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=028b5f94e3aef435c626131e5b571272f2d3d52c", "patch": "@@ -26,13 +26,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+        self.demand_suptype_diag(sp, expected, actual).map(|mut e| e.emit());\n+    }\n+\n+    pub fn demand_suptype_diag(&self, sp: Span,\n+                               expected: Ty<'tcx>,\n+                               actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n         let cause = &self.misc(sp);\n         match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n+                None\n             },\n             Err(e) => {\n-                self.report_mismatched_types(&cause, expected, actual, e).emit();\n+                Some(self.report_mismatched_types(&cause, expected, actual, e))\n             }\n         }\n     }"}, {"sha": "5bba79a176eee31ad4c075f28cb736a579a85580", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=028b5f94e3aef435c626131e5b571272f2d3d52c", "patch": "@@ -232,6 +232,9 @@ pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n+    /// This expression is an `if` condition, it must resolve to `bool`.\n+    ExpectIfCondition,\n+\n     /// This expression should have the type given (or some subtype)\n     ExpectHasType(Ty<'tcx>),\n \n@@ -310,9 +313,8 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     // no constraints yet present), just returns `None`.\n     fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n-            NoExpectation => {\n-                NoExpectation\n-            }\n+            NoExpectation => NoExpectation,\n+            ExpectIfCondition => ExpectIfCondition,\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n             }\n@@ -328,6 +330,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn to_option(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n+            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n             ExpectRvalueLikeUnsized(ty) => Some(ty),\n@@ -341,6 +344,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n+            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             _ => None\n         }\n     }\n@@ -2646,7 +2650,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_expr_has_type(&self,\n                                expr: &'gcx hir::Expr,\n                                expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let mut ty = self.check_expr_with_hint(expr, expected);\n+        self.check_expr_expect_type(expr, ExpectHasType(expected))\n+    }\n+\n+    fn check_expr_expect_type(&self,\n+                              expr: &'gcx hir::Expr,\n+                              expected: Expectation<'tcx>) -> Ty<'tcx> {\n+        let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n+        let mut ty = self.check_expr_with_expectation(expr, expected);\n \n         // While we don't allow *arbitrary* coercions here, we *do* allow\n         // coercions from ! to `expected`.\n@@ -2662,7 +2673,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty = adj_ty;\n         }\n \n-        self.demand_suptype(expr.span, expected, ty);\n+        if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n+            // Add help to type error if this is an `if` condition with an assignment\n+            match (expected, &expr.node) {\n+                (ExpectIfCondition, &hir::ExprAssign(ref lhs, ref rhs)) => {\n+                    let msg = \"did you mean to compare equality?\";\n+                    if let (Ok(left), Ok(right)) = (\n+                        self.tcx.sess.codemap().span_to_snippet(lhs.span),\n+                        self.tcx.sess.codemap().span_to_snippet(rhs.span))\n+                    {\n+                        err.span_suggestion(expr.span, msg, format!(\"{} == {}\", left, right));\n+                    } else {\n+                        err.help(msg);\n+                    }\n+                }\n+                _ => (),\n+            }\n+            err.emit();\n+        }\n         ty\n     }\n \n@@ -2837,7 +2865,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n+        let cond_ty = self.check_expr_expect_type(cond_expr, ExpectIfCondition);\n         let cond_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -3637,19 +3665,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprAssign(ref lhs, ref rhs) => {\n             let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n \n-            let tcx = self.tcx;\n-            if !tcx.expr_is_lval(&lhs) {\n-                struct_span_err!(\n-                    tcx.sess, expr.span, E0070,\n-                    \"invalid left-hand side expression\")\n-                .span_label(\n-                    expr.span,\n-                    \"left-hand of expression not valid\")\n-                .emit();\n-            }\n-\n             let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n+            match expected {\n+                ExpectIfCondition => (),\n+                _ => {\n+                    // Only check this if not in an `if` condition, as the\n+                    // mistyped comparison help is more appropriate.\n+                    if !self.tcx.expr_is_lval(&lhs) {\n+                        struct_span_err!(\n+                            self.tcx.sess, expr.span, E0070,\n+                            \"invalid left-hand side expression\")\n+                        .span_label(\n+                            expr.span,\n+                            \"left-hand of expression not valid\")\n+                        .emit();\n+                    }\n+                }\n+            }\n+\n             self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n \n             if lhs_ty.references_error() || rhs_ty.references_error() {"}, {"sha": "f06888b8ec4698a1649a4ca37fcf7cbc96bc5cc7", "filename": "src/test/ui/type-check/issue-17283.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Ftest%2Fui%2Ftype-check%2Fissue-17283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Ftest%2Fui%2Ftype-check%2Fissue-17283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-17283.rs?ref=028b5f94e3aef435c626131e5b571272f2d3d52c", "patch": "@@ -24,25 +24,25 @@ fn main() {\n     // `x { ... }` should not be interpreted as a struct literal here\n     if x = x {\n         //~^ ERROR mismatched types\n-        //~| expected type `bool`\n-        //~| found type `()`\n-        //~| expected bool, found ()\n+        //~| HELP did you mean to compare equality?\n         println!(\"{}\", x);\n     }\n     // Explicit parentheses on the left should match behavior of above\n     if (x = x) {\n         //~^ ERROR mismatched types\n-        //~| expected type `bool`\n-        //~| found type `()`\n-        //~| expected bool, found ()\n+        //~| HELP did you mean to compare equality?\n         println!(\"{}\", x);\n     }\n     // The struct literal interpretation is fine with explicit parentheses on the right\n     if y = (Foo { foo: x }) {\n         //~^ ERROR mismatched types\n-        //~| expected type `bool`\n-        //~| found type `()`\n-        //~| expected bool, found ()\n+        //~| HELP did you mean to compare equality?\n+        println!(\"{}\", x);\n+    }\n+    // \"invalid left-hand side expression\" error is suppresed\n+    if 3 = x {\n+        //~^ ERROR mismatched types\n+        //~| HELP did you mean to compare equality?\n         println!(\"{}\", x);\n     }\n }", "previous_filename": "src/test/compile-fail/issue-17283.rs"}, {"sha": "f258caecd300e02998dbd3b58684f231619a169c", "filename": "src/test/ui/type-check/issue-17283.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Ftest%2Fui%2Ftype-check%2Fissue-17283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/028b5f94e3aef435c626131e5b571272f2d3d52c/src%2Ftest%2Fui%2Ftype-check%2Fissue-17283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-17283.stderr?ref=028b5f94e3aef435c626131e5b571272f2d3d52c", "patch": "@@ -0,0 +1,50 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-17283.rs:25:8\n+   |\n+25 |     if x = x {\n+   |        ^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `x == x`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-17283.rs:31:8\n+   |\n+31 |     if (x = x) {\n+   |        ^^^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `x == x`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-17283.rs:37:8\n+   |\n+37 |     if y = (Foo { foo: x }) {\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `y == (Foo { foo: x })`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-17283.rs:43:8\n+   |\n+43 |     if 3 = x {\n+   |        ^^^^^\n+   |        |\n+   |        help: did you mean to compare equality? `3 == x`\n+   |        expected bool, found ()\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error: aborting due to previous error(s)\n+"}]}