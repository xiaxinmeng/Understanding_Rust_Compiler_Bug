{"sha": "91ff1db5bc51c8513038ce510b182b7cd75de9d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZmYxZGI1YmM1MWM4NTEzMDM4Y2U1MTBiMTgyYjdjZDc1ZGU5ZDQ=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-20T01:23:39Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-20T11:57:14Z"}, "message": "Add a lint for starts_with", "tree": {"sha": "3e9e6a8a1caa47f961b4590af415189ac145ad5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e9e6a8a1caa47f961b4590af415189ac145ad5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91ff1db5bc51c8513038ce510b182b7cd75de9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91ff1db5bc51c8513038ce510b182b7cd75de9d4", "html_url": "https://github.com/rust-lang/rust/commit/91ff1db5bc51c8513038ce510b182b7cd75de9d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91ff1db5bc51c8513038ce510b182b7cd75de9d4/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdcd9743ee611a0486b153715d6e6d88a674c8ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdcd9743ee611a0486b153715d6e6d88a674c8ad", "html_url": "https://github.com/rust-lang/rust/commit/fdcd9743ee611a0486b153715d6e6d88a674c8ad"}], "stats": {"total": 137, "additions": 105, "deletions": 32}, "files": [{"sha": "ba257ce43a17846d5c2a1885a21990c27a758cdf", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91ff1db5bc51c8513038ce510b182b7cd75de9d4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/91ff1db5bc51c8513038ce510b182b7cd75de9d4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=91ff1db5bc51c8513038ce510b182b7cd75de9d4", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 94 lints included in this crate:\n+There are 95 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -20,6 +20,7 @@ name\n [cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                       | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n [cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                     | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n [cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                               | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n+[chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                               | warn    | using `.chars().next()` to check if a string starts with a char\n [cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                             | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                         | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                               | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`"}, {"sha": "1a4501ffce6fe05b465e55a8bdb50743e0e0a47a", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ff1db5bc51c8513038ce510b182b7cd75de9d4/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ff1db5bc51c8513038ce510b182b7cd75de9d4/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=91ff1db5bc51c8513038ce510b182b7cd75de9d4", "patch": "@@ -191,6 +191,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n+        methods::CHARS_NEXT_CMP,\n         methods::FILTER_NEXT,\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,"}, {"sha": "3f57f8189c39a2eaa18bc3bd11542cc7419eb3c2", "filename": "src/methods.rs", "status": "modified", "additions": 85, "deletions": 27, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/91ff1db5bc51c8513038ce510b182b7cd75de9d4/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ff1db5bc51c8513038ce510b182b7cd75de9d4/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=91ff1db5bc51c8513038ce510b182b7cd75de9d4", "patch": "@@ -7,11 +7,14 @@ use std::borrow::Cow;\n use syntax::ptr::P;\n use syntax::codemap::Span;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args, match_trait_method,\n-            walk_ptrs_ty_depth, walk_ptrs_ty, get_trait_def_id, implements_trait};\n use utils::{\n-    BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH,\n-    RESULT_PATH, STRING_PATH\n+    snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args,\n+    match_trait_method, walk_ptrs_ty_depth, walk_ptrs_ty, get_trait_def_id, implements_trait,\n+    span_lint_and_then\n+};\n+use utils::{\n+    BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH,\n+    STRING_PATH\n };\n use utils::MethodArgs;\n use rustc::middle::cstore::CrateStore;\n@@ -176,6 +179,17 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n               \"using an iterator search followed by `is_some()`, which is more succinctly \\\n                expressed as a call to `any()`\");\n \n+/// **What it does:** This lint `Warn`s on using `.chars().next()` on a `str` to check if it\n+/// starts with a given char.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.starts_with(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `name.chars().next() == Some('_')`\n+declare_lint!(pub CHARS_NEXT_CMP, Warn,\n+              \"using `.chars().next()` to check if a string starts with a char\");\n+\n /// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n /// suggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.\n ///\n@@ -210,35 +224,44 @@ impl LintPass for MethodsPass {\n                     OK_EXPECT,\n                     OPTION_MAP_UNWRAP_OR,\n                     OPTION_MAP_UNWRAP_OR_ELSE,\n-                    OR_FUN_CALL)\n+                    OR_FUN_CALL,\n+                    CHARS_NEXT_CMP)\n     }\n }\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(name, _, ref args) = expr.node {\n-            // Chain calls\n-            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                lint_unwrap(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n-                lint_to_string(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n-                lint_ok_expect(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n-                lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n-                lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n-                lint_filter_next(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n-                lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n-                lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n-                lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n-            }\n+        match expr.node {\n+            ExprMethodCall(name, _, ref args) => {\n+                // Chain calls\n+                if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                    lint_unwrap(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n+                    lint_to_string(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n+                    lint_ok_expect(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n+                    lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n+                    lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n+                    lint_filter_next(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n+                    lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n+                    lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n+                    lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n+                }\n \n-            lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n+                lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n+            }\n+            ExprBinary(op, ref lhs, ref rhs) if op.node == BiEq || op.node == BiNe => {\n+                if !lint_chars_next(cx, expr, lhs, rhs, op.node == BiEq) {\n+                    lint_chars_next(cx, expr, rhs, lhs, op.node == BiEq);\n+                }\n+            }\n+            _ => (),\n         }\n     }\n \n@@ -570,6 +593,41 @@ fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, searc\n     }\n }\n \n+/// Checks for the `CHARS_NEXT_CMP` lint.\n+fn lint_chars_next(cx: &LateContext, expr: &Expr, chain: &Expr, other: &Expr, eq: bool) -> bool {\n+    if_let_chain! {[\n+        let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n+        let ExprCall(ref fun, ref arg_char) = other.node,\n+        arg_char.len() == 1,\n+        let ExprPath(None, ref path) = fun.node,\n+        path.segments.len() == 1 && path.segments[0].identifier.name.as_str() == \"Some\"\n+    ], {\n+        let self_ty = walk_ptrs_ty(cx.tcx.expr_ty_adjusted(&args[0][0]));\n+\n+        if self_ty.sty != ty::TyStr {\n+            return false;\n+        }\n+\n+        span_lint_and_then(cx,\n+                           CHARS_NEXT_CMP,\n+                           expr.span,\n+                           \"you should use the `starts_with` method\",\n+                           |db| {\n+                               let sugg = format!(\"{}{}.starts_with({})\",\n+                                                  if eq { \"\" } else { \"!\" },\n+                                                  snippet(cx, args[0][0].span, \"_\"),\n+                                                  snippet(cx, arg_char[0].span, \"_\")\n+                                                  );\n+\n+                               db.span_suggestion(expr.span, \"like this\", sugg);\n+                           });\n+\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n // Given a `Result<T, E>` type, return its error type (`E`)\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {"}, {"sha": "4b6170cf16437fe83e20cfac714796ae3495497f", "filename": "src/misc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91ff1db5bc51c8513038ce510b182b7cd75de9d4/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ff1db5bc51c8513038ce510b182b7cd75de9d4/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=91ff1db5bc51c8513038ce510b182b7cd75de9d4", "patch": "@@ -389,13 +389,14 @@ impl LateLintPass for UsedUnderscoreBinding {\n                                 .last()\n                                 .expect(\"path should always have at least one segment\")\n                                 .identifier;\n-                ident.name.as_str().chars().next() == Some('_') && // starts with '_'\n-                ident.name.as_str().chars().skip(1).next() != Some('_') &&  // doesn't start with \"__\"\n-                ident.name != ident.unhygienic_name && is_used(cx, expr) // not in bang macro\n+                ident.name.as_str().starts_with('_') &&\n+                !ident.name.as_str().starts_with(\"__\") &&\n+                ident.name != ident.unhygienic_name &&\n+                is_used(cx, expr) // not in bang macro\n             }\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n-                name.chars().next() == Some('_') && name.chars().skip(1).next() != Some('_')\n+                name.starts_with('_') && !name.starts_with(\"__\")\n             }\n             _ => false,\n         };"}, {"sha": "535e8cc4a26c6b8ae3e1fce7df48a4dd47801012", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ff1db5bc51c8513038ce510b182b7cd75de9d4/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ff1db5bc51c8513038ce510b182b7cd75de9d4/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=91ff1db5bc51c8513038ce510b182b7cd75de9d4", "patch": "@@ -292,3 +292,15 @@ struct MyError(()); // doesn't implement Debug\n struct MyErrorWithParam<T> {\n     x: T\n }\n+\n+fn starts_with() {\n+    \"\".chars().next() == Some(' ');\n+    //~^ ERROR starts_with\n+    //~| HELP like this\n+    //~| SUGGESTION \"\".starts_with(' ')\n+\n+    Some(' ') != \"\".chars().next();\n+    //~^ ERROR starts_with\n+    //~| HELP like this\n+    //~| SUGGESTION !\"\".starts_with(' ')\n+}"}]}