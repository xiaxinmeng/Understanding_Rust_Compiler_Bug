{"sha": "45f5f8ec45da02700d77569b0ea470ae0fb430b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZjVmOGVjNDVkYTAyNzAwZDc3NTY5YjBlYTQ3MGFlMGZiNDMwYjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-13T00:59:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-13T01:22:08Z"}, "message": "libcore: Add some visitor-based logging functionality", "tree": {"sha": "aac622b6fd222c9eb5bb258895dc3df4d3567d83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aac622b6fd222c9eb5bb258895dc3df4d3567d83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45f5f8ec45da02700d77569b0ea470ae0fb430b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45f5f8ec45da02700d77569b0ea470ae0fb430b0", "html_url": "https://github.com/rust-lang/rust/commit/45f5f8ec45da02700d77569b0ea470ae0fb430b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45f5f8ec45da02700d77569b0ea470ae0fb430b0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8299f3a447ca6416b23c20871172d784a28762bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8299f3a447ca6416b23c20871172d784a28762bd", "html_url": "https://github.com/rust-lang/rust/commit/8299f3a447ca6416b23c20871172d784a28762bd"}], "stats": {"total": 585, "additions": 583, "deletions": 2}, "files": [{"sha": "d6091801da4504f4cdfff707016420abb01e4c37", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45f5f8ec45da02700d77569b0ea470ae0fb430b0/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/45f5f8ec45da02700d77569b0ea470ae0fb430b0/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=45f5f8ec45da02700d77569b0ea470ae0fb430b0", "patch": "@@ -61,6 +61,7 @@ export mutable;\n export flate;\n export unit;\n export uniq;\n+export repr;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -224,10 +225,9 @@ mod rand;\n mod run;\n mod sys;\n mod unsafe;\n-\n mod mutable;\n-\n mod flate;\n+mod repr;\n \n // Modules supporting compiler-generated code\n // Exported but not part of the public interface"}, {"sha": "f052016ed6c9a655f1f03408ce227dd7b1024968", "filename": "src/libcore/repr.rs", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/45f5f8ec45da02700d77569b0ea470ae0fb430b0/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f5f8ec45da02700d77569b0ea470ae0fb430b0/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=45f5f8ec45da02700d77569b0ea470ae0fb430b0", "patch": "@@ -0,0 +1,575 @@\n+use dvec::DVec;\n+use io::{Writer, WriterUtil};\n+use libc::c_void;\n+use sys::TypeDesc;\n+use to_str::ToStr;\n+use unsafe::transmute;\n+use intrinsic::{TyDesc, TyVisitor};\n+\n+/// Helpers\n+\n+/// Helper function for alignment calculation.\n+#[inline(always)]\n+fn align(size: uint, align: uint) -> uint {\n+    ((size + align) - 1) & !(align - 1)\n+}\n+\n+struct VecRepr {\n+    box_header: (uint, uint, uint, uint),\n+    mut fill: uint,\n+    mut alloc: uint,\n+    data: u8\n+}\n+\n+struct BoxRepr {\n+    ref_count: uint,\n+    type_desc: *TyDesc,\n+    prev: *BoxRepr,\n+    next: *BoxRepr,\n+    data: u8\n+}\n+\n+trait EscapedCharWriter {\n+    fn write_escaped_char(ch: char);\n+}\n+\n+impl Writer : EscapedCharWriter {\n+    fn write_escaped_char(ch: char) {\n+        match ch {\n+            '\\t' => self.write_str(\"\\\\t\"),\n+            '\\r' => self.write_str(\"\\\\r\"),\n+            '\\n' => self.write_str(\"\\\\n\"),\n+            '\\\\' => self.write_str(\"\\\\\\\\\"),\n+            '\\'' => self.write_str(\"\\\\'\"),\n+            '\"' => self.write_str(\"\\\\\\\"\"),\n+            '\\x20'..'\\x7e' => self.write_char(ch),\n+            _ => {\n+                // XXX: This is inefficient because it requires a malloc.\n+                self.write_str(char::escape_unicode(ch))\n+            }\n+        }\n+    }\n+}\n+\n+/// Representations\n+\n+trait Repr {\n+    fn write_repr(writer: @Writer);\n+}\n+\n+impl () : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_str(\"()\"); }\n+}\n+\n+impl bool : Repr {\n+    fn write_repr(writer: @Writer) {\n+        writer.write_str(if self { \"true\" } else { \"false\" })\n+    }\n+}\n+\n+impl int : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_int(self); }\n+}\n+impl i8 : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+}\n+impl i16 : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+}\n+impl i32 : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+}\n+impl i64 : Repr {\n+    // XXX: This can lose precision.\n+    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+}\n+\n+impl uint : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_uint(self); }\n+}\n+impl u8 : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+}\n+impl u16 : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+}\n+impl u32 : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+}\n+impl u64 : Repr {\n+    // XXX: This can lose precision.\n+    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+}\n+\n+impl float : Repr {\n+    // XXX: This mallocs.\n+    fn write_repr(writer: @Writer) { writer.write_str(self.to_str()); }\n+}\n+impl f32 : Repr {\n+    // XXX: This mallocs.\n+    fn write_repr(writer: @Writer) { writer.write_str(self.to_str()); }\n+}\n+impl f64 : Repr {\n+    // XXX: This mallocs.\n+    fn write_repr(writer: @Writer) { writer.write_str(self.to_str()); }\n+}\n+\n+impl char : Repr {\n+    fn write_repr(writer: @Writer) { writer.write_char(self); }\n+}\n+\n+/// XXX: This should not use a boxed writer!\n+struct ReprPrinter {\n+    mut ptr: *c_void,\n+    writer: @Writer,    // XXX: This should not use a boxed trait.\n+    mut skip: bool,\n+    enum_stack: DVec<*c_void>\n+}\n+\n+/// FIXME (issue #3462): This is horrible.\n+struct ReprPrinterWrapper {\n+    printer: @ReprPrinter\n+}\n+\n+impl ReprPrinter {\n+    #[inline(always)]\n+    fn align(n: uint) {\n+        unsafe {\n+            self.ptr = transmute(align(self.ptr as uint, n));\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn bump(n: uint) {\n+        unsafe {\n+            self.ptr = transmute(self.ptr as uint + n);\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn log_simple<T:Repr>() -> bool {\n+        unsafe {\n+            self.align(sys::min_align_of::<T>());\n+            let value_addr: &T = transmute(copy self.ptr);\n+            (*value_addr).write_repr(self.writer);\n+            self.bump(sys::size_of::<T>());\n+            true\n+        }\n+    }\n+}\n+\n+impl ReprPrinterWrapper {\n+    fn visit_estr() -> bool {\n+        unsafe {\n+            self.printer.writer.write_char('\"');\n+            let vec_repr_ptr: **VecRepr = transmute(copy self.printer.ptr);\n+            let vec_repr = *vec_repr_ptr;\n+            let data_ptr = ptr::to_unsafe_ptr(&(*vec_repr).data);\n+            let slice: &str = transmute((data_ptr, (*vec_repr).fill));\n+            do str::chars_iter(slice) |ch| {\n+                self.printer.writer.write_escaped_char(ch);\n+            }\n+            self.printer.writer.write_char('\"');\n+            let ptr_size = sys::size_of::<*c_void>();\n+            self.printer.ptr = transmute(self.printer.ptr as uint + ptr_size);\n+            true\n+        }\n+    }\n+\n+    fn visit_self_describing_heap_alloc(mtbl: uint) -> bool {\n+        unsafe {\n+            if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+            let box_ptr: **BoxRepr = transmute(copy self.printer.ptr);\n+            let box = *box_ptr;\n+            self.printer.ptr = transmute(&(*box).data);\n+            intrinsic::visit_tydesc((*box).type_desc, self as @TyVisitor);\n+            let box_size = sys::size_of::<*BoxRepr>();\n+            self.printer.ptr = transmute(self.printer.ptr as uint + box_size);\n+            true\n+        }\n+    }\n+\n+    fn visit_ptr_contents(mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe {\n+            if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+            let data_ptr: **c_void = transmute(copy self.printer.ptr);\n+            if *data_ptr == ptr::null() {\n+                self.printer.writer.write_str(\"null\");\n+            } else {\n+                self.printer.ptr = *data_ptr;\n+                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+            }\n+            let ptr_size = sys::size_of::<*c_void>();\n+            self.printer.ptr = transmute(self.printer.ptr as uint + ptr_size);\n+            true\n+        }\n+    }\n+\n+    fn visit_evec(mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe {\n+            self.printer.writer.write_char('[');\n+            self.printer.align(sys::min_align_of::<*c_void>());\n+            let vec_repr_ptr: **VecRepr = transmute(copy self.printer.ptr);\n+            let old_ptr = self.printer.ptr as uint;\n+            let vec_repr: *VecRepr = *vec_repr_ptr;\n+            self.printer.ptr = transmute(&(*vec_repr).data);\n+            let end_ptr: *c_void = transmute(self.printer.ptr as uint +\n+                                             (*vec_repr).fill);\n+            let sys_tydesc: *TypeDesc = transmute(copy inner);\n+            let alignment = (*sys_tydesc).align;\n+            let mut first = true;\n+            loop {\n+                self.printer.align(alignment);\n+                if self.printer.ptr >= end_ptr { break; }\n+                if first {\n+                    self.printer.writer.write_char(' ');\n+                    if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+                } else {\n+                    self.printer.writer.write_str(\", \");\n+                }\n+                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+                first = false;\n+            }\n+            if !first {\n+                self.printer.writer.write_char(' ');\n+            } else if mtbl != 1 {\n+                self.printer.writer.write_str(\"mut\");\n+            }\n+            self.printer.writer.write_char(']');\n+            self.printer.ptr = transmute(old_ptr + sys::size_of::<int>());\n+            true\n+        }\n+    }\n+}\n+\n+impl ReprPrinterWrapper : TyVisitor {\n+    fn visit_bot() -> bool {\n+        self.printer.bump(1);\n+        self.printer.writer.write_str(\"fail\");\n+        true\n+    }\n+\n+    fn visit_nil() -> bool { self.printer.log_simple::<()>() }\n+    fn visit_bool() -> bool { self.printer.log_simple::<bool>() }\n+\n+    // Numbers\n+\n+    fn visit_int() -> bool { self.printer.log_simple::<int>() }\n+    fn visit_i8() -> bool { self.printer.log_simple::<i8>() }\n+    fn visit_i16() -> bool { self.printer.log_simple::<i16>() }\n+    fn visit_i32() -> bool { self.printer.log_simple::<i32>() }\n+    fn visit_i64() -> bool { self.printer.log_simple::<i64>() }\n+\n+    fn visit_uint() -> bool { self.printer.log_simple::<uint>() }\n+    fn visit_u8() -> bool { self.printer.log_simple::<u8>() }\n+    fn visit_u16() -> bool { self.printer.log_simple::<u16>() }\n+    fn visit_u32() -> bool { self.printer.log_simple::<u32>() }\n+    fn visit_u64() -> bool { self.printer.log_simple::<u64>() }\n+\n+    fn visit_float() -> bool { self.printer.log_simple::<float>() }\n+    fn visit_f32() -> bool { self.printer.log_simple::<f32>() }\n+    fn visit_f64() -> bool { self.printer.log_simple::<f64>() }\n+\n+    fn visit_char() -> bool { self.printer.log_simple::<char>() }\n+    fn visit_str() -> bool { true }\n+\n+    // Strings\n+\n+    fn visit_estr_box() -> bool {\n+        self.printer.writer.write_char('@');\n+        self.visit_estr()\n+    }\n+    fn visit_estr_uniq() -> bool {\n+        self.printer.writer.write_char('~');\n+        self.visit_estr()\n+    }\n+    fn visit_estr_slice() -> bool {\n+        unsafe {\n+            self.printer.writer.write_char('\"');\n+            let slice_ptr: *&str = transmute(copy self.printer.ptr);\n+            let slice = *slice_ptr;\n+            do str::chars_iter(slice) |ch| {\n+                self.printer.writer.write_escaped_char(ch);\n+            }\n+            self.printer.writer.write_char('\"');\n+            let slice_sz = sys::size_of::<(*char,uint)>();\n+            self.printer.ptr = transmute(self.printer.ptr as uint + slice_sz);\n+            true\n+        }\n+    }\n+    fn visit_estr_fixed(_n: uint, _sz: uint, _align: uint) -> bool { true }\n+\n+    // Pointers\n+\n+    fn visit_box(mtbl: uint, _inner: *TyDesc) -> bool {\n+        self.printer.writer.write_char('@');\n+        self.visit_self_describing_heap_alloc(mtbl)\n+    }\n+    fn visit_uniq(mtbl: uint, _inner: *TyDesc) -> bool {\n+        self.printer.writer.write_char('~');\n+        self.visit_self_describing_heap_alloc(mtbl)\n+    }\n+    fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.printer.writer.write_char('*');\n+        self.visit_ptr_contents(mtbl, inner)\n+    }\n+    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.printer.writer.write_char('&');\n+        self.visit_ptr_contents(mtbl, inner)\n+    }\n+\n+    // Vectors\n+\n+    fn visit_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_unboxed_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.printer.writer.write_char('@');\n+        self.visit_evec(mtbl, inner)\n+    }\n+    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.printer.writer.write_char('~');\n+        self.visit_evec(mtbl, inner)\n+    }\n+    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe {\n+            self.printer.writer.write_str(\"&[\");\n+            self.printer.align(sys::min_align_of::<(*c_void,uint)>());\n+            let slice_ptr: *(*c_void,uint) = transmute(copy self.printer.ptr);\n+            let (data, fill) = *slice_ptr;\n+            self.printer.ptr = data;\n+            let end_ptr: *c_void = transmute(self.printer.ptr as uint + fill);\n+            let sys_tydesc: *TypeDesc = transmute(copy inner);\n+            let alignment = (*sys_tydesc).align;\n+            let mut first = true;\n+            loop {\n+                self.printer.align(alignment);\n+                if self.printer.ptr >= end_ptr { break; }\n+                if first {\n+                    self.printer.writer.write_char(' ');\n+                    if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+                } else {\n+                    self.printer.writer.write_str(\", \");\n+                }\n+                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+                first = false;\n+            }\n+            if !first {\n+                self.printer.writer.write_char(' ');\n+            } else if mtbl != 1 {\n+                self.printer.writer.write_str(\"mut\");\n+            }\n+            self.printer.writer.write_char(']');\n+            let slice_size = sys::size_of::<(uint, *c_void)>();\n+            self.printer.ptr = transmute(slice_ptr as uint + slice_size);\n+            true\n+        }\n+    }\n+    fn visit_evec_fixed(n: uint, sz: uint, align: uint, mtbl: uint,\n+                        inner: *TyDesc) -> bool {\n+        unsafe {\n+            self.printer.writer.write_char('[');\n+            self.printer.align(align);\n+            let end_ptr: *c_void = transmute(self.printer.ptr as uint + sz);\n+            for uint::range(0, n) |i| {\n+                self.printer.align(align);\n+                if i == 0 {\n+                    self.printer.writer.write_char(' ');\n+                    if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+                } else {\n+                    self.printer.writer.write_str(\", \");\n+                }\n+                intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+            }\n+            if n > 0 {\n+                self.printer.writer.write_char(' ');\n+            } else if mtbl != 1 {\n+                self.printer.writer.write_str(\"mut\");\n+            }\n+            self.printer.writer.write_char(']');\n+            self.printer.ptr = end_ptr;\n+            true\n+        }\n+    }\n+\n+    // Records\n+\n+    fn visit_enter_rec(_n_fields: uint, _sz: uint, align: uint) -> bool {\n+        self.printer.writer.write_char('{');\n+        self.printer.align(align);\n+        true\n+    }\n+    fn visit_rec_field(i: uint, name: &str, mtbl: uint, inner: *TyDesc) ->\n+                       bool {\n+        if i != 0 {\n+            self.printer.writer.write_str(\", \");\n+        } else {\n+            self.printer.writer.write_char(' ');\n+        }\n+        if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+        self.printer.writer.write_str(name);\n+        self.printer.writer.write_str(\": \");\n+        intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+        true\n+    }\n+    fn visit_leave_rec(n_fields: uint, _sz: uint, _align: uint) -> bool {\n+        if n_fields > 0 { self.printer.writer.write_char(' '); }\n+        self.printer.writer.write_char('}');\n+        true\n+    }\n+\n+    // Structs\n+\n+    fn visit_enter_class(_n_fields: uint, _sz: uint, align: uint) -> bool {\n+        self.printer.writer.write_char('{');\n+        self.printer.align(align);\n+        true\n+    }\n+    fn visit_class_field(i: uint, name: &str, mtbl: uint, inner: *TyDesc) ->\n+                         bool {\n+        if i != 0 {\n+            self.printer.writer.write_str(\", \");\n+        } else {\n+            self.printer.writer.write_char(' ');\n+        }\n+        if mtbl != 1 { self.printer.writer.write_str(\"mut \"); }\n+        self.printer.writer.write_str(name);\n+        self.printer.writer.write_str(\": \");\n+        intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+        true\n+    }\n+    fn visit_leave_class(n_fields: uint, _sz: uint, _align: uint) -> bool {\n+        if n_fields > 0 { self.printer.writer.write_char(' '); }\n+        self.printer.writer.write_char('}');\n+        true\n+    }\n+\n+    // Tuples\n+\n+    fn visit_enter_tup(_n_fields: uint, _sz: uint, align: uint) -> bool {\n+        self.printer.writer.write_char('(');\n+        self.printer.align(align);\n+        true\n+    }\n+    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n+        if i != 0 { self.printer.writer.write_str(\", \"); }\n+        intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+        true\n+    }\n+    fn visit_leave_tup(_n_fields: uint, _sz: uint, _align: uint) -> bool {\n+        self.printer.writer.write_char(')');\n+        true\n+    }\n+\n+    // Enums\n+\n+    fn visit_enter_enum(_n_variants: uint, sz: uint, align: uint) -> bool {\n+        unsafe {\n+            self.printer.align(align);\n+\n+            // Write in the location of the end of this enum.\n+            let new_pos = self.printer.ptr as uint + sz;\n+            self.printer.enum_stack.push(transmute(new_pos));\n+\n+            true\n+        }\n+    }\n+\n+    fn visit_enter_enum_variant(_variant: uint,\n+                                disr_val: int,\n+                                _n_fields: uint,\n+                                name: &str) -> bool {\n+        unsafe {\n+            let disr_ptr = self.printer.ptr as *int;\n+            if *disr_ptr == disr_val {\n+                self.printer.skip = false;  // Don't skip this variant.\n+                self.printer.writer.write_str(name);\n+                self.printer.bump(sys::size_of::<int>());\n+            } else {\n+                self.printer.skip = true;   // Skip this variant.\n+            }\n+            true\n+        }\n+    }\n+\n+    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n+        if !self.printer.skip {\n+            if i == 0 {\n+                self.printer.writer.write_char('(');\n+            } else {\n+                self.printer.writer.write_str(\", \");\n+            }\n+\n+            intrinsic::visit_tydesc(inner, self as @TyVisitor);\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(_variant: uint,\n+                                _disr_val: int,\n+                                n_fields: uint,\n+                                _name: &str) -> bool {\n+        if !self.printer.skip && n_fields > 1 {\n+            self.printer.writer.write_char(')');\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum(_n_variants: uint, _sz: uint, _align: uint) -> bool {\n+        self.printer.ptr = self.printer.enum_stack.pop();\n+        true\n+    }\n+\n+    // Functions\n+\n+    fn visit_enter_fn(_purity: uint, proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool {\n+        self.printer.align(sys::min_align_of::<(uint,uint)>());\n+        match proto {\n+            2u => self.printer.writer.write_char('~'),\n+            3u => self.printer.writer.write_char('@'),\n+            4u => self.printer.writer.write_char('&'),\n+            _ => {}\n+        }\n+        self.printer.writer.write_str(\"fn\");\n+        true\n+    }\n+\n+    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+\n+    // Others\n+\n+    fn visit_trait() -> bool { self.printer.writer.write_str(\"@trait\"); true }\n+    fn visit_var() -> bool { true }\n+    fn visit_var_integral() -> bool { true }\n+    fn visit_param(_i: uint) -> bool { true }\n+    fn visit_self() -> bool { true }\n+    fn visit_type() -> bool { true }\n+    fn visit_opaque_box() -> bool {\n+        self.printer.writer.write_char('@');\n+        self.visit_self_describing_heap_alloc(1)\n+    }\n+    fn visit_constr(_inner: *TyDesc) -> bool { true }\n+    fn visit_closure_ptr(_ck: uint) -> bool { true }\n+}\n+\n+pub fn write_repr<T>(writer: @Writer, object: &T) {\n+    unsafe {\n+        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n+        let tydesc = sys::get_type_desc::<T>();\n+        let tydesc = unsafe::transmute(tydesc);\n+\n+        let repr_printer = @ReprPrinter {\n+            ptr: ptr,\n+            writer: writer,\n+            skip: false,\n+            enum_stack: DVec()\n+        };\n+\n+        let wrapper = ReprPrinterWrapper { printer: repr_printer };\n+        intrinsic::visit_tydesc(tydesc, wrapper as @TyVisitor);\n+    }\n+}\n+"}, {"sha": "358ad0e281fe8c706a6acf0b34d5d416f292fa1d", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45f5f8ec45da02700d77569b0ea470ae0fb430b0/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f5f8ec45da02700d77569b0ea470ae0fb430b0/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=45f5f8ec45da02700d77569b0ea470ae0fb430b0", "patch": "@@ -37,6 +37,12 @@ impl u64: ToStr {\n impl float: ToStr {\n     fn to_str() -> ~str { float::to_str(self, 4u) }\n }\n+impl f32: ToStr {\n+    fn to_str() -> ~str { float::to_str(self as float, 4u) }\n+}\n+impl f64: ToStr {\n+    fn to_str() -> ~str { float::to_str(self as float, 4u) }\n+}\n impl bool: ToStr {\n     fn to_str() -> ~str { bool::to_str(self) }\n }"}]}