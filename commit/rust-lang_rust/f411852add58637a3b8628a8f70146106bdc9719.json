{"sha": "f411852add58637a3b8628a8f70146106bdc9719", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MTE4NTJhZGQ1ODYzN2EzYjg2MjhhOGY3MDE0NjEwNmJkYzk3MTk=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-02-14T05:35:20Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-02-20T05:37:30Z"}, "message": "Refactor Windows stdio and remove stdin double buffering", "tree": {"sha": "349d6fb007bf62c0895507ba1fcd58cee8ac6ad3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/349d6fb007bf62c0895507ba1fcd58cee8ac6ad3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f411852add58637a3b8628a8f70146106bdc9719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f411852add58637a3b8628a8f70146106bdc9719", "html_url": "https://github.com/rust-lang/rust/commit/f411852add58637a3b8628a8f70146106bdc9719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f411852add58637a3b8628a8f70146106bdc9719/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc20ed678e4fc782cbbe55501bb3e300b5430c37", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc20ed678e4fc782cbbe55501bb3e300b5430c37", "html_url": "https://github.com/rust-lang/rust/commit/cc20ed678e4fc782cbbe55501bb3e300b5430c37"}], "stats": {"total": 294, "additions": 178, "deletions": 116}, "files": [{"sha": "2527168a968c47a5be151a453ad7e69042eed8f4", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f411852add58637a3b8628a8f70146106bdc9719/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f411852add58637a3b8628a8f70146106bdc9719/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=f411852add58637a3b8628a8f70146106bdc9719", "patch": "@@ -252,9 +252,9 @@ impl Stdio {\n             // should still be unavailable so propagate the\n             // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => {\n-                match stdio::get(stdio_id) {\n+                match stdio::get_handle(stdio_id) {\n                     Ok(io) => {\n-                        let io = Handle::new(io.handle());\n+                        let io = Handle::new(io);\n                         let ret = io.duplicate(0, true,\n                                                c::DUPLICATE_SAME_ACCESS);\n                         io.into_raw();"}, {"sha": "ccfe0ced82fbc3818cde57c39116dcedcdc25ef0", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 176, "deletions": 114, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/f411852add58637a3b8628a8f70146106bdc9719/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f411852add58637a3b8628a8f70146106bdc9719/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=f411852add58637a3b8628a8f70146106bdc9719", "patch": "@@ -1,131 +1,226 @@\n #![unstable(issue = \"0\", feature = \"windows_stdio\")]\n \n+use cell::Cell;\n use cmp;\n-use io::{self, Cursor};\n+use io;\n use ptr;\n use str;\n-use sync::Mutex;\n use sys::c;\n use sys::cvt;\n use sys::handle::Handle;\n \n-pub enum Output {\n-    Console(c::HANDLE),\n-    Pipe(c::HANDLE),\n-}\n-\n+// Don't cache handles but get them fresh for every read/write. This allows us to track changes to\n+// the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n-    utf8: Mutex<io::Cursor<Vec<u8>>>,\n+    high_surrogate: Cell<u16>,\n }\n pub struct Stdout;\n pub struct Stderr;\n \n-pub fn get(handle: c::DWORD) -> io::Result<Output> {\n-    let handle = unsafe { c::GetStdHandle(handle) };\n+// Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n+// #13304 for details).\n+//\n+// From MSDN (2011): \"The storage for this buffer is allocated from a shared heap for the\n+// process that is 64 KB in size. The maximum size of the buffer will depend on heap usage.\"\n+//\n+// We choose the cap at 8 KiB because libuv does the same, and it seems to be acceptable so far.\n+const MAX_BUFFER_SIZE: usize = 8192;\n+\n+// The standard buffer size of BufReader for Stdin should be able to hold 3x more bytes than there\n+// are `u16`'s in MAX_BUFFER_SIZE. This ensures the read data can always be completely decoded from\n+// UTF-16 to UTF-8.\n+pub const STDIN_BUF_SIZE: usize = MAX_BUFFER_SIZE / 2 * 3;\n+\n+pub fn get_handle(handle_id: c::DWORD) -> io::Result<c::HANDLE> {\n+    let handle = unsafe { c::GetStdHandle(handle_id) };\n     if handle == c::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n         Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n     } else {\n-        let mut out = 0;\n-        match unsafe { c::GetConsoleMode(handle, &mut out) } {\n-            0 => Ok(Output::Pipe(handle)),\n-            _ => Ok(Output::Console(handle)),\n-        }\n+        Ok(handle)\n     }\n }\n \n-fn write(handle: c::DWORD, data: &[u8]) -> io::Result<usize> {\n-    let handle = match get(handle)? {\n-        Output::Console(c) => c,\n-        Output::Pipe(p) => {\n-            let handle = Handle::new(p);\n-            let ret = handle.write(data);\n-            handle.into_raw();\n-            return ret\n-        }\n-    };\n+fn is_console(handle: c::HANDLE) -> bool {\n+    // `GetConsoleMode` will return false (0) if this is a pipe (we don't care about the reported\n+    // mode). This will only detect Windows Console, not other terminals connected to a pipe like\n+    // MSYS. Which is exactly what we need, as only Windows Console needs a conversion to UTF-16.\n+    let mut mode = 0;\n+    unsafe { c::GetConsoleMode(handle, &mut mode) != 0 }\n+}\n \n-    // As with stdin on windows, stdout often can't handle writes of large\n-    // sizes. For an example, see #14940. For this reason, don't try to\n-    // write the entire output buffer on windows.\n-    //\n-    // For some other references, it appears that this problem has been\n-    // encountered by others [1] [2]. We choose the number 8K just because\n-    // libuv does the same.\n+fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+    let handle = get_handle(handle_id)?;\n+    if !is_console(handle) {\n+        let handle = Handle::new(handle);\n+        let ret = handle.write(data);\n+        handle.into_raw(); // Don't close the handle\n+        return ret;\n+    }\n+\n+    // As the console is meant for presenting text, we assume bytes of `data` come from a string\n+    // and are encoded as UTF-8, which needs to be encoded as UTF-16.\n     //\n-    // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n-    // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-    const OUT_MAX: usize = 8192;\n-    let len = cmp::min(data.len(), OUT_MAX);\n+    // If the data is not valid UTF-8 we write out as many bytes as are valid.\n+    // Only when there are no valid bytes (which will happen on the next call), return an error.\n+    let len = cmp::min(data.len(), MAX_BUFFER_SIZE);\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n-        Err(ref e) if e.valid_up_to() == 0 => return Err(invalid_encoding()),\n+        Err(ref e) if e.valid_up_to() == 0 => {\n+            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                \"Windows stdio in console mode does not support non-UTF-8 byte sequences; \\\n+                see https://github.com/rust-lang/rust/issues/23344\"))\n+        },\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n     let utf16 = utf8.encode_utf16().collect::<Vec<u16>>();\n+\n+    let mut written = write_u16s(handle, &utf16)?;\n+\n+    // Figure out how many bytes of as UTF-8 were written away as UTF-16.\n+    if written >= utf16.len() {\n+        Ok(utf8.len())\n+    } else {\n+        // Make sure we didn't end up writing only half of a surrogate pair (even though the chance\n+        // is tiny). Because it is not possible for user code to re-slice `data` in such a way that\n+        // a missing surrogate can be produced (and also because of the UTF-8 validation above),\n+        // write the missing surrogate out now.\n+        // Buffering it would mean we have to lie about the number of bytes written.\n+        let first_char_remaining = utf16[written];\n+        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF { // low surrogate\n+            // We just hope this works, and give up otherwise\n+            let _ = write_u16s(handle, &utf16[written..written]);\n+            written += 1;\n+        }\n+        // Calculate the number of bytes of `utf8` that were actually written.\n+        let mut count = 0;\n+        for ch in utf16[..written].iter() {\n+            count += match ch {\n+                0x0000 ..= 0x007F => 1,\n+                0x0080 ..= 0x07FF => 2,\n+                0xDCEE ..= 0xDFFF => 1, // Low surrogate. We already counted 3 bytes for the other.\n+                _ => 3,\n+            };\n+        }\n+        Ok(count)\n+    }\n+}\n+\n+fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n     let mut written = 0;\n     cvt(unsafe {\n         c::WriteConsoleW(handle,\n-                         utf16.as_ptr() as c::LPCVOID,\n-                         utf16.len() as u32,\n+                         data.as_ptr() as c::LPCVOID,\n+                         data.len() as u32,\n                          &mut written,\n                          ptr::null_mut())\n     })?;\n-\n-    // FIXME if this only partially writes the utf16 buffer then we need to\n-    //       figure out how many bytes of `data` were actually written\n-    assert_eq!(written as usize, utf16.len());\n-    Ok(utf8.len())\n+    Ok(written as usize)\n }\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        Ok(Stdin {\n-            utf8: Mutex::new(Cursor::new(Vec::new())),\n-        })\n+        Ok(Stdin { high_surrogate: Cell::new(0) })\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let handle = match get(c::STD_INPUT_HANDLE)? {\n-            Output::Console(c) => c,\n-            Output::Pipe(p) => {\n-                let handle = Handle::new(p);\n-                let ret = handle.read(buf);\n-                handle.into_raw();\n-                return ret\n-            }\n+        let handle = get_handle(c::STD_INPUT_HANDLE)?;\n+        if !is_console(handle) {\n+            let handle = Handle::new(handle);\n+            let ret = handle.read(buf);\n+            handle.into_raw(); // Don't close the handle\n+            return ret;\n+        }\n+\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        } else if buf.len() < 4 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                        \"Windows stdin in console mode does not support a buffer too small to; \\\n+                        guarantee holding one arbitrary UTF-8 character (4 bytes)\"))\n+        }\n+\n+        let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+        // In the worst case, an UTF-8 string can take 3 bytes for every `u16` of an UTF-16. So\n+        // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n+        // lost.\n+        let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n+        let read = self.read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount)?;\n+        let utf16 = &utf16_buf[..read];\n+\n+        // FIXME: it would be nice if we could directly decode into the buffer instead of doing an\n+        //        allocation.\n+        let data = match String::from_utf16(&utf16) {\n+            Ok(utf8) => utf8.into_bytes(),\n+            Err(..) => {\n+                // We can't really do any better than forget all data and return an error.\n+                return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    encountered unpaired surrogate\"))\n+            },\n         };\n-        let mut utf8 = self.utf8.lock().unwrap();\n-        // Read more if the buffer is empty\n-        if utf8.position() as usize == utf8.get_ref().len() {\n-            let mut utf16 = vec![0u16; 0x1000];\n-            let mut num = 0;\n-            let mut input_control = readconsole_input_control(CTRL_Z_MASK);\n-            cvt(unsafe {\n-                c::ReadConsoleW(handle,\n-                                utf16.as_mut_ptr() as c::LPVOID,\n-                                utf16.len() as u32,\n-                                &mut num,\n-                                &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n-            })?;\n-            utf16.truncate(num as usize);\n-            // FIXME: what to do about this data that has already been read?\n-            let mut data = match String::from_utf16(&utf16) {\n-                Ok(utf8) => utf8.into_bytes(),\n-                Err(..) => return Err(invalid_encoding()),\n-            };\n-            if let Some(&last_byte) = data.last() {\n-                if last_byte == CTRL_Z {\n-                    data.pop();\n-                }\n+        buf.copy_from_slice(&data);\n+        Ok(data.len())\n+    }\n+\n+    // We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our\n+    // buffer size, and keep it around for the next read hoping to put them together.\n+    // This is a best effort, and may not work if we are not the only reader on Stdin.\n+    pub fn read_u16s_fixup_surrogates(&self, handle: c::HANDLE, buf: &mut [u16], mut amount: usize)\n+        -> io::Result<usize>\n+    {\n+        // Insert possibly remaining unpaired surrogate from last read.\n+        let mut start = 0;\n+        if self.high_surrogate.get() != 0 {\n+            buf[0] = self.high_surrogate.replace(0);\n+            start = 1;\n+            if amount == 1 {\n+                // Special case: `Stdin::read` guarantees we can always read at least one new `u16`\n+                // and combine it with an unpaired surrogate, because the UTF-8 buffer is at least\n+                // 4 bytes.\n+                amount = 2;\n+            }\n+        }\n+        let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n+\n+        if amount > 0 {\n+            let last_char = buf[amount - 1];\n+            if last_char >= 0xD800 && last_char <= 0xDBFF { // high surrogate\n+                self.high_surrogate.set(last_char);\n+                amount -= 1;\n             }\n-            *utf8 = Cursor::new(data);\n         }\n+        Ok(amount)\n+    }\n+}\n+\n+fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n+    // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n+    // traditional DOS method to indicate end of character stream / user input (SUB).\n+    // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n+    const CTRL_Z: u16 = 0x1A;\n+    const CTRL_Z_MASK: c::ULONG = 1 << CTRL_Z;\n+    let mut input_control = c::CONSOLE_READCONSOLE_CONTROL {\n+        nLength: ::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n+        nInitialChars: 0,\n+        dwCtrlWakeupMask: CTRL_Z_MASK,\n+        dwControlKeyState: 0,\n+    };\n+\n+    let mut amount = 0;\n+    cvt(unsafe {\n+        c::ReadConsoleW(handle,\n+                        buf.as_mut_ptr() as c::LPVOID,\n+                        buf.len() as u32,\n+                        &mut amount,\n+                        &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL)\n+    })?;\n \n-        // MemReader shouldn't error here since we just filled it\n-        utf8.read(buf)\n+    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n+        amount -= 1;\n     }\n+    Ok(amount as usize)\n }\n \n impl Stdout {\n@@ -156,43 +251,10 @@ impl Stderr {\n     }\n }\n \n-impl Output {\n-    pub fn handle(&self) -> c::HANDLE {\n-        match *self {\n-            Output::Console(c) => c,\n-            Output::Pipe(c) => c,\n-        }\n-    }\n-}\n-\n-fn invalid_encoding() -> io::Error {\n-    io::Error::new(io::ErrorKind::InvalidData,\n-                   \"Windows stdio in console mode does not support non-UTF-8 byte sequences; \\\n-                    see https://github.com/rust-lang/rust/issues/23344\")\n-}\n-\n-fn readconsole_input_control(wakeup_mask: c::ULONG) -> c::CONSOLE_READCONSOLE_CONTROL {\n-    c::CONSOLE_READCONSOLE_CONTROL {\n-        nLength: ::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n-        nInitialChars: 0,\n-        dwCtrlWakeupMask: wakeup_mask,\n-        dwControlKeyState: 0,\n-    }\n-}\n-\n-const CTRL_Z: u8 = 0x1A;\n-const CTRL_Z_MASK: c::ULONG = 0x4000000; //1 << 0x1A\n-\n pub fn is_ebadf(err: &io::Error) -> bool {\n     err.raw_os_error() == Some(c::ERROR_INVALID_HANDLE as i32)\n }\n \n-// The default buffer capacity is 64k, but apparently windows\n-// doesn't like 64k reads on stdin. See #13304 for details, but the\n-// idea is that on windows we use a slightly smaller buffer that's\n-// been seen to be acceptable.\n-pub const STDIN_BUF_SIZE: usize = 8 * 1024;\n-\n pub fn panic_output() -> Option<impl io::Write> {\n     io::stderr_raw().ok()\n }"}]}