{"sha": "a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MWJiNzBmMGE5MzNjYTVlNzhjYTAyYTIwNWZkNGNiOTRlY2U0OGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-14T15:55:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-15T15:52:28Z"}, "message": "Store DB in SourceBinder", "tree": {"sha": "4619e31516d3a16506ec707d4d751b6eca03fd84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4619e31516d3a16506ec707d4d751b6eca03fd84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "html_url": "https://github.com/rust-lang/rust/commit/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccfe53376ac579c2874000a939ea8be331c626aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccfe53376ac579c2874000a939ea8be331c626aa", "html_url": "https://github.com/rust-lang/rust/commit/ccfe53376ac579c2874000a939ea8be331c626aa"}], "stats": {"total": 65, "additions": 33, "deletions": 32}, "files": [{"sha": "a2350573c7c5f5f568b5e7ceb332d560605333d0", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "patch": "@@ -48,6 +48,7 @@ pub use crate::{\n     from_source::FromSource,\n     has_source::HasSource,\n     source_analyzer::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n+    source_binder::SourceBinder,\n };\n \n pub use hir_def::{"}, {"sha": "186dd2411fb8130fda819a14c25660538f4d881d", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "patch": "@@ -105,7 +105,7 @@ impl SourceAnalyzer {\n         node: InFile<&SyntaxNode>,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n-        crate::source_binder::SourceBinder::default().analyze(db, node, offset)\n+        crate::source_binder::SourceBinder::new(db).analyze(node, offset)\n     }\n \n     pub(crate) fn new_for_body("}, {"sha": "8f002d2ee2ecbe7dfdf03dec5ccc7af542342b02", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a71bb70f0a933ca5e78ca02a205fd4cb94ece48e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=a71bb70f0a933ca5e78ca02a205fd4cb94ece48e", "patch": "@@ -18,48 +18,52 @@ use rustc_hash::FxHashMap;\n \n use crate::{db::HirDatabase, ModuleSource, SourceAnalyzer};\n \n-#[derive(Default)]\n-pub struct SourceBinder {\n+pub struct SourceBinder<'a, DB> {\n+    pub db: &'a DB,\n     child_by_source_cache: FxHashMap<ChildContainer, DynMap>,\n }\n \n-impl SourceBinder {\n+impl<DB: HirDatabase> SourceBinder<'_, DB> {\n+    pub fn new(db: &DB) -> SourceBinder<DB> {\n+        SourceBinder { db, child_by_source_cache: FxHashMap::default() }\n+    }\n+\n     pub fn analyze(\n         &mut self,\n-        db: &impl HirDatabase,\n         src: InFile<&SyntaxNode>,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n         let _p = profile(\"SourceBinder::analyzer\");\n-        let container = match self.find_container(db, src) {\n+        let container = match self.find_container(src) {\n             Some(it) => it,\n             None => return SourceAnalyzer::new_for_resolver(Resolver::default(), src),\n         };\n \n         let resolver = match container {\n             ChildContainer::DefWithBodyId(def) => {\n-                return SourceAnalyzer::new_for_body(db, def, src, offset)\n+                return SourceAnalyzer::new_for_body(self.db, def, src, offset)\n             }\n-            ChildContainer::TraitId(it) => it.resolver(db),\n-            ChildContainer::ImplId(it) => it.resolver(db),\n-            ChildContainer::ModuleId(it) => it.resolver(db),\n-            ChildContainer::EnumId(it) => it.resolver(db),\n-            ChildContainer::VariantId(it) => it.resolver(db),\n+            ChildContainer::TraitId(it) => it.resolver(self.db),\n+            ChildContainer::ImplId(it) => it.resolver(self.db),\n+            ChildContainer::ModuleId(it) => it.resolver(self.db),\n+            ChildContainer::EnumId(it) => it.resolver(self.db),\n+            ChildContainer::VariantId(it) => it.resolver(self.db),\n         };\n         SourceAnalyzer::new_for_resolver(resolver, src)\n     }\n \n-    pub fn to_def<D, ID>(&mut self, db: &impl HirDatabase, src: InFile<ID::Ast>) -> Option<D>\n+    pub fn to_def<D, ID>(&mut self, src: InFile<ID::Ast>) -> Option<D>\n     where\n         D: From<ID>,\n         ID: ToId,\n     {\n-        let id: ID = self.to_id(db, src)?;\n+        let id: ID = self.to_id(src)?;\n         Some(id.into())\n     }\n \n-    fn to_id<D: ToId>(&mut self, db: &impl HirDatabase, src: InFile<D::Ast>) -> Option<D> {\n-        let container = self.find_container(db, src.as_ref().map(|it| it.syntax()))?;\n+    fn to_id<D: ToId>(&mut self, src: InFile<D::Ast>) -> Option<D> {\n+        let container = self.find_container(src.as_ref().map(|it| it.syntax()))?;\n+        let db = self.db;\n         let dyn_map =\n             &*self.child_by_source_cache.entry(container).or_insert_with(|| match container {\n                 ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n@@ -72,44 +76,40 @@ impl SourceBinder {\n         dyn_map[D::KEY].get(&src).copied()\n     }\n \n-    fn find_container(\n-        &mut self,\n-        db: &impl HirDatabase,\n-        src: InFile<&SyntaxNode>,\n-    ) -> Option<ChildContainer> {\n-        for container in src.cloned().ancestors_with_macros(db).skip(1) {\n+    fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n+        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n             let res: ChildContainer = match_ast! {\n                 match (container.value) {\n                     ast::TraitDef(it) => {\n-                        let def: TraitId = self.to_id(db, container.with_value(it))?;\n+                        let def: TraitId = self.to_id(container.with_value(it))?;\n                         def.into()\n                     },\n                     ast::ImplBlock(it) => {\n-                        let def: ImplId = self.to_id(db, container.with_value(it))?;\n+                        let def: ImplId = self.to_id(container.with_value(it))?;\n                         def.into()\n                     },\n                     ast::FnDef(it) => {\n-                        let def: FunctionId = self.to_id(db, container.with_value(it))?;\n+                        let def: FunctionId = self.to_id(container.with_value(it))?;\n                         DefWithBodyId::from(def).into()\n                     },\n                     ast::StaticDef(it) => {\n-                        let def: StaticId = self.to_id(db, container.with_value(it))?;\n+                        let def: StaticId = self.to_id(container.with_value(it))?;\n                         DefWithBodyId::from(def).into()\n                     },\n                     ast::ConstDef(it) => {\n-                        let def: ConstId = self.to_id(db, container.with_value(it))?;\n+                        let def: ConstId = self.to_id(container.with_value(it))?;\n                         DefWithBodyId::from(def).into()\n                     },\n                     ast::EnumDef(it) => {\n-                        let def: EnumId = self.to_id(db, container.with_value(it))?;\n+                        let def: EnumId = self.to_id(container.with_value(it))?;\n                         def.into()\n                     },\n                     ast::StructDef(it) => {\n-                        let def: StructId = self.to_id(db, container.with_value(it))?;\n+                        let def: StructId = self.to_id(container.with_value(it))?;\n                         VariantId::from(def).into()\n                     },\n                     ast::UnionDef(it) => {\n-                        let def: UnionId = self.to_id(db, container.with_value(it))?;\n+                        let def: UnionId = self.to_id(container.with_value(it))?;\n                         VariantId::from(def).into()\n                     },\n                     // FIXME: handle out-of-line modules here\n@@ -119,8 +119,8 @@ impl SourceBinder {\n             return Some(res);\n         }\n \n-        let module_source = ModuleSource::from_child_node(db, src);\n-        let c = crate::Module::from_definition(db, src.with_value(module_source))?;\n+        let module_source = ModuleSource::from_child_node(self.db, src);\n+        let c = crate::Module::from_definition(self.db, src.with_value(module_source))?;\n         Some(c.id.into())\n     }\n }"}]}