{"sha": "14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0Y2IzMWZiODgzMjhhNWY5YTA3ZTAwYjA2ZDZiMGEwMTRmYmUxOTc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T07:12:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T21:46:53Z"}, "message": "permit bit-anding in pointer values below the alignment\n\nThis makes HashMap work!", "tree": {"sha": "e584c610b520f02edd190dc23ee33ae9d8f657a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e584c610b520f02edd190dc23ee33ae9d8f657a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "html_url": "https://github.com/rust-lang/rust/commit/14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "269667e152e9377dfe8894b661e110fbd773bdd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/269667e152e9377dfe8894b661e110fbd773bdd2", "html_url": "https://github.com/rust-lang/rust/commit/269667e152e9377dfe8894b661e110fbd773bdd2"}], "stats": {"total": 70, "additions": 50, "deletions": 20}, "files": [{"sha": "4cb66f2acdc87bfd401256478a49200c0f0f5ff1", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 StaticKind::Immutable => \" (immutable)\",\n                 StaticKind::NotStatic => \"\",\n             };\n-            trace!(\"{}({} bytes){}\", msg, alloc.bytes.len(), immutable);\n+            trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n             if !relocations.is_empty() {\n                 msg.clear();"}, {"sha": "58003331e6376e355e0268bd57ff85c5a11d75d4", "filename": "src/operator.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "patch": "@@ -190,19 +190,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n                 // These work if one operand is a pointer, the other an integer\n-                Add | Sub\n+                Add | BitAnd | Sub\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n                 && left.is_ptr() && right.is_bytes() => {\n                     // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                    let (res, over) = self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize)?;\n-                    return Ok((PrimVal::Ptr(res), over));\n+                    return self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize);\n                 }\n-                Add\n+                Add | BitAnd\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n                 && left.is_bytes() && right.is_ptr() => {\n                     // This is a commutative operation, just swap the operands\n-                    let (res, over) = self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize)?;\n-                    return Ok((PrimVal::Ptr(res), over));\n+                    return self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize);\n                 }\n                 _ => {}\n             }\n@@ -287,18 +285,40 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         left: Pointer,\n         right: i128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Pointer, bool)> {\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n \n+        fn map_to_primval((res, over) : (Pointer, bool)) -> (PrimVal, bool) {\n+            (PrimVal::Ptr(res), over)\n+        }\n+\n         Ok(match bin_op {\n             Sub =>\n                 // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                left.overflowing_signed_offset(-right, self.memory.layout),\n+                map_to_primval(left.overflowing_signed_offset(-right, self.memory.layout)),\n             Add if signed =>\n-                left.overflowing_signed_offset(right, self.memory.layout),\n+                map_to_primval(left.overflowing_signed_offset(right, self.memory.layout)),\n             Add if !signed =>\n-                left.overflowing_offset(right as u64, self.memory.layout),\n-            _ => bug!(\"ptr_int_arithmetic called on unsupported operation\")\n+                map_to_primval(left.overflowing_offset(right as u64, self.memory.layout)),\n+\n+            BitAnd if !signed => {\n+                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n+                let right = right as u64;\n+                if right & base_mask == base_mask {\n+                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n+                    (PrimVal::Ptr(Pointer::new(left.alloc_id, left.offset & right)), false)\n+                } else if right & base_mask == 0 {\n+                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n+                    (PrimVal::from_u128((left.offset & right) as u128), false)\n+                } else {\n+                    return Err(EvalError::ReadPointerAsBytes);\n+                }\n+            }\n+\n+            _ => {\n+                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n         })\n     }\n }"}, {"sha": "99630f6006f857ea343d9721c82f88a66d7938d6", "filename": "src/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "patch": "@@ -25,7 +25,7 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n \n pub(super) fn bytes_to_bool(n: u128) -> bool {\n     // FIXME(solson): Can we reach here due to user error?\n-    debug_assert!(n == 0 || n == 1, \"bytes interpreted as bool were {}\", n);\n+    assert!(n == 0 || n == 1, \"bytes interpreted as bool were {}\", n);\n     n & 1 == 1\n }\n "}, {"sha": "f4a358174f555bce8e38d0a3f9427d52fe0e93b9", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "patch": "@@ -2,14 +2,24 @@ use std::collections::{self, HashMap};\n use std::hash::BuildHasherDefault;\n \n fn main() {\n-    let map : HashMap<String, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+    let mut map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+    map.insert(0, 0);\n     assert_eq!(map.values().fold(0, |x, y| x+y), 0);\n \n-    // TODO: This performs bit operations on the least significant bit of a pointer\n-//     for i in 0..33 {\n-//         map.insert(format!(\"key_{}\", i), i);\n-//         assert_eq!(map.values().fold(0, |x, y| x+y), i*(i+1)/2);\n-//     }\n+    let table_base = map.get(&0).unwrap() as *const _;\n+\n+    let num = 22; // large enough to trigger a resize\n+    for i in 1..num {\n+        map.insert(i, i);\n+    }\n+    assert!(table_base != map.get(&0).unwrap() as *const _); // make sure relocation happened\n+    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2); // check the right things are in the table now\n+\n+    // Inserting again replaces the existing entries\n+    for i in 0..num {\n+        map.insert(i, num-1-i);\n+    }\n+    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2);\n \n     // TODO: Test Entry API\n }"}, {"sha": "81c19022ab080c4f1aa1be0107c24819ab67f910", "filename": "tests/run-pass/tag-align-dyn-u64.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/tests%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14cb31fb88328a5f9a07e00b06d6b0a014fbe197/tests%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=14cb31fb88328a5f9a07e00b06d6b0a014fbe197", "patch": "@@ -28,7 +28,7 @@ fn mk_rec() -> Rec {\n fn is_u64_aligned(u: &Tag<u64>) -> bool {\n     let p: usize = unsafe { mem::transmute(u) };\n     let u64_align = std::mem::align_of::<u64>();\n-    return (p & (u64_align - 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    return (p & (u64_align - 1)) == 0;\n }\n \n pub fn main() {", "previous_filename": "tests/compile-fail/tag-align-dyn-u64.rs"}]}