{"sha": "ab671552c3b44906b63c07f2676492b766f2a7c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNjcxNTUyYzNiNDQ5MDZiNjNjMDdmMjY3NjQ5MmI3NjZmMmE3YzM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-10-13T03:01:31Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-10-13T03:01:31Z"}, "message": "Refactor attr::Stability\n\nStricter checking + enforcement of invariants at compile time", "tree": {"sha": "5fcfa78f184afcc1bd1cf0cbf5be83f25ec720b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fcfa78f184afcc1bd1cf0cbf5be83f25ec720b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab671552c3b44906b63c07f2676492b766f2a7c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab671552c3b44906b63c07f2676492b766f2a7c3", "html_url": "https://github.com/rust-lang/rust/commit/ab671552c3b44906b63c07f2676492b766f2a7c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab671552c3b44906b63c07f2676492b766f2a7c3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "843e528fd0c09666cc5f2896258f88c25eaacb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/843e528fd0c09666cc5f2896258f88c25eaacb29", "html_url": "https://github.com/rust-lang/rust/commit/843e528fd0c09666cc5f2896258f88c25eaacb29"}], "stats": {"total": 1185, "additions": 299, "deletions": 886}, "files": [{"sha": "f38ee19a2740a8ca506264d0dedd46173d8e8fd0", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -11,6 +11,8 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n+pub use self::StabilityLevel::*;\n+\n use session::Session;\n use lint;\n use metadata::cstore::LOCAL_CRATE;\n@@ -34,6 +36,18 @@ use rustc_front::visit::{self, FnKind, Visitor};\n use std::mem::replace;\n use std::cmp::Ordering;\n \n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Copy, Debug, Eq, Hash)]\n+pub enum StabilityLevel {\n+    Unstable,\n+    Stable,\n+}\n+\n+impl StabilityLevel {\n+    pub fn from_attr_level(level: &attr::StabilityLevel) -> Self {\n+        if level.is_stable() { Stable } else { Unstable }\n+    }\n+}\n+\n /// A stability index, giving the stability level for items and methods.\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n@@ -67,20 +81,19 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     // if parent is deprecated and we're not, inherit this by merging\n                     // deprecated_since and its reason.\n                     if let Some(parent_stab) = self.parent {\n-                        if parent_stab.deprecated_since.is_some()\n-                        && stab.deprecated_since.is_none() {\n-                            stab.deprecated_since = parent_stab.deprecated_since.clone();\n-                            stab.reason = parent_stab.reason.clone();\n+                        if parent_stab.depr.is_some()\n+                        && stab.depr.is_none() {\n+                            stab.depr = parent_stab.depr.clone()\n                         }\n                     }\n \n                     let stab = self.tcx.intern_stability(stab);\n \n                     // Check if deprecated_since < stable_since. If it is,\n                     // this is *almost surely* an accident.\n-                    let deprecated_predates_stable = match (stab.deprecated_since.as_ref(),\n-                                                            stab.since.as_ref()) {\n-                        (Some(dep_since), Some(stab_since)) => {\n+                    let deprecated_predates_stable = match (&stab.depr, &stab.level) {\n+                        (&Some(attr::Deprecation {since: ref dep_since, ..}),\n+                               &attr::Stable {since: ref stab_since}) => {\n                             // explicit version of iter::order::lt to handle parse errors properly\n                             let mut is_less = false;\n                             for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n@@ -117,7 +130,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     self.index.map.insert(def_id, Some(stab));\n \n                     // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                    if stab.level != attr::Stable {\n+                    if !stab.level.is_stable() {\n                         let parent = replace(&mut self.parent, Some(stab));\n                         f(self);\n                         self.parent = parent;\n@@ -261,7 +274,7 @@ impl<'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n-                                -> FnvHashMap<InternedString, attr::StabilityLevel> {\n+                                -> FnvHashMap<InternedString, StabilityLevel> {\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n     // Put the active features into a map for quick lookup\n@@ -284,7 +297,7 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n struct Checker<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     active_features: FnvHashSet<InternedString>,\n-    used_features: FnvHashMap<InternedString, attr::StabilityLevel>,\n+    used_features: FnvHashMap<InternedString, StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -303,22 +316,21 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         }\n \n         match *stab {\n-            Some(&Stability { level: attr::Unstable, ref feature, ref reason, issue, .. }) => {\n-                self.used_features.insert(feature.clone(), attr::Unstable);\n+            Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n+                self.used_features.insert(feature.clone(), Unstable);\n \n                 if !self.active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n                                                &feature, &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n-\n                     emit_feature_err(&self.tcx.sess.parse_sess.span_diagnostic,\n-                                      &feature, span, GateIssue::Library(issue), &msg);\n+                                      &feature, span, GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n-            Some(&Stability { level, ref feature, .. }) => {\n-                self.used_features.insert(feature.clone(), level);\n+            Some(&Stability { ref level, ref feature, .. }) => {\n+                self.used_features.insert(feature.clone(), StabilityLevel::from_attr_level(level));\n \n                 // Stable APIs are always ok to call and deprecated APIs are\n                 // handled by a lint.\n@@ -636,7 +648,7 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n                                        lib_features_used: &FnvHashMap<InternedString,\n-                                                                      attr::StabilityLevel>) {\n+                                                                      StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n     let mut remaining_lib_features: FnvHashMap<InternedString, Span>\n         = declared_lib_features.clone().into_iter().collect();\n@@ -653,7 +665,7 @@ pub fn check_unused_or_stable_features(sess: &Session,\n     for (used_lib_feature, level) in lib_features_used {\n         match remaining_lib_features.remove(used_lib_feature) {\n             Some(span) => {\n-                if *level == attr::Stable {\n+                if *level == Stable {\n                     sess.add_lint(lint::builtin::STABLE_FEATURES,\n                                   ast::CRATE_NODE_ID,\n                                   span,"}, {"sha": "1a564eb28a3a039874bde3aacff131ac1d33dfed", "filename": "src/librustc_front/attr.rs", "status": "removed", "additions": 0, "deletions": 625, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/843e528fd0c09666cc5f2896258f88c25eaacb29/src%2Flibrustc_front%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843e528fd0c09666cc5f2896258f88c25eaacb29/src%2Flibrustc_front%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fattr.rs?ref=843e528fd0c09666cc5f2896258f88c25eaacb29", "patch": "@@ -1,625 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Functions dealing with attributes and meta items\n-\n-pub use self::StabilityLevel::*;\n-pub use self::ReprAttr::*;\n-pub use self::IntType::*;\n-\n-use hir;\n-use syntax::codemap::{Span, Spanned, spanned, dummy_spanned};\n-use syntax::codemap::BytePos;\n-use syntax::diagnostic::SpanHandler;\n-use syntax::attr as syntax_attr;\n-use syntax::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use syntax::parse::token::{InternedString, intern_and_get_ident};\n-use syntax::parse::token;\n-use syntax::ptr::P;\n-\n-use std::cell::Cell;\n-use std::collections::HashSet;\n-use std::fmt;\n-\n-pub fn mark_used(attr: &Attribute) {\n-    syntax_attr::mark_used(&unlower_attribute(attr))\n-}\n-\n-pub trait AttrMetaMethods {\n-    fn check_name(&self, name: &str) -> bool {\n-        name == &self.name()[..]\n-    }\n-\n-    /// Retrieve the name of the meta item, e.g. `foo` in `#[foo]`,\n-    /// `#[foo=\"bar\"]` and `#[foo(bar)]`\n-    fn name(&self) -> InternedString;\n-\n-    /// Gets the string value if self is a MetaNameValue variant\n-    /// containing a string, otherwise None.\n-    fn value_str(&self) -> Option<InternedString>;\n-    /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]>;\n-\n-    fn span(&self) -> Span;\n-}\n-\n-impl AttrMetaMethods for Attribute {\n-    fn check_name(&self, name: &str) -> bool {\n-        let matches = name == &self.name()[..];\n-        if matches {\n-            syntax_attr::mark_used(&unlower_attribute(self));\n-        }\n-        matches\n-    }\n-    fn name(&self) -> InternedString { self.meta().name() }\n-    fn value_str(&self) -> Option<InternedString> {\n-        self.meta().value_str()\n-    }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n-        self.node.value.meta_item_list()\n-    }\n-    fn span(&self) -> Span { self.meta().span }\n-}\n-\n-impl AttrMetaMethods for MetaItem {\n-    fn name(&self) -> InternedString {\n-        match self.node {\n-            MetaWord(ref n) => (*n).clone(),\n-            MetaNameValue(ref n, _) => (*n).clone(),\n-            MetaList(ref n, _) => (*n).clone(),\n-        }\n-    }\n-\n-    fn value_str(&self) -> Option<InternedString> {\n-        match self.node {\n-            MetaNameValue(_, ref v) => {\n-                match v.node {\n-                    hir::LitStr(ref s, _) => Some((*s).clone()),\n-                    _ => None,\n-                }\n-            },\n-            _ => None\n-        }\n-    }\n-\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n-        match self.node {\n-            MetaList(_, ref l) => Some(&l[..]),\n-            _ => None\n-        }\n-    }\n-    fn span(&self) -> Span { self.span }\n-}\n-\n-// Annoying, but required to get test_cfg to work\n-impl AttrMetaMethods for P<MetaItem> {\n-    fn name(&self) -> InternedString { (**self).name() }\n-    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n-        (**self).meta_item_list()\n-    }\n-    fn span(&self) -> Span { (**self).span() }\n-}\n-\n-\n-pub trait AttributeMethods {\n-    fn meta<'a>(&'a self) -> &'a MetaItem;\n-    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&Attribute) -> T;\n-}\n-\n-impl AttributeMethods for Attribute {\n-    /// Extract the MetaItem from inside this Attribute.\n-    fn meta<'a>(&'a self) -> &'a MetaItem {\n-        &*self.node.value\n-    }\n-\n-    /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n-    /// comment like `///` or `/** */`. (Returns self unchanged for\n-    /// non-sugared doc attributes.)\n-    fn with_desugared_doc<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&Attribute) -> T,\n-    {\n-        if self.node.is_sugared_doc {\n-            let comment = self.value_str().unwrap();\n-            let meta = mk_name_value_item_str(\n-                InternedString::new(\"doc\"),\n-                token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        &comment)));\n-            if self.node.style == hir::AttrOuter {\n-                f(&mk_attr_outer(self.node.id, meta))\n-            } else {\n-                f(&mk_attr_inner(self.node.id, meta))\n-            }\n-        } else {\n-            f(self)\n-        }\n-    }\n-}\n-\n-/* Constructors */\n-\n-pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> P<MetaItem> {\n-    let value_lit = dummy_spanned(hir::LitStr(value, hir::CookedStr));\n-    mk_name_value_item(name, value_lit)\n-}\n-\n-pub fn mk_name_value_item(name: InternedString, value: hir::Lit)\n-                          -> P<MetaItem> {\n-    P(dummy_spanned(MetaNameValue(name, value)))\n-}\n-\n-pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n-    P(dummy_spanned(MetaList(name, items)))\n-}\n-\n-pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n-    P(dummy_spanned(MetaWord(name)))\n-}\n-\n-thread_local! { static NEXT_ATTR_ID: Cell<usize> = Cell::new(0) }\n-\n-pub fn mk_attr_id() -> AttrId {\n-    let id = NEXT_ATTR_ID.with(|slot| {\n-        let r = slot.get();\n-        slot.set(r + 1);\n-        r\n-    });\n-    AttrId(id)\n-}\n-\n-/// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n-    dummy_spanned(Attribute_ {\n-        id: id,\n-        style: hir::AttrStyle::Inner,\n-        value: item,\n-        is_sugared_doc: false,\n-    })\n-}\n-\n-/// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n-    dummy_spanned(Attribute_ {\n-        id: id,\n-        style: hir::AttrStyle::Outer,\n-        value: item,\n-        is_sugared_doc: false,\n-    })\n-}\n-\n-pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n-                           hi: BytePos)\n-                           -> Attribute {\n-    let style = lower_attr_style(doc_comment_style(&text));\n-    let lit = spanned(lo, hi, hir::LitStr(text, hir::CookedStr));\n-    let attr = Attribute_ {\n-        id: id,\n-        style: style,\n-        value: P(spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n-                                               lit))),\n-        is_sugared_doc: true\n-    };\n-    spanned(lo, hi, attr)\n-}\n-\n-/* Searching */\n-/// Check if `needle` occurs in `haystack` by a structural\n-/// comparison. This is slightly subtle, and relies on ignoring the\n-/// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n-    debug!(\"attr::contains (name={})\", needle.name());\n-    haystack.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n-        item.node == needle.node\n-    })\n-}\n-\n-pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n-    debug!(\"attr::contains_name (name={})\", name);\n-    metas.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n-        item.check_name(name)\n-    })\n-}\n-\n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n-                                 -> Option<InternedString> {\n-    attrs.iter()\n-        .find(|at| at.check_name(name))\n-        .and_then(|at| at.value_str())\n-}\n-\n-pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n-                                     -> Option<InternedString> {\n-    items.iter()\n-         .rev()\n-         .find(|mi| mi.check_name(name))\n-         .and_then(|i| i.value_str())\n-}\n-\n-/* Higher-level applications */\n-\n-pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n-    // This is sort of stupid here, but we need to sort by\n-    // human-readable strings.\n-    let mut v = items.into_iter()\n-        .map(|mi| (mi.name(), mi))\n-        .collect::<Vec<(InternedString, P<MetaItem>)>>();\n-\n-    v.sort_by(|&(ref a, _), &(ref b, _)| a.cmp(b));\n-\n-    // There doesn't seem to be a more optimal way to do this\n-    v.into_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n-        Spanned {\n-            node: match node {\n-                MetaList(n, mis) => MetaList(n, sort_meta_items(mis)),\n-                _ => node\n-            },\n-            span: span\n-        }\n-    })).collect()\n-}\n-\n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n-    first_attr_value_str_by_name(attrs, \"crate_name\")\n-}\n-\n-/// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &SpanHandler, attrs: &[Attribute]) -> Option<InternedString> {\n-    attrs.iter().fold(None, |ia,attr| {\n-        if attr.check_name(\"export_name\") {\n-            if let s@Some(_) = attr.value_str() {\n-                s\n-            } else {\n-                diag.span_err(attr.span, \"export_name attribute has invalid format\");\n-                diag.handler.help(\"use #[export_name=\\\"*\\\"]\");\n-                None\n-            }\n-        } else {\n-            ia\n-        }\n-    })\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum InlineAttr {\n-    None,\n-    Hint,\n-    Always,\n-    Never,\n-}\n-\n-/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&SpanHandler>, attrs: &[Attribute]) -> InlineAttr {\n-    attrs.iter().fold(InlineAttr::None, |ia,attr| {\n-        match attr.node.value.node {\n-            MetaWord(ref n) if *n == \"inline\" => {\n-                syntax_attr::mark_used(&unlower_attribute(attr));\n-                InlineAttr::Hint\n-            }\n-            MetaList(ref n, ref items) if *n == \"inline\" => {\n-                syntax_attr::mark_used(&unlower_attribute(attr));\n-                if items.len() != 1 {\n-                    diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n-                    InlineAttr::None\n-                } else if contains_name(&items[..], \"always\") {\n-                    InlineAttr::Always\n-                } else if contains_name(&items[..], \"never\") {\n-                    InlineAttr::Never\n-                } else {\n-                    diagnostic.map(|d|{ d.span_err((*items[0]).span, \"invalid argument\"); });\n-                    InlineAttr::None\n-                }\n-            }\n-            _ => ia\n-        }\n-    })\n-}\n-\n-/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n-pub fn requests_inline(attrs: &[Attribute]) -> bool {\n-    match find_inline_attr(None, attrs) {\n-        InlineAttr::Hint | InlineAttr::Always => true,\n-        InlineAttr::None | InlineAttr::Never => false,\n-    }\n-}\n-\n-/// Represents the #[deprecated] and friends attributes.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct Stability {\n-    pub level: StabilityLevel,\n-    pub feature: InternedString,\n-    pub since: Option<InternedString>,\n-    pub deprecated_since: Option<InternedString>,\n-    // The reason for the current stability level. If deprecated, the\n-    // reason for deprecation.\n-    pub reason: Option<InternedString>,\n-    // The relevant rust-lang issue\n-    pub issue: Option<u32>\n-}\n-\n-/// The available stability levels.\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Copy, Eq, Hash)]\n-pub enum StabilityLevel {\n-    Unstable,\n-    Stable,\n-}\n-\n-impl fmt::Display for StabilityLevel {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-fn find_stability_generic<'a,\n-                              AM: AttrMetaMethods,\n-                              I: Iterator<Item=&'a AM>>\n-                             (diagnostic: &SpanHandler, attrs: I, item_sp: Span)\n-                             -> (Option<Stability>, Vec<&'a AM>) {\n-\n-    let mut stab: Option<Stability> = None;\n-    let mut deprecated: Option<(Option<InternedString>, Option<InternedString>)> = None;\n-    let mut used_attrs: Vec<&'a AM> = vec![];\n-\n-    'outer: for attr in attrs {\n-        let tag = attr.name();\n-        let tag = &tag[..];\n-        if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n-            continue // not a stability level\n-        }\n-\n-        used_attrs.push(attr);\n-\n-        let (feature, since, reason, issue) = match attr.meta_item_list() {\n-            Some(metas) => {\n-                let mut feature = None;\n-                let mut since = None;\n-                let mut reason = None;\n-                let mut issue = None;\n-                for meta in metas {\n-                    match &*meta.name() {\n-                        \"feature\" => {\n-                            match meta.value_str() {\n-                                Some(v) => feature = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n-                        }\n-                        \"since\" => {\n-                            match meta.value_str() {\n-                                Some(v) => since = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n-                        }\n-                        \"reason\" => {\n-                            match meta.value_str() {\n-                                Some(v) => reason = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n-                        }\n-                        \"issue\" => {\n-                            match meta.value_str().and_then(|s| s.parse().ok()) {\n-                                Some(v) => issue = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-                (feature, since, reason, issue)\n-            }\n-            None => {\n-                diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n-                continue\n-            }\n-        };\n-\n-        // Deprecated tags don't require feature names\n-        if feature == None && tag != \"deprecated\" {\n-            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n-        }\n-\n-        // Unstable tags don't require a version\n-        if since == None && tag != \"unstable\" {\n-            diagnostic.span_err(attr.span(), \"missing 'since'\");\n-        }\n-\n-        if tag == \"unstable\" || tag == \"stable\" {\n-            if stab.is_some() {\n-                diagnostic.span_err(item_sp, \"multiple stability levels\");\n-            }\n-\n-            let level = match tag {\n-                \"unstable\" => Unstable,\n-                \"stable\" => Stable,\n-                _ => unreachable!()\n-            };\n-\n-            stab = Some(Stability {\n-                level: level,\n-                feature: feature.unwrap_or(intern_and_get_ident(\"bogus\")),\n-                since: since,\n-                deprecated_since: None,\n-                reason: reason,\n-                issue: issue,\n-            });\n-        } else { // \"deprecated\"\n-            if deprecated.is_some() {\n-                diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n-            }\n-\n-            deprecated = Some((since, reason));\n-        }\n-    }\n-\n-    // Merge the deprecation info into the stability info\n-    if deprecated.is_some() {\n-        match stab {\n-            Some(ref mut s) => {\n-                let (since, reason) = deprecated.unwrap();\n-                s.deprecated_since = since;\n-                s.reason = reason;\n-            }\n-            None => {\n-                diagnostic.span_err(item_sp, \"deprecated attribute must be paired with \\\n-                                              either stable or unstable attribute\");\n-            }\n-        }\n-    } else if stab.as_ref().map_or(false, |s| s.level == Unstable && s.issue.is_none()) {\n-        // non-deprecated unstable items need to point to issues.\n-        diagnostic.span_err(item_sp,\n-                            \"non-deprecated unstable items need to point \\\n-                             to an issue with `issue = \\\"NNN\\\"`\");\n-    }\n-\n-    (stab, used_attrs)\n-}\n-\n-/// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n-                      item_sp: Span) -> Option<Stability> {\n-    let (s, used) = find_stability_generic(diagnostic, attrs.iter(), item_sp);\n-    for used in used { syntax_attr::mark_used(&unlower_attribute(used)) }\n-    return s;\n-}\n-\n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n-    let mut set = HashSet::new();\n-    for meta in metas {\n-        let name = meta.name();\n-\n-        if !set.insert(name.clone()) {\n-            panic!(diagnostic.span_fatal(meta.span,\n-                                  &format!(\"duplicate meta item `{}`\", name)));\n-        }\n-    }\n-}\n-\n-\n-/// Parse #[repr(...)] forms.\n-///\n-/// Valid repr contents: any of the primitive integral type names (see\n-/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n-/// the same discriminant size that the corresponding C enum would or C\n-/// structure layout, and `packed` to remove padding.\n-pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n-    let mut acc = Vec::new();\n-    match attr.node.value.node {\n-        hir::MetaList(ref s, ref items) if *s == \"repr\" => {\n-            syntax_attr::mark_used(&unlower_attribute(attr));\n-            for item in items {\n-                match item.node {\n-                    hir::MetaWord(ref word) => {\n-                        let hint = match &word[..] {\n-                            // Can't use \"extern\" because it's not a lexical identifier.\n-                            \"C\" => Some(ReprExtern),\n-                            \"packed\" => Some(ReprPacked),\n-                            \"simd\" => Some(ReprSimd),\n-                            _ => match int_type_of_word(&word) {\n-                                Some(ity) => Some(ReprInt(item.span, ity)),\n-                                None => {\n-                                    // Not a word we recognize\n-                                    diagnostic.span_err(item.span,\n-                                                        \"unrecognized representation hint\");\n-                                    None\n-                                }\n-                            }\n-                        };\n-\n-                        match hint {\n-                            Some(h) => acc.push(h),\n-                            None => { }\n-                        }\n-                    }\n-                    // Not a word:\n-                    _ => diagnostic.span_err(item.span, \"unrecognized enum representation hint\")\n-                }\n-            }\n-        }\n-        // Not a \"repr\" hint: ignore.\n-        _ => { }\n-    }\n-    acc\n-}\n-\n-fn int_type_of_word(s: &str) -> Option<IntType> {\n-    match s {\n-        \"i8\" => Some(SignedInt(hir::TyI8)),\n-        \"u8\" => Some(UnsignedInt(hir::TyU8)),\n-        \"i16\" => Some(SignedInt(hir::TyI16)),\n-        \"u16\" => Some(UnsignedInt(hir::TyU16)),\n-        \"i32\" => Some(SignedInt(hir::TyI32)),\n-        \"u32\" => Some(UnsignedInt(hir::TyU32)),\n-        \"i64\" => Some(SignedInt(hir::TyI64)),\n-        \"u64\" => Some(UnsignedInt(hir::TyU64)),\n-        \"isize\" => Some(SignedInt(hir::TyIs)),\n-        \"usize\" => Some(UnsignedInt(hir::TyUs)),\n-        _ => None\n-    }\n-}\n-\n-#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub enum ReprAttr {\n-    ReprAny,\n-    ReprInt(Span, IntType),\n-    ReprExtern,\n-    ReprPacked,\n-    ReprSimd,\n-}\n-\n-impl ReprAttr {\n-    pub fn is_ffi_safe(&self) -> bool {\n-        match *self {\n-            ReprAny => false,\n-            ReprInt(_sp, ity) => ity.is_ffi_safe(),\n-            ReprExtern => true,\n-            ReprPacked => false,\n-            ReprSimd => true,\n-        }\n-    }\n-}\n-\n-#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub enum IntType {\n-    SignedInt(hir::IntTy),\n-    UnsignedInt(hir::UintTy)\n-}\n-\n-impl IntType {\n-    #[inline]\n-    pub fn is_signed(self) -> bool {\n-        match self {\n-            SignedInt(..) => true,\n-            UnsignedInt(..) => false\n-        }\n-    }\n-    fn is_ffi_safe(self) -> bool {\n-        match self {\n-            SignedInt(hir::TyI8) | UnsignedInt(hir::TyU8) |\n-            SignedInt(hir::TyI16) | UnsignedInt(hir::TyU16) |\n-            SignedInt(hir::TyI32) | UnsignedInt(hir::TyU32) |\n-            SignedInt(hir::TyI64) | UnsignedInt(hir::TyU64) => true,\n-            SignedInt(hir::TyIs) | UnsignedInt(hir::TyUs) => false\n-        }\n-    }\n-}"}, {"sha": "490f57e6607301a630e08b0531c63e142fcb46a1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -674,7 +674,7 @@ impl Stability {\n             span: Span, stability: &Option<&attr::Stability>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n-            Some(&attr::Stability { deprecated_since: Some(_), .. }) =>\n+            Some(&attr::Stability { depr: Some(_), .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n             _ => return\n         };\n@@ -684,8 +684,8 @@ impl Stability {\n         fn output(cx: &LateContext, span: Span, stability: &Option<&attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n-                Some(&attr::Stability { reason: Some(ref s), .. }) => {\n-                    format!(\"use of {} item: {}\", label, *s)\n+                Some(&attr::Stability {depr: Some(attr::Deprecation {ref reason, ..}), ..}) => {\n+                    format!(\"use of {} item: {}\", label, reason)\n                 }\n                 _ => format!(\"use of {} item\", label)\n             };\n@@ -695,20 +695,6 @@ impl Stability {\n     }\n }\n \n-fn hir_to_ast_stability(stab: &attr::Stability) -> attr::Stability {\n-    attr::Stability {\n-        level: match stab.level {\n-            attr::Unstable => attr::Unstable,\n-            attr::Stable => attr::Stable,\n-        },\n-        feature: stab.feature.clone(),\n-        since: stab.since.clone(),\n-        deprecated_since: stab.deprecated_since.clone(),\n-        reason: stab.reason.clone(),\n-        issue: stab.issue,\n-    }\n-}\n-\n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DEPRECATED)\n@@ -719,36 +705,31 @@ impl LateLintPass for Stability {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         stability::check_item(cx.tcx, item, false,\n                               &mut |id, sp, stab|\n-                                self.lint(cx, id, sp,\n-                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n+                                self.lint(cx, id, sp, &stab));\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab|\n-                                self.lint(cx, id, sp,\n-                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n+                                self.lint(cx, id, sp, &stab));\n     }\n \n     fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n         stability::check_path(cx.tcx, path, id,\n                               &mut |id, sp, stab|\n-                                self.lint(cx, id, sp,\n-                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n+                                self.lint(cx, id, sp, &stab));\n     }\n \n     fn check_path_list_item(&mut self, cx: &LateContext, item: &hir::PathListItem) {\n         stability::check_path_list_item(cx.tcx, item,\n                                          &mut |id, sp, stab|\n-                                           self.lint(cx, id, sp,\n-                                                &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n+                                           self.lint(cx, id, sp, &stab));\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         stability::check_pat(cx.tcx, pat,\n                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp,\n-                                          &stab.map(|s| hir_to_ast_stability(s)).as_ref()));\n+                                self.lint(cx, id, sp, &stab));\n     }\n }\n "}, {"sha": "88e254b86b213bf6f55deebae31890545bb2ece7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -324,8 +324,8 @@ impl Item {\n         match self.stability {\n             Some(ref s) => {\n                 let mut base = match s.level {\n-                    attr::Unstable => \"unstable\".to_string(),\n-                    attr::Stable => String::new(),\n+                    stability::Unstable => \"unstable\".to_string(),\n+                    stability::Stable => String::new(),\n                 };\n                 if !s.deprecated_since.is_empty() {\n                     base.push_str(\" deprecated\");\n@@ -2679,7 +2679,7 @@ impl Clean<Item> for doctree::Macro {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Stability {\n-    pub level: attr::StabilityLevel,\n+    pub level: stability::StabilityLevel,\n     pub feature: String,\n     pub since: String,\n     pub deprecated_since: String,\n@@ -2690,32 +2690,31 @@ pub struct Stability {\n impl Clean<Stability> for attr::Stability {\n     fn clean(&self, _: &DocContext) -> Stability {\n         Stability {\n-            level: self.level,\n+            level: stability::StabilityLevel::from_attr_level(&self.level),\n             feature: self.feature.to_string(),\n-            since: self.since.as_ref().map_or(\"\".to_string(),\n-                                              |interned| interned.to_string()),\n-            deprecated_since: self.deprecated_since.as_ref().map_or(\"\".to_string(),\n-                                                                    |istr| istr.to_string()),\n-            reason: self.reason.as_ref().map_or(\"\".to_string(),\n-                                                |interned| interned.to_string()),\n-            issue: self.issue,\n+            since: match self.level {\n+                attr::Stable {ref since} => since.to_string(),\n+                _ => \"\".to_string(),\n+            },\n+            deprecated_since: match self.depr {\n+                Some(attr::Deprecation {ref since, ..}) => since.to_string(),\n+                _=> \"\".to_string(),\n+            },\n+            reason: match self.level {\n+                attr::Unstable {reason: Some(ref reason), ..} => reason.to_string(),\n+                _ => \"\".to_string(),\n+            },\n+            issue: match self.level {\n+                attr::Unstable {issue, ..} => Some(issue),\n+                _ => None,\n+            }\n         }\n     }\n }\n \n impl<'a> Clean<Stability> for &'a attr::Stability {\n-    fn clean(&self, _: &DocContext) -> Stability {\n-        Stability {\n-            level: self.level,\n-            feature: self.feature.to_string(),\n-            since: self.since.as_ref().map_or(\"\".to_string(),\n-                                              |interned| interned.to_string()),\n-            deprecated_since: self.deprecated_since.as_ref().map_or(\"\".to_string(),\n-                                                                    |istr| istr.to_string()),\n-            reason: self.reason.as_ref().map_or(\"\".to_string(),\n-                                                |interned| interned.to_string()),\n-            issue: self.issue,\n-        }\n+    fn clean(&self, dc: &DocContext) -> Stability {\n+        (**self).clean(dc)\n     }\n }\n "}, {"sha": "d6fee744da677c1e23b620a82aa7a4d5b688a2b4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -52,9 +52,10 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{self, ToJson};\n-use syntax::{abi, ast, attr};\n+use syntax::{abi, ast};\n use rustc::metadata::cstore::LOCAL_CRATE;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::middle::stability;\n use rustc::util::nodemap::DefIdSet;\n use rustc_front::hir;\n \n@@ -1608,8 +1609,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         let s1 = i1.stability.as_ref().map(|s| s.level);\n         let s2 = i2.stability.as_ref().map(|s| s.level);\n         match (s1, s2) {\n-            (Some(attr::Unstable), Some(attr::Stable)) => return Ordering::Greater,\n-            (Some(attr::Stable), Some(attr::Unstable)) => return Ordering::Less,\n+            (Some(stability::Unstable), Some(stability::Stable)) => return Ordering::Greater,\n+            (Some(stability::Stable), Some(stability::Unstable)) => return Ordering::Less,\n             _ => {}\n         }\n         i1.name.cmp(&i2.name)\n@@ -1724,7 +1725,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n                 String::new()\n             };\n             format!(\"Deprecated{}{}\", since, Markdown(&reason))\n-        } else if stab.level == attr::Unstable {\n+        } else if stab.level == stability::Unstable {\n             let unstable_extra = if show_reason {\n                 match (!stab.feature.is_empty(), &cx.issue_tracker_base_url, stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) =>"}, {"sha": "eeb832d48b0d89675574a2eab825bfd9debeafa4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 171, "deletions": 123, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -27,7 +27,6 @@ use ptr::P;\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashSet;\n-use std::fmt;\n \n thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n@@ -382,174 +381,223 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n     }\n }\n \n-/// Represents the #[deprecated] and friends attributes.\n+/// Represents the #[stable], #[unstable] and #[deprecated] attributes.\n #[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: InternedString,\n-    pub since: Option<InternedString>,\n-    pub deprecated_since: Option<InternedString>,\n-    // The reason for the current stability level. If deprecated, the\n-    // reason for deprecation.\n-    pub reason: Option<InternedString>,\n-    // The relevant rust-lang issue\n-    pub issue: Option<u32>\n+    pub depr: Option<Deprecation>,\n }\n \n /// The available stability levels.\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Copy, Eq, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n-    Unstable,\n-    Stable,\n+    // Reason for the current stability level and the relevant rust-lang issue\n+    Unstable { reason: Option<InternedString>, issue: u32 },\n+    Stable { since: InternedString },\n }\n \n-impl fmt::Display for StabilityLevel {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(self, f)\n-    }\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct Deprecation {\n+    pub since: InternedString,\n+    pub reason: InternedString,\n }\n \n-fn find_stability_generic<'a,\n-                              AM: AttrMetaMethods,\n-                              I: Iterator<Item=&'a AM>>\n-                             (diagnostic: &SpanHandler, attrs: I, item_sp: Span)\n-                             -> (Option<Stability>, Vec<&'a AM>) {\n+impl StabilityLevel {\n+    pub fn is_unstable(&self) -> bool { if let Unstable {..} = *self { true } else { false }}\n+    pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n+}\n \n+fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n+                                 attrs_iter: I,\n+                                 item_sp: Span)\n+                                 -> Option<Stability>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n     let mut stab: Option<Stability> = None;\n-    let mut deprecated: Option<(Option<InternedString>, Option<InternedString>)> = None;\n-    let mut used_attrs: Vec<&'a AM> = vec![];\n+    let mut depr: Option<Deprecation> = None;\n \n-    'outer: for attr in attrs {\n+    'outer: for attr in attrs_iter {\n         let tag = attr.name();\n-        let tag = &tag[..];\n+        let tag = &*tag;\n         if tag != \"deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n \n-        used_attrs.push(attr);\n-\n-        let (feature, since, reason, issue) = match attr.meta_item_list() {\n-            Some(metas) => {\n-                let mut feature = None;\n-                let mut since = None;\n-                let mut reason = None;\n-                let mut issue = None;\n-                for meta in metas {\n-                    match &*meta.name() {\n-                        \"feature\" => {\n-                            match meta.value_str() {\n-                                Some(v) => feature = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n+        mark_used(attr);\n+\n+        if let Some(metas) = attr.meta_item_list() {\n+            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+                if item.is_some() {\n+                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n+                                                             meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            match tag {\n+                \"deprecated\" => {\n+                    if depr.is_some() {\n+                        diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+                        break\n+                    }\n+\n+                    let mut since = None;\n+                    let mut reason = None;\n+                    for meta in metas {\n+                        match &*meta.name() {\n+                            \"since\" => if !get(meta, &mut since) { continue 'outer },\n+                            \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n+                            _ => {\n+                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n+                                                                        meta.name()));\n+                                continue 'outer\n                             }\n                         }\n-                        \"since\" => {\n-                            match meta.value_str() {\n-                                Some(v) => since = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n+                    }\n+\n+                    match (since, reason) {\n+                        (Some(since), Some(reason)) => {\n+                            depr = Some(Deprecation {\n+                                since: since,\n+                                reason: reason,\n+                            })\n                         }\n-                        \"reason\" => {\n-                            match meta.value_str() {\n-                                Some(v) => reason = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n+                        (None, _) => {\n+                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            continue\n                         }\n-                        \"issue\" => {\n-                            match meta.value_str().and_then(|s| s.parse().ok()) {\n-                                Some(v) => issue = Some(v),\n-                                None => {\n-                                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n-                                    continue 'outer;\n-                                }\n-                            }\n+                        _ => {\n+                            diagnostic.span_err(attr.span(), \"missing 'reason'\");\n+                            continue\n                         }\n-                        _ => {}\n                     }\n                 }\n-                (feature, since, reason, issue)\n-            }\n-            None => {\n-                diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n-                continue\n-            }\n-        };\n+                \"unstable\" => {\n+                    if stab.is_some() {\n+                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        break\n+                    }\n \n-        // Deprecated tags don't require feature names\n-        if feature == None && tag != \"deprecated\" {\n-            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n-        }\n+                    let mut feature = None;\n+                    let mut reason = None;\n+                    let mut issue = None;\n+                    for meta in metas {\n+                        match &*meta.name() {\n+                            \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n+                            \"reason\" => if !get(meta, &mut reason) { continue 'outer },\n+                            \"issue\" => if !get(meta, &mut issue) { continue 'outer },\n+                            _ => {\n+                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n+                                                                        meta.name()));\n+                                continue 'outer\n+                            }\n+                        }\n+                    }\n \n-        // Unstable tags don't require a version\n-        if since == None && tag != \"unstable\" {\n-            diagnostic.span_err(attr.span(), \"missing 'since'\");\n-        }\n+                    match (feature, reason, issue) {\n+                        (Some(feature), reason, Some(issue)) => {\n+                            stab = Some(Stability {\n+                                level: Unstable {\n+                                    reason: reason,\n+                                    issue: {\n+                                        if let Ok(issue) = issue.parse() {\n+                                            issue\n+                                        } else {\n+                                            diagnostic.span_err(attr.span(), \"incorrect 'issue'\");\n+                                            continue\n+                                        }\n+                                    }\n+                                },\n+                                feature: feature,\n+                                depr: None,\n+                            })\n+                        }\n+                        (None, _, _) => {\n+                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            continue\n+                        }\n+                        _ => {\n+                            diagnostic.span_err(attr.span(), \"missing 'issue'\");\n+                            continue\n+                        }\n+                    }\n+                }\n+                \"stable\" => {\n+                    if stab.is_some() {\n+                        diagnostic.span_err(item_sp, \"multiple stability levels\");\n+                        break\n+                    }\n \n-        if tag == \"unstable\" || tag == \"stable\" {\n-            if stab.is_some() {\n-                diagnostic.span_err(item_sp, \"multiple stability levels\");\n-            }\n+                    let mut feature = None;\n+                    let mut since = None;\n+                    for meta in metas {\n+                        match &*meta.name() {\n+                            \"feature\" => if !get(meta, &mut feature) { continue 'outer },\n+                            \"since\" => if !get(meta, &mut since) { continue 'outer },\n+                            _ => {\n+                                diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n+                                                                        meta.name()));\n+                                continue 'outer\n+                            }\n+                        }\n+                    }\n \n-            let level = match tag {\n-                \"unstable\" => Unstable,\n-                \"stable\" => Stable,\n+                    match (feature, since) {\n+                        (Some(feature), Some(since)) => {\n+                            stab = Some(Stability {\n+                                level: Stable {\n+                                    since: since,\n+                                },\n+                                feature: feature,\n+                                depr: None,\n+                            })\n+                        }\n+                        (None, _) => {\n+                            diagnostic.span_err(attr.span(), \"missing 'feature'\");\n+                            continue\n+                        }\n+                        _ => {\n+                            diagnostic.span_err(attr.span(), \"missing 'since'\");\n+                            continue\n+                        }\n+                    }\n+                }\n                 _ => unreachable!()\n-            };\n-\n-            stab = Some(Stability {\n-                level: level,\n-                feature: feature.unwrap_or(intern_and_get_ident(\"bogus\")),\n-                since: since,\n-                deprecated_since: None,\n-                reason: reason,\n-                issue: issue,\n-            });\n-        } else { // \"deprecated\"\n-            if deprecated.is_some() {\n-                diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n             }\n-\n-            deprecated = Some((since, reason));\n+        } else {\n+            diagnostic.span_err(attr.span(), \"incorrect stability attribute type\");\n+            continue\n         }\n     }\n \n     // Merge the deprecation info into the stability info\n-    if deprecated.is_some() {\n-        match stab {\n-            Some(ref mut s) => {\n-                let (since, reason) = deprecated.unwrap();\n-                s.deprecated_since = since;\n-                s.reason = reason;\n-            }\n-            None => {\n-                diagnostic.span_err(item_sp, \"deprecated attribute must be paired with \\\n-                                              either stable or unstable attribute\");\n+    if let Some(depr) = depr {\n+        if let Some(ref mut stab) = stab {\n+            if let Unstable {reason: ref mut reason @ None, ..} = stab.level {\n+                *reason = Some(depr.reason.clone())\n             }\n+            stab.depr = Some(depr);\n+        } else {\n+            diagnostic.span_err(item_sp, \"deprecated attribute must be paired with \\\n+                                          either stable or unstable attribute\");\n         }\n-    } else if stab.as_ref().map_or(false, |s| s.level == Unstable && s.issue.is_none()) {\n-        // non-deprecated unstable items need to point to issues.\n-        diagnostic.span_err(item_sp,\n-                            \"non-deprecated unstable items need to point \\\n-                             to an issue with `issue = \\\"NNN\\\"`\");\n     }\n \n-    (stab, used_attrs)\n+    stab\n }\n \n /// Find the first stability attribute. `None` if none exists.\n pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n-    let (s, used) = find_stability_generic(diagnostic, attrs.iter(), item_sp);\n-    for used in used { mark_used(used) }\n-    return s;\n+    find_stability_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {"}, {"sha": "3a06ea66d17ee4db86926685386bbfb78d32d2a4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -593,7 +593,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    #[unstable(feature = \"rustc_private\")]\n+    #[unstable(feature = \"rustc_private\", issue = \"0\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"Replaced with `expander().fold_expr()`\")]\n     pub fn expand_expr(&mut self, e: P<ast::Expr>) -> P<ast::Expr> {"}, {"sha": "9743da15a47bbc7ccc9e064d443a98dc309dd2fd", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -129,7 +129,7 @@ impl<T> SmallVector<T> {\n     }\n \n     /// Deprecated: use `into_iter`.\n-    #[unstable(feature = \"rustc_private\")]\n+    #[unstable(feature = \"rustc_private\", issue = \"0\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use into_iter\")]\n     pub fn move_iter(self) -> IntoIter<T> {\n         self.into_iter()"}, {"sha": "60477288f7cb090312fc6d095be258367a5a8b08", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -29,7 +29,7 @@ pub mod stable_mod {\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n pub mod unstable_mod {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub fn deprecated() {}\n \n     pub fn unstable() {}"}, {"sha": "8794119a869cea83e62965bb06ca4ae14867a35e", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -15,7 +15,7 @@\n #![unstable(feature = \"test_feature\", issue = \"0\")]\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub fn foo() -> usize {\n     20\n }"}, {"sha": "260361634ae8734a42dca56d38f534867818e194", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -14,14 +14,14 @@\n #![stable(feature = \"lint_stability\", since = \"1.0.0\")]\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub fn deprecated() {}\n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub fn deprecated_text() {}\n \n #[unstable(feature = \"test_feature\", issue = \"0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub fn deprecated_unstable() {}\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n #[deprecated(since = \"1.0.0\", reason = \"text\")]\n@@ -34,22 +34,22 @@ pub fn unstable_text() {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stable() {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stable_text() {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct MethodTester;\n \n impl MethodTester {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub fn method_deprecated(&self) {}\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n     #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub fn method_deprecated_text(&self) {}\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub fn method_deprecated_unstable(&self) {}\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     #[deprecated(since = \"1.0.0\", reason = \"text\")]\n@@ -62,21 +62,21 @@ impl MethodTester {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn method_stable(&self) {}\n-    #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn method_stable_text(&self) {}\n }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n pub trait Trait {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn trait_deprecated(&self) {}\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n     #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn trait_deprecated_text(&self) {}\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn trait_deprecated_unstable(&self) {}\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     #[deprecated(since = \"1.0.0\", reason = \"text\")]\n@@ -89,7 +89,7 @@ pub trait Trait {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trait_stable(&self) {}\n-    #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trait_stable_text(&self) {}\n }\n \n@@ -99,12 +99,12 @@ impl Trait for MethodTester {}\n pub trait UnstableTrait { fn dummy(&self) { } }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedStruct {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedUnstableStruct {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n@@ -118,10 +118,10 @@ pub struct StableStruct {\n }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedUnitStruct;\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedUnstableUnitStruct;\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n pub struct UnstableUnitStruct;\n@@ -131,10 +131,10 @@ pub struct StableUnitStruct;\n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n pub enum Enum {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     DeprecatedVariant,\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     DeprecatedUnstableVariant,\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     UnstableVariant,\n@@ -144,10 +144,10 @@ pub enum Enum {\n }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n-#[deprecated(since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct DeprecatedUnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);\n #[unstable(feature = \"test_feature\", issue = \"0\")]\n pub struct UnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);"}, {"sha": "44b4abd38b85a6180bdf7aade37361cf2b5f6a87", "filename": "src/test/auxiliary/lint_stability_fields.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Flint_stability_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fauxiliary%2Flint_stability_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability_fields.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -18,7 +18,7 @@ pub struct Stable {\n     pub inherit: u8, // it's a lie (stable doesn't inherit)\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     pub override1: u8,\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     pub override2: u8,\n }\n@@ -27,14 +27,14 @@ pub struct Stable {\n pub struct Stable2(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub u8,\n                    #[unstable(feature = \"test_feature\", issue = \"0\")] pub u8,\n                    #[unstable(feature = \"test_feature\", issue = \"0\")]\n-                   #[deprecated(since = \"1.0.0\")] pub u8);\n+                   #[deprecated(since = \"1.0.0\", reason = \"text\")] pub u8);\n \n #[unstable(feature = \"test_feature\", issue = \"0\")]\n pub struct Unstable {\n     pub inherit: u8,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub override1: u8,\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     pub override2: u8,\n }\n@@ -43,10 +43,10 @@ pub struct Unstable {\n pub struct Unstable2(pub u8,\n                      #[stable(feature = \"rust1\", since = \"1.0.0\")] pub u8,\n                      #[unstable(feature = \"test_feature\", issue = \"0\")]\n-                     #[deprecated(since = \"1.0.0\")] pub u8);\n+                     #[deprecated(since = \"1.0.0\", reason = \"text\")] pub u8);\n \n #[unstable(feature = \"test_feature\", issue = \"0\")]\n-#[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct Deprecated {\n     pub inherit: u8,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -56,7 +56,7 @@ pub struct Deprecated {\n }\n \n #[unstable(feature = \"test_feature\", issue = \"0\")]\n-#[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"text\")]\n pub struct Deprecated2(pub u8,\n                        #[stable(feature = \"rust1\", since = \"1.0.0\")] pub u8,\n                        #[unstable(feature = \"test_feature\", issue = \"0\")] pub u8);"}, {"sha": "501f6eb4deaa01b4b662dda31653cd32af7fa1f6", "filename": "src/test/compile-fail/issue-17337.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17337.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -15,8 +15,8 @@\n struct Foo;\n \n impl Foo {\n-    #[unstable(feature = \"test_feature\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn foo(self) {}\n }\n "}, {"sha": "c22ad3182ddaa15467b72b6dd03c645879923e13", "filename": "src/test/compile-fail/lint-output-format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -15,7 +15,7 @@\n \n extern crate lint_output_format; //~ ERROR use of unstable library feature\n use lint_output_format::{foo, bar}; //~ ERROR use of unstable library feature\n-//~^ WARNING use of deprecated item,\n+//~^ WARNING use of deprecated item: text,\n \n fn main() {\n     let _x = foo(); //~ WARNING #[warn(deprecated)] on by default"}, {"sha": "11f641196807e73600fe97d69fb76b353ce5a805", "filename": "src/test/compile-fail/lint-stability-fields.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -189,7 +189,7 @@ mod this_crate {\n         inherit: u8,\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         override1: u8,\n-        #[deprecated(since = \"1.0.0\")]\n+        #[deprecated(since = \"1.0.0\", reason = \"text\")]\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         override2: u8,\n     }\n@@ -198,14 +198,14 @@ mod this_crate {\n     struct Stable2(u8,\n                    #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n                    #[unstable(feature = \"test_feature\", issue = \"0\")]\n-                   #[deprecated(since = \"1.0.0\")] u8);\n+                   #[deprecated(since = \"1.0.0\", reason = \"text\")] u8);\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     struct Unstable {\n         inherit: u8,\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         override1: u8,\n-        #[deprecated(since = \"1.0.0\")]\n+        #[deprecated(since = \"1.0.0\", reason = \"text\")]\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         override2: u8,\n     }\n@@ -214,10 +214,10 @@ mod this_crate {\n     struct Unstable2(u8,\n                      #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n                      #[unstable(feature = \"test_feature\", issue = \"0\")]\n-                     #[deprecated(since = \"1.0.0\")] u8);\n+                     #[deprecated(since = \"1.0.0\", reason = \"text\")] u8);\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     struct Deprecated {\n         inherit: u8,\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -227,7 +227,7 @@ mod this_crate {\n     }\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     struct Deprecated2(u8,\n                        #[stable(feature = \"rust1\", since = \"1.0.0\")] u8,\n                        #[unstable(feature = \"test_feature\", issue = \"0\")] u8);"}, {"sha": "864aafe5a6b6ffff707e20f4b1963275ca6bdaf0", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -258,7 +258,7 @@ mod inheritance {\n \n mod this_crate {\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub fn deprecated() {}\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     #[deprecated(since = \"1.0.0\", reason = \"text\")]\n@@ -271,15 +271,15 @@ mod this_crate {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stable() {}\n-    #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stable_text() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct MethodTester;\n \n     impl MethodTester {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n-        #[deprecated(since = \"1.0.0\")]\n+        #[deprecated(since = \"1.0.0\", reason = \"text\")]\n         pub fn method_deprecated(&self) {}\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         #[deprecated(since = \"1.0.0\", reason = \"text\")]\n@@ -292,13 +292,13 @@ mod this_crate {\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn method_stable(&self) {}\n-        #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn method_stable_text(&self) {}\n     }\n \n     pub trait Trait {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n-        #[deprecated(since = \"1.0.0\")]\n+        #[deprecated(since = \"1.0.0\", reason = \"text\")]\n         fn trait_deprecated(&self) {}\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         #[deprecated(since = \"1.0.0\", reason = \"text\")]\n@@ -311,14 +311,14 @@ mod this_crate {\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         fn trait_stable(&self) {}\n-        #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         fn trait_stable_text(&self) {}\n     }\n \n     impl Trait for MethodTester {}\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub struct DeprecatedStruct {\n         #[stable(feature = \"test_feature\", since = \"1.0.0\")] i: isize\n     }\n@@ -332,7 +332,7 @@ mod this_crate {\n     }\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub struct DeprecatedUnitStruct;\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     pub struct UnstableUnitStruct;\n@@ -341,7 +341,7 @@ mod this_crate {\n \n     pub enum Enum {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n-        #[deprecated(since = \"1.0.0\")]\n+        #[deprecated(since = \"1.0.0\", reason = \"text\")]\n         DeprecatedVariant,\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         UnstableVariant,\n@@ -351,7 +351,7 @@ mod this_crate {\n     }\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub struct DeprecatedTupleStruct(isize);\n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n     pub struct UnstableTupleStruct(isize);\n@@ -472,23 +472,23 @@ mod this_crate {\n     }\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn test_fn_body() {\n         fn fn_in_body() {}\n         fn_in_body();\n     }\n \n     impl MethodTester {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n-        #[deprecated(since = \"1.0.0\")]\n+        #[deprecated(since = \"1.0.0\", reason = \"text\")]\n         fn test_method_body(&self) {\n             fn fn_in_body() {}\n             fn_in_body();\n         }\n     }\n \n     #[unstable(feature = \"test_feature\", issue = \"0\")]\n-    #[deprecated(since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"text\")]\n     pub trait DeprecatedTrait {\n         fn dummy(&self) { }\n     }"}, {"sha": "f71e66ded7e621c9846e2d236c8eef23e358e619", "filename": "src/test/compile-fail/stability-attribute-sanity.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab671552c3b44906b63c07f2676492b766f2a7c3/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-sanity.rs?ref=ab671552c3b44906b63c07f2676492b766f2a7c3", "patch": "@@ -14,22 +14,19 @@\n #![staged_api]\n \n mod bogus_attribute_types_1 {\n-    #[stable(feature = \"a\", since = \"a\", reason)] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n     fn f1() { }\n \n-    #[stable(feature = \"a\", since, reason = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since)] //~ ERROR incorrect meta item\n     fn f2() { }\n \n-    #[stable(feature, since = \"a\", reason = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature, since = \"a\")] //~ ERROR incorrect meta item\n     fn f3() { }\n \n-    #[stable(feature = \"a\", since = \"a\", reason(b))] //~ ERROR incorrect meta item\n-    fn f4() { }\n-\n-    #[stable(feature = \"a\", since(b), reason = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature = \"a\", since(b))] //~ ERROR incorrect meta item\n     fn f5() { }\n \n-    #[stable(feature(b), since = \"a\", reason = \"a\")] //~ ERROR incorrect meta item\n+    #[stable(feature(b), since = \"a\")] //~ ERROR incorrect meta item\n     fn f6() { }\n }\n \n@@ -56,11 +53,11 @@ mod bogus_attribute_types_2 {\n }\n \n mod missing_feature_names {\n-    #[unstable(since = \"a\", issue = \"0\")] //~ ERROR missing 'feature'\n+    #[unstable(issue = \"0\")] //~ ERROR missing 'feature'\n     fn f1() { }\n \n-    #[unstable(feature = \"a\")]\n-    fn f2() { } //~ ERROR need to point to an issue\n+    #[unstable(feature = \"a\")] //~ ERROR missing 'issue'\n+    fn f2() { }\n \n     #[stable(since = \"a\")] //~ ERROR missing 'feature'\n     fn f3() { }\n@@ -75,25 +72,25 @@ mod missing_version {\n     fn f2() { }\n }\n \n-#[unstable(feature = \"a\", since = \"b\", issue = \"0\")]\n+#[unstable(feature = \"a\", issue = \"0\")]\n #[stable(feature = \"a\", since = \"b\")]\n fn multiple1() { } //~ ERROR multiple stability levels\n \n-#[unstable(feature = \"a\", since = \"b\", issue = \"0\")]\n-#[unstable(feature = \"a\", since = \"b\", issue = \"0\")]\n+#[unstable(feature = \"a\", issue = \"0\")]\n+#[unstable(feature = \"a\", issue = \"0\")]\n fn multiple2() { } //~ ERROR multiple stability levels\n \n #[stable(feature = \"a\", since = \"b\")]\n #[stable(feature = \"a\", since = \"b\")]\n fn multiple3() { } //~ ERROR multiple stability levels\n \n #[stable(feature = \"a\", since = \"b\")]\n-#[deprecated(since = \"b\")]\n-#[deprecated(since = \"b\")]\n+#[deprecated(since = \"b\", reason = \"text\")]\n+#[deprecated(since = \"b\", reason = \"text\")]\n fn multiple4() { } //~ ERROR multiple deprecated attributes\n //~^ ERROR Invalid stability or deprecation version found\n \n-#[deprecated(since = \"a\")]\n+#[deprecated(since = \"a\", reason = \"text\")]\n fn deprecated_without_unstable_or_stable() { } //~ ERROR deprecated attribute must be paired\n \n fn main() { }"}]}