{"sha": "84878794edf0d60248be578943f9edbb5c0174ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODc4Nzk0ZWRmMGQ2MDI0OGJlNTc4OTQzZjllZGJiNWMwMTc0YWI=", "commit": {"author": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-10-12T00:27:29Z"}, "committer": {"name": "Nicholas-Baron", "email": "nicholas.baron.ten@gmail.com", "date": "2020-10-12T00:27:29Z"}, "message": "Moved the functions starting with check to a separate file", "tree": {"sha": "90d06421e49951ae65579be5e217be7ee9d82bad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90d06421e49951ae65579be5e217be7ee9d82bad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84878794edf0d60248be578943f9edbb5c0174ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84878794edf0d60248be578943f9edbb5c0174ab", "html_url": "https://github.com/rust-lang/rust/commit/84878794edf0d60248be578943f9edbb5c0174ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84878794edf0d60248be578943f9edbb5c0174ab/comments", "author": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nicholas-Baron", "id": 35079404, "node_id": "MDQ6VXNlcjM1MDc5NDA0", "avatar_url": "https://avatars.githubusercontent.com/u/35079404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nicholas-Baron", "html_url": "https://github.com/Nicholas-Baron", "followers_url": "https://api.github.com/users/Nicholas-Baron/followers", "following_url": "https://api.github.com/users/Nicholas-Baron/following{/other_user}", "gists_url": "https://api.github.com/users/Nicholas-Baron/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nicholas-Baron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nicholas-Baron/subscriptions", "organizations_url": "https://api.github.com/users/Nicholas-Baron/orgs", "repos_url": "https://api.github.com/users/Nicholas-Baron/repos", "events_url": "https://api.github.com/users/Nicholas-Baron/events{/privacy}", "received_events_url": "https://api.github.com/users/Nicholas-Baron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "url": "https://api.github.com/repos/rust-lang/rust/commits/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d", "html_url": "https://github.com/rust-lang/rust/commit/16d0205d5c161ceb2a442ce8b4a938ecc3eb687d"}], "stats": {"total": 1945, "additions": 987, "deletions": 958}, "files": [{"sha": "829ad21faf1f99308b4b9dacfddebf5e79c66b05", "filename": "compiler/rustc_typeck/src/check/fn_ctxt_checks.rs", "status": "added", "additions": 975, "deletions": 0, "changes": 975, "blob_url": "https://github.com/rust-lang/rust/blob/84878794edf0d60248be578943f9edbb5c0174ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84878794edf0d60248be578943f9edbb5c0174ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_checks.rs?ref=84878794edf0d60248be578943f9edbb5c0174ab", "patch": "@@ -0,0 +1,975 @@\n+use super::coercion::CoerceMany;\n+use super::method::MethodCallee;\n+use super::Expectation::*;\n+use super::TupleArgumentsFlag::*;\n+use super::{\n+    potentially_plural_count, struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt,\n+    LocalTy, Needs, TupleArgumentsFlag,\n+};\n+use crate::astconv::AstConv;\n+\n+use rustc_ast as ast;\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_middle::ty::adjustment::AllowTwoPhase;\n+use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_session::Session;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{self, Span};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n+\n+use std::mem::replace;\n+use std::slice;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(super) fn check_casts(&self) {\n+        let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+        for cast in deferred_cast_checks.drain(..) {\n+            cast.check(self);\n+        }\n+    }\n+\n+    pub(super) fn check_method_argument_types(\n+        &self,\n+        sp: Span,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        method: Result<MethodCallee<'tcx>, ()>,\n+        args_no_rcvr: &'tcx [hir::Expr<'tcx>],\n+        tuple_arguments: TupleArgumentsFlag,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let has_error = match method {\n+            Ok(method) => method.substs.references_error() || method.sig.references_error(),\n+            Err(_) => true,\n+        };\n+        if has_error {\n+            let err_inputs = self.err_args(args_no_rcvr.len());\n+\n+            let err_inputs = match tuple_arguments {\n+                DontTupleArguments => err_inputs,\n+                TupleArguments => vec![self.tcx.intern_tup(&err_inputs[..])],\n+            };\n+\n+            self.check_argument_types(\n+                sp,\n+                expr,\n+                &err_inputs[..],\n+                &[],\n+                args_no_rcvr,\n+                false,\n+                tuple_arguments,\n+                None,\n+            );\n+            return self.tcx.ty_error();\n+        }\n+\n+        let method = method.unwrap();\n+        // HACK(eddyb) ignore self in the definition (see above).\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            sp,\n+            expected,\n+            method.sig.output(),\n+            &method.sig.inputs()[1..],\n+        );\n+        self.check_argument_types(\n+            sp,\n+            expr,\n+            &method.sig.inputs()[1..],\n+            &expected_arg_tys[..],\n+            args_no_rcvr,\n+            method.sig.c_variadic,\n+            tuple_arguments,\n+            self.tcx.hir().span_if_local(method.def_id),\n+        );\n+        method.sig.output()\n+    }\n+\n+    /// Generic function that factors out common logic from function calls,\n+    /// method calls and overloaded operators.\n+    pub(super) fn check_argument_types(\n+        &self,\n+        sp: Span,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        fn_inputs: &[Ty<'tcx>],\n+        expected_arg_tys: &[Ty<'tcx>],\n+        args: &'tcx [hir::Expr<'tcx>],\n+        c_variadic: bool,\n+        tuple_arguments: TupleArgumentsFlag,\n+        def_span: Option<Span>,\n+    ) {\n+        let tcx = self.tcx;\n+        // Grab the argument types, supplying fresh type variables\n+        // if the wrong number of arguments were supplied\n+        let supplied_arg_count = if tuple_arguments == DontTupleArguments { args.len() } else { 1 };\n+\n+        // All the input types from the fn signature must outlive the call\n+        // so as to validate implied bounds.\n+        for (&fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n+            self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n+        }\n+\n+        let expected_arg_count = fn_inputs.len();\n+\n+        let param_count_error = |expected_count: usize,\n+                                 arg_count: usize,\n+                                 error_code: &str,\n+                                 c_variadic: bool,\n+                                 sugg_unit: bool| {\n+            let (span, start_span, args) = match &expr.kind {\n+                hir::ExprKind::Call(hir::Expr { span, .. }, args) => (*span, *span, &args[..]),\n+                hir::ExprKind::MethodCall(path_segment, span, args, _) => (\n+                    *span,\n+                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n+                    path_segment\n+                        .args\n+                        .and_then(|args| args.args.iter().last())\n+                        // Account for `foo.bar::<T>()`.\n+                        .map(|arg| {\n+                            // Skip the closing `>`.\n+                            tcx.sess\n+                                .source_map()\n+                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n+                        })\n+                        .unwrap_or(*span),\n+                    &args[1..], // Skip the receiver.\n+                ),\n+                k => span_bug!(sp, \"checking argument types on a non-call: `{:?}`\", k),\n+            };\n+            let arg_spans = if args.is_empty() {\n+                // foo()\n+                // ^^^-- supplied 0 arguments\n+                // |\n+                // expected 2 arguments\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(sp.hi())]\n+            } else {\n+                // foo(1, 2, 3)\n+                // ^^^ -  -  - supplied 3 arguments\n+                // |\n+                // expected 2 arguments\n+                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n+            };\n+\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                span,\n+                &format!(\n+                    \"this function takes {}{} but {} {} supplied\",\n+                    if c_variadic { \"at least \" } else { \"\" },\n+                    potentially_plural_count(expected_count, \"argument\"),\n+                    potentially_plural_count(arg_count, \"argument\"),\n+                    if arg_count == 1 { \"was\" } else { \"were\" }\n+                ),\n+                DiagnosticId::Error(error_code.to_owned()),\n+            );\n+            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n+            for (i, span) in arg_spans.into_iter().enumerate() {\n+                err.span_label(\n+                    span,\n+                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n+                );\n+            }\n+\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().guess_head_span(sp)) {\n+                err.span_label(def_s, \"defined here\");\n+            }\n+            if sugg_unit {\n+                let sugg_span = tcx.sess.source_map().end_point(expr.span);\n+                // remove closing `)` from the span\n+                let sugg_span = sugg_span.shrink_to_lo();\n+                err.span_suggestion(\n+                    sugg_span,\n+                    \"expected the unit value `()`; create it with empty parentheses\",\n+                    String::from(\"()\"),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    span,\n+                    format!(\n+                        \"expected {}{}\",\n+                        if c_variadic { \"at least \" } else { \"\" },\n+                        potentially_plural_count(expected_count, \"argument\")\n+                    ),\n+                );\n+            }\n+            err.emit();\n+        };\n+\n+        let mut expected_arg_tys = expected_arg_tys.to_vec();\n+\n+        let formal_tys = if tuple_arguments == TupleArguments {\n+            let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n+            match tuple_type.kind() {\n+                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n+                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n+                    expected_arg_tys = vec![];\n+                    self.err_args(args.len())\n+                }\n+                ty::Tuple(arg_types) => {\n+                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                        Some(&ty) => match ty.kind() {\n+                            ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n+                            _ => vec![],\n+                        },\n+                        None => vec![],\n+                    };\n+                    arg_types.iter().map(|k| k.expect_ty()).collect()\n+                }\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        sp,\n+                        E0059,\n+                        \"cannot use call notation; the first type parameter \\\n+                         for the function trait is neither a tuple nor unit\"\n+                    )\n+                    .emit();\n+                    expected_arg_tys = vec![];\n+                    self.err_args(args.len())\n+                }\n+            }\n+        } else if expected_arg_count == supplied_arg_count {\n+            fn_inputs.to_vec()\n+        } else if c_variadic {\n+            if supplied_arg_count >= expected_arg_count {\n+                fn_inputs.to_vec()\n+            } else {\n+                param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n+                expected_arg_tys = vec![];\n+                self.err_args(supplied_arg_count)\n+            }\n+        } else {\n+            // is the missing argument of type `()`?\n+            let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n+            } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n+            } else {\n+                false\n+            };\n+            param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n+\n+            expected_arg_tys = vec![];\n+            self.err_args(supplied_arg_count)\n+        };\n+\n+        debug!(\n+            \"check_argument_types: formal_tys={:?}\",\n+            formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n+        );\n+\n+        // If there is no expectation, expect formal_tys.\n+        let expected_arg_tys =\n+            if !expected_arg_tys.is_empty() { expected_arg_tys } else { formal_tys.clone() };\n+\n+        let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n+\n+        // Check the arguments.\n+        // We do this in a pretty awful way: first we type-check any arguments\n+        // that are not closures, then we type-check the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // type-check the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            debug!(\"check_closures={}\", check_closures);\n+\n+            // More awful hacks: before we check argument types, try to do\n+            // an \"opportunistic\" trait resolution of any trait bounds on\n+            // the call. This helps coercions.\n+            if check_closures {\n+                self.select_obligations_where_possible(false, |errors| {\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n+                    self.point_at_arg_instead_of_call_if_possible(\n+                        errors,\n+                        &final_arg_types[..],\n+                        sp,\n+                        &args,\n+                    );\n+                })\n+            }\n+\n+            // For C-variadic functions, we don't have a declared type for all of\n+            // the arguments hence we only do our usual type checking with\n+            // the arguments who's types we do know.\n+            let t = if c_variadic {\n+                expected_arg_count\n+            } else if tuple_arguments == TupleArguments {\n+                args.len()\n+            } else {\n+                supplied_arg_count\n+            };\n+            for (i, arg) in args.iter().take(t).enumerate() {\n+                // Warn only for the first loop (the \"no closures\" one).\n+                // Closure arguments themselves can't be diverging, but\n+                // a previous argument can, e.g., `foo(panic!(), || {})`.\n+                if !check_closures {\n+                    self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n+                }\n+\n+                let is_closure = match arg.kind {\n+                    ExprKind::Closure(..) => true,\n+                    _ => false,\n+                };\n+\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n+\n+                debug!(\"checking the argument\");\n+                let formal_ty = formal_tys[i];\n+\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n+\n+                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n+\n+                // 2. Coerce to the most detailed type that could be coerced\n+                //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n+                // We're processing function arguments so we definitely want to use\n+                // two-phase borrows.\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n+                final_arg_types.push((i, checked_ty, coerce_ty));\n+\n+                // 3. Relate the expected type and the formal one,\n+                //    if the expected type was used for the coercion.\n+                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n+            }\n+        }\n+\n+        // We also need to make sure we at least write the ty of the other\n+        // arguments which we skipped above.\n+        if c_variadic {\n+            fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n+                use crate::structured_errors::{StructuredDiagnostic, VariadicError};\n+                VariadicError::new(s, span, t, cast_ty).diagnostic().emit();\n+            }\n+\n+            for arg in args.iter().skip(expected_arg_count) {\n+                let arg_ty = self.check_expr(&arg);\n+\n+                // There are a few types which get autopromoted when passed via varargs\n+                // in C but we just error out instead and require explicit casts.\n+                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n+                match arg_ty.kind() {\n+                    ty::Float(ast::FloatTy::F32) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n+                    }\n+                    ty::Int(ast::IntTy::I8 | ast::IntTy::I16) | ty::Bool => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n+                    }\n+                    ty::Uint(ast::UintTy::U8 | ast::UintTy::U16) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n+                    }\n+                    ty::FnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n+                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    // AST fragment checking\n+    pub(super) fn check_lit(&self, lit: &hir::Lit, expected: Expectation<'tcx>) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+\n+        match lit.node {\n+            ast::LitKind::Str(..) => tcx.mk_static_str(),\n+            ast::LitKind::ByteStr(ref v) => {\n+                tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.u8, v.len() as u64))\n+            }\n+            ast::LitKind::Byte(_) => tcx.types.u8,\n+            ast::LitKind::Char(_) => tcx.types.char,\n+            ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(t),\n+            ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n+            ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n+                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n+                    ty::Int(_) | ty::Uint(_) => Some(ty),\n+                    ty::Char => Some(tcx.types.u8),\n+                    ty::RawPtr(..) => Some(tcx.types.usize),\n+                    ty::FnDef(..) | ty::FnPtr(_) => Some(tcx.types.usize),\n+                    _ => None,\n+                });\n+                opt_ty.unwrap_or_else(|| self.next_int_var())\n+            }\n+            ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => tcx.mk_mach_float(t),\n+            ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n+                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n+                    ty::Float(_) => Some(ty),\n+                    _ => None,\n+                });\n+                opt_ty.unwrap_or_else(|| self.next_float_var())\n+            }\n+            ast::LitKind::Bool(_) => tcx.types.bool,\n+            ast::LitKind::Err(_) => tcx.ty_error(),\n+        }\n+    }\n+\n+    pub fn check_struct_path(\n+        &self,\n+        qpath: &QPath<'_>,\n+        hir_id: hir::HirId,\n+    ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n+        let path_span = qpath.qself_span();\n+        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n+        let variant = match def {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                return None;\n+            }\n+            Res::Def(DefKind::Variant, _) => match ty.kind() {\n+                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did, substs)),\n+                _ => bug!(\"unexpected type: {:?}\", ty),\n+            },\n+            Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n+            | Res::SelfTy(..) => match ty.kind() {\n+                ty::Adt(adt, substs) if !adt.is_enum() => {\n+                    Some((adt.non_enum_variant(), adt.did, substs))\n+                }\n+                _ => None,\n+            },\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n+        };\n+\n+        if let Some((variant, did, substs)) = variant {\n+            debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n+\n+            // Check bounds on type arguments used in the path.\n+            let (bounds, _) = self.instantiate_bounds(path_span, did, substs);\n+            let cause =\n+                traits::ObligationCause::new(path_span, self.body_id, traits::ItemObligation(did));\n+            self.add_obligations_for_parameters(cause, bounds);\n+\n+            Some((variant, ty))\n+        } else {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                path_span,\n+                E0071,\n+                \"expected struct, variant or union type, found {}\",\n+                ty.sort_string(self.tcx)\n+            )\n+            .span_label(path_span, \"not a struct\")\n+            .emit();\n+            None\n+        }\n+    }\n+\n+    pub fn check_decl_initializer(\n+        &self,\n+        local: &'tcx hir::Local<'tcx>,\n+        init: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n+        // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n+        // for #42640 (default match binding modes).\n+        //\n+        // See #44848.\n+        let ref_bindings = local.pat.contains_explicit_ref_binding();\n+\n+        let local_ty = self.local_ty(init.span, local.hir_id).revealed_ty;\n+        if let Some(m) = ref_bindings {\n+            // Somewhat subtle: if we have a `ref` binding in the pattern,\n+            // we want to avoid introducing coercions for the RHS. This is\n+            // both because it helps preserve sanity and, in the case of\n+            // ref mut, for soundness (issue #23116). In particular, in\n+            // the latter case, we need to be clear that the type of the\n+            // referent for the reference that results is *equal to* the\n+            // type of the place it is referencing, and not some\n+            // supertype thereof.\n+            let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n+            self.demand_eqtype(init.span, local_ty, init_ty);\n+            init_ty\n+        } else {\n+            self.check_expr_coercable_to_type(init, local_ty, None)\n+        }\n+    }\n+\n+    /// Type check a `let` statement.\n+    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n+        // Determine and write the type which we'll check the pattern against.\n+        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n+        self.write_ty(local.hir_id, ty);\n+\n+        // Type check the initializer.\n+        if let Some(ref init) = local.init {\n+            let init_ty = self.check_decl_initializer(local, &init);\n+            self.overwrite_local_ty_if_err(local, ty, init_ty);\n+        }\n+\n+        // Does the expected pattern type originate from an expression and what is the span?\n+        let (origin_expr, ty_span) = match (local.ty, local.init) {\n+            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n+            (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n+            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n+        };\n+\n+        // Type check the pattern. Override if necessary to avoid knock-on errors.\n+        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n+        let pat_ty = self.node_ty(local.pat.hir_id);\n+        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n+    }\n+\n+    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n+        // Don't do all the complex logic below for `DeclItem`.\n+        match stmt.kind {\n+            hir::StmtKind::Item(..) => return,\n+            hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+        }\n+\n+        self.warn_if_unreachable(stmt.hir_id, stmt.span, \"statement\");\n+\n+        // Hide the outer diverging and `has_errors` flags.\n+        let old_diverges = self.diverges.replace(Diverges::Maybe);\n+        let old_has_errors = self.has_errors.replace(false);\n+\n+        match stmt.kind {\n+            hir::StmtKind::Local(ref l) => {\n+                self.check_decl_local(&l);\n+            }\n+            // Ignore for now.\n+            hir::StmtKind::Item(_) => {}\n+            hir::StmtKind::Expr(ref expr) => {\n+                // Check with expected type of `()`.\n+                self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit(), |err| {\n+                    self.suggest_semicolon_at_end(expr.span, err);\n+                });\n+            }\n+            hir::StmtKind::Semi(ref expr) => {\n+                self.check_expr(&expr);\n+            }\n+        }\n+\n+        // Combine the diverging and `has_error` flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+    }\n+\n+    pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n+        let unit = self.tcx.mk_unit();\n+        let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n+\n+        // if the block produces a `!` value, that can always be\n+        // (effectively) coerced to unit.\n+        if !ty.is_never() {\n+            self.demand_suptype(blk.span, unit, ty);\n+        }\n+    }\n+\n+    pub(super) fn check_block_with_expected(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let prev = {\n+            let mut fcx_ps = self.ps.borrow_mut();\n+            let unsafety_state = fcx_ps.recurse(blk);\n+            replace(&mut *fcx_ps, unsafety_state)\n+        };\n+\n+        // In some cases, blocks have just one exit, but other blocks\n+        // can be targeted by multiple breaks. This can happen both\n+        // with labeled blocks as well as when we desugar\n+        // a `try { ... }` expression.\n+        //\n+        // Example 1:\n+        //\n+        //    'a: { if true { break 'a Err(()); } Ok(()) }\n+        //\n+        // Here we would wind up with two coercions, one from\n+        // `Err(())` and the other from the tail expression\n+        // `Ok(())`. If the tail expression is omitted, that's a\n+        // \"forced unit\" -- unless the block diverges, in which\n+        // case we can ignore the tail expression (e.g., `'a: {\n+        // break 'a 22; }` would not force the type of the block\n+        // to be `()`).\n+        let tail_expr = blk.expr.as_ref();\n+        let coerce_to_ty = expected.coercion_target_type(self, blk.span);\n+        let coerce = if blk.targeted_by_break {\n+            CoerceMany::new(coerce_to_ty)\n+        } else {\n+            let tail_expr: &[&hir::Expr<'_>] = match tail_expr {\n+                Some(e) => slice::from_ref(e),\n+                None => &[],\n+            };\n+            CoerceMany::with_coercion_sites(coerce_to_ty, tail_expr)\n+        };\n+\n+        let prev_diverges = self.diverges.get();\n+        let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n+\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+            for s in blk.stmts {\n+                self.check_stmt(s);\n+            }\n+\n+            // check the tail expression **without** holding the\n+            // `enclosing_breakables` lock below.\n+            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+            let coerce = ctxt.coerce.as_mut().unwrap();\n+            if let Some(tail_expr_ty) = tail_expr_ty {\n+                let tail_expr = tail_expr.unwrap();\n+                let span = self.get_expr_coercion_span(tail_expr);\n+                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n+            } else {\n+                // Subtle: if there is no explicit tail expression,\n+                // that is typically equivalent to a tail expression\n+                // of `()` -- except if the block diverges. In that\n+                // case, there is no value supplied from the tail\n+                // expression (assuming there are no other breaks,\n+                // this implies that the type of the block will be\n+                // `!`).\n+                //\n+                // #41425 -- label the implicit `()` as being the\n+                // \"found type\" here, rather than the \"expected type\".\n+                if !self.diverges.get().is_always() {\n+                    // #50009 -- Do not point at the entire fn block span, point at the return type\n+                    // span, as it is the cause of the requirement, and\n+                    // `consider_hint_about_removing_semicolon` will point at the last expression\n+                    // if it were a relevant part of the error. This improves usability in editors\n+                    // that highlight errors inline.\n+                    let mut sp = blk.span;\n+                    let mut fn_span = None;\n+                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                        let ret_sp = decl.output.span();\n+                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                            // output would otherwise be incorrect and even misleading. Make sure\n+                            // the span we're aiming at correspond to a `fn` body.\n+                            if block_sp == blk.span {\n+                                sp = ret_sp;\n+                                fn_span = Some(ident.span);\n+                            }\n+                        }\n+                    }\n+                    coerce.coerce_forced_unit(\n+                        self,\n+                        &self.misc(sp),\n+                        &mut |err| {\n+                            if let Some(expected_ty) = expected.only_has_type(self) {\n+                                self.consider_hint_about_removing_semicolon(blk, expected_ty, err);\n+                            }\n+                            if let Some(fn_span) = fn_span {\n+                                err.span_label(\n+                                    fn_span,\n+                                    \"implicitly returns `()` as its body has no tail or `return` \\\n+                                     expression\",\n+                                );\n+                            }\n+                        },\n+                        false,\n+                    );\n+                }\n+            }\n+        });\n+\n+        if ctxt.may_break {\n+            // If we can break from the block, then the block's exit is always reachable\n+            // (... as long as the entry is reachable) - regardless of the tail of the block.\n+            self.diverges.set(prev_diverges);\n+        }\n+\n+        let mut ty = ctxt.coerce.unwrap().complete(self);\n+\n+        if self.has_errors.get() || ty.references_error() {\n+            ty = self.tcx.ty_error()\n+        }\n+\n+        self.write_ty(blk.hir_id, ty);\n+\n+        *self.ps.borrow_mut() = prev;\n+        ty\n+    }\n+\n+    pub(super) fn check_rustc_args_require_const(\n+        &self,\n+        def_id: DefId,\n+        hir_id: hir::HirId,\n+        span: Span,\n+    ) {\n+        // We're only interested in functions tagged with\n+        // #[rustc_args_required_const], so ignore anything that's not.\n+        if !self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n+            return;\n+        }\n+\n+        // If our calling expression is indeed the function itself, we're good!\n+        // If not, generate an error that this can only be called directly.\n+        if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id)) {\n+            if let ExprKind::Call(ref callee, ..) = expr.kind {\n+                if callee.hir_id == hir_id {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_err(\n+            span,\n+            \"this function can only be invoked directly, not through a function pointer\",\n+        );\n+    }\n+\n+    /// A common error is to add an extra semicolon:\n+    ///\n+    /// ```\n+    /// fn foo() -> usize {\n+    ///     22;\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the final statement in a block is an\n+    /// expression with an explicit semicolon whose type is compatible\n+    /// with `expected_ty`. If so, it suggests removing the semicolon.\n+    fn consider_hint_about_removing_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n+            err.span_suggestion(\n+                span_semi,\n+                \"consider removing this semicolon\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n+        let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n+        match node {\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body_id), .. }) => {\n+                let body = self.tcx.hir().body(body_id);\n+                if let ExprKind::Block(block, _) = &body.value.kind {\n+                    return Some(block.span);\n+                }\n+            }\n+            _ => {}\n+        }\n+        None\n+    }\n+\n+    /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n+    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n+        let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n+        self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n+    }\n+\n+    /// If `expr` is a `match` expression that has only one non-`!` arm, use that arm's tail\n+    /// expression's `Span`, otherwise return `expr.span`. This is done to give better errors\n+    /// when given code like the following:\n+    /// ```text\n+    /// if false { return 0i32; } else { 1u32 }\n+    /// //                               ^^^^ point at this instead of the whole `if` expression\n+    /// ```\n+    fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> rustc_span::Span {\n+        if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n+            let arm_spans: Vec<Span> = arms\n+                .iter()\n+                .filter_map(|arm| {\n+                    self.in_progress_typeck_results\n+                        .and_then(|typeck_results| {\n+                            typeck_results.borrow().node_type_opt(arm.body.hir_id)\n+                        })\n+                        .and_then(|arm_ty| {\n+                            if arm_ty.is_never() {\n+                                None\n+                            } else {\n+                                Some(match &arm.body.kind {\n+                                    // Point at the tail expression when possible.\n+                                    hir::ExprKind::Block(block, _) => {\n+                                        block.expr.as_ref().map(|e| e.span).unwrap_or(block.span)\n+                                    }\n+                                    _ => arm.body.span,\n+                                })\n+                            }\n+                        })\n+                })\n+                .collect();\n+            if arm_spans.len() == 1 {\n+                return arm_spans[0];\n+            }\n+        }\n+        expr.span\n+    }\n+\n+    fn overwrite_local_ty_if_err(\n+        &self,\n+        local: &'tcx hir::Local<'tcx>,\n+        decl_ty: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) {\n+        if ty.references_error() {\n+            // Override the types everywhere with `err()` to avoid knock on errors.\n+            self.write_ty(local.hir_id, ty);\n+            self.write_ty(local.pat.hir_id, ty);\n+            let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n+            self.locals.borrow_mut().insert(local.hir_id, local_ty);\n+            self.locals.borrow_mut().insert(local.pat.hir_id, local_ty);\n+        }\n+    }\n+\n+    // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n+    // The newly resolved definition is written into `type_dependent_defs`.\n+    fn finish_resolving_struct_path(\n+        &self,\n+        qpath: &QPath<'_>,\n+        path_span: Span,\n+        hir_id: hir::HirId,\n+    ) -> (Res, Ty<'tcx>) {\n+        match *qpath {\n+            QPath::Resolved(ref maybe_qself, ref path) => {\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let ty = AstConv::res_to_ty(self, self_ty, path, true);\n+                (path.res, ty)\n+            }\n+            QPath::TypeRelative(ref qself, ref segment) => {\n+                let ty = self.to_ty(qself);\n+\n+                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n+                    path.res\n+                } else {\n+                    Res::Err\n+                };\n+                let result =\n+                    AstConv::associated_path_to_ty(self, hir_id, path_span, ty, res, segment, true);\n+                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let result = result.map(|(_, kind, def_id)| (kind, def_id));\n+\n+                // Write back the new resolution.\n+                self.write_resolution(hir_id, result);\n+\n+                (result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err), ty)\n+            }\n+            QPath::LangItem(lang_item, span) => {\n+                self.resolve_lang_item_path(lang_item, span, hir_id)\n+            }\n+        }\n+    }\n+\n+    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n+    /// the checked and coerced types for each argument to see if any of the `FulfillmentError`s\n+    /// reference a type argument. The reason to walk also the checked type is that the coerced type\n+    /// can be not easily comparable with predicate type (because of coercion). If the types match\n+    /// for either checked or coerced type, and there's only *one* argument that does, we point at\n+    /// the corresponding argument's expression span instead of the `fn` call path span.\n+    fn point_at_arg_instead_of_call_if_possible(\n+        &self,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n+        final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n+        call_sp: Span,\n+        args: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        // We *do not* do this for desugared call spans to keep good diagnostics when involving\n+        // the `?` operator.\n+        if call_sp.desugaring_kind().is_some() {\n+            return;\n+        }\n+\n+        for error in errors {\n+            // Only if the cause is somewhere inside the expression we want try to point at arg.\n+            // Otherwise, it means that the cause is somewhere else and we should not change\n+            // anything because we can break the correct span.\n+            if !call_sp.contains(error.obligation.cause.span) {\n+                continue;\n+            }\n+\n+            if let ty::PredicateAtom::Trait(predicate, _) =\n+                error.obligation.predicate.skip_binders()\n+            {\n+                // Collect the argument position for all arguments that could have caused this\n+                // `FulfillmentError`.\n+                let mut referenced_in = final_arg_types\n+                    .iter()\n+                    .map(|&(i, checked_ty, _)| (i, checked_ty))\n+                    .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n+                    .flat_map(|(i, ty)| {\n+                        let ty = self.resolve_vars_if_possible(&ty);\n+                        // We walk the argument type because the argument's type could have\n+                        // been `Option<T>`, but the `FulfillmentError` references `T`.\n+                        if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n+                            Some(i)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect::<Vec<usize>>();\n+\n+                // Both checked and coerced types could have matched, thus we need to remove\n+                // duplicates.\n+\n+                // We sort primitive type usize here and can use unstable sort\n+                referenced_in.sort_unstable();\n+                referenced_in.dedup();\n+\n+                if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n+                    // We make sure that only *one* argument matches the obligation failure\n+                    // and we assign the obligation's span to its expression's.\n+                    error.obligation.cause.make_mut().span = args[ref_in].span;\n+                    error.points_at_arg_span = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call expression, we walk the\n+    /// `PathSegment`s and resolve their type parameters to see if any of the `FulfillmentError`s\n+    /// were caused by them. If they were, we point at the corresponding type argument's span\n+    /// instead of the `fn` call path span.\n+    fn point_at_type_arg_instead_of_call_if_possible(\n+        &self,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+    ) {\n+        if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n+            if let hir::ExprKind::Path(qpath) = &path.kind {\n+                if let hir::QPath::Resolved(_, path) = &qpath {\n+                    for error in errors {\n+                        if let ty::PredicateAtom::Trait(predicate, _) =\n+                            error.obligation.predicate.skip_binders()\n+                        {\n+                            // If any of the type arguments in this path segment caused the\n+                            // `FullfillmentError`, point at its span (#61860).\n+                            for arg in path\n+                                .segments\n+                                .iter()\n+                                .filter_map(|seg| seg.args.as_ref())\n+                                .flat_map(|a| a.args.iter())\n+                            {\n+                                if let hir::GenericArg::Type(hir_ty) = &arg {\n+                                    if let hir::TyKind::Path(hir::QPath::TypeRelative(..)) =\n+                                        &hir_ty.kind\n+                                    {\n+                                        // Avoid ICE with associated types. As this is best\n+                                        // effort only, it's ok to ignore the case. It\n+                                        // would trigger in `is_send::<T::AssocType>();`\n+                                        // from `typeck-default-trait-impl-assoc-type.rs`.\n+                                    } else {\n+                                        let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n+                                        let ty = self.resolve_vars_if_possible(&ty);\n+                                        if ty == predicate.self_ty() {\n+                                            error.obligation.cause.make_mut().span = hir_ty.span;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "0a1cf76e5ae78faac61980eeb2824d61f5cf9ddd", "filename": "compiler/rustc_typeck/src/check/fn_ctxt_impl.rs", "status": "modified", "additions": 10, "deletions": 958, "changes": 968, "blob_url": "https://github.com/rust-lang/rust/blob/84878794edf0d60248be578943f9edbb5c0174ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84878794edf0d60248be578943f9edbb5c0174ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt_impl.rs?ref=84878794edf0d60248be578943f9edbb5c0174ab", "patch": "@@ -1,20 +1,13 @@\n use super::callee::{self, DeferredCallResolution};\n-use super::coercion::CoerceMany;\n use super::method::{self, MethodCallee, SelfSource};\n-use super::Expectation::*;\n-use super::TupleArgumentsFlag::*;\n-use super::{\n-    potentially_plural_count, struct_span_err, BreakableCtxt, Diverges, Expectation, FallbackMode,\n-    FnCtxt, LocalTy, Needs, TupleArgumentsFlag,\n-};\n+use super::{BreakableCtxt, Diverges, Expectation, FallbackMode, FnCtxt, LocalTy};\n use crate::astconv::{\n     AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n };\n \n-use rustc_ast as ast;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -23,9 +16,7 @@ use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n-use rustc_middle::ty::adjustment::{\n-    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n-};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{\n     self, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSelfTy, UserSubsts,\n@@ -34,7 +25,7 @@ use rustc_middle::ty::{\n     self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, ToPolyTraitRef, ToPredicate,\n     Ty, UserType,\n };\n-use rustc_session::{lint, Session};\n+use rustc_session::lint;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -45,7 +36,6 @@ use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCauseCode, TraitEngine, TraitEngineExt};\n \n use std::collections::hash_map::Entry;\n-use std::mem::replace;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -159,7 +149,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n-    fn write_resolution(&self, hir_id: hir::HirId, r: Result<(DefKind, DefId), ErrorReported>) {\n+    pub(super) fn write_resolution(\n+        &self,\n+        hir_id: hir::HirId,\n+        r: Result<(DefKind, DefId), ErrorReported>,\n+    ) {\n         self.typeck_results.borrow_mut().type_dependent_defs_mut().insert(hir_id, r);\n     }\n \n@@ -341,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// As `instantiate_type_scheme`, but for the bounds found in a\n     /// generic type scheme.\n-    fn instantiate_bounds(\n+    pub(super) fn instantiate_bounds(\n         &self,\n         span: Span,\n         def_id: DefId,\n@@ -606,13 +600,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n     }\n \n-    pub(super) fn check_casts(&self) {\n-        let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-        for cast in deferred_cast_checks.drain(..) {\n-            cast.check(self);\n-        }\n-    }\n-\n     pub(super) fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n@@ -733,61 +720,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ret_ty.builtin_deref(true).unwrap()\n     }\n \n-    pub(super) fn check_method_argument_types(\n-        &self,\n-        sp: Span,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        method: Result<MethodCallee<'tcx>, ()>,\n-        args_no_rcvr: &'tcx [hir::Expr<'tcx>],\n-        tuple_arguments: TupleArgumentsFlag,\n-        expected: Expectation<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let has_error = match method {\n-            Ok(method) => method.substs.references_error() || method.sig.references_error(),\n-            Err(_) => true,\n-        };\n-        if has_error {\n-            let err_inputs = self.err_args(args_no_rcvr.len());\n-\n-            let err_inputs = match tuple_arguments {\n-                DontTupleArguments => err_inputs,\n-                TupleArguments => vec![self.tcx.intern_tup(&err_inputs[..])],\n-            };\n-\n-            self.check_argument_types(\n-                sp,\n-                expr,\n-                &err_inputs[..],\n-                &[],\n-                args_no_rcvr,\n-                false,\n-                tuple_arguments,\n-                None,\n-            );\n-            return self.tcx.ty_error();\n-        }\n-\n-        let method = method.unwrap();\n-        // HACK(eddyb) ignore self in the definition (see above).\n-        let expected_arg_tys = self.expected_inputs_for_expected_output(\n-            sp,\n-            expected,\n-            method.sig.output(),\n-            &method.sig.inputs()[1..],\n-        );\n-        self.check_argument_types(\n-            sp,\n-            expr,\n-            &method.sig.inputs()[1..],\n-            &expected_arg_tys[..],\n-            args_no_rcvr,\n-            method.sig.c_variadic,\n-            tuple_arguments,\n-            self.tcx.hir().span_if_local(method.def_id),\n-        );\n-        method.sig.output()\n-    }\n-\n     fn self_type_matches_expected_vid(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -865,447 +797,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n     }\n \n-    /// Generic function that factors out common logic from function calls,\n-    /// method calls and overloaded operators.\n-    pub(super) fn check_argument_types(\n-        &self,\n-        sp: Span,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        fn_inputs: &[Ty<'tcx>],\n-        expected_arg_tys: &[Ty<'tcx>],\n-        args: &'tcx [hir::Expr<'tcx>],\n-        c_variadic: bool,\n-        tuple_arguments: TupleArgumentsFlag,\n-        def_span: Option<Span>,\n-    ) {\n-        let tcx = self.tcx;\n-        // Grab the argument types, supplying fresh type variables\n-        // if the wrong number of arguments were supplied\n-        let supplied_arg_count = if tuple_arguments == DontTupleArguments { args.len() } else { 1 };\n-\n-        // All the input types from the fn signature must outlive the call\n-        // so as to validate implied bounds.\n-        for (&fn_input_ty, arg_expr) in fn_inputs.iter().zip(args.iter()) {\n-            self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n-        }\n-\n-        let expected_arg_count = fn_inputs.len();\n-\n-        let param_count_error = |expected_count: usize,\n-                                 arg_count: usize,\n-                                 error_code: &str,\n-                                 c_variadic: bool,\n-                                 sugg_unit: bool| {\n-            let (span, start_span, args) = match &expr.kind {\n-                hir::ExprKind::Call(hir::Expr { span, .. }, args) => (*span, *span, &args[..]),\n-                hir::ExprKind::MethodCall(path_segment, span, args, _) => (\n-                    *span,\n-                    // `sp` doesn't point at the whole `foo.bar()`, only at `bar`.\n-                    path_segment\n-                        .args\n-                        .and_then(|args| args.args.iter().last())\n-                        // Account for `foo.bar::<T>()`.\n-                        .map(|arg| {\n-                            // Skip the closing `>`.\n-                            tcx.sess\n-                                .source_map()\n-                                .next_point(tcx.sess.source_map().next_point(arg.span()))\n-                        })\n-                        .unwrap_or(*span),\n-                    &args[1..], // Skip the receiver.\n-                ),\n-                k => span_bug!(sp, \"checking argument types on a non-call: `{:?}`\", k),\n-            };\n-            let arg_spans = if args.is_empty() {\n-                // foo()\n-                // ^^^-- supplied 0 arguments\n-                // |\n-                // expected 2 arguments\n-                vec![tcx.sess.source_map().next_point(start_span).with_hi(sp.hi())]\n-            } else {\n-                // foo(1, 2, 3)\n-                // ^^^ -  -  - supplied 3 arguments\n-                // |\n-                // expected 2 arguments\n-                args.iter().map(|arg| arg.span).collect::<Vec<Span>>()\n-            };\n-\n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                span,\n-                &format!(\n-                    \"this function takes {}{} but {} {} supplied\",\n-                    if c_variadic { \"at least \" } else { \"\" },\n-                    potentially_plural_count(expected_count, \"argument\"),\n-                    potentially_plural_count(arg_count, \"argument\"),\n-                    if arg_count == 1 { \"was\" } else { \"were\" }\n-                ),\n-                DiagnosticId::Error(error_code.to_owned()),\n-            );\n-            let label = format!(\"supplied {}\", potentially_plural_count(arg_count, \"argument\"));\n-            for (i, span) in arg_spans.into_iter().enumerate() {\n-                err.span_label(\n-                    span,\n-                    if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n-                );\n-            }\n-\n-            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().guess_head_span(sp)) {\n-                err.span_label(def_s, \"defined here\");\n-            }\n-            if sugg_unit {\n-                let sugg_span = tcx.sess.source_map().end_point(expr.span);\n-                // remove closing `)` from the span\n-                let sugg_span = sugg_span.shrink_to_lo();\n-                err.span_suggestion(\n-                    sugg_span,\n-                    \"expected the unit value `()`; create it with empty parentheses\",\n-                    String::from(\"()\"),\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"expected {}{}\",\n-                        if c_variadic { \"at least \" } else { \"\" },\n-                        potentially_plural_count(expected_count, \"argument\")\n-                    ),\n-                );\n-            }\n-            err.emit();\n-        };\n-\n-        let mut expected_arg_tys = expected_arg_tys.to_vec();\n-\n-        let formal_tys = if tuple_arguments == TupleArguments {\n-            let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n-            match tuple_type.kind() {\n-                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n-                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n-                    expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n-                }\n-                ty::Tuple(arg_types) => {\n-                    expected_arg_tys = match expected_arg_tys.get(0) {\n-                        Some(&ty) => match ty.kind() {\n-                            ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n-                            _ => vec![],\n-                        },\n-                        None => vec![],\n-                    };\n-                    arg_types.iter().map(|k| k.expect_ty()).collect()\n-                }\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        sp,\n-                        E0059,\n-                        \"cannot use call notation; the first type parameter \\\n-                         for the function trait is neither a tuple nor unit\"\n-                    )\n-                    .emit();\n-                    expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n-                }\n-            }\n-        } else if expected_arg_count == supplied_arg_count {\n-            fn_inputs.to_vec()\n-        } else if c_variadic {\n-            if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.to_vec()\n-            } else {\n-                param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n-                expected_arg_tys = vec![];\n-                self.err_args(supplied_arg_count)\n-            }\n-        } else {\n-            // is the missing argument of type `()`?\n-            let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n-            } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n-            } else {\n-                false\n-            };\n-            param_count_error(expected_arg_count, supplied_arg_count, \"E0061\", false, sugg_unit);\n-\n-            expected_arg_tys = vec![];\n-            self.err_args(supplied_arg_count)\n-        };\n-\n-        debug!(\n-            \"check_argument_types: formal_tys={:?}\",\n-            formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>()\n-        );\n-\n-        // If there is no expectation, expect formal_tys.\n-        let expected_arg_tys =\n-            if !expected_arg_tys.is_empty() { expected_arg_tys } else { formal_tys.clone() };\n-\n-        let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n-\n-        // Check the arguments.\n-        // We do this in a pretty awful way: first we type-check any arguments\n-        // that are not closures, then we type-check the closures. This is so\n-        // that we have more information about the types of arguments when we\n-        // type-check the functions. This isn't really the right way to do this.\n-        for &check_closures in &[false, true] {\n-            debug!(\"check_closures={}\", check_closures);\n-\n-            // More awful hacks: before we check argument types, try to do\n-            // an \"opportunistic\" trait resolution of any trait bounds on\n-            // the call. This helps coercions.\n-            if check_closures {\n-                self.select_obligations_where_possible(false, |errors| {\n-                    self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n-                    self.point_at_arg_instead_of_call_if_possible(\n-                        errors,\n-                        &final_arg_types[..],\n-                        sp,\n-                        &args,\n-                    );\n-                })\n-            }\n-\n-            // For C-variadic functions, we don't have a declared type for all of\n-            // the arguments hence we only do our usual type checking with\n-            // the arguments who's types we do know.\n-            let t = if c_variadic {\n-                expected_arg_count\n-            } else if tuple_arguments == TupleArguments {\n-                args.len()\n-            } else {\n-                supplied_arg_count\n-            };\n-            for (i, arg) in args.iter().take(t).enumerate() {\n-                // Warn only for the first loop (the \"no closures\" one).\n-                // Closure arguments themselves can't be diverging, but\n-                // a previous argument can, e.g., `foo(panic!(), || {})`.\n-                if !check_closures {\n-                    self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n-                }\n-\n-                let is_closure = match arg.kind {\n-                    ExprKind::Closure(..) => true,\n-                    _ => false,\n-                };\n-\n-                if is_closure != check_closures {\n-                    continue;\n-                }\n-\n-                debug!(\"checking the argument\");\n-                let formal_ty = formal_tys[i];\n-\n-                // The special-cased logic below has three functions:\n-                // 1. Provide as good of an expected type as possible.\n-                let expected = Expectation::rvalue_hint(self, expected_arg_tys[i]);\n-\n-                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n-\n-                // 2. Coerce to the most detailed type that could be coerced\n-                //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n-                // We're processing function arguments so we definitely want to use\n-                // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n-                final_arg_types.push((i, checked_ty, coerce_ty));\n-\n-                // 3. Relate the expected type and the formal one,\n-                //    if the expected type was used for the coercion.\n-                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n-            }\n-        }\n-\n-        // We also need to make sure we at least write the ty of the other\n-        // arguments which we skipped above.\n-        if c_variadic {\n-            fn variadic_error<'tcx>(s: &Session, span: Span, t: Ty<'tcx>, cast_ty: &str) {\n-                use crate::structured_errors::{StructuredDiagnostic, VariadicError};\n-                VariadicError::new(s, span, t, cast_ty).diagnostic().emit();\n-            }\n-\n-            for arg in args.iter().skip(expected_arg_count) {\n-                let arg_ty = self.check_expr(&arg);\n-\n-                // There are a few types which get autopromoted when passed via varargs\n-                // in C but we just error out instead and require explicit casts.\n-                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n-                match arg_ty.kind() {\n-                    ty::Float(ast::FloatTy::F32) => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n-                    }\n-                    ty::Int(ast::IntTy::I8 | ast::IntTy::I16) | ty::Bool => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n-                    }\n-                    ty::Uint(ast::UintTy::U8 | ast::UintTy::U16) => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n-                    }\n-                    ty::FnDef(..) => {\n-                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n-                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-    }\n-\n     pub(super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n         vec![self.tcx.ty_error(); len]\n     }\n \n-    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n-    /// the checked and coerced types for each argument to see if any of the `FulfillmentError`s\n-    /// reference a type argument. The reason to walk also the checked type is that the coerced type\n-    /// can be not easily comparable with predicate type (because of coercion). If the types match\n-    /// for either checked or coerced type, and there's only *one* argument that does, we point at\n-    /// the corresponding argument's expression span instead of the `fn` call path span.\n-    fn point_at_arg_instead_of_call_if_possible(\n-        &self,\n-        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n-        final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n-        call_sp: Span,\n-        args: &'tcx [hir::Expr<'tcx>],\n-    ) {\n-        // We *do not* do this for desugared call spans to keep good diagnostics when involving\n-        // the `?` operator.\n-        if call_sp.desugaring_kind().is_some() {\n-            return;\n-        }\n-\n-        for error in errors {\n-            // Only if the cause is somewhere inside the expression we want try to point at arg.\n-            // Otherwise, it means that the cause is somewhere else and we should not change\n-            // anything because we can break the correct span.\n-            if !call_sp.contains(error.obligation.cause.span) {\n-                continue;\n-            }\n-\n-            if let ty::PredicateAtom::Trait(predicate, _) =\n-                error.obligation.predicate.skip_binders()\n-            {\n-                // Collect the argument position for all arguments that could have caused this\n-                // `FulfillmentError`.\n-                let mut referenced_in = final_arg_types\n-                    .iter()\n-                    .map(|&(i, checked_ty, _)| (i, checked_ty))\n-                    .chain(final_arg_types.iter().map(|&(i, _, coerced_ty)| (i, coerced_ty)))\n-                    .flat_map(|(i, ty)| {\n-                        let ty = self.resolve_vars_if_possible(&ty);\n-                        // We walk the argument type because the argument's type could have\n-                        // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                        if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n-                            Some(i)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect::<Vec<usize>>();\n-\n-                // Both checked and coerced types could have matched, thus we need to remove\n-                // duplicates.\n-\n-                // We sort primitive type usize here and can use unstable sort\n-                referenced_in.sort_unstable();\n-                referenced_in.dedup();\n-\n-                if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n-                    // We make sure that only *one* argument matches the obligation failure\n-                    // and we assign the obligation's span to its expression's.\n-                    error.obligation.cause.make_mut().span = args[ref_in].span;\n-                    error.points_at_arg_span = true;\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call expression, we walk the\n-    /// `PathSegment`s and resolve their type parameters to see if any of the `FulfillmentError`s\n-    /// were caused by them. If they were, we point at the corresponding type argument's span\n-    /// instead of the `fn` call path span.\n-    fn point_at_type_arg_instead_of_call_if_possible(\n-        &self,\n-        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n-        call_expr: &'tcx hir::Expr<'tcx>,\n-    ) {\n-        if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n-            if let hir::ExprKind::Path(qpath) = &path.kind {\n-                if let hir::QPath::Resolved(_, path) = &qpath {\n-                    for error in errors {\n-                        if let ty::PredicateAtom::Trait(predicate, _) =\n-                            error.obligation.predicate.skip_binders()\n-                        {\n-                            // If any of the type arguments in this path segment caused the\n-                            // `FullfillmentError`, point at its span (#61860).\n-                            for arg in path\n-                                .segments\n-                                .iter()\n-                                .filter_map(|seg| seg.args.as_ref())\n-                                .flat_map(|a| a.args.iter())\n-                            {\n-                                if let hir::GenericArg::Type(hir_ty) = &arg {\n-                                    if let hir::TyKind::Path(hir::QPath::TypeRelative(..)) =\n-                                        &hir_ty.kind\n-                                    {\n-                                        // Avoid ICE with associated types. As this is best\n-                                        // effort only, it's ok to ignore the case. It\n-                                        // would trigger in `is_send::<T::AssocType>();`\n-                                        // from `typeck-default-trait-impl-assoc-type.rs`.\n-                                    } else {\n-                                        let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n-                                        let ty = self.resolve_vars_if_possible(&ty);\n-                                        if ty == predicate.self_ty() {\n-                                            error.obligation.cause.make_mut().span = hir_ty.span;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // AST fragment checking\n-    pub(super) fn check_lit(&self, lit: &hir::Lit, expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-\n-        match lit.node {\n-            ast::LitKind::Str(..) => tcx.mk_static_str(),\n-            ast::LitKind::ByteStr(ref v) => {\n-                tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.u8, v.len() as u64))\n-            }\n-            ast::LitKind::Byte(_) => tcx.types.u8,\n-            ast::LitKind::Char(_) => tcx.types.char,\n-            ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(t),\n-            ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n-            ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n-                    ty::Int(_) | ty::Uint(_) => Some(ty),\n-                    ty::Char => Some(tcx.types.u8),\n-                    ty::RawPtr(..) => Some(tcx.types.usize),\n-                    ty::FnDef(..) | ty::FnPtr(_) => Some(tcx.types.usize),\n-                    _ => None,\n-                });\n-                opt_ty.unwrap_or_else(|| self.next_int_var())\n-            }\n-            ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => tcx.mk_mach_float(t),\n-            ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n-                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n-                    ty::Float(_) => Some(ty),\n-                    _ => None,\n-                });\n-                opt_ty.unwrap_or_else(|| self.next_float_var())\n-            }\n-            ast::LitKind::Bool(_) => tcx.types.bool,\n-            ast::LitKind::Err(_) => tcx.ty_error(),\n-        }\n-    }\n-\n     /// Unifies the output type with the expected type early, for more coercions\n     /// and forward type information on the input expressions.\n     pub(super) fn expected_inputs_for_expected_output(\n@@ -1361,95 +856,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expect_args\n     }\n \n-    pub fn check_struct_path(\n-        &self,\n-        qpath: &QPath<'_>,\n-        hir_id: hir::HirId,\n-    ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n-        let path_span = qpath.qself_span();\n-        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n-        let variant = match def {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                return None;\n-            }\n-            Res::Def(DefKind::Variant, _) => match ty.kind() {\n-                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did, substs)),\n-                _ => bug!(\"unexpected type: {:?}\", ty),\n-            },\n-            Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n-            | Res::SelfTy(..) => match ty.kind() {\n-                ty::Adt(adt, substs) if !adt.is_enum() => {\n-                    Some((adt.non_enum_variant(), adt.did, substs))\n-                }\n-                _ => None,\n-            },\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n-        };\n-\n-        if let Some((variant, did, substs)) = variant {\n-            debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n-\n-            // Check bounds on type arguments used in the path.\n-            let (bounds, _) = self.instantiate_bounds(path_span, did, substs);\n-            let cause =\n-                traits::ObligationCause::new(path_span, self.body_id, traits::ItemObligation(did));\n-            self.add_obligations_for_parameters(cause, bounds);\n-\n-            Some((variant, ty))\n-        } else {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                path_span,\n-                E0071,\n-                \"expected struct, variant or union type, found {}\",\n-                ty.sort_string(self.tcx)\n-            )\n-            .span_label(path_span, \"not a struct\")\n-            .emit();\n-            None\n-        }\n-    }\n-\n-    // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n-    // The newly resolved definition is written into `type_dependent_defs`.\n-    fn finish_resolving_struct_path(\n-        &self,\n-        qpath: &QPath<'_>,\n-        path_span: Span,\n-        hir_id: hir::HirId,\n-    ) -> (Res, Ty<'tcx>) {\n-        match *qpath {\n-            QPath::Resolved(ref maybe_qself, ref path) => {\n-                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::res_to_ty(self, self_ty, path, true);\n-                (path.res, ty)\n-            }\n-            QPath::TypeRelative(ref qself, ref segment) => {\n-                let ty = self.to_ty(qself);\n-\n-                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n-                let result =\n-                    AstConv::associated_path_to_ty(self, hir_id, path_span, ty, res, segment, true);\n-                let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n-                let result = result.map(|(_, kind, def_id)| (kind, def_id));\n-\n-                // Write back the new resolution.\n-                self.write_resolution(hir_id, result);\n-\n-                (result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err), ty)\n-            }\n-            QPath::LangItem(lang_item, span) => {\n-                self.resolve_lang_item_path(lang_item, span, hir_id)\n-            }\n-        }\n-    }\n-\n     pub(super) fn resolve_lang_item_path(\n         &self,\n         lang_item: hir::LangItem,\n@@ -1530,310 +936,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    pub fn check_decl_initializer(\n-        &self,\n-        local: &'tcx hir::Local<'tcx>,\n-        init: &'tcx hir::Expr<'tcx>,\n-    ) -> Ty<'tcx> {\n-        // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n-        // for #42640 (default match binding modes).\n-        //\n-        // See #44848.\n-        let ref_bindings = local.pat.contains_explicit_ref_binding();\n-\n-        let local_ty = self.local_ty(init.span, local.hir_id).revealed_ty;\n-        if let Some(m) = ref_bindings {\n-            // Somewhat subtle: if we have a `ref` binding in the pattern,\n-            // we want to avoid introducing coercions for the RHS. This is\n-            // both because it helps preserve sanity and, in the case of\n-            // ref mut, for soundness (issue #23116). In particular, in\n-            // the latter case, we need to be clear that the type of the\n-            // referent for the reference that results is *equal to* the\n-            // type of the place it is referencing, and not some\n-            // supertype thereof.\n-            let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n-            self.demand_eqtype(init.span, local_ty, init_ty);\n-            init_ty\n-        } else {\n-            self.check_expr_coercable_to_type(init, local_ty, None)\n-        }\n-    }\n-\n-    /// Type check a `let` statement.\n-    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n-        // Determine and write the type which we'll check the pattern against.\n-        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n-        self.write_ty(local.hir_id, ty);\n-\n-        // Type check the initializer.\n-        if let Some(ref init) = local.init {\n-            let init_ty = self.check_decl_initializer(local, &init);\n-            self.overwrite_local_ty_if_err(local, ty, init_ty);\n-        }\n-\n-        // Does the expected pattern type originate from an expression and what is the span?\n-        let (origin_expr, ty_span) = match (local.ty, local.init) {\n-            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n-            (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n-            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n-        };\n-\n-        // Type check the pattern. Override if necessary to avoid knock-on errors.\n-        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n-        let pat_ty = self.node_ty(local.pat.hir_id);\n-        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n-    }\n-\n-    fn overwrite_local_ty_if_err(\n-        &self,\n-        local: &'tcx hir::Local<'tcx>,\n-        decl_ty: Ty<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) {\n-        if ty.references_error() {\n-            // Override the types everywhere with `err()` to avoid knock on errors.\n-            self.write_ty(local.hir_id, ty);\n-            self.write_ty(local.pat.hir_id, ty);\n-            let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n-            self.locals.borrow_mut().insert(local.hir_id, local_ty);\n-            self.locals.borrow_mut().insert(local.pat.hir_id, local_ty);\n-        }\n-    }\n-\n-    pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>) {\n-        // Don't do all the complex logic below for `DeclItem`.\n-        match stmt.kind {\n-            hir::StmtKind::Item(..) => return,\n-            hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n-        }\n-\n-        self.warn_if_unreachable(stmt.hir_id, stmt.span, \"statement\");\n-\n-        // Hide the outer diverging and `has_errors` flags.\n-        let old_diverges = self.diverges.replace(Diverges::Maybe);\n-        let old_has_errors = self.has_errors.replace(false);\n-\n-        match stmt.kind {\n-            hir::StmtKind::Local(ref l) => {\n-                self.check_decl_local(&l);\n-            }\n-            // Ignore for now.\n-            hir::StmtKind::Item(_) => {}\n-            hir::StmtKind::Expr(ref expr) => {\n-                // Check with expected type of `()`.\n-                self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit(), |err| {\n-                    self.suggest_semicolon_at_end(expr.span, err);\n-                });\n-            }\n-            hir::StmtKind::Semi(ref expr) => {\n-                self.check_expr(&expr);\n-            }\n-        }\n-\n-        // Combine the diverging and `has_error` flags.\n-        self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n-    }\n-\n-    pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n-        let unit = self.tcx.mk_unit();\n-        let ty = self.check_block_with_expected(blk, ExpectHasType(unit));\n-\n-        // if the block produces a `!` value, that can always be\n-        // (effectively) coerced to unit.\n-        if !ty.is_never() {\n-            self.demand_suptype(blk.span, unit, ty);\n-        }\n-    }\n-\n-    /// If `expr` is a `match` expression that has only one non-`!` arm, use that arm's tail\n-    /// expression's `Span`, otherwise return `expr.span`. This is done to give better errors\n-    /// when given code like the following:\n-    /// ```text\n-    /// if false { return 0i32; } else { 1u32 }\n-    /// //                               ^^^^ point at this instead of the whole `if` expression\n-    /// ```\n-    fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> rustc_span::Span {\n-        if let hir::ExprKind::Match(_, arms, _) = &expr.kind {\n-            let arm_spans: Vec<Span> = arms\n-                .iter()\n-                .filter_map(|arm| {\n-                    self.in_progress_typeck_results\n-                        .and_then(|typeck_results| {\n-                            typeck_results.borrow().node_type_opt(arm.body.hir_id)\n-                        })\n-                        .and_then(|arm_ty| {\n-                            if arm_ty.is_never() {\n-                                None\n-                            } else {\n-                                Some(match &arm.body.kind {\n-                                    // Point at the tail expression when possible.\n-                                    hir::ExprKind::Block(block, _) => {\n-                                        block.expr.as_ref().map(|e| e.span).unwrap_or(block.span)\n-                                    }\n-                                    _ => arm.body.span,\n-                                })\n-                            }\n-                        })\n-                })\n-                .collect();\n-            if arm_spans.len() == 1 {\n-                return arm_spans[0];\n-            }\n-        }\n-        expr.span\n-    }\n-\n-    pub(super) fn check_block_with_expected(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected: Expectation<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let prev = {\n-            let mut fcx_ps = self.ps.borrow_mut();\n-            let unsafety_state = fcx_ps.recurse(blk);\n-            replace(&mut *fcx_ps, unsafety_state)\n-        };\n-\n-        // In some cases, blocks have just one exit, but other blocks\n-        // can be targeted by multiple breaks. This can happen both\n-        // with labeled blocks as well as when we desugar\n-        // a `try { ... }` expression.\n-        //\n-        // Example 1:\n-        //\n-        //    'a: { if true { break 'a Err(()); } Ok(()) }\n-        //\n-        // Here we would wind up with two coercions, one from\n-        // `Err(())` and the other from the tail expression\n-        // `Ok(())`. If the tail expression is omitted, that's a\n-        // \"forced unit\" -- unless the block diverges, in which\n-        // case we can ignore the tail expression (e.g., `'a: {\n-        // break 'a 22; }` would not force the type of the block\n-        // to be `()`).\n-        let tail_expr = blk.expr.as_ref();\n-        let coerce_to_ty = expected.coercion_target_type(self, blk.span);\n-        let coerce = if blk.targeted_by_break {\n-            CoerceMany::new(coerce_to_ty)\n-        } else {\n-            let tail_expr: &[&hir::Expr<'_>] = match tail_expr {\n-                Some(e) => slice::from_ref(e),\n-                None => &[],\n-            };\n-            CoerceMany::with_coercion_sites(coerce_to_ty, tail_expr)\n-        };\n-\n-        let prev_diverges = self.diverges.get();\n-        let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n-\n-        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for s in blk.stmts {\n-                self.check_stmt(s);\n-            }\n-\n-            // check the tail expression **without** holding the\n-            // `enclosing_breakables` lock below.\n-            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n-\n-            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n-            let coerce = ctxt.coerce.as_mut().unwrap();\n-            if let Some(tail_expr_ty) = tail_expr_ty {\n-                let tail_expr = tail_expr.unwrap();\n-                let span = self.get_expr_coercion_span(tail_expr);\n-                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n-                coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n-            } else {\n-                // Subtle: if there is no explicit tail expression,\n-                // that is typically equivalent to a tail expression\n-                // of `()` -- except if the block diverges. In that\n-                // case, there is no value supplied from the tail\n-                // expression (assuming there are no other breaks,\n-                // this implies that the type of the block will be\n-                // `!`).\n-                //\n-                // #41425 -- label the implicit `()` as being the\n-                // \"found type\" here, rather than the \"expected type\".\n-                if !self.diverges.get().is_always() {\n-                    // #50009 -- Do not point at the entire fn block span, point at the return type\n-                    // span, as it is the cause of the requirement, and\n-                    // `consider_hint_about_removing_semicolon` will point at the last expression\n-                    // if it were a relevant part of the error. This improves usability in editors\n-                    // that highlight errors inline.\n-                    let mut sp = blk.span;\n-                    let mut fn_span = None;\n-                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n-                        let ret_sp = decl.output.span();\n-                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n-                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n-                            // output would otherwise be incorrect and even misleading. Make sure\n-                            // the span we're aiming at correspond to a `fn` body.\n-                            if block_sp == blk.span {\n-                                sp = ret_sp;\n-                                fn_span = Some(ident.span);\n-                            }\n-                        }\n-                    }\n-                    coerce.coerce_forced_unit(\n-                        self,\n-                        &self.misc(sp),\n-                        &mut |err| {\n-                            if let Some(expected_ty) = expected.only_has_type(self) {\n-                                self.consider_hint_about_removing_semicolon(blk, expected_ty, err);\n-                            }\n-                            if let Some(fn_span) = fn_span {\n-                                err.span_label(\n-                                    fn_span,\n-                                    \"implicitly returns `()` as its body has no tail or `return` \\\n-                                     expression\",\n-                                );\n-                            }\n-                        },\n-                        false,\n-                    );\n-                }\n-            }\n-        });\n-\n-        if ctxt.may_break {\n-            // If we can break from the block, then the block's exit is always reachable\n-            // (... as long as the entry is reachable) - regardless of the tail of the block.\n-            self.diverges.set(prev_diverges);\n-        }\n-\n-        let mut ty = ctxt.coerce.unwrap().complete(self);\n-\n-        if self.has_errors.get() || ty.references_error() {\n-            ty = self.tcx.ty_error()\n-        }\n-\n-        self.write_ty(blk.hir_id, ty);\n-\n-        *self.ps.borrow_mut() = prev;\n-        ty\n-    }\n-\n-    fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n-        let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n-        match node {\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })\n-            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body_id), .. }) => {\n-                let body = self.tcx.hir().body(body_id);\n-                if let ExprKind::Block(block, _) = &body.value.kind {\n-                    return Some(block.span);\n-                }\n-            }\n-            _ => {}\n-        }\n-        None\n-    }\n-\n-    /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n-        let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n-        self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n-    }\n-\n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n     pub(super) fn get_node_fn_decl(\n         &self,\n@@ -1953,33 +1055,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ));\n     }\n \n-    /// A common error is to add an extra semicolon:\n-    ///\n-    /// ```\n-    /// fn foo() -> usize {\n-    ///     22;\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the final statement in a block is an\n-    /// expression with an explicit semicolon whose type is compatible\n-    /// with `expected_ty`. If so, it suggests removing the semicolon.\n-    fn consider_hint_about_removing_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n-            err.span_suggestion(\n-                span_semi,\n-                \"consider removing this semicolon\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-\n     pub(super) fn could_remove_semicolon(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n@@ -2310,29 +1385,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_rustc_args_require_const(&self, def_id: DefId, hir_id: hir::HirId, span: Span) {\n-        // We're only interested in functions tagged with\n-        // #[rustc_args_required_const], so ignore anything that's not.\n-        if !self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n-            return;\n-        }\n-\n-        // If our calling expression is indeed the function itself, we're good!\n-        // If not, generate an error that this can only be called directly.\n-        if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id)) {\n-            if let ExprKind::Call(ref callee, ..) = expr.kind {\n-                if callee.hir_id == hir_id {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        self.tcx.sess.span_err(\n-            span,\n-            \"this function can only be invoked directly, not through a function pointer\",\n-        );\n-    }\n-\n     /// Resolves `typ` by a single level if `typ` is a type variable.\n     /// If no resolution is possible, then an error is reported.\n     /// Numeric inference variables may be left unresolved."}, {"sha": "b9e1b74265042e1bf28a49fbcbfd375b35c3d13e", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84878794edf0d60248be578943f9edbb5c0174ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84878794edf0d60248be578943f9edbb5c0174ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=84878794edf0d60248be578943f9edbb5c0174ab", "patch": "@@ -76,6 +76,7 @@ pub mod dropck;\n mod expectation;\n mod expr;\n mod fn_ctxt;\n+mod fn_ctxt_checks;\n mod fn_ctxt_impl;\n mod fn_ctxt_suggestions;\n mod gather_locals;\n@@ -99,6 +100,7 @@ pub use check::{check_item_type, check_wf_new};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::FnCtxt;\n+pub use fn_ctxt_checks::*;\n pub use fn_ctxt_impl::*;\n pub use fn_ctxt_suggestions::*;\n pub use inherited::{Inherited, InheritedBuilder};"}]}