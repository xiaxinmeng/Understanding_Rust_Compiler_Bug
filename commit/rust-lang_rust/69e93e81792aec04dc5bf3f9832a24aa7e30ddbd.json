{"sha": "69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZTkzZTgxNzkyYWVjMDRkYzViZjNmOTgzMmEyNGFhN2UzMGRkYmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-17T01:08:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-17T01:08:36Z"}, "message": "Rollup merge of #64416 - mark-i-m:region-naming-ctx, r=estebank\n\nVarious refactorings to clean up nll diagnostics\n\n- Create ErrorReportingCtx and ErrorConstraintInfo, vasting reducing the\n  number of arguments passed around everywhere in the error reporting code\n- Create RegionErrorNamingCtx, making a given lifetime have consistent\n  numbering thoughout all error messages for that MIR def.\n- Make the error reporting code return the DiagnosticBuilder rather than\n  directly buffer the Diagnostic. This makes it easier to modify the\n  diagnostic later, e.g. to add suggestions.\n\nr? @estebank\n\nSplit out from https://github.com/rust-lang/rust/pull/58281", "tree": {"sha": "e71a53791750551c4452510b44271c1d2e17babe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e71a53791750551c4452510b44271c1d2e17babe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdgDIUCRBK7hj4Ov3rIwAAdHIIAHv6Iz0KXjn+cLlWbwrP7bws\n32aaUzj0hpuslF9EPr5wdM0vDL0xH6kZEGWHMPOgVtkmZ5ucZcCSHuqAsKQr03+Z\n5Zpp/q0AkqUwMEjV7/4H0nlad4LiA2m9pH36BJ8IR3H2xib2p7qGwpjtUWcKYHqy\noTMlfDtW9R5/8o9kMWlCxxc8ozxmV3MzdXLy+3ndnX8GLDc1e6u6gYUbhpBXYwZ8\nV+IL4UECX79Wxv4ZUt0M7DSfSiqSI7kMG9sYXhRCb3NjRn9QYu65hGPhYxumDCLf\nMdXd2/5bTSJ0d/OsyfY5RiIsANobrHvWr/KYZyjg73VWYbppYkU6gJ5T/fX1pFg=\n=E/2e\n-----END PGP SIGNATURE-----\n", "payload": "tree e71a53791750551c4452510b44271c1d2e17babe\nparent aeb32f01b674e383d240b3a173d6d9bc29c7a6ad\nparent 2a774b1e6bfda649f75dcc6d32502100f8420a3a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568682516 +0200\ncommitter GitHub <noreply@github.com> 1568682516 +0200\n\nRollup merge of #64416 - mark-i-m:region-naming-ctx, r=estebank\n\nVarious refactorings to clean up nll diagnostics\n\n- Create ErrorReportingCtx and ErrorConstraintInfo, vasting reducing the\n  number of arguments passed around everywhere in the error reporting code\n- Create RegionErrorNamingCtx, making a given lifetime have consistent\n  numbering thoughout all error messages for that MIR def.\n- Make the error reporting code return the DiagnosticBuilder rather than\n  directly buffer the Diagnostic. This makes it easier to modify the\n  diagnostic later, e.g. to add suggestions.\n\nr? @estebank\n\nSplit out from https://github.com/rust-lang/rust/pull/58281\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "html_url": "https://github.com/rust-lang/rust/commit/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeb32f01b674e383d240b3a173d6d9bc29c7a6ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb32f01b674e383d240b3a173d6d9bc29c7a6ad", "html_url": "https://github.com/rust-lang/rust/commit/aeb32f01b674e383d240b3a173d6d9bc29c7a6ad"}, {"sha": "2a774b1e6bfda649f75dcc6d32502100f8420a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a774b1e6bfda649f75dcc6d32502100f8420a3a", "html_url": "https://github.com/rust-lang/rust/commit/2a774b1e6bfda649f75dcc6d32502100f8420a3a"}], "stats": {"total": 530, "additions": 316, "deletions": 214}, "files": [{"sha": "26a89b4e7a8d1ec412b1e0efbb7342ee4cb30452", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 128, "deletions": 115, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{ConstraintCategory, Location, Body};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n use std::collections::VecDeque;\n use syntax::errors::Applicability;\n use syntax::symbol::kw;\n@@ -22,7 +22,7 @@ use syntax_pos::Span;\n mod region_name;\n mod var_name;\n \n-crate use self::region_name::{RegionName, RegionNameSource};\n+crate use self::region_name::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -54,6 +54,39 @@ enum Trace {\n     NotVisited,\n }\n \n+/// Various pieces of state used when reporting borrow checker errors.\n+pub struct ErrorReportingCtx<'a, 'b, 'tcx> {\n+    /// The region inference context used for borrow chekcing this MIR body.\n+    #[allow(dead_code)] // FIXME(mark-i-m): used by outlives suggestions\n+    region_infcx: &'b RegionInferenceContext<'tcx>,\n+\n+    /// The inference context used for type checking.\n+    infcx: &'b InferCtxt<'a, 'tcx>,\n+\n+    /// The MIR def we are reporting errors on.\n+    mir_def_id: DefId,\n+\n+    /// The MIR body we are reporting errors on (for convenience).\n+    body: &'b Body<'tcx>,\n+\n+    /// Any upvars for the MIR body we have kept track of during borrow checking.\n+    upvars: &'b [Upvar],\n+}\n+\n+/// Information about the various region constraints involved in a borrow checker error.\n+#[derive(Clone, Debug)]\n+pub struct ErrorConstraintInfo {\n+    // fr: outlived_fr\n+    fr: RegionVid,\n+    fr_is_local: bool,\n+    outlived_fr: RegionVid,\n+    outlived_fr_is_local: bool,\n+\n+    // Category and span for best blame constraint\n+    category: ConstraintCategory,\n+    span: Span,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Tries to find the best constraint to blame for the fact that\n     /// `R: from_region`, where `R` is some region that meets\n@@ -257,16 +290,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    pub(super) fn report_error(\n-        &self,\n+    pub(super) fn report_error<'a>(\n+        &'a self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n         let (category, _, span) = self.best_blame_constraint(body, fr, |r| {\n@@ -279,8 +312,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n             let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n-                diag.buffer(errors_buffer);\n-                return;\n+                return diag;\n             }\n         }\n \n@@ -293,45 +325,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n             fr_is_local, outlived_fr_is_local, category\n         );\n+\n+        let errctx = ErrorReportingCtx {\n+            region_infcx: self,\n+            infcx,\n+            mir_def_id,\n+            body,\n+            upvars,\n+        };\n+\n+        let errci = ErrorConstraintInfo {\n+            fr, outlived_fr, fr_is_local, outlived_fr_is_local, category, span\n+        };\n+\n         match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n-                self.report_fnmut_error(\n-                    body,\n-                    upvars,\n-                    infcx,\n-                    mir_def_id,\n-                    fr,\n-                    outlived_fr,\n-                    span,\n-                    errors_buffer,\n-                )\n+                self.report_fnmut_error(&errctx, &errci, renctx)\n             }\n             (ConstraintCategory::Assignment, true, false)\n-            | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                outlived_fr,\n-                category,\n-                span,\n-                errors_buffer,\n-            ),\n-            _ => self.report_general_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                fr_is_local,\n-                outlived_fr,\n-                outlived_fr_is_local,\n-                category,\n-                span,\n-                errors_buffer,\n-            ),\n-        };\n+            | (ConstraintCategory::CallArgument, true, false) =>\n+                self.report_escaping_data_error(&errctx, &errci, renctx),\n+            _ => self.report_general_error(&errctx, &errci, renctx),\n+        }\n     }\n \n     /// We have a constraint `fr1: fr2` that is not satisfied, where\n@@ -379,19 +394,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        _fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n-        let mut diag = infcx\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorConstraintInfo {\n+            outlived_fr, span, ..\n+        } = errci;\n+\n+        let mut diag = errctx\n+            .infcx\n             .tcx\n             .sess\n-            .struct_span_err(span, \"captured variable cannot escape `FnMut` closure body\");\n+            .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n@@ -403,11 +418,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"returns a reference to a captured variable which escapes the closure body\"\n         };\n \n-        diag.span_label(span, message);\n+        diag.span_label(*span, message);\n \n-        match self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, &mut 1)\n-            .unwrap().source\n-        {\n+        match self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -427,7 +440,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n         diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Reports a error specifically for when data is escaping a closure.\n@@ -444,20 +457,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        category: ConstraintCategory,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorReportingCtx {\n+            infcx, body, upvars, ..\n+        } = errctx;\n+\n+        let ErrorConstraintInfo {\n+            span, category, ..\n+        } = errci;\n+\n         let fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -469,27 +484,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Revert to the normal error in these cases.\n         // Assignments aren't \"escapes\" in function items.\n         if (fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none())\n-            || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n+            || (*category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n             return self.report_general_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                true,\n-                outlived_fr,\n-                false,\n-                category,\n-                span,\n-                errors_buffer,\n+                errctx,\n+                &ErrorConstraintInfo {\n+                    fr_is_local: true,\n+                    outlived_fr_is_local: false,\n+                    .. *errci\n+                },\n+                renctx,\n             );\n         }\n \n         let mut diag = borrowck_errors::borrowed_data_escapes_closure(\n             infcx.tcx,\n-            span,\n+            *span,\n             escapes_from,\n         );\n \n@@ -513,12 +524,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             diag.span_label(\n-                span,\n+                *span,\n                 format!(\"`{}` escapes the {} body here\", fr_name, escapes_from),\n             );\n         }\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Reports a region inference error for the general case with named/synthesized lifetimes to\n@@ -538,41 +549,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        fr_is_local: bool,\n-        outlived_fr: RegionVid,\n-        outlived_fr_is_local: bool,\n-        category: ConstraintCategory,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorReportingCtx {\n+            infcx, mir_def_id, ..\n+        } = errctx;\n+        let ErrorConstraintInfo {\n+            fr, fr_is_local, outlived_fr, outlived_fr_is_local, span, category, ..\n+        } = errci;\n+\n         let mut diag = infcx.tcx.sess.struct_span_err(\n-            span,\n+            *span,\n             \"lifetime may not live long enough\"\n         );\n \n-        let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx, body, upvars, mir_def_id, fr, counter).unwrap();\n-        fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name =\n-            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, counter).unwrap();\n-        outlived_fr_name.highlight_region_name(&mut diag);\n-\n-        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n+        let mir_def_name = if infcx.tcx.is_closure(*mir_def_id) {\n             \"closure\"\n         } else {\n             \"function\"\n         };\n \n+        let fr_name = self.give_region_a_name(errctx, renctx, *fr).unwrap();\n+        fr_name.highlight_region_name(&mut diag);\n+        let outlived_fr_name = self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap();\n+        outlived_fr_name.highlight_region_name(&mut diag);\n+\n         match (category, outlived_fr_is_local, fr_is_local) {\n             (ConstraintCategory::Return, true, _) => {\n                 diag.span_label(\n-                    span,\n+                    *span,\n                     format!(\n                         \"{} was supposed to return data with lifetime `{}` but it is returning \\\n                          data with lifetime `{}`\",\n@@ -582,7 +589,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n             _ => {\n                 diag.span_label(\n-                    span,\n+                    *span,\n                     format!(\n                         \"{}requires that `{}` must outlive `{}`\",\n                         category.description(),\n@@ -593,9 +600,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(infcx, &mut diag, fr, fr_name, outlived_fr);\n+        self.add_static_impl_trait_suggestion(infcx, &mut diag, *fr, fr_name, *outlived_fr);\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Adds a suggestion to errors where a `impl Trait` is returned.\n@@ -704,8 +711,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             borrow_region,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region)\n         );\n-        let outlived_fr_name =\n-            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_region, &mut 1);\n+\n+        let mut renctx = RegionErrorNamingCtx::new();\n+        let errctx = ErrorReportingCtx {\n+            infcx, body, upvars, mir_def_id,\n+            region_infcx: self,\n+        };\n+        let outlived_fr_name = self.give_region_a_name(&errctx, &mut renctx, outlived_region);\n+\n         (category, from_closure, span, outlived_fr_name)\n     }\n "}, {"sha": "6fa94269107f583388ea5f71819150d454983f5f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 127, "deletions": 71, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "patch": "@@ -1,5 +1,9 @@\n use std::fmt::{self, Display};\n-use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n+\n+use crate::borrow_check::nll::region_infer::{\n+    RegionInferenceContext,\n+    error_reporting::ErrorReportingCtx,\n+};\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n@@ -13,29 +17,75 @@ use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n-use syntax_pos::Span;\n-use syntax_pos::symbol::InternedString;\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::{Span, symbol::InternedString};\n \n-#[derive(Debug)]\n+/// A name for a particular region used in emitting diagnostics. This name could be a generated\n+/// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n+#[derive(Debug, Clone)]\n crate struct RegionName {\n+    /// The name of the region (interned).\n     crate name: InternedString,\n+    /// Where the region comes from.\n     crate source: RegionNameSource,\n }\n \n-#[derive(Debug)]\n+/// Denotes the source of a region that is named by a `RegionName`. For example, a free region that\n+/// was named by the user would get `NamedFreeRegion` and `'static` lifetime would get `Static`.\n+/// This helps to print the right kinds of diagnostics.\n+#[derive(Debug, Clone)]\n crate enum RegionNameSource {\n+    /// A bound (not free) region that was substituted at the def site (not an HRTB).\n     NamedEarlyBoundRegion(Span),\n+    /// A free region that the user has a name (`'a`) for.\n     NamedFreeRegion(Span),\n+    /// The `'static` region.\n     Static,\n+    /// The free region corresponding to the environment of a closure.\n     SynthesizedFreeEnvRegion(Span, String),\n+    /// The region name corresponds to a region where the type annotation is completely missing\n+    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n     CannotMatchHirTy(Span, String),\n+    /// The region name corresponds a reference that was found by traversing the type in the HIR.\n     MatchedHirTy(Span),\n+    /// A region name from the generics list of a struct/enum/union.\n     MatchedAdtAndSegment(Span),\n+    /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n+    /// The region corresponding to the return type of a closure.\n     AnonRegionFromOutput(Span, String, String),\n     AnonRegionFromYieldTy(Span, String),\n }\n \n+/// Records region names that have been assigned before so that we can use the same ones in later\n+/// diagnostics.\n+#[derive(Debug, Clone)]\n+crate struct RegionErrorNamingCtx {\n+    /// Record the region names generated for each region in the given\n+    /// MIR def so that we can reuse them later in help/error messages.\n+    renctx: FxHashMap<RegionVid, RegionName>,\n+\n+    /// The counter for generating new region names.\n+    counter: usize,\n+}\n+\n+impl RegionErrorNamingCtx {\n+    crate fn new() -> Self {\n+        Self {\n+            counter: 1,\n+            renctx: FxHashMap::default(),\n+        }\n+    }\n+\n+    crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n+        self.renctx.get(region)\n+    }\n+\n+    crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n+        self.renctx.insert(region, name);\n+    }\n+}\n+\n impl RegionName {\n     #[allow(dead_code)]\n     crate fn was_named(&self) -> bool {\n@@ -63,43 +113,40 @@ impl RegionName {\n         self.name\n     }\n \n-    crate fn highlight_region_name(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>\n-    ) {\n+    crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n         match &self.source {\n-            RegionNameSource::NamedFreeRegion(span) |\n-            RegionNameSource::NamedEarlyBoundRegion(span) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\"lifetime `{}` defined here\", self),\n-                );\n-            },\n+            RegionNameSource::NamedFreeRegion(span)\n+            | RegionNameSource::NamedEarlyBoundRegion(span) => {\n+                diag.span_label(*span, format!(\"lifetime `{}` defined here\", self));\n+            }\n             RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"lifetime `{}` represents this closure's body\", self),\n                 );\n                 diag.note(&note);\n-            },\n+            }\n             RegionNameSource::CannotMatchHirTy(span, type_name) => {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n-            },\n+            }\n             RegionNameSource::MatchedHirTy(span) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"let's call the lifetime of this reference `{}`\", self),\n                 );\n-            },\n+            }\n             RegionNameSource::MatchedAdtAndSegment(span) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n-            },\n+            }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                    format!(\n+                        \"lifetime `{}` appears in the type of `{}`\",\n+                        self, upvar_name\n+                    ),\n                 );\n-            },\n+            }\n             RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n                 diag.span_label(\n                     *span,\n@@ -151,39 +198,49 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and then return the name `'1` for us to use.\n     crate fn give_region_a_name(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        renctx: &mut RegionErrorNamingCtx,\n         fr: RegionVid,\n-        counter: &mut usize,\n     ) -> Option<RegionName> {\n-        debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n+        let ErrorReportingCtx {\n+            infcx, body, mir_def_id, upvars, ..\n+        } = errctx;\n+\n+        debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n \n-        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter)\n+        if let Some(value) = renctx.get(&fr) {\n+            return Some(value.clone());\n+        }\n+\n+        let value = self\n+            .give_name_from_error_region(infcx.tcx, *mir_def_id, fr, renctx)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, upvars, fr, counter,\n+                    infcx.tcx, upvars, fr, renctx\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_yield_ty(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             });\n \n+        if let Some(ref value) = value {\n+            renctx.insert(fr, value.clone());\n+        }\n+\n         debug!(\"give_region_a_name: gave name {:?}\", value);\n         value\n     }\n@@ -197,7 +254,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n@@ -208,7 +265,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let span = self.get_named_span(tcx, error_region, ebr.name);\n                     Some(RegionName {\n                         name: ebr.name,\n-                        source: RegionNameSource::NamedEarlyBoundRegion(span)\n+                        source: RegionNameSource::NamedEarlyBoundRegion(span),\n                     })\n                 } else {\n                     None\n@@ -227,12 +284,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         name,\n                         source: RegionNameSource::NamedFreeRegion(span),\n                     })\n-                },\n+                }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = tcx.hir()\n-                                        .as_local_hir_id(mir_def_id)\n-                                        .expect(\"non-local mir\");\n+                    let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n@@ -243,7 +298,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = self.synthesize_region_name(counter);\n+                        let region_name = self.synthesize_region_name(renctx);\n \n                         let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -265,7 +320,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             name: region_name,\n                             source: RegionNameSource::SynthesizedFreeEnvRegion(\n                                 args_span,\n-                                note.to_string()\n+                                note.to_string(),\n                             ),\n                         })\n                     } else {\n@@ -335,7 +390,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n@@ -349,12 +404,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             fr,\n             arg_ty,\n             argument_index,\n-            counter,\n+            renctx,\n         ) {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, counter)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, renctx)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -365,7 +420,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n@@ -379,15 +434,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 body,\n                 needle_fr,\n                 argument_ty,\n-                counter,\n+                renctx,\n             ),\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n                 infcx.tcx,\n                 needle_fr,\n                 argument_ty,\n                 argument_hir_ty,\n-                counter,\n+                renctx,\n             ),\n         }\n     }\n@@ -409,10 +464,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n+        let counter = renctx.counter;\n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(needle_fr, *counter);\n+        highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name = infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n@@ -428,7 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: self.synthesize_region_name(counter),\n+                name: self.synthesize_region_name(renctx),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -455,7 +511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// type. Once we find that, we can use the span of the `hir::Ty`\n     /// to add the highlight.\n     ///\n-    /// This is a somewhat imperfect process, so long the way we also\n+    /// This is a somewhat imperfect process, so along the way we also\n     /// keep track of the **closest** type we've found. If we fail to\n     /// find the exact `&` or `'_` to highlight, then we may fall back\n     /// to highlighting that closest type instead.\n@@ -465,7 +521,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n@@ -483,7 +539,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = self.synthesize_region_name(counter);\n+                        let region_name = self.synthesize_region_name(renctx);\n \n                         // Just grab the first character, the `&`.\n                         let source_map = tcx.sess.source_map();\n@@ -515,7 +571,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                 substs,\n                                 needle_fr,\n                                 last_segment,\n-                                counter,\n+                                renctx,\n                                 search_stack,\n                             ) {\n                                 return Some(name);\n@@ -559,18 +615,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n-        let lifetime = self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n+        let lifetime =\n+            self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n             hir::LifetimeName::Param(_)\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = self.synthesize_region_name(counter);\n+                let region_name = self.synthesize_region_name(renctx);\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -657,12 +714,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n-        let region_name = self.synthesize_region_name(counter);\n+        let region_name = self.synthesize_region_name(renctx);\n \n         Some(RegionName {\n             name: region_name,\n@@ -680,7 +737,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let tcx = infcx.tcx;\n \n@@ -694,7 +751,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *counter);\n+        highlight.highlighting_region_vid(fr, renctx.counter);\n         let type_name = infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n@@ -725,11 +782,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: self.synthesize_region_name(counter),\n+            name: self.synthesize_region_name(renctx),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n-                type_name\n+                type_name,\n             ),\n         })\n     }\n@@ -740,7 +797,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n@@ -757,7 +814,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *counter);\n+        highlight.highlighting_region_vid(fr, renctx.counter);\n         let type_name = infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n@@ -780,16 +837,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         Some(RegionName {\n-            name: self.synthesize_region_name(counter),\n+            name: self.synthesize_region_name(renctx),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }\n \n-    /// Creates a synthetic region named `'1`, incrementing the\n-    /// counter.\n-    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n-        let c = *counter;\n-        *counter += 1;\n+    /// Creates a synthetic region named `'1`, incrementing the counter.\n+    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> InternedString {\n+        let c = renctx.counter;\n+        renctx.counter += 1;\n \n         InternedString::intern(&format!(\"'{:?}\", c))\n     }"}, {"sha": "78e7943598d68ad7eb8761fe5f3bd935b04ef2c1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "patch": "@@ -1,15 +1,20 @@\n-use super::universal_regions::UniversalRegions;\n-use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use crate::borrow_check::nll::constraints::{\n-    ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n-};\n-use crate::borrow_check::nll::member_constraints::{MemberConstraintSet, NllMemberConstraintIndex};\n-use crate::borrow_check::nll::region_infer::values::{\n-    PlaceholderIndices, RegionElement, ToElementIndex,\n+use std::rc::Rc;\n+\n+use crate::borrow_check::nll::{\n+    constraints::{\n+        graph::NormalConstraintGraph,\n+        ConstraintSccIndex,\n+        OutlivesConstraint,\n+        OutlivesConstraintSet,\n+    },\n+    member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n+    region_infer::values::{\n+        PlaceholderIndices, RegionElement, ToElementIndex\n+    },\n+    type_check::{free_region_relations::UniversalRegionRelations, Locations},\n };\n-use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n-use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::Upvar;\n+\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryOutlivesConstraint;\n use rustc::infer::opaque_types;\n@@ -31,16 +36,16 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n \n-use std::rc::Rc;\n+crate use self::error_reporting::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n+use self::values::{LivenessValues, RegionValueElements, RegionValues};\n+use super::universal_regions::UniversalRegions;\n+use super::ToRegionVid;\n \n mod dump_mir;\n mod error_reporting;\n-crate use self::error_reporting::{RegionName, RegionNameSource};\n mod graphviz;\n-pub mod values;\n-use self::values::{LivenessValues, RegionValueElements, RegionValues};\n \n-use super::ToRegionVid;\n+pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable. Region\n@@ -487,13 +492,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n+        // If we produce any errors, we keep track of the names of all regions, so that we can use\n+        // the same error names in any suggestions we produce. Note that we need names to be unique\n+        // across different errors for the same MIR def so that we can make suggestions that fix\n+        // multiple problems.\n+        let mut region_naming = RegionErrorNamingCtx::new();\n+\n         self.check_universal_regions(\n             infcx,\n             body,\n             upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n+            &mut region_naming,\n         );\n \n         self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n@@ -1312,6 +1324,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) {\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n@@ -1327,6 +1340,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         fr,\n                         &mut propagated_outlives_requirements,\n                         errors_buffer,\n+                        region_naming,\n                     );\n                 }\n \n@@ -1358,6 +1372,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) {\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n@@ -1385,6 +1400,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n+                region_naming,\n             );\n             return;\n         }\n@@ -1401,8 +1417,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n+                region_naming,\n             ) {\n                 // continuing to iterate just reports more errors than necessary\n+                //\n+                // FIXME It would also allow us to report more Outlives Suggestions, though, so\n+                // it's not clear that that's a bad thing. Somebody should try commenting out this\n+                // line and see it is actually a regression.\n                 return;\n             }\n         }\n@@ -1418,6 +1439,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n         if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n@@ -1466,7 +1488,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(body, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        let db = self.report_error(\n+            body,\n+            upvars,\n+            infcx,\n+            mir_def_id,\n+            longer_fr,\n+            shorter_fr,\n+            region_naming,\n+        );\n+\n+        db.buffer(errors_buffer);\n+\n         Some(ErrorReported)\n     }\n "}, {"sha": "ab8398ec5e935c498c4b7479e66974a026ed5e50", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "patch": "@@ -37,11 +37,11 @@ error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:20:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'1>`\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n    |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'2>`\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     *ap0 = ap1;\n-   |     ^^^^ assignment requires that `'1` must outlive `'2`\n+   |     ^^^^ assignment requires that `'2` must outlive `'1`\n \n error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:25:5\n@@ -57,11 +57,11 @@ error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:25:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               ---                   ------- has type `core::ffi::VaListImpl<'1>`\n+   |                                               ---                   ------- has type `core::ffi::VaListImpl<'2>`\n    |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'2>`\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     ap0 = &mut ap1;\n-   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'2` must outlive `'1`\n \n error[E0384]: cannot assign to immutable argument `ap0`\n   --> $DIR/variadic-ffi-4.rs:25:5\n@@ -99,11 +99,11 @@ error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:33:12\n    |\n LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'1>`\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n    |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'2>`\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     *ap0 = ap1.clone();\n-   |            ^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |            ^^^^^^^^^^^ argument requires that `'2` must outlive `'1`\n \n error: aborting due to 11 previous errors\n "}, {"sha": "2ed4d6d4401aa194c4b1e2f6b5731dc479a25cf9", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-3.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr?ref=69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "patch": "@@ -12,11 +12,11 @@ error: lifetime may not live long enough\n   --> $DIR/ex3-both-anon-regions-3.rs:2:5\n    |\n LL | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                         -                    - let's call the lifetime of this reference `'1`\n+   |                         -                    - let's call the lifetime of this reference `'3`\n    |                         |\n-   |                         let's call the lifetime of this reference `'2`\n+   |                         let's call the lifetime of this reference `'4`\n LL |     z.push((x,y));\n-   |     ^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^^^^^ argument requires that `'3` must outlive `'4`\n \n error: aborting due to 2 previous errors\n "}]}