{"sha": "65fafd9414915fe33bc69fb4bfefa8629b5e42ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZmFmZDk0MTQ5MTVmZTMzYmM2OWZiNGJmZWZhODYyOWI1ZTQyZWE=", "commit": {"author": {"name": "Suchith J N", "email": "suchithjn@localhost.localdomain", "date": "2017-04-15T04:44:09Z"}, "committer": {"name": "Suchith J N", "email": "suchithjn@localhost.localdomain", "date": "2017-04-15T04:44:09Z"}, "message": "[41272] - code for desugaring iflet changed", "tree": {"sha": "0abf71ed1a22b52a266cb88d357baa686a520d16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0abf71ed1a22b52a266cb88d357baa686a520d16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65fafd9414915fe33bc69fb4bfefa8629b5e42ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65fafd9414915fe33bc69fb4bfefa8629b5e42ea", "html_url": "https://github.com/rust-lang/rust/commit/65fafd9414915fe33bc69fb4bfefa8629b5e42ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65fafd9414915fe33bc69fb4bfefa8629b5e42ea/comments", "author": null, "committer": null, "parents": [{"sha": "4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "html_url": "https://github.com/rust-lang/rust/commit/4f32e0dfb287c2b3d0c48cb3b8090b3902960084"}], "stats": {"total": 110, "additions": 23, "deletions": 87}, "files": [{"sha": "adefd2a8d7baaccedf18e265540a333c846ff168", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 10, "deletions": 87, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/65fafd9414915fe33bc69fb4bfefa8629b5e42ea/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65fafd9414915fe33bc69fb4bfefa8629b5e42ea/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=65fafd9414915fe33bc69fb4bfefa8629b5e42ea", "patch": "@@ -2033,7 +2033,6 @@ impl<'a> LoweringContext<'a> {\n                 //\n                 //   match <sub_expr> {\n                 //     <pat> => <body>,\n-                //     [_ if <else_opt_if_cond> => <else_opt_if_body>,]\n                 //     _ => [<else_opt> | ()]\n                 //   }\n \n@@ -2047,93 +2046,17 @@ impl<'a> LoweringContext<'a> {\n                     arms.push(self.arm(hir_vec![pat], body_expr));\n                 }\n \n-                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                // `_ => [<else_opt> | ()]`\n+                // _ => [<else_opt>|()]\n                 {\n-                    let mut current: Option<&Expr> = else_opt.as_ref().map(|p| &**p);\n-                    let mut else_exprs: Vec<Option<&Expr>> = vec![current];\n-\n-                    // First, we traverse the AST and recursively collect all\n-                    // `else` branches into else_exprs, e.g.:\n-                    //\n-                    // if let Some(_) = x {\n-                    //    ...\n-                    // } else if ... {  // Expr1\n-                    //    ...\n-                    // } else if ... {  // Expr2\n-                    //    ...\n-                    // } else {         // Expr3\n-                    //    ...\n-                    // }\n-                    //\n-                    // ... results in else_exprs = [Some(&Expr1),\n-                    //                              Some(&Expr2),\n-                    //                              Some(&Expr3)]\n-                    //\n-                    // Because there also the case there is no `else`, these\n-                    // entries can also be `None`, as in:\n-                    //\n-                    // if let Some(_) = x {\n-                    //    ...\n-                    // } else if ... {  // Expr1\n-                    //    ...\n-                    // } else if ... {  // Expr2\n-                    //    ...\n-                    // }\n-                    //\n-                    // ... results in else_exprs = [Some(&Expr1),\n-                    //                              Some(&Expr2),\n-                    //                              None]\n-                    //\n-                    // The last entry in this list is always translated into\n-                    // the final \"unguard\" wildcard arm of the `match`. In the\n-                    // case of a `None`, it becomes `_ => ()`.\n-                    loop {\n-                        if let Some(e) = current {\n-                            // There is an else branch at this level\n-                            if let ExprKind::If(_, _, ref else_opt) = e.node {\n-                                // The else branch is again an if-expr\n-                                current = else_opt.as_ref().map(|p| &**p);\n-                                else_exprs.push(current);\n-                            } else {\n-                                // The last item in the list is not an if-expr,\n-                                // stop here\n-                                break\n-                             }\n-                        } else {\n-                            // We have no more else branch\n-                            break\n-                         }\n-                    }\n-\n-                    // Now translate the list of nested else-branches into the\n-                    // arms of the match statement.\n-                    for else_expr in else_exprs {\n-                        if let Some(else_expr) = else_expr {\n-                            let (guard, body) = if let ExprKind::If(ref cond,\n-                                                                    ref then,\n-                                                                    _) = else_expr.node {\n-                                let then = self.lower_block(then, false);\n-                                (Some(cond),\n-                                 self.expr_block(then, ThinVec::new()))\n-                            } else {\n-                                (None,\n-                                 self.lower_expr(else_expr))\n-                            };\n-\n-                            arms.push(hir::Arm {\n-                                attrs: hir_vec![],\n-                                pats: hir_vec![self.pat_wild(e.span)],\n-                                guard: guard.map(|e| P(self.lower_expr(e))),\n-                                body: P(body),\n-                            });\n-                        } else {\n-                            // There was no else-branch, push a noop\n-                            let pat_under = self.pat_wild(e.span);\n-                            let unit = self.expr_tuple(e.span, hir_vec![]);\n-                            arms.push(self.arm(hir_vec![pat_under], unit));\n-                        }\n-                    }\n+                \tlet wildcard_arm: Option<&Expr> = else_opt.as_ref().map(|p| &**p);\n+\t\t\t\t\tlet wildcard_pattern = self.pat_wild(e.span);\n+\t\t\t\t\tlet body = \n+\t\t\t\t\t\tif let Some(else_expr) = wildcard_arm {\n+\t\t\t\t\t\t\tP(self.lower_expr(else_expr))\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tself.expr_tuple(e.span, hir_vec![])\n+\t\t\t\t\t\t};\n+\t\t\t\t\tarms.push(self.arm(hir_vec![wildcard_pattern], body));\n                 }\n \n                 let contains_else_clause = else_opt.is_some();"}, {"sha": "154aa5b8cbe6372f3fbc2521255857392823bea2", "filename": "src/test/run-pass/issue-41272.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/65fafd9414915fe33bc69fb4bfefa8629b5e42ea/src%2Ftest%2Frun-pass%2Fissue-41272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65fafd9414915fe33bc69fb4bfefa8629b5e42ea/src%2Ftest%2Frun-pass%2Fissue-41272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41272.rs?ref=65fafd9414915fe33bc69fb4bfefa8629b5e42ea", "patch": "@@ -0,0 +1,13 @@\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&mut self) -> bool { true }\n+}\n+\n+/* This causes E0301. By fixing issue #41272 this problem should vanish */\n+fn iflet_issue(foo: &mut Foo) {\n+    if let Some(_) = Some(true) {\n+    } else if foo.bar() {}\n+}\n+\n+fn main() {}"}]}