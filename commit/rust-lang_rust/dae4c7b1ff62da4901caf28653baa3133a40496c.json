{"sha": "dae4c7b1ff62da4901caf28653baa3133a40496c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZTRjN2IxZmY2MmRhNDkwMWNhZjI4NjUzYmFhMzEzM2E0MDQ5NmM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T00:25:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-26T21:32:30Z"}, "message": "resolve: Implement edition hygiene for imports and absolute paths\n\nUse per-span hygiene in a few other places in resolve\nPrefer `rust_2015`/`rust_2018` helpers to comparing editions", "tree": {"sha": "c805c4c5ed9442f48ed0a611cacdce35b03947d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c805c4c5ed9442f48ed0a611cacdce35b03947d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dae4c7b1ff62da4901caf28653baa3133a40496c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dae4c7b1ff62da4901caf28653baa3133a40496c", "html_url": "https://github.com/rust-lang/rust/commit/dae4c7b1ff62da4901caf28653baa3133a40496c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dae4c7b1ff62da4901caf28653baa3133a40496c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba116fc5fb7018faeb1834d42422d7bdbcc4f64", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba116fc5fb7018faeb1834d42422d7bdbcc4f64", "html_url": "https://github.com/rust-lang/rust/commit/fba116fc5fb7018faeb1834d42422d7bdbcc4f64"}], "stats": {"total": 301, "additions": 226, "deletions": 75}, "files": [{"sha": "d383d8375a948dd7b132bf85af124cd0f88ddeed", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -1478,15 +1478,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// done with either: `-Ztwo-phase-borrows`, `#![feature(nll)]`,\n     /// or by opting into an edition after 2015.\n     pub fn two_phase_borrows(self) -> bool {\n-        if self.features().nll || self.sess.opts.debugging_opts.two_phase_borrows {\n-            return true;\n-        }\n-\n-        match self.sess.edition() {\n-            Edition::Edition2015 => false,\n-            Edition::Edition2018 => true,\n-            _ => true,\n-        }\n+        self.sess.rust_2018() || self.features().nll ||\n+        self.sess.opts.debugging_opts.two_phase_borrows\n     }\n \n     /// What mode(s) of borrowck should we run? AST? MIR? both?"}, {"sha": "350e55288ea10a24d716d373f1be9abc652bf567", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -14,7 +14,6 @@ use ty::{self, DefIdTree, Ty, TyCtxt};\n use middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n use syntax::symbol::{keywords, LocalInternedString, Symbol};\n-use syntax_pos::edition::Edition;\n \n use std::cell::Cell;\n use std::fmt::Debug;\n@@ -140,7 +139,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         debug!(\"push_krate_path: name={:?}\", name);\n                         buffer.push(&name);\n                     }\n-                } else if self.sess.edition() == Edition::Edition2018 && !pushed_prelude_crate {\n+                } else if self.sess.rust_2018() && !pushed_prelude_crate {\n                     SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n                         // We only add the `crate::` keyword where appropriate. In particular,\n                         // when we've not previously pushed a prelude crate to this path."}, {"sha": "3f0780191fb2a4c49d3f6ada05cc8ef8e6f228c3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -133,14 +133,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // The root is prepended lazily, when the first non-empty prefix or terminating glob\n         // appears, so imports in braced groups can have roots prepended independently.\n         let is_glob = if let ast::UseTreeKind::Glob = use_tree.kind { true } else { false };\n-        let crate_root = if !self.session.rust_2018() &&\n-                prefix_iter.peek().map_or(is_glob, |seg| !seg.ident.is_path_segment_keyword()) {\n-            Some(Segment::from_ident(Ident::new(\n-                keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo()\n-            )))\n-        } else {\n-            None\n-        };\n+        let crate_root = match prefix_iter.peek() {\n+            Some(seg) if !seg.ident.is_path_segment_keyword() && seg.ident.span.rust_2015() => {\n+                Some(seg.ident.span.ctxt())\n+            }\n+            None if is_glob && use_tree.span.rust_2015() => {\n+                Some(use_tree.span.ctxt())\n+            }\n+            _ => None,\n+        }.map(|ctxt| Segment::from_ident(Ident::new(\n+            keywords::CrateRoot.name(), use_tree.prefix.span.shrink_to_lo().with_ctxt(ctxt)\n+        )));\n \n         let prefix = crate_root.into_iter().chain(prefix_iter).collect::<Vec<_>>();\n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);"}, {"sha": "e2a6303f579449e8f60e272c29b1119154c6a709", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -33,7 +33,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             (Some(fst), Some(snd)) if fst.ident.name == keywords::CrateRoot.name() &&\n                                       !snd.ident.is_path_segment_keyword() => {}\n             // `ident::...` on 2018\n-            (Some(fst), _) if self.session.rust_2018() && !fst.ident.is_path_segment_keyword() => {\n+            (Some(fst), _) if fst.ident.span.rust_2018() &&\n+                              !fst.ident.is_path_segment_keyword() => {\n                 // Insert a placeholder that's later replaced by `self`/`super`/etc.\n                 path.insert(0, Segment::from_ident(keywords::Invalid.ident()));\n             }\n@@ -141,7 +142,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n-        if !self.session.rust_2018() {\n+        if path[1].ident.span.rust_2015() {\n             return None;\n         }\n "}, {"sha": "2e7ed80c91bb31403d5646c9ec3e20e43849f429", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -2354,14 +2354,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn future_proof_import(&mut self, use_tree: &ast::UseTree) {\n-        if !self.session.rust_2018() {\n-            return;\n-        }\n-\n         let segments = &use_tree.prefix.segments;\n         if !segments.is_empty() {\n             let ident = segments[0].ident;\n-            if ident.is_path_segment_keyword() {\n+            if ident.is_path_segment_keyword() || ident.span.rust_2015() {\n                 return;\n             }\n \n@@ -3181,10 +3177,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = path.last().unwrap().ident;\n-            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n+            let candidates = this.lookup_import_candidates(ident, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n-                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n+                    this.lookup_import_candidates(ident, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -3772,7 +3768,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() && self.session.rust_2018() {\n+                       name == keywords::CrateRoot.name() && ident.span.rust_2018() {\n                         module =\n                             Some(ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude));\n                         continue;\n@@ -3875,7 +3871,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     let msg = if module_def == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_import_candidates(name, TypeNS, is_mod);\n+                            self.lookup_import_candidates(ident, TypeNS, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n                             (c.path.segments.len(), c.path.to_string())\n                         });\n@@ -3911,11 +3907,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n-        // In the 2018 edition this lint is a hard error, so nothing to do\n-        if self.session.rust_2018() {\n-            return\n-        }\n-\n         let (diag_id, diag_span) = match crate_lint {\n             CrateLint::No => return,\n             CrateLint::SimplePath(id) => (id, path_span),\n@@ -3924,8 +3915,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         let first_name = match path.get(0) {\n-            Some(ident) => ident.ident.name,\n-            None => return,\n+            // In the 2018 edition this lint is a hard error, so nothing to do\n+            Some(seg) if seg.ident.span.rust_2015() => seg.ident.name,\n+            _ => return,\n         };\n \n         // We're only interested in `use` paths which should start with\n@@ -4507,7 +4499,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n-                                          lookup_name: Name,\n+                                          lookup_ident: Ident,\n                                           namespace: Namespace,\n                                           start_module: &'a ModuleData<'a>,\n                                           crate_name: Ident,\n@@ -4534,11 +4526,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 if !name_binding.is_importable() { return; }\n \n                 // collect results based on the filter function\n-                if ident.name == lookup_name && ns == namespace {\n+                if ident.name == lookup_ident.name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n                         let mut segms = path_segments.clone();\n-                        if self.session.rust_2018() {\n+                        if lookup_ident.span.rust_2018() {\n                             // crate-local absolute paths start with `crate::` in edition 2018\n                             // FIXME: may also be stabilized for Rust 2015 (Issues #45477, #44660)\n                             segms.insert(\n@@ -4572,7 +4564,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n                     let is_extern_crate_that_also_appears_in_prelude =\n                         name_binding.is_extern_crate() &&\n-                        self.session.rust_2018();\n+                        lookup_ident.span.rust_2018();\n \n                     let is_visible_to_user =\n                         !in_module_is_extern || name_binding.vis == ty::Visibility::Public;\n@@ -4599,16 +4591,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     /// NOTE: The method does not look into imports, but this is not a problem,\n     /// since we report the definitions (thus, the de-aliased imports).\n     fn lookup_import_candidates<FilterFn>(&mut self,\n-                                          lookup_name: Name,\n+                                          lookup_ident: Ident,\n                                           namespace: Namespace,\n                                           filter_fn: FilterFn)\n                                           -> Vec<ImportSuggestion>\n         where FilterFn: Fn(Def) -> bool\n     {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n-            lookup_name, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n+            lookup_ident, namespace, self.graph_root, keywords::Crate.ident(), &filter_fn);\n \n-        if self.session.rust_2018() {\n+        if lookup_ident.span.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for (ident, _) in extern_prelude_names.into_iter() {\n                 if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n@@ -4620,7 +4612,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     self.populate_module_if_necessary(&crate_root);\n \n                     suggestions.extend(self.lookup_import_candidates_from_module(\n-                        lookup_name, namespace, crate_root, ident, &filter_fn));\n+                        lookup_ident, namespace, crate_root, ident, &filter_fn));\n                 }\n             }\n         }\n@@ -4712,19 +4704,26 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n                 // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n-                let first_ident = path.segments[0].ident;\n-                if self.session.rust_2018() && !first_ident.is_path_segment_keyword() {\n+                // On 2015 edition visibilities are resolved as crate-relative by default,\n+                // so we are prepending a root segment if necessary.\n+                let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n+                let crate_root = if ident.is_path_segment_keyword() {\n+                    None\n+                } else if ident.span.rust_2018() {\n                     let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n-                    self.session.struct_span_err(first_ident.span, msg)\n+                    self.session.struct_span_err(ident.span, msg)\n                                 .span_suggestion(path.span, \"try\", format!(\"crate::{}\", path))\n                                 .emit();\n                     return ty::Visibility::Public;\n-                }\n-                // On 2015 visibilities are resolved as crate-relative by default,\n-                // add starting root segment if necessary.\n-                let segments = path.make_root().iter().chain(path.segments.iter())\n-                    .map(|seg| Segment { ident: seg.ident, id: Some(seg.id) })\n-                    .collect::<Vec<_>>();\n+                } else {\n+                    let ctxt = ident.span.ctxt();\n+                    Some(Segment::from_ident(Ident::new(\n+                        keywords::CrateRoot.name(), path.span.shrink_to_lo().with_ctxt(ctxt)\n+                    )))\n+                };\n+\n+                let segments = crate_root.into_iter()\n+                    .chain(path.segments.iter().map(|seg| seg.into())).collect::<Vec<_>>();\n                 let def = self.smart_resolve_path_fragment(\n                     id,\n                     None,\n@@ -4837,7 +4836,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 help_msgs.push(format!(\"consider adding an explicit import of \\\n                                         `{ident}` to disambiguate\", ident = ident))\n             }\n-            if b.is_extern_crate() && self.session.rust_2018() {\n+            if b.is_extern_crate() && ident.span.rust_2018() {\n                 help_msgs.push(format!(\"use `::{ident}` to refer to this {thing} unambiguously\",\n                                        ident = ident, thing = b.descr()))\n             }"}, {"sha": "6fa9110fedb7fa9612a4f0f422f4d48b138f51b3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -605,6 +605,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         assert!(force || !record_used); // `record_used` implies `force`\n         assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n+        let rust_2015 = ident.span.rust_2015();\n         ident = ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n@@ -696,7 +697,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n-                    if use_prelude || self.session.rust_2015() {\n+                    if use_prelude || rust_2015 {\n                         match self.macro_use_prelude.get(&ident.name).cloned() {\n                             Some(binding) =>\n                                 Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n@@ -725,7 +726,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n                 WhereToResolve::LegacyPluginHelpers => {\n-                    if (use_prelude || self.session.rust_2015()) &&\n+                    if (use_prelude || rust_2015) &&\n                        self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),"}, {"sha": "c82ebd6aa5128c32329a575830b25aa07b6e0543", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -43,7 +43,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use source_map::{self, SourceMap, Spanned, respan};\n-use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n+use syntax_pos::{self, Span, MultiSpan, BytePos, FileName};\n use errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n@@ -1404,11 +1404,7 @@ impl<'a> Parser<'a> {\n                 // definition...\n \n                 // We don't allow argument names to be left off in edition 2018.\n-                if p.span.edition() >= Edition::Edition2018 {\n-                    p.parse_arg_general(true)\n-                } else {\n-                    p.parse_arg_general(false)\n-                }\n+                p.parse_arg_general(p.span.rust_2018())\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -1601,9 +1597,9 @@ impl<'a> Parser<'a> {\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n-                  (self.span.edition() == Edition::Edition2018 ||\n+                  (self.span.rust_2018() ||\n                    self.look_ahead(1, |t| t.can_begin_bound() &&\n-                                         !can_continue_type_after_non_fn_ident(t))) {\n+                                          !can_continue_type_after_non_fn_ident(t))) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n             let bounds = self.parse_generic_bounds()?;\n@@ -2084,8 +2080,9 @@ impl<'a> Parser<'a> {\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n         let mut segments = Vec::new();\n+        let mod_sep_ctxt = self.span.ctxt();\n         if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n+            segments.push(PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n         self.parse_path_segments(&mut segments, style, enable_warning)?;\n \n@@ -2423,8 +2420,7 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n-                if self.span.edition() >= Edition::Edition2018 &&\n-                    self.check_keyword(keywords::Async)\n+                if self.span.rust_2018() && self.check_keyword(keywords::Async)\n                 {\n                     if self.is_async_block() { // check for `async {` and `async move {`\n                         return self.parse_async_block(attrs);\n@@ -3440,7 +3436,7 @@ impl<'a> Parser<'a> {\n         } else {\n             Movability::Movable\n         };\n-        let asyncness = if self.span.edition() >= Edition::Edition2018 {\n+        let asyncness = if self.span.rust_2018() {\n             self.parse_asyncness()\n         } else {\n             IsAsync::NotAsync\n@@ -4562,9 +4558,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&mut self) -> bool {\n         self.token.is_keyword(keywords::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-\n-        self.span.edition() >= Edition::Edition2018 &&\n-\n+        self.span.rust_2018() &&\n         // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -7648,8 +7642,11 @@ impl<'a> Parser<'a> {\n                       self.check(&token::BinOp(token::Star)) ||\n                       self.is_import_coupler() {\n             // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n+            let mod_sep_ctxt = self.span.ctxt();\n             if self.eat(&token::ModSep) {\n-                prefix.segments.push(PathSegment::crate_root(lo.shrink_to_lo()));\n+                prefix.segments.push(\n+                    PathSegment::crate_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n+                );\n             }\n \n             if self.eat(&token::BinOp(token::Star)) {"}, {"sha": "65f6d27239b83c53c4094fbd6dafecb911f7b155", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -325,6 +325,16 @@ impl Span {\n                                                     |einfo| einfo.edition)\n     }\n \n+    #[inline]\n+    pub fn rust_2015(&self) -> bool {\n+        self.edition() == edition::Edition::Edition2015\n+    }\n+\n+    #[inline]\n+    pub fn rust_2018(&self) -> bool {\n+        self.edition() >= edition::Edition::Edition2018\n+    }\n+\n     /// Return the source callee.\n     ///\n     /// Returns `None` if the supplied span has no expansion trace,"}, {"sha": "e333a4f2176f55b0027dc1987b68fdc5dae5b7ca", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -12,7 +12,6 @@\n //! allows bidirectional lookup; i.e. given a value, one can easily find the\n //! type, and vice versa.\n \n-use edition::Edition;\n use hygiene::SyntaxContext;\n use {Span, DUMMY_SP, GLOBALS};\n \n@@ -444,7 +443,7 @@ impl Ident {\n     pub fn is_unused_keyword(self) -> bool {\n         // Note: `span.edition()` is relatively expensive, don't call it unless necessary.\n         self.name >= keywords::Abstract.name() && self.name <= keywords::Yield.name() ||\n-        self.name.is_unused_keyword_2018() && self.span.edition() == Edition::Edition2018\n+        self.name.is_unused_keyword_2018() && self.span.rust_2018()\n     }\n \n     /// Returns `true` if the token is either a special identifier or a keyword."}, {"sha": "5bb818f7d23baedb45e8143997a0949ab5f589db", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/edition-imports-2015.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fedition-imports-2015.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,19 @@\n+// edition:2015\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Derive2015)]\n+pub fn derive_2015(_: TokenStream) -> TokenStream {\n+    \"\n+    use import::Path;\n+\n+    fn check_absolute() {\n+        let x = ::absolute::Path;\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "f8d6bc5e0785dd98e2472683c7dc0a9fbaa98d65", "filename": "src/test/ui-fulldeps/proc-macro/edition-imports-2018.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fedition-imports-2018.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,24 @@\n+// compile-pass\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+mod import {\n+    pub struct Path;\n+}\n+mod absolute {\n+    pub struct Path;\n+}\n+\n+mod check {\n+    #[derive(Derive2015)] // OK\n+    struct S;\n+\n+    fn check() {\n+        Path;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d596f97355f4c2dc68efab5aefb36d56d2399b55", "filename": "src/test/ui/editions/auxiliary/absolute.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fabsolute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fabsolute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fabsolute.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1 @@\n+pub struct Path;"}, {"sha": "fb1a89d402242f831b3c9dbd1e182634f53e478b", "filename": "src/test/ui/editions/auxiliary/edition-imports-2015.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2015.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,17 @@\n+// edition:2015\n+\n+#[macro_export]\n+macro_rules! gen_imports { () => {\n+    use import::Path;\n+    // use std::collections::LinkedList; // FIXME\n+\n+    fn check_absolute() {\n+        ::absolute::Path;\n+        // ::std::collections::LinkedList::<u8>::new(); // FIXME\n+    }\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_glob { () => {\n+    use *;\n+}}"}, {"sha": "b08dc499a0dddf16b15646b9d830b28bac86d470", "filename": "src/test/ui/editions/auxiliary/edition-imports-2018.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fauxiliary%2Fedition-imports-2018.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,17 @@\n+// edition:2018\n+\n+#[macro_export]\n+macro_rules! gen_imports { () => {\n+    use import::Path;\n+    use std::collections::LinkedList;\n+\n+    fn check_absolute() {\n+        ::absolute::Path;\n+        ::std::collections::LinkedList::<u8>::new();\n+    }\n+}}\n+\n+#[macro_export]\n+macro_rules! gen_glob { () => {\n+    use *;\n+}}"}, {"sha": "b89ca28e279db223c19a7b6a516c4e13f7aa4d8c", "filename": "src/test/ui/editions/edition-imports-2015.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,28 @@\n+// edition:2015\n+// compile-flags:--extern absolute\n+// aux-build:edition-imports-2018.rs\n+// aux-build:absolute.rs\n+\n+#![feature(uniform_paths)]\n+\n+#[macro_use]\n+extern crate edition_imports_2018;\n+\n+mod check {\n+    mod import {\n+        pub struct Path;\n+    }\n+\n+    gen_imports!(); // OK\n+\n+    fn check() {\n+        Path;\n+        LinkedList::<u8>::new();\n+    }\n+}\n+\n+mod check_glob {\n+    gen_glob!(); //~ ERROR cannot glob-import all possible crates\n+}\n+\n+fn main() {}"}, {"sha": "fb6b2e64ef5b8ddc27e50a1d561453eba564bea9", "filename": "src/test/ui/editions/edition-imports-2015.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,10 @@\n+error: cannot glob-import all possible crates\n+  --> $DIR/edition-imports-2015.rs:25:5\n+   |\n+LL |     gen_glob!(); //~ ERROR cannot glob-import all possible crates\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "cef4ce3bf16758069f7a1b6b32f5d6c3f6e91057", "filename": "src/test/ui/editions/edition-imports-2018.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae4c7b1ff62da4901caf28653baa3133a40496c/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.rs?ref=dae4c7b1ff62da4901caf28653baa3133a40496c", "patch": "@@ -0,0 +1,33 @@\n+// compile-pass\n+// edition:2018\n+// aux-build:edition-imports-2015.rs\n+\n+#[macro_use]\n+extern crate edition_imports_2015;\n+\n+mod import {\n+    pub struct Path;\n+}\n+mod absolute {\n+    pub struct Path;\n+}\n+\n+mod check {\n+    gen_imports!(); // OK\n+\n+    fn check() {\n+        Path;\n+        // LinkedList::<u8>::new(); // FIXME\n+    }\n+}\n+\n+mod check_glob {\n+    gen_glob!(); // OK\n+\n+    fn check() {\n+        import::Path;\n+        absolute::Path;\n+    }\n+}\n+\n+fn main() {}"}]}