{"sha": "87134c7d72d0a39f696051a22c05aa2b328a6d00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTM0YzdkNzJkMGEzOWY2OTYwNTFhMjJjMDVhYTJiMzI4YTZkMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-09T09:51:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-09T09:51:23Z"}, "message": "auto merge of #16326 : pnkfelix/rust/fsk-add-path-suffix-lookup, r=huonw\n\nExtended `ast_map::Map` with an iterator over all node id's that match a path suffix.\r\n\r\nExtended pretty printer to let users choose particular items to pretty print, either by indicating an integer node-id, or by providing a path suffix.\r\n\r\n * Example 1: the suffix `typeck::check::check_struct` matches the item with the path `rustc::middle::typeck::check::check_struct` when compiling the `rustc` crate.\r\n\r\n * Example 2: the suffix `and` matches `core::option::Option::and` and `core::result::Result::and` when compiling the `core` crate.\r\n\r\nRefactored `pprust` slightly to support the pretty printer changes.\r\n\r\n(See individual commits for more description.)", "tree": {"sha": "64c50551faef0e4df76fd4b0c0e5ceba788851e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64c50551faef0e4df76fd4b0c0e5ceba788851e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87134c7d72d0a39f696051a22c05aa2b328a6d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87134c7d72d0a39f696051a22c05aa2b328a6d00", "html_url": "https://github.com/rust-lang/rust/commit/87134c7d72d0a39f696051a22c05aa2b328a6d00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87134c7d72d0a39f696051a22c05aa2b328a6d00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a23d6795a50cf0b51d61d2b9d6d79127876796c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a23d6795a50cf0b51d61d2b9d6d79127876796c1", "html_url": "https://github.com/rust-lang/rust/commit/a23d6795a50cf0b51d61d2b9d6d79127876796c1"}, {"sha": "db0e71f10a157c211863ac844ceb0572967df298", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0e71f10a157c211863ac844ceb0572967df298", "html_url": "https://github.com/rust-lang/rust/commit/db0e71f10a157c211863ac844ceb0572967df298"}], "stats": {"total": 713, "additions": 613, "deletions": 100}, "files": [{"sha": "477fc5e1c0f30374080c2e2d3564e31d8c17ff98", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 297, "deletions": 52, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -11,9 +11,9 @@\n \n use back::link;\n use driver::session::Session;\n-use driver::{config, PpMode};\n+use driver::{config, PpMode, PpSourceMode};\n use driver::{PpmFlowGraph, PpmExpanded, PpmExpandedIdentified, PpmTyped};\n-use driver::{PpmIdentified};\n+use driver::{PpmIdentified, PpmNormal, PpmSource};\n use front;\n use lint;\n use llvm::{ContextRef, ModuleRef};\n@@ -39,11 +39,15 @@ use dot = graphviz;\n \n use serialize::{json, Encodable};\n \n+use std::from_str::FromStr;\n use std::io;\n use std::io::fs;\n use std::io::MemReader;\n+use std::option;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_map::blocks;\n+use syntax::ast_map::NodePrinter;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::diagnostics;\n@@ -602,7 +606,90 @@ fn write_out_deps(sess: &Session,\n     }\n }\n \n-struct IdentifiedAnnotation;\n+// This slightly awkward construction is to allow for each PpMode to\n+// choose whether it needs to do analyses (which can consume the\n+// Session) and then pass through the session (now attached to the\n+// analysis results) on to the chosen pretty-printer, along with the\n+// `&PpAnn` object.\n+//\n+// Note that since the `&PrinterSupport` is freshly constructed on each\n+// call, it would not make sense to try to attach the lifetime of `self`\n+// to the lifetime of the `&PrinterObject`.\n+//\n+// (The `use_once_payload` is working around the current lack of once\n+// functions in the compiler.)\n+trait CratePrinter {\n+    /// Constructs a `PrinterSupport` object and passes it to `f`.\n+    fn call_with_pp_support<A,B>(&self,\n+                                 sess: Session,\n+                                 krate: &ast::Crate,\n+                                 ast_map: Option<syntax::ast_map::Map>,\n+                                 id: String,\n+                                 use_once_payload: B,\n+                                 f: |&PrinterSupport, B| -> A) -> A;\n+}\n+\n+trait SessionCarrier {\n+    /// Provides a uniform interface for re-extracting a reference to a\n+    /// `Session` from a value that now owns it.\n+    fn sess<'a>(&'a self) -> &'a Session;\n+}\n+\n+trait AstMapCarrier {\n+    /// Provides a uniform interface for re-extracting a reference to an\n+    /// `ast_map::Map` from a value that now owns it.\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map>;\n+}\n+\n+trait PrinterSupport : SessionCarrier + AstMapCarrier {\n+    /// Produces the pretty-print annotation object.\n+    ///\n+    /// Usually implemented via `self as &pprust::PpAnn`.\n+    ///\n+    /// (Rust does not yet support upcasting from a trait object to\n+    /// an object for one of its super-traits.)\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n+}\n+\n+struct NoAnn {\n+    sess: Session,\n+    ast_map: Option<ast_map::Map>,\n+}\n+\n+impl PrinterSupport for NoAnn {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for NoAnn {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+}\n+\n+impl AstMapCarrier for NoAnn {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        self.ast_map.as_ref()\n+    }\n+}\n+\n+impl pprust::PpAnn for NoAnn {}\n+\n+struct IdentifiedAnnotation {\n+    sess: Session,\n+    ast_map: Option<ast_map::Map>,\n+}\n+\n+impl PrinterSupport for IdentifiedAnnotation {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for IdentifiedAnnotation {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+}\n+\n+impl AstMapCarrier for IdentifiedAnnotation {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        self.ast_map.as_ref()\n+    }\n+}\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n     fn pre(&self,\n@@ -642,6 +729,20 @@ struct TypedAnnotation {\n     analysis: CrateAnalysis,\n }\n \n+impl PrinterSupport for TypedAnnotation {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for TypedAnnotation {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n+}\n+\n+impl AstMapCarrier for TypedAnnotation {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        Some(&self.analysis.ty_cx.map)\n+    }\n+}\n+\n impl pprust::PpAnn for TypedAnnotation {\n     fn pre(&self,\n            s: &mut pprust::State,\n@@ -690,25 +791,155 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n     variants\n }\n \n+#[deriving(Clone, Show)]\n+pub enum UserIdentifiedItem {\n+    ItemViaNode(ast::NodeId),\n+    ItemViaPath(Vec<String>),\n+}\n+\n+impl FromStr for UserIdentifiedItem {\n+    fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n+        let extract_path_parts = || {\n+            let v : Vec<_> = s.split_str(\"::\")\n+                .map(|x|x.to_string())\n+                .collect();\n+            Some(ItemViaPath(v))\n+        };\n+\n+        from_str(s).map(ItemViaNode).or_else(extract_path_parts)\n+    }\n+}\n+\n+enum NodesMatchingUII<'a> {\n+    NodesMatchingDirect(option::Item<ast::NodeId>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, String>),\n+}\n+\n+impl<'a> Iterator<ast::NodeId> for NodesMatchingUII<'a> {\n+    fn next(&mut self) -> Option<ast::NodeId> {\n+        match self {\n+            &NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &NodesMatchingSuffix(ref mut iter) => iter.next(),\n+        }\n+    }\n+}\n+\n+impl UserIdentifiedItem {\n+    fn reconstructed_input(&self) -> String {\n+        match *self {\n+            ItemViaNode(node_id) => node_id.to_string(),\n+            ItemViaPath(ref parts) => parts.connect(\"::\"),\n+        }\n+    }\n+\n+    fn all_matching_node_ids<'a>(&'a self, map: &'a ast_map::Map) -> NodesMatchingUII<'a> {\n+        match *self {\n+            ItemViaNode(node_id) =>\n+                NodesMatchingDirect(Some(node_id).move_iter()),\n+            ItemViaPath(ref parts) =>\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n+        }\n+    }\n+\n+    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n+        let fail_because = |is_wrong_because| -> ast::NodeId {\n+            let message =\n+                format!(\"{:s} needs NodeId (int) or unique \\\n+                         path suffix (b::c::d); got {:s}, which {:s}\",\n+                        user_option,\n+                        self.reconstructed_input(),\n+                        is_wrong_because);\n+            sess.fatal(message.as_slice())\n+        };\n+\n+        let mut saw_node = ast::DUMMY_NODE_ID;\n+        let mut seen = 0u;\n+        for node in self.all_matching_node_ids(map) {\n+            saw_node = node;\n+            seen += 1;\n+            if seen > 1 {\n+                fail_because(\"does not resolve uniquely\");\n+            }\n+        }\n+        if seen == 0 {\n+            fail_because(\"does not resolve to any item\");\n+        }\n+\n+        assert!(seen == 1);\n+        return saw_node;\n+    }\n+}\n+\n+impl CratePrinter for PpSourceMode {\n+    fn call_with_pp_support<A,B>(&self,\n+                                 sess: Session,\n+                                 krate: &ast::Crate,\n+                                 ast_map: Option<syntax::ast_map::Map>,\n+                                 id: String,\n+                                 payload: B,\n+                                 f: |&PrinterSupport, B| -> A) -> A {\n+        match *self {\n+            PpmNormal | PpmExpanded => {\n+                let annotation = NoAnn { sess: sess, ast_map: ast_map };\n+                f(&annotation, payload)\n+            }\n+\n+            PpmIdentified | PpmExpandedIdentified => {\n+                let annotation = IdentifiedAnnotation { sess: sess, ast_map: ast_map };\n+                f(&annotation, payload)\n+            }\n+            PpmTyped => {\n+                let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n+                let analysis = phase_3_run_analysis_passes(sess, krate, ast_map, id);\n+                let annotation = TypedAnnotation { analysis: analysis };\n+                f(&annotation, payload)\n+            }\n+        }\n+    }\n+}\n+\n+fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+    match *ppm {\n+        PpmSource(PpmNormal) |\n+        PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+        PpmSource(PpmExpanded) |\n+        PpmSource(PpmExpandedIdentified) |\n+        PpmSource(PpmTyped) |\n+        PpmFlowGraph => true\n+    }\n+}\n+\n+fn needs_expansion(ppm: &PpMode) -> bool {\n+    match *ppm {\n+        PpmSource(PpmNormal) |\n+        PpmSource(PpmIdentified) => false,\n+\n+        PpmSource(PpmExpanded) |\n+        PpmSource(PpmExpandedIdentified) |\n+        PpmSource(PpmTyped) |\n+        PpmFlowGraph => true\n+    }\n+}\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode,\n+                          opt_uii: Option<UserIdentifiedItem>,\n                           ofile: Option<Path>) {\n     let krate = phase_1_parse_input(&sess, cfg, input);\n     let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n \n-    let (krate, ast_map, is_expanded) = match ppm {\n-        PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n-            let (krate, ast_map)\n-                = match phase_2_configure_and_expand(&sess, krate,\n-                                                     id.as_slice(), None) {\n-                    None => return,\n-                    Some(p) => p,\n-                };\n-            (krate, Some(ast_map), true)\n-        }\n-        _ => (krate, None, false)\n+    let is_expanded = needs_expansion(&ppm);\n+    let (krate, ast_map) = if needs_ast_map(&ppm, &opt_uii) {\n+        let k = phase_2_configure_and_expand(&sess, krate, id.as_slice(), None);\n+        let (krate, ast_map) = match k {\n+            None => return,\n+            Some(p) => p,\n+        };\n+        (krate, Some(ast_map))\n+    } else {\n+        (krate, None)\n     };\n \n     let src_name = source_name(input);\n@@ -729,38 +960,63 @@ pub fn pretty_print_input(sess: Session,\n             }\n         }\n     };\n-    match ppm {\n-        PpmIdentified | PpmExpandedIdentified => {\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                &krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                &IdentifiedAnnotation,\n-                                is_expanded)\n-        }\n-        PpmTyped => {\n-            let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);\n-            let annotation = TypedAnnotation {\n-                analysis: analysis\n-            };\n-            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),\n-                                annotation.analysis.ty_cx.sess.diagnostic(),\n-                                &krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                &annotation,\n-                                is_expanded)\n-        }\n-        PpmFlowGraph(nodeid) => {\n+\n+    match (ppm, opt_uii) {\n+        (PpmSource(s), None) =>\n+            s.call_with_pp_support(\n+                sess, &krate, ast_map, id, out, |annotation, out| {\n+                    debug!(\"pretty printing source code {}\", s);\n+                    let sess = annotation.sess();\n+                    pprust::print_crate(sess.codemap(),\n+                                        sess.diagnostic(),\n+                                        &krate,\n+                                        src_name.to_string(),\n+                                        &mut rdr,\n+                                        out,\n+                                        annotation.pp_ann(),\n+                                        is_expanded)\n+                }),\n+\n+        (PpmSource(s), Some(uii)) =>\n+            s.call_with_pp_support(\n+                sess, &krate, ast_map, id, (out,uii), |annotation, (out,uii)| {\n+                    debug!(\"pretty printing source code {}\", s);\n+                    let sess = annotation.sess();\n+                    let ast_map = annotation.ast_map()\n+                        .expect(\"--pretty missing ast_map\");\n+                    let mut pp_state =\n+                        pprust::State::new_from_input(sess.codemap(),\n+                                                      sess.diagnostic(),\n+                                                      src_name.to_string(),\n+                                                      &mut rdr,\n+                                                      out,\n+                                                      annotation.pp_ann(),\n+                                                      is_expanded);\n+                    for node_id in uii.all_matching_node_ids(ast_map) {\n+                        let node = ast_map.get(node_id);\n+                        try!(pp_state.print_node(&node));\n+                        try!(pp::space(&mut pp_state.s));\n+                        try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n+                        try!(pp::hardbreak(&mut pp_state.s));\n+                    }\n+                    pp::eof(&mut pp_state.s)\n+                }),\n+\n+        (PpmFlowGraph, opt_uii) => {\n+            debug!(\"pretty printing flow graph for {}\", opt_uii);\n+            let uii = opt_uii.unwrap_or_else(|| {\n+                sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n+                                     unique path suffix (b::c::d)\").as_slice())\n+\n+            });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n+            let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n+\n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n                                    nodeid).as_slice())\n             });\n+\n             let code = blocks::Code::from_node(node);\n             match code {\n                 Some(code) => {\n@@ -783,18 +1039,7 @@ pub fn pretty_print_input(sess: Session,\n                 }\n             }\n         }\n-        _ => {\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                &krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                &pprust::NoAnn,\n-                                is_expanded)\n-        }\n     }.unwrap()\n-\n }\n \n fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,"}, {"sha": "05762aa3db2762c709cc8570e48342374ec36218", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -99,11 +99,11 @@ fn run_compiler(args: &[String]) {\n         parse_pretty(&sess, a.as_slice())\n     });\n     match pretty {\n-        Some::<PpMode>(ppm) => {\n-            driver::pretty_print_input(sess, cfg, &input, ppm, ofile);\n+        Some((ppm, opt_uii)) => {\n+            driver::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n             return;\n         }\n-        None::<PpMode> => {/* continue */ }\n+        None => {/* continue */ }\n     }\n \n     let r = matches.opt_strs(\"Z\");\n@@ -340,42 +340,41 @@ fn print_crate_info(sess: &Session,\n     }\n }\n \n-pub enum PpMode {\n+#[deriving(PartialEq, Show)]\n+pub enum PpSourceMode {\n     PpmNormal,\n     PpmExpanded,\n     PpmTyped,\n     PpmIdentified,\n     PpmExpandedIdentified,\n-    PpmFlowGraph(ast::NodeId),\n }\n \n-pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n+#[deriving(PartialEq, Show)]\n+pub enum PpMode {\n+    PpmSource(PpSourceMode),\n+    PpmFlowGraph,\n+}\n+\n+fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<driver::UserIdentifiedItem>) {\n     let mut split = name.splitn('=', 1);\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n-    match (opt_second, first) {\n-        (None, \"normal\")       => PpmNormal,\n-        (None, \"expanded\")     => PpmExpanded,\n-        (None, \"typed\")        => PpmTyped,\n-        (None, \"expanded,identified\") => PpmExpandedIdentified,\n-        (None, \"identified\")   => PpmIdentified,\n-        (arg, \"flowgraph\") => {\n-             match arg.and_then(from_str) {\n-                 Some(id) => PpmFlowGraph(id),\n-                 None => {\n-                     sess.fatal(format!(\"`pretty flowgraph=<nodeid>` needs \\\n-                                         an integer <nodeid>; got {}\",\n-                                        arg.unwrap_or(\"nothing\")).as_slice())\n-                 }\n-             }\n-        }\n+    let first = match first {\n+        \"normal\"       => PpmSource(PpmNormal),\n+        \"expanded\"     => PpmSource(PpmExpanded),\n+        \"typed\"        => PpmSource(PpmTyped),\n+        \"expanded,identified\" => PpmSource(PpmExpandedIdentified),\n+        \"identified\"   => PpmSource(PpmIdentified),\n+        \"flowgraph\"    => PpmFlowGraph,\n         _ => {\n             sess.fatal(format!(\n                 \"argument to `pretty` must be one of `normal`, \\\n                  `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n                  or `expanded,identified`; got {}\", name).as_slice());\n         }\n-    }\n+    };\n+    let opt_second = opt_second.and_then::<driver::UserIdentifiedItem>(from_str);\n+    (first, opt_second)\n }\n \n fn parse_crate_attrs(sess: &Session, input: &Input) ->"}, {"sha": "881ee4fd8d13e664d5ebbfcaa317fb4fcd4f56c9", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -11,7 +11,7 @@\n use abi;\n use ast::*;\n use ast_util;\n-use codemap::Span;\n+use codemap::{Span, Spanned};\n use fold::Folder;\n use fold;\n use parse::token;\n@@ -21,6 +21,7 @@ use util::small_vector::SmallVector;\n use std::cell::RefCell;\n use std::fmt;\n use std::gc::{Gc, GC};\n+use std::io::IoResult;\n use std::iter;\n use std::slice;\n \n@@ -203,6 +204,10 @@ pub struct Map {\n }\n \n impl Map {\n+    fn entry_count(&self) -> uint {\n+        self.map.borrow().len()\n+    }\n+\n     fn find_entry(&self, id: NodeId) -> Option<MapEntry> {\n         let map = self.map.borrow();\n         if map.len() > id as uint {\n@@ -405,6 +410,20 @@ impl Map {\n         f(attrs)\n     }\n \n+    /// Returns an iterator that yields the node id's with paths that\n+    /// match `parts`.  (Requires `parts` is non-empty.)\n+    ///\n+    /// For example, if given `parts` equal to `[\"bar\", \"quux\"]`, then\n+    /// the iterator will produce node id's for items with paths\n+    /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n+    /// any other such items it can find in the map.\n+    pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S]) -> NodesMatchingSuffix<'a,S> {\n+        NodesMatchingSuffix { map: self,\n+                              item_name: parts.last().unwrap(),\n+                              where: parts.slice_to(parts.len() - 1),\n+                              idx: 0 }\n+    }\n+\n     pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n@@ -438,6 +457,119 @@ impl Map {\n     }\n }\n \n+pub struct NodesMatchingSuffix<'a, S> {\n+    map: &'a Map,\n+    item_name: &'a S,\n+    where: &'a [S],\n+    idx: NodeId,\n+}\n+\n+impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n+    /// Returns true only if some suffix of the module path for parent\n+    /// matches `self.where`.\n+    ///\n+    /// In other words: let `[x_0,x_1,...,x_k]` be `self.where`;\n+    /// returns true if parent's path ends with the suffix\n+    /// `x_0::x_1::...::x_k`.\n+    fn suffix_matches(&self, parent: NodeId) -> bool {\n+        let mut cursor = parent;\n+        for part in self.where.iter().rev() {\n+            let (mod_id, mod_name) = match find_first_mod_parent(self.map, cursor) {\n+                None => return false,\n+                Some((node_id, name)) => (node_id, name),\n+            };\n+            if part.as_slice() != mod_name.as_str() {\n+                return false;\n+            }\n+            cursor = self.map.get_parent(mod_id);\n+        }\n+        return true;\n+\n+        // Finds the first mod in parent chain for `id`, along with\n+        // that mod's name.\n+        //\n+        // If `id` itself is a mod named `m` with parent `p`, then\n+        // returns `Some(id, m, p)`.  If `id` has no mod in its parent\n+        // chain, then returns `None`.\n+        fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n+            loop {\n+                match map.find(id) {\n+                    None => return None,\n+                    Some(NodeItem(item)) if item_is_mod(&*item) =>\n+                        return Some((id, item.ident.name)),\n+                    _ => {}\n+                }\n+                let parent = map.get_parent(id);\n+                if parent == id { return None }\n+                id = parent;\n+            }\n+\n+            fn item_is_mod(item: &Item) -> bool {\n+                match item.node {\n+                    ItemMod(_) => true,\n+                    _ => false,\n+                }\n+            }\n+        }\n+    }\n+\n+    // We are looking at some node `n` with a given name and parent\n+    // id; do their names match what I am seeking?\n+    fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n+        name.as_str() == self.item_name.as_slice() &&\n+            self.suffix_matches(parent_of_n)\n+    }\n+}\n+\n+impl<'a,S:Str> Iterator<NodeId> for NodesMatchingSuffix<'a,S> {\n+    fn next(&mut self) -> Option<NodeId> {\n+        loop {\n+            let idx = self.idx;\n+            if idx as uint >= self.map.entry_count() {\n+                return None;\n+            }\n+            self.idx += 1;\n+            let (p, name) = match self.map.find_entry(idx) {\n+                Some(EntryItem(p, n))        => (p, n.name()),\n+                Some(EntryForeignItem(p, n)) => (p, n.name()),\n+                Some(EntryTraitMethod(p, n)) => (p, n.name()),\n+                Some(EntryMethod(p, n))      => (p, n.name()),\n+                Some(EntryVariant(p, n))     => (p, n.name()),\n+                _ => continue,\n+            };\n+            if self.matches_names(p, name) {\n+                return Some(idx)\n+            }\n+        }\n+    }\n+}\n+\n+trait Named {\n+    fn name(&self) -> Name;\n+}\n+\n+impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() } }\n+\n+impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n+impl Named for TraitMethod {\n+    fn name(&self) -> Name {\n+        match *self {\n+            Required(ref tm) => tm.ident.name,\n+            Provided(m) => m.name(),\n+        }\n+    }\n+}\n+impl Named for Method {\n+    fn name(&self) -> Name {\n+        match self.node {\n+            MethDecl(i, _, _, _, _, _, _, _) => i.name,\n+            MethMac(_) => fail!(\"encountered unexpanded method macro.\"),\n+        }\n+    }\n+}\n+\n pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n         id\n@@ -688,6 +820,34 @@ pub fn map_decoded_item<F: FoldOps>(map: &Map,\n     ii\n }\n \n+pub trait NodePrinter {\n+    fn print_node(&mut self, node: &Node) -> IoResult<()>;\n+}\n+\n+impl<'a> NodePrinter for pprust::State<'a> {\n+    fn print_node(&mut self, node: &Node) -> IoResult<()> {\n+        match *node {\n+            NodeItem(a)        => self.print_item(&*a),\n+            NodeForeignItem(a) => self.print_foreign_item(&*a),\n+            NodeTraitMethod(a) => self.print_trait_method(&*a),\n+            NodeMethod(a)      => self.print_method(&*a),\n+            NodeVariant(a)     => self.print_variant(&*a),\n+            NodeExpr(a)        => self.print_expr(&*a),\n+            NodeStmt(a)        => self.print_stmt(&*a),\n+            NodePat(a)         => self.print_pat(&*a),\n+            NodeBlock(a)       => self.print_block(&*a),\n+            NodeLifetime(a)    => self.print_lifetime(&*a),\n+\n+            // these cases do not carry enough information in the\n+            // ast_map to reconstruct their full structure for pretty\n+            // printing.\n+            NodeLocal(_)       => fail!(\"cannot print isolated Local\"),\n+            NodeArg(_)         => fail!(\"cannot print isolated Arg\"),\n+            NodeStructCtor(_)  => fail!(\"cannot print isolated StructCtor\"),\n+        }\n+    }\n+}\n+\n fn node_id_to_string(map: &Map, id: NodeId) -> String {\n     match map.find(id) {\n         Some(NodeItem(item)) => {"}, {"sha": "9d4b7343c8a156fa63e039549773934a59199a8e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -97,35 +97,62 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        out: Box<io::Writer>,\n                        ann: &'a PpAnn,\n                        is_expanded: bool) -> IoResult<()> {\n-    let (cmnts, lits) = comments::gather_comments_and_literals(\n-        span_diagnostic,\n-        filename,\n-        input\n-    );\n-    let mut s = State {\n-        s: pp::mk_printer(out, default_columns),\n-        cm: Some(cm),\n-        comments: Some(cmnts),\n-        // If the code is post expansion, don't use the table of\n-        // literals, since it doesn't correspond with the literals\n-        // in the AST anymore.\n-        literals: if is_expanded {\n-            None\n-        } else {\n-            Some(lits)\n-        },\n-        cur_cmnt_and_lit: CurrentCommentAndLiteral {\n-            cur_cmnt: 0,\n-            cur_lit: 0\n-        },\n-        boxes: Vec::new(),\n-        ann: ann\n-    };\n+    let mut s = State::new_from_input(cm,\n+                                      span_diagnostic,\n+                                      filename,\n+                                      input,\n+                                      out,\n+                                      ann,\n+                                      is_expanded);\n     try!(s.print_mod(&krate.module, krate.attrs.as_slice()));\n     try!(s.print_remaining_comments());\n     eof(&mut s.s)\n }\n \n+impl<'a> State<'a> {\n+    pub fn new_from_input(cm: &'a CodeMap,\n+                          span_diagnostic: &diagnostic::SpanHandler,\n+                          filename: String,\n+                          input: &mut io::Reader,\n+                          out: Box<io::Writer>,\n+                          ann: &'a PpAnn,\n+                          is_expanded: bool) -> State<'a> {\n+        let (cmnts, lits) = comments::gather_comments_and_literals(\n+            span_diagnostic,\n+            filename,\n+            input);\n+\n+        State::new(\n+            cm,\n+            out,\n+            ann,\n+            Some(cmnts),\n+            // If the code is post expansion, don't use the table of\n+            // literals, since it doesn't correspond with the literals\n+            // in the AST anymore.\n+            if is_expanded { None } else { Some(lits) })\n+    }\n+\n+    pub fn new(cm: &'a CodeMap,\n+               out: Box<io::Writer>,\n+               ann: &'a PpAnn,\n+               comments: Option<Vec<comments::Comment>>,\n+               literals: Option<Vec<comments::Literal>>) -> State<'a> {\n+        State {\n+            s: pp::mk_printer(out, default_columns),\n+            cm: Some(cm),\n+            comments: comments,\n+            literals: literals,\n+            cur_cmnt_and_lit: CurrentCommentAndLiteral {\n+                cur_cmnt: 0,\n+                cur_lit: 0\n+            },\n+            boxes: Vec::new(),\n+            ann: ann\n+        }\n+    }\n+}\n+\n pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n     let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();"}, {"sha": "f58a6527ac6886ab70878d9d17c7da8836c5bf4f", "filename": "src/test/run-make/pretty-print-path-suffix/Makefile", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2FMakefile?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -0,0 +1,9 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) -o $(TMPDIR)/foo.out --pretty normal=foo input.rs\n+\t$(RUSTC) -o $(TMPDIR)/nest_foo.out --pretty normal=nest::foo input.rs\n+\t$(RUSTC) -o $(TMPDIR)/foo_method.out --pretty normal=foo_method input.rs\n+\tdiff -u $(TMPDIR)/foo.out foo.pp\n+\tdiff -u $(TMPDIR)/nest_foo.out nest_foo.pp\n+\tdiff -u $(TMPDIR)/foo_method.out foo_method.pp"}, {"sha": "f3130a8044a2013bd1017377a5220ff59b668179", "filename": "src/test/run-make/pretty-print-path-suffix/foo.pp", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo.pp", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo.pp?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub fn foo() -> i32 { 45 } /* foo */\n+\n+\n+pub fn foo() -> &'static str { \"i am a foo.\" } /* nest::foo */"}, {"sha": "acf3f90cb0e1f0dac2a798202f07f37ea1b41046", "filename": "src/test/run-make/pretty-print-path-suffix/foo_method.pp", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Ffoo_method.pp?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+\n+\n+\n+fn foo_method(&self) -> &'static str { return \"i am very similiar to foo.\"; }\n+/* nest::S::foo_method */"}, {"sha": "4942540126b11fee3e4fae0c72c3a38042cf5703", "filename": "src/test/run-make/pretty-print-path-suffix/input.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Finput.rs?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn\n+foo() -> i32\n+{ 45 }\n+\n+pub fn bar() -> &'static str { \"i am not a foo.\" }\n+\n+pub mod nest {\n+    pub fn foo() -> &'static str { \"i am a foo.\" }\n+\n+    struct S;\n+    impl S {\n+        fn foo_method(&self) -> &'static str {\n+            return \"i am very similiar to foo.\";\n+        }\n+    }\n+}"}, {"sha": "88eaa062b03204cdf444c7d2eb42896b5e5b8885", "filename": "src/test/run-make/pretty-print-path-suffix/nest_foo.pp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Fnest_foo.pp", "raw_url": "https://github.com/rust-lang/rust/raw/87134c7d72d0a39f696051a22c05aa2b328a6d00/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Fnest_foo.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-print-path-suffix%2Fnest_foo.pp?ref=87134c7d72d0a39f696051a22c05aa2b328a6d00", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+\n+\n+pub fn foo() -> &'static str { \"i am a foo.\" } /* nest::foo */"}]}