{"sha": "c1734cef33dc235c2564d75abcbc7b8fbb8d1a38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNzM0Y2VmMzNkYzIzNWMyNTY0ZDc1YWJjYmM3YjhmYmI4ZDFhMzg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-15T10:25:35Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-16T20:30:43Z"}, "message": "debuginfo: Implemented support for Self type parameter in trait methods with default implementation.", "tree": {"sha": "1afb26ef2f592ab123a8499937d4fd16fbce31d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1afb26ef2f592ab123a8499937d4fd16fbce31d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38", "html_url": "https://github.com/rust-lang/rust/commit/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a36e53730f616479596868ba67fd1932064a00ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/a36e53730f616479596868ba67fd1932064a00ea", "html_url": "https://github.com/rust-lang/rust/commit/a36e53730f616479596868ba67fd1932064a00ea"}], "stats": {"total": 311, "additions": 266, "deletions": 45}, "files": [{"sha": "e3b5f732af8462e156c51a9d7cd9e98947128894", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 125, "deletions": 45, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c1734cef33dc235c2564d75abcbc7b8fbb8d1a38", "patch": "@@ -70,7 +70,7 @@ use std::ptr;\n use std::vec;\n use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::special_idents;\n \n static DW_LANG_RUST: int = 0x9000;\n \n@@ -195,9 +195,8 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let scope = create_function_metadata(bcx.fcx);\n-    let self_ident = keywords::Self.to_ident();\n \n-    let var_metadata = do cx.sess.str_of(self_ident).to_c_str().with_ref |name| {\n+    let var_metadata = do cx.sess.str_of(special_idents::self_).to_c_str().with_ref |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateLocalVariable(\n                 DIB(cx),\n@@ -229,8 +228,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: @mut Block,\n-                                arg: &ast::arg,\n-                                needs_deref: bool) {\n+                                arg: &ast::arg) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n@@ -337,11 +335,11 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     }\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, fn_decl, generics, span) = match fnitem {\n+    let (ident, fn_decl, generics, span, is_trait_default_impl) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n                 ast::item_fn(ref fn_decl, _, _, ref generics, _) => {\n-                    (item.ident, fn_decl, Some(generics), item.span)\n+                    (item.ident, fn_decl, Some(generics), item.span, false)\n                 }\n                 _ => fcx.ccx.sess.span_bug(item.span,\n                                            \"create_function_metadata: item bound to non-function\")\n@@ -357,7 +355,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, Some(generics), span)\n+            (ident, fn_decl, Some(generics), span, false)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n@@ -367,7 +365,8 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n                         None,\n-                        expr.span)\n+                        expr.span,\n+                        false)\n                 }\n                 _ => fcx.ccx.sess.span_bug(expr.span,\n                         \"create_function_metadata: expected an expr_fn_block here\")\n@@ -384,7 +383,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, Some(generics), span)\n+            (ident, fn_decl, Some(generics), span, true)\n         }\n         _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n@@ -405,6 +404,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let mut function_name = cx.sess.str_of(ident).to_owned();\n     let template_parameters = get_template_parameters(fcx,\n                                                       generics,\n+                                                      is_trait_default_impl,\n                                                       file_metadata,\n                                                       span,\n                                                       &mut function_name);\n@@ -507,6 +507,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n \n     fn get_template_parameters(fcx: &FunctionContext,\n                                generics: Option<&ast::Generics>,\n+                               is_trait_default_impl: bool,\n                                file_metadata: DIFile,\n                                span: span,\n                                name_to_append_suffix_to: &mut ~str)\n@@ -521,58 +522,131 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n \n         match generics {\n             None => {\n-                if (fcx.param_substs.is_some()) {\n+                if (!is_trait_default_impl && fcx.param_substs.is_some()) {\n                     cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                        Mismatch between ast::Generics and FunctionContext::param_substs\");\n+                        Mismatch between ast::Generics (does not exist) and \\\n+                        FunctionContext::param_substs (does exist)\");\n                 }\n \n                 return ptr::null();\n             }\n \n             Some(generics) => {\n-                let actual_types = match fcx.param_substs {\n-                    Some(@param_substs { tys: ref actual_types, _}) => {\n-                        actual_types\n+                let (actual_types, actual_self_type) = match fcx.param_substs {\n+                    Some(@param_substs { tys: ref types, self_ty: ref self_type, _ }) => {\n+                        if is_trait_default_impl && self_type.is_none() {\n+                            cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n+                                Expected self type parameter substitution for default \\\n+                                implementation of trait method\");\n+                        }\n+\n+                        (types, self_type)\n                     }\n                     None => {\n                         cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                            Mismatch between ast::Generics and FunctionContext::param_substs\");\n+                            Mismatch between ast::Generics (does exist) and \\\n+                            FunctionContext::param_substs (does not exist)\");\n                     }\n                 };\n \n                 name_to_append_suffix_to.push_char('<');\n \n-                let template_params: ~[DIDescriptor] = do generics\n-                    .ty_params\n-                    .iter()\n-                    .enumerate()\n-                    .map |(index, &ast::TyParam{ ident: ident, _ })| {\n-\n-                        let actual_type = actual_types[index];\n-                        let actual_type_metadata = type_metadata(cx,\n-                                                                 actual_type,\n-                                                                 codemap::dummy_sp());\n-\n-                        // Add actual type name to <...> clause of function name\n-                        let actual_type_name = ty_to_str(cx.tcx, actual_type);\n-                        name_to_append_suffix_to.push_str(actual_type_name);\n-                        if index != generics.ty_params.len() - 1 {\n-                            name_to_append_suffix_to.push_str(\",\");\n+                let mut template_params: ~[DIDescriptor] =\n+                    vec::with_capacity(actual_types.len() + 1);\n+\n+                if is_trait_default_impl {\n+                    let actual_self_type_metadata = type_metadata(cx,\n+                                                                  actual_self_type.unwrap(),\n+                                                                  codemap::dummy_sp());\n+\n+                    // Add self type name to <...> clause of function name\n+                    let actual_self_type_name = ty_to_str(cx.tcx, actual_self_type.unwrap());\n+                    name_to_append_suffix_to.push_str(actual_self_type_name);\n+                    if actual_types.len() > 0 {\n+                        name_to_append_suffix_to.push_str(\",\");\n+                    }\n+\n+                    let ident = special_idents::type_self;\n+\n+                    let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                                DIB(cx),\n+                                file_metadata,\n+                                name,\n+                                actual_self_type_metadata,\n+                                ptr::null(),\n+                                0,\n+                                0)\n                         }\n+                    };\n+\n+                    template_params.push(param_metadata);\n+                }\n \n-                        do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n-                            unsafe {\n-                                llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                                    DIB(cx),\n-                                    file_metadata,\n-                                    name,\n-                                    actual_type_metadata,\n-                                    ptr::null(),\n-                                    0,\n-                                    0)\n-                            }\n+                for (index, &ast::TyParam{ ident: ident, _ }) in generics\n+                                                                 .ty_params\n+                                                                 .iter()\n+                                                                 .enumerate() {\n+                    let actual_type = actual_types[index];\n+                    let actual_type_metadata = type_metadata(cx,\n+                                                             actual_type,\n+                                                             codemap::dummy_sp());\n+\n+                    // Add actual type name to <...> clause of function name\n+                    let actual_type_name = ty_to_str(cx.tcx, actual_type);\n+                    name_to_append_suffix_to.push_str(actual_type_name);\n+                    if index != generics.ty_params.len() - 1 {\n+                        name_to_append_suffix_to.push_str(\",\");\n+                    }\n+\n+                    let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                                DIB(cx),\n+                                file_metadata,\n+                                name,\n+                                actual_type_metadata,\n+                                ptr::null(),\n+                                0,\n+                                0)\n                         }\n-                    }.collect();\n+                    };\n+\n+                    template_params.push(param_metadata);\n+                }\n+\n+                // let template_params: ~[DIDescriptor] = do generics\n+                //     .ty_params\n+                //     .iter()\n+                //     .enumerate()\n+                //     .map |(index, &ast::TyParam{ ident: ident, _ })| {\n+\n+                //         let actual_type = actual_types[index];\n+                //         let actual_type_metadata = type_metadata(cx,\n+                //                                                  actual_type,\n+                //                                                  codemap::dummy_sp());\n+\n+                //         // Add actual type name to <...> clause of function name\n+                //         let actual_type_name = ty_to_str(cx.tcx, actual_type);\n+                //         name_to_append_suffix_to.push_str(actual_type_name);\n+                //         if index != generics.ty_params.len() - 1 {\n+                //             name_to_append_suffix_to.push_str(\",\");\n+                //         }\n+\n+                //         do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                //             unsafe {\n+                //                 llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                //                     DIB(cx),\n+                //                     file_metadata,\n+                //                     name,\n+                //                     actual_type_metadata,\n+                //                     ptr::null(),\n+                //                     0,\n+                //                     0)\n+                //             }\n+                //         }\n+                //     }.collect();\n \n                 name_to_append_suffix_to.push_char('>');\n \n@@ -795,7 +869,13 @@ fn struct_metadata(cx: &mut CrateContext,\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n-    let field_names = do fields.map |field| { cx.sess.str_of(field.ident).to_owned() };\n+    let field_names = do fields.map |field| {\n+        if field.ident == special_idents::unnamed_field {\n+            ~\"\"\n+        } else {\n+            cx.sess.str_of(field.ident).to_owned()\n+        }\n+    };\n     let field_types_metadata = do fields.map |field| {\n         type_metadata(cx, field.mt.ty, span)\n     };"}, {"sha": "cc7cab395934064fee3e29af8078ca79e62dc9d8", "filename": "src/test/debug-info/self-in-default-method.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1734cef33dc235c2564d75abcbc7b8fbb8d1a38/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs?ref=c1734cef33dc235c2564d75abcbc7b8fbb8d1a38", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = 100}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 100}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 200}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 200}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 200}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = 300}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 300}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = 300}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+struct Struct {\n+    x: int\n+}\n+\n+trait Trait {\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+}\n+\n+impl Trait for Struct;\n+\n+fn main() {\n+    let stack = Struct { x: 100 };\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~Struct { x: 200 };\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @Struct { x: 300 };\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}]}