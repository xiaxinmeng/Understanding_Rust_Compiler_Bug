{"sha": "a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MDhiYTM3NGY3ZmRmNmZlYTNmMGJkZTljZTA5Zjk4ZjBkYjdkMmQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-10-25T17:45:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T17:45:56Z"}, "message": "Rollup merge of #65705 - shepmaster:vec-into-raw, r=SimonSapin\n\nAdd {String,Vec}::into_raw_parts\n\nAspects to address:\n\n- [x] Create a tracking issue\n  - #65816", "tree": {"sha": "53532045ef05b19d5dd34f08575ee645329ae6ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53532045ef05b19d5dd34f08575ee645329ae6ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdszTUCRBK7hj4Ov3rIwAAdHIIAJBNi3en4Kkq/iCZD+tJlb8y\n4VyofoBxzEFYJsGZHBQYBwsM1YdJKNzcLsPDsllbjhCA002/tud5RwVJKv+6mtrR\nsLFapN8xCRDzsMoGBMialWd9dmOx4XftuJq9SzCZnCY/Rw7+E/iJgEGezgPWoHcf\nCF+eydbBowd+lLI1Alg1Ie1KyVvZSDKYgovDLN9ipWlqzVx4iCw+uU6OaBgoV2WQ\n00EJi9Dc5uNOl0KhnesvT2NWdKMVuwLGW+9US4l63fZqNkbfcm+CmvrkXB/1AD1I\nCGmuK1arCHPjxdUupMs/r5frbGfClyY0Toj035yc3RzejsQ2VOnq7mJOza8rI2o=\n=UKLh\n-----END PGP SIGNATURE-----\n", "payload": "tree 53532045ef05b19d5dd34f08575ee645329ae6ab\nparent 23f890f10202a71168c6424da0cdf94135d3c40c\nparent 6600cf604091a99bba990d41b93885b40c02a97d\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1572025556 +0900\ncommitter GitHub <noreply@github.com> 1572025556 +0900\n\nRollup merge of #65705 - shepmaster:vec-into-raw, r=SimonSapin\n\nAdd {String,Vec}::into_raw_parts\n\nAspects to address:\n\n- [x] Create a tracking issue\n  - #65816\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "html_url": "https://github.com/rust-lang/rust/commit/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f890f10202a71168c6424da0cdf94135d3c40c", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f890f10202a71168c6424da0cdf94135d3c40c", "html_url": "https://github.com/rust-lang/rust/commit/23f890f10202a71168c6424da0cdf94135d3c40c"}, {"sha": "6600cf604091a99bba990d41b93885b40c02a97d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6600cf604091a99bba990d41b93885b40c02a97d", "html_url": "https://github.com/rust-lang/rust/commit/6600cf604091a99bba990d41b93885b40c02a97d"}], "stats": {"total": 103, "additions": 89, "deletions": 14}, "files": [{"sha": "d9927c642b2d8528cc012de950ace36fdbcdafa6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "patch": "@@ -196,20 +196,21 @@ use crate::vec::Vec;\n ///\n /// let story = String::from(\"Once upon a time...\");\n ///\n-/// let ptr = story.as_ptr();\n+// FIXME Update this when vec_into_raw_parts is stabilized\n+/// // Prevent automatically dropping the String's data\n+/// let mut story = mem::ManuallyDrop::new(story);\n+///\n+/// let ptr = story.as_mut_ptr();\n /// let len = story.len();\n /// let capacity = story.capacity();\n ///\n /// // story has nineteen bytes\n /// assert_eq!(19, len);\n ///\n-/// // Now that we have our parts, we throw the story away.\n-/// mem::forget(story);\n-///\n /// // We can re-build a String out of ptr, len, and capacity. This is all\n /// // unsafe because we are responsible for making sure the components are\n /// // valid:\n-/// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n+/// let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n ///\n /// assert_eq!(String::from(\"Once upon a time...\"), s);\n /// ```\n@@ -647,6 +648,37 @@ impl String {\n         decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n     }\n \n+    /// Decomposes a `String` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the string (in bytes), and the allocated capacity of the data\n+    /// (in bytes). These are the same arguments in the same order as\n+    /// the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `String`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `String` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: #method.from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let s = String::from(\"hello\");\n+    ///\n+    /// let (ptr, len, cap) = s.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe { String::from_raw_parts(ptr, len, cap) };\n+    /// assert_eq!(rebuilt, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut u8, usize, usize) {\n+        self.vec.into_raw_parts()\n+    }\n+\n     /// Creates a new `String` from a length, capacity, and pointer.\n     ///\n     /// # Safety\n@@ -677,13 +709,16 @@ impl String {\n     ///\n     /// unsafe {\n     ///     let s = String::from(\"hello\");\n-    ///     let ptr = s.as_ptr();\n+    ///\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    ///     // Prevent automatically dropping the String's data\n+    ///     let mut s = mem::ManuallyDrop::new(s);\n+    ///\n+    ///     let ptr = s.as_mut_ptr();\n     ///     let len = s.len();\n     ///     let capacity = s.capacity();\n     ///\n-    ///     mem::forget(s);\n-    ///\n-    ///     let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n+    ///     let s = String::from_raw_parts(ptr, len, capacity);\n     ///\n     ///     assert_eq!(String::from(\"hello\"), s);\n     /// }"}, {"sha": "641f9eafa8d23fa55a047204cac29b989d544880", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "patch": "@@ -358,6 +358,44 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Decomposes a `Vec<T>` into its raw components.\n+    ///\n+    /// Returns the raw pointer to the underlying data, the length of\n+    /// the vector (in elements), and the allocated capacity of the\n+    /// data (in elements). These are the same arguments in the same\n+    /// order as the arguments to [`from_raw_parts`].\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `Vec`. The only way to do\n+    /// this is to convert the raw pointer, length, and capacity back\n+    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n+    /// the destructor to perform the cleanup.\n+    ///\n+    /// [`from_raw_parts`]: #method.from_raw_parts\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_into_raw_parts)]\n+    /// let v: Vec<i32> = vec![-1, 0, 1];\n+    ///\n+    /// let (ptr, len, cap) = v.into_raw_parts();\n+    ///\n+    /// let rebuilt = unsafe {\n+    ///     // We can now make changes to the components, such as\n+    ///     // transmuting the raw pointer to a compatible type.\n+    ///     let ptr = ptr as *mut u32;\n+    ///\n+    ///     Vec::from_raw_parts(ptr, len, cap)\n+    /// };\n+    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n+    /// ```\n+    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n+    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n+        let mut me = mem::ManuallyDrop::new(self);\n+        (me.as_mut_ptr(), me.len(), me.capacity())\n+    }\n+\n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n     ///\n     /// # Safety\n@@ -389,18 +427,19 @@ impl<T> Vec<T> {\n     /// use std::ptr;\n     /// use std::mem;\n     ///\n-    /// let mut v = vec![1, 2, 3];\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n+    /// // Prevent running `v`'s destructor so we are in complete control\n+    /// // of the allocation.\n+    /// let mut v = mem::ManuallyDrop::new(v);\n     ///\n     /// // Pull out the various important pieces of information about `v`\n     /// let p = v.as_mut_ptr();\n     /// let len = v.len();\n     /// let cap = v.capacity();\n     ///\n     /// unsafe {\n-    ///     // Cast `v` into the void: no destructor run, so we are in\n-    ///     // complete control of the allocation to which `p` points.\n-    ///     mem::forget(v);\n-    ///\n     ///     // Overwrite memory with 4, 5, 6\n     ///     for i in 0..len as isize {\n     ///         ptr::write(p.offset(i), 4 + i);"}, {"sha": "4655d39fb8f1fd187bf1222e7a21163014eeb53f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a808ba374f7fdf6fea3f0bde9ce09f98f0db7d2d", "patch": "@@ -874,6 +874,7 @@ extern \"rust-intrinsic\" {\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n+    // FIXME Update this when vec_into_raw_parts is stabilized\n     ///     // Ensure the original vector is not dropped.\n     ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n     ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,"}]}