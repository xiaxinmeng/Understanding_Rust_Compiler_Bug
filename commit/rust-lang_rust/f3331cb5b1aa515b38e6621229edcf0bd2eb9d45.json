{"sha": "f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzMxY2I1YjFhYTUxNWIzOGU2NjIxMjI5ZWRjZjBiZDJlYjlkNDU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-24T23:35:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-24T23:35:55Z"}, "message": "Rollup merge of #71330 - ecstatic-morse:const-qualif-lazy, r=oli-obk\n\nOnly run dataflow for const qualification if type-based check would fail\n\nThis is the optimization discussed in https://github.com/rust-lang/rust/issues/49146#issuecomment-614012476. We wait for `Qualif::in_any_value_of_ty` to return `true` before running dataflow. For bodies that deal mostly with primitive types, this will avoid running dataflow at all during const qualification.\n\nThis also removes the `BitSet` used to cache `in_any_value_of_ty` for each local, which was only necessary for an old version of #64470 that also handled promotability.", "tree": {"sha": "49539d51419622ee45a627a3210d1ee596be8d4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49539d51419622ee45a627a3210d1ee596be8d4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeo3fbCRBK7hj4Ov3rIwAAdHIIAAMeLQa+9vYjc4fIIN+CgLQG\n5sknWRhuDc2/dDCtSiW3ziifm0Ay6srlFQwGRxmcO9vH0+Nbz8kmxAl49bh9fghw\nyrKbkujK0jj1iSfMIr14FwfOTmJ4ZE8exaCkyJlpNChluqxd7BqZOOHVw3ANoAX8\nXZoKA1U0YXktnAoGkBDE3rM8hq76hucrVl/1VThT8A1Wo8kC1uagPZpgjck/D9rg\nSVHfr6P1RkNFdscGXYKzldi/WL75+WwG8wDx6KNYWsX6bg9OzMl9Rwv87CZ3NrWo\nwY+YLlxxvlaMd77sTAXVDf2r86nYDbK/0U2AZjzMo/7A6JVEYGgFdfqbH71+L/I=\n=b6dk\n-----END PGP SIGNATURE-----\n", "payload": "tree 49539d51419622ee45a627a3210d1ee596be8d4e\nparent 2e2080dee60d2bad4eaed97e0a74de54f53226ba\nparent 15f95b145e8ca9aaf2e8690f64db24b05153f851\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587771355 +0200\ncommitter GitHub <noreply@github.com> 1587771355 +0200\n\nRollup merge of #71330 - ecstatic-morse:const-qualif-lazy, r=oli-obk\n\nOnly run dataflow for const qualification if type-based check would fail\n\nThis is the optimization discussed in https://github.com/rust-lang/rust/issues/49146#issuecomment-614012476. We wait for `Qualif::in_any_value_of_ty` to return `true` before running dataflow. For bodies that deal mostly with primitive types, this will avoid running dataflow at all during const qualification.\n\nThis also removes the `BitSet` used to cache `in_any_value_of_ty` for each local, which was only necessary for an old version of #64470 that also handled promotability.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "html_url": "https://github.com/rust-lang/rust/commit/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e2080dee60d2bad4eaed97e0a74de54f53226ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2080dee60d2bad4eaed97e0a74de54f53226ba", "html_url": "https://github.com/rust-lang/rust/commit/2e2080dee60d2bad4eaed97e0a74de54f53226ba"}, {"sha": "15f95b145e8ca9aaf2e8690f64db24b05153f851", "url": "https://api.github.com/repos/rust-lang/rust/commits/15f95b145e8ca9aaf2e8690f64db24b05153f851", "html_url": "https://github.com/rust-lang/rust/commit/15f95b145e8ca9aaf2e8690f64db24b05153f851"}], "stats": {"total": 288, "additions": 189, "deletions": 99}, "files": [{"sha": "004d685c8f81aa4aa4fd0dfdfd35476f2658bb8a", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 83, "deletions": 72, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "patch": "@@ -3,7 +3,6 @@\n use rustc_errors::struct_span_err;\n use rustc_hir::lang_items;\n use rustc_hir::{def_id::DefId, HirId};\n-use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -28,70 +27,100 @@ use crate::dataflow::{self, Analysis};\n // We are using `MaybeMutBorrowedLocals` as a proxy for whether an item may have been mutated\n // through a pointer prior to the given point. This is okay even though `MaybeMutBorrowedLocals`\n // kills locals upon `StorageDead` because a local will never be used after a `StorageDead`.\n-pub type IndirectlyMutableResults<'mir, 'tcx> =\n+type IndirectlyMutableResults<'mir, 'tcx> =\n     dataflow::ResultsCursor<'mir, 'tcx, MaybeMutBorrowedLocals<'mir, 'tcx>>;\n \n-struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n-    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n-    in_any_value_of_ty: BitSet<Local>,\n-}\n-\n-impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n-        let cursor = FlowSensitiveAnalysis::new(q, ccx)\n-            .into_engine(ccx.tcx, ccx.body, ccx.def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(ccx.body);\n-\n-        let mut in_any_value_of_ty = BitSet::new_empty(ccx.body.local_decls.len());\n-        for (local, decl) in ccx.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(ccx, decl.ty) {\n-                in_any_value_of_ty.insert(local);\n-            }\n-        }\n+type QualifResults<'mir, 'tcx, Q> =\n+    dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'mir, 'mir, 'tcx, Q>>;\n \n-        QualifCursor { cursor, in_any_value_of_ty }\n-    }\n+#[derive(Default)]\n+pub struct Qualifs<'mir, 'tcx> {\n+    has_mut_interior: Option<QualifResults<'mir, 'tcx, HasMutInterior>>,\n+    needs_drop: Option<QualifResults<'mir, 'tcx, NeedsDrop>>,\n+    indirectly_mutable: Option<IndirectlyMutableResults<'mir, 'tcx>>,\n }\n \n-pub struct Qualifs<'a, 'mir, 'tcx> {\n-    has_mut_interior: QualifCursor<'a, 'mir, 'tcx, HasMutInterior>,\n-    needs_drop: QualifCursor<'a, 'mir, 'tcx, NeedsDrop>,\n-    indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n-}\n-\n-impl Qualifs<'a, 'mir, 'tcx> {\n-    fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n-        self.indirectly_mutable.seek_before(location);\n-        self.indirectly_mutable.get().contains(local)\n+impl Qualifs<'mir, 'tcx> {\n+    fn indirectly_mutable(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let indirectly_mutable = self.indirectly_mutable.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n+\n+            // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n+            // allowed in a const.\n+            //\n+            // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n+            // without breaking stable code?\n+            MaybeMutBorrowedLocals::mut_borrows_only(tcx, &body, param_env)\n+                .unsound_ignore_borrow_on_drop()\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        indirectly_mutable.seek_before(location);\n+        indirectly_mutable.get().contains(local)\n     }\n \n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(&mut self, local: Local, location: Location) -> bool {\n-        if !self.needs_drop.in_any_value_of_ty.contains(local) {\n+    fn needs_drop(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let ty = ccx.body.local_decls[local].ty;\n+        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n-        self.needs_drop.cursor.seek_before(location);\n-        self.needs_drop.cursor.get().contains(local) || self.indirectly_mutable(local, location)\n+        let needs_drop = self.needs_drop.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+\n+            FlowSensitiveAnalysis::new(NeedsDrop, ccx)\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        needs_drop.seek_before(location);\n+        needs_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior(&mut self, local: Local, location: Location) -> bool {\n-        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+    fn has_mut_interior(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let ty = ccx.body.local_decls[local].ty;\n+        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n-        self.has_mut_interior.cursor.seek_before(location);\n-        self.has_mut_interior.cursor.get().contains(local)\n-            || self.indirectly_mutable(local, location)\n+        let has_mut_interior = self.has_mut_interior.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+\n+            FlowSensitiveAnalysis::new(HasMutInterior, ccx)\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        has_mut_interior.seek_before(location);\n+        has_mut_interior.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n-    fn in_return_place(&mut self, ccx: &ConstCx<'_, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, ccx: &'mir ConstCx<'mir, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n@@ -114,49 +143,31 @@ impl Qualifs<'a, 'mir, 'tcx> {\n         let return_loc = ccx.body.terminator_loc(return_block);\n \n         ConstQualifs {\n-            needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n-            has_mut_interior: self.has_mut_interior(RETURN_PLACE, return_loc),\n+            needs_drop: self.needs_drop(ccx, RETURN_PLACE, return_loc),\n+            has_mut_interior: self.has_mut_interior(ccx, RETURN_PLACE, return_loc),\n         }\n     }\n }\n \n-pub struct Validator<'a, 'mir, 'tcx> {\n-    ccx: &'a ConstCx<'mir, 'tcx>,\n-    qualifs: Qualifs<'a, 'mir, 'tcx>,\n+pub struct Validator<'mir, 'tcx> {\n+    ccx: &'mir ConstCx<'mir, 'tcx>,\n+    qualifs: Qualifs<'mir, 'tcx>,\n \n     /// The span of the current statement.\n     span: Span,\n }\n \n-impl Deref for Validator<'_, 'mir, 'tcx> {\n+impl Deref for Validator<'mir, 'tcx> {\n     type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.ccx\n     }\n }\n \n-impl Validator<'a, 'mir, 'tcx> {\n-    pub fn new(ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n-        let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n-\n-        let needs_drop = QualifCursor::new(NeedsDrop, ccx);\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, ccx);\n-\n-        // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n-        // allowed in a const.\n-        //\n-        // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n-        // without breaking stable code?\n-        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-            .unsound_ignore_borrow_on_drop()\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(body);\n-\n-        let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n-\n-        Validator { span: ccx.body.span, ccx, qualifs }\n+impl Validator<'mir, 'tcx> {\n+    pub fn new(ccx: &'mir ConstCx<'mir, 'tcx>) -> Self {\n+        Validator { span: ccx.body.span, ccx, qualifs: Default::default() }\n     }\n \n     pub fn check_body(&mut self) {\n@@ -239,7 +250,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &BasicBlockData<'tcx>) {\n         trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n \n@@ -345,7 +356,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.ccx,\n-                    &mut |local| self.qualifs.has_mut_interior(local, location),\n+                    &mut |local| self.qualifs.has_mut_interior(self.ccx, local, location),\n                     place.as_ref(),\n                 );\n \n@@ -571,7 +582,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop(local, location)\n+                    self.qualifs.needs_drop(self.ccx, local, location)\n                 } else {\n                     true\n                 };"}, {"sha": "ee621a8cb147309deb514880bb1cf5e3eb806b14", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "patch": "@@ -1,11 +1,22 @@\n-error[E0391]: cycle detected when const checking `FOO`\n-  --> $DIR/issue-17252.rs:1:20\n+error[E0391]: cycle detected when normalizing `FOO`\n+   |\n+note: ...which requires const-evaluating + checking `FOO`...\n+  --> $DIR/issue-17252.rs:1:1\n+   |\n+LL | const FOO: usize = FOO;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `FOO`...\n+  --> $DIR/issue-17252.rs:1:1\n    |\n LL | const FOO: usize = FOO;\n-   |                    ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `FOO`...\n+  --> $DIR/issue-17252.rs:1:1\n    |\n-   = note: ...which again requires const checking `FOO`, completing the cycle\n-note: cycle used when const checking `main::{{constant}}#0`\n+LL | const FOO: usize = FOO;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires normalizing `FOO`, completing the cycle\n+note: cycle used when const-evaluating `main::{{constant}}#0`\n   --> $DIR/issue-17252.rs:4:18\n    |\n LL |     let _x: [u8; FOO]; // caused stack overflow prior to fix"}, {"sha": "b6c85b9e22749c9053cb5000a4d34efcc0744174", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "patch": "@@ -1,15 +1,26 @@\n-error[E0391]: cycle detected when const checking `X::A::{{constant}}#0`\n+error[E0391]: cycle detected when const-evaluating + checking `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires const checking `X::A::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `X::A::{{constant}}#0`\n+note: ...which requires const-evaluating + checking `X::A::{{constant}}#0`...\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `X::A::{{constant}}#0`...\n+  --> $DIR/issue-23302-1.rs:4:9\n+   |\n+LL |     A = X::A as isize,\n+   |         ^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `X::A as isize`...\n+   = note: ...which again requires const-evaluating + checking `X::A::{{constant}}#0`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-23302-1.rs:3:1\n+   |\n+LL | enum X {\n+   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d014922fe2069a5c5838c8e7f5578fdaab635d39", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "patch": "@@ -1,15 +1,26 @@\n-error[E0391]: cycle detected when const checking `Y::A::{{constant}}#0`\n+error[E0391]: cycle detected when const-evaluating + checking `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires const checking `Y::A::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `Y::A::{{constant}}#0`\n+note: ...which requires const-evaluating + checking `Y::A::{{constant}}#0`...\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `Y::A::{{constant}}#0`...\n+  --> $DIR/issue-23302-2.rs:4:9\n+   |\n+LL |     A = Y::B as isize,\n+   |         ^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `Y::B as isize`...\n+   = note: ...which again requires const-evaluating + checking `Y::A::{{constant}}#0`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-23302-2.rs:3:1\n+   |\n+LL | enum Y {\n+   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b30b1214271a06354e0900c238c621e744a244c0", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "patch": "@@ -1,20 +1,38 @@\n-error[E0391]: cycle detected when const checking `A`\n-  --> $DIR/issue-23302-3.rs:1:16\n+error[E0391]: cycle detected when const-evaluating + checking `A`\n+  --> $DIR/issue-23302-3.rs:1:1\n    |\n LL | const A: i32 = B;\n-   |                ^\n+   | ^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires const checking `B`...\n-  --> $DIR/issue-23302-3.rs:3:16\n+note: ...which requires const-evaluating + checking `A`...\n+  --> $DIR/issue-23302-3.rs:1:1\n    |\n-LL | const B: i32 = A;\n-   |                ^\n-   = note: ...which again requires const checking `A`, completing the cycle\n-note: cycle used when processing `A`\n+LL | const A: i32 = B;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `A`...\n   --> $DIR/issue-23302-3.rs:1:1\n    |\n LL | const A: i32 = B;\n    | ^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `B`...\n+note: ...which requires const-evaluating + checking `B`...\n+  --> $DIR/issue-23302-3.rs:3:1\n+   |\n+LL | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `B`...\n+  --> $DIR/issue-23302-3.rs:3:1\n+   |\n+LL | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `B`...\n+  --> $DIR/issue-23302-3.rs:3:1\n+   |\n+LL | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `A`...\n+   = note: ...which again requires const-evaluating + checking `A`, completing the cycle\n+   = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error\n "}, {"sha": "7c2da9dce6e9da41cc45a1809c0d2efa07257910", "filename": "src/test/ui/issues/issue-36163.stderr", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3331cb5b1aa515b38e6621229edcf0bd2eb9d45/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr?ref=f3331cb5b1aa515b38e6621229edcf0bd2eb9d45", "patch": "@@ -1,20 +1,48 @@\n-error[E0391]: cycle detected when const checking `Foo::B::{{constant}}#0`\n+error[E0391]: cycle detected when const-evaluating + checking `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n    |\n-note: ...which requires const checking `A`...\n-  --> $DIR/issue-36163.rs:1:18\n+note: ...which requires const-evaluating + checking `Foo::B::{{constant}}#0`...\n+  --> $DIR/issue-36163.rs:4:9\n    |\n-LL | const A: isize = Foo::B as isize;\n-   |                  ^^^^^^^^^^^^^^^\n-   = note: ...which again requires const checking `Foo::B::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `Foo::B::{{constant}}#0`\n+LL |     B = A,\n+   |         ^\n+note: ...which requires const-evaluating `Foo::B::{{constant}}#0`...\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n+   = note: ...which requires normalizing `A`...\n+note: ...which requires const-evaluating + checking `A`...\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | const A: isize = Foo::B as isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `A`...\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | const A: isize = Foo::B as isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `A`...\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | const A: isize = Foo::B as isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `A`...\n+   = note: ...which again requires const-evaluating + checking `Foo::B::{{constant}}#0`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | / const A: isize = Foo::B as isize;\n+LL | |\n+LL | | enum Foo {\n+LL | |     B = A,\n+LL | | }\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n \n error: aborting due to previous error\n "}]}