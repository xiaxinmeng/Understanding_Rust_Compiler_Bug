{"sha": "022bd13bee5c083578895ccc2b2675b9bd6e82ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmJkMTNiZWU1YzA4MzU3ODg5NWNjYzJiMjY3NWI5YmQ2ZTgyYWU=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T07:16:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-16T07:16:53Z"}, "message": "Merge branch 'master' into hack_branch_for_miri_do_not_delete_until_merged", "tree": {"sha": "66654b397821ed3bcd7a1a644bd5b64909e2afff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66654b397821ed3bcd7a1a644bd5b64909e2afff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022bd13bee5c083578895ccc2b2675b9bd6e82ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbTEZlCRBK7hj4Ov3rIwAAdHIIADZySdW1FnyNwUrh4wQUZeVH\nj7AgRH/3mr/+qdJlWd1SmGp98vmzorDhjN0IFe1Cl7kkuL6hiPKoZGMiiBogtCdE\nqzZiRmGZtSHg04c/xdXn/4apGgSlC/iK9vuhHunyyqyCsHyfvAlgE35Z4WKdKC6K\nQN1tWHkrb+mFcmazPE2tPyBXVVNmAB5uiYio7L17c4wVUycitKbvZ86rDmxj1pA5\nd6cZbx1wL3vPf2Y3dDuKp3AWAptcRxZkePVUI/ljwf7Fte9UshuLgSi3r6LfdD/b\n0mBzo5/TFaEgWnqQrHJy9jDoojm/+L5E4enBtHgqvjFWm4fyFKXfTGYOMci2bj0=\n=37Lp\n-----END PGP SIGNATURE-----\n", "payload": "tree 66654b397821ed3bcd7a1a644bd5b64909e2afff\nparent d4712ca37500f26bbcbf97edcb27820717f769f7\nparent fd6dad78f4b6d0babf0ae227221349388e80c405\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1531725413 +0200\ncommitter GitHub <noreply@github.com> 1531725413 +0200\n\nMerge branch 'master' into hack_branch_for_miri_do_not_delete_until_merged"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022bd13bee5c083578895ccc2b2675b9bd6e82ae", "html_url": "https://github.com/rust-lang/rust/commit/022bd13bee5c083578895ccc2b2675b9bd6e82ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022bd13bee5c083578895ccc2b2675b9bd6e82ae/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4712ca37500f26bbcbf97edcb27820717f769f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4712ca37500f26bbcbf97edcb27820717f769f7", "html_url": "https://github.com/rust-lang/rust/commit/d4712ca37500f26bbcbf97edcb27820717f769f7"}, {"sha": "fd6dad78f4b6d0babf0ae227221349388e80c405", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6dad78f4b6d0babf0ae227221349388e80c405", "html_url": "https://github.com/rust-lang/rust/commit/fd6dad78f4b6d0babf0ae227221349388e80c405"}], "stats": {"total": 3363, "additions": 1903, "deletions": 1460}, "files": [{"sha": "9aa632da05e0e976756cab9c1d054ad4a79c67f4", "filename": ".travis.yml", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,13 +1,23 @@\n language: rust\n+cache: cargo\n+\n+os:\n+- osx\n+- linux\n+\n rust:\n - nightly\n before_script:\n+# mac os weirdness (https://github.com/travis-ci/travis-ci/issues/6307)\n+- curl -sSL https://rvm.io/mpapis.asc | gpg --import -\n+- rvm get stable\n+# actual travis code\n - export PATH=$HOME/.local/bin:$PATH\n - rustup target add i686-unknown-linux-gnu\n - rustup target add i686-pc-windows-gnu\n - rustup target add i686-pc-windows-msvc\n - rustup component add rust-src\n-- cargo install --git https://github.com/japaric/xargo.git\n+- cargo install xargo || echo \"skipping xargo install\"\n - export RUST_SYSROOT=$HOME/rust\n script:\n - set -e\n@@ -17,13 +27,13 @@ script:\n - |\n   # Test plain miri\n   cargo build --release --all-features &&\n-  cargo test --release --all-features --all &&\n-  cargo install --all-features\n+  RUST_BACKTRACE=1 cargo test --release --all-features --all &&\n+  cargo install --all-features --force\n - |\n   # Test cargo miri\n   cd cargo-miri-test &&\n   cargo miri &&\n-  cargo miri test &&\n+  #cargo miri test &&\n   cd ..\n - |\n   # and run all tests with full mir"}, {"sha": "c46ba7c41429500fde27ea6772d9aeb1126c0deb", "filename": "Cargo.toml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -10,25 +10,25 @@ build = \"build.rs\"\n [[bin]]\n doc = false\n name = \"miri\"\n-path = \"miri/bin/miri.rs\"\n+path = \"src/bin/miri.rs\"\n \n [[bin]]\n doc = false\n name = \"cargo-miri\"\n-path = \"miri/bin/cargo-miri.rs\"\n+path = \"src/bin/cargo-miri.rs\"\n required-features = [\"cargo_miri\"]\n \n-[lib]\n-path = \"miri/lib.rs\"\n-\n [dependencies]\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n-cargo_metadata = { version = \"0.2\", optional = true }\n-regex = \"0.2.2\"\n+cargo_metadata = { version = \"0.6\", optional = true }\n+regex = \"1.0\"\n lazy_static = \"1.0\"\n+env_logger = \"0.5.0-rc.1\"\n+log = \"0.4\"\n \n [features]\n cargo_miri = [\"cargo_metadata\"]\n \n [dev-dependencies]\n-compiletest_rs = { version = \"0.3.7\", features = [\"tmp\"] }\n+compiletest_rs = { version = \"0.3.4\", features = [\"tmp\"] }\n+colored = \"1.6\""}, {"sha": "4891575c05e52d0229b2567e63582717be8ad564", "filename": "README.md", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -42,10 +42,22 @@ cargo run --bin miri tests/run-pass-fullmir/vecs.rs # Or whatever test you like.\n \n ## Debugging\n \n-You can get detailed, statement-by-statement traces by setting the `MIRI_LOG`\n-environment variable to `trace`. These traces are indented based on call stack\n-depth. You can get a much less verbose set of information with other logging\n-levels such as `warn`.\n+Since the heart of miri (the main interpreter engine) lives in rustc, tracing\n+the interpreter requires a version of rustc compiled with tracing.  To this\n+end, you will have to compile your own rustc:\n+```\n+git clone https://github.com/rust-lang/rust/ rustc\n+cd rustc\n+cp config.toml.example config.toml\n+# Now edit `config.toml` and set `debug-assertions = true`\n+./x.py build src/rustc\n+rustup toolchain link custom build/x86_64-unknown-linux-gnu/stage2\n+```\n+The `build` step can take 30 to 60 minutes.\n+\n+Now, in the miri directory, you can `rustup override set custom` and re-build\n+everything.  Finally, if you now set `RUST_LOG=rustc_mir::interpret=trace` as\n+environment variable, you will get detailed step-by-step tracing information.\n \n ## Running miri on your own project('s test suite)\n \n@@ -70,12 +82,15 @@ RUSTFLAGS='-Zalways-encode-mir' xargo build\n Now you can run miri against the libstd compiled by xargo:\n \n ```sh\n-MIRI_SYSROOT=~/.xargo/HOST cargo run --bin miri tests/run-pass-fullmir/vecs.rs\n+MIRI_SYSROOT=~/.xargo/HOST cargo run --bin miri tests/run-pass-fullmir/hashmap.rs\n ```\n \n Notice that you will have to re-run the last step of the preparations above when\n your toolchain changes (e.g., when you update the nightly).\n \n+You can also set `-Zmiri-start-fn` to make miri start evaluation with the\n+`start_fn` lang item, instead of starting at the `main` function.\n+\n ## Contributing and getting help\n \n Check out the issues on this GitHub repository for some ideas. There's lots that"}, {"sha": "46580f274bf62b01bc04cbcf5f45675ffa6143ea", "filename": "appveyor.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -22,7 +22,7 @@ install:\n     - rustc -V\n     - cargo -V\n     - rustup component add rust-src\n-    - cargo install --git https://github.com/japaric/xargo.git\n+    - cargo install xargo\n     - cd xargo\n     - set RUSTFLAGS=-Zalways-encode-mir -Zmir-emit-validate=1\n     - xargo build\n@@ -33,8 +33,8 @@ build: false\n \n test_script:\n     - set RUST_BACKTRACE=1\n-    - cargo build --locked --release\n-    - cargo test --locked --release\n+    - cargo build --release\n+    - cargo test --release\n \n notifications:\n     - provider: Email"}, {"sha": "0fbb46246aea8a8c99d665e1836bbae4ca3d8e09", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -5,8 +5,7 @@ extern crate rustc_driver;\n extern crate test;\n \n use self::miri::eval_main;\n-use self::rustc::session::Session;\n-use self::rustc_driver::{driver, CompilerCalls, Compilation};\n+use self::rustc_driver::{driver, Compilation};\n use std::cell::RefCell;\n use std::rc::Rc;\n use test::Bencher;\n@@ -36,40 +35,26 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         \"--sysroot\".to_string(),\n         find_sysroot(),\n     ];\n-    let compiler_calls = &mut MiriCompilerCalls(Rc::new(RefCell::new(bencher)));\n-    rustc_driver::run_compiler(args, compiler_calls, None, None);\n-}\n-\n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n-    fn build_controller(\n-        &mut self,\n-        _: &Session,\n-        _: &getopts::Matches,\n-    ) -> driver::CompileController<'a> {\n-        let mut control: driver::CompileController<'a> = driver::CompileController::basic();\n-\n-        let bencher = self.0.clone();\n+    let bencher = RefCell::new(bencher);\n \n-        control.after_analysis.stop = Compilation::Stop;\n-        control.after_analysis.callback = Box::new(move |state| {\n-            state.session.abort_if_errors();\n+    let mut control = driver::CompileController::basic();\n \n-            let tcx = state.tcx.unwrap();\n-            let (entry_node_id, _) = state.session.entry_fn.borrow().expect(\n-                \"no main or start function found\",\n-            );\n-            let entry_def_id = tcx.map.local_def_id(entry_node_id);\n+    control.after_analysis.stop = Compilation::Stop;\n+    control.after_analysis.callback = Box::new(move |state| {\n+        state.session.abort_if_errors();\n \n-            let memory_size = 100 * 1024 * 1024; // 100MB\n-            let step_limit = 1000_000;\n-            let stack_limit = 100;\n-            bencher.borrow_mut().iter(|| {\n-                eval_main(tcx, entry_def_id, memory_size, step_limit, stack_limit);\n-            });\n+        let tcx = state.tcx.unwrap();\n+        let (entry_node_id, _, _) = state.session.entry_fn.borrow().expect(\n+            \"no main or start function found\",\n+        );\n+        let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n \n-            state.session.abort_if_errors();\n+        bencher.borrow_mut().iter(|| {\n+            eval_main(tcx, entry_def_id, None);\n         });\n \n-        control\n-    }\n+        state.session.abort_if_errors();\n+    });\n+\n+    rustc_driver::run_compiler(args, Box::new(control), None, None);\n }"}, {"sha": "85c3c08dba019c44e772bc92cd594b984d341dd8", "filename": "cargo-miri-test/Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/cargo-miri-test%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/cargo-miri-test%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri-test%2FCargo.lock?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,14 +1,14 @@\n-[root]\n+[[package]]\n+name = \"byteorder\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n name = \"cargo-miri-test\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"byteorder\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [metadata]\n \"checksum byteorder 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c40977b0ee6b9885c9013cd41d9feffdd22deb3bb4dc3a71d901cc7a77de18c8\""}, {"sha": "0e541cf2920865f4a3fc73caa79fe6a395e06328", "filename": "miri/helpers.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,69 +0,0 @@\n-use super::{Pointer, EvalResult, PrimVal, EvalContext};\n-use rustc::ty::Ty;\n-use rustc::ty::layout::LayoutOf;\n-\n-pub trait EvalContextExt<'tcx> {\n-    fn wrapping_pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer>;\n-\n-    fn pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer>;\n-}\n-\n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n-    fn wrapping_pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer> {\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n-        let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.wrapping_signed_offset(offset, self)\n-    }\n-\n-    fn pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer> {\n-        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n-        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n-        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n-        // allocation.\n-\n-        if ptr.is_null()? {\n-            // NULL pointers must only be offset by 0\n-            return if offset == 0 {\n-                Ok(ptr)\n-            } else {\n-                err!(InvalidNullPointerUsage)\n-            };\n-        }\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset, self)?;\n-            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n-                self.memory.check_bounds(ptr, false)?;\n-            } else if ptr.is_null()? {\n-                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n-                return err!(InvalidNullPointerUsage);\n-            }\n-            Ok(ptr)\n-        } else {\n-            err!(OverflowingMath)\n-        };\n-    }\n-}"}, {"sha": "739ccfbf76712d8dd955639e89d7c3133c791363", "filename": "miri/lib.rs", "status": "removed", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,388 +0,0 @@\n-#![feature(\n-    i128_type,\n-    rustc_private,\n-    conservative_impl_trait,\n-    catch_expr,\n-)]\n-\n-// From rustc.\n-#[macro_use]\n-extern crate log;\n-#[macro_use]\n-extern crate rustc;\n-extern crate rustc_mir;\n-extern crate rustc_data_structures;\n-extern crate syntax;\n-extern crate regex;\n-#[macro_use]\n-extern crate lazy_static;\n-\n-use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::{TyLayout, LayoutOf};\n-use rustc::hir::def_id::DefId;\n-use rustc::mir;\n-use rustc::traits;\n-\n-use syntax::ast::Mutability;\n-use syntax::codemap::Span;\n-\n-use std::collections::{HashMap, BTreeMap};\n-\n-pub use rustc::mir::interpret::*;\n-pub use rustc_mir::interpret::*;\n-\n-mod fn_call;\n-mod operator;\n-mod intrinsic;\n-mod helpers;\n-mod memory;\n-mod tls;\n-mod locks;\n-mod range_map;\n-mod validation;\n-\n-use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n-use operator::EvalContextExt as OperatorEvalContextExt;\n-use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n-use tls::EvalContextExt as TlsEvalContextExt;\n-use locks::LockInfo;\n-use locks::MemoryExt as LockMemoryExt;\n-use validation::EvalContextExt as ValidationEvalContextExt;\n-use range_map::RangeMap;\n-use validation::{ValidationQuery, AbsPlace};\n-\n-pub fn eval_main<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    main_id: DefId,\n-    start_wrapper: Option<DefId>,\n-    limits: ResourceLimits,\n-) {\n-    fn run_main<'a, 'tcx: 'a>(\n-        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'tcx, Evaluator<'tcx>>,\n-        main_id: DefId,\n-        start_wrapper: Option<DefId>,\n-    ) -> EvalResult<'tcx> {\n-        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n-        let main_mir = ecx.load_mir(main_instance.def)?;\n-        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n-\n-        if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n-            return err!(Unimplemented(\n-                \"miri does not support main functions without `fn()` type signatures\"\n-                    .to_owned(),\n-            ));\n-        }\n-\n-        if let Some(start_id) = start_wrapper {\n-            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n-            let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-            if start_mir.arg_count != 3 {\n-                return err!(AbiViolation(format!(\n-                    \"'start' lang item should have three arguments, but has {}\",\n-                    start_mir.arg_count\n-                )));\n-            }\n-\n-            // Return value\n-            let size = ecx.tcx.data_layout.pointer_size.bytes();\n-            let align = ecx.tcx.data_layout.pointer_align.abi();\n-            let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n-            cleanup_ptr = Some(ret_ptr);\n-\n-            // Push our stack frame\n-            ecx.push_stack_frame(\n-                start_instance,\n-                start_mir.span,\n-                start_mir,\n-                Place::from_ptr(ret_ptr),\n-                StackPopCleanup::None,\n-            )?;\n-\n-            let mut args = ecx.frame().mir.args_iter();\n-\n-            // First argument: pointer to main()\n-            let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n-            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let main_ty = main_instance.def.def_ty(ecx.tcx);\n-            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n-            ecx.write_value(\n-                ValTy {\n-                    value: Value::ByVal(PrimVal::Ptr(main_ptr)),\n-                    ty: main_ptr_ty,\n-                },\n-                dest,\n-            )?;\n-\n-            // Second argument (argc): 1\n-            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.types.isize;\n-            ecx.write_primval(dest, PrimVal::Bytes(1), ty)?;\n-\n-            // FIXME: extract main source file path\n-            // Third argument (argv): &[b\"foo\"]\n-            let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n-            let foo = ecx.memory.allocate_cached(b\"foo\\0\");\n-            let ptr_size = ecx.memory.pointer_size();\n-            let foo_ptr = ecx.memory.allocate(ptr_size * 1, ptr_size, None)?;\n-            ecx.memory.write_primval(foo_ptr.into(), PrimVal::Ptr(foo.into()), ptr_size, false)?;\n-            ecx.memory.mark_static_initalized(foo_ptr.alloc_id, Mutability::Immutable)?;\n-            ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n-\n-            assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n-        } else {\n-            ecx.push_stack_frame(\n-                main_instance,\n-                main_mir.span,\n-                main_mir,\n-                Place::undef(),\n-                StackPopCleanup::None,\n-            )?;\n-\n-            // No arguments\n-            let mut args = ecx.frame().mir.args_iter();\n-            assert!(args.next().is_none(), \"main function must not have arguments\");\n-        }\n-\n-        while ecx.step()? {}\n-        ecx.run_tls_dtors()?;\n-        if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory_mut().deallocate(\n-                cleanup_ptr,\n-                None,\n-                MemoryKind::Stack,\n-            )?;\n-        }\n-        Ok(())\n-    }\n-\n-    let mut ecx = EvalContext::new(tcx, ty::ParamEnv::empty(traits::Reveal::All), limits, Default::default(), Default::default());\n-    match run_main(&mut ecx, main_id, start_wrapper) {\n-        Ok(()) => {\n-            let leaks = ecx.memory().leak_report();\n-            if leaks != 0 {\n-                tcx.sess.err(\"the evaluated program leaked memory\");\n-            }\n-        }\n-        Err(mut e) => {\n-            ecx.report(&mut e);\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct Evaluator<'tcx> {\n-    /// Environment variables set by `setenv`\n-    /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n-\n-    /// Places that were suspended by the validation subsystem, and will be recovered later\n-    pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n-}\n-\n-pub type TlsKey = usize;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct TlsEntry<'tcx> {\n-    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-#[derive(Default)]\n-pub struct MemoryData<'tcx> {\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// Memory regions that are locked by some function\n-    ///\n-    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n-    /// The entry is created when allocating the memory and deleted after deallocation.\n-    locks: HashMap<u64, RangeMap<LockInfo<'tcx>>>,\n-}\n-\n-impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n-    type MemoryData = MemoryData<'tcx>;\n-    type MemoryKinds = memory::MemoryKind;\n-\n-    /// Returns Ok() when the function was handled, fail otherwise\n-    fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n-        span: Span,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        ecx.eval_fn_call(instance, destination, args, span, sig)\n-    }\n-\n-    fn call_intrinsic<'a>(\n-        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Place,\n-        dest_layout: TyLayout<'tcx>,\n-        target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        ecx.call_intrinsic(instance, args, dest, dest_layout, target)\n-    }\n-\n-    fn try_ptr_op<'a>(\n-        ecx: &rustc_mir::interpret::EvalContext<'a, 'tcx, Self>,\n-        bin_op: mir::BinOp,\n-        left: PrimVal,\n-        left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n-        right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n-    }\n-\n-    fn mark_static_initialized(m: memory::MemoryKind) -> EvalResult<'tcx> {\n-        use memory::MemoryKind::*;\n-        match m {\n-            // FIXME: This could be allowed, but not for env vars set during miri execution\n-            Env => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n-            _ => Ok(()),\n-        }\n-    }\n-\n-    fn box_alloc<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        ty: ty::Ty<'tcx>,\n-        dest: Place,\n-    ) -> EvalResult<'tcx> {\n-        let layout = ecx.layout_of(ty)?;\n-\n-        // Call the `exchange_malloc` lang item\n-        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n-        let malloc = ty::Instance::mono(ecx.tcx, malloc);\n-        let malloc_mir = ecx.load_mir(malloc.def)?;\n-        ecx.push_stack_frame(\n-            malloc,\n-            malloc_mir.span,\n-            malloc_mir,\n-            dest,\n-            // Don't do anything when we are done.  The statement() function will increment\n-            // the old stack frame's stmt counter to the next statement, which means that when\n-            // exchange_malloc returns, we go on evaluating exactly where we want to be.\n-            StackPopCleanup::None,\n-        )?;\n-\n-        let mut args = ecx.frame().mir.args_iter();\n-        let usize = ecx.tcx.types.usize;\n-\n-        // First argument: size\n-        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        ecx.write_value(\n-            ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(layout.size.bytes().into())),\n-                ty: usize,\n-            },\n-            dest,\n-        )?;\n-\n-        // Second argument: align\n-        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        ecx.write_value(\n-            ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(layout.align.abi().into())),\n-                ty: usize,\n-            },\n-            dest,\n-        )?;\n-\n-        // No more arguments\n-        assert!(args.next().is_none(), \"exchange_malloc lang item has more arguments than expected\");\n-        Ok(())\n-    }\n-\n-    fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n-        trace!(\"Initializing an extern global with NULL\");\n-        let ptr_size = ecx.memory.pointer_size();\n-        let ptr = ecx.memory.allocate(\n-            ptr_size,\n-            ptr_size,\n-            None,\n-        )?;\n-        ecx.memory.write_ptr_sized_unsigned(ptr, PrimVal::Bytes(0))?;\n-        ecx.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n-        ecx.tcx.interpret_interner.borrow_mut().cache(\n-            GlobalId {\n-                instance,\n-                promoted: None,\n-            },\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: true,\n-            },\n-        );\n-        Ok(())\n-    }\n-\n-    fn check_locks<'a>(\n-        mem: &Memory<'a, 'tcx, Self>,\n-        ptr: MemoryPointer,\n-        size: u64,\n-        access: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        mem.check_locks(ptr, size, access)\n-    }\n-\n-    fn add_lock<'a>(\n-        mem: &mut Memory<'a, 'tcx, Self>,\n-        id: u64,\n-    ) {\n-        mem.data.locks.insert(id, RangeMap::new());\n-    }\n-\n-    fn free_lock<'a>(\n-        mem: &mut Memory<'a, 'tcx, Self>,\n-        id: u64,\n-        len: u64,\n-    ) -> EvalResult<'tcx> {\n-        mem.data.locks\n-            .remove(&id)\n-            .expect(\"allocation has no corresponding locks\")\n-            .check(\n-                Some(mem.cur_frame),\n-                0,\n-                len,\n-                AccessKind::Read,\n-            )\n-            .map_err(|lock| {\n-                EvalErrorKind::DeallocatedLockedMemory {\n-                    //ptr, FIXME\n-                    ptr: MemoryPointer {\n-                        alloc_id: AllocId(0),\n-                        offset: 0,\n-                    },\n-                    lock: lock.active,\n-                }.into()\n-            })\n-    }\n-\n-    fn end_region<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        reg: Option<::rustc::middle::region::Scope>,\n-    ) -> EvalResult<'tcx> {\n-        ecx.end_region(reg)\n-    }\n-\n-    fn validation_op<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        op: ::rustc::mir::ValidationOp,\n-        operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n-    ) -> EvalResult<'tcx> {\n-        ecx.validation_op(op, operand)\n-    }\n-}"}, {"sha": "bf867e0ae5b6c08df1118a2ece970677bc479f1b", "filename": "rust-toolchain", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1 @@\n+nightly"}, {"sha": "9cf4fe0d1342a4841c8419959d982dd7d0be57d7", "filename": "rustc_tests/Cargo.lock", "status": "modified", "additions": 127, "deletions": 76, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/rustc_tests%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/rustc_tests%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.lock?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,10 +1,3 @@\n-[root]\n-name = \"rustc_tests\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"miri 0.1.0\",\n-]\n-\n [[package]]\n name = \"aho-corasick\"\n version = \"0.6.3\"\n@@ -14,26 +7,13 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"backtrace\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"backtrace-sys\"\n-version = \"0.1.12\"\n+name = \"atty\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -47,40 +27,33 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n-name = \"dbghelp-sys\"\n-version = \"0.2.0\"\n+name = \"env_logger\"\n+version = \"0.5.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"termcolor 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n-name = \"env_logger\"\n-version = \"0.4.3\"\n+name = \"humantime\"\n+version = \"1.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n-name = \"gcc\"\n-version = \"0.3.53\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n+name = \"lazy_static\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"lazy_static\"\n-version = \"0.2.8\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -90,20 +63,23 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"log\"\n-version = \"0.3.8\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n-name = \"log_settings\"\n-version = \"0.1.1\"\n+name = \"memchr\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n-version = \"1.0.1\"\n+version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -114,10 +90,28 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_miri 0.1.0\",\n+ \"env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"quick-error\"\n+version = \"1.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.1.40\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"redox_termios\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -132,26 +126,54 @@ dependencies = [\n  \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"regex\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n-name = \"rustc-demangle\"\n-version = \"0.1.5\"\n+name = \"regex-syntax\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"ucd-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n-name = \"rustc_miri\"\n+name = \"rustc_tests\"\n version = \"0.1.0\"\n dependencies = [\n- \"backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miri 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"termcolor\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"wincolor 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"termion\"\n+version = \"1.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -163,6 +185,11 @@ dependencies = [\n  \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ucd-util\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"unreachable\"\n version = \"1.0.0\"\n@@ -183,35 +210,59 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"winapi\"\n-version = \"0.2.8\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"wincolor\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [metadata]\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n-\"checksum backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99f2ce94e22b8e664d95c57fff45b98a966c2252b60691d0b7aeeccd88d70983\"\n-\"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\"\n+\"checksum atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fc4a1aa4c24c0718a250f0681885c1af91419d242f29eb8f2ab28502d80dbd1\"\n \"checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n-\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n-\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n-\"checksum gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8310f7e9c890398b0e80e301c4f474e9918d2b27fca8f48486ca775fa9ffc5a\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+\"checksum env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e6e40ebb0e66918a37b38c7acab4e10d299e0463fe2af5d29b9cc86710cfd2a\"\n+\"checksum humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0484fda3e7007f2a4a0d9c3a703ca38c71c54c55602ce4660c419fd32e188c9e\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n+\"checksum lazy_static 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6412c5e2ad9584b0b8e979393122026cdd6d2a80b933f890dcd694ddbe73739\"\n \"checksum libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2370ca07ec338939e356443dac2296f581453c35fe1e3a3ed06023c49435f915\"\n-\"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n-\"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n+\"checksum log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"89f010e843f2b1a31dbd316b3b8d443758bc634bed37aabade59c686d644e0a2\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n+\"checksum memchr 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"796fba70e76612589ed2ce7f45282f5af869e0fdd7cc6199fa1aa1f1d591ba9d\"\n+\"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n+\"checksum redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c214e91d3ecf43e9a4e41e578973adeb14b474f2bee858742d127af75a0112b1\"\n+\"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n+\"checksum regex 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"75ecf88252dce580404a22444fc7d626c01815debba56a7f4f536772a5ff19d3\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n+\"checksum regex-syntax 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f1ac0f60d675cc6cf13a20ec076568254472551051ad5dd050364d70671bf6b\"\n+\"checksum termcolor 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"adc4587ead41bf016f11af03e55a624c06568b5a19db4e90fde573d805074f83\"\n+\"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n \"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n+\"checksum ucd-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fd2be2d6639d0f8fe6cdda291ad456e23629558d466e2789d2c3e9892bda285d\"\n \"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n-\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n+\"checksum winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"04e3bd221fcbe8a271359c04f21a76db7d0c6028862d1bb5512d85e1e2eb5bb3\"\n+\"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\"checksum wincolor 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eeb06499a3a4d44302791052df005d5232b927ed1a9658146d842165c4de7767\""}, {"sha": "64cd380970e4d0f7da2f063d4aa26457d295f6ab", "filename": "rustc_tests/src/main.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/rustc_tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/rustc_tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2Fsrc%2Fmain.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,9 +1,10 @@\n-#![feature(rustc_private, i128_type)]\n+#![feature(rustc_private)]\n extern crate miri;\n extern crate getopts;\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_errors;\n+extern crate rustc_codegen_utils;\n extern crate syntax;\n \n use std::path::{PathBuf, Path};\n@@ -18,11 +19,12 @@ use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n use rustc::hir::{self, itemlikevisit};\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n struct MiriCompilerCalls {\n-    default: RustcDefaultCalls,\n+    default: Box<RustcDefaultCalls>,\n     /// whether we are building for the host\n     host_target: bool,\n }\n@@ -51,20 +53,22 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n     }\n     fn late_callback(\n         &mut self,\n+        trans: &CodegenBackend,\n         matches: &getopts::Matches,\n         sess: &Session,\n         cstore: &CrateStore,\n         input: &Input,\n         odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>\n+        ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.default.late_callback(matches, sess, cstore, input, odir, ofile)\n+        self.default.late_callback(trans, matches, sess, cstore, input, odir, ofile)\n     }\n-    fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n-        let mut control = self.default.build_controller(sess, matches);\n+    fn build_controller(self: Box<Self>, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n+        let this = *self;\n+        let mut control = this.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n         control.after_analysis.callback = Box::new(after_analysis);\n-        if !self.host_target {\n+        if !this.host_target {\n             // only fully compile targets on the host\n             control.after_analysis.stop = Compilation::Stop;\n         }\n@@ -81,30 +85,27 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n     state.session.abort_if_errors();\n \n     let tcx = state.tcx.unwrap();\n-    let limits = Default::default();\n \n     if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(miri::ResourceLimits, TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n+        struct Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n         impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::Item_::ItemFn(_, _, _, _, _, body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| attr.name().map_or(false, |n| n == \"test\")) {\n-                        let did = self.1.hir.body_owner_def_id(body_id);\n-                        println!(\"running test: {}\", self.1.def_path_debug_str(did));\n-                        miri::eval_main(self.1, did, None, self.0);\n-                        self.2.session.abort_if_errors();\n+                if let hir::Item_::ItemFn(.., body_id) = i.node {\n+                    if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n+                        let did = self.0.hir.body_owner_def_id(body_id);\n+                        println!(\"running test: {}\", self.0.def_path_debug_str(did));\n+                        miri::eval_main(self.0, did, None);\n+                        self.1.session.abort_if_errors();\n                     }\n                 }\n             }\n             fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n             fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n         }\n-        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n-    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n+        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(tcx, state));\n+    } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items().start_fn().and_then(|start_fn|\n-                                if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n-        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n+        miri::eval_main(tcx, entry_def_id, None);\n \n         state.session.abort_if_errors();\n     } else {\n@@ -182,10 +183,10 @@ fn main() {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         let result = std::panic::catch_unwind(|| {\n-            rustc_driver::run_compiler(&args, &mut MiriCompilerCalls {\n-                default: RustcDefaultCalls,\n+            rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n+                default: Box::new(RustcDefaultCalls),\n                 host_target,\n-            }, None, Some(Box::new(buf)));\n+            }), None, Some(Box::new(buf)));\n         });\n \n         match result {"}, {"sha": "010f25e8152dc1c1a31020c42907b635e29eb03b", "filename": "src/bin/cargo-miri.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -121,7 +121,9 @@ fn main() {\n \n         let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n         let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-        let sys_root = if let (Some(home), Some(toolchain)) = (home, toolchain) {\n+        let sys_root = if let Ok(sysroot) = ::std::env::var(\"MIRI_SYSROOT\") {\n+            sysroot\n+        } else if let (Some(home), Some(toolchain)) = (home, toolchain) {\n             format!(\"{}/toolchains/{}\", home, toolchain)\n         } else {\n             option_env!(\"RUST_SYSROOT\")\n@@ -152,7 +154,7 @@ fn main() {\n \n         // this check ensures that dependencies are built but not interpreted and the final crate is\n         // interpreted but not built\n-        let miri_enabled = std::env::args().any(|s| s == \"-Zno-trans\");\n+        let miri_enabled = std::env::args().any(|s| s == \"--emit=dep-info,metadata\");\n \n         let mut command = if miri_enabled {\n             let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n@@ -191,7 +193,7 @@ where\n     if !found_dashes {\n         args.push(\"--\".to_owned());\n     }\n-    args.push(\"-Zno-trans\".to_owned());\n+    args.push(\"--emit=dep-info,metadata\".to_owned());\n     args.push(\"--cfg\".to_owned());\n     args.push(r#\"feature=\"cargo-miri\"\"#.to_owned());\n ", "previous_filename": "miri/bin/cargo-miri.rs"}, {"sha": "51c53b4af275d03663deb1c22dc06dc6cac9fe74", "filename": "src/bin/miri.rs", "status": "renamed", "additions": 59, "deletions": 88, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,10 +1,11 @@\n-#![feature(rustc_private, i128_type)]\n+#![feature(rustc_private)]\n \n extern crate getopts;\n extern crate miri;\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_errors;\n+extern crate rustc_codegen_utils;\n extern crate env_logger;\n extern crate log_settings;\n extern crate syntax;\n@@ -17,11 +18,16 @@ use rustc_driver::driver::{CompileState, CompileController};\n use rustc::session::config::{self, Input, ErrorOutputType};\n use rustc::hir::{self, itemlikevisit};\n use rustc::ty::TyCtxt;\n-use syntax::ast::{self, MetaItemKind, NestedMetaItemKind};\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use syntax::ast;\n use std::path::PathBuf;\n \n struct MiriCompilerCalls {\n-    default: RustcDefaultCalls,\n+    default: Box<RustcDefaultCalls>,\n+    /// Whether to begin interpretation at the start_fn lang item or not\n+    ///\n+    /// If false, the interpretation begins at the `main` function\n+    start_fn: bool,\n }\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n@@ -61,27 +67,27 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n     }\n     fn late_callback(\n         &mut self,\n+        codegen_backend: &CodegenBackend,\n         matches: &getopts::Matches,\n         sess: &Session,\n         cstore: &CrateStore,\n         input: &Input,\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.default.late_callback(matches, sess, cstore, input, odir, ofile)\n+        self.default.late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n     }\n     fn build_controller(\n-        &mut self,\n+        self: Box<Self>,\n         sess: &Session,\n         matches: &getopts::Matches,\n     ) -> CompileController<'a> {\n-        let mut control = self.default.build_controller(sess, matches);\n+        let this = *self;\n+        let mut control = this.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        control.after_analysis.callback = Box::new(after_analysis);\n-        if sess.target.target != sess.host {\n-            // only fully compile targets on the host. linking will fail for cross-compilation.\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n+        let start_fn = this.start_fn;\n+        control.after_analysis.callback = Box::new(move |state| after_analysis(state, start_fn));\n+        control.after_analysis.stop = Compilation::Stop;\n         control\n     }\n }\n@@ -94,135 +100,91 @@ fn after_hir_lowering(state: &mut CompileState) {\n     state.session.plugin_attributes.borrow_mut().push(attr);\n }\n \n-fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n+fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>, use_start_fn: bool) {\n     state.session.abort_if_errors();\n \n     let tcx = state.tcx.unwrap();\n-    let limits = resource_limits_from_attributes(state);\n \n     if std::env::args().any(|arg| arg == \"--test\") {\n         struct Visitor<'a, 'tcx: 'a>(\n-            miri::ResourceLimits,\n             TyCtxt<'a, 'tcx, 'tcx>,\n             &'a CompileState<'a, 'tcx>\n         );\n         impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::Item_::ItemFn(_, _, _, _, _, body_id) = i.node {\n+                if let hir::Item_::ItemFn(.., body_id) = i.node {\n                     if i.attrs.iter().any(|attr| {\n-                        attr.name().map_or(false, |n| n == \"test\")\n+                        attr.name() == \"test\"\n                     })\n                     {\n-                        let did = self.1.hir.body_owner_def_id(body_id);\n+                        let did = self.0.hir.body_owner_def_id(body_id);\n                         println!(\n                             \"running test: {}\",\n-                            self.1.def_path_debug_str(did),\n+                            self.0.def_path_debug_str(did),\n                         );\n-                        miri::eval_main(self.1, did, None, self.0);\n-                        self.2.session.abort_if_errors();\n+                        miri::eval_main(self.0, did, None);\n+                        self.1.session.abort_if_errors();\n                     }\n                 }\n             }\n             fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n             fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n         }\n         state.hir_crate.unwrap().visit_all_item_likes(\n-            &mut Visitor(limits, tcx, state),\n+            &mut Visitor(tcx, state),\n         );\n-    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n+    } else if let Some((entry_node_id, _, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items().start_fn().and_then(|start_fn| {\n-            if tcx.is_mir_available(start_fn) {\n-                Some(start_fn)\n-            } else {\n-                None\n-            }\n-        });\n-        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n+        // Use start_fn lang item if we have -Zmiri-start-fn set\n+        let start_wrapper = if use_start_fn {\n+            Some(tcx.lang_items().start_fn().unwrap())\n+        } else {\n+            None\n+        };\n+        miri::eval_main(tcx, entry_def_id, start_wrapper);\n \n         state.session.abort_if_errors();\n     } else {\n         println!(\"no main function found, assuming auxiliary build\");\n     }\n }\n \n-fn resource_limits_from_attributes(state: &CompileState) -> miri::ResourceLimits {\n-    let mut limits = miri::ResourceLimits::default();\n-    let krate = state.hir_crate.as_ref().unwrap();\n-    let err_msg = \"miri attributes need to be in the form `miri(key = value)`\";\n-    let extract_int = |lit: &syntax::ast::Lit| -> u128 {\n-        match lit.node {\n-            syntax::ast::LitKind::Int(i, _) => i,\n-            _ => {\n-                state.session.span_fatal(\n-                    lit.span,\n-                    \"expected an integer literal\",\n-                )\n-            }\n-        }\n-    };\n-\n-    for attr in krate.attrs.iter().filter(|a| {\n-        a.name().map_or(false, |n| n == \"miri\")\n-    })\n-    {\n-        if let Some(items) = attr.meta_item_list() {\n-            for item in items {\n-                if let NestedMetaItemKind::MetaItem(ref inner) = item.node {\n-                    if let MetaItemKind::NameValue(ref value) = inner.node {\n-                        match &inner.name().as_str()[..] {\n-                            \"memory_size\" => limits.memory_size = extract_int(value) as u64,\n-                            \"step_limit\" => limits.step_limit = extract_int(value) as u64,\n-                            \"stack_limit\" => limits.stack_limit = extract_int(value) as usize,\n-                            _ => state.session.span_err(item.span, \"unknown miri attribute\"),\n-                        }\n-                    } else {\n-                        state.session.span_err(inner.span, err_msg);\n-                    }\n-                } else {\n-                    state.session.span_err(item.span, err_msg);\n-                }\n-            }\n-        } else {\n-            state.session.span_err(attr.span, err_msg);\n-        }\n-    }\n-    limits\n-}\n-\n fn init_logger() {\n-    let format = |record: &log::LogRecord| {\n-        if record.level() == log::LogLevel::Trace {\n+    let format = |formatter: &mut env_logger::fmt::Formatter, record: &log::Record| {\n+        use std::io::Write;\n+        if record.level() == log::Level::Trace {\n             // prepend frame number\n             let indentation = log_settings::settings().indentation;\n-            format!(\n+            writeln!(\n+                formatter,\n                 \"{indentation}:{lvl}:{module}: {text}\",\n                 lvl = record.level(),\n-                module = record.location().module_path(),\n+                module = record.module_path().unwrap_or(\"<unknown module>\"),\n                 indentation = indentation,\n                 text = record.args(),\n             )\n         } else {\n-            format!(\n+            writeln!(\n+                formatter,\n                 \"{lvl}:{module}: {text}\",\n                 lvl = record.level(),\n-                module = record.location().module_path(),\n+                module = record.module_path().unwrap_or(\"<unknown_module>\"),\n                 text = record.args(),\n             )\n         }\n     };\n \n-    let mut builder = env_logger::LogBuilder::new();\n+    let mut builder = env_logger::Builder::new();\n     builder.format(format).filter(\n         None,\n-        log::LogLevelFilter::Info,\n+        log::LevelFilter::Info,\n     );\n \n     if std::env::var(\"MIRI_LOG\").is_ok() {\n         builder.parse(&std::env::var(\"MIRI_LOG\").unwrap());\n     }\n \n-    builder.init().unwrap();\n+    builder.init();\n }\n \n fn find_sysroot() -> String {\n@@ -246,6 +208,7 @@ fn find_sysroot() -> String {\n }\n \n fn main() {\n+    rustc_driver::init_rustc_env_logger();\n     init_logger();\n     let mut args: Vec<String> = std::env::args().collect();\n \n@@ -255,10 +218,18 @@ fn main() {\n         args.push(find_sysroot());\n     }\n \n-    // Make sure we always have all the MIR (e.g. for auxilary builds in unit tests).\n-    args.push(\"-Zalways-encode-mir\".to_owned());\n+    let mut start_fn = false;\n+    args.retain(|arg| {\n+        if arg == \"-Zmiri-start-fn\" {\n+            start_fn = true;\n+            false\n+        } else {\n+            true\n+        }\n+    });\n \n-    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls {\n-        default: RustcDefaultCalls,\n-    }, None, None);\n+    rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n+        default: Box::new(RustcDefaultCalls),\n+        start_fn,\n+    }), None, None);\n }", "previous_filename": "miri/bin/miri.rs"}, {"sha": "8105330b3263ed209dd8238a30078cec16e27df9", "filename": "src/fn_call.rs", "status": "renamed", "additions": 248, "deletions": 154, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,23 +1,65 @@\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{self, Align, LayoutOf, Size};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax::attr;\n-use syntax::abi::Abi;\n use syntax::codemap::Span;\n \n use std::mem;\n \n-use rustc::traits;\n-\n use super::*;\n \n use tls::MemoryExt;\n \n use super::memory::MemoryKind;\n \n+fn write_discriminant_value<'a, 'mir, 'tcx: 'a + 'mir>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>>,\n+        dest_ty: Ty<'tcx>,\n+        dest: Place,\n+        variant_index: usize,\n+    ) -> EvalResult<'tcx> {\n+        let layout = ecx.layout_of(dest_ty)?;\n+\n+        match layout.variants {\n+            layout::Variants::Single { index } => {\n+                if index != variant_index {\n+                    // If the layout of an enum is `Single`, all\n+                    // other variants are necessarily uninhabited.\n+                    assert_eq!(layout.for_variant(&ecx, variant_index).abi,\n+                               layout::Abi::Uninhabited);\n+                }\n+            }\n+            layout::Variants::Tagged { .. } => {\n+                let discr_val = dest_ty.ty_adt_def().unwrap()\n+                    .discriminant_for_variant(*ecx.tcx, variant_index)\n+                    .val;\n+\n+                let (discr_dest, discr) = ecx.place_field(dest, mir::Field::new(0), layout)?;\n+                ecx.write_scalar(discr_dest, Scalar::from_u128(discr_val), discr.ty)?;\n+            }\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n+            } => {\n+                if variant_index != dataful_variant {\n+                    let (niche_dest, niche) =\n+                        ecx.place_field(dest, mir::Field::new(0), layout)?;\n+                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n+                        .wrapping_add(niche_start);\n+                    ecx.write_scalar(niche_dest, Scalar::from_u128(niche_value), niche.ty)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n pub trait EvalContextExt<'tcx> {\n-    fn call_c_abi(\n+    fn call_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[ValTy<'tcx>],\n@@ -49,7 +91,7 @@ pub trait EvalContextExt<'tcx> {\n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -60,6 +102,47 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n     ) -> EvalResult<'tcx, bool> {\n         trace!(\"eval_fn_call: {:#?}, {:#?}\", instance, destination);\n \n+        let def_id = instance.def_id();\n+        let item_path = self.tcx.absolute_item_path_str(def_id);\n+        match &*item_path {\n+            \"std::sys::unix::thread::guard::init\" | \"std::sys::unix::thread::guard::current\" => {\n+                // Return None, as it doesn't make sense to return Some, because miri detects stack overflow itself.\n+                let ret_ty = sig.output();\n+                match ret_ty.sty {\n+                    ty::TyAdt(ref adt_def, _) => {\n+                        assert!(adt_def.is_enum(), \"Unexpected return type for {}\", item_path);\n+                        let none_variant_index = adt_def.variants.iter().position(|def| {\n+                            def.name.as_str() == \"None\"\n+                        }).expect(\"No None variant\");\n+                        let (return_place, return_to_block) = destination.unwrap();\n+                        write_discriminant_value(self, ret_ty, return_place, none_variant_index)?;\n+                        self.goto_block(return_to_block);\n+                        return Ok(true);\n+                    }\n+                    _ => panic!(\"Unexpected return type for {}\", item_path)\n+                }\n+            }\n+            \"std::sys::unix::fast_thread_local::register_dtor\" => {\n+                // TODO: register the dtor\n+                let (_return_place, return_to_block) = destination.unwrap();\n+                self.goto_block(return_to_block);\n+                return Ok(true);\n+            }\n+            _ => {}\n+        }\n+\n+        if self.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n+            // FIXME: return a real value in case the target allocation has an\n+            // alignment bigger than the one requested\n+            let n = u128::max_value();\n+            let amt = 128 - self.memory.pointer_size().bytes() * 8;\n+            let (dest, return_to_block) = destination.unwrap();\n+            let ty = self.tcx.types.usize;\n+            self.write_scalar(dest, Scalar::from_u128((n << amt) >> amt), ty)?;\n+            self.goto_block(return_to_block);\n+            return Ok(true);\n+        }\n+\n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n@@ -91,7 +174,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         Ok(false)\n     }\n \n-    fn call_c_abi(\n+    fn call_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[ValTy<'tcx>],\n@@ -102,18 +185,18 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n             Some(name) => name.as_str(),\n-            None => self.tcx.item_name(def_id),\n+            None => self.tcx.item_name(def_id).as_str(),\n         };\n \n         match &link_name[..] {\n             \"malloc\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n                 if size == 0 {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n-                    let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Some(MemoryKind::C.into()))?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                    let align = self.tcx.data_layout.pointer_align;\n+                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MemoryKind::C.into())?;\n+                    self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n@@ -128,13 +211,80 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 }\n             }\n \n+            \"__rust_alloc\" => {\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                if size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(Size::from_bytes(size),\n+                                               Align::from_bytes(align, align).unwrap(),\n+                                               MemoryKind::Rust.into())?;\n+                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n+            }\n+            \"__rust_alloc_zeroed\" => {\n+                let size = self.value_to_scalar(args[0])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                if size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(Size::from_bytes(size),\n+                                               Align::from_bytes(align, align).unwrap(),\n+                                               MemoryKind::Rust.into())?;\n+                self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n+                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n+            }\n+            \"__rust_dealloc\" => {\n+                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                if old_size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(\n+                    ptr,\n+                    Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n+                    MemoryKind::Rust.into(),\n+                )?;\n+            }\n+            \"__rust_realloc\" => {\n+                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_usize(self)?;\n+                let align = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                let new_size = self.value_to_scalar(args[3])?.to_usize(self)?;\n+                if old_size == 0 || new_size == 0 {\n+                    return err!(HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let new_ptr = self.memory.reallocate(\n+                    ptr,\n+                    Size::from_bytes(old_size),\n+                    Align::from_bytes(align, align).unwrap(),\n+                    Size::from_bytes(new_size),\n+                    Align::from_bytes(align, align).unwrap(),\n+                    MemoryKind::Rust.into(),\n+                )?;\n+                self.write_scalar(dest, Scalar::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n             \"syscall\" => {\n                 // TODO: read `syscall` ids like `sysconf` ids and\n                 // figure out some way to actually process some of them\n                 //\n                 // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n                 // is called if a `HashMap` is created the regular way.\n-                match self.value_to_primval(args[0])?.to_u64()? {\n+                match self.value_to_scalar(args[0])?.to_usize(self)? {\n                     318 | 511 => {\n                         return err!(Unimplemented(\n                             \"miri does not support random number generators\".to_owned(),\n@@ -181,7 +331,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 )?;\n                 let mut args = self.frame().mir.args_iter();\n \n-                let arg_local = args.next().ok_or(\n+                let arg_local = args.next().ok_or_else(||\n                     EvalErrorKind::AbiViolation(\n                         \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n                             .to_owned(),\n@@ -206,36 +356,36 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"memcmp\" => {\n                 let left = self.into_ptr(args[0].value)?;\n                 let right = self.into_ptr(args[1].value)?;\n-                let n = self.value_to_primval(args[2])?.to_u64()?;\n+                let n = Size::from_bytes(self.value_to_scalar(args[2])?.to_usize(self)?);\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n                     let right_bytes = self.memory.read_bytes(right, n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n-                        Less => -1i8,\n+                        Less => -1i32,\n                         Equal => 0,\n                         Greater => 1,\n                     }\n                 };\n \n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(result as u128),\n+                    Scalar::from_i32(result),\n                     dest_ty,\n                 )?;\n             }\n \n             \"memrchr\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2])?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(\n+                let val = self.value_to_scalar(args[1])?.to_bytes()? as u8;\n+                let num = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -244,13 +394,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             \"memchr\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2])?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(\n+                let val = self.value_to_scalar(args[1])?.to_bytes()? as u8;\n+                let num = self.value_to_scalar(args[2])?.to_usize(self)?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.offset(idx as u64, &self)?;\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -262,11 +412,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     let name_ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n-                        Some(&var) => PrimVal::Ptr(var),\n-                        None => PrimVal::Bytes(0),\n+                        Some(&var) => Scalar::Ptr(var),\n+                        None => Scalar::null(),\n                     }\n                 };\n-                self.write_primval(dest, result, dest_ty)?;\n+                self.write_scalar(dest, result, dest_ty)?;\n             }\n \n             \"unsetenv\" => {\n@@ -286,7 +436,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::from_i128(-1), dest_ty)?;\n                 }\n             }\n \n@@ -306,12 +456,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate(\n-                        (value.len() + 1) as u64,\n-                        1,\n-                        Some(MemoryKind::Env.into()),\n+                        Size::from_bytes((value.len() + 1) as u64),\n+                        Align::from_bytes(1, 1).unwrap(),\n+                        MemoryKind::Env.into(),\n                     )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n+                    let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n                     self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n@@ -322,58 +472,61 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::from_i128(-1), dest_ty)?;\n                 }\n             }\n \n             \"write\" => {\n-                let fd = self.value_to_primval(args[0])?.to_u64()?;\n+                let fd = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let buf = self.into_ptr(args[1].value)?;\n-                let n = self.value_to_primval(args[2])?.to_u64()?;\n+                let n = self.value_to_scalar(args[2])?.to_bytes()? as u64;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let buf_cont = self.memory.read_bytes(buf, Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n                         io::stderr().write(buf_cont)\n                     };\n                     match res {\n-                        Ok(n) => n as isize,\n+                        Ok(n) => n as i64,\n                         Err(_) => -1,\n                     }\n                 } else {\n                     warn!(\"Ignored output to FD {}\", fd);\n-                    n as isize // pretend it all went well\n+                    n as i64 // pretend it all went well\n                 }; // now result is the value we return back to the program\n-                self.write_primval(\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(result as u128),\n+                    Scalar::from_isize(result, ptr_size),\n                     dest_ty,\n                 )?;\n             }\n \n             \"strlen\" => {\n                 let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_usize(n as u64, ptr_size), dest_ty)?;\n             }\n \n             // Some things needed for sys::thread initialization to go through\n             \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_scalar(dest, Scalar::null(), dest_ty)?;\n             }\n \n             \"sysconf\" => {\n-                let name = self.value_to_primval(args[0])?.to_u64()?;\n+                let name = self.value_to_scalar(args[0])?.to_usize(self)?;\n+\n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n                 let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_i128(4096)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_i128(-1)),\n                 ];\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n@@ -382,20 +535,16 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                             instance,\n                             promoted: None,\n                         };\n-                        // compute global if not cached\n-                        let val = match self.tcx.interpret_interner.borrow().get_cached(cid) {\n-                            Some(ptr) => ptr,\n-                            None => eval_body(self.tcx, instance, ty::ParamEnv::empty(traits::Reveal::All)).0?.0,\n-                        };\n-                        let val = self.value_to_primval(ValTy { value: Value::ByRef(val), ty: args[0].ty })?.to_u64()?;\n-                        if val == name {\n+                        let const_val = self.const_eval(cid)?;\n+                        let value = const_val.unwrap_usize(self.tcx.tcx);\n+                        if value == name {\n                             result = Some(path_value);\n                             break;\n                         }\n                     }\n                 }\n                 if let Some(result) = result {\n-                    self.write_primval(dest, result, dest_ty)?;\n+                    self.write_scalar(dest, result, dest_ty)?;\n                 } else {\n                     return err!(Unimplemented(\n                         format!(\"Unimplemented sysconf name: {}\", name),\n@@ -406,67 +555,85 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = self.into_ptr(args[0].value)?;\n+                let key_align = self.layout_of(args[0].ty)?.align;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match self.into_ptr(args[1].value)?.into_inner_primval() {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return err!(ReadBytesAsPointer),\n-                    PrimVal::Undef => return err!(ReadUndefBytes),\n+                let dtor = match self.into_ptr(args[1].value)? {\n+                    Scalar::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    Scalar::Bits { defined: 0, .. } => return err!(ReadUndefBytes),\n+                    Scalar::Bits { bits: 0, .. } => None,\n+                    Scalar::Bits { .. } => return err!(ReadBytesAsPointer),\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = args[0].ty.builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                   .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                let key_type = args[0].ty.builtin_deref(true)\n+                                   .ok_or_else(|| EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = self.layout_of(key_type)?.size;\n \n                 // Create key and write it into the memory where key_ptr wants it\n                 let key = self.memory.create_tls_key(dtor) as u128;\n                 if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.memory.write_primval(\n-                    key_ptr.to_ptr()?,\n-                    PrimVal::Bytes(key),\n-                    key_size.bytes(),\n+                self.memory.write_scalar(\n+                    key_ptr,\n+                    key_align,\n+                    Scalar::from_u128(key),\n+                    key_size,\n                     false,\n                 )?;\n \n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n             }\n             \"pthread_key_delete\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n+                let key = self.value_to_scalar(args[0])?.to_bytes()?;\n                 self.memory.delete_tls_key(key)?;\n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n             }\n             \"pthread_getspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n+                let key = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let ptr = self.memory.load_tls(key)?;\n                 self.write_ptr(dest, ptr, dest_ty)?;\n             }\n             \"pthread_setspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n+                let key = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let new_ptr = self.into_ptr(args[1].value)?;\n                 self.memory.store_tls(key, new_ptr)?;\n \n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n             }\n \n+            \"_tlv_atexit\" => {\n+                return err!(Unimplemented(\"can't interpret with full mir for osx target\".to_owned()));\n+            },\n+\n             // Stub out all the other pthread calls to just return 0\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 info!(\"ignoring C ABI call: {}\", link_name);\n                 self.write_null(dest, dest_ty)?;\n             }\n \n+            \"mmap\" => {\n+                // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n+                let addr = self.into_ptr(args[0].value)?;\n+                self.write_ptr(dest, addr, dest_ty)?;\n+            }\n+\n+            // Windows API subs\n+            \"AddVectoredExceptionHandler\" |\n+            \"SetThreadStackGuarantee\" => {\n+                let usize = self.tcx.types.usize;\n+                // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n+                self.write_scalar(dest, Scalar::from_u128(1), usize)?;\n+            },\n+\n+            // We can't execute anything else\n             _ => {\n                 return err!(Unimplemented(\n-                    format!(\"can't call C ABI function: {}\", link_name),\n+                    format!(\"can't call foreign function: {}\", link_name),\n                 ));\n             }\n         }\n@@ -497,7 +664,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     for item in mem::replace(&mut items, Default::default()).iter() {\n                         if item.ident.name == *segment {\n                             if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n+                                return Some(ty::Instance::mono(self.tcx.tcx, item.def.def_id()));\n                             }\n \n                             items = self.tcx.item_children(item.def.def_id());\n@@ -534,11 +701,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             || EvalErrorKind::NoMirFor(path.clone()),\n         )?;\n \n-        if sig.abi == Abi::C {\n-            // An external C function\n+        if self.tcx.is_foreign_item(instance.def_id()) {\n+            // An external function\n             // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n             // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(\n+            self.call_foreign_item(\n                 instance.def_id(),\n                 args,\n                 dest,\n@@ -549,74 +716,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         }\n \n         match &path[..] {\n-            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n-            \"alloc::heap::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                let align = self.value_to_primval(args[1])?.to_u64()?;\n-                if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Some(MemoryKind::Rust.into()))?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                let align = self.value_to_primval(args[1])?.to_u64()?;\n-                if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Some(MemoryKind::Rust.into()))?;\n-                self.memory.write_repeat(ptr.into(), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n-                let align = self.value_to_primval(args[2])?.to_u64()?;\n-                if old_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(\n-                    ptr,\n-                    Some((old_size, align)),\n-                    MemoryKind::Rust.into(),\n-                )?;\n-            }\n-            \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n-                let old_align = self.value_to_primval(args[2])?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3])?.to_u64()?;\n-                let new_align = self.value_to_primval(args[4])?.to_u64()?;\n-                if old_size == 0 || new_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !old_align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(old_align));\n-                }\n-                if !new_align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(new_align));\n-                }\n-                let new_ptr = self.memory.reallocate(\n-                    ptr,\n-                    old_size,\n-                    old_align,\n-                    new_size,\n-                    new_align,\n-                    MemoryKind::Rust.into(),\n-                )?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n             // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n             // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n             \"std::io::_print\" => {\n@@ -636,14 +735,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"std::rt::panicking\" => {\n                 // we abort on panic -> `std::rt::panicking` always returns false\n                 let bool = self.tcx.types.bool;\n-                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n+                self.write_scalar(dest, Scalar::from_bool(false), bool)?;\n             }\n-            \"std::sys::imp::c::::AddVectoredExceptionHandler\" |\n-            \"std::sys::imp::c::::SetThreadStackGuarantee\" => {\n-                let usize = self.tcx.types.usize;\n-                // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n-                self.write_primval(dest, PrimVal::Bytes(1), usize)?;\n-            },\n+\n             _ => return err!(NoMirFor(path)),\n         }\n \n@@ -652,10 +746,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         // current frame.\n         self.dump_local(dest);\n         self.goto_block(dest_block);\n-        return Ok(());\n+        Ok(())\n     }\n \n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n+        self.write_scalar(dest, Scalar::null(), dest_ty)\n     }\n }", "previous_filename": "miri/fn_call.rs"}, {"sha": "aa699b509fad8a4210c7ac177b475afdcfe2082f", "filename": "src/helpers.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,128 @@\n+use mir;\n+use rustc::ty::Ty;\n+use rustc::ty::layout::{LayoutOf, Size};\n+\n+use super::{Scalar, ScalarExt, EvalResult, EvalContext, ValTy};\n+use rustc_mir::interpret::sign_extend;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn wrapping_pointer_offset(\n+        &self,\n+        ptr: Scalar,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Scalar>;\n+\n+    fn pointer_offset(\n+        &self,\n+        ptr: Scalar,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Scalar>;\n+\n+    fn value_to_isize(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, i64>;\n+\n+    fn value_to_usize(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, u64>;\n+\n+    fn value_to_i32(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, i32>;\n+\n+    fn value_to_u8(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, u8>;\n+}\n+\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n+    fn wrapping_pointer_offset(\n+        &self,\n+        ptr: Scalar,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Scalar> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n+        let offset = offset.overflowing_mul(pointee_size).0;\n+        ptr.ptr_wrapping_signed_offset(offset, self)\n+    }\n+\n+    fn pointer_offset(\n+        &self,\n+        ptr: Scalar,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Scalar> {\n+        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n+        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n+        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n+        // allocation.\n+\n+        if ptr.is_null()? {\n+            // NULL pointers must only be offset by 0\n+            return if offset == 0 {\n+                Ok(ptr)\n+            } else {\n+                err!(InvalidNullPointerUsage)\n+            };\n+        }\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n+         if let Some(offset) = offset.checked_mul(pointee_size) {\n+            let ptr = ptr.ptr_signed_offset(offset, self)?;\n+            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n+            if let Scalar::Ptr(ptr) = ptr {\n+                self.memory.check_bounds(ptr, false)?;\n+            } else if ptr.is_null()? {\n+                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n+                return err!(InvalidNullPointerUsage);\n+            }\n+            Ok(ptr)\n+        } else {\n+            err!(Overflow(mir::BinOp::Mul))\n+        }\n+    }\n+\n+    fn value_to_isize(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, i64> {\n+        assert_eq!(value.ty, self.tcx.types.isize);\n+        let raw = self.value_to_scalar(value)?.to_bits(self.memory.pointer_size())?;\n+        let raw = sign_extend(self.tcx.tcx, raw, self.tcx.types.isize)?;\n+        Ok(raw as i64)\n+    }\n+\n+    fn value_to_usize(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, u64> {\n+        assert_eq!(value.ty, self.tcx.types.usize);\n+        self.value_to_scalar(value)?.to_bits(self.memory.pointer_size()).map(|v| v as u64)\n+    }\n+\n+    fn value_to_i32(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, i32> {\n+        assert_eq!(value.ty, self.tcx.types.i32);\n+        let raw = self.value_to_scalar(value)?.to_bits(Size::from_bits(32))?;\n+        let raw = sign_extend(self.tcx.tcx, raw, self.tcx.types.i32)?;\n+        Ok(raw as i32)\n+    }\n+\n+    fn value_to_u8(\n+        &self,\n+        value: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, u8> {\n+        assert_eq!(value.ty, self.tcx.types.u8);\n+        self.value_to_scalar(value)?.to_bits(Size::from_bits(8)).map(|v| v as u8)\n+    }\n+}"}, {"sha": "cee2f1ab7682fb9e0cc7e71ffa76f7a51dce2966", "filename": "src/intrinsic.rs", "status": "renamed", "additions": 156, "deletions": 138, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,13 +1,14 @@\n use rustc::mir;\n-use rustc::traits::Reveal;\n-use rustc::ty::layout::{TyLayout, LayoutOf};\n+use rustc::ty::layout::{TyLayout, LayoutOf, Size, Primitive, Integer::*};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, Pointer, AccessKind, PtrAndAlign};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use rustc_mir::interpret::{Place, PlaceExtra, HasMemory, EvalContext, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n \n+use super::ScalarExt;\n+\n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n         &mut self,\n@@ -19,7 +20,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -30,14 +31,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n     ) -> EvalResult<'tcx> {\n         let substs = instance.substs;\n \n-        let intrinsic_name = &self.tcx.item_name(instance.def_id())[..];\n+        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n-            \"align_offset\" => {\n-                // FIXME: return a real value in case the target allocation has an\n-                // alignment bigger than the one requested\n-                self.write_primval(dest, PrimVal::Bytes(u128::max_value()), dest_layout.ty)?;\n-            },\n-\n             \"add_with_overflow\" => {\n                 self.intrinsic_with_overflow(\n                     mir::BinOp::Add,\n@@ -69,14 +64,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n \n             \"arith_offset\" => {\n-                let offset = self.value_to_primval(args[1])?.to_i128()? as i64;\n+                let offset = self.value_to_isize(args[1])?;\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_layout.ty)?;\n             }\n \n             \"assume\" => {\n-                let cond = self.value_to_primval(args[0])?.to_bool()?;\n+                let cond = self.value_to_scalar(args[0])?.to_bool()?;\n                 if !cond {\n                     return err!(AssumptionNotHeld);\n                 }\n@@ -87,8 +82,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n+                let align = self.layout_of(args[0].ty)?.align;\n+\n                 let valty = ValTy {\n-                    value: Value::by_ref(ptr),\n+                    value: Value::ByRef(ptr, align),\n                     ty: substs.type_at(0),\n                 };\n                 self.write_value(valty, dest)?;\n@@ -99,8 +96,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let dest = self.into_ptr(args[0].value)?;\n-                self.write_value_to_ptr(args[1].value, dest, ty)?;\n+                self.write_value_to_ptr(args[1].value, dest, align, ty)?;\n             }\n \n             \"atomic_fence_acq\" => {\n@@ -109,41 +107,43 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let change = self.value_to_primval(args[1])?;\n-                let old = self.read_value(ptr, ty)?;\n+                let change = self.value_to_scalar(args[1])?;\n+                let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::ByVal(val) => val,\n+                    Value::Scalar(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n+                    Value::ScalarPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n-                self.write_primval(dest, old, ty)?;\n-                self.write_primval(\n-                    Place::from_primval_ptr(ptr),\n+                self.write_scalar(dest, old, ty)?;\n+                self.write_scalar(\n+                    Place::from_scalar_ptr(ptr, align),\n                     change,\n                     ty,\n                 )?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let expect_old = self.value_to_primval(args[1])?;\n-                let change = self.value_to_primval(args[2])?;\n-                let old = self.read_value(ptr, ty)?;\n+                let expect_old = self.value_to_scalar(args[1])?;\n+                let change = self.value_to_scalar(args[2])?;\n+                let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::ByVal(val) => val,\n+                    Value::Scalar(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n+                    Value::ScalarPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let valty = ValTy {\n-                    value: Value::ByValPair(old, val),\n+                    value: Value::ScalarPair(old, val),\n                     ty: dest_layout.ty,\n                 };\n                 self.write_value(valty, dest)?;\n-                self.write_primval(\n-                    Place::from_primval_ptr(ptr),\n+                self.write_scalar(\n+                    Place::from_scalar_ptr(ptr, dest_layout.align),\n                     change,\n                     ty,\n                 )?;\n@@ -175,17 +175,18 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let change = self.value_to_primval(args[1])?;\n-                let old = self.read_value(ptr, ty)?;\n+                let change = self.value_to_scalar(args[1])?;\n+                let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::ByVal(val) => val,\n+                    Value::Scalar(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => {\n+                    Value::ScalarPair(..) => {\n                         bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\")\n                     }\n                 };\n-                self.write_primval(dest, old, ty)?;\n+                self.write_scalar(dest, old, ty)?;\n                 let op = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => mir::BinOp::BitOr,\n                     \"xor\" => mir::BinOp::BitXor,\n@@ -196,7 +197,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 };\n                 // FIXME: what do atomics do on overflow?\n                 let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_primval(Place::from_primval_ptr(ptr), val, ty)?;\n+                self.write_scalar(Place::from_scalar_ptr(ptr, dest_layout.align), val, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -206,27 +207,31 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 let elem_ty = substs.type_at(0);\n                 let elem_layout = self.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n-                let count = self.value_to_primval(args[2])?.to_u64()?;\n+                let count = self.value_to_usize(args[2])?;\n                 if count * elem_size != 0 {\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n-                    let elem_align = elem_layout.align.abi();\n+                    let elem_align = elem_layout.align;\n                     let src = self.into_ptr(args[0].value)?;\n                     let dest = self.into_ptr(args[1].value)?;\n                     self.memory.copy(\n                         src,\n+                        elem_align,\n                         dest,\n-                        count * elem_size,\n                         elem_align,\n+                        Size::from_bytes(count * elem_size),\n                         intrinsic_name.ends_with(\"_nonoverlapping\"),\n                     )?;\n                 }\n             }\n \n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n                 let ty = substs.type_at(0);\n-                let num = self.value_to_primval(args[0])?.to_bytes()?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n+                let num = self.value_to_scalar(args[0])?.to_bytes()?;\n+                let kind = match self.layout_of(ty)?.abi {\n+                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n+                };\n                 let num = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if num == 0 {\n                         return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n@@ -235,20 +240,21 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 } else {\n                     numeric_intrinsic(intrinsic_name, num, kind)?\n                 };\n-                self.write_primval(dest, num, ty)?;\n+                self.write_scalar(dest, num, ty)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = self.into_ptr(args[0].value)?;\n-                let place = Place::from_primval_ptr(adt_ptr);\n+                let adt_align = self.layout_of(args[0].ty)?.align;\n+                let place = Place::from_scalar_ptr(adt_ptr, adt_align);\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_u128(discr_val), dest_layout.ty)?;\n             }\n \n             \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n             \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let f = f32::from_bits(f as u32);\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n@@ -265,12 +271,12 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     \"truncf32\" => f.trunc(),\n                     _ => bug!(),\n                 };\n-                self.write_primval(dest, PrimVal::Bytes(f.to_bits() as u128), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_f32(f), dest_layout.ty)?;\n             }\n \n             \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n             \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let f = f64::from_bits(f as u64);\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n@@ -287,13 +293,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     \"truncf64\" => f.trunc(),\n                     _ => bug!(),\n                 };\n-                self.write_primval(dest, PrimVal::Bytes(f.to_bits() as u128), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_f64(f), dest_layout.ty)?;\n             }\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n                 let ty = substs.type_at(0);\n-                let a = self.value_to_primval(args[0])?;\n-                let b = self.value_to_primval(args[1])?;\n+                let a = self.value_to_scalar(args[0])?;\n+                let b = self.value_to_scalar(args[1])?;\n                 let op = match intrinsic_name {\n                     \"fadd_fast\" => mir::BinOp::Add,\n                     \"fsub_fast\" => mir::BinOp::Sub,\n@@ -303,44 +309,59 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     _ => bug!(),\n                 };\n                 let result = self.binary_op(op, a, ty, b, ty)?;\n-                self.write_primval(dest, result.0, dest_layout.ty)?;\n+                self.write_scalar(dest, result.0, dest_layout.ty)?;\n             }\n \n+            \"exact_div\" => {\n+                // Performs an exact division, resulting in undefined behavior where\n+                // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+                let ty = substs.type_at(0);\n+                let a = self.value_to_scalar(args[0])?;\n+                let b = self.value_to_scalar(args[1])?;\n+                // check x % y != 0\n+                if !self.binary_op(mir::BinOp::Rem, a, ty, b, ty)?.0.is_null()? {\n+                    return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n+                }\n+                let result = self.binary_op(mir::BinOp::Div, a, ty, b, ty)?;\n+                self.write_scalar(dest, result.0, dest_layout.ty)?;\n+            },\n+\n             \"likely\" | \"unlikely\" | \"forget\" => {}\n \n             \"init\" => {\n-                let size = dest_layout.size.bytes();\n+                let size = dest_layout.size;\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n+                        Value::ByRef(ptr, _) => {\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n                             val\n                         }\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n-                        Value::ByVal(PrimVal::Undef) => {\n-                            match this.ty_to_primval_kind(dest_layout.ty) {\n-                                Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                                Err(_) => {\n+                        Value::Scalar(Scalar::Bits { defined: 0, .. }) => {\n+                            match this.layout_of(dest_layout.ty)?.abi {\n+                                ty::layout::Abi::Scalar(_) => Value::Scalar(Scalar::null()),\n+                                _ => {\n                                     // FIXME(oli-obk): pass TyLayout to alloc_ptr instead of Ty\n                                     let ptr = this.alloc_ptr(dest_layout.ty)?;\n-                                    let ptr = Pointer::from(PrimVal::Ptr(ptr));\n+                                    let ptr = Scalar::Ptr(ptr);\n                                     this.memory.write_repeat(ptr, 0, size)?;\n-                                    Value::by_ref(ptr)\n+                                    Value::ByRef(ptr, dest_layout.align)\n                                 }\n                             }\n                         }\n-                        Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                        Value::ByValPair(..) => {\n-                            Value::ByValPair(PrimVal::Bytes(0), PrimVal::Bytes(0))\n+                        Value::Scalar(_) => Value::Scalar(Scalar::null()),\n+                        Value::ScalarPair(..) => {\n+                            Value::ScalarPair(Scalar::null(), Scalar::null())\n                         }\n                     };\n                     Ok(zero_val)\n                 };\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, init)?,\n                     Place::Ptr {\n-                        ptr: PtrAndAlign { ptr, aligned: true },\n+                        ptr,\n+                        align: _align,\n                         extra: PlaceExtra::None,\n                     } => self.memory.write_repeat(ptr, 0, size)?,\n                     Place::Ptr { .. } => {\n@@ -352,37 +373,38 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.layout_of(elem_ty)?.align.abi();\n-                let align_val = PrimVal::from_u128(elem_align as u128);\n-                self.write_primval(dest, align_val, dest_layout.ty)?;\n+                let align_val = Scalar::from_u128(elem_align as u128);\n+                self.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n                 let align = layout.align.pref();\n-                let align_val = PrimVal::from_u128(align as u128);\n-                self.write_primval(dest, align_val, dest_layout.ty)?;\n+                let align_val = Scalar::from_u128(align as u128);\n+                self.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = self.into_ptr(args[0].value)?;\n-                self.write_value_to_ptr(args[1].value, ptr, ty)?;\n+                let align = self.layout_of(args[0].ty)?.align;\n+                self.write_value_to_ptr(args[1].value, ptr, align, ty)?;\n             }\n \n             \"needs_drop\" => {\n                 let ty = substs.type_at(0);\n-                let env = ty::ParamEnv::empty(Reveal::All);\n-                let needs_drop = ty.needs_drop(self.tcx, env);\n-                self.write_primval(\n+                let env = ty::ParamEnv::reveal_all();\n+                let needs_drop = ty.needs_drop(self.tcx.tcx, env);\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_bool(needs_drop),\n+                    Scalar::from_bool(needs_drop),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"offset\" => {\n-                let offset = self.value_to_primval(args[1])?.to_i128()? as i64;\n+                let offset = self.value_to_isize(args[1])?;\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_layout.ty)?;\n@@ -419,91 +441,91 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n \n             \"powf32\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n                 let f = f32::from_bits(f as u32);\n-                let f2 = self.value_to_primval(args[1])?.to_bytes()?;\n+                let f2 = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n                 let f2 = f32::from_bits(f2 as u32);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powf(f2).to_bits() as u128),\n+                    Scalar::from_f32(f.powf(f2)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"powf64\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n                 let f = f64::from_bits(f as u64);\n-                let f2 = self.value_to_primval(args[1])?.to_bytes()?;\n+                let f2 = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n                 let f2 = f64::from_bits(f2 as u64);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powf(f2).to_bits() as u128),\n+                    Scalar::from_f64(f.powf(f2)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"fmaf32\" => {\n-                let a = self.value_to_primval(args[0])?.to_bytes()?;\n+                let a = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n                 let a = f32::from_bits(a as u32);\n-                let b = self.value_to_primval(args[1])?.to_bytes()?;\n+                let b = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n                 let b = f32::from_bits(b as u32);\n-                let c = self.value_to_primval(args[2])?.to_bytes()?;\n+                let c = self.value_to_scalar(args[2])?.to_bits(Size::from_bits(32))?;\n                 let c = f32::from_bits(c as u32);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes((a * b + c).to_bits() as u128),\n+                    Scalar::from_f32(a * b + c),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"fmaf64\" => {\n-                let a = self.value_to_primval(args[0])?.to_bytes()?;\n+                let a = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n                 let a = f64::from_bits(a as u64);\n-                let b = self.value_to_primval(args[1])?.to_bytes()?;\n+                let b = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n                 let b = f64::from_bits(b as u64);\n-                let c = self.value_to_primval(args[2])?.to_bytes()?;\n+                let c = self.value_to_scalar(args[2])?.to_bits(Size::from_bits(64))?;\n                 let c = f64::from_bits(c as u64);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes((a * b + c).to_bits() as u128),\n+                    Scalar::from_f64(a * b + c),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"powif32\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n                 let f = f32::from_bits(f as u32);\n-                let i = self.value_to_primval(args[1])?.to_i128()?;\n-                self.write_primval(\n+                let i = self.value_to_i32(args[1])?;\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powi(i as i32).to_bits() as u128),\n+                    Scalar::from_f32(f.powi(i)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"powif64\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n                 let f = f64::from_bits(f as u64);\n-                let i = self.value_to_primval(args[1])?.to_i128()?;\n-                self.write_primval(\n+                let i = self.value_to_i32(args[1])?;\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powi(i as i32).to_bits() as u128),\n+                    Scalar::from_f64(f.powi(i)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = self.layout_of(ty)?.size.bytes().into();\n-                self.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_u128(size), dest_layout.ty)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, args[0].value)?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_u128(size.bytes() as u128),\n+                    Scalar::from_u128(size.bytes() as u128),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -512,9 +534,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, args[0].value)?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_u128(align.abi() as u128),\n+                    Scalar::from_u128(align.abi() as u128),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -528,24 +550,20 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::Bits { bits: n as u128, defined: 64 }, dest_layout.ty)?;\n             }\n \n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n+                let _src_align = self.layout_of(src_ty)?.align;\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_maybe_aligned_mut(\n-                    /*aligned*/\n-                    false,\n-                    |ectx| {\n-                        ectx.write_value_to_ptr(args[0].value, ptr.into(), src_ty)\n-                    },\n-                )?;\n+                let dest_align = self.layout_of(substs.type_at(1))?.align;\n+                self.write_value_to_ptr(args[0].value, ptr.into(), dest_align, src_ty).unwrap();\n             }\n \n             \"unchecked_shl\" => {\n                 let bits = dest_layout.size.bytes() as u128 * 8;\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n                     return err!(Intrinsic(\n@@ -563,7 +581,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             \"unchecked_shr\" => {\n                 let bits = dest_layout.size.bytes() as u128 * 8;\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n                     return err!(Intrinsic(\n@@ -580,7 +598,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n \n             \"unchecked_div\" => {\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n@@ -595,7 +613,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n \n             \"unchecked_rem\" => {\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n@@ -610,18 +628,19 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n \n             \"uninit\" => {\n-                let size = dest_layout.size.bytes();\n+                let size = dest_layout.size;\n                 let uninit = |this: &mut Self, val: Value| match val {\n-                    Value::ByRef(PtrAndAlign { ptr, .. }) => {\n+                    Value::ByRef(ptr, _) => {\n                         this.memory.mark_definedness(ptr, size, false)?;\n                         Ok(val)\n                     }\n-                    _ => Ok(Value::ByVal(PrimVal::Undef)),\n+                    _ => Ok(Value::Scalar(Scalar::undef())),\n                 };\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n                     Place::Ptr {\n-                        ptr: PtrAndAlign { ptr, aligned: true },\n+                        ptr,\n+                        align: _align,\n                         extra: PlaceExtra::None,\n                     } => self.memory.mark_definedness(ptr, size, false)?,\n                     Place::Ptr { .. } => {\n@@ -633,14 +652,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"write_bytes\" => {\n                 let ty = substs.type_at(0);\n                 let ty_layout = self.layout_of(ty)?;\n-                let val_byte = self.value_to_primval(args[1])?.to_u128()? as u8;\n+                let val_byte = self.value_to_u8(args[1])?;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let count = self.value_to_primval(args[2])?.to_u64()?;\n+                let count = self.value_to_usize(args[2])?;\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_layout.align.abi(), Some(AccessKind::Write))?;\n-                    self.memory.write_repeat(ptr, val_byte, ty_layout.size.bytes() * count)?;\n+                    self.memory.check_align(ptr, ty_layout.align)?;\n+                    self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;\n                 }\n             }\n \n@@ -659,26 +678,25 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n fn numeric_intrinsic<'tcx>(\n     name: &str,\n     bytes: u128,\n-    kind: PrimValKind,\n-) -> EvalResult<'tcx, PrimVal> {\n+    kind: Primitive,\n+) -> EvalResult<'tcx, Scalar> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n-            use rustc::mir::interpret::PrimValKind::*;\n             let result_bytes = match kind {\n-                I8 => (bytes as i8).$method() as u128,\n-                U8 => (bytes as u8).$method() as u128,\n-                I16 => (bytes as i16).$method() as u128,\n-                U16 => (bytes as u16).$method() as u128,\n-                I32 => (bytes as i32).$method() as u128,\n-                U32 => (bytes as u32).$method() as u128,\n-                I64 => (bytes as i64).$method() as u128,\n-                U64 => (bytes as u64).$method() as u128,\n-                I128 => (bytes as i128).$method() as u128,\n-                U128 => bytes.$method() as u128,\n+                Primitive::Int(I8, true) => (bytes as i8).$method() as u128,\n+                Primitive::Int(I8, false) => (bytes as u8).$method() as u128,\n+                Primitive::Int(I16, true) => (bytes as i16).$method() as u128,\n+                Primitive::Int(I16, false) => (bytes as u16).$method() as u128,\n+                Primitive::Int(I32, true) => (bytes as i32).$method() as u128,\n+                Primitive::Int(I32, false) => (bytes as u32).$method() as u128,\n+                Primitive::Int(I64, true) => (bytes as i64).$method() as u128,\n+                Primitive::Int(I64, false) => (bytes as u64).$method() as u128,\n+                Primitive::Int(I128, true) => (bytes as i128).$method() as u128,\n+                Primitive::Int(I128, false) => bytes.$method() as u128,\n                 _ => bug!(\"invalid `{}` argument: {:?}\", name, bytes),\n             };\n \n-            PrimVal::Bytes(result_bytes)\n+            Scalar::from_u128(result_bytes)\n         });\n     }\n ", "previous_filename": "miri/intrinsic.rs"}, {"sha": "520d696405a1b890783a6f4b4907256d2a662d88", "filename": "src/lib.rs", "status": "added", "additions": 604, "deletions": 0, "changes": 604, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,604 @@\n+#![feature(\n+    rustc_private,\n+    catch_expr,\n+    inclusive_range_fields,\n+    inclusive_range_methods,\n+)]\n+\n+#![cfg_attr(feature = \"cargo-clippy\", allow(cast_lossless))]\n+\n+#[macro_use]\n+extern crate log;\n+\n+// From rustc.\n+#[macro_use]\n+extern crate rustc;\n+extern crate rustc_data_structures;\n+extern crate rustc_mir;\n+extern crate rustc_target;\n+extern crate syntax;\n+extern crate regex;\n+#[macro_use]\n+extern crate lazy_static;\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n+use rustc::ty::subst::Subst;\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+\n+use rustc_data_structures::fx::FxHasher;\n+\n+use syntax::ast::Mutability;\n+use syntax::codemap::Span;\n+\n+use std::collections::{HashMap, BTreeMap};\n+use std::hash::{Hash, Hasher};\n+\n+pub use rustc::mir::interpret::*;\n+pub use rustc_mir::interpret::*;\n+\n+mod fn_call;\n+mod operator;\n+mod intrinsic;\n+mod helpers;\n+mod memory;\n+mod tls;\n+mod locks;\n+mod range_map;\n+mod validation;\n+\n+use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n+use operator::EvalContextExt as OperatorEvalContextExt;\n+use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n+use tls::EvalContextExt as TlsEvalContextExt;\n+use locks::LockInfo;\n+use locks::MemoryExt as LockMemoryExt;\n+use validation::EvalContextExt as ValidationEvalContextExt;\n+use range_map::RangeMap;\n+use validation::{ValidationQuery, AbsPlace};\n+\n+pub trait ScalarExt {\n+    fn null() -> Self;\n+    fn from_i32(i: i32) -> Self;\n+    fn from_u128(i: u128) -> Self;\n+    fn from_i128(i: i128) -> Self;\n+    fn from_usize(i: u64, ptr_size: Size) -> Self;\n+    fn from_isize(i: i64, ptr_size: Size) -> Self;\n+    fn from_f32(f: f32) -> Self;\n+    fn from_f64(f: f64) -> Self;\n+    fn to_usize<'a, 'mir, 'tcx>(self, ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>) -> EvalResult<'static, u64>;\n+    fn is_null(self) -> EvalResult<'static, bool>;\n+    /// HACK: this function just extracts all bits if `defined != 0`\n+    /// Mainly used for args of C-functions and we should totally correctly fetch the size\n+    /// of their arguments\n+    fn to_bytes(self) -> EvalResult<'static, u128>;\n+}\n+\n+impl ScalarExt for Scalar {\n+    fn null() -> Self {\n+        Scalar::Bits { bits: 0, defined: 128 }\n+    }\n+\n+    fn from_i32(i: i32) -> Self {\n+        Scalar::Bits { bits: i as u32 as u128, defined: 32 }\n+    }\n+\n+    fn from_u128(i: u128) -> Self {\n+        Scalar::Bits { bits: i, defined: 128 }\n+    }\n+\n+    fn from_i128(i: i128) -> Self {\n+        Scalar::Bits { bits: i as u128, defined: 128 }\n+    }\n+\n+    fn from_usize(i: u64, ptr_size: Size) -> Self {\n+        Scalar::Bits { bits: i as u128, defined: ptr_size.bits() as u8 }\n+    }\n+\n+    fn from_isize(i: i64, ptr_size: Size) -> Self {\n+        Scalar::Bits { bits: i as i128 as u128, defined: ptr_size.bits() as u8 }\n+    }\n+\n+    fn from_f32(f: f32) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, defined: 32 }\n+    }\n+\n+    fn from_f64(f: f64) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, defined: 64 }\n+    }\n+\n+    fn to_usize<'a, 'mir, 'tcx>(self, ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>) -> EvalResult<'static, u64> {\n+        let b = self.to_bits(ecx.memory.pointer_size())?;\n+        assert_eq!(b as u64 as u128, b);\n+        Ok(b as u64)\n+    }\n+\n+    fn is_null(self) -> EvalResult<'static, bool> {\n+        match self {\n+            Scalar::Bits { bits, defined } => {\n+                if defined > 0 {\n+                    Ok(bits == 0)\n+                } else {\n+                    err!(ReadUndefBytes)\n+                }\n+            }\n+            Scalar::Ptr(_) => Ok(false)\n+        }\n+    }\n+\n+    fn to_bytes(self) -> EvalResult<'static, u128> {\n+        match self {\n+            Scalar::Bits { defined: 0, .. } => err!(ReadUndefBytes),\n+            Scalar::Bits { bits, .. } => Ok(bits),\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+        }\n+    }\n+}\n+\n+pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n+) -> EvalResult<'tcx, (EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>, Option<Pointer>)> {\n+    let mut ecx = EvalContext::new(tcx.at(syntax::codemap::DUMMY_SP), ty::ParamEnv::reveal_all(), Default::default(), Default::default());\n+\n+    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n+    let main_mir = ecx.load_mir(main_instance.def)?;\n+    let mut cleanup_ptr = None; // Scalar to be deallocated when we are done\n+\n+    if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n+        return err!(Unimplemented(\n+            \"miri does not support main functions without `fn()` type signatures\"\n+                .to_owned(),\n+        ));\n+    }\n+\n+    if let Some(start_id) = start_wrapper {\n+        let main_ret_ty = ecx.tcx.fn_sig(main_id).output();\n+        let main_ret_ty = main_ret_ty.no_late_bound_regions().unwrap();\n+        let start_instance = ty::Instance::resolve(\n+            ecx.tcx.tcx,\n+            ty::ParamEnv::reveal_all(),\n+            start_id,\n+            ecx.tcx.mk_substs(\n+                ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n+            ).unwrap();\n+        let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+        if start_mir.arg_count != 3 {\n+            return err!(AbiViolation(format!(\n+                \"'start' lang item should have three arguments, but has {}\",\n+                start_mir.arg_count\n+            )));\n+        }\n+\n+        // Return value\n+        let size = ecx.tcx.data_layout.pointer_size;\n+        let align = ecx.tcx.data_layout.pointer_align;\n+        let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n+        cleanup_ptr = Some(ret_ptr);\n+\n+        // Push our stack frame\n+        ecx.push_stack_frame(\n+            start_instance,\n+            start_mir.span,\n+            start_mir,\n+            Place::from_ptr(ret_ptr, align),\n+            StackPopCleanup::None,\n+        )?;\n+\n+        let mut args = ecx.frame().mir.args_iter();\n+\n+        // First argument: pointer to main()\n+        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        let main_ty = main_instance.ty(ecx.tcx.tcx);\n+        let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx.tcx));\n+        ecx.write_value(\n+            ValTy {\n+                value: Value::Scalar(Scalar::Ptr(main_ptr)),\n+                ty: main_ptr_ty,\n+            },\n+            dest,\n+        )?;\n+\n+        // Second argument (argc): 1\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        let ty = ecx.tcx.types.isize;\n+        ecx.write_scalar(dest, Scalar::from_u128(1), ty)?;\n+\n+        // FIXME: extract main source file path\n+        // Third argument (argv): &[b\"foo\"]\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n+        let foo = ecx.memory.allocate_bytes(b\"foo\\0\");\n+        let ptr_size = ecx.memory.pointer_size();\n+        let ptr_align = ecx.tcx.data_layout.pointer_align;\n+        let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, MemoryKind::Stack)?;\n+        ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n+        ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n+        ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n+\n+        assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n+    } else {\n+        ecx.push_stack_frame(\n+            main_instance,\n+            main_mir.span,\n+            main_mir,\n+            Place::from_scalar_ptr(Scalar::from_u128(1), ty::layout::Align::from_bytes(1, 1).unwrap()),\n+            StackPopCleanup::None,\n+        )?;\n+\n+        // No arguments\n+        let mut args = ecx.frame().mir.args_iter();\n+        assert!(args.next().is_none(), \"main function must not have arguments\");\n+    }\n+\n+    Ok((ecx, cleanup_ptr))\n+}\n+\n+pub fn eval_main<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n+) {\n+    let (mut ecx, cleanup_ptr) = create_ecx(tcx, main_id, start_wrapper).expect(\"Couldn't create ecx\");\n+\n+    let res: EvalResult = do catch {\n+        while ecx.step()? {}\n+        ecx.run_tls_dtors()?;\n+        if let Some(cleanup_ptr) = cleanup_ptr {\n+            ecx.memory_mut().deallocate(\n+                cleanup_ptr,\n+                None,\n+                MemoryKind::Stack,\n+            )?;\n+        }\n+    };\n+\n+    match res {\n+        Ok(()) => {\n+            let leaks = ecx.memory().leak_report();\n+            if leaks != 0 {\n+                // TODO: Prevent leaks which aren't supposed to be there\n+                //tcx.sess.err(\"the evaluated program leaked memory\");\n+            }\n+        }\n+        Err(e) => {\n+            if let Some(frame) = ecx.stack().last() {\n+                let block = &frame.mir.basic_blocks()[frame.block];\n+                let span = if frame.stmt < block.statements.len() {\n+                    block.statements[frame.stmt].source_info.span\n+                } else {\n+                    block.terminator().source_info.span\n+                };\n+\n+                let e = e.to_string();\n+                let msg = format!(\"constant evaluation error: {}\", e);\n+                let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n+                let (frames, span) = ecx.generate_stacktrace(None);\n+                err.span_label(span, e);\n+                for FrameInfo { span, location, .. } in frames {\n+                    err.span_note(span, &format!(\"inside call to `{}`\", location));\n+                }\n+                err.emit();\n+            } else {\n+                ecx.tcx.sess.err(&e.to_string());\n+            }\n+\n+            for (i, frame) in ecx.stack().iter().enumerate() {\n+                trace!(\"-------------------\");\n+                trace!(\"Frame {}\", i);\n+                trace!(\"    return: {:#?}\", frame.return_place);\n+                for (i, local) in frame.locals.iter().enumerate() {\n+                    if let Some(local) = local {\n+                        trace!(\"    local {}: {:?}\", i, local);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Default, PartialEq, Eq)]\n+pub struct Evaluator<'tcx> {\n+    /// Environment variables set by `setenv`\n+    /// Miri does not expose env vars from the host to the emulated program\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n+\n+    /// Places that were suspended by the validation subsystem, and will be recovered later\n+    pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n+}\n+\n+impl<'tcx> Hash for Evaluator<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let Evaluator {\n+            env_vars,\n+            suspended: _,\n+        } = self;\n+\n+        env_vars.iter()\n+            .map(|(env, ptr)| {\n+                let mut h = FxHasher::default();\n+                env.hash(&mut h);\n+                ptr.hash(&mut h);\n+                h.finish()\n+            })\n+            .fold(0u64, |acc, hash| acc.wrapping_add(hash))\n+            .hash(state);\n+    }\n+}\n+\n+pub type TlsKey = u128;\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct TlsEntry<'tcx> {\n+    data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Clone, Default, PartialEq, Eq)]\n+pub struct MemoryData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    next_thread_local: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+\n+    /// Memory regions that are locked by some function\n+    ///\n+    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n+    /// The entry is created when allocating the memory and deleted after deallocation.\n+    locks: HashMap<AllocId, RangeMap<LockInfo<'tcx>>>,\n+\n+    statics: HashMap<GlobalId<'tcx>, AllocId>,\n+}\n+\n+impl<'tcx> Hash for MemoryData<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let MemoryData {\n+            next_thread_local: _,\n+            thread_local,\n+            locks: _,\n+            statics: _,\n+        } = self;\n+\n+        thread_local.hash(state);\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n+    type MemoryData = MemoryData<'tcx>;\n+    type MemoryKinds = memory::MemoryKind;\n+\n+    /// Returns Ok() when the function was handled, fail otherwise\n+    fn eval_fn_call<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n+        args: &[ValTy<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        ecx.eval_fn_call(instance, destination, args, span, sig)\n+    }\n+\n+    fn call_intrinsic<'a>(\n+        ecx: &mut rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[ValTy<'tcx>],\n+        dest: Place,\n+        dest_layout: TyLayout<'tcx>,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        ecx.call_intrinsic(instance, args, dest, dest_layout, target)\n+    }\n+\n+    fn try_ptr_op<'a>(\n+        ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: Scalar,\n+        left_ty: ty::Ty<'tcx>,\n+        right: Scalar,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n+        ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n+    }\n+\n+    fn mark_static_initialized<'a>(\n+        mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        id: AllocId,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool> {\n+        use memory::MemoryKind::*;\n+        match mem.get_alloc_kind(id) {\n+            // FIXME: This could be allowed, but not for env vars set during miri execution\n+            Some(MemoryKind::Machine(Env)) => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n+            _ => Ok(false), // TODO: What does the bool mean?\n+        }\n+    }\n+\n+    fn init_static<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        cid: GlobalId<'tcx>,\n+    ) -> EvalResult<'tcx, AllocId> {\n+        // Step 1: If the static has already been evaluated return the cached version\n+        if let Some(alloc_id) = ecx.memory.data.statics.get(&cid) {\n+            return Ok(*alloc_id);\n+        }\n+\n+        let tcx = ecx.tcx.tcx;\n+\n+        // Step 2: Load mir\n+        let mut mir = ecx.load_mir(cid.instance.def)?;\n+        if let Some(index) = cid.promoted {\n+            mir = &mir.promoted[index];\n+        }\n+        assert!(mir.arg_count == 0);\n+\n+        // Step 3: Allocate storage\n+        let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n+        assert!(!layout.is_unsized());\n+        let ptr = ecx.memory.allocate(\n+            layout.size,\n+            layout.align,\n+            MemoryKind::Stack,\n+        )?;\n+\n+        // Step 4: Cache allocation id for recursive statics\n+        assert!(ecx.memory.data.statics.insert(cid, ptr.alloc_id).is_none());\n+\n+        // Step 5: Push stackframe to evaluate static\n+        let cleanup = StackPopCleanup::None;\n+        ecx.push_stack_frame(\n+            cid.instance,\n+            mir.span,\n+            mir,\n+            Place::from_ptr(ptr, layout.align),\n+            cleanup,\n+        )?;\n+\n+        // Step 6: Step until static has been initialized\n+        let call_stackframe = ecx.stack().len();\n+        while ecx.step()? && ecx.stack().len() >= call_stackframe {\n+            if ecx.stack().len() == call_stackframe {\n+                let frame = ecx.frame_mut();\n+                let bb = &frame.mir.basic_blocks()[frame.block];\n+                if bb.statements.len() == frame.stmt && !bb.is_cleanup {\n+                    if let ::rustc::mir::TerminatorKind::Return = bb.terminator().kind {\n+                        for (local, _local_decl) in mir.local_decls.iter_enumerated().skip(1) {\n+                            // Don't deallocate locals, because the return value might reference them\n+                            frame.storage_dead(local);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // TODO: Freeze immutable statics without copying them to the global static cache\n+\n+        // Step 7: Return the alloc\n+        Ok(ptr.alloc_id)\n+    }\n+\n+    fn box_alloc<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ty: ty::Ty<'tcx>,\n+        dest: Place,\n+    ) -> EvalResult<'tcx> {\n+        let layout = ecx.layout_of(ty)?;\n+\n+        // Call the `exchange_malloc` lang item\n+        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n+        let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n+        let malloc_mir = ecx.load_mir(malloc.def)?;\n+        ecx.push_stack_frame(\n+            malloc,\n+            malloc_mir.span,\n+            malloc_mir,\n+            dest,\n+            // Don't do anything when we are done.  The statement() function will increment\n+            // the old stack frame's stmt counter to the next statement, which means that when\n+            // exchange_malloc returns, we go on evaluating exactly where we want to be.\n+            StackPopCleanup::None,\n+        )?;\n+\n+        let mut args = ecx.frame().mir.args_iter();\n+        let usize = ecx.tcx.types.usize;\n+\n+        // First argument: size\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        ecx.write_value(\n+            ValTy {\n+                value: Value::Scalar(Scalar::from_u128(match layout.size.bytes() {\n+                    0 => 1 as u128,\n+                    size => size as u128,\n+                })),\n+                ty: usize,\n+            },\n+            dest,\n+        )?;\n+\n+        // Second argument: align\n+        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+        ecx.write_value(\n+            ValTy {\n+                value: Value::Scalar(Scalar::from_u128(layout.align.abi().into())),\n+                ty: usize,\n+            },\n+            dest,\n+        )?;\n+\n+        // No more arguments\n+        assert!(args.next().is_none(), \"exchange_malloc lang item has more arguments than expected\");\n+        Ok(())\n+    }\n+\n+    fn global_item_with_linkage<'a>(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx> {\n+        panic!(\"remove this function from rustc\");\n+    }\n+\n+    fn check_locks<'a>(\n+        mem: &Memory<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+        size: Size,\n+        access: AccessKind,\n+    ) -> EvalResult<'tcx> {\n+        mem.check_locks(ptr, size.bytes(), access)\n+    }\n+\n+    fn add_lock<'a>(\n+        mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        id: AllocId,\n+    ) {\n+        mem.data.locks.insert(id, RangeMap::new());\n+    }\n+\n+    fn free_lock<'a>(\n+        mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n+        id: AllocId,\n+        len: u64,\n+    ) -> EvalResult<'tcx> {\n+        mem.data.locks\n+            .remove(&id)\n+            .expect(\"allocation has no corresponding locks\")\n+            .check(\n+                Some(mem.cur_frame),\n+                0,\n+                len,\n+                AccessKind::Read,\n+            )\n+            .map_err(|lock| {\n+                EvalErrorKind::DeallocatedLockedMemory {\n+                    //ptr, FIXME\n+                    ptr: Pointer {\n+                        alloc_id: AllocId(0),\n+                        offset: Size::from_bytes(0),\n+                    },\n+                    lock: lock.active,\n+                }.into()\n+            })\n+    }\n+\n+    fn end_region<'a>(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        reg: Option<::rustc::middle::region::Scope>,\n+    ) -> EvalResult<'tcx> {\n+        ecx.end_region(reg)\n+    }\n+\n+    fn validation_op<'a>(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _op: ::rustc::mir::ValidationOp,\n+        _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n+    ) -> EvalResult<'tcx> {\n+        // FIXME: prevent this from ICEing\n+        //ecx.validation_op(op, operand)\n+        Ok(())\n+    }\n+}"}, {"sha": "9f4126ad82b60002e105863b78712e8f10ae5278", "filename": "src/locks.rs", "status": "renamed", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,12 +1,13 @@\n use super::*;\n use rustc::middle::region;\n+use rustc::ty::layout::Size;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Information about a lock that is currently held.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LockInfo<'tcx> {\n     /// Stores for which lifetimes (of the original write lock) we got\n     /// which suspensions.\n@@ -69,27 +70,27 @@ impl<'tcx> LockInfo<'tcx> {\n pub trait MemoryExt<'tcx> {\n     fn check_locks(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         access: AccessKind,\n     ) -> EvalResult<'tcx>;\n     fn acquire_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         region: Option<region::Scope>,\n         kind: AccessKind,\n     ) -> EvalResult<'tcx>;\n     fn suspend_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         suspend: Option<region::Scope>,\n     ) -> EvalResult<'tcx>;\n     fn recover_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         lock_region: Option<region::Scope>,\n@@ -99,24 +100,24 @@ pub trait MemoryExt<'tcx> {\n }\n \n \n-impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn check_locks(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         access: AccessKind,\n     ) -> EvalResult<'tcx> {\n         if len == 0 {\n             return Ok(());\n         }\n-        let locks = match self.data.locks.get(&ptr.alloc_id.0) {\n+        let locks = match self.data.locks.get(&ptr.alloc_id) {\n             Some(locks) => locks,\n             // immutable static or other constant memory\n             None => return Ok(()),\n         };\n         let frame = self.cur_frame;\n         locks\n-            .check(Some(frame), ptr.offset, len, access)\n+            .check(Some(frame), ptr.offset.bytes(), len, access)\n             .map_err(|lock| {\n                 EvalErrorKind::MemoryLockViolation {\n                     ptr,\n@@ -131,7 +132,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n     /// Acquire the lock for the given lifetime\n     fn acquire_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         region: Option<region::Scope>,\n         kind: AccessKind,\n@@ -146,9 +147,9 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n             len,\n             region\n         );\n-        self.check_bounds(ptr.offset(len, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(Size::from_bytes(len), &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n \n-        let locks = match self.data.locks.get_mut(&ptr.alloc_id.0) {\n+        let locks = match self.data.locks.get_mut(&ptr.alloc_id) {\n             Some(locks) => locks,\n             // immutable static or other constant memory\n             None => return Ok(()),\n@@ -157,7 +158,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n         // Iterate over our range and acquire the lock.  If the range is already split into pieces,\n         // we have to manipulate all of them.\n         let lifetime = DynamicLifetime { frame, region };\n-        for lock in locks.iter_mut(ptr.offset, len) {\n+        for lock in locks.iter_mut(ptr.offset.bytes(), len) {\n             if !lock.access_permitted(None, kind) {\n                 return err!(MemoryAcquireConflict {\n                     ptr,\n@@ -190,20 +191,20 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n     /// When suspending, the same cases are fine; we just register an additional suspension.\n     fn suspend_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         suspend: Option<region::Scope>,\n     ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let locks = match self.data.locks.get_mut(&ptr.alloc_id.0) {\n+        let locks = match self.data.locks.get_mut(&ptr.alloc_id) {\n             Some(locks) => locks,\n             // immutable static or other constant memory\n             None => return Ok(()),\n         };\n \n-        'locks: for lock in locks.iter_mut(ptr.offset, len) {\n+        'locks: for lock in locks.iter_mut(ptr.offset.bytes(), len) {\n             let is_our_lock = match lock.active {\n                 WriteLock(lft) =>\n                     // Double-check that we are holding the lock.\n@@ -240,11 +241,9 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n                     // All is well\n                     continue 'locks;\n                 }\n-            } else {\n-                if !is_our_lock {\n-                    // All is well.\n-                    continue 'locks;\n-                }\n+            } else if !is_our_lock {\n+                // All is well.\n+                continue 'locks;\n             }\n             // If we get here, releasing this is an error except for NoLock.\n             if lock.active != NoLock {\n@@ -263,7 +262,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n     /// Release a suspension from the write lock.  If this is the last suspension or if there is no suspension, acquire the lock.\n     fn recover_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         lock_region: Option<region::Scope>,\n@@ -275,13 +274,13 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n             frame: cur_frame,\n             path: lock_path.clone(),\n         };\n-        let locks = match self.data.locks.get_mut(&ptr.alloc_id.0) {\n+        let locks = match self.data.locks.get_mut(&ptr.alloc_id) {\n             Some(locks) => locks,\n             // immutable static or other constant memory\n             None => return Ok(()),\n         };\n \n-        for lock in locks.iter_mut(ptr.offset, len) {\n+        for lock in locks.iter_mut(ptr.offset.bytes(), len) {\n             // Check if we have a suspension here\n             let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_id) {\n                 None => {\n@@ -376,7 +375,7 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n             }\n             // Clean up the map\n             alloc_locks.retain(|lock| match lock.active {\n-                NoLock => lock.suspended.len() > 0,\n+                NoLock => !lock.suspended.is_empty(),\n                 _ => true,\n             });\n         }", "previous_filename": "miri/locks.rs"}, {"sha": "bed0eb28c25c691e465fd7fa7e65831698bc5929", "filename": "src/memory.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "miri/memory.rs"}, {"sha": "1440f1dab4e0fc8187cadb09490907e0d329d7b0", "filename": "src/operator.rs", "status": "renamed", "additions": 68, "deletions": 45, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,5 @@\n use rustc::ty;\n+use rustc::ty::layout::Primitive;\n use rustc::mir;\n \n use super::*;\n@@ -9,74 +10,96 @@ pub trait EvalContextExt<'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: MemoryPointer,\n+        left: Pointer,\n         right: i128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        use rustc::mir::interpret::PrimValKind::*;\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n         use rustc::mir::BinOp::*;\n-        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n-        let left_kind = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        use rustc::ty::layout::Integer::*;\n+        let usize = Primitive::Int(match self.memory.pointer_size().bytes() {\n+            1 => I8,\n+            2 => I16,\n+            4 => I32,\n+            8 => I64,\n+            16 => I128,\n+            _ => unreachable!(),\n+        }, false);\n+        let isize = Primitive::Int(match self.memory.pointer_size().bytes() {\n+            1 => I8,\n+            2 => I16,\n+            4 => I32,\n+            8 => I64,\n+            16 => I128,\n+            _ => unreachable!(),\n+        }, true);\n+        let left_layout = self.layout_of(left_ty)?;\n+        let left_kind = match left_layout.abi {\n+            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+            _ => Err(EvalErrorKind::TypeNotPrimitive(left_ty))?,\n+        };\n+        let right_layout = self.layout_of(right_ty)?;\n+        let right_kind = match right_layout.abi {\n+            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+            _ => Err(EvalErrorKind::TypeNotPrimitive(right_ty))?,\n+        };\n         match bin_op {\n-            Offset if left_kind == Ptr && right_kind == usize => {\n+            Offset if left_kind == Primitive::Pointer && right_kind == usize => {\n                 let pointee_ty = left_ty\n-                    .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                    .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset(\n-                    left.into(),\n+                    left,\n                     pointee_ty,\n-                    right.to_bytes()? as i64,\n+                    right.to_bits(self.memory.pointer_size())? as i64,\n                 )?;\n-                Ok(Some((ptr.into_inner_primval(), false)))\n+                Ok(Some((ptr, false)))\n             }\n             // These work on anything\n             Eq if left_kind == right_kind => {\n                 let result = match (left, right) {\n-                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n-                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                    (PrimVal::Undef, _) |\n-                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n+                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n+                        left.to_bits(left_layout.size)? == right.to_bits(right_layout.size)?\n+                    },\n+                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left == right,\n                     _ => false,\n                 };\n-                Ok(Some((PrimVal::from_bool(result), false)))\n+                Ok(Some((Scalar::from_bool(result), false)))\n             }\n             Ne if left_kind == right_kind => {\n                 let result = match (left, right) {\n-                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n-                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                    (PrimVal::Undef, _) |\n-                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n+                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n+                        left.to_bits(left_layout.size)? != right.to_bits(right_layout.size)?\n+                    },\n+                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left != right,\n                     _ => true,\n                 };\n-                Ok(Some((PrimVal::from_bool(result), false)))\n+                Ok(Some((Scalar::from_bool(result), false)))\n             }\n             // These need both pointers to be in the same allocation\n             Lt | Le | Gt | Ge | Sub\n                 if left_kind == right_kind &&\n-                       (left_kind == Ptr || left_kind == usize || left_kind == isize) &&\n+                       (left_kind == Primitive::Pointer || left_kind == usize || left_kind == isize) &&\n                        left.is_ptr() && right.is_ptr() => {\n                 let left = left.to_ptr()?;\n                 let right = right.to_ptr()?;\n@@ -89,15 +112,15 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                         Sub => {\n                             return self.binary_op(\n                                 Sub,\n-                                PrimVal::Bytes(left.offset as u128),\n+                                Scalar::Bits { bits: left.offset.bytes() as u128, defined: self.memory.pointer_size().bits() as u8 },\n                                 self.tcx.types.usize,\n-                                PrimVal::Bytes(right.offset as u128),\n+                                Scalar::Bits { bits: right.offset.bytes() as u128, defined: self.memory.pointer_size().bits() as u8 },\n                                 self.tcx.types.usize,\n                             ).map(Some)\n                         }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n-                    Ok(Some((PrimVal::from_bool(res), false)))\n+                    Ok(Some((Scalar::from_bool(res), false)))\n                 } else {\n                     // Both are pointers, but from different allocations.\n                     err!(InvalidPointerMath)\n@@ -106,23 +129,23 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             // These work if one operand is a pointer, the other an integer\n             Add | BitAnd | Sub\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_bytes() => {\n+                       left.is_ptr() && right.is_bits() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     left.to_ptr()?,\n-                    right.to_bytes()? as i128,\n+                    right.to_bits(self.memory.pointer_size())? as i128,\n                     left_kind == isize,\n                 ).map(Some)\n             }\n             Add | BitAnd\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_bytes() && right.is_ptr() => {\n+                       left.is_bits() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     right.to_ptr()?,\n-                    left.to_bytes()? as i128,\n+                    left.to_bits(self.memory.pointer_size())? as i128,\n                     left_kind == isize,\n                 ).map(Some)\n             }\n@@ -133,14 +156,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: MemoryPointer,\n+        left: Pointer,\n         right: i128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over): (MemoryPointer, bool)) -> (PrimVal, bool) {\n-            (PrimVal::Ptr(res), over)\n+        fn map_to_primval((res, over): (Pointer, bool)) -> (Scalar, bool) {\n+            (Scalar::Ptr(res), over)\n         }\n \n         Ok(match bin_op {\n@@ -150,17 +173,17 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             Add if signed =>\n                 map_to_primval(left.overflowing_signed_offset(right, self)),\n             Add if !signed =>\n-                map_to_primval(left.overflowing_offset(right as u64, self)),\n+                map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n-                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n+                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align.abi() - 1);\n                 let right = right as u64;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n+                    (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(left.offset.bytes() & right))), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (PrimVal::from_u128((left.offset & right) as u128), false)\n+                    (Scalar::Bits { bits: (left.offset.bytes() & right) as u128, defined: 128 }, false)\n                 } else {\n                     return err!(ReadPointerAsBytes);\n                 }", "previous_filename": "miri/operator.rs"}, {"sha": "76d01ad19e3ab609e5bfafc80aed5ea3c7cf24c7", "filename": "src/range_map.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -7,7 +7,7 @@\n use std::collections::BTreeMap;\n use std::ops;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct RangeMap<T> {\n     map: BTreeMap<Range, T>,\n }\n@@ -19,7 +19,7 @@ pub struct RangeMap<T> {\n // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n // This kind of search breaks, if `end < start`, so don't do that!\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-struct Range {\n+pub struct Range {\n     start: u64,\n     end: u64, // Invariant: end > start\n }\n@@ -189,7 +189,7 @@ impl<T> RangeMap<T> {\n         F: FnMut(&T) -> bool,\n     {\n         let mut remove = Vec::new();\n-        for (range, data) in self.map.iter() {\n+        for (range, data) in &self.map {\n             if !f(data) {\n                 remove.push(*range);\n             }", "previous_filename": "miri/range_map.rs"}, {"sha": "45805f3aa8cc1199e15b24ede7dfecf42b95f57e", "filename": "src/tls.rs", "status": "renamed", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,67 +1,67 @@\n use rustc::{ty, mir};\n \n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Pointer, Memory, Evaluator, Place,\n-            StackPopCleanup, EvalContext};\n+use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, ScalarExt, Memory, Evaluator,\n+            Place, StackPopCleanup, EvalContext};\n \n pub trait MemoryExt<'tcx> {\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar>;\n+    fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx>;\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n+    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Scalar, TlsKey)>>;\n }\n \n pub trait EvalContextExt<'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.data.next_thread_local;\n         self.data.next_thread_local += 1;\n         self.data.thread_local.insert(\n             new_key,\n             TlsEntry {\n-                data: Pointer::null(),\n+                data: Scalar::null(),\n                 dtor,\n             },\n         );\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n+        new_key\n     }\n \n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.remove(&key) {\n+        match self.data.thread_local.remove(&key) {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n-        return match self.data.thread_local.get(&key) {\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n+        match self.data.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data)\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.get_mut(&key) {\n+    fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n+        match self.data.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n                 *data = new_data;\n                 Ok(())\n             }\n             None => err!(TlsOutOfBounds),\n-        };\n+        }\n     }\n \n     /// Returns a dtor, its argument and its index, if one is supposed to run\n@@ -85,28 +85,30 @@ impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator<'tcx>> {\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n+    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Scalar, TlsKey)>> {\n         use std::collections::Bound::*;\n+\n+        let thread_local = &mut self.data.thread_local;\n         let start = match key {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n         for (&key, &mut TlsEntry { ref mut data, dtor }) in\n-            self.data.thread_local.range_mut((start, Unbounded))\n+            thread_local.range_mut((start, Unbounded))\n         {\n             if !data.is_null()? {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = Pointer::null();\n+                    *data = Scalar::null();\n                     return Ok(ret);\n                 }\n             }\n         }\n-        return Ok(None);\n+        Ok(None)\n     }\n }\n \n-impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n         let mut dtor = self.memory.fetch_tls_dtor(None)?;\n         // FIXME: replace loop by some structure that works with stepping\n@@ -122,8 +124,8 @@ impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator<'tcx\n                 Place::undef(),\n                 StackPopCleanup::None,\n             )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(\n-                EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n+            let arg_local = self.frame().mir.args_iter().next().ok_or_else(\n+                || EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n             )?;\n             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n             let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);", "previous_filename": "miri/tls.rs"}, {"sha": "758fd5d274701c409415b8e42f1504a0978eaf8d", "filename": "src/validation.rs", "status": "renamed", "additions": 56, "deletions": 70, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,17 +1,18 @@\n use rustc::hir::{self, Mutability};\n use rustc::hir::Mutability::*;\n use rustc::mir::{self, ValidationOp, ValidationOperand};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::mir::interpret::GlobalId;\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt, Instance};\n+use rustc::ty::layout::{LayoutOf, PrimitiveExt};\n use rustc::ty::subst::{Substs, Subst};\n-use rustc::traits;\n+use rustc::traits::{self, TraitEngine};\n use rustc::infer::InferCtxt;\n-use rustc::traits::Reveal;\n use rustc::middle::region;\n+use rustc::mir::interpret::{ConstValue};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::interpret::HasMemory;\n \n-use super::{EvalContext, Place, PlaceExtra, ValTy};\n+use super::{EvalContext, Place, PlaceExtra, ValTy, ScalarExt};\n use rustc::mir::interpret::{DynamicLifetime, AccessKind, EvalErrorKind, Value, EvalError, EvalResult};\n use locks::MemoryExt;\n \n@@ -108,7 +109,7 @@ pub(crate) trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'tcx>> {\n+impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn abstract_place_projection(&self, proj: &mir::PlaceProjection<'tcx>) -> EvalResult<'tcx, AbsPlaceProjection<'tcx>> {\n         use self::mir::ProjectionElem::*;\n \n@@ -117,8 +118,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             Field(f, _) => Field(f, ()),\n             Index(v) => {\n                 let value = self.frame().get_local(v)?;\n-                let ty = self.tcx.types.usize;\n-                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n+                let ty = self.tcx.tcx.types.usize;\n+                let n = self.value_to_scalar(ValTy { value, ty })?.to_usize(self)?;\n                 Index(n)\n             },\n             ConstantIndex { offset, min_length, from_end } =>\n@@ -134,10 +135,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n     }\n \n     fn abstract_place(&self, place: &mir::Place<'tcx>) -> EvalResult<'tcx, AbsPlace<'tcx>> {\n-        Ok(match place {\n-            &mir::Place::Local(l) => AbsPlace::Local(l),\n-            &mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n-            &mir::Place::Projection(ref p) =>\n+        Ok(match *place {\n+            mir::Place::Local(l) => AbsPlace::Local(l),\n+            mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n+            mir::Place::Projection(ref p) =>\n                 AbsPlace::Projection(Box::new(self.abstract_place_projection(&*p)?)),\n         })\n     }\n@@ -152,7 +153,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         // because other crates may have been compiled with mir-emit-validate > 0.  Ignore those\n         // commands.  This makes mir-emit-validate also a flag to control whether miri will do\n         // validation or not.\n-        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n+        if self.tcx.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n             return Ok(());\n         }\n         debug_assert!(self.memory.cur_frame == self.cur_frame());\n@@ -187,7 +188,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n         // We need to monomorphize ty *without* erasing lifetimes\n         trace!(\"validation_op1: {:?}\", operand.ty.sty);\n-        let ty = operand.ty.subst(self.tcx, self.substs());\n+        let ty = operand.ty.subst(self.tcx.tcx, self.substs());\n         trace!(\"validation_op2: {:?}\", operand.ty.sty);\n         let place = self.eval_place(&operand.place)?;\n         let abs_place = self.abstract_place(&operand.place)?;\n@@ -250,7 +251,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n     }\n \n     fn normalize_type_unerased(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        return normalize_associated_type(self.tcx, &ty);\n+        return normalize_associated_type(self.tcx.tcx, &ty);\n \n         use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -356,7 +357,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         where\n             T: MyTransNormalize<'tcx>,\n         {\n-            let param_env = ty::ParamEnv::empty(Reveal::All);\n+            let param_env = ty::ParamEnv::reveal_all();\n \n             if !value.has_projections() {\n                 return value.clone();\n@@ -377,13 +378,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         mut layout: ty::layout::TyLayout<'tcx>,\n         i: usize,\n     ) -> EvalResult<'tcx, Ty<'tcx>> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                layout = layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n+        if let Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } = base {\n+            layout = layout.for_variant(&self, variant_index);\n         }\n-        let tcx = self.tcx;\n+        let tcx = self.tcx.tcx;\n         Ok(match layout.ty.sty {\n             ty::TyBool |\n             ty::TyChar |\n@@ -393,13 +391,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             ty::TyFnPtr(_) |\n             ty::TyNever |\n             ty::TyFnDef(..) |\n+            ty::TyGeneratorWitness(..) |\n             ty::TyDynamic(..) |\n             ty::TyForeign(..) => {\n                 bug!(\"TyLayout::field_type({:?}): not applicable\", layout)\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 assert!(i < 2);\n \n@@ -437,7 +436,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 substs.field_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::TyTuple(tys, _) => tys[i],\n+            ty::TyTuple(tys) => tys[i],\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n@@ -453,7 +452,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     }\n \n                     // Discriminant field for enums (where applicable).\n-                    Variants::Tagged { ref discr, .. } |\n+                    Variants::Tagged { tag: ref discr, .. } |\n                     Variants::NicheFilling { niche: ref discr, .. } => {\n                         assert_eq!(i, 0);\n                         return Ok(discr.value.to_ty(tcx))\n@@ -509,7 +508,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = self.into_ptr(val)?;\n-        self.memory.check_align(ptr, align.abi(), None)?;\n+        self.memory.check_align(ptr, align)?;\n \n         // Recurse\n         let pointee_place = self.val_to_place(val, pointee_ty)?;\n@@ -558,6 +557,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             TyAdt(adt, _) if adt.is_box() => true,\n             TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) |\n             TyDynamic(..) | TyGenerator(..) | TyForeign(_) => false,\n+            TyGeneratorWitness(..) => unreachable!(\"TyGeneratorWitness in validate\"),\n             TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => {\n                 bug!(\"I got an incomplete/unnormalized type for validation\")\n             }\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             // Tracking the same state for locals not backed by memory would just duplicate too\n             // much machinery.\n             // FIXME: We ignore alignment.\n-            let (ptr, extra) = self.force_allocation(query.place.1)?.to_ptr_extra_aligned();\n+            let (ptr, _, extra) = self.force_allocation(query.place.1)?.to_ptr_align_extra();\n             // Determine the size\n             // FIXME: Can we reuse size_and_align_of_dst for Places?\n             let layout = self.layout_of(query.ty)?;\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             }\n         }\n \n-        let res = do catch {\n+        let res: EvalResult<'tcx> = do catch {\n             match query.ty.sty {\n                 TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n                     if mode.acquiring() {\n@@ -645,23 +645,17 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                         // FIXME: It would be great to rule out Undef here, but that doesn't actually work.\n                         // Passing around undef data is a thing that e.g. Vec::extend_with does.\n                     }\n-                    Ok(())\n                 }\n                 TyBool | TyFloat(_) | TyChar => {\n                     if mode.acquiring() {\n                         let val = self.read_place(query.place.1)?;\n-                        let val = self.value_to_primval(ValTy { value: val, ty: query.ty })?;\n+                        let val = self.value_to_scalar(ValTy { value: val, ty: query.ty })?;\n                         val.to_bytes()?;\n                         // TODO: Check if these are valid bool/float/codepoint/UTF-8\n                     }\n-                    Ok(())\n                 }\n-                TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n-                TyRef(region,\n-                    ty::TypeAndMut {\n-                        ty: pointee_ty,\n-                        mutbl,\n-                    }) => {\n+                TyNever => return err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n+                TyRef(region, pointee_ty, mutbl) => {\n                     let val = self.read_place(query.place.1)?;\n                     // Sharing restricts our context\n                     if mutbl == MutImmutable {\n@@ -670,36 +664,32 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n                     // we record the region of this borrow to the context.\n                     if query.re == None {\n-                        match *region {\n-                            ReScope(scope) => query.re = Some(scope),\n-                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                            // this functions' Subst will be erased.\n-                            _ => {}\n+                        if let ReScope(scope) = *region {\n+                            query.re = Some(scope);\n                         }\n+                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n                     }\n-                    self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)\n+                    self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)?;\n                 }\n                 TyAdt(adt, _) if adt.is_box() => {\n                     let val = self.read_place(query.place.1)?;\n-                    self.validate_ptr(val, query.place.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n+                    self.validate_ptr(val, query.place.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)?;\n                 }\n                 TyFnPtr(_sig) => {\n                     let ptr = self.read_place(query.place.1)?;\n                     let ptr = self.into_ptr(ptr)?.to_ptr()?;\n                     self.memory.get_fn(ptr)?;\n                     // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                    Ok(())\n                 }\n                 TyFnDef(..) => {\n                     // This is a zero-sized type with all relevant data sitting in the type.\n                     // There is nothing to validate.\n-                    Ok(())\n                 }\n \n                 // Compound types\n                 TyStr => {\n                     // TODO: Validate strings\n-                    Ok(())\n                 }\n                 TySlice(elem_ty) => {\n                     let len = match query.place.1 {\n@@ -722,10 +712,19 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                             mode,\n                         )?;\n                     }\n-                    Ok(())\n                 }\n                 TyArray(elem_ty, len) => {\n-                    let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                    let len = match len.val {\n+                        ConstValue::Unevaluated(def_id, substs) => {\n+                            self.tcx.const_eval(self.tcx.param_env(def_id).and(GlobalId {\n+                                instance: Instance::new(def_id, substs),\n+                                promoted: None,\n+                            }))\n+                                .map_err(|_err|EvalErrorKind::MachineError(\"<already reported>\".to_string()))?\n+                        }\n+                        _ => len,\n+                    };\n+                    let len = len.unwrap_usize(self.tcx.tcx);\n                     for i in 0..len {\n                         let inner_place = self.place_index(query.place.1, query.ty, i as u64)?;\n                         self.validate(\n@@ -737,7 +736,6 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                             mode,\n                         )?;\n                     }\n-                    Ok(())\n                 }\n                 TyDynamic(_data, _region) => {\n                     // Check that this is a valid vtable\n@@ -756,10 +754,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n                     // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n                     // their return values.  So, it doesn't seem like there's anything else to do.\n-                    Ok(())\n                 }\n                 TyAdt(adt, _) => {\n-                    if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n+                    if Some(adt.did) == self.tcx.tcx.lang_items().unsafe_cell_type() &&\n                         query.mutbl == MutImmutable\n                     {\n                         // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n@@ -768,19 +765,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n                     match adt.adt_kind() {\n                         AdtKind::Enum => {\n-                            let discr = self.read_discriminant_value(query.place.1, query.ty)?;\n-\n-                            // Get variant index for discriminant\n-                            let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n-                                variant_discr.to_u128_unchecked() == discr\n-                            });\n-                            let variant_idx = match variant_idx {\n-                                Some(val) => val,\n-                                None => return err!(InvalidDiscriminant),\n-                            };\n+                            let variant_idx = self.read_discriminant_as_variant_index(query.place.1, query.ty)?;\n                             let variant = &adt.variants[variant_idx];\n \n-                            if variant.fields.len() > 0 {\n+                            if !variant.fields.is_empty() {\n                                 // Downcast to this variant, if needed\n                                 let place = if adt.is_enum() {\n                                     (\n@@ -799,19 +787,17 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                                 self.validate_fields(\n                                     ValidationQuery { place, ..query },\n                                     mode,\n-                                )\n+                                )?;\n                             } else {\n                                 // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n-                                Ok(())\n                             }\n                         }\n                         AdtKind::Struct => {\n-                            self.validate_fields(query, mode)\n+                            self.validate_fields(query, mode)?;\n                         }\n                         AdtKind::Union => {\n                             // No guarantees are provided for union types.\n                             // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n-                            Ok(())\n                         }\n                     }\n                 }\n@@ -820,10 +806,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     // TODO: Check if the signature matches for `TyClosure`\n                     // (should be the same check as what terminator/mod.rs already does on call?).\n                     // Is there other things we can/should check?  Like vtable pointers?\n-                    self.validate_fields(query, mode)\n+                    self.validate_fields(query, mode)?;\n                 }\n                 // FIXME: generators aren't validated right now\n-                TyGenerator(..) => Ok(()),\n+                TyGenerator(..) => {},\n                 _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n             }\n         };\n@@ -835,7 +821,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             // release if it is.  But of course that can't even always be statically determined.\n             Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n                 if mode == ValidationMode::ReleaseUntil(None) => {\n-                return Ok(());\n+                Ok(())\n             }\n             res => res,\n         }", "previous_filename": "miri/validation.rs"}, {"sha": "4b89f0ac70c79a6b7cc793c410280758a48257e5", "filename": "tests/compile-fail-fullmir/deallocate-bad-alignment.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-alignment.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,15 @@\n+#![feature(alloc, allocator_api)]\n+\n+extern crate alloc;\n+\n+use alloc::alloc::Global;\n+use std::alloc::*;\n+\n+// error-pattern: incorrect alloc info: expected size 1 and align 2, got size 1 and align 1\n+\n+fn main() {\n+    unsafe {\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Global.dealloc(x, Layout::from_size_align_unchecked(1, 2));\n+    }\n+}"}, {"sha": "3a74245816c469afdee9f172fd699e23a5934fd3", "filename": "tests/compile-fail-fullmir/deallocate-bad-size.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fdeallocate-bad-size.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,15 @@\n+#![feature(alloc, allocator_api)]\n+\n+extern crate alloc;\n+\n+use alloc::alloc::Global;\n+use std::alloc::*;\n+\n+// error-pattern: incorrect alloc info: expected size 2 and align 1, got size 1 and align 1\n+\n+fn main() {\n+    unsafe {\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Global.dealloc(x, Layout::from_size_align_unchecked(2, 1));\n+    }\n+}"}, {"sha": "613edf3c6af95d81768c7e9ee0d269a5ee464e4e", "filename": "tests/compile-fail-fullmir/deallocate-twice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fdeallocate-twice.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,16 @@\n+#![feature(alloc, allocator_api)]\n+\n+extern crate alloc;\n+\n+use alloc::alloc::Global;\n+use std::alloc::*;\n+\n+// error-pattern: tried to deallocate dangling pointer\n+\n+fn main() {\n+    unsafe {\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Global.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n+        Global.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n+    }\n+}"}, {"sha": "8dce7e578626403647b5764d26387798a15420b4", "filename": "tests/compile-fail-fullmir/out_of_bounds_ptr_1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "tests/compile-fail/out_of_bounds_ptr_1.rs"}, {"sha": "e19a616a191651db51acc1fabce20565261fb500", "filename": "tests/compile-fail-fullmir/out_of_bounds_ptr_2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: overflowing math\n+// error-pattern: attempt to add with overflow\n fn main() {\n     let v = [0i8; 4];\n     let x = &v as *const i8;", "previous_filename": "tests/compile-fail/out_of_bounds_ptr_2.rs"}, {"sha": "32ab2daebf0d0443b5aab4572cfa2e5892b1b8d5", "filename": "tests/compile-fail-fullmir/ptr_offset_overflow.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fptr_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fptr_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fptr_offset_overflow.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,4 @@\n-//error-pattern: overflowing math\n+//error-pattern: attempt to add with overflow\n fn main() {\n     let v = [1i8, 2];\n     let x = &v[1] as *const i8;", "previous_filename": "tests/compile-fail/ptr_offset_overflow.rs"}, {"sha": "f85b651e857304a41e774244b288fbd2a98e6c74", "filename": "tests/compile-fail-fullmir/reallocate-bad-size.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Freallocate-bad-size.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,15 @@\n+#![feature(alloc, allocator_api)]\n+\n+extern crate alloc;\n+\n+use alloc::alloc::Global;\n+use std::alloc::*;\n+\n+// error-pattern: incorrect alloc info: expected size 2 and align 1, got size 1 and align 1\n+\n+fn main() {\n+    unsafe {\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        let _y = Global.realloc(x, Layout::from_size_align_unchecked(2, 1), 1).unwrap();\n+    }\n+}"}, {"sha": "a44ccf4c49cd879650243520effc32bd56bae6c9", "filename": "tests/compile-fail-fullmir/reallocate-change-alloc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Freallocate-change-alloc.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,15 @@\n+#![feature(alloc, allocator_api)]\n+\n+extern crate alloc;\n+\n+use alloc::alloc::Global;\n+use std::alloc::*;\n+\n+fn main() {\n+    unsafe {\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        let _y = Global.realloc(x, Layout::from_size_align_unchecked(1, 1), 1).unwrap();\n+        let _z = *(x.as_ptr() as *mut u8); //~ ERROR constant evaluation error\n+        //~^ NOTE dangling pointer was dereferenced\n+    }\n+}"}, {"sha": "6dfb7fe2b9663b6cc637e58514ff8a079d06c37c", "filename": "tests/compile-fail-fullmir/reallocate-dangling.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Freallocate-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Freallocate-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Freallocate-dangling.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,16 @@\n+#![feature(alloc, allocator_api)]\n+\n+extern crate alloc;\n+\n+use alloc::alloc::Global;\n+use std::alloc::*;\n+\n+// error-pattern: dangling pointer was dereferenced\n+\n+fn main() {\n+    unsafe {\n+        let x = Global.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n+        Global.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n+        Global.realloc(x, Layout::from_size_align_unchecked(1, 1), 1).unwrap();\n+    }\n+}"}, {"sha": "96006c884e5806b085aafc46e7fff5691108149b", "filename": "tests/compile-fail-fullmir/stack_free.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstack_free.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "tests/compile-fail/stack_free.rs"}, {"sha": "71161f5d6da0036360ac4d590f6b11f14d7b486b", "filename": "tests/compile-fail/alignment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Falignment.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -5,7 +5,8 @@ fn main() {\n     let x_ptr: *mut u8 = &mut x[0];\n     let y_ptr = x_ptr as *mut u64;\n     unsafe {\n-        *y_ptr = 42; //~ ERROR tried to access memory with alignment 1, but alignment\n+        *y_ptr = 42; //~ ERROR constant evaluation error\n+        //~^ NOTE tried to access memory with alignment 1, but alignment\n     }\n     panic!(\"unreachable in miri\");\n }"}, {"sha": "d9eec480cd0c613a1df6e309619526d4c37f1afc", "filename": "tests/compile-fail/assume.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fassume.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fassume.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fassume.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -5,6 +5,7 @@ fn main() {\n     unsafe {\n         std::intrinsics::assume(x < 10);\n         std::intrinsics::assume(x > 1);\n-        std::intrinsics::assume(x > 42); //~ ERROR: `assume` argument was false\n+        std::intrinsics::assume(x > 42); //~ ERROR constant evaluation error\n+    //~^ NOTE `assume` argument was false\n     }\n }"}, {"sha": "c8cbc9a9184163361d933f05d563aa72ba30566d", "filename": "tests/compile-fail/bitop-beyond-alignment.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -28,10 +28,11 @@ fn mk_rec() -> Rec {\n fn is_u64_aligned(u: &Tag<u64>) -> bool {\n     let p: usize = unsafe { mem::transmute(u) };\n     let u64_align = std::mem::align_of::<u64>();\n-    return (p & (u64_align + 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    return (p & (u64_align + 1)) == 0; //~ ERROR constant evaluation error\n+    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n }\n \n pub fn main() {\n     let x = mk_rec();\n-    assert!(is_u64_aligned(&x.t));\n+    assert!(is_u64_aligned(&x.t)); //~ NOTE inside call to `is_u64_aligned\n }"}, {"sha": "2a317f579f5e035ca229ef28a9b1213979f2cff4", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -7,5 +7,6 @@ fn main() {\n         std::mem::transmute::<&usize, &fn(i32)>(&b)\n     };\n \n-    (*g)(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n+    (*g)(42) //~ ERROR constant evaluation error\n+    //~^ NOTE a memory access tried to interpret some bytes as a pointer\n }"}, {"sha": "0a8f5ef752a6d48fe1b555a38e1958dd3c0c7c95", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -5,5 +5,6 @@ fn main() {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR tried to call a function with sig fn() through a function pointer of type fn(i32)\n+    g(42) //~ ERROR constant evaluation error\n+    //~^ NOTE tried to call a function with sig fn() through a function pointer of type fn(i32)\n }"}, {"sha": "cb80521c60eeb8cbc88c9d19622382914b38dd3d", "filename": "tests/compile-fail/cast_fn_ptr2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -5,5 +5,6 @@ fn main() {\n         std::mem::transmute::<fn((i32,i32)), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n+    g(42) //~ ERROR constant evaluation error\n+    //~^ NOTE tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n }"}, {"sha": "29d16e9a4259a7e14d0c35ed3d68701ad4477e78", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -6,5 +6,6 @@ fn main() {\n         std::mem::transmute::<usize, fn(i32)>(42)\n     };\n \n-    g(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n+    g(42) //~ ERROR constant evaluation error\n+    //~^ NOTE a memory access tried to interpret some bytes as a pointer\n }"}, {"sha": "18fbc61b6d07090b800f1cee18acf372374420f6", "filename": "tests/compile-fail/copy_nonoverlapping.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(core_intrinsics)]\n \n-use std::intrinsics::*;\n-\n //error-pattern: copy_nonoverlapping called on overlapping ranges\n \n fn main() {"}, {"sha": "4e2ccd0ac508a8841bfdf2edf9911e1d7cfde93a", "filename": "tests/compile-fail/ctlz_nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fctlz_nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fctlz_nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fctlz_nonzero.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -10,6 +10,6 @@ pub fn main() {\n     unsafe {\n         use rusti::*;\n \n-        ctlz_nonzero(0u8); //~ ERROR: ctlz_nonzero called on 0\n+        ctlz_nonzero(0u8); //~ ERROR constant evaluation error: ctlz_nonzero called on 0\n     }\n }"}, {"sha": "50b8df61998272641d0e9bc60117894a41394c22", "filename": "tests/compile-fail/cttz_nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcttz_nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fcttz_nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcttz_nonzero.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -10,6 +10,6 @@ pub fn main() {\n     unsafe {\n         use rusti::*;\n \n-        cttz_nonzero(0u8); //~ ERROR: cttz_nonzero called on 0\n+        cttz_nonzero(0u8); //~ ERROR constant evaluation error: cttz_nonzero called on 0\n     }\n }"}, {"sha": "434f5c780b46f0c00897109f93c6c71391750b0e", "filename": "tests/compile-fail/dangling_pointer_deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fdangling_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fdangling_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointer_deref.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -3,6 +3,7 @@ fn main() {\n         let b = Box::new(42);\n         &*b as *const i32\n     };\n-    let x = unsafe { *p }; //~ ERROR: dangling pointer was dereferenced\n+    let x = unsafe { *p }; //~ ERROR constant evaluation error\n+    //~^ NOTE dangling pointer was dereferenced\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "b64740de81f4d0c79e8a13358fbf69ed15bf4cba", "filename": "tests/compile-fail/deallocate-bad-alignment.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,15 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: incorrect alloc info: expected size 1 and align 2, got size 1 and align 1\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 2));\n-    }\n-}"}, {"sha": "f5b82f65d2af326cb88660891c960393115df031", "filename": "tests/compile-fail/deallocate-bad-size.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,15 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: incorrect alloc info: expected size 2 and align 1, got size 1 and align 1\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(2, 1));\n-    }\n-}"}, {"sha": "e11df0eb4147d842a69617bf74405b4331b4fd77", "filename": "tests/compile-fail/deallocate-twice.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-twice.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate dangling pointer\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-    }\n-}"}, {"sha": "1b36c77bd32ab86534bf1e3938df207a8cdd3c94", "filename": "tests/compile-fail/deref_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fderef_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fderef_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fderef_fn_ptr.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -2,7 +2,7 @@ fn f() {}\n \n fn main() {\n     let x: i32 = unsafe {\n-        *std::mem::transmute::<fn(), *const i32>(f) //~ ERROR: tried to dereference a function pointer\n+        *std::mem::transmute::<fn(), *const i32>(f) //~ ERROR constant evaluation error: tried to dereference a function pointer\n     };\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "94145c2cf32f37c7b0d5f8084a56bcca7e731719", "filename": "tests/compile-fail/div-by-zero-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fdiv-by-zero-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fdiv-by-zero-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdiv-by-zero-2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -11,5 +11,6 @@\n #![allow(const_err)]\n \n fn main() {\n-    let _n = 1 / 0; //~ ERROR: DivisionByZero\n+    let _n = 1 / 0; //~ ERROR constant evaluation error\n+    //~^ NOTE attempt to divide by zero\n }"}, {"sha": "bcde13d13ee773b49adf26a226e8b5d2f4cc8cf5", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -7,6 +7,7 @@ fn main() {\n     let x = box 42;\n     unsafe {\n         let f = std::mem::transmute::<Box<i32>, fn()>(x);\n-        f() //~ ERROR: tried to treat a memory pointer as a function pointer\n+        f() //~ ERROR constant evaluation error\n+        //~^ NOTE tried to treat a memory pointer as a function pointer\n     }\n }"}, {"sha": "0c0590e375bbca9129937d094b49f1a0afa474fe", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -10,5 +10,6 @@ fn main() {\n     let y : *mut u8 = unsafe { mem::transmute(x) };\n     let y = y.wrapping_offset(1);\n     let x : fn() = unsafe { mem::transmute(y) };\n-    x(); //~ ERROR: tried to use a function pointer after offsetting it\n+    x(); //~ ERROR constant evaluation error\n+    //~^ NOTE tried to use a function pointer after offsetting it\n }"}, {"sha": "1aa5d9bf77bcc603cfebfafb187e9b9eb6456408", "filename": "tests/compile-fail/invalid_bool.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_bool.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n-    let b = unsafe { std::mem::transmute::<u8, bool>(2) }; //~ ERROR: invalid boolean value read\n-    if b { unreachable!() } else { unreachable!() }\n+    let b = unsafe { std::mem::transmute::<u8, bool>(2) };\n+    if b { unreachable!() } else { unreachable!() } //~ ERROR constant evaluation error\n+    //~^ NOTE invalid boolean value read\n }"}, {"sha": "760b6563d27cc412b22f9f6c1d821a0626be27dd", "filename": "tests/compile-fail/invalid_enum_discriminant.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -9,9 +9,10 @@ pub enum Foo {\n fn main() {\n     let f = unsafe { std::mem::transmute::<i32, Foo>(42) };\n     match f {\n-        Foo::A => {}, //~ ERROR invalid enum discriminant value read\n+        Foo::A => {},\n         Foo::B => {},\n         Foo::C => {},\n         Foo::D => {},\n     }\n-}\n+} //~ ERROR constant evaluation error\n+//~^ NOTE entered unreachable code"}, {"sha": "52f33b58e6fb6fb907afce1cb043abaad7f0e537", "filename": "tests/compile-fail/match_char.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmatch_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmatch_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_char.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,6 +1,9 @@\n+// ignore-test FIXME: we are not checking these things on match any more?\n+\n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());\n-    match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ERROR tried to interpret an invalid 32-bit value as a char: 4294967295\n+    match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR constant evaluation error\n+        //~^ NOTE tried to interpret an invalid 32-bit value as a char: 4294967295\n         'a' => {},\n         'b' => {},\n         _ => {},"}, {"sha": "c03cf50eb27f613f6100a24ef02163c61a8cfe70", "filename": "tests/compile-fail/memleak.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,4 @@\n+// ignore-test FIXME: leak detection is disabled\n //error-pattern: the evaluated program leaked memory\n \n fn main() {"}, {"sha": "da3a58118a2a5671f295b67f0af108889988c70a", "filename": "tests/compile-fail/memleak_rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak_rc.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,4 @@\n+// ignore-test FIXME: leak detection is disabled\n //error-pattern: the evaluated program leaked memory\n \n use std::rc::Rc;"}, {"sha": "c10657ae75a77646902195e7ca5e655a0ed05a1c", "filename": "tests/compile-fail/modifying_constants.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,6 +1,7 @@\n fn main() {\n     let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee\n     let y = unsafe { &mut *(x as *const i32 as *mut i32) };\n-    *y = 42; //~ ERROR tried to modify constant memory\n+    *y = 42;  //~ ERROR constant evaluation error\n+    //~^ NOTE tried to modify constant memory\n     assert_eq!(*x, 42);\n }"}, {"sha": "fd76ecbd1503e564eef38733dfa7d3e8ec9cefc0", "filename": "tests/compile-fail/never_say_never.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnever_say_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnever_say_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_say_never.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -7,7 +7,8 @@\n fn main() {\n     let y = &5;\n     let x: ! = unsafe {\n-        *(y as *const _ as *const !) //~ ERROR entered unreachable code\n+        *(y as *const _ as *const !)  //~ ERROR constant evaluation error\n+        //~^ NOTE entered unreachable code\n     };\n     f(x)\n }"}, {"sha": "7652cdfdd3df55993d4c627972cfceb216c546ec", "filename": "tests/compile-fail/never_transmute_humans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_humans.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -9,7 +9,8 @@ struct Human;\n \n fn main() {\n     let x: ! = unsafe {\n-        std::mem::transmute::<Human, !>(Human) //~ ERROR entered unreachable code\n+        std::mem::transmute::<Human, !>(Human) //~ ERROR constant evaluation error\n+        //^~ NOTE entered unreachable code\n     };\n     f(x)\n }"}, {"sha": "9329cd365994ea92a89f6f07038d3d8be400bfc4", "filename": "tests/compile-fail/never_transmute_void.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_void.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -8,12 +8,13 @@\n enum Void {}\n \n fn f(v: Void) -> ! {\n-    match v {} //~ ERROR entered unreachable code\n+    match v {} //~ ERROR constant evaluation error\n+    //~^ NOTE entered unreachable code\n }\n \n fn main() {\n     let v: Void = unsafe {\n         std::mem::transmute::<(), Void>(())\n     };\n-    f(v);\n+    f(v); //~ inside call to `f`\n }"}, {"sha": "08ea63f58ff5974bb296a96288fe6452daa4531b", "filename": "tests/compile-fail/null_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: invalid use of NULL pointer\n+    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR constant evaluation error: invalid use of NULL pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "d4aebb912ee1707ef795f555cfa88497b1ff82e9", "filename": "tests/compile-fail/oom.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,7 +0,0 @@\n-#![feature(custom_attribute, attr_literals)]\n-#![miri(memory_size=4095)]\n-\n-fn main() {\n-    let _x = [42; 1024];\n-    //~^ERROR tried to allocate 4096 more bytes, but only\n-}"}, {"sha": "6c973bcf4016ddfba9b859b4ceaacaa35244c135", "filename": "tests/compile-fail/oom2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,14 +0,0 @@\n-// Validation forces more allocation; disable it.\n-// compile-flags: -Zmir-emit-validate=0\n-#![feature(box_syntax, custom_attribute, attr_literals)]\n-#![miri(memory_size=1024)]\n-\n-// On 64bit platforms, the allocator needs 32 bytes allocated to pass a return value, so that's the error we see.\n-// On 32bit platforms, it's just 16 bytes.\n-// error-pattern: tried to allocate\n-\n-fn main() {\n-    loop {\n-        ::std::mem::forget(box 42);\n-    }\n-}"}, {"sha": "3ccdb365feebc737b11d81ba660b7f6edd8c1f92", "filename": "tests/compile-fail/out_of_bounds_read.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR: which has size 2\n+    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR constant evaluation error\n+    //~^ NOTE which has size 2\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "811ba7d4b26cfe37c1018605c8b4f9d83aca9323", "filename": "tests/compile-fail/out_of_bounds_read2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR: memory access at offset 6, outside bounds of allocation\n+    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR constant evaluation error\n+    //~^ NOTE memory access at offset 6, outside bounds of allocation\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "825a82226634910216c007766e454901d8ebb3d7", "filename": "tests/compile-fail/overflowing-lsh-neg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -12,5 +12,6 @@\n #![allow(const_err)]\n \n fn main() {\n-    let _n = 2i64 << -1; //~ Overflow(Shl)\n+    let _n = 2i64 << -1; //~ ERROR constant evaluation error\n+    //~^ NOTE attempt to shift left with overflow\n }"}, {"sha": "cf107a76ae29dba95bab4a82c1d28bc4e34dd053", "filename": "tests/compile-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -12,5 +12,6 @@\n \n fn main() {\n     // Make sure we catch overflows that would be hidden by first casting the RHS to u32\n-    let _n = 1i64 >> (u32::max_value() as i64 + 1); //~ Overflow(Shr)\n+    let _n = 1i64 >> (u32::max_value() as i64 + 1); //~ ERROR constant evaluation error\n+    //~^ NOTE attempt to shift right with overflow\n }"}, {"sha": "ea53d7e730925e94d2e77fc1fbcab3a223421edd", "filename": "tests/compile-fail/overflowing-rsh.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverflowing-rsh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverflowing-rsh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-rsh.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -11,5 +11,6 @@\n #![allow(exceeding_bitshifts)]\n \n fn main() {\n-    let _n = 1i64 >> 64; //~ Overflow(Shr)\n+    let _n = 1i64 >> 64; //~ ERROR constant evaluation error\n+    //~^ NOTE attempt to shift right with overflow\n }"}, {"sha": "7c38c05746983d07d72a9b715d55684392f9403b", "filename": "tests/compile-fail/overwriting_part_of_relocation_makes_the_rest_undefined.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverwriting_part_of_relocation_makes_the_rest_undefined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Foverwriting_part_of_relocation_makes_the_rest_undefined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverwriting_part_of_relocation_makes_the_rest_undefined.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -6,6 +6,7 @@ fn main() {\n         // \"attempted to interpret some raw bytes as a pointer address\" instead of\n         // \"attempted to read undefined bytes\"\n     }\n-    let x = *p; //~ ERROR: attempted to read undefined bytes\n+    let x = *p; //~ ERROR constant evaluation error\n+    //~^ NOTE attempted to read undefined bytes\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "1f9e8f6e1d0b0b3af0eee73d145713785e6c8fd0", "filename": "tests/compile-fail/panic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,4 @@\n+//ignore-windows\n // FIXME: Something in panic handling fails validation with full-MIR\n // compile-flags: -Zmir-emit-validate=0\n //error-pattern: the evaluated program panicked"}, {"sha": "b3aaec759ce026d7bcfa7859a4093a9b14374903", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -3,5 +3,6 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const usize;\n     let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes % 432; //~ ERROR: tried to access part of a pointer value as raw bytes\n+    let _ = ptr_bytes % 432; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access part of a pointer value as raw bytes\n }"}, {"sha": "c8a1a2e10f5004fa8200f65b0bd544c29b067089", "filename": "tests/compile-fail/pointer_byte_read_2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -3,5 +3,6 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const u8;\n     // the deref fails, because we are reading only a part of the pointer\n-    let _ = unsafe { *z }; //~ ERROR: tried to access part of a pointer value as raw bytes\n+    let _ = unsafe { *z }; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access part of a pointer value as raw bytes\n }"}, {"sha": "89cf357e201cff0675f1bb49475202040e48b26e", "filename": "tests/compile-fail/pointers_to_different_allocations_are_unorderable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,7 +1,8 @@\n fn main() {\n     let x: *const u8 = &1;\n     let y: *const u8 = &2;\n-    if x < y { //~ ERROR: attempted to do invalid arithmetic on pointers\n+    if x < y { //~ ERROR constant evaluation error\n+    //~^ NOTE attempted to do invalid arithmetic on pointers\n         unreachable!()\n     }\n }"}, {"sha": "ecd47a186efb14eb62dc530fb754a74a913ca509", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -2,6 +2,7 @@ fn main() {\n     let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let one = bytes.as_ptr().wrapping_offset(1);\n     let three = bytes.as_ptr().wrapping_offset(3);\n-    let res = (one as usize) | (three as usize); //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    let res = (one as usize) | (three as usize); //~ ERROR constant evaluation error\n+    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n     println!(\"{}\", res);\n }"}, {"sha": "11243921bfd48e5f8f615192f071a4e8c1984475", "filename": "tests/compile-fail/ptr_int_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fptr_int_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fptr_int_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_int_cast.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     let x = &1;\n     // Casting down to u8 and back up to a pointer loses too much precision; this must not work.\n     let x = x as *const i32;\n-    let x = x as u8; //~ ERROR: a raw memory access tried to access part of a pointer value as raw bytes\n+    let x = x as u8; //~ ERROR constant evaluation error\n+    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n     let x = x as *const i32;\n     let _ = unsafe { *x };\n }"}, {"sha": "3ea693a3f0fbbf63dded626048c7635633942b0b", "filename": "tests/compile-fail/reading_half_a_pointer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Freading_half_a_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Freading_half_a_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freading_half_a_pointer.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -24,6 +24,7 @@ fn main() {\n     // starts 1 byte to the right, so using it would actually be wrong!\n     let d_alias = &mut w.data as *mut _ as *mut *const u8;\n     unsafe {\n-        let _x = *d_alias; //~ ERROR: tried to access part of a pointer value as raw bytes\n+        let _x = *d_alias; //~ ERROR constant evaluation error\n+        //~^ NOTE tried to access part of a pointer value as raw bytes\n     }\n }"}, {"sha": "fae8246c5d29c2bbec346a2200e6180a20df7354", "filename": "tests/compile-fail/reallocate-bad-alignment-2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-bad-alignment-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-bad-alignment-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-alignment-2.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: incorrect alloc info: expected size 1 and align 2, got size 1 and align 1\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        // Try realloc with a too big alignment.\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 2), Layout::from_size_align_unchecked(1, 1)).unwrap();\n-    }\n-}"}, {"sha": "6a928de07eec3dfe908e7d0332d3d70780354bdb", "filename": "tests/compile-fail/reallocate-bad-alignment.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: incorrect alloc info: expected size 1 and align 1, got size 1 and align 2\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 2)).unwrap();\n-        // Try realloc with a too small alignment.\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 2)).unwrap();\n-    }\n-}"}, {"sha": "d57c610d9337f806ead81c256b61334f80034d28", "filename": "tests/compile-fail/reallocate-bad-size.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-size.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,15 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: incorrect alloc info: expected size 2 and align 1, got size 1 and align 1\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(2, 1), Layout::from_size_align_unchecked(1, 1)).unwrap();\n-    }\n-}"}, {"sha": "290c966a2bc8a8acb3b3e440c5286a713444a554", "filename": "tests/compile-fail/reallocate-change-alloc.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-change-alloc.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,14 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        let _z = *x; //~ ERROR: dangling pointer was dereferenced\n-    }\n-}"}, {"sha": "6225879a5a2a0faff4d9cdc4280997f1c3c05844", "filename": "tests/compile-fail/reallocate-dangling.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Freallocate-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-dangling.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: dangling pointer was dereferenced\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-        Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 1));\n-    }\n-}"}, {"sha": "946a6b89a777a25e213b0b4f7292ba68cfde4137", "filename": "tests/compile-fail/reference_to_packed.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freference_to_packed.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -15,5 +15,6 @@ fn main() {\n         y: 99,\n     };\n     let p = unsafe { &foo.x };\n-    let i = *p; //~ ERROR tried to access memory with alignment 1, but alignment 4 is required\n+    let i = *p; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access memory with alignment 1, but alignment 4 is required\n }"}, {"sha": "abe89e233e7cd824849d93b527c3a176949aa8c4", "filename": "tests/compile-fail/repeat.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let data: [u8; std::usize::MAX] = [42; std::usize::MAX];\n-    //~^ ERROR: rustc layout computation failed: SizeOverflow([u8;\n-    assert_eq!(data.len(), 1024);\n-}"}, {"sha": "61aa855a798f8eca8d0f07efc0a2ef55ae9a3f22", "filename": "tests/compile-fail/repeat2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Frepeat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Frepeat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat2.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let data: [u8; 1024*1024*1024] = [42; 1024*1024*1024];\n-    //~^ ERROR: tried to allocate\n-    assert_eq!(data.len(), 1024*1024*1024);\n-}"}, {"sha": "e28bcb37fb72d3637c52dadeca3b9ac057388f51", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,9 +1,11 @@\n+// ignore-test FIXME: we are not making these statics read-only any more?\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]\n fn main() {\n     unsafe {\n-        *std::mem::transmute::<&usize, &mut usize>(&X) = 6; //~ ERROR: tried to modify constant memory\n+        *std::mem::transmute::<&usize, &mut usize>(&X) = 6; //~ ERROR constant evaluation error\n+        //~^ NOTE tried to modify constant memory\n         assert_eq!(X, 6);\n     }\n }"}, {"sha": "2f702f09c8047e736ee5cf10dcd97e03be72567d", "filename": "tests/compile-fail/static_memory_modification2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -7,6 +7,7 @@ use std::mem::transmute;\n fn main() {\n     unsafe {\n         let s = \"this is a test\";\n-        transmute::<&[u8], &mut [u8]>(s.as_bytes())[4] = 42; //~ ERROR: tried to modify constant memory\n+        transmute::<&[u8], &mut [u8]>(s.as_bytes())[4] = 42; //~ ERROR constant evaluation error\n+        //~^ NOTE tried to modify constant memory\n     }\n }"}, {"sha": "37d8bfe02ceb2bc8be2d954c65063fad0f7eaa38", "filename": "tests/compile-fail/static_memory_modification3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -4,6 +4,7 @@ use std::mem::transmute;\n fn main() {\n     unsafe {\n         let bs = b\"this is a test\";\n-        transmute::<&[u8], &mut [u8]>(bs)[4] = 42; //~ ERROR: tried to modify constant memory\n+        transmute::<&[u8], &mut [u8]>(bs)[4] = 42; //~ ERROR constant evaluation error\n+        //~^ NOTE tried to modify constant memory\n     }\n }"}, {"sha": "edd4c31866910642e97e6813084c7c27240367ec", "filename": "tests/compile-fail/timeout.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Fcompile-fail%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftimeout.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,9 +0,0 @@\n-//error-pattern: reached the configured maximum execution time\n-#![feature(custom_attribute, attr_literals)]\n-#![miri(step_limit=1000)]\n-\n-fn main() {\n-    for i in 0..1000000 {\n-        assert!(i < 1000);\n-    }\n-}"}, {"sha": "9509bb60e8b112126f7b820684b7c7bbbc6131a1", "filename": "tests/compile-fail/transmute-pair-undef.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ftransmute-pair-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ftransmute-pair-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute-pair-undef.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -16,5 +16,6 @@ fn main() {\n         assert_eq!(byte, 0);\n     }\n     let v = unsafe { *z.offset(first_undef) };\n-    if v == 0 {} //~ ERROR attempted to read undefined bytes\n+    if v == 0 {} //~ ERROR constant evaluation error\n+    //~^ NOTE attempted to read undefined bytes\n }"}, {"sha": "dad5f4df2da3cd467454eca295ec6fee2249ef03", "filename": "tests/compile-fail/transmute_fat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute_fat.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,6 +1,5 @@\n // This should fail even without validation\n // compile-flags: -Zmir-emit-validate=0\n-#![feature(i128_type)]\n \n fn main() {\n     #[cfg(target_pointer_width=\"64\")]\n@@ -11,5 +10,6 @@ fn main() {\n     let bad = unsafe {\n         std::mem::transmute::<&[u8], u64>(&[1u8])\n     };\n-    bad + 1; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    let _ = bad + 1; //~ ERROR constant evaluation error\n+    //~^ NOTE a raw memory access tried to access part of a pointer value as raw bytes\n }"}, {"sha": "e9e21a84294dc5795d8dc6f776b1e6d87ff8e53a", "filename": "tests/compile-fail/transmute_fat2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ftransmute_fat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Ftransmute_fat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute_fat2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,5 +1,3 @@\n-#![feature(i128_type)]\n-\n fn main() {\n     #[cfg(target_pointer_width=\"64\")]\n     let bad = unsafe {\n@@ -9,5 +7,6 @@ fn main() {\n     let bad = unsafe {\n         std::mem::transmute::<u64, &[u8]>(42)\n     };\n-    bad[0]; //~ ERROR index out of bounds: the len is 0 but the index is 0\n+    bad[0]; //~ ERROR constant evaluation error\n+    //~^ NOTE index out of bounds: the len is 0 but the index is 0\n }"}, {"sha": "f91def30d120582de6fa0e69b15d05b2e5586690", "filename": "tests/compile-fail/unaligned_ptr_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -2,5 +2,6 @@ fn main() {\n     let x = &2u16;\n     let x = x as *const _ as *const u32;\n     // This must fail because alignment is violated\n-    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment 4 is required\n+    let _x = unsafe { *x }; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access memory with alignment 2, but alignment 4 is required\n }"}, {"sha": "f87dab76ba30084d5de534a34c22aafb7582e5f7", "filename": "tests/compile-fail/unaligned_ptr_cast2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -3,5 +3,6 @@ fn main() {\n     let x = x as *const _ as *const *const u8;\n     // This must fail because alignment is violated.  Test specifically for loading pointers, which have special code\n     // in miri's memory.\n-    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment\n+    let _x = unsafe { *x }; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access memory with alignment 2, but alignment\n }"}, {"sha": "45016473c97528e060c20806f27c7d327ffb35e0", "filename": "tests/compile-fail/unaligned_ptr_cast_zst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -2,5 +2,6 @@ fn main() {\n     let x = &2u16;\n     let x = x as *const _ as *const [u32; 0];\n     // This must fail because alignment is violated.  Test specifically for loading ZST.\n-    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment 4 is required\n+    let _x = unsafe { *x }; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access memory with alignment 2, but alignment 4 is required\n }"}, {"sha": "24718bce7db96bb04147b4e13fe8a480dabcb43e", "filename": "tests/compile-fail/undefined_byte_read.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fundefined_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fundefined_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fundefined_byte_read.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -4,6 +4,7 @@\n fn main() {\n     let v: Vec<u8> = Vec::with_capacity(10);\n     let undef = unsafe { *v.get_unchecked(5) };\n-    let x = undef + 1; //~ ERROR: attempted to read undefined bytes\n+    let x = undef + 1; //~ ERROR: error\n+    //~^ NOTE attempted to read undefined bytes\n     panic!(\"this should never print: {}\", x);\n }", "previous_filename": "tests/compile-fail-fullmir/undefined_byte_read.rs"}, {"sha": "e812e13e702cadbfc5dd1dece7e0ba011b0720e2", "filename": "tests/compile-fail/validation_aliasing_mut1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "36ebcc2b4ac6fae57a657af0c9b9c1dfdeda47a3", "filename": "tests/compile-fail/validation_aliasing_mut2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "ad50fbd61b451f0d1a8d1cd05b24afe11a8eff8c", "filename": "tests/compile-fail/validation_aliasing_mut3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "a0f0a3cf9753a1abbb6fff23ded22eeb41f0e989", "filename": "tests/compile-fail/validation_aliasing_mut4.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "282e536ce9b738d7006f2a6f025b2edb1080eb45", "filename": "tests/compile-fail/validation_buggy_as_mut_slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_buggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_buggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_buggy_as_mut_slice.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n // For some reason, the error location is different when using fullmir"}, {"sha": "a750f1466f51b8cf431e084c191c87288f15a864", "filename": "tests/compile-fail/validation_buggy_split_at_mut.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "cb3e4b3c1a204249571a6010bf3bfee86b104913", "filename": "tests/compile-fail/validation_illegal_write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "2a0857659622f7ddb7a6736165052f2493d1814f", "filename": "tests/compile-fail/validation_lock_confusion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n // Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n #![allow(unused_variables)]\n use std::cell::RefCell;"}, {"sha": "14d6242860382d5781ada58d749ffe87a1b8a862", "filename": "tests/compile-fail/validation_pointer_smuggling.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n static mut PTR: *mut u8 = 0 as *mut _;"}, {"sha": "9061070ef67ebbed6aeb9dff7bd9b0740794e6ce", "filename": "tests/compile-fail/validation_recover1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover1.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n #[repr(u32)]"}, {"sha": "7a4a417ab1db993b640864d6911a92f9015d94c8", "filename": "tests/compile-fail/validation_recover2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover2.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "5cfc8aaa66b5f2cefa127b5dfe236a00e65b497b", "filename": "tests/compile-fail/validation_recover3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover3.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n \n mod safe {"}, {"sha": "939e93a264e8c03214903485b62c38c206353092", "filename": "tests/compile-fail/validation_undef.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fvalidation_undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_undef.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test validation_op is disabled\n+\n #![allow(unused_variables)]\n // error-pattern: attempted to read undefined bytes\n "}, {"sha": "4096cfb93e722cb25859cae874dc5d6396c5b7ae", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let p = 44 as *const i32;\n-    let x = unsafe { *p }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n+    let x = unsafe { *p }; //~ ERROR constant evaluation error\n+    //~^ NOTE a memory access tried to interpret some bytes as a pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "efb2dafd36fc58e5f50df098359e0f9edab855d4", "filename": "tests/compile-fail/zst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n     let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR: tried to access memory with alignment 1, but alignment 4 is required\n+    let _ = unsafe { *x }; //~ ERROR constant evaluation error\n+    //~^ NOTE tried to access memory with alignment 1, but alignment 4 is required\n }"}, {"sha": "896d1cae5969e921c448e4df4793508f852acc5c", "filename": "tests/compiletest.rs", "status": "modified", "additions": 68, "deletions": 58, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,6 +1,9 @@\n #![feature(slice_concat_ext)]\n \n extern crate compiletest_rs as compiletest;\n+extern crate colored;\n+\n+use colored::*;\n \n use std::slice::SliceConcatExt;\n use std::path::{PathBuf, Path};\n@@ -30,12 +33,26 @@ fn rustc_lib_path() -> PathBuf {\n     option_env!(\"RUSTC_LIB_PATH\").unwrap().into()\n }\n \n-fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: bool) {\n-    eprintln!(\n+fn have_fullmir() -> bool {\n+    // We assume we have full MIR when MIRI_SYSROOT is set or when we are in rustc\n+    std::env::var(\"MIRI_SYSROOT\").is_ok() || rustc_test_suite().is_some()\n+}\n+\n+fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir: bool) {\n+    if need_fullmir && !have_fullmir() {\n+        eprintln!(\"{}\", format!(\n+            \"## Skipping compile-fail tests in {} against miri for target {} due to missing mir\",\n+            path,\n+            target\n+        ).yellow().bold());\n+        return;\n+    }\n+\n+    eprintln!(\"{}\", format!(\n         \"## Running compile-fail tests in {} against miri for target {}\",\n         path,\n         target\n-    );\n+    ).green().bold());\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n     config.rustc_path = miri_path();\n@@ -44,52 +61,49 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: b\n         config.run_lib_path = rustc_lib_path();\n         config.compile_lib_path = rustc_lib_path();\n     }\n-    // if we are building as part of the rustc test suite, we already have fullmir for everything\n-    if fullmir && rustc_test_suite().is_none() {\n-        if host != target {\n-            // skip fullmir on nonhost\n-            return;\n-        }\n-        let sysroot = std::env::home_dir().unwrap()\n-            .join(\".xargo\")\n-            .join(\"HOST\");\n-        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-        config.src_base = PathBuf::from(path.to_string());\n-    } else {\n-        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-        config.src_base = PathBuf::from(path.to_string());\n-    }\n+    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n+    config.src_base = PathBuf::from(path.to_string());\n     flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     config.target_rustcflags = Some(flags.join(\" \"));\n     config.target = target.to_owned();\n+    config.host = host.to_owned();\n     compiletest::run_tests(&config);\n }\n \n-fn run_pass(path: &str) {\n-    eprintln!(\"## Running run-pass tests in {} against rustc\", path);\n+fn rustc_pass(sysroot: &Path, path: &str) {\n+    eprintln!(\"{}\", format!(\"## Running run-pass tests in {} against rustc\", path).green().bold());\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"run-pass\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n     if let Some(rustc_path) = rustc_test_suite() {\n         config.rustc_path = rustc_path;\n         config.run_lib_path = rustc_lib_path();\n         config.compile_lib_path = rustc_lib_path();\n-        config.target_rustcflags = Some(format!(\"-Dwarnings --sysroot {}\", get_sysroot().display()));\n+        config.target_rustcflags = Some(format!(\"-Dwarnings --sysroot {}\", sysroot.display()));\n     } else {\n         config.target_rustcflags = Some(\"-Dwarnings\".to_owned());\n     }\n     config.host_rustcflags = Some(\"-Dwarnings\".to_string());\n     compiletest::run_tests(&config);\n }\n \n-fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n+fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir: bool, opt: bool) {\n+    if need_fullmir && !have_fullmir() {\n+        eprintln!(\"{}\", format!(\n+            \"## Skipping run-pass tests in {} against miri for target {} due to missing mir\",\n+            path,\n+            target\n+        ).yellow().bold());\n+        return;\n+    }\n+\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n-    eprintln!(\n+    eprintln!(\"{}\", format!(\n         \"## Running run-pass tests in {} against miri for target {}{}\",\n         path,\n         target,\n         opt_str\n-    );\n+    ).green().bold());\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"ui\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n@@ -101,20 +115,9 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n         config.compile_lib_path = rustc_lib_path();\n     }\n     let mut flags = Vec::new();\n-    // Control miri logging. This is okay despite concurrent test execution as all tests\n-    // will set this env var to the same value.\n-    env::set_var(\"MIRI_LOG\", \"warn\");\n-    // if we are building as part of the rustc test suite, we already have fullmir for everything\n-    if fullmir && rustc_test_suite().is_none() {\n-        if host != target {\n-            // skip fullmir on nonhost\n-            return;\n-        }\n-        let sysroot = std::env::home_dir().unwrap()\n-            .join(\".xargo\")\n-            .join(\"HOST\");\n-\n-        flags.push(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n+    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n+    if have_fullmir() {\n+        flags.push(\"-Zmiri-start-fn\".to_owned());\n     }\n     if opt {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n@@ -123,6 +126,9 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n         // For now, only validate without optimizations.  Inlining breaks validation.\n         flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     }\n+    // Control miri logging. This is okay despite concurrent test execution as all tests\n+    // will set this env var to the same value.\n+    env::set_var(\"MIRI_LOG\", \"warn\");\n     config.target_rustcflags = Some(flags.join(\" \"));\n     compiletest::run_tests(&config);\n }\n@@ -179,35 +185,39 @@ fn run_pass_miri(opt: bool) {\n     let host = get_host();\n \n     for_all_targets(&sysroot, |target| {\n-        miri_pass(\"tests/run-pass\", &target, &host, false, opt);\n+        miri_pass(&sysroot, \"tests/run-pass\", &target, &host, false, opt);\n     });\n-    miri_pass(\"tests/run-pass-fullmir\", &host, &host, true, opt);\n+    miri_pass(&sysroot, \"tests/run-pass-fullmir\", &host, &host, true, opt);\n }\n \n-#[test]\n-fn run_pass_miri_noopt() {\n-    run_pass_miri(false);\n-}\n-\n-#[test]\n-#[ignore] // FIXME: Disabled for now, as the optimizer is pretty broken and crashes...\n-fn run_pass_miri_opt() {\n-    run_pass_miri(true);\n-}\n-\n-#[test]\n fn run_pass_rustc() {\n-    run_pass(\"tests/run-pass\");\n-    run_pass(\"tests/run-pass-fullmir\");\n+    let sysroot = get_sysroot();\n+    rustc_pass(&sysroot, \"tests/run-pass\");\n+    rustc_pass(&sysroot, \"tests/run-pass-fullmir\");\n }\n \n-#[test]\n fn compile_fail_miri() {\n     let sysroot = get_sysroot();\n     let host = get_host();\n \n-    for_all_targets(&sysroot, |target| {\n-        compile_fail(&sysroot, \"tests/compile-fail\", &target, &host, false);\n-    });\n+    // FIXME: run tests for other targets, too\n+    compile_fail(&sysroot, \"tests/compile-fail\", &host, &host, false);\n     compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true);\n }\n+\n+#[test]\n+fn test() {\n+    // We put everything into a single test to avoid the parallelism `cargo test`\n+    // introduces.  We still get parallelism within our tests because `compiletest`\n+    // uses `libtest` which runs jobs in parallel.\n+\n+    run_pass_rustc();\n+\n+    run_pass_miri(false);\n+\n+    // FIXME: Disabled for now, as the optimizer is pretty broken and crashes...\n+    // See https://github.com/rust-lang/rust/issues/50411\n+    //run_pass_miri(true);\n+\n+    compile_fail_miri();\n+}"}, {"sha": "60c86c99e9aaf9d67924ce09ea5bb5e86b8727c3", "filename": "tests/run-pass-fullmir/catch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fcatch.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,5 @@\n //ignore-msvc\n+//ignore-macos\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n fn main() {"}, {"sha": "59af803b59f0f1dd18d6820374965b07903927c8", "filename": "tests/run-pass-fullmir/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fformat.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,5 @@\n //ignore-msvc\n+//ignore-macos\n fn main() {\n     println!(\"Hello {}\", 13);\n }"}, {"sha": "a0d73733bdfc8d28034ebebbdd171342b6f13a1f", "filename": "tests/run-pass-fullmir/hello.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhello.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,5 @@\n //ignore-msvc\n+//ignore-macos\n fn main() {\n     println!(\"Hello, world!\");\n }"}, {"sha": "8b653f0f95fc9ef6ae1bce52fbb0fbf760d0606d", "filename": "tests/run-pass-fullmir/issue-3794.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fissue-3794.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //ignore-msvc\n+//ignore-macos\n #![feature(box_syntax)]\n \n trait T {"}, {"sha": "d7764bf6201ae8e5655ca7f0344fcbe4a6e280b0", "filename": "tests/run-pass-fullmir/u128.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass-fullmir%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fu128.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -10,8 +10,6 @@\n \n //ignore-msvc\n \n-#![feature(i128_type)]\n-\n fn b<T>(t: T) -> T { t }\n \n fn main() {"}, {"sha": "beed82e058029681b73495548cea7c316098ba2c", "filename": "tests/run-pass/aux_test.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Frun-pass%2Faux_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Frun-pass%2Faux_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Faux_test.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1,9 +0,0 @@\n-// aux-build:dep.rs\n-\n-// ignore-cross-compile\n-\n-extern crate dep;\n-\n-fn main() {\n-    dep::foo();\n-}"}, {"sha": "b76b4321d62aa8e066b24d213c79ccc8230b8d7b", "filename": "tests/run-pass/auxiliary/dep.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Frun-pass%2Fauxiliary%2Fdep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4712ca37500f26bbcbf97edcb27820717f769f7/tests%2Frun-pass%2Fauxiliary%2Fdep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fauxiliary%2Fdep.rs?ref=d4712ca37500f26bbcbf97edcb27820717f769f7", "patch": "@@ -1 +0,0 @@\n-pub fn foo() {}"}, {"sha": "900ff0e34904cfae67343673ae9f33a829e09927", "filename": "tests/run-pass/generator_control_flow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fgenerator_control_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fgenerator_control_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fgenerator_control_flow.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -16,7 +16,7 @@ fn finish<T>(mut amt: usize, mut t: T) -> T::Return\n     where T: Generator<Yield = ()>\n {\n     loop {\n-        match t.resume() {\n+        match unsafe { t.resume() } {\n             GeneratorState::Yielded(()) => amt -= 1,\n             GeneratorState::Complete(ret) => {\n                 assert_eq!(amt, 0);"}, {"sha": "917d51d0e4b654b71de324efebf5fc2dac7c9053", "filename": "tests/run-pass/heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "tests/run-pass-fullmir/heap.rs"}, {"sha": "4a84f2bc5d62d60fa29453dc6eeef69450ad8be1", "filename": "tests/run-pass/issue-15080.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-15080.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "tests/run-pass-fullmir/issue-15080.rs"}, {"sha": "b14eb074488b29244744dd496a86dff277c5955d", "filename": "tests/run-pass/iter_any.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fiter_any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fiter_any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_any.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -0,0 +1,12 @@\n+pub fn main() {\n+    let f = |x: &u8| { 10u8 == *x };\n+    f(&1u8);\n+\n+    let g = |(), x: &u8| { 10u8 == *x };\n+    g((), &1u8);\n+\n+    let h = |(), (), x: &u8| { 10u8 == *x };\n+    h((), (), &1u8);\n+\n+    [1, 2, 3u8].into_iter().any(|elt| 10 == *elt);\n+}"}, {"sha": "f3c656623765fedbdede95cfa23a62ad35ecffaa", "filename": "tests/run-pass/move-arg-2-unique.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-2-unique.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "tests/run-pass-fullmir/move-arg-2-unique.rs"}, {"sha": "74e94ddbf84f6b0b35b6c217a63e69e55bdb4171", "filename": "tests/run-pass/regions-mock-trans.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-mock-trans.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: We handle uninitialzied storage here, which currently makes validation fail.\n+// FIXME: We handle uninitialized storage here, which currently makes validation fail.\n // compile-flags: -Zmir-emit-validate=0\n \n //ignore-msvc", "previous_filename": "tests/run-pass-fullmir/regions-mock-trans.rs"}, {"sha": "5bbbffe4e60e1f36ce8b25554c42d8ae46128787", "filename": "tests/run-pass/subslice_array.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fsubslice_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fsubslice_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsubslice_array.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,3 @@\n-#![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n \n fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {"}, {"sha": "1a30f875580c201480aec5173002d74d381f0726", "filename": "tests/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvec-matching-fold.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n \n use std::fmt::Debug;"}, {"sha": "9a8912a6b98897cc527c2e2c5a85aef216e5f23e", "filename": "tests/run-pass/vecs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/tests%2Frun-pass%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvecs.rs?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "previous_filename": "tests/run-pass-fullmir/vecs.rs"}, {"sha": "c85820b708b67fa78874fbfee622efe770ea2abd", "filename": "xargo/Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022bd13bee5c083578895ccc2b2675b9bd6e82ae/xargo%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/022bd13bee5c083578895ccc2b2675b9bd6e82ae/xargo%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FCargo.lock?ref=022bd13bee5c083578895ccc2b2675b9bd6e82ae", "patch": "@@ -1,4 +1,4 @@\n-[root]\n+[[package]]\n name = \"miri-xargo\"\n version = \"0.0.0\"\n "}]}