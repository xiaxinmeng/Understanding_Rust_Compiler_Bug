{"sha": "965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NWIwYmZlZmUyN2IwYTQ4N2I3MjQzY2IxYTBhNmYzNmEyYmU3MGI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-01-08T19:40:52Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-01-12T14:24:52Z"}, "message": "Issue 30530: initialize allocas for `Datum::to_lvalue_datum_in_scope`.\n\nIn particular, bring back the `zero` flag for `lvalue_scratch_datum`,\nwhich controls whether the alloca's created immediately at function\nstart are uninitialized at that point or have their embedded\ndrop-flags initialized to \"dropped\".\n\nThen made `to_lvalue_datum_in_scope` pass \"dropped\" as `zero` flag.", "tree": {"sha": "d13837241155870ed1455241315ef63ce0f9f4f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d13837241155870ed1455241315ef63ce0f9f4f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "html_url": "https://github.com/rust-lang/rust/commit/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3246eaec90d3369347da28353b8aa23c9347d592", "url": "https://api.github.com/repos/rust-lang/rust/commits/3246eaec90d3369347da28353b8aa23c9347d592", "html_url": "https://github.com/rust-lang/rust/commit/3246eaec90d3369347da28353b8aa23c9347d592"}], "stats": {"total": 76, "additions": 70, "deletions": 6}, "files": [{"sha": "e152e11a6a657157ed6839b28d7abac0133acb87", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "patch": "@@ -55,6 +55,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n use trans::_match;\n+use trans::base::InitAlloca;\n use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n@@ -1279,6 +1280,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n                 bcx, tcx.dtor_type(), \"drop_flag\",\n+                InitAlloca::Uninit(\"drop flag itself has no dtor\"),\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {"}, {"sha": "b2bc7c2af933b296ae3878acf4310c6a8c32003c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "patch": "@@ -1285,12 +1285,62 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n            None);\n }\n \n-pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) -> ValueRef {\n+/// In general, when we create an scratch value in an alloca, the\n+/// creator may not know if the block (that initializes the scratch\n+/// with the desired value) actually dominates the cleanup associated\n+/// with the scratch value.\n+///\n+/// To deal with this, when we do an alloca (at the *start* of whole\n+/// function body), we optionally can also set the associated\n+/// dropped-flag state of the alloca to \"dropped.\"\n+#[derive(Copy, Clone, Debug)]\n+pub enum InitAlloca {\n+    /// Indicates that the state should have its associated drop flag\n+    /// set to \"dropped\" at the point of allocation.\n+    Dropped,\n+    /// Indicates the value of the associated drop flag is irrelevant.\n+    /// The embedded string literal is a programmer provided argument\n+    /// for why. This is a safeguard forcing compiler devs to\n+    /// document; it might be a good idea to also emit this as a\n+    /// comment with the alloca itself when emitting LLVM output.ll.\n+    Uninit(&'static str),\n+}\n+\n+\n+pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            t: Ty<'tcx>,\n+                            name: &str) -> ValueRef {\n+    // pnkfelix: I do not know why alloc_ty meets the assumptions for\n+    // passing Uninit, but it was never needed (even back when we had\n+    // the original boolean `zero` flag on `lvalue_scratch_datum`).\n+    alloc_ty_init(bcx, t, InitAlloca::Uninit(\"all alloc_ty are uninit\"), name)\n+}\n+\n+pub fn alloc_ty_init<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             t: Ty<'tcx>,\n+                             init: InitAlloca,\n+                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!t.has_param_types());\n-    alloca(bcx, ty, name)\n+    match init {\n+        InitAlloca::Dropped => alloca_dropped(bcx, t, name),\n+        InitAlloca::Uninit(_) => alloca(bcx, ty, name),\n+    }\n+}\n+\n+pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    let _icx = push_ctxt(\"alloca_dropped\");\n+    let llty = type_of::type_of(cx.ccx(), ty);\n+    if cx.unreachable.get() {\n+        unsafe { return llvm::LLVMGetUndef(llty.ptr_to().to_ref()); }\n+    }\n+    let p = alloca(cx, llty, name);\n+    let b = cx.fcx.ccx.builder();\n+    b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+    memfill(&b, p, ty, adt::DTOR_DONE);\n+    p\n }\n \n pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n@@ -1650,6 +1700,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n     // This alloca should be optimized away by LLVM's mem-to-reg pass in\n     // the event it's not truly needed.\n     let mut idx = fcx.arg_offset() as c_uint;\n+    let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n             if type_of::arg_is_indirect(bcx.ccx(), arg_ty) &&\n@@ -1669,7 +1720,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 let data = get_param(fcx.llfn, idx);\n                 let extra = get_param(fcx.llfn, idx + 1);\n                 idx += 2;\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\", uninit_reason,\n                                                         arg_scope_id, (data, extra),\n                                                         |(data, extra), bcx, dst| {\n                     Store(bcx, data, expr::get_dataptr(bcx, dst));\n@@ -1684,6 +1735,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                               datum::lvalue_scratch_datum(bcx,\n                                                           arg_ty,\n                                                           \"\",\n+                                                          uninit_reason,\n                                                           arg_scope_id,\n                                                           tmp,\n                                                           |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n@@ -1696,6 +1748,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                                   datum::lvalue_scratch_datum(bcx,\n                                                               arg_ty,\n                                                               \"tupled_args\",\n+                                                              uninit_reason,\n                                                               arg_scope_id,\n                                                               (),\n                                                               |(),"}, {"sha": "339b3f0f920d7f5746bce5dceed0a362698ad4a9", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965b0bfefe27b0a487b7243cb1a0a6f36a2be70b/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=965b0bfefe27b0a487b7243cb1a0a6f36a2be70b", "patch": "@@ -288,20 +288,29 @@ pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n-\n /// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n /// it. The memory will be dropped upon exit from `scope`. The callback `populate` should\n /// initialize the memory.\n+///\n+/// The flag `zero` indicates how the temporary space itself should be\n+/// initialized at the outset of the function; the only time that\n+/// `InitAlloca::Uninit` is a valid value for `zero` is when the\n+/// caller can prove that either (1.) the code injected by `populate`\n+/// onto `bcx` always dominates the end of `scope`, or (2.) the data\n+/// being allocated has no associated destructor.\n pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                               ty: Ty<'tcx>,\n                                               name: &str,\n+                                              zero: InitAlloca,\n                                               scope: cleanup::ScopeId,\n                                               arg: A,\n                                               populate: F)\n                                               -> DatumBlock<'blk, 'tcx, Lvalue> where\n     F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n {\n-    let scratch = alloc_ty(bcx, ty, name);\n+    // Very subtle: potentially initialize the scratch memory at point where it is alloca'ed.\n+    // (See discussion at Issue 30530.)\n+    let scratch = alloc_ty_init(bcx, ty, zero, name);\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n@@ -496,7 +505,7 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n \n             ByValue => {\n                 lvalue_scratch_datum(\n-                    bcx, self.ty, name, scope, self,\n+                    bcx, self.ty, name, InitAlloca::Dropped, scope, self,\n                     |this, bcx, llval| {\n                         call_lifetime_start(bcx, llval);\n                         let bcx = this.store_to(bcx, llval);"}]}