{"sha": "d6cffe41b59feaab5fb92bb320e60586202c9950", "node_id": "C_kwDOAAsO6NoAKGQ2Y2ZmZTQxYjU5ZmVhYWI1ZmI5MmJiMzIwZTYwNTg2MjAyYzk5NTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-19T03:33:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-19T03:33:19Z"}, "message": "Auto merge of #89831 - Aaron1011:project-caching-speedup, r=jackh726\n\nRe-introduce concept of projection cache 'completion'\n\nInstead of clearing out the cache entirely, we store\nthe intermediate evaluation result into the cache entry.\nThis accomplishes several things:\n\n* We avoid the performance hit associated with re-evaluating\n  the sub-obligations\n* We avoid causing issues with incremental compilation, since\n  the final evaluation result is always the same\n* We avoid affecting other uses of the same `InferCtxt` which\n  might care about 'side effects' from processing the sub-obligations\n  (e,g. region constraints). Only code that is specifically aware\n   of the new 'complete' code is affected", "tree": {"sha": "b139bcfeca7b9f2ed7c532922b40e811f1286d0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b139bcfeca7b9f2ed7c532922b40e811f1286d0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6cffe41b59feaab5fb92bb320e60586202c9950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6cffe41b59feaab5fb92bb320e60586202c9950", "html_url": "https://github.com/rust-lang/rust/commit/d6cffe41b59feaab5fb92bb320e60586202c9950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6cffe41b59feaab5fb92bb320e60586202c9950/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df2f45c1d30615c930b7aa76bb9efbeea3909703", "url": "https://api.github.com/repos/rust-lang/rust/commits/df2f45c1d30615c930b7aa76bb9efbeea3909703", "html_url": "https://github.com/rust-lang/rust/commit/df2f45c1d30615c930b7aa76bb9efbeea3909703"}, {"sha": "40ef1d322304c8a21c675fd32886fb27ebe07039", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ef1d322304c8a21c675fd32886fb27ebe07039", "html_url": "https://github.com/rust-lang/rust/commit/40ef1d322304c8a21c675fd32886fb27ebe07039"}], "stats": {"total": 144, "additions": 138, "deletions": 6}, "files": [{"sha": "9fc0b978c736b1533ae4efe16a68ace8b909380b", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=d6cffe41b59feaab5fb92bb320e60586202c9950", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::{\n };\n use rustc_middle::ty::{self, Ty};\n \n-pub use rustc_middle::traits::Reveal;\n+pub use rustc_middle::traits::{EvaluationResult, Reveal};\n \n pub(crate) type UndoLog<'tcx> =\n     snapshot_map::UndoLog<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>;\n@@ -92,7 +92,42 @@ pub enum ProjectionCacheEntry<'tcx> {\n     Ambiguous,\n     Recur,\n     Error,\n-    NormalizedTy(NormalizedTy<'tcx>),\n+    NormalizedTy {\n+        ty: NormalizedTy<'tcx>,\n+        /// If we were able to successfully evaluate the\n+        /// corresponding cache entry key during predicate\n+        /// evaluation, then this field stores the final\n+        /// result obtained from evaluating all of the projection\n+        /// sub-obligations. During evaluation, we will skip\n+        /// evaluating the cached sub-obligations in `ty`\n+        /// if this field is set. Evaluation only\n+        /// cares about the final result, so we don't\n+        /// care about any region constraint side-effects\n+        /// produced by evaluating the sub-boligations.\n+        ///\n+        /// Additionally, we will clear out the sub-obligations\n+        /// entirely if we ever evaluate the cache entry (along\n+        /// with all its sub obligations) to `EvaluatedToOk`.\n+        /// This affects all users of the cache, not just evaluation.\n+        /// Since a result of `EvaluatedToOk` means that there were\n+        /// no region obligations that need to be tracked, it's\n+        /// fine to forget about the sub-obligations - they\n+        /// don't provide any additional information. However,\n+        /// we do *not* discard any obligations when we see\n+        /// `EvaluatedToOkModuloRegions` - we don't know\n+        /// which sub-obligations may introduce region constraints,\n+        /// so we keep them all to be safe.\n+        ///\n+        /// When we are not performing evaluation\n+        /// (e.g. in `FulfillmentContext`), we ignore this field,\n+        /// and always re-process the cached sub-obligations\n+        /// (which may have been cleared out - see the above\n+        /// paragraph).\n+        /// This ensures that we do not lose any regions\n+        /// constraints that arise from processing the\n+        /// sub-obligations.\n+        complete: Option<EvaluationResult>,\n+    },\n }\n \n impl<'tcx> ProjectionCacheStorage<'tcx> {\n@@ -149,10 +184,41 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n             debug!(\"Not overwriting Recur\");\n             return;\n         }\n-        let fresh_key = map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n+        let fresh_key =\n+            map.insert(key, ProjectionCacheEntry::NormalizedTy { ty: value, complete: None });\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n+    /// Mark the relevant projection cache key as having its derived obligations\n+    /// complete, so they won't have to be re-computed (this is OK to do in a\n+    /// snapshot - if the snapshot is rolled back, the obligations will be\n+    /// marked as incomplete again).\n+    pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>, result: EvaluationResult) {\n+        let mut map = self.map();\n+        match map.get(&key) {\n+            Some(&ProjectionCacheEntry::NormalizedTy { ref ty, complete: _ }) => {\n+                info!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n+                let mut ty = ty.clone();\n+                if result == EvaluationResult::EvaluatedToOk {\n+                    ty.obligations = vec![];\n+                }\n+                map.insert(key, ProjectionCacheEntry::NormalizedTy { ty, complete: Some(result) });\n+            }\n+            ref value => {\n+                // Type inference could \"strand behind\" old cache entries. Leave\n+                // them alone for now.\n+                info!(\"ProjectionCacheEntry::complete({:?}) - ignoring {:?}\", key, value);\n+            }\n+        };\n+    }\n+\n+    pub fn is_complete(&mut self, key: ProjectionCacheKey<'tcx>) -> Option<EvaluationResult> {\n+        self.map().get(&key).and_then(|res| match res {\n+            ProjectionCacheEntry::NormalizedTy { ty: _, complete } => *complete,\n+            _ => None,\n+        })\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will"}, {"sha": "17e7b481890a90748d14ca83be18853152e5369d", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=d6cffe41b59feaab5fb92bb320e60586202c9950", "patch": "@@ -16,6 +16,7 @@\n #![feature(drain_filter)]\n #![feature(derive_default_enum)]\n #![feature(hash_drain_filter)]\n+#![feature(label_break_value)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "35bb7d6f06cb7f630286cb4c06374a1fb651d0ce", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=d6cffe41b59feaab5fb92bb320e60586202c9950", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n+use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n@@ -20,12 +21,14 @@ use super::wf;\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::EvaluationResult;\n use super::Unimplemented;\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n use crate::traits::error_reporting::InferCtxtExt as _;\n use crate::traits::project::PolyProjectionObligation;\n+use crate::traits::project::ProjectionCacheKeyExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n@@ -709,6 +712,20 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n             if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+                if let Some(key) = ProjectionCacheKey::from_poly_projection_predicate(\n+                    &mut self.selcx,\n+                    project_obligation.predicate,\n+                ) {\n+                    // If `predicate_must_hold_considering_regions` succeeds, then we've\n+                    // evaluated all sub-obligations. We can therefore mark the 'root'\n+                    // obligation as complete, and skip evaluating sub-obligations.\n+                    self.selcx\n+                        .infcx()\n+                        .inner\n+                        .borrow_mut()\n+                        .projection_cache()\n+                        .complete(key, EvaluationResult::EvaluatedToOk);\n+                }\n                 return ProcessResult::Changed(vec![]);\n             } else {\n                 tracing::debug!(\"Does NOT hold: {:?}\", obligation);"}, {"sha": "490e35d34f23128c514d529845d1c7b286fd106b", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d6cffe41b59feaab5fb92bb320e60586202c9950", "patch": "@@ -889,7 +889,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             debug!(\"recur cache\");\n             return Err(InProgress);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy { ty, complete: _ }) => {\n             // This is the hottest path in this function.\n             //\n             // If we find the value in the cache, then return it along"}, {"sha": "77b8fc49a15cf5542f94f52a123c1351ff4da627", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6cffe41b59feaab5fb92bb320e60586202c9950/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d6cffe41b59feaab5fb92bb320e60586202c9950", "patch": "@@ -25,6 +25,8 @@ use super::{ObligationCause, PredicateObligation, TraitObligation};\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::project::ProjectionCacheKeyExt;\n+use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n@@ -550,8 +552,54 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n-                            self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n-                            self.evaluate_predicates_recursively(previous_stack, subobligations)\n+                            'compute_res: {\n+                                // If we've previously marked this projection as 'complete', thne\n+                                // use the final cached result (either `EvaluatedToOk` or\n+                                // `EvaluatedToOkModuloRegions`), and skip re-evaluating the\n+                                // sub-obligations.\n+                                if let Some(key) =\n+                                    ProjectionCacheKey::from_poly_projection_predicate(self, data)\n+                                {\n+                                    if let Some(cached_res) = self\n+                                        .infcx\n+                                        .inner\n+                                        .borrow_mut()\n+                                        .projection_cache()\n+                                        .is_complete(key)\n+                                    {\n+                                        break 'compute_res Ok(cached_res);\n+                                    }\n+                                }\n+\n+                                self.add_depth(\n+                                    subobligations.iter_mut(),\n+                                    obligation.recursion_depth,\n+                                );\n+                                let res = self.evaluate_predicates_recursively(\n+                                    previous_stack,\n+                                    subobligations,\n+                                );\n+                                if let Ok(res) = res {\n+                                    if res == EvaluatedToOk || res == EvaluatedToOkModuloRegions {\n+                                        if let Some(key) =\n+                                            ProjectionCacheKey::from_poly_projection_predicate(\n+                                                self, data,\n+                                            )\n+                                        {\n+                                            // If the result is something that we can cache, then mark this\n+                                            // entry as 'complete'. This will allow us to skip evaluating the\n+                                            // suboligations at all the next time we evaluate the projection\n+                                            // predicate.\n+                                            self.infcx\n+                                                .inner\n+                                                .borrow_mut()\n+                                                .projection_cache()\n+                                                .complete(key, res);\n+                                        }\n+                                    }\n+                                }\n+                                res\n+                            }\n                         }\n                         Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n                         Ok(Err(project::InProgress)) => Ok(EvaluatedToRecur),"}]}