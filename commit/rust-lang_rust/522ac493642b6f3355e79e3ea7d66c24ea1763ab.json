{"sha": "522ac493642b6f3355e79e3ea7d66c24ea1763ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMmFjNDkzNjQyYjZmMzM1NWU3OWUzZWE3ZDY2YzI0ZWExNzYzYWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-22T09:25:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-22T09:25:05Z"}, "message": "Merge pull request #206 from RalfJung/ptrs\n\nPointer Arithmetic", "tree": {"sha": "846c9340f014e477dd6fa042628b8ee63a73f93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/846c9340f014e477dd6fa042628b8ee63a73f93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/522ac493642b6f3355e79e3ea7d66c24ea1763ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/522ac493642b6f3355e79e3ea7d66c24ea1763ab", "html_url": "https://github.com/rust-lang/rust/commit/522ac493642b6f3355e79e3ea7d66c24ea1763ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/522ac493642b6f3355e79e3ea7d66c24ea1763ab/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "046136a3f76069ac030ec0f5e1d388b6febde2c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/046136a3f76069ac030ec0f5e1d388b6febde2c9", "html_url": "https://github.com/rust-lang/rust/commit/046136a3f76069ac030ec0f5e1d388b6febde2c9"}, {"sha": "7b2b0dd56c2ab8d5dc4e9c7e2bbd0c4128ba4f5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2b0dd56c2ab8d5dc4e9c7e2bbd0c4128ba4f5d", "html_url": "https://github.com/rust-lang/rust/commit/7b2b0dd56c2ab8d5dc4e9c7e2bbd0c4128ba4f5d"}], "stats": {"total": 359, "additions": 250, "deletions": 109}, "files": [{"sha": "4cf3ecb8215ae0cbee631220de22d49719248b73", "filename": "src/memory.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -64,10 +64,20 @@ impl Pointer {\n         Pointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n     }\n \n+    pub fn overflowing_signed_offset<'tcx>(self, i: i128, layout: &TargetDataLayout) -> (Self, bool) {\n+        let (res, over) = value::overflowing_signed_offset(self.offset, i, layout);\n+        (Pointer::new(self.alloc_id, res), over)\n+    }\n+\n     pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n     }\n \n+    pub fn overflowing_offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> (Self, bool) {\n+        let (res, over) = value::overflowing_offset(self.offset, i, layout);\n+        (Pointer::new(self.alloc_id, res), over)\n+    }\n+\n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }\n@@ -470,11 +480,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n-        debug!(\"reading fn ptr: {}\", id);\n-        match self.functions.get(&id) {\n+    pub fn get_fn(&self, ptr: Pointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+        if ptr.offset != 0 {\n+            return Err(EvalError::InvalidFunctionPointer);\n+        }\n+        debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n+        match self.functions.get(&ptr.alloc_id) {\n             Some(&fndef) => Ok(fndef),\n-            None => match self.alloc_map.get(&id) {\n+            None => match self.alloc_map.get(&ptr.alloc_id) {\n                 Some(_) => Err(EvalError::ExecuteMemory),\n                 None => Err(EvalError::InvalidFunctionPointer),\n             }"}, {"sha": "7cba12594f9b6a466c8502b653c7a79158167e9e", "filename": "src/operator.rs", "status": "modified", "additions": 76, "deletions": 64, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -3,6 +3,7 @@ use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n+use memory::Pointer;\n use lvalue::Lvalue;\n use value::{\n     PrimVal,\n@@ -145,46 +146,69 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let left_kind  = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n-\n-        // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n-        if bin_op == Offset {\n-            if left_kind == Ptr && right_kind == PrimValKind::from_uint_size(self.memory.pointer_size()) {\n-                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n-                return Ok((ptr, false));\n-            } else {\n-                bug!(\"Offset used with wrong type\");\n-            }\n-        }\n-\n-        // unrelated pointer ops\n-        let op: Option<fn(&PrimVal, &PrimVal) -> bool> = match bin_op {\n-            Eq => Some(PrimVal::eq),\n-            Ne => Some(PrimVal::ne),\n-            _ => None,\n-        };\n-        if let Some(op) = op {\n-            // only floats can't be binary compared\n-            let ok = left_kind != F32 && left_kind != F64;\n-            let ok = ok && right_kind != F32 && right_kind != F64;\n-            if ok {\n-                return Ok((PrimVal::from_bool(op(&left, &right)), false));\n-            }\n-        }\n-\n-        \n-        if let (Ok(left), Ok(right)) = (left.to_ptr(), right.to_ptr()) {\n-            if left.alloc_id == right.alloc_id {\n-                return self.ptr_ops(\n-                    bin_op,\n-                    left.offset,\n-                    right.offset,\n-                );\n-            } else {\n-                return Err(EvalError::InvalidPointerMath);\n+        //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+\n+        // I: Handle operations that support pointers\n+        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n+        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n+        if !left_kind.is_float() && !right_kind.is_float() {\n+            match bin_op {\n+                Offset if left_kind == Ptr && right_kind == usize => {\n+                    let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+                    let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n+                    return Ok((ptr, false));\n+                },\n+                // These work on anything\n+                Eq if left_kind == right_kind => {\n+                    return Ok((PrimVal::from_bool(left == right), false));\n+                }\n+                Ne if left_kind == right_kind => {\n+                    return Ok((PrimVal::from_bool(left != right), false));\n+                }\n+                // These need both pointers to be in the same allocation\n+                Lt | Le | Gt | Ge | Sub\n+                if left_kind == right_kind\n+                && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n+                && left.is_ptr() && right.is_ptr() => {\n+                    let left = left.to_ptr()?;\n+                    let right = right.to_ptr()?;\n+                    if left.alloc_id == right.alloc_id {\n+                        let res = match bin_op {\n+                            Lt => left.offset < right.offset,\n+                            Le => left.offset <= right.offset,\n+                            Gt => left.offset > right.offset,\n+                            Ge => left.offset >= right.offset,\n+                            Sub => {\n+                                return int_arithmetic!(left_kind, overflowing_sub, left.offset, right.offset);\n+                            }\n+                            _ => bug!(\"We already established it has to be one of these operators.\"),\n+                        };\n+                        return Ok((PrimVal::from_bool(res), false));\n+                    } else {\n+                        // Both are pointers, but from different allocations.\n+                        return Err(EvalError::InvalidPointerMath);\n+                    }\n+                }\n+                // These work if one operand is a pointer, the other an integer\n+                Add | Sub\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+                && left.is_ptr() && right.is_bytes() => {\n+                    // Cast to i128 is fine as we checked the kind to be ptr-sized\n+                    let (res, over) = self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize)?;\n+                    return Ok((PrimVal::Ptr(res), over));\n+                }\n+                Add\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+                && left.is_bytes() && right.is_ptr() => {\n+                    // This is a commutative operation, just swap the operands\n+                    let (res, over) = self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize)?;\n+                    return Ok((PrimVal::Ptr(res), over));\n+                }\n+                _ => {}\n             }\n         }\n \n+        // II: From now on, everything must be bytes, no pointers\n         let l = left.to_bytes()?;\n         let r = right.to_bytes()?;\n \n@@ -229,8 +253,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (Div, F64) => f64_arithmetic!(/, l, r),\n             (Rem, F64) => f64_arithmetic!(%, l, r),\n \n-            (Eq, _) => PrimVal::from_bool(l == r),\n-            (Ne, _) => PrimVal::from_bool(l != r),\n             (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n             (Lt, _) => PrimVal::from_bool(l <  r),\n             (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n@@ -259,35 +281,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok((val, false))\n     }\n \n-    fn ptr_ops(\n+    fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: u64,\n-        right: u64,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        left: Pointer,\n+        right: i128,\n+        signed: bool,\n+    ) -> EvalResult<'tcx, (Pointer, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        let val = match bin_op {\n-            Eq => PrimVal::from_bool(left == right),\n-            Ne => PrimVal::from_bool(left != right),\n-            Lt | Le | Gt | Ge => {\n-                PrimVal::from_bool(match bin_op {\n-                    Lt => left < right,\n-                    Le => left <= right,\n-                    Gt => left > right,\n-                    Ge => left >= right,\n-                    _ => bug!(\"We already established it has to be a comparison operator.\"),\n-                })\n-            }\n-            Sub => {\n-                let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-                return int_arithmetic!(usize, overflowing_sub, left, right);\n-            }\n-            _ => {\n-                return Err(EvalError::ReadPointerAsBytes);\n-            }\n-        };\n-        Ok((val, false))\n+        Ok(match bin_op {\n+            Sub =>\n+                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n+                left.overflowing_signed_offset(-right, self.memory.layout),\n+            Add if signed =>\n+                left.overflowing_signed_offset(right, self.memory.layout),\n+            Add if !signed =>\n+                left.overflowing_offset(right as u64, self.memory.layout),\n+            _ => bug!(\"ptr_int_arithmetic called on unsupported operation\")\n+        })\n     }\n }\n "}, {"sha": "8ede9fa7559b9c9c3c60008f75d48187bbcdc688", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -424,9 +424,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n+                    let ptr = ptr.to_ptr()?;\n                     self.memory.check_align(ptr, ty_align, size * count)?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }"}, {"sha": "22b1bf309ce8b7a4cce10d3427f4c7abf3cc351c", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (fn_def, sig) = match func_ty.sty {\n                     ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.def.def_ty(self.tcx);\n                         let instance_ty = self.monomorphize(instance_ty, instance.substs);\n                         match instance_ty.sty {\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr_size = self.memory.pointer_size();\n                 let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n                 let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), self.memory.layout)?)?;\n-                let instance = self.memory.get_fn(fn_ptr.to_ptr()?.alloc_id)?;\n+                let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n                 let ty = self.get_field_ty(ty, 0)?;\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n                 let f = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let data = args[1].read_ptr(&self.memory)?;\n-                let f_instance = self.memory.get_fn(f.alloc_id)?;\n+                let f_instance = self.memory.get_fn(f)?;\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n \n                 // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n@@ -614,7 +614,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                 self.write_primval(arg_dest, data, u8_ptr_ty)?;\n \n-                // We ourselbes return 0\n+                // We ourselves return 0\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n \n                 // Don't fall through\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match args[1].read_ptr(&self.memory)? {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr.alloc_id)?),\n+                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n                     PrimVal::Undef => return Err(EvalError::ReadUndefBytes),"}, {"sha": "680776968f9898f6ba0046bc2325a389d33f5195", "filename": "src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n             Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n-            Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn.alloc_id).map(Some),\n+            Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n             _ => Err(EvalError::ReadBytesAsPointer),\n         }\n     }"}, {"sha": "519c048f3ef8da7a0b105d9634a14265e0c17f6f", "filename": "src/value.rs", "status": "modified", "additions": 53, "deletions": 11, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -160,6 +160,27 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n+    pub fn is_bytes(self) -> bool {\n+        match self {\n+            PrimVal::Bytes(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_ptr(self) -> bool {\n+        match self {\n+            PrimVal::Ptr(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_undef(self) -> bool {\n+        match self {\n+            PrimVal::Undef => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn to_u128(self) -> EvalResult<'tcx, u128> {\n         self.to_bytes()\n     }\n@@ -239,32 +260,45 @@ impl<'tcx> PrimVal {\n     }\n }\n \n-pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+// Overflow checking only works properly on the range from -u64 to +u64.\n+pub fn overflowing_signed_offset<'tcx>(val: u64, i: i128, layout: &TargetDataLayout) -> (u64, bool) {\n     // FIXME: is it possible to over/underflow here?\n     if i < 0 {\n         // trickery to ensure that i64::min_value() works fine\n         // this formula only works for true negative values, it panics for zero!\n         let n = u64::max_value() - (i as u64) + 1;\n-        val.checked_sub(n).ok_or(EvalError::OverflowingMath)\n+        val.overflowing_sub(n)\n     } else {\n-        offset(val, i as u64, layout)\n+        overflowing_offset(val, i as u64, layout)\n     }\n }\n \n-pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    if let Some(res) = val.checked_add(i) {\n-        if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n-            Err(EvalError::OverflowingMath)\n-        } else {\n-            Ok(res)\n-        }\n+pub fn overflowing_offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> (u64, bool) {\n+    let (res, over) = val.overflowing_add(i);\n+    ((res as u128 % (1u128 << layout.pointer_size.bits())) as u64,\n+     over || res as u128 >= (1u128 << layout.pointer_size.bits()))\n+}\n+\n+pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+    let (res, over) = overflowing_signed_offset(val, i as i128, layout);\n+    if over {\n+        Err(EvalError::OverflowingMath)\n     } else {\n+        Ok(res)\n+    }\n+}\n+\n+pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+    let (res, over) = overflowing_offset(val, i, layout);\n+    if over {\n         Err(EvalError::OverflowingMath)\n+    } else {\n+        Ok(res)\n     }\n }\n \n pub fn wrapping_signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> u64 {\n-    (val.wrapping_add(i as u64) as u128 % (1u128 << layout.pointer_size.bits())) as u64\n+    overflowing_signed_offset(val, i as i128, layout).0\n }\n \n impl PrimValKind {\n@@ -284,6 +318,14 @@ impl PrimValKind {\n         }\n     }\n \n+     pub fn is_float(self) -> bool {\n+        use self::PrimValKind::*;\n+        match self {\n+            F32 | F64 => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn from_uint_size(size: u64) -> Self {\n         match size {\n             1 => PrimValKind::U8,"}, {"sha": "2d240b6a55ade8ae223a1fa16cc5e5fa573a874c", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -0,0 +1,11 @@\n+use std::mem;\n+\n+fn f() {}\n+\n+fn main() {\n+    let x : fn() = f;\n+    let y : *mut u8 = unsafe { mem::transmute(x) };\n+    let y = y.wrapping_offset(1);\n+    let x : fn() = unsafe { mem::transmute(y) };\n+    x(); //~ ERROR: tried to use an integer pointer or a dangling pointer as a function pointer\n+}"}, {"sha": "c0c396240733a5250ebaaeb00bcefe4bbfb0445f", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -1,10 +1,6 @@\n use std::collections::{self, HashMap};\n use std::hash::BuildHasherDefault;\n \n-// This disables the test completely:\n-// ignore-stage1\n-// TODO: The tests actually passes against rustc and miri with MIR-libstd, but right now, we cannot express that in the test flags\n-\n fn main() {\n     let map : HashMap<String, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n     assert_eq!(map.values().fold(0, |x, y| x+y), 0);", "previous_filename": "tests/run-pass/hashmap.rs"}, {"sha": "b7b17089efc7df49925193681d156cc4e34355eb", "filename": "tests/run-pass/ptr_int_casts.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Frun-pass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Frun-pass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_casts.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -1,15 +1,32 @@\n+use std::mem;\n+\n fn eq_ref<T>(x: &T, y: &T) -> bool {\n     x as *const _ == y as *const _\n }\n \n+fn f() -> i32 { 42 }\n+\n fn main() {\n     // int-ptr-int\n     assert_eq!(1 as *const i32 as usize, 1);\n+    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4*4);\n \n     {   // ptr-int-ptr\n         let x = 13;\n-        let y = &x as *const _ as usize;\n+        let mut y = &x as *const _ as usize;\n+        y += 13;\n+        y -= 13;\n         let y = y as *const _;\n         assert!(eq_ref(&x, unsafe { &*y }));\n     }\n+\n+    {   // fnptr-int-fnptr\n+        let x : fn() -> i32 = f;\n+        let y : *mut u8 = unsafe { mem::transmute(x) };\n+        let mut y = y as usize;\n+        y += 13;\n+        y -= 13;\n+        let x : fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n+        assert_eq!(x(), 42);\n+    }\n }"}, {"sha": "4fb43793eaec5b85fe34126c4079372bf2cd2c96", "filename": "tests/run-pass/thread-local-no-dtor.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/046136a3f76069ac030ec0f5e1d388b6febde2c9/tests%2Frun-pass%2Fthread-local-no-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/046136a3f76069ac030ec0f5e1d388b6febde2c9/tests%2Frun-pass%2Fthread-local-no-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local-no-dtor.rs?ref=046136a3f76069ac030ec0f5e1d388b6febde2c9", "patch": "@@ -1,18 +0,0 @@\n-//ignore-windows\n-\n-#![feature(libc)]\n-extern crate libc;\n-\n-use std::mem;\n-\n-pub type Key = libc::pthread_key_t;\n-\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    let mut key = 0;\n-    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n-    key\n-}\n-\n-fn main() {\n-    let _ = unsafe { create(None) };\n-}"}, {"sha": "34aeef23b1ad4596587b528a0102efaf53f913b1", "filename": "tests/run-pass/thread-local.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Frun-pass%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522ac493642b6f3355e79e3ea7d66c24ea1763ab/tests%2Frun-pass%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local.rs?ref=522ac493642b6f3355e79e3ea7d66c24ea1763ab", "patch": "@@ -0,0 +1,67 @@\n+//ignore-windows\n+\n+#![feature(libc)]\n+extern crate libc;\n+\n+use std::mem;\n+\n+pub type Key = libc::pthread_key_t;\n+\n+static mut RECORD : usize = 0;\n+static mut KEYS : [Key; 2] = [0; 2];\n+static mut GLOBALS : [u64; 2] = [1, 0];\n+\n+static mut CANNARY : *mut u64 = 0 as *mut _; // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n+\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    let mut key = 0;\n+    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n+    key\n+}\n+\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    let r = libc::pthread_setspecific(key, value as *mut _);\n+    assert_eq!(r, 0);\n+}\n+\n+pub fn record(r: usize) {\n+    assert!(r < 10);\n+    unsafe { RECORD = RECORD*10 + r };\n+}\n+\n+unsafe extern fn dtor(mut ptr: *mut u64) {\n+    assert!(CANNARY != 0 as *mut _); // make sure we do not get run too often\n+    let val = *ptr;\n+    \n+    let which_key = GLOBALS.iter().position(|global| global as *const _ == ptr).expect(\"Should find my global\");\n+    record(which_key);\n+\n+    if val > 0 {\n+        *ptr = val-1;\n+        set(KEYS[which_key], ptr as *mut _);\n+    }\n+\n+    // Check if the records matches what we expect. If yes, clear the cannary.\n+    // If the record is wrong, the cannary will never get cleared, leading to a leak -> test fails.\n+    // If the record is incomplete (i.e., more dtor calls happen), the check at the beginning of this function will fail -> test fails.\n+    // The correct sequence is: First key 0, then key 1, then key 0.\n+    if RECORD == 0_1_0 {\n+        drop(Box::from_raw(CANNARY));\n+        CANNARY = 0 as *mut _;\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        create(None); // check that the no-dtor case works\n+\n+        // Initialize the keys we use to check destructor ordering\n+        for (key, global) in KEYS.iter_mut().zip(GLOBALS.iter()) {\n+            *key = create(Some(mem::transmute(dtor as unsafe extern fn(*mut u64))));\n+            set(*key, global as *const _ as *mut _);\n+        }\n+\n+        // Initialize cannary\n+        CANNARY = Box::into_raw(Box::new(0u64));\n+    }\n+}"}]}