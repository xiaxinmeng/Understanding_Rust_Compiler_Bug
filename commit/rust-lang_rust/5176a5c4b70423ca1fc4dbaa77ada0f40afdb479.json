{"sha": "5176a5c4b70423ca1fc4dbaa77ada0f40afdb479", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNzZhNWM0YjcwNDIzY2ExZmM0ZGJhYTc3YWRhMGY0MGFmZGI0Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-01T08:36:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-01T08:36:11Z"}, "message": "Auto merge of #3726 - phansch:some_renaming, r=oli-obk\n\nSome renamings: s/ast_ty/hir_ty and s/StructField/hir::StructField\n\nI think in both cases the new names make the code more understandable.\nFor `StructField` specifically because there's one in\n[`syntax::ast`][ast] and one in [`rustc::hir`][hir].\n\n[ast]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.StructField.html\n[hir]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.StructField.html", "tree": {"sha": "58448e73c119bfd2188ed8af38e44dfd02825240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58448e73c119bfd2188ed8af38e44dfd02825240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5176a5c4b70423ca1fc4dbaa77ada0f40afdb479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5176a5c4b70423ca1fc4dbaa77ada0f40afdb479", "html_url": "https://github.com/rust-lang/rust/commit/5176a5c4b70423ca1fc4dbaa77ada0f40afdb479", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5176a5c4b70423ca1fc4dbaa77ada0f40afdb479/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84dca9af66da7e49eda8005509c8dffebefe96a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/84dca9af66da7e49eda8005509c8dffebefe96a0", "html_url": "https://github.com/rust-lang/rust/commit/84dca9af66da7e49eda8005509c8dffebefe96a0"}, {"sha": "ee7bad455b12f6c434e308d18f7128e86213163b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7bad455b12f6c434e308d18f7128e86213163b", "html_url": "https://github.com/rust-lang/rust/commit/ee7bad455b12f6c434e308d18f7128e86213163b"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "939dd27c441590f0c938bb4dcdf250a3641a0448", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5176a5c4b70423ca1fc4dbaa77ada0f40afdb479/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5176a5c4b70423ca1fc4dbaa77ada0f40afdb479/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=5176a5c4b70423ca1fc4dbaa77ada0f40afdb479", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n         check_fn_decl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField) {\n         check_ty(cx, &field.ty, false);\n     }\n \n@@ -240,21 +240,21 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n ///\n /// The parameter `is_local` distinguishes the context of the type; types from\n /// local bindings should only be checked for the `BORROWED_BOX` lint.\n-fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n-    if in_macro(ast_ty.span) {\n+fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool) {\n+    if in_macro(hir_ty.span) {\n         return;\n     }\n-    match ast_ty.node {\n+    match hir_ty.node {\n         TyKind::Path(ref qpath) if !is_local => {\n-            let hir_id = cx.tcx.hir().node_to_hir_id(ast_ty.id);\n+            let hir_id = cx.tcx.hir().node_to_hir_id(hir_ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                     if match_type_parameter(cx, qpath, &paths::VEC) {\n                         span_help_and_lint(\n                             cx,\n                             BOX_VEC,\n-                            ast_ty.span,\n+                            hir_ty.span,\n                             \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n                             \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n                         );\n@@ -288,7 +288,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n                             span_lint_and_sugg(\n                                 cx,\n                                 VEC_BOX,\n-                                ast_ty.span,\n+                                hir_ty.span,\n                                 \"`Vec<T>` is already on the heap, the boxing is unnecessary.\",\n                                 \"try\",\n                                 format!(\"Vec<{}>\", boxed_type),\n@@ -302,7 +302,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n                         span_lint(\n                             cx,\n                             OPTION_OPTION,\n-                            ast_ty.span,\n+                            hir_ty.span,\n                             \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n                              enum if you need to distinguish all 3 cases\",\n                         );\n@@ -312,7 +312,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n                     span_help_and_lint(\n                         cx,\n                         LINKEDLIST,\n-                        ast_ty.span,\n+                        hir_ty.span,\n                         \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n                         \"a VecDeque might work\",\n                     );\n@@ -360,7 +360,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n                 },\n             }\n         },\n-        TyKind::Rptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n+        TyKind::Rptr(ref lt, ref mut_ty) => check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),\n         // recurse\n         TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n             check_ty(cx, ty, is_local)\n@@ -374,7 +374,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n     }\n }\n \n-fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n+fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n             let hir_id = cx.tcx.hir().node_to_hir_id(mut_ty.ty.id);\n@@ -410,7 +410,7 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt:\n                     span_lint_and_sugg(\n                         cx,\n                         BORROWED_BOX,\n-                        ast_ty.span,\n+                        hir_ty.span,\n                         \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n                         \"try\",\n                         format!(\n@@ -1324,7 +1324,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n         self.check_fndecl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n         // enum variants are also struct fields now\n         self.check_type(cx, &field.ty);\n     }"}]}