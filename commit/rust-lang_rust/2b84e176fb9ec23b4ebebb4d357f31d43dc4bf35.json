{"sha": "2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODRlMTc2ZmI5ZWMyM2I0ZWJlYmI0ZDM1N2YzMWQ0M2RjNGJmMzU=", "commit": {"author": {"name": "David Renshaw", "email": "david@sandstorm.io", "date": "2017-05-13T11:08:30Z"}, "committer": {"name": "David Renshaw", "email": "david@sandstorm.io", "date": "2017-05-13T11:09:57Z"}, "message": "update for new boxier mir", "tree": {"sha": "3f7bd335f57deadd2861c0e212b1f6bb6dbeea5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f7bd335f57deadd2861c0e212b1f6bb6dbeea5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35", "html_url": "https://github.com/rust-lang/rust/commit/2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35/comments", "author": null, "committer": null, "parents": [{"sha": "ecf452ce3acf1893e5dc26b6a575b0f293f86fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf452ce3acf1893e5dc26b6a575b0f293f86fd4", "html_url": "https://github.com/rust-lang/rust/commit/ecf452ce3acf1893e5dc26b6a575b0f293f86fd4"}], "stats": {"total": 19, "additions": 10, "deletions": 9}, "files": [{"sha": "e3d62e33d64e1720cb075d5979a7640d939aaa46", "filename": "src/eval_context.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=2b84e176fb9ec23b4ebebb4d357f31d43dc4bf35", "patch": "@@ -137,13 +137,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     source_info,\n                     kind: mir::StatementKind::Assign(\n                         mir::Lvalue::Local(mir::Local::new(2)),\n-                        mir::Rvalue::Use(mir::Operand::Constant(mir::Constant {\n+                        mir::Rvalue::Use(mir::Operand::Constant(Box::new(mir::Constant {\n                             span: DUMMY_SP,\n                             ty: tcx.types.usize,\n                             literal: mir::Literal::Value {\n                                 value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(0, tcx.sess.target.uint_type).unwrap())),\n                             },\n-                        }))\n+                        })))\n                     )\n                 },\n                 mir::Statement {\n@@ -225,13 +225,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         mir::Rvalue::BinaryOp(\n                             mir::BinOp::Add,\n                             mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n-                            mir::Operand::Constant(mir::Constant {\n+                            mir::Operand::Constant(Box::new(mir::Constant {\n                                 span: DUMMY_SP,\n                                 ty: tcx.types.usize,\n                                 literal: mir::Literal::Value {\n                                     value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(1, tcx.sess.target.uint_type).unwrap())),\n                                 },\n-                            }),\n+                            })),\n                         )\n                     )\n                 },\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     General { discr, ref variants, .. } => {\n-                        if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n+                        if let mir::AggregateKind::Adt(adt_def, variant, _, _) = **kind {\n                             let discr_val = adt_def.discriminants(self.tcx)\n                                 .nth(variant)\n                                 .expect(\"broken mir: Adt variant id invalid\")\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     RawNullablePointer { nndiscr, .. } => {\n-                        if let mir::AggregateKind::Adt(_, variant, _, _) = *kind {\n+                        if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n                             if nndiscr == variant as u64 {\n                                 assert_eq!(operands.len(), 1);\n                                 let operand = &operands[0];\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     StructWrappedNullablePointer { nndiscr, ref nonnull, ref discrfield, .. } => {\n-                        if let mir::AggregateKind::Adt(_, variant, _, _) = *kind {\n+                        if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n                             if nonnull.packed {\n                                 let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0;\n                                 self.memory.mark_packed(ptr, nonnull.stride().bytes());\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     CEnum { .. } => {\n                         assert_eq!(operands.len(), 0);\n-                        if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n+                        if let mir::AggregateKind::Adt(adt_def, variant, _, _) = **kind {\n                             let n = adt_def.discriminants(self.tcx)\n                                 .nth(variant)\n                                 .expect(\"broken mir: Adt variant index invalid\")\n@@ -997,8 +997,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n \n-            Constant(mir::Constant { ref literal, .. }) => {\n+            Constant(ref constant) => {\n                 use rustc::mir::Literal;\n+                let mir::Constant { ref literal, .. } = **constant;\n                 let value = match *literal {\n                     Literal::Value { ref value } => self.const_to_value(value)?,\n "}]}