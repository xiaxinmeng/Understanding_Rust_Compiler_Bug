{"sha": "7b901f86cd1d0198994e5a2ab7eea18f444dd148", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiOTAxZjg2Y2QxZDAxOTg5OTRlNWEyYWI3ZWVhMThmNDQ0ZGQxNDg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-23T14:37:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-23T14:37:10Z"}, "message": "move SyntaxPtr to ra_syntax", "tree": {"sha": "dfe8364efeeaca6f8f32e1d922fb615119b8012b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfe8364efeeaca6f8f32e1d922fb615119b8012b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b901f86cd1d0198994e5a2ab7eea18f444dd148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b901f86cd1d0198994e5a2ab7eea18f444dd148", "html_url": "https://github.com/rust-lang/rust/commit/7b901f86cd1d0198994e5a2ab7eea18f444dd148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b901f86cd1d0198994e5a2ab7eea18f444dd148/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81fcfc55d247bfe6090741f2e4ae9aa89947bf32", "url": "https://api.github.com/repos/rust-lang/rust/commits/81fcfc55d247bfe6090741f2e4ae9aa89947bf32", "html_url": "https://github.com/rust-lang/rust/commit/81fcfc55d247bfe6090741f2e4ae9aa89947bf32"}], "stats": {"total": 217, "additions": 109, "deletions": 108}, "files": [{"sha": "32d7e09b999cbb96fba2d3b5394c23a636c06d41", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -1,6 +1,5 @@\n //! ra_db defines basic database traits. The concrete DB is defined by ra_ide_api.\n mod cancellation;\n-mod syntax_ptr;\n mod input;\n mod loc2id;\n pub mod mock;\n@@ -12,7 +11,6 @@ use ra_syntax::{TextUnit, TextRange, SourceFile, TreeArc};\n pub use ::salsa as salsa;\n pub use crate::{\n     cancellation::Canceled,\n-    syntax_ptr::LocalSyntaxPtr,\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,\n         FileTextQuery, FileSourceRootQuery, SourceRootQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,"}, {"sha": "5270826da363619768d951c9da4deabfe9879817", "filename": "crates/ra_db/src/syntax_ptr.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/81fcfc55d247bfe6090741f2e4ae9aa89947bf32/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fcfc55d247bfe6090741f2e4ae9aa89947bf32/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs?ref=81fcfc55d247bfe6090741f2e4ae9aa89947bf32", "patch": "@@ -1,52 +0,0 @@\n-use ra_syntax::{AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, TreeArc};\n-\n-/// A pointer to a syntax node inside a file.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LocalSyntaxPtr {\n-    range: TextRange,\n-    kind: SyntaxKind,\n-}\n-\n-impl LocalSyntaxPtr {\n-    pub fn new(node: &SyntaxNode) -> LocalSyntaxPtr {\n-        LocalSyntaxPtr {\n-            range: node.range(),\n-            kind: node.kind(),\n-        }\n-    }\n-\n-    pub fn resolve(self, file: &SourceFile) -> TreeArc<SyntaxNode> {\n-        let mut curr = file.syntax();\n-        loop {\n-            if curr.range() == self.range && curr.kind() == self.kind {\n-                return curr.to_owned();\n-            }\n-            curr = curr\n-                .children()\n-                .find(|it| self.range.is_subrange(&it.range()))\n-                .unwrap_or_else(|| panic!(\"can't resolve local ptr to SyntaxNode: {:?}\", self))\n-        }\n-    }\n-\n-    pub fn range(self) -> TextRange {\n-        self.range\n-    }\n-\n-    pub fn kind(self) -> SyntaxKind {\n-        self.kind\n-    }\n-}\n-\n-#[test]\n-fn test_local_syntax_ptr() {\n-    use ra_syntax::{ast, AstNode};\n-    let file = SourceFile::parse(\"struct Foo { f: u32, }\");\n-    let field = file\n-        .syntax()\n-        .descendants()\n-        .find_map(ast::NamedFieldDef::cast)\n-        .unwrap();\n-    let ptr = LocalSyntaxPtr::new(field.syntax());\n-    let field_syntax = ptr.resolve(&file);\n-    assert_eq!(field.syntax(), &*field_syntax);\n-}"}, {"sha": "c5d1de5eb58ad75835ee3c0fde7617315c36d247", "filename": "crates/ra_hir/src/code_model_impl/function/scope.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction%2Fscope.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -3,12 +3,11 @@ use std::sync::Arc;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SyntaxNode, TextUnit, TextRange,\n+    AstNode, SyntaxNode, TextUnit, TextRange, SyntaxNodePtr,\n     algo::generate,\n     ast,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n-use ra_db::LocalSyntaxPtr;\n \n use crate::{Name, AsName, expr::{PatId, ExprId, Pat, Expr, Body, Statement, BodySyntaxMapping}};\n \n@@ -126,15 +125,15 @@ pub struct ScopesWithSyntaxMapping {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ScopeEntryWithSyntax {\n     name: Name,\n-    ptr: LocalSyntaxPtr,\n+    ptr: SyntaxNodePtr,\n }\n \n impl ScopeEntryWithSyntax {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n \n-    pub fn ptr(&self) -> LocalSyntaxPtr {\n+    pub fn ptr(&self) -> SyntaxNodePtr {\n         self.ptr\n     }\n }\n@@ -169,7 +168,7 @@ impl ScopesWithSyntaxMapping {\n \n     // XXX: during completion, cursor might be outside of any particular\n     // expression. Try to figure out the correct scope...\n-    fn adjust(&self, ptr: LocalSyntaxPtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n+    fn adjust(&self, ptr: SyntaxNodePtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n         let r = ptr.range();\n         let child_scopes = self\n             .scopes\n@@ -212,7 +211,7 @@ impl ScopesWithSyntaxMapping {\n \n     pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n+        let name_ptr = SyntaxNodePtr::new(pat.syntax());\n         fn_def\n             .syntax()\n             .descendants()\n@@ -230,7 +229,7 @@ impl ScopesWithSyntaxMapping {\n \n     fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n         node.ancestors()\n-            .map(LocalSyntaxPtr::new)\n+            .map(SyntaxNodePtr::new)\n             .filter_map(|ptr| self.syntax_mapping.syntax_expr(ptr))\n             .find_map(|it| self.scopes.scope_for(it))\n     }"}, {"sha": "1a3821692233a6fb868c8a2d5a9640bbd043ac1c", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -4,8 +4,10 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n-use ra_db::LocalSyntaxPtr;\n-use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor};\n+use ra_syntax::{\n+    SyntaxNodePtr, AstNode,\n+    ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor}\n+};\n \n use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n@@ -38,10 +40,10 @@ pub struct Body {\n #[derive(Debug, Eq, PartialEq)]\n pub struct BodySyntaxMapping {\n     body: Arc<Body>,\n-    expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n-    expr_syntax_mapping_back: ArenaMap<ExprId, LocalSyntaxPtr>,\n-    pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n-    pat_syntax_mapping_back: ArenaMap<PatId, LocalSyntaxPtr>,\n+    expr_syntax_mapping: FxHashMap<SyntaxNodePtr, ExprId>,\n+    expr_syntax_mapping_back: ArenaMap<ExprId, SyntaxNodePtr>,\n+    pat_syntax_mapping: FxHashMap<SyntaxNodePtr, PatId>,\n+    pat_syntax_mapping_back: ArenaMap<PatId, SyntaxNodePtr>,\n }\n \n impl Body {\n@@ -71,31 +73,31 @@ impl Index<PatId> for Body {\n }\n \n impl BodySyntaxMapping {\n-    pub fn expr_syntax(&self, expr: ExprId) -> Option<LocalSyntaxPtr> {\n+    pub fn expr_syntax(&self, expr: ExprId) -> Option<SyntaxNodePtr> {\n         self.expr_syntax_mapping_back.get(expr).cloned()\n     }\n \n-    pub fn syntax_expr(&self, ptr: LocalSyntaxPtr) -> Option<ExprId> {\n+    pub fn syntax_expr(&self, ptr: SyntaxNodePtr) -> Option<ExprId> {\n         self.expr_syntax_mapping.get(&ptr).cloned()\n     }\n \n     pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n         self.expr_syntax_mapping\n-            .get(&LocalSyntaxPtr::new(node.syntax()))\n+            .get(&SyntaxNodePtr::new(node.syntax()))\n             .cloned()\n     }\n \n-    pub fn pat_syntax(&self, pat: PatId) -> Option<LocalSyntaxPtr> {\n+    pub fn pat_syntax(&self, pat: PatId) -> Option<SyntaxNodePtr> {\n         self.pat_syntax_mapping_back.get(pat).cloned()\n     }\n \n-    pub fn syntax_pat(&self, ptr: LocalSyntaxPtr) -> Option<PatId> {\n+    pub fn syntax_pat(&self, ptr: SyntaxNodePtr) -> Option<PatId> {\n         self.pat_syntax_mapping.get(&ptr).cloned()\n     }\n \n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_syntax_mapping\n-            .get(&LocalSyntaxPtr::new(node.syntax()))\n+            .get(&SyntaxNodePtr::new(node.syntax()))\n             .cloned()\n     }\n \n@@ -440,10 +442,10 @@ pub(crate) fn body_hir(db: &impl HirDatabase, def_id: DefId) -> Arc<Body> {\n struct ExprCollector {\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n-    expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n-    expr_syntax_mapping_back: ArenaMap<ExprId, LocalSyntaxPtr>,\n-    pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n-    pat_syntax_mapping_back: ArenaMap<PatId, LocalSyntaxPtr>,\n+    expr_syntax_mapping: FxHashMap<SyntaxNodePtr, ExprId>,\n+    expr_syntax_mapping_back: ArenaMap<ExprId, SyntaxNodePtr>,\n+    pat_syntax_mapping: FxHashMap<SyntaxNodePtr, PatId>,\n+    pat_syntax_mapping_back: ArenaMap<PatId, SyntaxNodePtr>,\n }\n \n impl ExprCollector {\n@@ -458,14 +460,14 @@ impl ExprCollector {\n         }\n     }\n \n-    fn alloc_expr(&mut self, expr: Expr, syntax_ptr: LocalSyntaxPtr) -> ExprId {\n+    fn alloc_expr(&mut self, expr: Expr, syntax_ptr: SyntaxNodePtr) -> ExprId {\n         let id = self.exprs.alloc(expr);\n         self.expr_syntax_mapping.insert(syntax_ptr, id);\n         self.expr_syntax_mapping_back.insert(id, syntax_ptr);\n         id\n     }\n \n-    fn alloc_pat(&mut self, pat: Pat, syntax_ptr: LocalSyntaxPtr) -> PatId {\n+    fn alloc_pat(&mut self, pat: Pat, syntax_ptr: SyntaxNodePtr) -> PatId {\n         let id = self.pats.alloc(pat);\n         self.pat_syntax_mapping.insert(syntax_ptr, id);\n         self.pat_syntax_mapping_back.insert(id, syntax_ptr);\n@@ -481,7 +483,7 @@ impl ExprCollector {\n     }\n \n     fn collect_expr(&mut self, expr: &ast::Expr) -> ExprId {\n-        let syntax_ptr = LocalSyntaxPtr::new(expr.syntax());\n+        let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n                 if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n@@ -643,9 +645,9 @@ impl ExprCollector {\n                                 // field shorthand\n                                 let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n                                 self.expr_syntax_mapping\n-                                    .insert(LocalSyntaxPtr::new(nr.syntax()), id);\n+                                    .insert(SyntaxNodePtr::new(nr.syntax()), id);\n                                 self.expr_syntax_mapping_back\n-                                    .insert(id, LocalSyntaxPtr::new(nr.syntax()));\n+                                    .insert(id, SyntaxNodePtr::new(nr.syntax()));\n                                 id\n                             } else {\n                                 self.exprs.alloc(Expr::Missing)\n@@ -806,7 +808,7 @@ impl ExprCollector {\n         let tail = block.expr().map(|e| self.collect_expr(e));\n         self.alloc_expr(\n             Expr::Block { statements, tail },\n-            LocalSyntaxPtr::new(block.syntax()),\n+            SyntaxNodePtr::new(block.syntax()),\n         )\n     }\n \n@@ -883,7 +885,7 @@ impl ExprCollector {\n             // TODO: implement\n             ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n         };\n-        let syntax_ptr = LocalSyntaxPtr::new(pat.syntax());\n+        let syntax_ptr = SyntaxNodePtr::new(pat.syntax());\n         self.alloc_pat(pattern, syntax_ptr)\n     }\n \n@@ -919,7 +921,7 @@ pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n         let mut params = Vec::new();\n \n         if let Some(self_param) = param_list.self_param() {\n-            let self_param = LocalSyntaxPtr::new(\n+            let self_param = SyntaxNodePtr::new(\n                 self_param\n                     .self_kw()\n                     .expect(\"self param without self keyword\")"}, {"sha": "7ca34d434511d670a5ae22bb38943ca3d6a4a842", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -9,9 +9,8 @@\n /// those yet, so all macros are string based at the moment!\n use std::sync::Arc;\n \n-use ra_db::LocalSyntaxPtr;\n use ra_syntax::{\n-    TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreeArc,\n+    TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreeArc, SyntaxNodePtr,\n     ast::{self, NameOwner},\n };\n \n@@ -80,7 +79,7 @@ impl MacroDef {\n         let file = SourceFile::parse(&text);\n         let match_expr = file.syntax().descendants().find_map(ast::MatchExpr::cast)?;\n         let match_arg = match_expr.expr()?;\n-        let ptr = LocalSyntaxPtr::new(match_arg.syntax());\n+        let ptr = SyntaxNodePtr::new(match_arg.syntax());\n         let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n         let ranges_map = vec![(src_range, match_arg.syntax().range())];\n         let res = MacroExpansion {\n@@ -94,7 +93,7 @@ impl MacroDef {\n         let text = format!(r\"fn dummy() {{ {}; }}\", input.text);\n         let file = SourceFile::parse(&text);\n         let array_expr = file.syntax().descendants().find_map(ast::ArrayExpr::cast)?;\n-        let ptr = LocalSyntaxPtr::new(array_expr.syntax());\n+        let ptr = SyntaxNodePtr::new(array_expr.syntax());\n         let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n         let ranges_map = vec![(src_range, array_expr.syntax().range())];\n         let res = MacroExpansion {\n@@ -119,7 +118,7 @@ impl MacroDef {\n         let file = SourceFile::parse(&text);\n         let trait_def = file.syntax().descendants().find_map(ast::TraitDef::cast)?;\n         let name = trait_def.name()?;\n-        let ptr = LocalSyntaxPtr::new(trait_def.syntax());\n+        let ptr = SyntaxNodePtr::new(trait_def.syntax());\n         let ranges_map = vec![(src_range, name.syntax().range())];\n         let res = MacroExpansion {\n             text,\n@@ -146,7 +145,7 @@ pub struct MacroExpansion {\n     /// Implementation detail: internally, a macro is expanded to the whole file,\n     /// even if it is an expression. This `ptr` selects the actual expansion from\n     /// the expanded file.\n-    ptr: LocalSyntaxPtr,\n+    ptr: SyntaxNodePtr,\n }\n \n impl MacroExpansion {\n@@ -157,7 +156,7 @@ impl MacroExpansion {\n     }\n \n     pub fn syntax(&self) -> TreeArc<SyntaxNode> {\n-        self.ptr.resolve(&self.file())\n+        self.ptr.to_node(&self.file()).to_owned()\n     }\n     /// Maps range in the source code to the range in the expanded code.\n     pub fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {"}, {"sha": "ab6f3a9bceba4f1721ebbc7078eda64a0b6a76ae", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    SyntaxKind, AstNode, SourceFile, TreeArc,\n+    SyntaxKind, AstNode, SourceFile, TreeArc, SyntaxNodePtr,\n     ast::{self, ModuleItemOwner},\n };\n-use ra_db::{SourceRootId, LocalSyntaxPtr};\n+use ra_db::{SourceRootId};\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n \n use crate::{\n@@ -72,13 +72,13 @@ pub struct LoweredModule {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImportSourceMap {\n-    map: ArenaMap<ImportId, LocalSyntaxPtr>,\n+    map: ArenaMap<ImportId, SyntaxNodePtr>,\n }\n \n impl ImportSourceMap {\n     fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n         self.map\n-            .insert(import, LocalSyntaxPtr::new(segment.syntax()))\n+            .insert(import, SyntaxNodePtr::new(segment.syntax()))\n     }\n \n     pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n@@ -87,7 +87,7 @@ impl ImportSourceMap {\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n-        ast::PathSegment::cast(&self.map[import].resolve(file))\n+        ast::PathSegment::cast(self.map[import].to_node(file))\n             .unwrap()\n             .to_owned()\n     }"}, {"sha": "92c74cf00828ef61682a8dd322c8a0725f64400d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -562,7 +562,7 @@ fn infer(content: &str) -> String {\n         // sort ranges for consistency\n         types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n         for (syntax_ptr, ty) in &types {\n-            let node = syntax_ptr.resolve(&source_file);\n+            let node = syntax_ptr.to_node(&source_file);\n             write!(\n                 acc,\n                 \"{} '{}': {}\\n\","}, {"sha": "0449c1902acd111b51cf2e91a2ad8345ac48c9d7", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -23,8 +23,8 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n         .into_iter()\n         .find(|it| it.ptr.kind() == FN_DEF)?;\n     let fn_file = db.source_file(symbol.file_id);\n-    let fn_def = symbol.ptr.resolve(&fn_file);\n-    let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n+    let fn_def = symbol.ptr.to_node(&fn_file);\n+    let fn_def = ast::FnDef::cast(fn_def).unwrap();\n     let mut call_info = CallInfo::new(fn_def)?;\n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters.len();"}, {"sha": "ddd9354ecb562b3ac872e80fa6d519a487dfeb54", "filename": "crates/ra_ide_api/src/imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimp.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -153,7 +153,7 @@ impl db::RootDatabase {\n                 source_binder::function_from_child_node(db, position.file_id, name_ref.syntax())?;\n             let scope = descr.scopes(db);\n             let resolved = scope.resolve_local_name(name_ref)?;\n-            let resolved = resolved.ptr().resolve(source_file);\n+            let resolved = resolved.ptr().to_node(source_file);\n             let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n             Some((binding, descr))\n         }"}, {"sha": "1b5d1eb1d46b93baab059a95adc169566cff358c", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -27,13 +27,13 @@ use std::{\n \n use fst::{self, Streamer};\n use ra_syntax::{\n-    SyntaxNode, SourceFile, SmolStr, TreeArc, AstNode,\n+    SyntaxNode, SyntaxNodePtr, SourceFile, SmolStr, TreeArc, AstNode,\n     algo::{visit::{visitor, Visitor}, find_covering_node},\n     SyntaxKind::{self, *},\n     ast::{self, NameOwner},\n };\n use ra_db::{\n-    SourceRootId, FilesDatabase, LocalSyntaxPtr,\n+    SourceRootId, FilesDatabase,\n     salsa::{self, ParallelDatabase},\n };\n use rayon::prelude::*;\n@@ -62,7 +62,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n \n     for (name, text_range) in hir::source_binder::macro_symbols(db, file_id) {\n         let node = find_covering_node(source_file.syntax(), text_range);\n-        let ptr = LocalSyntaxPtr::new(node);\n+        let ptr = SyntaxNodePtr::new(node);\n         symbols.push(FileSymbol { file_id, name, ptr })\n     }\n \n@@ -196,13 +196,13 @@ fn is_type(kind: SyntaxKind) -> bool {\n pub(crate) struct FileSymbol {\n     pub(crate) file_id: FileId,\n     pub(crate) name: SmolStr,\n-    pub(crate) ptr: LocalSyntaxPtr,\n+    pub(crate) ptr: SyntaxNodePtr,\n }\n \n-fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, LocalSyntaxPtr)> {\n-    fn decl<N: NameOwner>(node: &N) -> Option<(SmolStr, LocalSyntaxPtr)> {\n+fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, SyntaxNodePtr)> {\n+    fn decl<N: NameOwner>(node: &N) -> Option<(SmolStr, SyntaxNodePtr)> {\n         let name = node.name()?.text().clone();\n-        let ptr = LocalSyntaxPtr::new(node.syntax());\n+        let ptr = SyntaxNodePtr::new(node.syntax());\n         Some((name, ptr))\n     }\n     visitor()"}, {"sha": "97b196118ce9ce7191a49c55b7d11f7bc12e62a7", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -35,13 +35,15 @@ mod syntax_kinds;\n pub mod utils;\n mod validation;\n mod yellow;\n+mod ptr;\n \n pub use rowan::{SmolStr, TextRange, TextUnit};\n pub use crate::{\n     ast::AstNode,\n     lexer::{tokenize, Token},\n     syntax_kinds::SyntaxKind,\n     yellow::{Direction, SyntaxError, SyntaxNode, WalkEvent, Location, TreeArc},\n+    ptr::SyntaxNodePtr,\n };\n \n use ra_text_edit::AtomTextEdit;"}, {"sha": "e8c40e5d3ebd4dfe8b1c5d54c01438ef2af54ce1", "filename": "crates/ra_syntax/src/ptr.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b901f86cd1d0198994e5a2ab7eea18f444dd148/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=7b901f86cd1d0198994e5a2ab7eea18f444dd148", "patch": "@@ -0,0 +1,53 @@\n+use crate::{\n+    AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n+    algo::generate,\n+};\n+\n+/// A pointer to a syntax node inside a file. It can be used to remember a\n+/// specific node across reparses of the same file.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SyntaxNodePtr {\n+    range: TextRange,\n+    kind: SyntaxKind,\n+}\n+\n+impl SyntaxNodePtr {\n+    pub fn new(node: &SyntaxNode) -> SyntaxNodePtr {\n+        SyntaxNodePtr {\n+            range: node.range(),\n+            kind: node.kind(),\n+        }\n+    }\n+\n+    pub fn to_node(self, source_file: &SourceFile) -> &SyntaxNode {\n+        generate(Some(source_file.syntax()), |&node| {\n+            node.children()\n+                .find(|it| self.range.is_subrange(&it.range()))\n+        })\n+        .find(|it| it.range() == self.range && it.kind() == self.kind)\n+        .unwrap_or_else(|| panic!(\"can't resolve local ptr to SyntaxNode: {:?}\", self))\n+    }\n+\n+    pub fn range(self) -> TextRange {\n+        self.range\n+    }\n+\n+    pub fn kind(self) -> SyntaxKind {\n+        self.kind\n+    }\n+}\n+\n+#[test]\n+fn test_local_syntax_ptr() {\n+    use crate::{ast, AstNode};\n+\n+    let file = SourceFile::parse(\"struct Foo { f: u32, }\");\n+    let field = file\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::NamedFieldDef::cast)\n+        .unwrap();\n+    let ptr = SyntaxNodePtr::new(field.syntax());\n+    let field_syntax = ptr.to_node(&file);\n+    assert_eq!(field.syntax(), &*field_syntax);\n+}"}]}