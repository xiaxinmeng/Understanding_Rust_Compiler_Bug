{"sha": "8f171c49ceaf16b1a81125ad9788c9dae70d2111", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMTcxYzQ5Y2VhZjE2YjFhODExMjVhZDk3ODhjOWRhZTcwZDIxMTE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-07-11T11:27:41Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-07-12T09:44:58Z"}, "message": "Replace `struct_tail` and `struct_lockstep_tails` with variants handling normalization.\n\nThe old struct tail functions did not deal with `<T as Trait>::A` and `impl\nTrait`, at least not explicitly. (We didn't notice this bug before because it\nis only exposed when the tail (post deep normalization) is not `Sized`, so it\nwas a rare case to deal with.)\n\nFor post type-checking (i.e. during codegen), there is now\n`struct_tail_erasing_lifetimes` and `struct_lockstep_tails_erasing_lifetimes`,\nwhich each take an additional `ParamEnv` argument to drive normalization.\n\nFor pre type-checking cases where normalization is not needed, there is\n`struct_tail_without_normalization`. (Currently, the only instance of this is\n`Expectation::rvalue_hint`.)\n\nAll of these new entrypoints work by calling out to common helper routines.\nThe helpers are parameterized over a closure that handles the normalization.", "tree": {"sha": "deb9ab3635d7186a0dd4843e36f7bf893e09bba3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deb9ab3635d7186a0dd4843e36f7bf893e09bba3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f171c49ceaf16b1a81125ad9788c9dae70d2111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f171c49ceaf16b1a81125ad9788c9dae70d2111", "html_url": "https://github.com/rust-lang/rust/commit/8f171c49ceaf16b1a81125ad9788c9dae70d2111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f171c49ceaf16b1a81125ad9788c9dae70d2111/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0324a2b309cd66cb7bd4a156bd0b84cb136e254f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0324a2b309cd66cb7bd4a156bd0b84cb136e254f", "html_url": "https://github.com/rust-lang/rust/commit/0324a2b309cd66cb7bd4a156bd0b84cb136e254f"}], "stats": {"total": 133, "additions": 111, "deletions": 22}, "files": [{"sha": "4ed52a1e96638a88059d59b2fbd27bdd128f5748", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                 }\n \n-                let unsized_part = tcx.struct_tail(pointee);\n+                let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 let metadata = match unsized_part.sty {\n                     ty::Foreign(..) => {\n                         return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n@@ -1664,7 +1664,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             ty::Ref(_, pointee, _) |\n             ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n-                let tail = tcx.struct_tail(pointee);\n+                let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types() || tail.has_self_ty());\n@@ -2015,7 +2015,7 @@ where\n                     }));\n                 }\n \n-                match tcx.struct_tail(pointee).sty {\n+                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).sty {\n                     ty::Slice(_) |\n                     ty::Str => tcx.types.usize,\n                     ty::Dynamic(_, _) => {"}, {"sha": "871aeb78af5173ca3020ac8ce514413f47dbde3b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -258,10 +258,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         false\n     }\n \n-    /// Returns the deeply last field of nested structures, or the same type,\n-    /// if not a structure at all. Corresponds to the only possible unsized\n-    /// field, and its type can be used to determine unsizing strategy.\n-    pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    /// Attempts to returns the deeply last field of nested structures, but\n+    /// does not apply any normalization in its search. Returns the same type\n+    /// if input `ty` is not a structure at all.\n+    pub fn struct_tail_without_normalization(self, ty: Ty<'tcx>) -> Ty<'tcx>\n+    {\n+        let tcx = self;\n+        tcx.struct_tail_with_normalize(ty, |ty| ty)\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    pub fn struct_tail_erasing_lifetimes(self,\n+                                         ty: Ty<'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>)\n+                                         -> Ty<'tcx>\n+    {\n+        let tcx = self;\n+        tcx.struct_tail_with_normalize(ty, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+    }\n+\n+    /// Returns the deeply last field of nested structures, or the same type if\n+    /// not a structure at all. Corresponds to the only possible unsized field,\n+    /// and its type can be used to determine unsizing strategy.\n+    ///\n+    /// This is parameterized over the normalization strategy (i.e. how to\n+    /// handle `<T as Trait>::Assoc` and `impl Trait`); pass the identity\n+    /// function to indicate no normalization should take place.\n+    ///\n+    /// See also `struct_tail_erasing_lifetimes`, which is what callers running\n+    /// after type checking should use.\n+    pub fn struct_tail_with_normalize(self,\n+                                      mut ty: Ty<'tcx>,\n+                                      normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>)\n+                                      -> Ty<'tcx>\n+    {\n         loop {\n             match ty.sty {\n                 ty::Adt(def, substs) => {\n@@ -282,6 +314,15 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n+                ty::Projection(_) | ty::Opaque(..) => {\n+                    let normalized = normalize(ty);\n+                    if ty == normalized {\n+                        return ty;\n+                    } else {\n+                        ty = normalized;\n+                    }\n+                }\n+\n                 _ => {\n                     break;\n                 }\n@@ -295,10 +336,34 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n-    pub fn struct_lockstep_tails(self,\n-                                 source: Ty<'tcx>,\n-                                 target: Ty<'tcx>)\n-                                 -> (Ty<'tcx>, Ty<'tcx>) {\n+    ///\n+    /// Must only be called after type-checking is complete; otherwise\n+    /// normalization attempt may cause compiler bugs.\n+    pub fn struct_lockstep_tails_erasing_lifetimes(self,\n+                                                   source: Ty<'tcx>,\n+                                                   target: Ty<'tcx>,\n+                                                   param_env: ty::ParamEnv<'tcx>)\n+                                                   -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n+        let tcx = self;\n+        tcx.struct_lockstep_tails_with_normalize(\n+            source, target, |ty| tcx.normalize_erasing_regions(param_env, ty))\n+    }\n+\n+    /// Same as applying struct_tail on `source` and `target`, but only\n+    /// keeps going as long as the two types are instances of the same\n+    /// structure definitions.\n+    /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n+    /// whereas struct_tail produces `T`, and `Trait`, respectively.\n+    ///\n+    /// See also struct_lockstep_tails_erasing_lifetimes, which\n+    /// is what callers running after type checking should use.\n+    pub fn struct_lockstep_tails_with_normalize(self,\n+                                                source: Ty<'tcx>,\n+                                                target: Ty<'tcx>,\n+                                                normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>)\n+                                                -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.sty, &b.sty) {\n@@ -320,6 +385,22 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 },\n+                (ty::Projection(_), _) | (ty::Opaque(..), _) |\n+                (_, ty::Projection(_)) | (_, ty::Opaque(..)) => {\n+                    // If either side is a projection, attempt to\n+                    // progress via normalization. (Should be safe to\n+                    // apply to both sides as normalization is\n+                    // idempotent.)\n+                    let a_norm = normalize(a);\n+                    let b_norm = normalize(b);\n+                    if a == a_norm && b == b_norm {\n+                        break;\n+                    } else {\n+                        a = a_norm;\n+                        b = b_norm;\n+                    }\n+                }\n+\n                 _ => break,\n             }\n         }"}, {"sha": "00471095f2f3517efcba016c7b74307bfe4fdba7", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -128,7 +128,8 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n     target: Ty<'tcx>,\n     old_info: Option<Cx::Value>,\n ) -> Cx::Value {\n-    let (source, target) = cx.tcx().struct_lockstep_tails(source, target);\n+    let (source, target) =\n+        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n     match (&source.sty, &target.sty) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.unwrap_usize(cx.tcx()))"}, {"sha": "13f72e23819a1ac9b62df9b4141225ee7acaaa6c", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -77,11 +77,12 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+        let param_env = ty::ParamEnv::reveal_all();\n+        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n             return false;\n         }\n \n-        let tail = self.tcx().struct_tail(ty);\n+        let tail = self.tcx().struct_tail_erasing_lifetimes(ty, param_env);\n         match tail.sty {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,"}, {"sha": "980697360eb7574e95778f7dca4374f89323f723", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -270,7 +270,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dty: Ty<'tcx>,\n     ) -> InterpResult<'tcx> {\n         // A<Struct> -> A<Trait> conversion\n-        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+        let (src_pointee_ty, dest_pointee_ty) =\n+            self.tcx.struct_lockstep_tails_erasing_lifetimes(sty, dty, self.param_env);\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {"}, {"sha": "bcd36ac547c730525d2e0c5a13d7acee428362a5", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -146,7 +146,9 @@ for\n             let value = self.ecx.read_immediate(mplace.into())?;\n             // Handle trait object vtables\n             if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) = self.ecx.tcx.struct_tail(referenced_ty).sty {\n+                if let ty::Dynamic(..) =\n+                    self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.param_env).sty\n+                {\n                     if let Ok(vtable) = meta.unwrap().to_ptr() {\n                         // explitly choose `Immutable` here, since vtables are immutable, even\n                         // if the reference of the fat pointer is mutable"}, {"sha": "423fd9036bf71bed9eae391ff455ec7724767f18", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -361,7 +361,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     \"uninitialized data in fat pointer metadata\", self.path);\n                 let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.ecx.tcx.struct_tail(layout.ty);\n+                    let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(layout.ty,\n+                                                                          self.ecx.param_env);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = meta.unwrap();"}, {"sha": "6e9390f77508bc4a2499636dccd9c7c2bbf37a45", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -851,12 +851,13 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     target_ty: Ty<'tcx>,\n ) -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n+        let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n-            if ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+            if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n                 return false;\n             }\n-            let tail = tcx.struct_tail(ty);\n+            let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n             match tail.sty {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n@@ -866,7 +867,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n         if type_has_metadata(inner_source) {\n             (inner_source, inner_target)\n         } else {\n-            tcx.struct_lockstep_tails(inner_source, inner_target)\n+            tcx.struct_lockstep_tails_erasing_lifetimes(inner_source, inner_target, param_env)\n         }\n     };\n "}, {"sha": "c35136ad6df94a15c224b18203d2b01c522e3e70", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx.struct_tail(ty).sty {\n+        match fcx.tcx.struct_tail_without_normalization(ty).sty {\n             ty::Slice(_) | ty::Str | ty::Dynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }"}, {"sha": "68e5e7d4fd2454176bf54c1d014ceaa02846b31c", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f171c49ceaf16b1a81125ad9788c9dae70d2111/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8f171c49ceaf16b1a81125ad9788c9dae70d2111", "patch": "@@ -366,7 +366,8 @@ fn check_item_type(\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n-            if let ty::Foreign(_) = fcx.tcx.struct_tail(item_ty).sty {\n+            let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n+            if let ty::Foreign(_) = tail.sty {\n                 forbid_unsized = false;\n             }\n         }"}]}