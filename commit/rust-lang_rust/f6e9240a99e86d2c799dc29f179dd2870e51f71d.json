{"sha": "f6e9240a99e86d2c799dc29f179dd2870e51f71d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZTkyNDBhOTllODZkMmM3OTlkYzI5ZjE3OWRkMjg3MGU1MWY3MWQ=", "commit": {"author": {"name": "Mathieu David", "email": "mathieudavid@mathieudavid.org", "date": "2015-07-27T18:46:01Z"}, "committer": {"name": "Mathieu David", "email": "mathieudavid@mathieudavid.org", "date": "2015-07-27T18:46:01Z"}, "message": "Fix the relative path issue by including the files using include_bytes!", "tree": {"sha": "a7e5ba20745b16949a45a4612b2708e262693a7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7e5ba20745b16949a45a4612b2708e262693a7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e9240a99e86d2c799dc29f179dd2870e51f71d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e9240a99e86d2c799dc29f179dd2870e51f71d", "html_url": "https://github.com/rust-lang/rust/commit/f6e9240a99e86d2c799dc29f179dd2870e51f71d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e9240a99e86d2c799dc29f179dd2870e51f71d/comments", "author": {"login": "azerupi", "id": 7647338, "node_id": "MDQ6VXNlcjc2NDczMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/7647338?v=4", "gravatar_id": "", "url": "https://api.github.com/users/azerupi", "html_url": "https://github.com/azerupi", "followers_url": "https://api.github.com/users/azerupi/followers", "following_url": "https://api.github.com/users/azerupi/following{/other_user}", "gists_url": "https://api.github.com/users/azerupi/gists{/gist_id}", "starred_url": "https://api.github.com/users/azerupi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/azerupi/subscriptions", "organizations_url": "https://api.github.com/users/azerupi/orgs", "repos_url": "https://api.github.com/users/azerupi/repos", "events_url": "https://api.github.com/users/azerupi/events{/privacy}", "received_events_url": "https://api.github.com/users/azerupi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "azerupi", "id": 7647338, "node_id": "MDQ6VXNlcjc2NDczMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/7647338?v=4", "gravatar_id": "", "url": "https://api.github.com/users/azerupi", "html_url": "https://github.com/azerupi", "followers_url": "https://api.github.com/users/azerupi/followers", "following_url": "https://api.github.com/users/azerupi/following{/other_user}", "gists_url": "https://api.github.com/users/azerupi/gists{/gist_id}", "starred_url": "https://api.github.com/users/azerupi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/azerupi/subscriptions", "organizations_url": "https://api.github.com/users/azerupi/orgs", "repos_url": "https://api.github.com/users/azerupi/repos", "events_url": "https://api.github.com/users/azerupi/events{/privacy}", "received_events_url": "https://api.github.com/users/azerupi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "003c3eaa62981b791f9eb7bcad015baa1e00d98c", "url": "https://api.github.com/repos/rust-lang/rust/commits/003c3eaa62981b791f9eb7bcad015baa1e00d98c", "html_url": "https://github.com/rust-lang/rust/commit/003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "3351afeecffcc9ebaeb1188a5cde976da8e4a5aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3351afeecffcc9ebaeb1188a5cde976da8e4a5aa", "html_url": "https://github.com/rust-lang/rust/commit/3351afeecffcc9ebaeb1188a5cde976da8e4a5aa"}], "stats": {"total": 46166, "additions": 29528, "deletions": 16638}, "files": [{"sha": "572111bf96158cd3a8ec49e2efb7cbab862637ea", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -19,6 +19,7 @@\n *.exe\n *.fn\n *.html\n+*.kdev4\n *.ky\n *.ll\n *.llvm"}, {"sha": "c1a605bd94c9dc590bd0e1bb5e7adf639e269b7d", "filename": ".mailmap", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,12 +8,13 @@\n Aaron Todd <github@opprobrio.us>\n Abhishek Chanda <abhishek.becs@gmail.com> Abhishek Chanda <abhishek@cloudscaling.com>\n Ahmed Charles <ahmedcharles@gmail.com> <acharles@outlook.com>\n+Aydin Kim <ladinjin@hanmail.net> aydin.kim <aydin.kim@samsung.com>\n Alex Lyon <arcterus@mail.com> <Arcterus@mail.com>\n Alex R\u00f8nne Petersen <alex@lycus.org>\n Andreas Gal <gal@mozilla.com> <andreas.gal@gmail.com>\n Andrew Poelstra <asp11@sfu.ca> <apoelstra@wpsoftware.net>\n Anton L\u00f6fgren <anton.lofgren@gmail.com> <alofgren@op5.com>\n-Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> <ariel.byd@gmail.com>\n+Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> arielb1 <arielb1@mail.tau.ac.il> <ariel.byd@gmail.com>\n Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n Benjamin Jackman <ben@jackman.biz>\n@@ -38,13 +39,15 @@ Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n+Emily Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>\n Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n Eric Holmes <eric@ejholmes.net>\n Eric Reed <ecreed@cs.washington.edu> <ereed@mozilla.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com> <etryzelaar@iqt.org>\n Evgeny Sologubov\n Falco Hirschenberger <falco.hirschenberger@gmail.com> <hirschen@itwm.fhg.de>\n+Felix S. Klock II <pnkfelix@pnkfx.org> Felix S Klock II <pnkfelix@pnkfx.org>\n Gareth Daniel Smith <garethdanielsmith@gmail.com>\n Georges Dubus <georges.dubus@gmail.com> <georges.dubus@compiletoi.net>\n Graham Fawcett <fawcett@uwindsor.ca> <graham.fawcett@gmail.com>\n@@ -64,6 +67,7 @@ Jihyun Yu <jihyun@nclab.kaist.ac.kr> jihyun <jihyun@nablecomm.com>\n Jihyun Yu <jihyun@nclab.kaist.ac.kr> <yjh0502@gmail.com>\n Johann Hofmann <mail@johann-hofmann.com> Johann <git@johann-hofmann.com> Johann Hofmann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n+John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n Jonathan Bailey <jbailey@mozilla.com> <jbailey@jbailey-20809.local>\n Junyoung Cho <june0.cho@samsung.com>\n@@ -80,20 +84,24 @@ Luqman Aden <me@luqman.ca> <laden@csclub.uwaterloo.ca>\n Luke Metz <luke.metz@students.olin.edu>\n Makoto Nakashima <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n Makoto Nakashima <makoto.nksm+github@gmail.com> gifnksm <makoto.nksm+github@gmail.com>\n+Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n Mark Sinclair <mark.edward.x@gmail.com>\n Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n+Matej Lach <matej.lach@gmail.com> Matej \u013dach <matej.lach@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>\n Matthew McPherrin <matthew@mcpherrin.ca> <matt@mcpherrin.ca>\n Matthijs Hofstra <thiezz@gmail.com>\n Michael Williams <m.t.williams@live.com>\n-Michael Woerister <michaelwoerister@gmail> <michaelwoerister@gmail.com>\n-Michael Woerister <michaelwoerister@gmail> <michaelwoerister@posteo>\n+Michael Woerister <michaelwoerister@gmail> <michaelwoerister@gmail.com> <michaelwoerister@posteo> Michael Woerister <michaelwoerister@posteo>\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nicholas Mazzuca <npmazzuca@gmail.com> Nicholas <npmazzuca@gmail.com>\n+Oliver Schneider <github6541940@oli-obk.de> <git1984941651981@oli-obk.de> <git1984941651981@oli-obk.de> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com> gareins <ozbolt.menegatti@gmail.com>\n+Paul Faria <paul_faria@ultimatesoftware.com> Paul Faria <Nashenas88@gmail.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com> parir <peer.aramillo.irizar@gmail.com>\n+Peter Elmers <peter.elmers@yahoo.com> <peter.elmers@rice.edu>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <blei42@gmail.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <bruphili@student.ethz.ch>\n Pradeep Kumar <gohanpra@gmail.com>\n@@ -105,6 +113,7 @@ Robert Foss <dev@robertfoss.se> robertfoss <dev@robertfoss.se>\n Robert Gawdzik <rgawdzik@hotmail.com> Robert Gawdzik \u2622 <rgawdzik@hotmail.com>\n Robert Millar <robert.millar@cantab.net>\n Ryan Scheel <ryan.havvy@gmail.com>\n+Sean Gillespie <sean.william.g@gmail.com> swgillespie <sean.william.g@gmail.com>\n Seonghyun Kim <sh8281.kim@samsung.com>\n Simon Barber-Dueck <sbarberdueck@gmail.com> Simon BD <simon@server>\n Simon Sapin <simon@exyr.org> <simon.sapin@exyr.org>\n@@ -114,7 +123,9 @@ Steven Stewart-Gallus <sstewartgallus00@langara.bc.ca> <sstewartgallus00@mylanga\n Tamir Duberstein <tamird@gmail.com> Tamir Duberstein <tamird@squareup.com>\n Tim Chevalier <chevalier@alum.wellesley.edu> <catamorphism@gmail.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n+Vadim Petrochenkov <vadim.petrochenkov@gmail.com> petrochenkov <vadim.petrochenkov@gmail.com>\n William Ting <io@williamting.com> <william.h.ting@gmail.com>\n+Xuefeng Wu <benewu@gmail.com> Xuefeng Wu <xfwu@thoughtworks.com> XuefengWu <benewu@gmail.com>\n Youngsoo Son <ysson83@gmail.com> <ysoo.son@samsung.com>\n Zack Corr <zack@z0w0.me> <zackcorr95@gmail.com>\n Zack Slayton <zack.slayton@gmail.com>"}, {"sha": "dc955bc2f2be2e3527b553786db41fb2a5b2a1ba", "filename": ".travis.yml", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -1,20 +1,38 @@\n-# Use something that's not 'ruby' so we don't set up things like\n-# RVM/bundler/ruby and whatnot. Right now 'rust' as a language actually\n-# downloads a rust/cargo snapshot, which we don't really want for building rust.\n+# ccache support is disabled unless your language is a C-derivative. However\n+# `language: C` unconditionally sets `CC=compiler`. If we just set it in our\n+# `env` it will be overwritten by the default (gcc 4.6).\n language: c\n+compiler: /usr/bin/gcc-4.7\n+cache: ccache\n sudo: false\n \n # The test suite is in general way too stressful for travis, especially in\n # terms of time limit and reliability. In the past we've tried to scale things\n # back to only build the stage1 compiler and run a subset of tests, but this\n # didn't end up panning out very well.\n #\n-# As a result, we're just using travis to run `make tidy` now. It'll help\n-# everyone find out about their trailing spaces early on!\n+# As a result, we're just using travis to run `make tidy` and *only* build\n+# stage1 but *not* test it for now (a strict subset of the bootstrap). This will\n+# catch \"obvious\" errors like style or not even compiling.\n+#\n+# We need gcc4.7 or higher to build LLVM, and travis (well, Ubuntu 12.04)\n+# currently ships with 4.6. Gotta download our own.\n before_script:\n-  - ./configure --llvm-root=path/to/nowhere\n+  - ./configure --enable-ccache\n script:\n   - make tidy\n+  - make rustc-stage1 -j4\n+\n+env:\n+  - CXX=/usr/bin/g++-4.7\n+\n+addons:\n+  apt:\n+    sources:\n+    - ubuntu-toolchain-r-test\n+    packages:\n+    - gcc-4.7\n+    - g++-4.7\n \n # Real testing happens on http://buildbot.rust-lang.org/\n #"}, {"sha": "60e1a34aecb4dcf4c94849a96972cc063994310e", "filename": "AUTHORS.txt", "status": "modified", "additions": 81, "deletions": 4, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -22,11 +22,13 @@ Aidan Cully <github@aidan.users.panix.com>\n Aidan Hobson Sayers <aidanhs@cantab.net>\n A.J. Gardner <mrhota@users.noreply.github.com>\n Akos Kiss <akiss@inf.u-szeged.hu>\n+Akshay Chiwhane <achiwhane@gmail.com>\n Alan Andrade <alan.andradec@gmail.com>\n Alan Cutter <alancutter@chromium.org>\n Alan Williams <mralert@gmail.com>\n Aleksander Balicki <balicki.aleksander@gmail.com>\n Aleksandr Koshlo <sash7ko@gmail.com>\n+Alexander Artemenko <svetlyak.40wt@gmail.com>\n Alexander Bliskovsky <alexander.bliskovsky@gmail.com>\n Alexander Campbell <alexanderhcampbell@gmail.com>\n Alexander Chernyakhovsky <achernya@mit.edu>\n@@ -44,6 +46,7 @@ Alexis Beingessner <a.beingessner@gmail.com>\n Alex Lyon <arcterus@mail.com>\n Alex Quach <alex@clinkle.com>\n Alex R\u00f8nne Petersen <alex@lycus.org>\n+Alex Stokes <r.alex.stokes@gmail.com>\n Alex Whitney <aw1209@ic.ac.uk>\n Alfie John <alfie@alfie.wtf>\n Alisdair Owens <awo101@zepler.net>\n@@ -66,8 +69,10 @@ Andrew Barchuk <raindev@icloud.com>\n Andrew Cann <shum@canndrew.org>\n Andrew Chin <achin@eminence32.net>\n Andrew Dunham <andrew@du.nham.ca>\n+Andrew Foote <afoote97@gmail.com>\n Andrew Gallant <jamslam@gmail.com>\n Andrew Hobden <andrew@hoverbear.org>\n+Andrew Kensler <andrew@eastfarthing.com>\n Andrew Paseltiner <apaseltiner@gmail.com>\n Andrew Poelstra <asp11@sfu.ca>\n Andrew Seidl <dev@aas.io>\n@@ -93,19 +98,21 @@ Ashok Gautham <ScriptDevil@gmail.com>\n Augusto Hack <hack.augusto@gmail.com>\n auREAX <mark@xn--hwg34fba.ws>\n Austin Bonander <austin.bonander@gmail.com>\n+Austin Hellyer <hello@austinhellyer.me>\n Austin King <shout@ozten.com>\n Austin Seipp <mad.one@gmail.com>\n Avdi Grimm <avdi@avdi.org>\n awlnx <alecweber1994@gmail.com>\n Axel Viala <axel.viala@darnuria.eu>\n-aydin.kim <aydin.kim@samsung.com>\n Aydin Kim <ladinjin@hanmail.net>\n bachm <Ab@vapor.com>\n Barosl Lee <vcs@barosl.com>\n bcoopers <coopersmithbrian@gmail.com>\n Ben Alpert <ben@benalpert.com>\n+benaryorg <binary@benary.org>\n Ben Ashford <ben@bcash.org>\n Ben Blum <bblum@andrew.cmu.edu>\n+ben fleis <ben.fleis@gmail.com>\n Ben Foppa <benjamin.foppa@gmail.com>\n Ben Gamari <bgamari.foss@gmail.com>\n Ben Gesoff <ben.gesoff@gmail.com>\n@@ -128,6 +135,7 @@ Birunthan Mohanathas <birunthan@mohanathas.com>\n Bj\u00f6rn Steinbrink <bsteinbr@gmail.com>\n blake2-ppc <ulrik.sverdrup@gmail.com>\n bluss <bluss>\n+bluss <bluss@users.noreply.github.com>\n Boris Egorov <egorov@linux.com>\n bors <bors@rust-lang.org>\n Bouke van der Bijl <boukevanderbijl@gmail.com>\n@@ -149,6 +157,7 @@ Brian J Brennan <brianloveswords@gmail.com>\n Brian J. Burg <burg@cs.washington.edu>\n Brian Koropoff <bkoropoff@gmail.com>\n Brian Leibig <brian@brianleibig.com>\n+Brian Quinlan <brian@sweetapp.com>\n Bruno de Oliveira Abinader <bruno.d@partner.samsung.com>\n Bryan Dunsmore <dunsmoreb@gmail.com>\n Byron Williams <byron@112percent.com>\n@@ -172,21 +181,25 @@ Ches Martin <ches@whiskeyandgrits.net>\n chitra\n Chloe <5paceToast@users.noreply.github.com>\n Chris Double <chris.double@double.co.nz>\n+Chris Hellmuth <chellmuth@gmail.com>\n Chris Morgan <me@chrismorgan.info>\n Chris Nixon <chris.nixon@sigma.me.uk>\n Chris Peterson <cpeterson@mozilla.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Sainty <csainty@hotmail.com>\n Chris Shea <cmshea@gmail.com>\n Chris Thorn <chris@thorn.co>\n+Christian Stadelmann <dev@genodeftest.de>\n Christoph Burgdorf <christoph.burgdorf@bvsn.org>\n Christopher Bergqvist <spambox0@digitalpoetry.se>\n Christopher Chambers <chris.chambers@peanutcode.com>\n Christopher Kendell <ckendell@outlook.com>\n Chris Wong <lambda.fairy@gmail.com>\n chromatic <chromatic@wgz.org>\n+Chuck Bassett <iamchuckb@gmail.com>\n Chuck Ries <chuck.ries@gmail.com>\n Clark Gaebel <cg.wowus.cg@gmail.com>\n+clatour <chandler.latour@gmail.com>\n Clifford Caoile <piyo@users.sf.net>\n Clinton Ryan <clint.ryan3@gmail.com>\n Cody P Schafer <dev@codyps.com>\n@@ -201,10 +214,12 @@ Conrad Kleinespel <conradk@conradk.com>\n Corey Farwell <coreyf+rust@rwell.org>\n Corey Ford <corey@coreyford.name>\n Corey Richardson <corey@octayn.net>\n+Cornel Punga <cornel.punga@gmail.com>\n crhino <piraino.chris@gmail.com>\n Cristian Kubis <cristian.kubis@tsunix.de>\n Cristi Burc\u0103 <scribu@gmail.com>\n critiqjo <john.ch.fr@gmail.com>\n+Cruz Julian Bishop <cruzjbishop@gmail.com>\n Damian Gryski <damian@gryski.com>\n Damien Grassart <damien@grassart.com>\n Damien Radtke <dradtke@channeliq.com>\n@@ -240,6 +255,7 @@ Darrell Hamilton <darrell.noice@gmail.com>\n Dave Herman <dherman@mozilla.com>\n Dave Hodder <dmh@dmh.org.uk>\n Dave Huseby <dhuseby@mozilla.com>\n+David Campbell <dcampbell24@gmail.com>\n David Creswick <dcrewi@gyrae.net>\n David Forsythe <dforsythe@gmail.com>\n David Halperin <halperin.dr@gmail.com>\n@@ -251,7 +267,9 @@ David Rajchenbach-Teller <dteller@mozilla.com>\n David Reid <dreid@dreid.org>\n David Renshaw <dwrenshaw@gmail.com>\n David Ross <daboross@daboross.net>\n+David Stygstra <david.stygstra@gmail.com>\n David Vazgenovich Shakaryan <dvshakaryan@gmail.com>\n+David Voit <david.voit@gmail.com>\n Davis Silverman <sinistersnare@gmail.com>\n defuz <defuz.net@gmail.com>\n Denis Defreyne <denis.defreyne@stoneship.org>\n@@ -271,6 +289,7 @@ Dirk Leifeld <leifeld@posteo.de>\n Div Shekhar <div@pagerduty.com>\n diwic <diwic@users.noreply.github.com>\n DJUrsus <colinvh@divitu.com>\n+dmgawel <dgkonik@gmail.com>\n Dmitry Ermolov <epdmitry@yandex.ru>\n Dmitry Promsky <dmitry@willworkforcookies.com>\n Dmitry Vasiliev <dima@hlabs.org>\n@@ -290,20 +309,24 @@ Dylan Braithwaite <dylanbraithwaite1@gmail.com>\n Dylan Ede <dylanede@googlemail.com>\n Dzmitry Malyshau <kvarkus@gmail.com>\n Earl St Sauver <estsauver@gmail.com>\n+econoplas <econoplas@gmail.com>\n Eduard Bopp <eduard.bopp@aepsil0n.de>\n Eduard Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com>\n Edward Wang <edward.yu.wang@gmail.com>\n Edward Z. Yang <ezyang@cs.stanford.edu>\n Ehsanul Hoque <ehsanul@ehsanul.com>\n Elantsev Serj <elantsev@yandex-team.ru>\n+Eli Friedman <eli.friedman@gmail.com>\n eliovir <eliovir@gmail.com>\n Elliott Slaughter <elliottslaughter@gmail.com>\n Elly Fong-Jones <elly@leptoquark.net>\n elszben <notgonna@tellyou>\n emanueLczirai <emanueLczirai@cryptoLab.net>\n Emanuel Rylke <ema-fox@web.de>\n Emeliov Dmitrii <demelev1990@gmail.com>\n+Emilio Cobos \u00c1lvarez <ecoal95@gmail.com>\n+Emily Dunham <edunham@mozilla.com>\n Eric Allen <ericpallen@gmail.com>\n Eric Biggers <ebiggers3@gmail.com>\n Eric Holk <eric.holk@gmail.com>\n@@ -314,7 +337,9 @@ Erick Tryzelaar <erick.tryzelaar@gmail.com>\n Eric Martin <e.a.martin1337@gmail.com>\n Eric Platon <eric.platon@waku-waku.ne.jp>\n Eric Reed <ecreed@cs.washington.edu>\n+Eric Ye <me@ericye16.com>\n Erik Lyon <elyon001@local.fake>\n+Erik Michaels-Ober <sferik@gmail.com>\n Erik Price <erik.price16@gmail.com>\n Erik Rose <erik@mozilla.com>\n Erwan <erwan.ricq@gmail.com>\n@@ -344,10 +369,12 @@ Florian Wilkens <mrfloya_github@outlook.com>\n Florian Zeitz <florob@babelmonkeys.de>\n fort <e@mail.com>\n Francisco Souza <f@souza.cc>\n+frankamp <frankamp@gmail.com>\n Franklin Chen <franklinchen@franklinchen.com>\n Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\n free-Runner <aali07@students.poly.edu>\n FuGangqiang <fu_gangqiang@163.com>\n+funkill <funkill2@gmail.com>\n g3xzh <g3xzh@yahoo.com>\n G\u00e1bor Horv\u00e1th <xazax.hun@gmail.com>\n G\u00e1bor Lehel <glaebhoerl@gmail.com>\n@@ -381,6 +408,7 @@ Greg Chapple <gregchapple1@gmail.com>\n Grigoriy <ohaistarlight@gmail.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com>\n Guillaume Pinot <texitoi@texitoi.eu>\n+Gulshan Singh <gsingh2011@gmail.com>\n Gyorgy Andrasek <jurily@gmail.com>\n Haitao Li <lihaitao@gmail.com>\n Hajime Morrita <omo@dodgson.org>\n@@ -419,6 +447,7 @@ Ivano Coppola <rgbfirefox@gmail.com>\n Ivan Petkov <ivanppetkov@gmail.com>\n Ivan Radanov Ivanov <ivanradanov@yahoo.co.uk>\n Ivan Ukhov <ivan.ukhov@gmail.com>\n+Iven Hsu <ivenvd@gmail.com>\n Jack Heizer <jack.heizer@gmail.com>\n Jack Moffitt <jack@metajack.im>\n Jacob Edelman <edelman.jd@gmail.com>\n@@ -428,6 +457,7 @@ Jacob Parker <j3parker@csclub.uwaterloo.ca>\n Jaemin Moon <jaemin.moon@samsung.com>\n Jag Talon <talon.jag@gmail.com>\n Jake Goulding <jake.goulding@gmail.com>\n+Jake Hickey <empty@cqdr.es>\n Jake Kaufman <theevocater@gmail.com>\n Jake Kerr <kodafox@gmail.com>\n Jake Scott <jake.net@gmail.com>\n@@ -439,7 +469,7 @@ James Hurst <jamesrhurst@users.noreply.github.com>\n James Lal <james@lightsofapollo.com>\n James Laverack <james@jameslaverack.com>\n jamesluke <jamesluke@users.noreply.github.com>\n-James Miller <james@aatch.net>\n+James Miller <bladeon@gmail.com>\n James Perry <james.austin.perry@gmail.com>\n James Rowe <jroweboy@gmail.com>\n James Sanders <sanderjd@gmail.com>\n@@ -479,11 +509,13 @@ Jelte Fennema <github-tech@jeltef.nl>\n Jens Nockert <jens@nockert.se>\n Jeong YunWon <jeong@youknowone.org>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jeremy Schlatter <jeremy.schlatter@gmail.com>\n Jesse Jones <jesse9jones@gmail.com>\n Jesse Luehrs <doy@tozt.net>\n Jesse Ray <jesse@localhost.localdomain>\n Jesse Ruderman <jruderman@gmail.com>\n Jessy Diamond Exum <jessy.diamondman@gmail.com>\n+Jexell <Jexell@users.noreply.github.com>\n Jihyeok Seo <me@limeburst.net>\n Jihyun Yu <j.yu@navercorp.com>\n Jim Apple <jbapple+rust@google.com>\n@@ -504,6 +536,7 @@ Johannes L\u00f6thberg <johannes@kyriasis.com>\n Johannes Muenzel <jmuenzel@gmail.com>\n Johannes Oertel <johannes.oertel@uni-due.de>\n Johann Hofmann <git@johann-hofmann.com>\n+Johann Tuffe <tafia973@gmail.com>\n John Albietz <inthecloud247@gmail.com>\n John Barker <jebarker@gmail.com>\n John Clements <clements@racket-lang.org>\n@@ -519,6 +552,7 @@ John Simon <john@johnsoft.com>\n John Talling <inrustwetrust@users.noreply.github.com>\n John Van Enk <vanenkj@gmail.com>\n John Zhang <john@zhang.io>\n+joliv <joliv@users.noreply.github.com>\n Jonas Hietala <tradet.h@gmail.com>\n Jonathan Bailey <jbailey@mozilla.com>\n Jonathan Boyett <jonathan@failingservers.com>\n@@ -545,6 +579,7 @@ Josh Matthews <josh@joshmatthews.net>\n Josh Stone <cuviper@gmail.com>\n Josh Triplett <josh@joshtriplett.org>\n Joshua Clark <joshua.clark@txstate.edu>\n+Joshua Landau <joshua@landau.ws>\n Joshua Wise <joshua@joshuawise.com>\n Joshua Yanovski <pythonesque@gmail.com>\n JP-Ellis <coujellis@gmail.com>\n@@ -586,6 +621,7 @@ KokaKiwi <kokakiwi+rust@kokakiwi.net>\n korenchkin <korenchkin2@gmail.com>\n Kostas Karachalios <vrinek@me.com>\n Krzysztof Drewniak <krzysdrewniak@gmail.com>\n+Kubilay Kocak <koobs@users.noreply.github.com>\n kulakowski <george.kulakowski@gmail.com>\n kwantam <kwantam@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n@@ -601,6 +637,7 @@ Lee Jeffery <leejeffery@gmail.com>\n Lee Wondong <wdlee91@gmail.com>\n LemmingAvalanche <haugsbakk@yahoo.no>\n Lennart Kudling <github@kudling.de>\n+Leo Correa <lcorr005@gmail.com>\n Leonids Maslovs <leonids.maslovs@galeoconsulting.com>\n Leo Testard <leo.testard@gmail.com>\n leunggamciu <gamciuleung@gmail.com>\n@@ -610,6 +647,7 @@ Lindsey Kuper <lindsey@composition.al>\n Lionel Flandrin <lionel.flandrin@parrot.com>\n Logan Chien <tzuhsiang.chien@gmail.com>\n Lo\u00efc Damien <loic.damien@dzamlo.ch>\n+Lorenz <lorenzb@student.ethz.ch>\n lpy <pylaurent1314@gmail.com>\n Luca Bruno <lucab@debian.org>\n lucy <ne.tetewi@gmail.com>\n@@ -629,16 +667,21 @@ maikklein <maikklein@googlemail.com>\n Makoto Nakashima <makoto.nksm+github@gmail.com>\n Manish Goregaokar <manishsmail@gmail.com>\n Manuel Hoffmann <manuel@polythematik.de>\n+marcell <marcell.pardavi@gmail.com>\n+Marcel M\u00fcller <neikos@neikos.email>\n Marcel Rodrigues <marcelgmr@gmail.com>\n+Marcus Klaas <mail@marcusklaas.nl>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu>\n Marijn Haverbeke <marijnh@gmail.com>\n Marin Atanasov Nikolov <dnaeon@gmail.com>\n+M\u00e1rio Feroldi <thelost-t@live.com>\n Mark Lacey <641@rudkx.com>\n Mark Mossberg <mark.mossberg@gmail.com>\n Mark Rowe <mrowe@bdash.net.nz>\n Mark Sinclair <mark.edward.x@gmail.com>\n Markus Siemens <siemens1993@gmail.com>\n Markus Unterwaditzer <markus@unterwaditzer.net>\n+Markus Westerlind <marwes91@gmail.com>\n Mark Vian <mrv.caseus@gmail.com>\n Martin DeMello <martindemello@gmail.com>\n Martin Olsson <martin@minimum.se>\n@@ -648,13 +691,15 @@ Marvin L\u00f6bel <loebel.marvin@gmail.com>\n masklinn <github.com@masklinn.net>\n Matej Lach <matej.lach@gmail.com>\n Mateusz Czapli\u0144ski <czapkofan@gmail.com>\n+Mathieu David <mathieudavid@mathieudavid.org>\n Mathieu Poumeyrol <kali@zoy.org>\n Mathieu Rochette <mathieu@rochette.cc>\n Mathijs van de Nes <git@mathijs.vd-nes.nl>\n Matt Brubeck <mbrubeck@limpet.net>\n Matt Carberry <carberry.matt@gmail.com>\n Matt Coffin <mcoffin13@gmail.com>\n Matt Cox <mattcoxpdx@gmail.com>\n+Matthew Astley <mca@sanger.ac.uk>\n Matthew Auld <matthew.auld@intel.com>\n Matthew Iselin <matthew@theiselins.net>\n Matthew McPherrin <matthew@mcpherrin.ca>\n@@ -670,6 +715,7 @@ M\u00e1ty\u00e1s Mustoha <mmatyas@inf.u-szeged.hu>\n Maxime Quandalle <maxime@quandalle.com>\n Maximilian Haack <mxhaack@gmail.com>\n Maxim Kolganov <kolganov.mv@gmail.com>\n+Max Jacobson <max@hardscrabble.net>\n Max Penet <max.penet@gmail.com>\n Maya Nitu <maya_nitu@yahoo.com>\n mchaput <matt@whoosh.ca>\n@@ -685,7 +731,9 @@ Michael Darakananda <pongad@gmail.com>\n Michael Fairley <michaelfairley@gmail.com>\n Michael Gehring <mg@ebfe.org>\n Michael Kainer <kaini1123@gmail.com>\n+Michael Layzell <michael@thelayzells.com>\n Michael Letterle <michael.letterle@gmail.com>\n+Michael Macias <zaeleus@gmail.com>\n Michael Matuzak <mmatuzak@gmail.com>\n Michael Neumann <mneumann@ntecs.de>\n Michael Pankov <work@michaelpankov.com>\n@@ -715,6 +763,7 @@ Mike Sampson <mike@sambodata.com>\n Mikhail Zabaluev <mikhail.zabaluev@gmail.com>\n Mikko Perttunen <cyndis@kapsi.fi>\n mitchmindtree <mitchell.nordine@gmail.com>\n+Mohammed Attia <skeuomorf@gmail.com>\n moonglum <moonglum@moonbeamlabs.com>\n mrec <mike.capp@gmail.com>\n mr.Shu <mr@shu.io>\n@@ -727,6 +776,7 @@ nathan dotz <nathan.dotz@gmail.com>\n Nathan Froyd <froydnj@gmail.com>\n Nathaniel Herman <nherman@post.harvard.edu>\n Nathaniel Theis <nttheis@gmail.com>\n+Nathan Long <nathanmlong@gmail.com>\n Nathan Stoddard <nstodda@purdue.edu>\n Nathan Typanski <ntypanski@gmail.com>\n Nathan Wilson <wilnathan@gmail.com>\n@@ -739,6 +789,7 @@ Nicholas Bishop <nicholasbishop@gmail.com>\n Nicholas Mazzuca <npmazzuca@gmail.com>\n Nick Cameron <ncameron@mozilla.com>\n Nick Desaulniers <ndesaulniers@mozilla.com>\n+Nick Fitzgerald <fitzgen@gmail.com>\n Nick Hamann <nick@wabbo.org>\n Nick Howell <howellnick@gmail.com>\n Nick Platt <platt.nicholas@gmail.com>\n@@ -750,6 +801,7 @@ Nif Ward <nif.ward@gmail.com>\n Nikita Pekin <contact@nikitapek.in>\n Niklas Koep <niklas.koep@gmail.com>\n Niko Matsakis <niko@alum.mit.edu>\n+Nils Liberg <nils@nilsliberg.se>\n Nils Winter <nils.winter@gmail.com>\n noam <noam@clusterfoo.com>\n Noam Yorav-Raphael <noamraph@gmail.com>\n@@ -760,10 +812,13 @@ nsf <no.smile.face@gmail.com>\n nwin <nwin@users.noreply.github.com>\n Oak <White-Oak@users.noreply.github.com>\n OGINO Masanori <masanori.ogino@gmail.com>\n+OlegTsyba <idethrone1@gmail.com>\n+Oliver Schneider <git1984941651981@oli-obk.de>\n Oliver Schneider <github6541940@oli-obk.de>\n Olivier Saut <osaut@airpost.net>\n olivren <o.renaud@gmx.fr>\n Olle Jonsson <olle.jonsson@gmail.com>\n+olombard <lombard-olivier@bbox.fr>\n Or Brostovski <tohava@gmail.com>\n Oren Hazi <oren.hazi@gmail.com>\n Or Neeman <oneeman@gmail.com>\n@@ -776,6 +831,7 @@ P1start <rewi-github@whanau.org>\n Pablo Brasero <pablo@pablobm.com>\n Palmer Cox <p@lmercox.com>\n Paolo Falabella <paolo.falabella@gmail.com>\n+Parker Moore <parkrmoore@gmail.com>\n Pascal Hertleif <killercup@gmail.com>\n Patrick Reisert <kpreisert@gmail.com>\n Patrick Walton <pcwalton@mimiga.net>\n@@ -787,6 +843,7 @@ Paul Collier <paul@paulcollier.ca>\n Paul Collins <paul@ondioline.org>\n Paul Crowley <paulcrowley@google.com>\n Paul Faria <paul_faria@ultimatesoftware.com>\n+Paul Oliver <puzza007@gmail.com>\n Paul Osborne <osbpau@gmail.com>\n Paul Quint <DrKwint@gmail.com>\n Paul Stansifer <paul.stansifer@gmail.com>\n@@ -795,9 +852,10 @@ Pavel Panchekha <me@pavpanchekha.com>\n Pawel Olzacki <p.olzacki2@samsung.com>\n Pedro Larroy <pedro.larroy@here.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com>\n+peferron <pe.ferron@gmail.com>\n Pete Hunt <petehunt@users.noreply.github.com>\n Peter Atashian <retep998@gmail.com>\n-Peter Elmers <peter.elmers@rice.edu>\n+Peter Elmers <peter.elmers@yahoo.com>\n Peter Hull <peterhull90@gmail.com>\n Peter Marheine <peter@taricorp.net>\n Peter Minten <peter@pminten.nl>\n@@ -839,6 +897,8 @@ Ray Clanan <rclanan@utopianconcept.com>\n ray glover <ray@rayglover.net>\n reedlepee <reedlepee123@gmail.com>\n Reilly Watson <reillywatson@gmail.com>\n+Rein Henrichs <reinh@reinh.com>\n+R\u00e9mi Audebert <halfr@lse.epita.fr>\n Remi Rampin <remirampin@gmail.com>\n Renato Alves <alves.rjc@gmail.com>\n Renato Riccieri Santos Zannon <renato@rrsz.com.br>\n@@ -876,15 +936,18 @@ Roy Frostig <rfrostig@mozilla.com>\n R\u00fcdiger Sonderfeld <ruediger@c-plusplus.de>\n rundrop1 <rundrop1@zoho.com>\n Russell Johnston <rpjohnst@gmail.com>\n+Russell McClellan <russell.mcclellan@gmail.com>\n Ruud van Asseldonk <dev@veniogames.com>\n Ryan Levick <ryan@6wunderkinder.com>\n Ryan Mulligan <ryan@ryantm.com>\n Ryan Prichard <ryan.prichard@gmail.com>\n Ryan Riginding <marc.riginding@gmail.com>\n Ryan Scheel <ryan.havvy@gmail.com>\n+Ryman <haqkrs@gmail.com>\n \u3089\u3044\u3069\u3063\u3068 <ryogo.yoshimura@gmail.com>\n Sae-bom Kim <sae-bom.kim@samsung.com>\n Salem Talha <salem.a.talha@gmail.com>\n+saml <saml@users.noreply.github.com>\n Samuel Chase <samebchase@gmail.com>\n Samuel Neves <sneves@dei.uc.pt>\n Sander Mathijs van Veen <smvv@kompiler.org>\n@@ -895,7 +958,7 @@ Santiago Rodriguez <sanrodari@gmail.com>\n Saurabh Anand <saurabhanandiit@gmail.com>\n Scott Jenkins <scottdjwales@gmail.com>\n Scott Lawrence <bytbox@gmail.com>\n-Scott Olson <scott@scott-olson.org>\n+Scott Olson <scott@solson.me>\n Sean Bowe <ewillbefull@gmail.com>\n Sean Chalmers <sclhiannan@gmail.com>\n Sean Collins <sean@cllns.com>\n@@ -932,6 +995,7 @@ Simon Kern <simon.kern@rwth-aachen.de>\n Simon Persson <simon@flaskpost.org>\n Simon Sapin <simon@exyr.org>\n Simon Wollwage <mail.wollwage@gmail.com>\n+simplex <theemptystring@gmail.com>\n Sindre Johansen <sindre@sindrejohansen.no>\n sinkuu <sinkuupump@gmail.com>\n Skyler <skyler.lipthay@gmail.com>\n@@ -945,16 +1009,19 @@ Stefan Bucur <stefan.bucur@epfl.ch>\n Stefan Plantikow <stefan.plantikow@googlemail.com>\n Stepan Koltsov <stepan.koltsov@gmail.com>\n Sterling Greene <sterling.greene@gmail.com>\n+Steve Gury <steve.gury@gmail.com>\n Steve Klabnik <steve@steveklabnik.com>\n Steven Allen <steven@stebalien.com>\n Steven Crockett <crockett.j.steven@gmail.com>\n Steven De Coeyer <steven@banteng.be>\n Steven Fackler <sfackler@gmail.com>\n Steven Sheldon <steven@sasheldon.com>\n Steven Stewart-Gallus <sstewartgallus00@langara.bc.ca>\n+Steven Walter <stevenrwalter@gmail.com>\n Strahinja Val Markovic <val@markovic.io>\n Stuart Pernsteiner <stuart@pernsteiner.org>\n Subhash Bhushan <subhash.bhushan@kaybus.com>\n+sumito3478 <sumito3478@gmail.com>\n Swaroop C H <swaroop@swaroopch.com>\n Sylvestre Ledru <sylvestre@debian.org>\n Tamir Duberstein <tamird@gmail.com>\n@@ -975,6 +1042,7 @@ Thomas Backman <serenity@exscape.org>\n Thomas Bracht Laumann Jespersen <laumann.thomas@gmail.com>\n Thomas Daede <daede003@umn.edu>\n Thomas Jespersen <laumann.thomas@gmail.com>\n+Thomas Karpiniec <tk@1.21jiggawatts.net>\n Tiago Nobrega <tigarmo@gmail.com>\n Tibor Benke <ihrwein@gmail.com>\n Till Hoeppner <till@hoeppner.ws>\n@@ -986,6 +1054,7 @@ Tim Kuehn <tkuehn@cmu.edu>\n Timon Rapp <timon@zaeda.net>\n Timoth\u00e9e Ravier <tim@siosm.fr>\n Tim Parenti <timparenti@gmail.com>\n+Tim Ringenbach <tim.ringenbach@gmail.com>\n Tim Taubert <tim@timtaubert.de>\n tinaun <tinagma@gmail.com>\n Tincan <tincann@users.noreply.github.com>\n@@ -1046,31 +1115,39 @@ Volker Mische <volker.mische@gmail.com>\n Wade Mealing <wmealing@gmail.com>\n Wangshan Lu <wisagan@gmail.com>\n WebeWizard <webewizard@gmail.com>\n+webmobster <webmobster@users.noreply.github.com>\n Wei-Ming Yang <rick68@users.noreply.github.com>\n Wendell Smith <wendell.smith@yale.edu>\n Wesley Wiser <wwiser@gmail.com>\n whataloadofwhat <unusualmoniker@gmail.com>\n wickerwaka <martin.donlon@gmail.com>\n+Wilfred Hughes <me@wilfred.me.uk>\n+Will Andrews <will@firepipe.net>\n+Will Engler <engler.will@gmail.com>\n Will Hipschman <whipsch@gmail.com>\n William Ting <io@williamting.com>\n Willson Mock <willson.mock@gmail.com>\n Will <will@glozer.net>\n Wojciech Ogrodowczyk <github@haikuco.de>\n wonyong kim <wonyong.kim@samsung.com>\n xales <xales@naveria.com>\n+Xuefeng Wu <benewu@gmail.com>\n+XuefengWu <benewu@gmail.com>\n Xuefeng Wu <xfwu@thoughtworks.com>\n Xue Fuqiao <xfq.free@gmail.com>\n Yasuhiro Fujii <y-fujii@mimosa-pudica.net>\n YawarRaza7349 <YawarRaza7349@gmail.com>\n Yazhong Liu <yorkiefixer@gmail.com>\n Yehuda Katz <wycats@gmail.com>\n+Yongqian Li <yongqli@kerrmetric.com>\n York Xiang <bombless@126.com>\n Young-il Choi <duddlf.choi@samsung.com>\n Youngmin Yoo <youngmin.yoo@samsung.com>\n Youngsoo Son <ysson83@gmail.com>\n Young Wu <doomsplayer@gmail.com>\n Yuri Albuquerque <yuridenommus@gmail.com>\n Yuri Kunde Schlesner <yuriks@yuriks.net>\n+Z1 <MazinZ1@users.noreply.github.com>\n Zach Kamsler <smoo.master@gmail.com>\n Zach Pomerantz <zmp@umich.edu>\n Zack Corr <zack@z0w0.me>"}, {"sha": "22a23de07078034e4fec65394d17ff4c1243b689", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -83,6 +83,21 @@ feature. We use the 'fork and pull' model described there.\n \n Please make pull requests against the `master` branch.\n \n+Compiling all of `make check` can take a while. When testing your pull request,\n+consider using one of the more specialized `make` targets to cut down on the\n+amount of time you have to wait. You need to have built the compiler at least\n+once before running these will work, but that\u2019s only one full build rather than\n+one each time.\n+\n+    $ make -j8 rustc-stage1 && make check-stage1\n+\n+is one such example, which builds just `rustc`, and then runs the tests. If\n+you\u2019re adding something to the standard library, try\n+\n+    $ make -j8 check-stage1-std NO_REBUILD=1\n+\n+This will not rebuild the compiler, but will run the tests.\n+\n All pull requests are reviewed by another person. We have a bot,\n @rust-highfive, that will automatically assign a random person to review your\n request.\n@@ -108,14 +123,18 @@ will run all the tests on every platform we support. If it all works out,\n \n [merge-queue]: http://buildbot.rust-lang.org/homu/queue/rust\n \n+Speaking of tests, Rust has a comprehensive test suite. More information about\n+it can be found\n+[here](https://github.com/rust-lang/rust-wiki-backup/blob/master/Note-testsuite.md).\n+\n ## Writing Documentation\n \n Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n is located in `src/doc` in the tree, and standard API documentation is generated\n from the source code itself.\n \n-Documentation pull requests function in the same as other pull requests, though\n-you may see a slightly different form of `r+`:\n+Documentation pull requests function in the same way as other pull requests,\n+though you may see a slightly different form of `r+`:\n \n     @bors: r+ 38fe8d2 rollup\n "}, {"sha": "8968fabf1b4b37f54bcc03c6e34b75ac1980ed49", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -62,6 +62,7 @@\n #   * tidy-basic - show file / line stats\n #   * tidy-errors - show the highest rustc error code\n #   * tidy-features - show the status of language and lib features\n+#   * rustc-stage$(stage) - Only build up to a specific stage\n #\n # Then mix in some of these environment variables to harness the\n # ultimate power of The Rust Build System.\n@@ -90,7 +91,7 @@\n #\n # # Rust recipes for build system success\n #\n-#     // Modifying libstd? Use this comment to run unit tests just on your change\n+#     // Modifying libstd? Use this command to run unit tests just on your change\n #     make check-stage1-std NO_REBUILD=1 NO_BENCH=1\n #\n #     // Added a run-pass test? Use this to test running your test"}, {"sha": "9e54704a5ebadbcae3bb6b0322ff02efc974c232", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -4,7 +4,7 @@ Rust is a fast systems programming language that guarantees\n memory safety and offers painless concurrency ([no data races]).\n It does not employ a garbage collector and has minimal runtime overhead.\n \n-This repo contains the code for `rustc`, the Rust compiler, as well\n+This repo contains the code for the compiler (`rustc`), as well\n as standard libraries, tools and documentation for Rust.\n \n [no data races]: http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html\n@@ -73,7 +73,7 @@ Read [\"Installing Rust\"] from [The Book].\n    ```\n \n 3. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n-   MYSY2 (i.e. `C:\\msys`), depending on whether you want 32-bit or 64-bit Rust.\n+   MSYS2 (i.e. `C:\\msys`), depending on whether you want 32-bit or 64-bit Rust.\n \n 4. Navigate to Rust's source code, configure and build it:\n "}, {"sha": "db1c7380a788b4a5d3a408957f7df034360072b2", "filename": "RELEASES.md", "status": "modified", "additions": 155, "deletions": 14, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -1,3 +1,150 @@\n+Version 1.2.0 (August 2015)\n+===========================\n+\n+* ~1200 changes, numerous bugfixes\n+\n+Highlights\n+----------\n+\n+* [Dynamically-sized-type coercions][dst] allow smart pointer types\n+  like `Rc` to contain types without a fixed size, arrays and trait\n+  objects, finally enabling use of `Rc<[T]>` and completing the\n+  implementation of DST.\n+* [Parallel codegen][parcodegen] is now working again, which can\n+  substantially speed up large builds in debug mode; It also gets\n+  another ~33% speedup when bootstrapping on a 4 core machine (using 8\n+  jobs). It's not enabled by default, but will be \"in the near\n+  future\". It can be activated with the `-C codegen-units=N` flag to\n+  `rustc`.\n+\n+Breaking Changes\n+----------------\n+\n+* The [`to_uppercase`] and [`to_lowercase`] methods on `char` now do\n+  unicode case mapping, which is a previously-planned change in\n+  behavior and considered a bugfix.\n+* [`mem::align_of`] now specifies [the *minimum alignment* for\n+  T][align], which is usually the alignment programs are interested\n+  in, and the same value reported by clang's\n+  `alignof`. [`mem::min_align_of`] is deprecated. This is not known to\n+  break real code.\n+* [The `#[packed]` attribute is no longer silently accepted by the\n+  compiler][packed]. This attribute did nothing and code that\n+  mentioned it likely did not work as intended.\n+\n+Language\n+--------\n+\n+* Patterns with `ref mut` now correctly invoke [`DerefMut`] when\n+  matching against dereferencable values.\n+\n+Libraries\n+---------\n+\n+* The [`Extend`] trait, which grows a collection from an iterator, is\n+  implemented over iterators of references, for `String`, `Vec`,\n+  `LinkedList`, `VecDeque`, `EnumSet`, `BinaryHeap`, `VecMap`,\n+  `BTreeSet` and `BTreeMap`. [RFC][extend-rfc].\n+* The [`iter::once`] function returns an iterator that yields a single\n+  element.\n+* The [`iter::empty`] function returns an iterator that yields no\n+  elements.\n+* The [`matches`] and [`rmatches`] methods on `str` return iterators\n+  over substring matches.\n+* [`Cell`] and [`RefCell`] both implement [`Eq`].\n+* A number of methods for wrapping arithmetic are added to the\n+  integral types, [`wrapping_div`], [`wrapping_rem`],\n+  [`wrapping_neg`], [`wrapping_shl`], [`wrapping_shr`]. These are in\n+  addition to the existing [`wrapping_add`], [`wrapping_sub`], and\n+  [`wrapping_mul`] methods, and alternatives to the [`Wrapping`]\n+  type.. It is illegal for the default arithmetic operations in Rust\n+  to overflow; the desire to wrap must be explicit.\n+* The `{:#?}` formatting specifier [displays the alternate,\n+  pretty-printed][debugfmt] form of the `Debug` formatter. This\n+  feature was actually introduced prior to 1.0 with little\n+  fanfare.\n+* [`fmt::Formatter`] implements [`fmt::Write`], a `fmt`-specific trait\n+  for writing data to formatted strings, similar to [`io::Write`].\n+* [`fmt::Formatter`] adds 'debug builder' methods, [`debug_struct`],\n+  [`debug_tuple`], [`debug_list`], [`debug_set`], [`debug_map`]. These\n+  are used by code generators to emit implementations of [`Debug`].\n+* `str` has new [`to_uppercase`][strup] and [`to_lowercase`][strlow]\n+  methods that convert case, following Unicode case mapping.\n+* It is now easier to handle to poisoned locks. The [`PoisonError`]\n+  type, returned by failing lock operations, exposes `into_inner`,\n+  `get_ref`, and `get_mut`, which all give access to the inner lock\n+  guard, and allow the poisoned lock to continue to operate. The\n+  `is_poisoned` method of [`RwLock`] and [`Mutex`] can poll for a\n+  poisoned lock without attempting to take the lock.\n+* On Unix the [`FromRawFd`] trait is implemented for [`Stdio`], and\n+  [`AsRawFd`] for [`ChildStdin`], [`ChildStdout`], [`ChildStderr`].\n+  On Windows the `FromRawHandle` trait is implemented for `Stdio`,\n+  and `AsRawHandle` for `ChildStdin`, `ChildStdout`,\n+  `ChildStderr`.\n+* [`io::ErrorKind`] has a new variant, `InvalidData`, which indicates\n+  malformed input.\n+\n+Misc\n+----\n+\n+* `rustc` employs smarter heuristics for guessing at [typos].\n+* `rustc` emits more efficient code for [no-op conversions between\n+  unsafe pointers][nop].\n+* Fat pointers are now [passed in pairs of immediate arguments][fat],\n+  resulting in faster compile times and smaller code.\n+\n+[`Extend`]: http://doc.rust-lang.org/nightly/std/iter/trait.Extend.html\n+[extend-rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0839-embrace-extend-extinguish.md\n+[`iter::once`]: http://doc.rust-lang.org/nightly/std/iter/fn.once.html\n+[`iter::empty`]: http://doc.rust-lang.org/nightly/std/iter/fn.empty.html\n+[`matches`]: http://doc.rust-lang.org/nightly/std/primitive.str.html#method.matches\n+[`rmatches`]: http://doc.rust-lang.org/nightly/std/primitive.str.html#method.rmatches\n+[`Cell`]: http://doc.rust-lang.org/nightly/std/cell/struct.Cell.html\n+[`RefCell`]: http://doc.rust-lang.org/nightly/std/cell/struct.RefCell.html\n+[`wrapping_add`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_add\n+[`wrapping_sub`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_sub\n+[`wrapping_mul`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_mul\n+[`wrapping_div`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_div\n+[`wrapping_rem`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_rem\n+[`wrapping_neg`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_neg\n+[`wrapping_shl`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_shl\n+[`wrapping_shr`]: http://doc.rust-lang.org/nightly/std/primitive.i8.html#method.wrapping_shr\n+[`Wrapping`]: http://doc.rust-lang.org/nightly/std/num/struct.Wrapping.html\n+[`fmt::Formatter`]: http://doc.rust-lang.org/nightly/std/fmt/struct.Formatter.html\n+[`fmt::Write`]: http://doc.rust-lang.org/nightly/std/fmt/trait.Write.html\n+[`io::Write`]: http://doc.rust-lang.org/nightly/std/io/trait.Write.html\n+[`debug_struct`]: http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html#method.debug_struct\n+[`debug_tuple`]: http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html#method.debug_tuple\n+[`debug_list`]: http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html#method.debug_list\n+[`debug_set`]: http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html#method.debug_set\n+[`debug_map`]: http://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html#method.debug_map\n+[`Debug`]: http://doc.rust-lang.org/nightly/std/fmt/trait.Debug.html\n+[strup]: http://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_uppercase\n+[strlow]: http://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase\n+[`to_uppercase`]: http://doc.rust-lang.org/nightly/std/primitive.char.html#method.to_uppercase\n+[`to_lowercase`]: http://doc.rust-lang.org/nightly/std/primitive.char.html#method.to_lowercase\n+[`PoisonError`]: http://doc.rust-lang.org/nightly/std/sync/struct.PoisonError.html\n+[`RwLock`]: http://doc.rust-lang.org/nightly/std/sync/struct.RwLock.html\n+[`Mutex`]: http://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html\n+[`FromRawFd`]: http://doc.rust-lang.org/nightly/std/os/unix/io/trait.FromRawFd.html\n+[`AsRawFd`]: http://doc.rust-lang.org/nightly/std/os/unix/io/trait.AsRawFd.html\n+[`Stdio`]: http://doc.rust-lang.org/nightly/std/process/struct.Stdio.html\n+[`ChildStdin`]: http://doc.rust-lang.org/nightly/std/process/struct.ChildStdin.html\n+[`ChildStdout`]: http://doc.rust-lang.org/nightly/std/process/struct.ChildStdout.html\n+[`ChildStderr`]: http://doc.rust-lang.org/nightly/std/process/struct.ChildStderr.html\n+[`io::ErrorKind`]: http://doc.rust-lang.org/nightly/std/io/enum.ErrorKind.html\n+[debugfmt]: https://www.reddit.com/r/rust/comments/3ceaui/psa_produces_prettyprinted_debug_output/\n+[`DerefMut`]: http://doc.rust-lang.org/nightly/std/ops/trait.DerefMut.html\n+[`mem::align_of`]: http://doc.rust-lang.org/nightly/std/mem/fn.align_of.html\n+[align]: https://github.com/rust-lang/rust/pull/25646\n+[`mem::min_align_of`]: http://doc.rust-lang.org/nightly/std/mem/fn.min_align_of.html\n+[typos]: https://github.com/rust-lang/rust/pull/26087\n+[nop]: https://github.com/rust-lang/rust/pull/26336\n+[fat]: https://github.com/rust-lang/rust/pull/26411\n+[dst]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+[parcodegen]: https://github.com/rust-lang/rust/pull/26018\n+[packed]: https://github.com/rust-lang/rust/pull/25541\n+\n Version 1.1.0 (June 2015)\n =========================\n \n@@ -6,29 +153,28 @@ Version 1.1.0 (June 2015)\n Highlights\n ----------\n \n-* The [`std::fs` module has been expanded][fs-expand] to expand the set of\n+* The [`std::fs` module has been expanded][fs] to expand the set of\n   functionality exposed:\n   * `DirEntry` now supports optimizations like `file_type` and `metadata` which\n     don't incur a syscall on some platforms.\n   * A `symlink_metadata` function has been added.\n   * The `fs::Metadata` structure now lowers to its OS counterpart, providing\n     access to all underlying information.\n-* The compiler contains extended explanations of many errors.  When it\n-  emits such an error it also suggests using the `--explain` flag to\n-  read the extended explanations, which are also [cataloged on the web\n-  site][err].\n+* The compiler now contains extended explanations of many errors. When an error\n+  with an explanation occurs the compiler suggests using the `--explain` flag\n+  to read the explanation. Error explanations are also [available online][err-index].\n * Thanks to multiple [improvements][sk] to [type checking][pre], as\n   well as other work, the time to bootstrap the compiler decreased by\n   32%.\n \n Libraries\n ---------\n \n-* The `str::split_whitespace` method splits a string on unicode\n+* The [`str::split_whitespace`] method splits a string on unicode\n   whitespace boundaries.\n * On both Windows and Unix, new extension traits provide conversion of\n   I/O types to and from the underlying system handles. On Unix, these\n-  traits are [`FrowRawFd`] and [`AsRawFd`], on Windows `FromRawHandle`\n+  traits are [`FromRawFd`] and [`AsRawFd`], on Windows `FromRawHandle`\n   and `AsRawHandle`. These are implemented for `File`, `TcpStream`,\n   `TcpListener`, and `UpdSocket`. Further implementations for\n   `std::process` will be stabilized later.\n@@ -80,15 +226,14 @@ Misc\n * [The `drop_with_repr_extern` lint warns about mixing `repr(C)`\n   with `Drop`][drop].\n \n-[`split_whitespace`]: http://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_whitespace\n-[`Iterator::cloned`]: http://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html#method.cloned\n+[`str::split_whitespace`]: http://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_whitespace\n [`FromRawFd`]: http://doc.rust-lang.org/nightly/std/os/unix/io/trait.FromRawFd.html\n [`AsRawFd`]: http://doc.rust-lang.org/nightly/std/os/unix/io/trait.AsRawFd.html\n [`std::os::unix::symlink`]: http://doc.rust-lang.org/nightly/std/os/unix/fs/fn.symlink.html\n [`IntoIterator`]: http://doc.rust-lang.org/nightly/std/iter/trait.IntoIterator.html\n [`From`]: http://doc.rust-lang.org/nightly/std/convert/trait.From.html\n [rf]: https://github.com/rust-lang/rust/pull/24491\n-[err]: http://doc.rust-lang.org/error-index.html\n+[err-index]: http://doc.rust-lang.org/error-index.html\n [sk]: https://github.com/rust-lang/rust/pull/24615\n [pre]: https://github.com/rust-lang/rust/pull/25323\n [file]: https://github.com/rust-lang/rust/pull/24598\n@@ -251,7 +396,6 @@ Misc\n [sw]: https://github.com/rust-lang/rfcs/blob/master/text/1054-str-words.md\n [th]: https://github.com/rust-lang/rfcs/blob/master/text/0909-move-thread-local-to-std-thread.md\n [send-rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0458-send-improvements.md\n-[scoped]: http://static.rust-lang.org/doc/master/std/thread/fn.scoped.html\n [moar-ufcs]: https://github.com/rust-lang/rust/pull/22172\n [prim-inherent]: https://github.com/rust-lang/rust/pull/23104\n [overflow]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md\n@@ -261,12 +405,10 @@ Misc\n [string-pattern]: https://github.com/rust-lang/rust/pull/22466\n [oibit-final]: https://github.com/rust-lang/rust/pull/21689\n [reflect]: https://github.com/rust-lang/rust/pull/23712\n-[debug-builder]: https://github.com/rust-lang/rfcs/blob/master/text/0640-debug-improvements.md\n [conversion]: https://github.com/rust-lang/rfcs/pull/529\n [num-traits]: https://github.com/rust-lang/rust/pull/23549\n [index-value]: https://github.com/rust-lang/rust/pull/23601\n [dropck]: https://github.com/rust-lang/rfcs/pull/769\n-[fundamental]: https://github.com/rust-lang/rfcs/pull/1023\n [ci-compare]: https://gist.github.com/brson/a30a77836fbec057cbee\n [fn-inherit]: https://github.com/rust-lang/rust/pull/23282\n [fn-blanket]: https://github.com/rust-lang/rust/pull/23895\n@@ -369,7 +511,6 @@ Version 1.0.0-alpha.2 (February 2015)\n [osstr]: https://github.com/rust-lang/rust/pull/21488\n [osstr-rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0517-io-os-reform.md\n [Self]: https://github.com/rust-lang/rust/pull/22158\n-[ufcs]: https://github.com/rust-lang/rust/pull/21077\n [ufcs-rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md\n [un]: https://github.com/rust-lang/rust/pull/22256\n "}, {"sha": "542d829e2cd638cbd9afe53666662b3a89070289", "filename": "configure", "status": "modified", "additions": 163, "deletions": 73, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/configure", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -283,7 +283,7 @@ opt_core() {\n             fi\n         done\n     else\n-        if [ ! -z \"$META\" ]\n+        if [ -n \"$META\" ]\n         then\n             OP=\"$OP=<$META>\"\n         fi\n@@ -317,12 +317,23 @@ envopt() {\n     fi\n \n     # If script or environment provided a value, save it.\n-    if [ ! -z \"$VV\" ]\n+    if [ -n \"$VV\" ]\n     then\n         putvar $V\n     fi\n }\n \n+enable_if_not_disabled() {\n+    local OP=$1\n+    local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n+    local ENAB_V=\"CFG_ENABLE_$UOP\"\n+    local EXPLICITLY_DISABLED=\"CFG_DISABLE_${UOP}_PROVIDED\"\n+    eval VV=\\$$EXPLICITLY_DISABLED\n+    if [ -z \"$VV\" ]; then\n+        eval $ENAB_V=1\n+    fi\n+}\n+\n to_llvm_triple() {\n     case $1 in\n         i686-w64-mingw32) echo i686-pc-windows-gnu ;;\n@@ -405,6 +416,10 @@ case $CFG_OSTYPE in\n         CFG_OSTYPE=unknown-openbsd\n        ;;\n \n+    NetBSD)\n+\t    CFG_OSTYPE=unknown-netbsd\n+\t    ;;\n+\n     Darwin)\n         CFG_OSTYPE=apple-darwin\n         ;;\n@@ -667,10 +682,12 @@ if [ -n \"$CFG_ENABLE_DEBUG\" ]; then\n         CFG_DISABLE_OPTIMIZE=1\n         CFG_DISABLE_OPTIMIZE_CXX=1\n     fi\n-    CFG_ENABLE_DEBUG_ASSERTIONS=1\n-    CFG_ENABLE_DEBUG_JEMALLOC=1\n-    CFG_ENABLE_DEBUGINFO=1\n-    CFG_ENABLE_LLVM_ASSERTIONS=1\n+\n+    # Set following variables to 1 unless setting already provided\n+    enable_if_not_disabled debug-assertions\n+    enable_if_not_disabled debug-jemalloc\n+    enable_if_not_disabled debuginfo\n+    enable_if_not_disabled llvm-assertions\n fi\n \n # OK, now write the debugging options\n@@ -750,7 +767,7 @@ probe CFG_LLDB             lldb\n # On MacOS X, invoking `javac` pops up a dialog if the JDK is not\n # installed. Since `javac` is only used if `antlr4` is available,\n # probe for it only in this case.\n-if [ ! -z \"$CFG_ANTLR4\" ]\n+if [ -n \"$CFG_ANTLR4\" ]\n then\n    probe CFG_JAVAC            javac\n fi\n@@ -769,14 +786,14 @@ then\n     fi\n fi\n \n-if [ ! -z \"$CFG_GDB\" ]\n+if [ -n \"$CFG_GDB\" ]\n then\n     # Store GDB's version\n     CFG_GDB_VERSION=$($CFG_GDB --version 2>/dev/null | head -1)\n     putvar CFG_GDB_VERSION\n fi\n \n-if [ ! -z \"$CFG_LLDB\" ]\n+if [ -n \"$CFG_LLDB\" ]\n then\n     # Store LLDB's version\n     CFG_LLDB_VERSION=$($CFG_LLDB --version 2>/dev/null | head -1)\n@@ -802,7 +819,7 @@ step_msg \"looking for target specific programs\"\n \n probe CFG_ADB        adb\n \n-if [ ! -z \"$CFG_PANDOC\" ]\n+if [ -n \"$CFG_PANDOC\" ]\n then\n     # Extract \"MAJOR MINOR\" from Pandoc's version number\n     PV_MAJOR_MINOR=$(pandoc --version | grep '^pandoc' |\n@@ -828,7 +845,7 @@ then\n     BIN_SUF=.exe\n fi\n \n-if [ ! -z \"$CFG_ENABLE_LOCAL_RUST\" ]\n+if [ -n \"$CFG_ENABLE_LOCAL_RUST\" ]\n then\n     system_rustc=$(which rustc)\n     if [ -f ${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF} ]\n@@ -899,20 +916,32 @@ then\n     fi\n fi\n \n+# If the clang isn't already enabled, check for GCC, and if it is missing, turn\n+# on clang as a backup.\n+if [ -z \"$CFG_ENABLE_CLANG\" ]\n+then\n+  CFG_GCC_VERSION=$(\"$CFG_GCC\" --version 2>&1)\n+  if [ $? -ne 0 ]\n+  then\n+    step_msg \"GCC not installed, will try using Clang\"\n+    CFG_ENABLE_CLANG=1\n+  fi\n+fi\n+\n # Okay, at this point, we have made up our minds about whether we are\n # going to force CFG_ENABLE_CLANG or not; save the setting if so.\n-if [ ! -z \"$CFG_ENABLE_CLANG\" ]\n+if [ -n \"$CFG_ENABLE_CLANG\" ]\n then\n     putvar CFG_ENABLE_CLANG\n fi\n \n # Same with jemalloc.  save the setting here.\n-if [ ! -z \"$CFG_DISABLE_JEMALLOC\" ]\n+if [ -n \"$CFG_DISABLE_JEMALLOC\" ]\n then\n     putvar CFG_DISABLE_JEMALLOC\n fi\n \n-if [ ! -z \"$CFG_LLVM_ROOT\" -a -z \"$CFG_DISABLE_LLVM_VERSION_CHECK\" -a -e \"$CFG_LLVM_ROOT/bin/llvm-config\" ]\n+if [ -n \"$CFG_LLVM_ROOT\" -a -z \"$CFG_DISABLE_LLVM_VERSION_CHECK\" -a -e \"$CFG_LLVM_ROOT/bin/llvm-config\" ]\n then\n     step_msg \"using custom LLVM at $CFG_LLVM_ROOT\"\n \n@@ -941,7 +970,7 @@ fi\n # CFG_ENABLE_CLANG is set, that indicates that we are opting into\n # running such safeguards.\n \n-if [ ! -z \"$CC\" ]\n+if [ -n \"$CC\" ]\n then\n     msg \"skipping compiler inference steps; using provided CC=$CC\"\n     CFG_CC=\"$CC\"\n@@ -954,7 +983,7 @@ then\n         putvar CFG_USING_CLANG\n     fi\n else\n-    if [ ! -z \"$CFG_ENABLE_CLANG\" ]\n+    if [ -n \"$CFG_ENABLE_CLANG\" ]\n     then\n         if [ -z \"$CFG_CLANG\" ]\n         then\n@@ -968,47 +997,59 @@ else\n     fi\n fi\n \n-if [ ! -z \"$CFG_ENABLE_CLANG\" ]\n+if [ -n \"$CFG_ENABLE_CLANG\" ]\n then\n     case \"$CC\" in\n         (''|*clang)\n-        CFG_CLANG_VERSION=$($CFG_CC \\\n-            --version \\\n-            | grep version \\\n-            | sed 's/.*\\(version .*\\)/\\1/; s/.*based on \\(LLVM .*\\))/\\1/' \\\n-            | cut -d ' ' -f 2)\n-\n-        case $CFG_CLANG_VERSION in\n-            (3.2* | 3.3* | 3.4* | 3.5* | 3.6* | 3.7*)\n-            step_msg \"found ok version of CLANG: $CFG_CLANG_VERSION\"\n-            if [ -z \"$CC\" ]\n-            then\n-                CFG_CC=\"clang\"\n-                CFG_CXX=\"clang++\"\n-            fi\n-            ;;\n-            (*)\n-            err \"bad CLANG version: $CFG_CLANG_VERSION, need >=3.0svn\"\n-            ;;\n-        esac\n-        ;;\n-        (*)\n-        msg \"skipping CFG_ENABLE_CLANG version check; provided CC=$CC\"\n-        ;;\n+        CFG_CLANG_REPORTED_VERSION=$($CFG_CC --version | grep version)\n+\n+        if [[ $CFG_CLANG_REPORTED_VERSION == *\"(based on LLVM \"* ]]\n+        then\n+            CFG_CLANG_VERSION=$(echo $CFG_CLANG_REPORTED_VERSION | sed 's/.*(based on LLVM \\(.*\\))/\\1/')\n+        elif [[ $CFG_CLANG_REPORTED_VERSION == \"Apple LLVM\"* ]]\n+        then\n+            CFG_OSX_CLANG_VERSION=$(echo $CFG_CLANG_REPORTED_VERSION | sed 's/.*version \\(.*\\) .*/\\1/')\n+        else\n+            CFG_CLANG_VERSION=$(echo $CFG_CLANG_REPORTED_VERSION | sed 's/.*version \\(.*\\) .*/\\1/')\n+        fi\n+\n+        if [ -n \"$CFG_OSX_CLANG_VERSION\" ]\n+        then\n+            case $CFG_OSX_CLANG_VERSION in\n+                (7.0*)\n+                step_msg \"found ok version of APPLE CLANG: $CFG_OSX_CLANG_VERSION\"\n+                ;;\n+                (*)\n+                err \"bad APPLE CLANG version: $CFG_OSX_CLANG_VERSION, need >=7.0\"\n+                ;;\n+            esac\n+        else\n+            case $CFG_CLANG_VERSION in\n+                (3.2* | 3.3* | 3.4* | 3.5* | 3.6* | 3.7*)\n+                step_msg \"found ok version of CLANG: $CFG_CLANG_VERSION\"\n+                ;;\n+                (*)\n+                err \"bad CLANG version: $CFG_CLANG_VERSION, need >=3.0svn\"\n+                ;;\n+            esac\n+        fi\n+\n+        if [ -z \"$CC\" ]\n+        then\n+            CFG_CC=\"clang\"\n+            CFG_CXX=\"clang++\"\n+        fi\n     esac\n fi\n \n-if [ ! -z \"$CFG_ENABLE_CCACHE\" ]\n+if [ -n \"$CFG_ENABLE_CCACHE\" ]\n then\n-    if [ -z \"$CC\" ]\n+    if [ -z \"$CFG_CCACHE\" ]\n     then\n-        if [ -z \"$CFG_CCACHE\" ]\n-        then\n-            err \"ccache requested but not found\"\n-        fi\n-\n-        CFG_CC=\"ccache $CFG_CC\"\n+        err \"ccache requested but not found\"\n     fi\n+\n+    CFG_CC=\"ccache $CFG_CC\"\n fi\n \n if [ -z \"$CC\" -a -z \"$CFG_ENABLE_CLANG\" -a -z \"$CFG_GCC\" ]\n@@ -1102,7 +1143,7 @@ do\n             fi\n             ;;\n \n-        x86_64-*-msvc)\n+        *-msvc)\n             # Currently the build system is not configured to build jemalloc\n             # with MSVC, so we omit this optional dependency.\n             step_msg \"targeting MSVC, disabling jemalloc\"\n@@ -1142,30 +1183,53 @@ do\n             CFG_MSVC_ROOT=$(echo \"$install\" | grep InstallDir | sed 's/.*REG_SZ[ ]*//')\n             CFG_MSVC_ROOT=$(dirname \"$CFG_MSVC_ROOT\")\n             CFG_MSVC_ROOT=$(dirname \"$CFG_MSVC_ROOT\")\n-            CFG_MSVC_CL=\"${CFG_MSVC_ROOT}/VC/bin/amd64/cl.exe\"\n-            CFG_MSVC_LIB=\"${CFG_MSVC_ROOT}/VC/bin/amd64/lib.exe\"\n-            CFG_MSVC_LINK=\"${CFG_MSVC_ROOT}/VC/bin/amd64/link.exe\"\n+            putvar CFG_MSVC_ROOT\n+\n+            case $i in\n+                x86_64-*)\n+                    bits=x86_64\n+                    msvc_part=amd64\n+                    ;;\n+                i686-*)\n+                    bits=i386\n+                    msvc_part=\n+                    ;;\n+                *)\n+                    err \"can only target x86 targets for MSVC\"\n+                    ;;\n+            esac\n+            bindir=\"${CFG_MSVC_ROOT}/VC/bin\"\n+            if [ -n \"$msvc_part\" ]; then\n+                bindir=\"$bindir/$msvc_part\"\n+            fi\n+            eval CFG_MSVC_BINDIR_$bits=\"\\\"$bindir\\\"\"\n+            eval CFG_MSVC_CL_$bits=\"\\\"$bindir/cl.exe\\\"\"\n+            eval CFG_MSVC_LIB_$bits=\"\\\"$bindir/lib.exe\\\"\"\n+            eval CFG_MSVC_LINK_$bits=\"\\\"$bindir/link.exe\\\"\"\n \n             vcvarsall=\"${CFG_MSVC_ROOT}/VC/vcvarsall.bat\"\n-            CFG_MSVC_INCLUDE_PATH=$(cmd /c \"\\\"$vcvarsall\\\" amd64 && cmd /c echo %INCLUDE%\")\n+            include_path=$(cmd /c \"\\\"$vcvarsall\\\" $msvc_part && cmd /c echo %INCLUDE%\")\n             need_ok \"failed to learn about MSVC's INCLUDE\"\n-            CFG_MSVC_LIB_PATH=$(cmd /c \"\\\"$vcvarsall\\\" amd64 && cmd /c echo %LIB%\")\n+            lib_path=$(cmd /c \"\\\"$vcvarsall\\\" $msvc_part && cmd /c echo %LIB%\")\n             need_ok \"failed to learn about MSVC's LIB\"\n \n-            putvar CFG_MSVC_ROOT\n-            putvar CFG_MSVC_CL\n-            putvar CFG_MSVC_LIB\n-            putvar CFG_MSVC_LINK\n-            putvar CFG_MSVC_INCLUDE_PATH\n-            putvar CFG_MSVC_LIB_PATH\n+            eval CFG_MSVC_INCLUDE_PATH_${bits}=\"\\\"$include_path\\\"\"\n+            eval CFG_MSVC_LIB_PATH_${bits}=\"\\\"$lib_path\\\"\"\n+\n+            putvar CFG_MSVC_BINDIR_${bits}\n+            putvar CFG_MSVC_CL_${bits}\n+            putvar CFG_MSVC_LIB_${bits}\n+            putvar CFG_MSVC_LINK_${bits}\n+            putvar CFG_MSVC_INCLUDE_PATH_${bits}\n+            putvar CFG_MSVC_LIB_PATH_${bits}\n             ;;\n \n         *)\n             ;;\n     esac\n done\n \n-if [ ! -z \"$CFG_PERF\" ]\n+if [ -n \"$CFG_PERF\" ]\n then\n     HAVE_PERF_LOGFD=`$CFG_PERF stat --log-fd 2>&1 | grep 'unknown option'`\n     if [ -z \"$HAVE_PERF_LOGFD\" ];\n@@ -1275,11 +1339,11 @@ then\n     \"${CFG_GIT}\" submodule init\n \n     # Disable submodules that we're not using\n-    if [ ! -z \"${CFG_LLVM_ROOT}\" ]; then\n+    if [ -n \"${CFG_LLVM_ROOT}\" ]; then\n         msg \"git: submodule deinit src/llvm\"\n         \"${CFG_GIT}\" submodule deinit src/llvm\n     fi\n-    if [ ! -z \"${CFG_JEMALLOC_ROOT}\" ]; then\n+    if [ -n \"${CFG_JEMALLOC_ROOT}\" ]; then\n         msg \"git: submodule deinit src/jemalloc\"\n         \"${CFG_GIT}\" submodule deinit src/jemalloc\n     fi\n@@ -1326,7 +1390,7 @@ do\n     if [ -z $CFG_LLVM_ROOT ]\n     then\n         LLVM_BUILD_DIR=${CFG_BUILD_DIR}$t/llvm\n-        if [ ! -z \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]\n+        if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]\n         then\n             LLVM_DBG_OPTS=\"--enable-debug-symbols --disable-optimized\"\n             # Just use LLVM straight from its build directory to\n@@ -1382,7 +1446,7 @@ do\n         msg \"configuring LLVM for $t with cmake\"\n \n         CMAKE_ARGS=\"-DLLVM_INCLUDE_TESTS=OFF\"\n-        if [ ! -z \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then\n+        if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then\n             CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=Debug\"\n         else\n             CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=Release\"\n@@ -1396,8 +1460,19 @@ do\n \n         msg \"configuring LLVM with:\"\n         msg \"$CMAKE_ARGS\"\n+        case \"$t\" in\n+            x86_64-*)\n+                generator=\"Visual Studio 12 2013 Win64\"\n+                ;;\n+            i686-*)\n+                generator=\"Visual Studio 12 2013\"\n+                ;;\n+            *)\n+                err \"can only build LLVM for x86 platforms\"\n+                ;;\n+        esac\n         (cd $LLVM_BUILD_DIR && \"$CFG_CMAKE\" $CFG_LLVM_SRC_DIR \\\n-                                            -G \"Visual Studio 12 2013 Win64\" \\\n+                                            -G \"$generator\" \\\n                                             $CMAKE_ARGS)\n         need_ok \"LLVM cmake configure failed\"\n     fi\n@@ -1463,11 +1538,26 @@ do\n \n             (*)\n             msg \"inferring LLVM_CXX/CC from CXX/CC = $CXX/$CC\"\n-            LLVM_CXX_32=\"$CXX\"\n-            LLVM_CC_32=\"$CC\"\n+            if [ -n \"$CFG_ENABLE_CCACHE\" ]\n+            then\n+                if [ -z \"$CFG_CCACHE\" ]\n+                then\n+                    err \"ccache requested but not found\"\n+                fi\n+\n+                LLVM_CXX_32=\"ccache $CXX\"\n+                LLVM_CC_32=\"ccache $CC\"\n+\n+                LLVM_CXX_64=\"ccache $CXX\"\n+                LLVM_CC_64=\"ccache $CC\"\n+            else\n+                LLVM_CXX_32=\"$CXX\"\n+                LLVM_CC_32=\"$CC\"\n+\n+                LLVM_CXX_64=\"$CXX\"\n+                LLVM_CC_64=\"$CC\"\n+            fi\n \n-            LLVM_CXX_64=\"$CXX\"\n-            LLVM_CC_64=\"$CC\"\n             ;;\n         esac\n \n@@ -1582,20 +1672,20 @@ putvar CFG_MANDIR\n \n # Avoid spurious warnings from clang by feeding it original source on\n # ccache-miss rather than preprocessed input.\n-if [ ! -z \"$CFG_ENABLE_CCACHE\" ] && [ ! -z \"$CFG_USING_CLANG\" ]\n+if [ -n \"$CFG_ENABLE_CCACHE\" ] && [ -n \"$CFG_USING_CLANG\" ]\n then\n     CFG_CCACHE_CPP2=1\n     putvar CFG_CCACHE_CPP2\n fi\n \n-if [ ! -z \"$CFG_ENABLE_CCACHE\" ]\n+if [ -n \"$CFG_ENABLE_CCACHE\" ]\n then\n     CFG_CCACHE_BASEDIR=${CFG_SRC_DIR}\n     putvar CFG_CCACHE_BASEDIR\n fi\n \n \n-if [ ! -z $BAD_PANDOC ]\n+if [ -n $BAD_PANDOC ]\n then\n     CFG_PANDOC=\n     putvar CFG_PANDOC"}, {"sha": "bb1280688a7168dd96f5a66025e080ab68fe117f", "filename": "mk/cfg/i686-pc-windows-msvc.mk", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fi686-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fi686-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-msvc.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -0,0 +1,29 @@\n+# i686-pc-windows-msvc configuration\n+CC_i686-pc-windows-msvc=\"$(CFG_MSVC_CL_i386)\" -nologo\n+LINK_i686-pc-windows-msvc=\"$(CFG_MSVC_LINK_i386)\" -nologo\n+CXX_i686-pc-windows-msvc=\"$(CFG_MSVC_CL_i386)\" -nologo\n+CPP_i686-pc-windows-msvc=\"$(CFG_MSVC_CL_i386)\" -nologo\n+AR_i686-pc-windows-msvc=\"$(CFG_MSVC_LIB_i386)\" -nologo\n+CFG_LIB_NAME_i686-pc-windows-msvc=$(1).dll\n+CFG_STATIC_LIB_NAME_i686-pc-windows-msvc=$(1).lib\n+CFG_LIB_GLOB_i686-pc-windows-msvc=$(1)-*.{dll,lib}\n+CFG_LIB_DSYM_GLOB_i686-pc-windows-msvc=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_i686-pc-windows-msvc :=\n+CFG_GCCISH_CFLAGS_i686-pc-windows-msvc := -MD\n+CFG_GCCISH_CXXFLAGS_i686-pc-windows-msvc := -MD\n+CFG_GCCISH_LINK_FLAGS_i686-pc-windows-msvc :=\n+CFG_GCCISH_DEF_FLAG_i686-pc-windows-msvc :=\n+CFG_LLC_FLAGS_i686-pc-windows-msvc :=\n+CFG_INSTALL_NAME_i686-pc-windows-msvc =\n+CFG_EXE_SUFFIX_i686-pc-windows-msvc := .exe\n+CFG_WINDOWSY_i686-pc-windows-msvc := 1\n+CFG_UNIXY_i686-pc-windows-msvc :=\n+CFG_LDPATH_i686-pc-windows-msvc :=\n+CFG_RUN_i686-pc-windows-msvc=$(2)\n+CFG_RUN_TARG_i686-pc-windows-msvc=$(call CFG_RUN_i686-pc-windows-msvc,,$(2))\n+CFG_GNU_TRIPLE_i686-pc-windows-msvc := i686-pc-win32\n+\n+# All windows nightiles are currently a GNU triple, so this MSVC triple is not\n+# bootstrapping from itself. This is relevant during stage0, and other parts of\n+# the build system take this into account.\n+BOOTSTRAP_FROM_i686-pc-windows-msvc := i686-pc-windows-gnu"}, {"sha": "0ac0ca98a2f1eece8fbdb20c65d154776bf74806", "filename": "mk/cfg/i686-unknown-freebsd.mk", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fi686-unknown-freebsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fi686-unknown-freebsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-freebsd.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -0,0 +1,22 @@\n+# i686-unknown-freebsd configuration\n+CC_i686-unknown-freebsd=$(CC)\n+CXX_i686-unknown-freebsd=$(CXX)\n+CPP_i686-unknown-freebsd=$(CPP)\n+AR_i686-unknown-freebsd=$(AR)\n+CFG_LIB_NAME_i686-unknown-freebsd=lib$(1).so\n+CFG_STATIC_LIB_NAME_i686-unknown-freebsd=lib$(1).a\n+CFG_LIB_GLOB_i686-unknown-freebsd=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_i686-unknown-freebsd=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_i686-unknown-freebsd := -m32 -arch i386 -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-unknown-freebsd := -Wall -Werror -g -fPIC -m32 -arch i386 -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_LINK_FLAGS_i686-unknown-freebsd := -m32 -shared -fPIC -g -pthread -lrt\n+CFG_GCCISH_DEF_FLAG_i686-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_i686-unknown-freebsd :=\n+CFG_INSTALL_NAME_i686-unknown-freebsd =\n+CFG_EXE_SUFFIX_i686-unknown-freebsd :=\n+CFG_WINDOWSY_i686-unknown-freebsd :=\n+CFG_UNIXY_i686-unknown-freebsd := 1\n+CFG_LDPATH_i686-unknown-freebsd :=\n+CFG_RUN_i686-unknown-freebsd=$(2)\n+CFG_RUN_TARG_i686-unknown-freebsd=$(call CFG_RUN_i686-unknown-freebsd,,$(2))\n+CFG_GNU_TRIPLE_i686-unknown-freebsd := i686-unknown-freebsd"}, {"sha": "6f12836f05624fd52561fb585a0d21d2517ad33f", "filename": "mk/cfg/x86_64-pc-windows-msvc.mk", "status": "modified", "additions": 5, "deletions": 63, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -1,9 +1,9 @@\n # x86_64-pc-windows-msvc configuration\n-CC_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n-LINK_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LINK)\" -nologo\n-CXX_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n-CPP_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n-AR_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LIB)\" -nologo\n+CC_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL_x86_64)\" -nologo\n+LINK_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LINK_x86_64)\" -nologo\n+CXX_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL_x86_64)\" -nologo\n+CPP_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL_x86_64)\" -nologo\n+AR_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LIB_x86_64)\" -nologo\n CFG_LIB_NAME_x86_64-pc-windows-msvc=$(1).dll\n CFG_STATIC_LIB_NAME_x86_64-pc-windows-msvc=$(1).lib\n CFG_LIB_GLOB_x86_64-pc-windows-msvc=$(1)-*.{dll,lib}\n@@ -23,64 +23,6 @@ CFG_RUN_x86_64-pc-windows-msvc=$(2)\n CFG_RUN_TARG_x86_64-pc-windows-msvc=$(call CFG_RUN_x86_64-pc-windows-msvc,,$(2))\n CFG_GNU_TRIPLE_x86_64-pc-windows-msvc := x86_64-pc-win32\n \n-# These two environment variables are scraped by the `./configure` script and\n-# are necessary for `cl.exe` to find standard headers (the INCLUDE variable) and\n-# for `link.exe` to find standard libraries (the LIB variable).\n-ifdef CFG_MSVC_INCLUDE_PATH\n-export INCLUDE := $(CFG_MSVC_INCLUDE_PATH)\n-endif\n-ifdef CFG_MSVC_LIB_PATH\n-export LIB := $(CFG_MSVC_LIB_PATH)\n-endif\n-\n-# Unfortunately `link.exe` is also a program in `/usr/bin` on MinGW installs,\n-# but it's not the one that we want. As a result we make sure that our detected\n-# `link.exe` shows up in PATH first.\n-ifdef CFG_MSVC_LINK\n-export PATH := $(CFG_MSVC_ROOT)/VC/bin/amd64:$(PATH)\n-endif\n-\n-# There are more comments about this available in the target specification for\n-# Windows MSVC in the compiler, but the gist of it is that we use `llvm-ar.exe`\n-# instead of `lib.exe` for assembling archives, so we need to inject this custom\n-# dependency here.\n-NATIVE_TOOL_DEPS_core_T_x86_64-pc-windows-msvc += llvm-ar.exe\n-INSTALLED_BINS_x86_64-pc-windows-msvc += llvm-ar.exe\n-\n-# When working with MSVC on windows, each DLL needs to explicitly declare its\n-# interface to the outside world through some means. The options for doing so\n-# include:\n-#\n-# 1. A custom attribute on each function itself\n-# 2. A linker argument saying what to export\n-# 3. A file which lists all symbols that need to be exported\n-#\n-# The Rust compiler takes care (1) for us for all Rust code by annotating all\n-# public-facing functions with dllexport, but we have a few native dependencies\n-# which need to cross the DLL boundary. The most important of these dependencies\n-# is LLVM which is linked into `rustc_llvm.dll` but primarily used from\n-# `rustc_trans.dll`. This means that many of LLVM's C API functions need to be\n-# exposed from `rustc_llvm.dll` to be forwarded over the boundary.\n-#\n-# Unfortunately, at this time, LLVM does not handle this sort of exportation on\n-# Windows for us, so we're forced to do it ourselves if we want it (which seems\n-# like the path of least resistance right now). To do this we generate a `.DEF`\n-# file [1] which we then custom-pass to the linker when building the rustc_llvm\n-# crate. This DEF file list all symbols that are exported from\n-# `src/librustc_llvm/lib.rs` and is generated by a small python script.\n-#\n-# Fun times!\n-#\n-# [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n-RUSTFLAGS_rustc_llvm_T_x86_64-pc-windows-msvc += \\\n-\t-C link-args=\"-DEF:x86_64-pc-windows-msvc/rt/rustc_llvm.def\"\n-CUSTOM_DEPS_rustc_llvm_T_x86_64-pc-windows-msvc += \\\n-\tx86_64-pc-windows-msvc/rt/rustc_llvm.def\n-\n-x86_64-pc-windows-msvc/rt/rustc_llvm.def: $(S)src/etc/mklldef.py \\\n-\t\t\t$(S)src/librustc_llvm/lib.rs\n-\t$(CFG_PYTHON) $^ $@ rustc_llvm-$(CFG_FILENAME_EXTRA)\n-\n # All windows nightiles are currently a GNU triple, so this MSVC triple is not\n # bootstrapping from itself. This is relevant during stage0, and other parts of\n # the build system take this into account."}, {"sha": "401b0fb7ab0082084a524bc93d515747b0dd9abf", "filename": "mk/cfg/x86_64-unknown-netbsd.mk", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fx86_64-unknown-netbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fcfg%2Fx86_64-unknown-netbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-netbsd.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -0,0 +1,22 @@\n+# x86_64-unknown-netbsd configuration\n+CC_x86_64-unknown-netbsd=$(CC)\n+CXX_x86_64-unknown-netbsd=$(CXX)\n+CPP_x86_64-unknown-netbsd=$(CPP)\n+AR_x86_64-unknown-netbsd=$(AR)\n+CFG_LIB_NAME_x86_64-unknown-netbsd=lib$(1).so\n+CFG_STATIC_LIB_NAME_x86_64-unknown-netbsd=lib$(1).a\n+CFG_LIB_GLOB_x86_64-unknown-netbsd=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_x86_64-unknown-netbsd=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_x86_64-unknown-netbsd := -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-netbsd := -Wall -Werror -g -fPIC -I/usr/local/include $(CFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-netbsd := -shared -fPIC -g -pthread  -lrt\n+CFG_GCCISH_DEF_FLAG_x86_64-unknown-netbsd := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_x86_64-unknown-netbsd :=\n+CFG_INSTALL_NAME_x86_64-unknown-netbsd =\n+CFG_EXE_SUFFIX_x86_64-unknown-netbsd :=\n+CFG_WINDOWSY_x86_64-unknown-netbsd :=\n+CFG_UNIXY_x86_64-unknown-netbsd := 1\n+CFG_LDPATH_x86_64-unknown-netbsd :=\n+CFG_RUN_x86_64-unknown-netbsd=$(2)\n+CFG_RUN_TARG_x86_64-unknown-netbsd=$(call CFG_RUN_x86_64-unknown-netbsd,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-netbsd := x86_64-unknown-netbsd"}, {"sha": "964ae626d0c8d1c8d288d78c1ae8c88a2232efee", "filename": "mk/main.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -295,7 +295,6 @@ LLVM_BINDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --bindir)\n LLVM_INCDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --includedir)\n LLVM_LIBDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libdir)\n LLVM_LIBDIR_RUSTFLAGS_$(1)=-L \"$$(LLVM_LIBDIR_$(1))\"\n-LLVM_LIBS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libs $$(LLVM_COMPONENTS))\n LLVM_LDFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --ldflags)\n ifeq ($$(findstring freebsd,$(1)),freebsd)\n # On FreeBSD, it may search wrong headers (that are for pre-installed LLVM),"}, {"sha": "60fe22cb32ee695a4a749d0af0a677b727a2cf0a", "filename": "mk/platform.mk", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -238,3 +238,56 @@ endef\n \n $(foreach target,$(CFG_TARGET), \\\n   $(eval $(call CFG_MAKE_TOOLCHAIN,$(target))))\n+\n+# There are more comments about this available in the target specification for\n+# Windows MSVC in the compiler, but the gist of it is that we use `llvm-ar.exe`\n+# instead of `lib.exe` for assembling archives, so we need to inject this custom\n+# dependency here.\n+define ADD_LLVM_AR_TO_MSVC_DEPS\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+NATIVE_TOOL_DEPS_core_T_$(1) += llvm-ar.exe\n+INSTALLED_BINS_$(1) += llvm-ar.exe\n+endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call ADD_LLVM_AR_TO_MSVC_DEPS,$(target))))\n+\n+# When working with MSVC on windows, each DLL needs to explicitly declare its\n+# interface to the outside world through some means. The options for doing so\n+# include:\n+#\n+# 1. A custom attribute on each function itself\n+# 2. A linker argument saying what to export\n+# 3. A file which lists all symbols that need to be exported\n+#\n+# The Rust compiler takes care (1) for us for all Rust code by annotating all\n+# public-facing functions with dllexport, but we have a few native dependencies\n+# which need to cross the DLL boundary. The most important of these dependencies\n+# is LLVM which is linked into `rustc_llvm.dll` but primarily used from\n+# `rustc_trans.dll`. This means that many of LLVM's C API functions need to be\n+# exposed from `rustc_llvm.dll` to be forwarded over the boundary.\n+#\n+# Unfortunately, at this time, LLVM does not handle this sort of exportation on\n+# Windows for us, so we're forced to do it ourselves if we want it (which seems\n+# like the path of least resistance right now). To do this we generate a `.DEF`\n+# file [1] which we then custom-pass to the linker when building the rustc_llvm\n+# crate. This DEF file list all symbols that are exported from\n+# `src/librustc_llvm/lib.rs` and is generated by a small python script.\n+#\n+# Fun times!\n+#\n+# [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n+define ADD_RUSTC_LLVM_DEF_TO_MSVC\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+RUSTFLAGS_rustc_llvm_T_$(1) += -C link-args=\"-DEF:$(1)/rt/rustc_llvm.def\"\n+CUSTOM_DEPS_rustc_llvm_T_$(1) += $(1)/rt/rustc_llvm.def\n+\n+$(1)/rt/rustc_llvm.def: $$(S)src/etc/mklldef.py $$(S)src/librustc_llvm/lib.rs\n+\t$$(CFG_PYTHON) $$^ $$@ rustc_llvm-$$(CFG_FILENAME_EXTRA)\n+endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call ADD_RUSTC_LLVM_DEF_TO_MSVC,$(target))))\n+"}, {"sha": "69277e774e43bf99e41f767dfd70a4c1608c53d9", "filename": "mk/rt.mk", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -53,9 +53,7 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n NATIVE_DEPS_miniz_$(1) = miniz.c\n NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c\n-NATIVE_DEPS_rustrt_native_$(1) := \\\n-\t\t\trust_try.ll \\\n-\t\t\tarch/$$(HOST_$(1))/record_sp.S\n+NATIVE_DEPS_rustrt_native_$(1) := arch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n \n@@ -69,14 +67,6 @@ NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n \n RT_OUTPUT_DIR_$(1) := $(1)/rt\n \n-$$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.ll $$(MKFILE_DEPS) \\\n-\t    $$(LLVM_CONFIG_$$(CFG_BUILD))\n-\t@mkdir -p $$(@D)\n-\t@$$(call E, compile: $$@)\n-\t$$(Q)$$(LLC_$$(CFG_BUILD)) $$(CFG_LLC_FLAGS_$(1)) \\\n-\t    -filetype=obj -mtriple=$$(CFG_LLVM_TARGET_$(1)) \\\n-\t    -relocation-model=pic -o $$@ $$<\n-\n $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.c $$(MKFILE_DEPS)\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n@@ -90,6 +80,17 @@ $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.S $$(MKFILE_DEPS) \\\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_ASSEMBLE_$(1),$$@,$$<)\n+\n+# On MSVC targets the compiler's default include path (e.g. where to find system\n+# headers) is specified by the INCLUDE environment variable. This may not be set\n+# so the ./configure script scraped the relevant values and this is the location\n+# that we put them into cl.exe's environment.\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+$$(RT_OUTPUT_DIR_$(1))/%.o: \\\n+\texport INCLUDE := $$(CFG_MSVC_INCLUDE_PATH_$$(HOST_$(1)))\n+$(1)/rustllvm/%.o: \\\n+\texport INCLUDE := $$(CFG_MSVC_INCLUDE_PATH_$$(HOST_$(1)))\n+endif\n endef\n \n $(foreach target,$(CFG_TARGET),$(eval $(call NATIVE_LIBRARIES,$(target))))\n@@ -104,7 +105,6 @@ define THIRD_PARTY_LIB\n OBJS_$(2)_$(1) := $$(NATIVE_DEPS_$(2)_$(1):%=$$(RT_OUTPUT_DIR_$(1))/%)\n OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.c=.o)\n OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.cpp=.o)\n-OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.ll=.o)\n OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.S=.o)\n NATIVE_$(2)_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),$(2))\n $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1)): $$(OBJS_$(2)_$(1))\n@@ -237,8 +237,12 @@ COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1))\n ifeq ($$(findstring msvc,$(1)),msvc)\n COMPRT_CC_$(1) := gcc\n COMPRT_AR_$(1) := ar\n+ifeq ($$(findstring i686,$(1)),i686)\n+COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1)) -m32\n+else\n COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1)) -m64\n endif\n+endif\n \n $$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: compiler-rt)"}, {"sha": "6adffda7d1b322ab10f5c7a9e83a73f13a8c5aad", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -24,7 +24,8 @@ LLVM_EXTRA_INCDIRS_$(1)= $$(call CFG_CC_INCLUDE_$(1),$(S)src/llvm/include) \\\n endif\n \n RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n-\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp)\n+\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp \\\n+\tArchiveWrapper.cpp)\n \n RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\\n                      $$(call CFG_CC_INCLUDE_$(1),$$(LLVM_INCDIR_$(1))) \\"}, {"sha": "c2de9af39c7643397ab6370978b4d550f3503b51", "filename": "mk/target.mk", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -220,3 +220,38 @@ $(foreach target,$(CFG_TARGET), \\\n  $(foreach crate,$(CRATES), \\\n   $(foreach tool,$(NATIVE_TOOL_DEPS_$(crate)_T_$(target)), \\\n    $(eval $(call MOVE_TOOLS_TO_SNAPSHOT_HOST_DIR,0,$(target),$(BOOTSTRAP_FROM_$(target)),$(crate),$(tool))))))\n+\n+# For MSVC targets we need to set up some environment variables for the linker\n+# to work correctly when building Rust crates. These two variables are:\n+#\n+# - LIB tells the linker the default search path for finding system libraries,\n+#   for example kernel32.dll\n+# - PATH needs to be modified to ensure that MSVC's link.exe is first in the\n+#   path instead of MinGW's /usr/bin/link.exe (entirely unrelated)\n+#\n+# The values for these variables are detected by the configure script.\n+define SETUP_LIB_MSVC_ENV_VARS\n+ifeq ($$(findstring msvc,$(2)),msvc)\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n+\texport LIB := $$(CFG_MSVC_LIB_PATH_$$(HOST_$(2)))\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n+\texport PATH := $$(CFG_MSVC_BINDIR_$$(HOST_$(2))):$$(PATH)\n+endif\n+endef\n+define SETUP_TOOL_MSVC_ENV_VARS\n+ifeq ($$(findstring msvc,$(2)),msvc)\n+$$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n+\texport LIB := $$(CFG_MSVC_LIB_PATH_$$(HOST_$(2)))\n+$$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n+\texport PATH := $$(CFG_MSVC_BINDIR_$$(HOST_$(2))):$$(PATH)\n+endif\n+endef\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach crate,$(CRATES), \\\n+   $(eval $(call SETUP_LIB_MSVC_ENV_VARS,0,$(target),$(host),$(crate))))))\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach tool,$(TOOLS), \\\n+   $(eval $(call SETUP_TOOL_MSVC_ENV_VARS,0,$(target),$(host),$(tool))))))"}, {"sha": "36c676391019bd1ad44a078aede726784cf786ee", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -15,7 +15,7 @@\n #![feature(libc)]\n #![feature(path_ext)]\n #![feature(rustc_private)]\n-#![feature(slice_extras)]\n+#![feature(slice_splits)]\n #![feature(str_char)]\n #![feature(test)]\n #![feature(vec_push_all)]\n@@ -90,9 +90,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\"),\n           optflag(\"h\", \"help\", \"show this message\"));\n \n-    assert!(!args.is_empty());\n-    let argv0 = args[0].clone();\n-    let args_ = args.tail();\n+    let (argv0, args_) = args.split_first().unwrap();\n     if args[1] == \"-h\" || args[1] == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(&message, &groups));"}, {"sha": "5b62f29b8242323df0ac7e07c43ad7631925b745", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -344,7 +344,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n         check_lines,\n         breakpoint_lines\n     } = parse_debugger_commands(testfile, \"gdb\");\n-    let mut cmds = commands.connect(\"\\n\");\n+    let mut cmds = commands.join(\"\\n\");\n \n     // compile test file (it should have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testfile);\n@@ -799,7 +799,7 @@ fn cleanup_debug_info_options(options: &Option<String>) -> Option<String> {\n         split_maybe_args(options).into_iter()\n                                  .filter(|x| !options_to_remove.contains(x))\n                                  .collect::<Vec<String>>()\n-                                 .connect(\" \");\n+                                 .join(\" \");\n     Some(new_options)\n }\n \n@@ -1126,16 +1126,10 @@ impl fmt::Display for Status {\n \n fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, &[])\n-}\n-\n-fn compile_test_(config: &Config, props: &TestProps,\n-                 testfile: &Path, extra_args: &[String]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut link_args = vec!(\"-L\".to_string(),\n-                             aux_dir.to_str().unwrap().to_string());\n-    link_args.extend(extra_args.iter().cloned());\n+    let link_args = vec!(\"-L\".to_string(),\n+                         aux_dir.to_str().unwrap().to_string());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n@@ -1144,7 +1138,7 @@ fn compile_test_(config: &Config, props: &TestProps,\n }\n \n fn document(config: &Config, props: &TestProps,\n-            testfile: &Path, extra_args: &[String]) -> (ProcRes, PathBuf) {\n+            testfile: &Path) -> (ProcRes, PathBuf) {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     let out_dir = output_base_name(config, testfile);\n     let _ = fs::remove_dir_all(&out_dir);\n@@ -1154,7 +1148,6 @@ fn document(config: &Config, props: &TestProps,\n                         \"-o\".to_string(),\n                         out_dir.to_str().unwrap().to_string(),\n                         testfile.to_str().unwrap().to_string()];\n-    args.extend(extra_args.iter().cloned());\n     args.extend(split_maybe_args(&props.compile_flags));\n     let args = ProcArgs {\n         prog: config.rustdoc_path.to_str().unwrap().to_string(),\n@@ -1419,15 +1412,15 @@ fn make_cmdline(libpath: &str, prog: &str, args: &[String]) -> String {\n \n     // Linux and mac don't require adjusting the library search path\n     if cfg!(unix) {\n-        format!(\"{} {}\", prog, args.connect(\" \"))\n+        format!(\"{} {}\", prog, args.join(\" \"))\n     } else {\n         // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n         // for diagnostic purposes\n         fn lib_path_cmd_prefix(path: &str) -> String {\n             format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n         }\n \n-        format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.connect(\" \"))\n+        format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.join(\" \"))\n     }\n }\n \n@@ -1709,15 +1702,18 @@ fn run_codegen_test(config: &Config, props: &TestProps, testfile: &Path) {\n }\n \n fn charset() -> &'static str {\n-    if cfg!(any(target_os = \"bitrig\", target_os = \"freebsd\")) {\n+    // FreeBSD 10.1 defaults to GDB 6.1.1 which doesn't support \"auto\" charset\n+    if cfg!(target_os = \"bitrig\") {\n         \"auto\"\n+    } else if cfg!(target_os = \"freebsd\") {\n+        \"ISO-8859-1\"\n     } else {\n         \"UTF-8\"\n     }\n }\n \n fn run_rustdoc_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    let (proc_res, out_dir) = document(config, props, testfile, &[]);\n+    let (proc_res, out_dir) = document(config, props, testfile);\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n     }"}, {"sha": "13d6c029ff58458900dc57c34fc02fba75dab871", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -21,6 +21,7 @@ const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"ios\", \"ios\"),\n     (\"linux\", \"linux\"),\n     (\"mingw32\", \"windows\"),\n+    (\"netbsd\", \"netbsd\"),\n     (\"openbsd\", \"openbsd\"),\n     (\"win32\", \"windows\"),\n     (\"windows\", \"windows\"),"}, {"sha": "5e99876f5dab8c3f3eb5f2feda6fc5a6b0a298df", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -99,7 +99,7 @@ Second, it makes cost explicit. In general, the only safe way to have a\n non-exhaustive match would be to panic the thread if nothing is matched, though\n it could fall through if the type of the `match` expression is `()`. This sort\n of hidden cost and special casing is against the language's philosophy. It's\n-easy to ignore certain cases by using the `_` wildcard:\n+easy to ignore all unspecified cases by using the `_` wildcard:\n \n ```rust,ignore\n match val.do_something() {"}, {"sha": "dc80ec4399131470dab2876cadd8cf09ad8bd577", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -1,4 +1,7 @@\n-% The (old) Rust Pointer Guide\n+% The Rust Pointer Guide\n \n-This content has moved into\n-[the Rust Programming Language book](book/pointers.html).\n+This content has been removed, with no direct replacement. Rust only\n+has two built-in pointer types now,\n+[references](book/references-and-borrowing.html) and [raw\n+pointers](book/raw-pointers.html). Older Rusts had many more pointer\n+types, they\u2019re gone now."}, {"sha": "c1f9ea6b3b003895498dea23b29348198714d389", "filename": "src/doc/index.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -20,6 +20,13 @@ series of small examples.\n \n [rbe]: http://rustbyexample.com/\n \n+# The Standard Library\n+\n+We have [API documentation for the entire standard\n+library](std/index.html). There's a list of crates on the left with more\n+specific sections, or you can use the search bar at the top to search for\n+something if you know its name.\n+\n # Community & Getting Help\n \n If you need help with something, or just want to talk about Rust with others,\n@@ -75,13 +82,6 @@ There are questions that are asked quite often, so we've made FAQs for them:\n * [Project FAQ](complement-project-faq.html)\n * [How to submit a bug report](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports)\n \n-# The Standard Library\n-\n-We have [API documentation for the entire standard\n-library](std/index.html). There's a list of crates on the left with more\n-specific sections, or you can use the search bar at the top to search for\n-something if you know its name.\n-\n # The Error Index\n \n If you encounter an error while compiling your code you may be able to look it"}, {"sha": "9528871a77491ecd43027b47f7f0d9a9f3dc727e", "filename": "src/doc/reference.md", "status": "modified", "additions": 130, "deletions": 89, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -338,12 +338,16 @@ type of the literal. The integer suffix must be the name of one of the\n integral types: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`,\n `isize`, or `usize`.\n \n-The type of an _unsuffixed_ integer literal is determined by type inference.\n-If an integer type can be _uniquely_ determined from the surrounding program\n-context, the unsuffixed integer literal has that type. If the program context\n-underconstrains the type, it defaults to the signed 32-bit integer `i32`; if\n-the program context overconstrains the type, it is considered a static type\n-error.\n+The type of an _unsuffixed_ integer literal is determined by type inference:\n+\n+* If an integer type can be _uniquely_ determined from the surrounding\n+  program context, the unsuffixed integer literal has that type.\n+\n+* If the program context under-constrains the type, it defaults to the\n+  signed 32-bit integer `i32`.\n+\n+* If the program context over-constrains the type, it is considered a\n+  static type error.\n \n Examples of integer literals of various forms:\n \n@@ -371,12 +375,17 @@ The suffix forcibly sets the type of the literal. There are two valid\n _floating-point suffixes_, `f32` and `f64` (the 32-bit and 64-bit floating point\n types), which explicitly determine the type of the literal.\n \n-The type of an _unsuffixed_ floating-point literal is determined by type\n-inference. If a floating-point type can be _uniquely_ determined from the\n-surrounding program context, the unsuffixed floating-point literal has that type.\n-If the program context underconstrains the type, it defaults to double-precision `f64`;\n-if the program context overconstrains the type, it is considered a static type\n-error.\n+The type of an _unsuffixed_ floating-point literal is determined by\n+type inference:\n+\n+* If a floating-point type can be _uniquely_ determined from the\n+  surrounding program context, the unsuffixed floating-point literal\n+  has that type.\n+\n+* If the program context under-constrains the type, it defaults to `f64`.\n+\n+* If the program context over-constrains the type, it is considered a\n+  static type error.\n \n Examples of floating-point literals of various forms:\n \n@@ -582,8 +591,9 @@ always been designed to be compiled. For these reasons, this section assumes a\n compiler.\n \n Rust's semantics obey a *phase distinction* between compile-time and\n-run-time.[^phase-distinction] Those semantic rules that have a *static\n-interpretation* govern the success or failure of compilation. Those semantics\n+run-time.[^phase-distinction] Semantic rules that have a *static\n+interpretation* govern the success or failure of compilation, while\n+semantic rules\n that have a *dynamic interpretation* govern the behavior of the program at\n run-time.\n \n@@ -1047,11 +1057,8 @@ This is a list of behavior not considered *unsafe* in Rust terms, but that may\n be undesired.\n \n * Deadlocks\n-* Reading data from private fields (`std::repr`)\n * Leaks of memory and other resources\n * Exiting without calling destructors\n-* Sending signals\n-* Accessing/modifying the file system\n * Integer overflow\n   - Overflow is considered \"unexpected\" behavior and is always user-error,\n     unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n@@ -1286,7 +1293,7 @@ All access to a static is safe, but there are a number of restrictions on\n statics:\n \n * Statics may not contain any destructors.\n-* The types of static values must ascribe to `Sync` to allow threadsafe access.\n+* The types of static values must ascribe to `Sync` to allow thread-safe access.\n * Statics may not refer to other statics by value, only by reference.\n * Constants cannot refer to statics.\n \n@@ -1630,6 +1637,10 @@ The type of a function declared in an extern block is `extern \"abi\" fn(A1, ...,\n An) -> R`, where `A1...An` are the declared types of its arguments and `R` is\n the declared return type.\n \n+It is valid to add the `link` attribute on an empty extern block. You can use\n+this to satisfy the linking requirements of extern blocks elsewhere in your code\n+(including upstream crates) instead of adding the attribute to each extern block.\n+\n ## Visibility and Privacy\n \n These two terms are often used interchangeably, and what they are attempting to\n@@ -1688,7 +1699,7 @@ explain, here's a few use cases and what they would entail:\n * A crate needs a global available \"helper module\" to itself, but it doesn't\n   want to expose the helper module as a public API. To accomplish this, the\n   root of the crate's hierarchy would have a private module which then\n-  internally has a \"public api\". Because the entire crate is a descendant of\n+  internally has a \"public API\". Because the entire crate is a descendant of\n   the root, then the entire local crate can access this private module through\n   the second case.\n \n@@ -1951,8 +1962,6 @@ macro scope.\n   object file that this item's contents will be placed into.\n - `no_mangle` - on any item, do not apply the standard name mangling. Set the\n   symbol for this item to its identifier.\n-- `packed` - on structs or enums, eliminate any padding that would be used to\n-  align fields.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n@@ -2026,7 +2035,7 @@ The following configurations must be defined by the implementation:\n   as a configuration itself, like `unix` or `windows`.\n * `target_os = \"...\"`. Operating system of the target, examples include\n   `\"windows\"`, `\"macos\"`, `\"ios\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"`, `\"dragonfly\"`,\n-  `\"bitrig\"` or `\"openbsd\"`.\n+  `\"bitrig\"` , `\"openbsd\"` or `\"netbsd\"`.\n * `target_pointer_width = \"...\"`. Target pointer width in bits. This is set\n   to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n   64-bit pointers.\n@@ -2360,6 +2369,8 @@ The currently implemented features of the reference compiler are:\n                               internally without imposing on callers\n                               (i.e. making them behave like function calls in\n                               terms of encapsulation).\n+* - `default_type_parameter_fallback` - Allows type parameter defaults to\n+                                        influence type inference.\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n@@ -2509,9 +2520,8 @@ Here are some examples:\n #### Moved and copied types\n \n When a [local variable](#variables) is used as an\n-[rvalue](#lvalues,-rvalues-and-temporaries) the variable will either be moved\n-or copied, depending on its type. All values whose type implements `Copy` are\n-copied, all others are moved.\n+[rvalue](#lvalues,-rvalues-and-temporaries), the variable will be copied\n+if its type implements `Copy`. All others are moved.\n \n ### Literal expressions\n \n@@ -2876,7 +2886,6 @@ operand.\n ```\n # let mut x = 0;\n # let y = 0;\n-\n x = y;\n ```\n \n@@ -2966,14 +2975,12 @@ move values (depending on their type) from the environment into the lambda\n expression's captured environment.\n \n In this example, we define a function `ten_times` that takes a higher-order\n-function argument, and call it with a lambda expression as an argument:\n+function argument, and we then call it with a lambda expression as an argument:\n \n ```\n fn ten_times<F>(f: F) where F: Fn(i32) {\n-    let mut i = 0i32;\n-    while i < 10 {\n-        f(i);\n-        i += 1;\n+    for index in 0..10 {\n+        f(index);\n     }\n }\n \n@@ -3322,10 +3329,13 @@ An example of a tuple type and its use:\n \n ```\n type Pair<'a> = (i32, &'a str);\n-let p: Pair<'static> = (10, \"hello\");\n+let p: Pair<'static> = (10, \"ten\");\n let (a, b) = p;\n-assert!(b != \"world\");\n-assert!(p.0 == 10);\n+\n+assert_eq!(a, 10);\n+assert_eq!(b, \"ten\");\n+assert_eq!(p.0, 10);\n+assert_eq!(p.1, \"ten\");\n ```\n \n For historical reasons and convenience, the tuple type with no elements (`()`)\n@@ -3335,27 +3345,32 @@ is often called \u2018unit\u2019 or \u2018the unit type\u2019.\n \n Rust has two different types for a list of items:\n \n-* `[T; N]`, an 'array'.\n-* `&[T]`, a 'slice'.\n+* `[T; N]`, an 'array'\n+* `&[T]`, a 'slice'\n \n An array has a fixed size, and can be allocated on either the stack or the\n heap.\n \n A slice is a 'view' into an array. It doesn't own the data it points\n to, it borrows it.\n \n-An example of each kind:\n+Examples:\n \n ```{rust}\n-let vec: Vec<i32> = vec![1, 2, 3];\n-let arr: [i32; 3] = [1, 2, 3];\n-let s: &[i32] = &vec[..];\n+// A stack-allocated array\n+let array: [i32; 3] = [1, 2, 3];\n+\n+// A heap-allocated array\n+let vector: Vec<i32> = vec![1, 2, 3];\n+\n+// A slice into an array\n+let slice: &[i32] = &vector[..];\n ```\n \n As you can see, the `vec!` macro allows you to create a `Vec<T>` easily. The\n `vec!` macro is also part of the standard library, rather than the language.\n \n-All in-bounds elements of arrays, and slices are always initialized, and access\n+All in-bounds elements of arrays and slices are always initialized, and access\n to an array or slice is always bounds-checked.\n \n ### Structure types\n@@ -3489,7 +3504,7 @@ x = bo(5,7);\n \n #### Function types for specific items\n \n-Internally to the compiler, there are also function types that are specific to a particular\n+Internal to the compiler, there are also function types that are specific to a particular\n function item. In the following snippet, for example, the internal types of the functions\n `foo` and `bar` are different, despite the fact that they have the same signature:\n \n@@ -3517,13 +3532,14 @@ more of the closure traits:\n \n * `FnMut`\n   : The closure can be called multiple times as mutable. A closure called as\n-    `FnMut` can mutate values from its environment. `FnMut` implies\n-    `FnOnce`.\n+    `FnMut` can mutate values from its environment. `FnMut` inherits from\n+    `FnOnce` (i.e. anything implementing `FnMut` also implements `FnOnce`).\n \n * `Fn`\n   : The closure can be called multiple times through a shared reference.\n     A closure called as `Fn` can neither move out from nor mutate values\n-    from its environment. `Fn` implies `FnMut` and `FnOnce`.\n+    from its environment. `Fn` inherits from `FnMut`, which itself\n+    inherits from `FnOnce`.\n \n \n ### Trait objects\n@@ -3646,53 +3662,77 @@ Coercions are defined in [RFC401]. A coercion is implicit and has no syntax.\n ### Coercion sites\n \n A coercion can only occur at certain coercion sites in a program; these are\n-typically places where the desired type is explicit or can be dervied by\n+typically places where the desired type is explicit or can be derived by\n propagation from explicit types (without type inference). Possible coercion\n sites are:\n \n * `let` statements where an explicit type is given.\n \n-    In `let _: U = e;`, `e` is coerced to have type `U`.\n+   For example, `128` is coerced to have type `i8` in the following:\n+\n+   ```rust\n+   let _: i8 = 128;\n+   ```\n \n * `static` and `const` statements (similar to `let` statements).\n \n-* arguments for function calls.\n+* Arguments for function calls\n+\n+  The value being coerced is the actual parameter, and it is coerced to\n+  the type of the formal parameter.\n \n-    The value being coerced is the\n-    actual parameter and it is coerced to the type of the formal parameter. For\n-    example, let `foo` be defined as `fn foo(x: U) { ... }` and call it as\n-    `foo(e);`. Then `e` is coerced to have type `U`;\n+  For example, `128` is coerced to have type `i8` in the following:\n \n-* instantiations of struct or variant fields.\n+  ```rust\n+  fn bar(_: i8) { }\n \n-    Assume we have a `struct\n-    Foo { x: U }` and instantiate it as `Foo { x: e }`. Then `e` is coerced to\n-    have type `U`.\n+  fn main() {\n+     bar(128);\n+  }\n+  ```\n \n-* function results (either the final line of a block if it is not semicolon\n-terminated or any expression in a `return` statement).\n+* Instantiations of struct or variant fields\n \n-    In `fn foo() -> U { e }`, `e` is coerced to to have type `U`.\n+  For example, `128` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  struct Foo { x: i8 }\n+\n+  fn main() {\n+      Foo { x: 128 };\n+  }\n+  ```\n+\n+* Function results, either the final line of a block if it is not\n+  semicolon-terminated or any expression in a `return` statement\n+\n+  For example, `128` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn foo() -> i8 {\n+      128\n+  }\n+  ```\n \n If the expression in one of these coercion sites is a coercion-propagating\n expression, then the relevant sub-expressions in that expression are also\n coercion sites. Propagation recurses from these new coercion sites.\n Propagating expressions and their relevant sub-expressions are:\n \n-* array literals, where the array has type `[U; n]`. Each sub-expression in\n+* Array literals, where the array has type `[U; n]`. Each sub-expression in\n the array literal is a coercion site for coercion to type `U`.\n \n-* array literals with repeating syntax, where the array has type `[U; n]`. The\n+* Array literals with repeating syntax, where the array has type `[U; n]`. The\n repeated sub-expression is a coercion site for coercion to type `U`.\n \n-* tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n+* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n Each sub-expression is a coercion site to the respective type, e.g. the\n zeroth sub-expression is a coercion site to type `U_0`.\n \n-* parenthesised sub-expressions (`(e)`). If the expression has type `U`, then\n+* Parenthesised sub-expressions (`(e)`): if the expression has type `U`, then\n the sub-expression is a coercion site to `U`.\n \n-* blocks. If a block has type `U`, then the last expression in the block (if\n+* Blocks: if a block has type `U`, then the last expression in the block (if\n it is not semicolon-terminated) is a coercion site to `U`. This includes\n blocks which are part of control flow statements, such as `if`/`else`, if\n the block has a known type.\n@@ -3701,45 +3741,46 @@ the block has a known type.\n \n Coercion is allowed between the following types:\n \n-* `T` to `U` if `T` is a subtype of `U` (*reflexive case*).\n+* `T` to `U` if `T` is a subtype of `U` (*reflexive case*)\n \n * `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n-(*transitive case*).\n+(*transitive case*)\n \n     Note that this is not fully supported yet\n \n-* `&mut T` to `&T`.\n+* `&mut T` to `&T`\n \n-* `*mut T` to `*const T`.\n+* `*mut T` to `*const T`\n \n-* `&T` to `*const T`.\n+* `&T` to `*const T`\n \n-* `&mut T` to `*mut T`.\n+* `&mut T` to `*mut T`\n \n * `&T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n \n-```rust\n-use std::ops::Deref;\n+  ```rust\n+  use std::ops::Deref;\n \n-struct CharContainer {\n-    value: char\n-}\n+  struct CharContainer {\n+      value: char\n+  }\n \n-impl Deref for CharContainer {\n-    type Target = char;\n+  impl Deref for CharContainer {\n+      type Target = char;\n \n-    fn deref<'a>(&'a self) -> &'a char {\n-        &self.value\n-    }\n-}\n+      fn deref<'a>(&'a self) -> &'a char {\n+          &self.value\n+      }\n+  }\n \n-fn foo(arg: &char) {}\n+  fn foo(arg: &char) {}\n+\n+  fn main() {\n+      let x = &mut CharContainer { value: 'y' };\n+      foo(x); //&mut CharContainer is coerced to &char.\n+  }\n+  ```\n \n-fn main() {\n-    let x = &mut CharContainer { value: 'y' };\n-    foo(x); //&mut CharContainer is coerced to &char.\n-}\n-```\n * `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n \n * TyCtor(`T`) to TyCtor(coerce_inner(`T`)), where TyCtor(`T`) is one of\n@@ -3953,7 +3994,7 @@ In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n all compilation needs, and the other options are just available if more\n fine-grained control is desired over the output format of a Rust crate.\n \n-# Appendix: Rationales and design tradeoffs\n+# Appendix: Rationales and design trade-offs\n \n *TODO*.\n \n@@ -3963,7 +4004,7 @@ Rust is not a particularly original language, with design elements coming from\n a wide range of sources. Some of these are listed below (including elements\n that have since been removed):\n \n-* SML, OCaml: algebraic datatypes, pattern matching, type inference,\n+* SML, OCaml: algebraic data types, pattern matching, type inference,\n   semicolon statement separation\n * C++: references, RAII, smart pointers, move semantics, monomorphisation,\n   memory model"}, {"sha": "6204f38a37753ce603b4e830c8aae400c5b360c3", "filename": "src/doc/rust.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -221,6 +221,10 @@ a > code {\n     color: #428BCA;\n }\n \n+.section-header > a > code {\n+    color: #8D1A38;\n+}\n+\n /* Code highlighting */\n pre.rust .kw { color: #8959A8; }\n pre.rust .kw-2, pre.rust .prelude-ty { color: #4271AE; }"}, {"sha": "85f0019276eefe36cb61e3fc957eb3e0dba220a8", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -16,6 +16,7 @@\n     * [Iterators](iterators.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n+    * [Choosing your Guarantees](choosing-your-guarantees.md)\n     * [FFI](ffi.md)\n     * [Borrow and AsRef](borrow-and-asref.md)\n     * [Release Channels](release-channels.md)\n@@ -63,7 +64,7 @@\n     * [No stdlib](no-stdlib.md)\n     * [Intrinsics](intrinsics.md)\n     * [Lang items](lang-items.md)\n-    * [Link args](link-args.md)\n+    * [Advanced linking](advanced-linking.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n     * [Slice Patterns](slice-patterns.md)"}, {"sha": "e317f67934498cf778af3b73c6bab18e1faac3f8", "filename": "src/doc/trpl/academic-research.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Facademic-research.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Facademic-research.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Facademic-research.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -12,7 +12,7 @@ Recommended for inspiration and a better understanding of Rust's background.\n * [Macros that work together](https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf)\n * [Traits: composable units of behavior](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf)\n * [Alias burying](http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps) - We tried something similar and abandoned it.\n-* [External uniqueness is unique enough](http://www.computingscience.nl/research/techreps/repo/CS-2002/2002-048.pdf)\n+* [External uniqueness is unique enough](http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html)\n * [Uniqueness and Reference Immutability for Safe Parallelism](https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf)\n * [Region Based Memory Management](http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf)\n \n@@ -26,10 +26,10 @@ Recommended for inspiration and a better understanding of Rust's background.\n * [Dynamic circular work stealing deque](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&rep=rep1&type=pdf) - The Chase/Lev deque\n * [Work-first and help-first scheduling policies for async-finish task parallelism](http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf) - More general than fully-strict work stealing\n * [A Java fork/join calamity](http://www.coopsoft.com/ar/CalamityArticle.html) - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation\n-* [Scheduling techniques for concurrent systems](http://www.ece.rutgers.edu/%7Eparashar/Classes/ece572-papers/05/ps-ousterhout.pdf)\n+* [Scheduling techniques for concurrent systems](http://www.stanford.edu/~ouster/cgi-bin/papers/coscheduling.pdf)\n * [Contention aware scheduling](http://www.blagodurov.net/files/a8-blagodurov.pdf)\n * [Balanced work stealing for time-sharing multicores](http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf)\n-* [Three layer cake](http://www.upcrc.illinois.edu/workshops/paraplop10/papers/paraplop10_submission_8.pdf)\n+* [Three layer cake for shared-memory programming](http://dl.acm.org/citation.cfm?id=1953616&dl=ACM&coll=DL&CFID=524387192&CFTOKEN=44362705)\n * [Non-blocking steal-half work queues](http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf)\n * [Reagents: expressing and composing fine-grained concurrency](http://www.mpi-sws.org/~turon/reagents.pdf)\n * [Algorithms for scalable synchronization of shared-memory multiprocessors](https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf)"}, {"sha": "6d37043354282cf6db4dd95b87e320bf5b086b0d", "filename": "src/doc/trpl/advanced-linking.md", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-linking.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -0,0 +1,151 @@\n+% Advanced Linking\n+\n+The common cases of linking with Rust have been covered earlier in this book,\n+but supporting the range of linking possibilities made available by other\n+languages is important for Rust to achieve seamless interaction with native\n+libraries.\n+\n+# Link args\n+\n+There is one other way to tell `rustc` how to customize linking, and that is via\n+the `link_args` attribute. This attribute is applied to `extern` blocks and\n+specifies raw flags which need to get passed to the linker when producing an\n+artifact. An example usage would be:\n+\n+``` no_run\n+#![feature(link_args)]\n+\n+#[link_args = \"-foo -bar -baz\"]\n+extern {}\n+# fn main() {}\n+```\n+\n+Note that this feature is currently hidden behind the `feature(link_args)` gate\n+because this is not a sanctioned way of performing linking. Right now `rustc`\n+shells out to the system linker (`gcc` on most systems, `link.exe` on MSVC),\n+so it makes sense to provide extra command line\n+arguments, but this will not always be the case. In the future `rustc` may use\n+LLVM directly to link native libraries, in which case `link_args` will have no\n+meaning. You can achieve the same effect as the `link-args` attribute with the\n+`-C link-args` argument to `rustc`.\n+\n+It is highly recommended to *not* use this attribute, and rather use the more\n+formal `#[link(...)]` attribute on `extern` blocks instead.\n+\n+# Static linking\n+\n+Static linking refers to the process of creating output that contain all\n+required libraries and so don't need libraries installed on every system where\n+you want to use your compiled project. Pure-Rust dependencies are statically\n+linked by default so you can use created binaries and libraries without\n+installing the Rust everywhere. By contrast, native libraries\n+(e.g. `libc` and `libm`) usually dynamically linked, but it is possible to\n+change this and statically link them as well.\n+\n+Linking is a very platform dependent topic \u2014 on some platforms, static linking\n+may not be possible at all! This section assumes some basic familiarity with\n+linking on your platform of choice.\n+\n+## Linux\n+\n+By default, all Rust programs on Linux will link to the system `libc` along with\n+a number of other libraries. Let's look at an example on a 64-bit Linux machine\n+with GCC and `glibc` (by far the most common `libc` on Linux):\n+\n+``` text\n+$ cat example.rs\n+fn main() {}\n+$ rustc example.rs\n+$ ldd example\n+        linux-vdso.so.1 =>  (0x00007ffd565fd000)\n+        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)\n+        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)\n+        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)\n+        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)\n+        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)\n+        /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)\n+        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)\n+```\n+\n+Dynamic linking on Linux can be undesirable if you wish to use new library\n+features on old systems or target systems which do not have the required\n+dependencies for your program to run.\n+\n+Static linking is supported via an alternative `libc`, `musl` - this must be\n+enabled at Rust compile-time with some prerequisites available. You can compile\n+your own version of Rust with `musl` enabled and install it into a custom\n+directory with the instructions below:\n+\n+```text\n+$ mkdir musldist\n+$ PREFIX=$(pwd)/musldist\n+$\n+$ # Build musl\n+$ wget http://www.musl-libc.org/releases/musl-1.1.10.tar.gz\n+[...]\n+$ tar xf musl-1.1.10.tar.gz\n+$ cd musl-1.1.10/\n+musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX\n+[...]\n+musl-1.1.10 $ make\n+[...]\n+musl-1.1.10 $ make install\n+[...]\n+musl-1.1.10 $ cd ..\n+$ du -h musldist/lib/libc.a\n+2.2M    musldist/lib/libc.a\n+$\n+$ # Build libunwind.a\n+$ wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz\n+$ tar xf llvm-3.6.1.src.tar.xz\n+$ cd llvm-3.6.1.src/projects/\n+llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk/ libcxxabi\n+llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libunwind/trunk/ libunwind\n+llvm-3.6.1.src/projects $ sed -i 's#^\\(include_directories\\).*$#\\0\\n\\1(../libcxxabi/include)#' libunwind/CMakeLists.txt\n+llvm-3.6.1.src/projects $ mkdir libunwind/build\n+llvm-3.6.1.src/projects $ cd libunwind/build\n+llvm-3.6.1.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABLE_SHARED=0 ..\n+llvm-3.6.1.src/projects/libunwind/build $ make\n+llvm-3.6.1.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/\n+llvm-3.6.1.src/projects/libunwind/build $ cd cd ../../../../\n+$ du -h musldist/lib/libunwind.a\n+164K    musldist/lib/libunwind.a\n+$\n+$ # Build musl-enabled rust\n+$ git clone https://github.com/rust-lang/rust.git muslrust\n+$ cd muslrust\n+muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix=$PREFIX\n+muslrust $ make\n+muslrust $ make install\n+muslrust $ cd ..\n+$ du -h musldist/bin/rustc\n+12K     musldist/bin/rustc\n+```\n+\n+You now have a build of a `musl`-enabled Rust! Because we've installed it to a\n+custom prefix we need to make sure our system can the binaries and appropriate\n+libraries when we try and run it:\n+\n+```text\n+$ export PATH=$PREFIX/bin:$PATH\n+$ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH\n+```\n+\n+Let's try it out!\n+\n+```text\n+$ echo 'fn main() { println!(\"hi!\"); panic!(\"failed\"); }' > example.rs\n+$ rustc --target=x86_64-unknown-linux-musl example.rs\n+$ ldd example\n+        not a dynamic executable\n+$ ./example\n+hi!\n+thread '<main>' panicked at 'failed', example.rs:1\n+```\n+\n+Success! This binary can be copied to almost any Linux machine with the same\n+machine architecture and run without issues.\n+\n+`cargo build` also permits the `--target` option so you should be able to build\n+your crates as normal. However, you may need to recompile your native libraries\n+against `musl` before they can be linked against."}, {"sha": "db28ce6f428618427dae36aeea4828a120c6475b", "filename": "src/doc/trpl/choosing-your-guarantees.md", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -0,0 +1,356 @@\n+% Choosing your Guarantees\n+\n+One important feature of Rust as language is that it lets us control the costs and guarantees\n+of a program.\n+\n+There are various &ldquo;wrapper type&rdquo; abstractions in the Rust standard library which embody\n+a multitude of tradeoffs between cost, ergonomics, and guarantees. Many let one choose between\n+run time and compile time enforcement. This section will explain a few selected abstractions in\n+detail.\n+\n+Before proceeding, it is highly recommended that one reads about [ownership][ownership] and\n+[borrowing][borrowing] in Rust.\n+\n+[ownership]: ownership.html\n+[borrowing]: references-and-borrowing.html\n+\n+# Basic pointer types\n+\n+## `Box<T>`\n+\n+[`Box<T>`][box] is pointer which is &ldquo;owned&rdquo;, or a &ldquo;box&rdquo;. While it can hand\n+out references to the contained data, it is the only owner of the data. In particular, when\n+something like the following occurs:\n+\n+```rust\n+let x = Box::new(1);\n+let y = x;\n+// x no longer accessible here\n+```\n+\n+Here, the box was _moved_ into `y`. As `x` no longer owns it, the compiler will no longer allow the\n+programmer to use `x` after this. A box can similarly be moved _out_ of a function by returning it.\n+\n+When a box (that hasn't been moved) goes out of scope, destructors are run. These destructors take\n+care of deallocating the inner data.\n+\n+This is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the\n+heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be\n+allowed to share references to this by the regular borrowing rules, checked at compile time.\n+\n+[box]: ../std/boxed/struct.Box.html\n+\n+## `&T` and `&mut T` \n+\n+These are immutable and mutable references respectively. They follow the &lquo;read-write lock&rquo;\n+pattern, such that one may either have only one mutable reference to some data, or any number of\n+immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at\n+runtime. In most cases these two pointer types suffice for sharing cheap references between sections\n+of code.\n+\n+These pointers cannot be copied in such a way that they outlive the lifetime associated with them.\n+\n+## `*const T` and `*mut T`\n+\n+These are C-like raw pointers with no lifetime or ownership attached to them. They just point to\n+some location in memory with no other restrictions. The only guarantee that these provide is that\n+they cannot be dereferenced except in code marked `unsafe`.\n+\n+These are useful when building safe, low cost abstractions like `Vec<T>`, but should be avoided in\n+safe code.\n+\n+## `Rc<T>`\n+\n+This is the first wrapper we will cover that has a runtime cost.\n+\n+[`Rc<T>`][rc] is a reference counted pointer. In other words, this lets us have multiple \"owning\"\n+pointers to the same data, and the data will be dropped (destructors will be run) when all pointers\n+are out of scope.\n+\n+Internally, it contains a shared &ldquo;reference count&rdquo; (also called &ldquo;refcount&rdquo;),\n+which is incremented each time the `Rc` is cloned, and decremented each time one of the `Rc`s goes\n+out of scope. The main responsibility of `Rc<T>` is to ensure that destructors are called for shared\n+data.\n+\n+The internal data here is immutable, and if a cycle of references is created, the data will be\n+leaked. If we want data that doesn't leak when there are cycles, we need a garbage collector.\n+\n+#### Guarantees\n+\n+The main guarantee provided here is that the data will not be destroyed until all references to it\n+are out of scope.\n+\n+This should be used when we wish to dynamically allocate and share some data (read-only) between\n+various portions of yur program, where it is not certain which portion will finish using the pointer\n+last. It's a viable alternative to `&T` when `&T` is either impossible to statically check for\n+correctness, or creates extremely unergonomic code where the programmer does not wish to spend the\n+development cost of working with.\n+\n+This pointer is _not_ thread safe, and Rust will not let it be sent or shared with other threads.\n+This lets one avoid the cost of atomics in situations where they are unnecessary.\n+\n+There is a sister smart pointer to this one, `Weak<T>`. This is a non-owning, but also non-borrowed,\n+smart pointer. It is also similar to `&T`, but it is not restricted in lifetime&mdash;a `Weak<T>`\n+can be held on to forever. However, it is possible that an attempt to access the inner data may fail\n+and return `None`, since this can outlive the owned `Rc`s. This is useful for cyclic\n+data structures and other things.\n+\n+#### Cost\n+\n+As far as memory goes, `Rc<T>` is a single allocation, though it will allocate two extra words (i.e.\n+two `usize` values) as compared to a regular `Box<T>` (for \"strong\" and \"weak\" refcounts).\n+\n+`Rc<T>` has the computational cost of incrementing/decrementing the refcount whenever it is cloned\n+or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply\n+increment the inner reference count and return a copy of the `Rc<T>`.\n+\n+[rc]: ../std/rc/struct.Rc.html\n+\n+# Cell types\n+\n+&lquo;Cell&rquo;s provide interior mutability. In other words, they contain data which can be manipulated even\n+if the type cannot be obtained in a mutable form (for example, when it is behind an `&`-ptr or\n+`Rc<T>`).\n+\n+[The documentation for the `cell` module has a pretty good explanation for these][cell-mod].\n+\n+These types are _generally_ found in struct fields, but they may be found elsewhere too.\n+\n+## `Cell<T>`\n+\n+[`Cell<T>`][cell] is a type that provides zero-cost interior mutability, but only for `Copy` types.\n+Since the compiler knows that all the data owned by the contained value is on the stack, there's\n+no worry of leaking any data behind references (or worse!) by simply replacing the data.\n+\n+It is still possible to violate your own invariants using this wrapper, so be careful when using it.\n+If a field is wrapped in `Cell`, it's a nice indicator that the chunk of data is mutable and may not\n+stay the same between the time you first read it and when you intend to use it.\n+\n+```rust\n+# use std::cell::Cell;\n+let x = Cell::new(1);\n+let y = &x;\n+let z = &x;\n+x.set(2);\n+y.set(3);\n+z.set(4);\n+println!(\"{}\", x.get());\n+```\n+\n+Note that here we were able to mutate the same value from various immutable references.\n+\n+This has the same runtime cost as the following:\n+\n+```rust,ignore\n+let mut x = 1;\n+let y = &mut x;\n+let z = &mut x;\n+x = 2;\n+*y = 3;\n+*z = 4;\n+println!(\"{}\", x);\n+```\n+\n+but it has the added benefit of actually compiling successfully.\n+\n+#### Guarantees\n+\n+This relaxes the &ldquo;no aliasing with mutability&rdquo; restriction in places where it's\n+unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your\n+invariants depend on data stored within `Cell`, you should be careful.\n+\n+This is useful for mutating primitives and other `Copy` types when there is no easy way of\n+doing it in line with the static rules of `&` and `&mut`.\n+\n+`Cell` does not let you obtain interior references to the data, which makes it safe to freely\n+mutate.\n+\n+#### Cost\n+\n+There is no runtime cost to using `Cell<T>`, however if you are using it to wrap larger (`Copy`)\n+structs, it might be worthwhile to instead wrap individual fields in `Cell<T>` since each write is\n+otherwise a full copy of the struct.\n+\n+\n+## `RefCell<T>`\n+\n+[`RefCell<T>`][refcell] also provides interior mutability, but isn't restricted to `Copy` types.\n+\n+Instead, it has a runtime cost. `RefCell<T>` enforces the read-write lock pattern at runtime (it's\n+like a single-threaded mutex), unlike `&T`/`&mut T` which do so at compile time. This is done by the\n+`borrow()` and `borrow_mut()` functions, which modify an internal reference count and return smart\n+pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when\n+the smart pointers go out of scope. With this system, we can dynamically ensure that there are never\n+any other borrows active when a mutable borrow is active. If the programmer attempts to make such a\n+borrow, the thread will panic.\n+\n+```rust\n+# use std::cell::RefCell;\n+let x = RefCell::new(vec![1,2,3,4]);\n+{\n+    println!(\"{:?}\", *x.borrow())\n+}\n+\n+{\n+    let mut my_ref = x.borrow_mut();\n+    my_ref.push(1);\n+}\n+```\n+\n+Similar to `Cell`, this is mainly useful for situations where it's hard or impossible to satisfy the\n+borrow checker. Generally we know that such mutations won't happen in a nested form, but it's good\n+to check.\n+\n+For large, complicated programs, it becomes useful to put some things in `RefCell`s to make things\n+simpler. For example, a lot of the maps in [the `ctxt` struct][ctxt] in the rust compiler internals\n+are inside this wrapper. These are only modified once (during creation, which is not right after\n+initialization) or a couple of times in well-separated places. However, since this struct is\n+pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps\n+impossible) and probably form a soup of `&`-ptrs which would be hard to extend. On the other hand,\n+the `RefCell` provides a cheap (not zero-cost) way of safely accessing these. In the future, if\n+someone adds some code that attempts to modify the cell when it's already borrowed, it will cause a\n+(usually deterministic) panic which can be traced back to the offending borrow.\n+\n+Similarly, in Servo's DOM there is a lot of mutation, most of which is local to a DOM type, but some\n+of which crisscrosses the DOM and modifies various things. Using `RefCell` and `Cell` to guard all\n+mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the\n+places where mutation is _actually_ happening.\n+\n+Note that `RefCell` should be avoided if a mostly simple solution is possible with `&` pointers.\n+\n+#### Guarantees\n+\n+`RefCell` relaxes the _static_ restrictions preventing aliased mutation, and replaces them with\n+_dynamic_ ones. As such the guarantees have not changed.\n+\n+#### Cost\n+\n+`RefCell` does not allocate, but it contains an additional \"borrow state\"\n+indicator (one word in size) along with the data.\n+\n+At runtime each borrow causes a modification/check of the refcount.\n+\n+[cell-mod]: ../std/cell/\n+[cell]: ../std/cell/struct.Cell.html\n+[refcell]: ../std/cell/struct.RefCell.html\n+[ctxt]: ../rustc/middle/ty/struct.ctxt.html\n+\n+# Synchronous types\n+\n+Many of the types above cannot be used in a threadsafe manner. Particularly, `Rc<T>` and\n+`RefCell<T>`, which both use non-atomic reference counts (_atomic_ reference counts are those which\n+can be incremented from multiple threads without causing a data race), cannot be used this way. This\n+makes them cheaper to use, but we need thread safe versions of these too. They exist, in the form of\n+`Arc<T>` and `Mutex<T>`/`RWLock<T>`\n+\n+Note that the non-threadsafe types _cannot_ be sent between threads, and this is checked at compile\n+time.\n+\n+There are many useful wrappers for concurrent programming in the [sync][sync] module, but only the\n+major ones will be covered below.\n+\n+[sync]: ../std/sync/index.html\n+\n+## `Arc<T>`\n+\n+[`Arc<T>`][arc] is just a version of `Rc<T>` that uses an atomic reference count (hence, \"Arc\").\n+This can be sent freely between threads.\n+\n+C++'s `shared_ptr` is similar to `Arc`, however in the case of C++ the inner data is always mutable.\n+For semantics similar to that from C++, we should use `Arc<Mutex<T>>`, `Arc<RwLock<T>>`, or\n+`Arc<UnsafeCell<T>>`[^4] (`UnsafeCell<T>` is a cell type that can be used to hold any data and has\n+no runtime cost, but accessing it requires `unsafe` blocks). The last one should only be used if we\n+are certain that the usage won't cause any memory unsafety. Remember that writing to a struct is not\n+an atomic operation, and many functions like `vec.push()` can reallocate internally and cause unsafe\n+behavior, so even monotonicity may not be enough to justify `UnsafeCell`.\n+\n+[^4]: `Arc<UnsafeCell<T>>` actually won't compile since `UnsafeCell<T>` isn't `Send` or `Sync`, but we can wrap it in a type and implement `Send`/`Sync` for it manually to get `Arc<Wrapper<T>>` where `Wrapper` is `struct Wrapper<T>(UnsafeCell<T>)`.\n+\n+#### Guarantees\n+\n+Like `Rc`, this provides the (thread safe) guarantee that the destructor for the internal data will\n+be run when the last `Arc` goes out of scope (barring any cycles).\n+\n+#### Cost\n+\n+This has the added cost of using atomics for changing the refcount (which will happen whenever it is\n+cloned or goes out of scope). When sharing data from an `Arc` in a single thread, it is preferable\n+to share `&` pointers whenever possible.\n+\n+[arc]: ../std/sync/struct.Arc.html\n+\n+## `Mutex<T>` and `RwLock<T>`\n+\n+[`Mutex<T>`][mutex] and [`RwLock<T>`][rwlock] provide mutual-exclusion via RAII guards (guards are\n+objects which maintain some state, like a lock, until their destructor is called). For both of\n+these, the mutex is opaque until we call `lock()` on it, at which point the thread will block\n+until a lock can be acquired, and then a guard will be returned. This guard can be used to access\n+the inner data (mutably), and the lock will be released when the guard goes out of scope.\n+\n+```rust,ignore\n+{\n+    let guard = mutex.lock();\n+    // guard dereferences mutably to the inner type\n+    *guard += 1;\n+} // lock released when destructor runs\n+```\n+\n+\n+`RwLock` has the added benefit of being efficient for multiple reads. It is always safe to have\n+multiple readers to shared data as long as there are no writers; and `RwLock` lets readers acquire a\n+\"read lock\". Such locks can be acquired concurrently and are kept track of via a reference count.\n+Writers must obtain a \"write lock\" which can only be obtained when all readers have gone out of\n+scope.\n+\n+#### Guarantees\n+\n+Both of these provide safe shared mutability across threads, however they are prone to deadlocks.\n+Some level of additional protocol safety can be obtained via the type system.\n+#### Costs\n+\n+These use internal atomic-like types to maintain the locks, which are pretty costly (they can block\n+all memory reads across processors till they're done). Waiting on these locks can also be slow when\n+there's a lot of concurrent access happening.\n+\n+[rwlock]: ../std/sync/struct.RwLock.html\n+[mutex]: ../std/sync/struct.Mutex.html\n+[sessions]: https://github.com/Munksgaard/rust-sessions\n+\n+# Composition\n+\n+A common gripe when reading Rust code is with types like `Rc<RefCell<Vec<T>>>` (or even more more\n+complicated compositions of such types). It's not always clear what the composition does, or why the\n+author chose one like this (and when one should be using such a composition in one's own code)\n+\n+Usually, it's a case of composing together the guarantees that you need, without paying for stuff\n+that is unnecessary.\n+\n+For example, `Rc<RefCell<T>>` is one such composition. `Rc<T>` itself can't be dereferenced mutably;\n+because `Rc<T>` provides sharing and shared mutability can lead to unsafe behavior, so we put\n+`RefCell<T>` inside to get dynamically verified shared mutability. Now we have shared mutable data,\n+but it's shared in a way that there can only be one mutator (and no readers) or multiple readers.\n+\n+Now, we can take this a step further, and have `Rc<RefCell<Vec<T>>>` or `Rc<Vec<RefCell<T>>>`. These\n+are both shareable, mutable vectors, but they're not the same.\n+\n+With the former, the `RefCell<T>` is wrapping the `Vec<T>`, so the `Vec<T>` in its entirety is\n+mutable. At the same time, there can only be one mutable borrow of the whole `Vec` at a given time.\n+This means that your code cannot simultaneously work on different elements of the vector from\n+different `Rc` handles. However, we are able to push and pop from the `Vec<T>` at will. This is\n+similar to an `&mut Vec<T>` with the borrow checking done at runtime.\n+\n+With the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus,\n+we can independently borrow separate elements, but we cannot push or pop from the vector. This is\n+similar to an `&mut [T]`[^3], but, again, the borrow checking is at runtime.\n+\n+In concurrent programs, we have a similar situation with `Arc<Mutex<T>>`, which provides shared\n+mutability and ownership.\n+\n+When reading code that uses these, go in step by step and look at the guarantees/costs provided.\n+\n+When choosing a composed type, we must do the reverse; figure out which guarantees we want, and at\n+which point of the composition we need them. For example, if there is a choice between\n+`Vec<RefCell<T>>` and `RefCell<Vec<T>>`, we should figure out the tradeoffs as done above and pick\n+one.\n+\n+[^3]: `&[T]` and `&mut [T]` are _slices_; they consist of a pointer and a length and can refer to a portion of a vector or array. `&mut [T]` can have its elements mutated, however its length cannot be touched."}, {"sha": "e7eb48dc42c529c8e37f58a6972c7de7b46b08fe", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -38,6 +38,17 @@ fn add_one(x: i32) -> i32 {\n }\n ```\n \n+There is another style of doc comment, `//!`, to comment containing items (e.g.\n+crates, modules or functions), instead of the items following it. Commonly used\n+inside crates root (lib.rs) or modules root (mod.rs):\n+\n+```\n+//! # The Rust Standard Library\n+//!\n+//! The Rust Standard Library provides the essential runtime\n+//! functionality for building portable Rust software.\n+```\n+\n When writing doc comments, providing some examples of usage is very, very\n helpful. You\u2019ll notice we\u2019ve used a new macro here: `assert_eq!`. This compares\n two values, and `panic!`s if they\u2019re not equal to each other. It\u2019s very helpful"}, {"sha": "15c19ece48a147755090e355f62f8fd50ed47838", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,11 +10,12 @@ system is up to the task, and gives you powerful ways to reason about\n concurrent code at compile time.\n \n Before we talk about the concurrency features that come with Rust, it's important\n-to understand something: Rust is low-level enough that all of this is provided\n-by the standard library, not by the language. This means that if you don't like\n-some aspect of the way Rust handles concurrency, you can implement an alternative\n-way of doing things. [mio](https://github.com/carllerche/mio) is a real-world\n-example of this principle in action.\n+to understand something: Rust is low-level enough that the vast majority of\n+this is provided by the standard library, not by the language. This means that\n+if you don't like some aspect of the way Rust handles concurrency, you can\n+implement an alternative way of doing things.\n+[mio](https://github.com/carllerche/mio) is a real-world example of this\n+principle in action.\n \n ## Background: `Send` and `Sync`\n "}, {"sha": "9539cd3447cb9f023bec1813c475871ea9da438b", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -151,15 +151,15 @@ look at `main()` again:\n # struct Philosopher {\n #     name: String,\n # }\n-# \n+#\n # impl Philosopher {\n #     fn new(name: &str) -> Philosopher {\n #         Philosopher {\n #             name: name.to_string(),\n #         }\n #     }\n # }\n-# \n+#\n fn main() {\n     let p1 = Philosopher::new(\"Judith Butler\");\n     let p2 = Philosopher::new(\"Gilles Deleuze\");\n@@ -197,15 +197,15 @@ a method, and then loop through all the philosophers, calling it:\n ```rust\n struct Philosopher {\n     name: String,\n-}   \n+}\n \n-impl Philosopher { \n+impl Philosopher {\n     fn new(name: &str) -> Philosopher {\n         Philosopher {\n             name: name.to_string(),\n         }\n     }\n-    \n+\n     fn eat(&self) {\n         println!(\"{} is done eating.\", self.name);\n     }\n@@ -267,15 +267,15 @@ use std::thread;\n \n struct Philosopher {\n     name: String,\n-}   \n+}\n \n-impl Philosopher { \n+impl Philosopher {\n     fn new(name: &str) -> Philosopher {\n         Philosopher {\n             name: name.to_string(),\n         }\n     }\n-    \n+\n     fn eat(&self) {\n         println!(\"{} is eating.\", self.name);\n \n@@ -348,9 +348,9 @@ use std::thread;\n \n struct Philosopher {\n     name: String,\n-}   \n+}\n \n-impl Philosopher { \n+impl Philosopher {\n     fn new(name: &str) -> Philosopher {\n         Philosopher {\n             name: name.to_string(),\n@@ -401,7 +401,7 @@ let handles: Vec<_> = philosophers.into_iter().map(|p| {\n While this is only five lines, they\u2019re a dense five. Let\u2019s break it down.\n \n ```rust,ignore\n-let handles: Vec<_> = \n+let handles: Vec<_> =\n ```\n \n We introduce a new binding, called `handles`. We\u2019ve given it this name because\n@@ -460,15 +460,15 @@ If you run this program, you\u2019ll see that the philosophers eat out of order!\n We have multi-threading!\n \n ```text\n+Judith Butler is eating.\n Gilles Deleuze is eating.\n-Gilles Deleuze is done eating.\n+Karl Marx is eating.\n Emma Goldman is eating.\n-Emma Goldman is done eating.\n Michel Foucault is eating.\n-Judith Butler is eating.\n Judith Butler is done eating.\n-Karl Marx is eating.\n+Gilles Deleuze is done eating.\n Karl Marx is done eating.\n+Emma Goldman is done eating.\n Michel Foucault is done eating.\n ```\n "}, {"sha": "01b53a6c49d8be37bca372caaddd3f5e366b1024", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -33,8 +33,10 @@ pub fn new(value: T) -> Rc<T> {\n ```\n \n This code generates documentation that looks [like this][rc-new]. I've left the\n-implementation out, with a regular comment in its place. That's the first thing\n-to notice about this annotation: it uses `///`, instead of `//`. The triple slash\n+implementation out, with a regular comment in its place.\n+\n+The first thing to notice about this annotation is that it uses\n+`///` instead of `//`. The triple slash\n indicates a documentation comment.\n \n Documentation comments are written in Markdown.\n@@ -375,7 +377,7 @@ $ rustdoc --test path/to/my/crate/root.rs\n $ cargo test\n ```\n \n-That's right, `cargo test` tests embedded documentation too. However, \n+That's right, `cargo test` tests embedded documentation too. However,\n `cargo test` will not test binary crates, only library ones. This is\n due to the way `rustdoc` works: it links against the library to be tested,\n but with a binary, there\u2019s nothing to link to."}, {"sha": "8dd5a3650ef5260eb2d55201e4db9e6dc1a7f0a8", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -50,6 +50,8 @@ is very wrong. Wrong enough that we can't continue with things in the current\n state. Another example is using the `unreachable!()` macro:\n \n ```rust,ignore\n+use Event::NewRelease;\n+\n enum Event {\n     NewRelease,\n }\n@@ -71,7 +73,7 @@ fn descriptive_probability(event: Event) -> &'static str {\n }\n \n fn main() {\n-    std::io::println(descriptive_probability(NewRelease));\n+    println!(\"{}\", descriptive_probability(NewRelease));\n }\n ```\n "}, {"sha": "753a5a32e8a1bfff0249e479e05ffd7292f0b998", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -309,8 +309,8 @@ and invokes callbacks from there.\n In these cases access to Rust data structures inside the callbacks is\n especially unsafe and proper synchronization mechanisms must be used.\n Besides classical synchronization mechanisms like mutexes, one possibility in\n-Rust is to use channels (in `std::comm`) to forward data from the C thread\n-that invoked the callback into a Rust thread.\n+Rust is to use channels (in `std::sync::mpsc`) to forward data from the C\n+thread that invoked the callback into a Rust thread.\n \n If an asynchronous callback targets a special object in the Rust address space\n it is also absolutely necessary that no more callbacks are performed by the\n@@ -340,7 +340,7 @@ libraries:\n Note that frameworks are only available on OSX targets.\n \n The different `kind` values are meant to differentiate how the native library\n-participates in linkage. From a linkage perspective, the rust compiler creates\n+participates in linkage. From a linkage perspective, the Rust compiler creates\n two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).\n Native dynamic library and framework dependencies are propagated to the final\n artifact boundary, while static library dependencies are not propagated at\n@@ -350,9 +350,9 @@ artifact.\n A few examples of how this model can be used are:\n \n * A native build dependency. Sometimes some C/C++ glue is needed when writing\n-  some rust code, but distribution of the C/C++ code in a library format is just\n+  some Rust code, but distribution of the C/C++ code in a library format is just\n   a burden. In this case, the code will be archived into `libfoo.a` and then the\n-  rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n+  Rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n   \"static\")]`.\n \n   Regardless of the flavor of output for the crate, the native static library\n@@ -361,7 +361,7 @@ A few examples of how this model can be used are:\n \n * A normal dynamic dependency. Common system libraries (like `readline`) are\n   available on a large number of systems, and often a static copy of these\n-  libraries cannot be found. When this dependency is included in a rust crate,\n+  libraries cannot be found. When this dependency is included in a Rust crate,\n   partial targets (like rlibs) will not link to the library, but when the rlib\n   is included in a final target (like a binary), the native library will be\n   linked in.\n@@ -533,19 +533,10 @@ attribute turns off Rust's name mangling, so that it is easier to link to.\n \n # FFI and panics\n \n-It\u2019s important to be mindful of `panic!`s when working with FFI. This code,\n-when called from C, will `abort`:\n-\n-```rust\n-#[no_mangle]\n-pub extern fn oh_no() -> ! {\n-    panic!(\"Oops!\");\n-}\n-# fn main() {}\n-```\n-\n-If you\u2019re writing code that may panic, you should run it in another thread,\n-so that the panic doesn\u2019t bubble up to C:\n+It\u2019s important to be mindful of `panic!`s when working with FFI. A `panic!`\n+across an FFI boundary is undefined behavior. If you\u2019re writing code that may\n+panic, you should run it in another thread, so that the panic doesn\u2019t bubble up\n+to C:\n \n ```rust\n use std::thread;"}, {"sha": "1784c253f7f47ae90223ff539f4bf257c4594c96", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -360,10 +360,12 @@ rand=\"0.3.0\"\n The `[dependencies]` section of `Cargo.toml` is like the `[package]` section:\n everything that follows it is part of it, until the next section starts.\n Cargo uses the dependencies section to know what dependencies on external\n-crates you have, and what versions you require. In this case, we\u2019ve used version `0.3.0`.\n+crates you have, and what versions you require. In this case, we\u2019ve specified version `0.3.0`,\n+which Cargo understands to be any release that\u2019s compatible with this specific version.\n Cargo understands [Semantic Versioning][semver], which is a standard for writing version\n-numbers. If we wanted to use the latest version we could use `*` or we could use a range\n-of versions. [Cargo\u2019s documentation][cargodoc] contains more details.\n+numbers. If we wanted to use only `0.3.0` exactly, we could use `=0.3.0`. If we\n+wanted to use the latest version we could use `*`; We could use a range of\n+versions. [Cargo\u2019s documentation][cargodoc] contains more details.\n \n [semver]: http://semver.org\n [cargodoc]: http://doc.crates.io/crates-io.html"}, {"sha": "7659c4ff88dae983d3a4985fe223c1da41d2c92c", "filename": "src/doc/trpl/inline-assembly.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -103,7 +103,7 @@ fn main() {\n If you would like to use real operands in this position, however,\n you are required to put curly braces `{}` around the register that\n you want, and you are required to put the specific size of the\n-operand. This is useful for very low level programming, where \n+operand. This is useful for very low level programming, where\n which register you use is important:\n \n ```rust\n@@ -166,3 +166,12 @@ unsafe {\n println!(\"eax is currently {}\", result);\n # }\n ```\n+\n+## More Information\n+\n+The current implementation of the `asm!` macro is a direct binding to [LLVM's\n+inline assembler expressions][llvm-docs], so be sure to check out [their\n+documentation as well][llvm-docs] for more information about clobbers,\n+constraints, etc.\n+\n+[llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions"}, {"sha": "83750ec3b01adff931f9dfc68d22bd13e526b55d", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -2,7 +2,7 @@\n \n The first step to using Rust is to install it! There are a number of ways to\n install Rust, but the easiest is to use the `rustup` script. If you're on Linux\n-or a Mac, all you need to do is this: \n+or a Mac, all you need to do is this:\n \n > Note: you don't need to type in the `$`s, they just indicate the start of\n > each command. You\u2019ll see many tutorials and examples around the web that\n@@ -25,6 +25,12 @@ $ sh rustup.sh\n [insecurity]: http://curlpipesh.tumblr.com\n \n If you're on Windows, please download the appropriate [installer][install-page].\n+**NOTE:** By default, the Windows installer will not add Rust to the %PATH%\n+system variable. If this is the only version of Rust you are installing and you\n+want to be able to run it from the command line, click on \"Advanced\" on the\n+install dialog and on the \"Product Features\" page ensure \"Add to PATH\" is\n+installed on the local hard drive.\n+\n \n [install-page]: http://www.rust-lang.org/install.html\n \n@@ -87,6 +93,11 @@ rustc 1.0.0 (a59de37e9 2015-05-13)\n \n If you did, Rust has been installed successfully! Congrats!\n \n+If you didn't and you're on Windows, check that Rust is in your %PATH% system\n+variable. If it isn't, run the installer again, select \"Change\" on the \"Change,\n+repair, or remove installation\" page and ensure \"Add to PATH\" is installed on\n+the local hard drive.\n+\n This installer also installs a copy of the documentation locally, so you can\n read it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location.\n On Windows, it's in a `share/doc` directory, inside wherever you installed Rust\n@@ -101,5 +112,5 @@ resources include [the user\u2019s forum][users], and\n \n [irc]: irc://irc.mozilla.org/#rust\n [mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n-[users]: http://users.rust-lang.org/ \n+[users]: http://users.rust-lang.org/\n [stackoverflow]: http://stackoverflow.com/questions/tagged/rust"}, {"sha": "8e02367b921bc185eba4ff5fb12ca54fed57910c", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -101,6 +101,8 @@ the lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut\n i32` as \u2018a mutable reference to an i32\u2019 and `&'a mut i32` as \u2018a mutable\n reference to an `i32` with the lifetime `'a`\u2019.\n \n+# In `struct`s\n+\n You\u2019ll also need explicit lifetimes when working with [`struct`][structs]s:\n \n ```rust\n@@ -137,6 +139,33 @@ x: &'a i32,\n uses it. So why do we need a lifetime here? We need to ensure that any reference\n to a `Foo` cannot outlive the reference to an `i32` it contains.\n \n+## `impl` blocks\n+\n+Let\u2019s implement a method on `Foo`:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn x(&self) -> &'a i32 { self.x }\n+}\n+\n+fn main() {\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let f = Foo { x: y };\n+\n+    println!(\"x is: {}\", f.x());\n+}\n+```\n+\n+As you can see, we need to declare a lifetime for `Foo` in the `impl` line. We repeat\n+`'a` twice, just like on functions: `impl<'a>` defines a lifetime `'a`, and `Foo<'a>`\n+uses it.\n+\n+## Multiple lifetimes\n+\n If you have multiple references, you can use the same lifetime multiple times:\n \n ```rust"}, {"sha": "ee5159afb8e6f41502e00d4857ae9178a84a5ecf", "filename": "src/doc/trpl/link-args.md", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Fdoc%2Ftrpl%2Flink-args.md", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Fdoc%2Ftrpl%2Flink-args.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flink-args.md?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c", "patch": "@@ -1,25 +0,0 @@\n-% Link args\n-\n-There is one other way to tell rustc how to customize linking, and that is via\n-the `link_args` attribute. This attribute is applied to `extern` blocks and\n-specifies raw flags which need to get passed to the linker when producing an\n-artifact. An example usage would be:\n-\n-``` no_run\n-#![feature(link_args)]\n-\n-#[link_args = \"-foo -bar -baz\"]\n-extern {}\n-# fn main() {}\n-```\n-\n-Note that this feature is currently hidden behind the `feature(link_args)` gate\n-because this is not a sanctioned way of performing linking. Right now rustc\n-shells out to the system linker, so it makes sense to provide extra command line\n-arguments, but this will not always be the case. In the future rustc may use\n-LLVM directly to link native libraries in which case `link_args` will have no\n-meaning.\n-\n-It is highly recommended to *not* use this attribute, and rather use the more\n-formal `#[link(...)]` attribute on `extern` blocks instead.\n-"}, {"sha": "5ddbdd6df00b048c7dfc2284feeece0984bbbb1c", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -42,8 +42,8 @@ With that in mind, let\u2019s learn about ownership.\n # Ownership\n \n [Variable bindings][bindings] have a property in Rust: they \u2018have ownership\u2019\n-of what they\u2019re bound to. This means that when a binding goes out of scope, the\n-resource that they\u2019re bound to are freed. For example:\n+of what they\u2019re bound to. This means that when a binding goes out of scope, \n+Rust will free the bound resources. For example:\n \n ```rust\n fn foo() {"}, {"sha": "9603eec7aca712a8808ef6edde3d3647bbb251a3", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -282,6 +282,38 @@ This \u2018destructuring\u2019 behavior works on any compound data type, like\n [tuples]: primitive-types.html#tuples\n [enums]: enums.html\n \n+# Ignoring bindings\n+\n+You can use `_` in a pattern to disregard the value. For example, here\u2019s a\n+`match` against a `Result<T, E>`:\n+\n+```rust\n+# let some_value: Result<i32, &'static str> = Err(\"There was an error\");\n+match some_value {\n+    Ok(value) => println!(\"got a value: {}\", value),\n+    Err(_) => println!(\"an error occurred\"),\n+}\n+```\n+\n+In the first arm, we bind the value inside the `Ok` variant to `value`. But\n+in the `Err` arm, we use `_` to disregard the specific error, and just print\n+a general error message.\n+\n+`_` is valid in any pattern that creates a binding. This can be useful to\n+ignore parts of a larger structure:\n+\n+```rust\n+fn coordinate() -> (i32, i32, i32) {\n+    // generate and return some sort of triple tuple\n+# (1, 2, 3)\n+}\n+\n+let (x, _, z) = coordinate();\n+```\n+\n+Here, we bind the first and last element of the tuple to `x` and `z`, but\n+ignore the middle element.\n+\n # Mix and Match\n \n Whew! That\u2019s a lot of different ways to match things, and they can all be"}, {"sha": "d1d3063138e7e61228dd82652540ee86452dead2", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -336,7 +336,9 @@ In other words, `y` is only valid for the scope where `x` exists. As soon as\n the borrow \u2018doesn\u2019t live long enough\u2019 because it\u2019s not valid for the right\n amount of time.\n \n-The same problem occurs when the reference is declared _before_ the variable it refers to:\n+The same problem occurs when the reference is declared _before_ the variable it\n+refers to. This is because resources within the same scope are freed in the\n+opposite order they were declared:\n \n ```rust,ignore\n let y: &i32;\n@@ -369,3 +371,6 @@ statement 1 at 3:14\n     println!(\"{}\", y);\n }\n ```\n+\n+In the above example, `y` is declared before `x`, meaning that `y` lives longer\n+than `x`, which is not allowed."}, {"sha": "1e203c6553ee107f11cf205bab3da4062133225c", "filename": "src/doc/trpl/release-channels.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Frelease-channels.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Frelease-channels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frelease-channels.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -43,3 +43,26 @@ This will help alert the team in case there\u2019s an accidental regression.\n Additionally, testing against nightly can catch regressions even sooner, and so\n if you don\u2019t mind a third build, we\u2019d appreciate testing against all channels.\n \n+As an example, many Rust programmers use [Travis](https://travis-ci.org/) to\n+test their crates, which is free for open source projects. Travis [supports\n+Rust directly][travis], and you can use a `.travis.yml` file like this to\n+test on all channels:\n+\n+```yaml\n+language: rust\n+rust:\n+  - nightly\n+  - beta\n+  - stable\n+\n+matrix:\n+  allow_failures:\n+    - rust: nightly\n+```\n+\n+[travis]: http://docs.travis-ci.com/user/languages/rust/\n+\n+With this configuration, Travis will test all three channels, but if something\n+breaks on nightly, it won\u2019t fail your build. A similar configuration is\n+recommended for any CI system, check the documentation of the one you\u2019re\n+using for more details."}, {"sha": "a5a0127031ae55cb9bff34cdc309bfb118e6887c", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -250,11 +250,10 @@ that our tests are entirely left out of a normal build.\n \n The second change is the `use` declaration. Because we're in an inner module,\n we need to bring our test function into scope. This can be annoying if you have\n-a large module, and so this is a common use of the `glob` feature. Let's change\n-our `src/lib.rs` to make use of it:\n+a large module, and so this is a common use of globs. Let's change our\n+`src/lib.rs` to make use of it:\n \n ```rust,ignore\n-\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }"}, {"sha": "ff81590cc03b9b6a97ba837a946826c4509b40df", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -176,7 +176,7 @@ After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n | 1       | a    | 5     |\n | 0       | x    | 42    |\n \n-And then `foo()` ends, leaving just `main()`\n+And then `foo()` ends, leaving just `main()`:\n \n | Address | Name | Value |\n |---------|------|-------|\n@@ -537,7 +537,7 @@ Generally, you should prefer stack allocation, and so, Rust stack-allocates by\n default. The LIFO model of the stack is simpler, at a fundamental level. This\n has two big impacts: runtime efficiency and semantic impact.\n \n-## Runtime Efficiency.\n+## Runtime Efficiency\n \n Managing the memory for the stack is trivial: The machine just\n increments or decrements a single value, the so-called \u201cstack pointer\u201d."}, {"sha": "1b223365bd63ac72a15c072fc79da5a5ec3967d9", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,11 +8,11 @@ this, Rust has a keyword, `unsafe`. Code using `unsafe` has less restrictions\n than normal code does.\n \n Let\u2019s go over the syntax, and then we\u2019ll talk semantics. `unsafe` is used in\n-two contexts. The first one is to mark a function as unsafe:\n+four contexts. The first one is to mark a function as unsafe:\n \n ```rust\n unsafe fn danger_will_robinson() {\n-    // scary stuff \n+    // scary stuff\n }\n ```\n \n@@ -27,15 +27,40 @@ unsafe {\n }\n ```\n \n+The third is for unsafe traits:\n+\n+```rust\n+unsafe trait Scary { }\n+```\n+\n+And the fourth is for `impl`ementing one of those traits:\n+\n+```rust\n+# unsafe trait Scary { }\n+unsafe impl Scary for i32 {}\n+```\n+\n It\u2019s important to be able to explicitly delineate code that may have bugs that\n cause big problems. If a Rust program segfaults, you can be sure it\u2019s somewhere\n in the sections marked `unsafe`.\n \n # What does \u2018safe\u2019 mean?\n \n-Safe, in the context of Rust, means \u201cdoesn\u2019t do anything unsafe.\u201d Easy!\n+Safe, in the context of Rust, means \u2018doesn\u2019t do anything unsafe\u2019. It\u2019s also\n+important to know that there are certain behaviors that are probably not\n+desirable in your code, but are expressly _not_ unsafe:\n \n-Okay, let\u2019s try again: what is not safe to do? Here\u2019s a list:\n+* Deadlocks\n+* Leaks of memory or other resources\n+* Exiting without calling destructors\n+* Integer overflow\n+\n+Rust cannot prevent all kinds of software problems. Buggy code can and will be\n+written in Rust. These things aren\u2019t great, but they don\u2019t qualify as `unsafe`\n+specifically.\n+\n+In addition, the following are all undefined behaviors in Rust, and must be\n+avoided, even when writing `unsafe` code:\n \n * Data races\n * Dereferencing a null/dangling raw pointer\n@@ -64,21 +89,6 @@ Okay, let\u2019s try again: what is not safe to do? Here\u2019s a list:\n [undef]: http://llvm.org/docs/LangRef.html#undefined-values\n [aliasing]: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules\n \n-Whew! That\u2019s a bunch of stuff. It\u2019s also important to notice all kinds of\n-behaviors that are certainly bad, but are expressly _not_ unsafe:\n-\n-* Deadlocks\n-* Reading data from private fields\n-* Leaks due to reference count cycles\n-* Exiting without calling destructors\n-* Sending signals\n-* Accessing/modifying the file system\n-* Integer overflow\n-\n-Rust cannot prevent all kinds of software problems. Buggy code can and will be\n-written in Rust. These things aren\u2019t great, but they don\u2019t qualify as `unsafe`\n-specifically.\n-\n # Unsafe Superpowers\n \n In both unsafe functions and unsafe blocks, Rust will let you do three things\n@@ -90,10 +100,14 @@ that you normally can not do. Just three. Here they are:\n \n That\u2019s it. It\u2019s important that `unsafe` does not, for example, \u2018turn off the\n borrow checker\u2019. Adding `unsafe` to some random Rust code doesn\u2019t change its\n-semantics, it won\u2019t just start accepting anything.\n+semantics, it won\u2019t just start accepting anything. But it will let you write\n+things that _do_ break some of the rules.\n+\n+You will also encounter the `unsafe` keyword when writing bindings to foreign\n+(non-Rust) interfaces. You're encouraged to write a safe, native Rust interface\n+around the methods provided by the library.\n \n-But it will let you write things that _do_ break some of the rules. Let\u2019s go\n-over these three abilities in order.\n+Let\u2019s go over the basic three abilities listed, in order.\n \n ## Access or update a `static mut`\n "}, {"sha": "124ebc7d69ddcb5343a708ad50b26a413cf7783a", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -88,6 +88,24 @@ for x in 0..10 {\n }\n ```\n \n+You may also encounter situations where you have nested loops and need to \n+specify which one your `break` or `continue` statement is for. Like most \n+other languages, by default a `break` or `continue` will apply to innermost \n+loop. In a sitation where you would like to a `break` or `continue` for one \n+of the outer loops, you can use labels to specify which loop the `break` or\n+ `continue` statement applies to. This will only print when both `x` and `y` are\n+ odd:\n+\n+```rust\n+'outer: for x in 0..10 {\n+    'inner: for y in 0..10 {\n+        if x % 2 == 0 { continue 'outer; } // continues the loop over x\n+        if y % 2 == 0 { continue 'inner; } // continues the loop over y\n+        println!(\"x: {}, y: {}\", x, y);\n+    }\n+}\n+```\n+\n Both `continue` and `break` are valid in both `while` loops and [`for` loops][for].\n \n [for]: for-loops.html"}, {"sha": "06a83c75936fe4a44a6584b9cbf9e09b9a554d1c", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -55,12 +55,10 @@\n SLICE_FIELD_NAMES = [SLICE_FIELD_NAME_DATA_PTR, SLICE_FIELD_NAME_LENGTH]\n \n # std::Vec<> related constants\n-STD_VEC_FIELD_NAME_DATA_PTR = \"ptr\"\n STD_VEC_FIELD_NAME_LENGTH = \"len\"\n-STD_VEC_FIELD_NAME_CAPACITY = \"cap\"\n-STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_DATA_PTR,\n-                       STD_VEC_FIELD_NAME_LENGTH,\n-                       STD_VEC_FIELD_NAME_CAPACITY]\n+STD_VEC_FIELD_NAME_BUF = \"buf\"\n+STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_BUF,\n+                       STD_VEC_FIELD_NAME_LENGTH]\n \n # std::String related constants\n STD_STRING_FIELD_NAMES = [\"vec\"]\n@@ -302,13 +300,13 @@ def get_discriminant_value_as_integer(enum_val):\n def extract_length_ptr_and_cap_from_std_vec(vec_val):\n     assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VEC\n     length_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_LENGTH)\n-    ptr_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_DATA_PTR)\n-    cap_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_CAPACITY)\n+    buf_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_BUF)\n \n     length = vec_val.get_child_at_index(length_field_index).as_integer()\n-    vec_ptr_val = vec_val.get_child_at_index(ptr_field_index)\n-    capacity = vec_val.get_child_at_index(cap_field_index).as_integer()\n+    buf = vec_val.get_child_at_index(buf_field_index)\n \n+    vec_ptr_val = buf.get_child_at_index(0)\n+    capacity = buf.get_child_at_index(1).as_integer()\n     unique_ptr_val = vec_ptr_val.get_child_at_index(0)\n     data_ptr = unique_ptr_val.get_child_at_index(0)\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR"}, {"sha": "48736542f20c7fda99c1d0c316049ed892a5a86f", "filename": "src/etc/errorck.py", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -23,6 +23,18 @@\n errcode_map = {}\n error_re = re.compile(\"(E\\d\\d\\d\\d)\")\n \n+# In the register_long_diagnostics! macro, entries look like this:\n+#\n+# EXXXX: r##\"\n+# <Long diagnostic message>\n+# \"##,\n+#\n+# These two variables are for detecting the beginning and end of diagnostic\n+# messages so that duplicate error codes are not reported when a code occurs\n+# inside a diagnostic message\n+long_diag_begin = \"r##\\\"\"\n+long_diag_end = \"\\\"##\"\n+\n for (dirpath, dirnames, filenames) in os.walk(src_dir):\n     if \"src/test\" in dirpath or \"src/llvm\" in dirpath:\n         # Short circuit for fast\n@@ -35,7 +47,14 @@\n         path = os.path.join(dirpath, filename)\n \n         with open(path, 'r') as f:\n+            inside_long_diag = False\n             for line_num, line in enumerate(f, start=1):\n+                if inside_long_diag:\n+                    # Skip duplicate error code checking for this line\n+                    if long_diag_end in line:\n+                        inside_long_diag = False\n+                    continue\n+\n                 match = error_re.search(line)\n                 if match:\n                     errcode = match.group(1)\n@@ -47,6 +66,9 @@\n                     else:\n                         errcode_map[errcode] = new_record\n \n+                if long_diag_begin in line:\n+                    inside_long_diag = True\n+\n errors = False\n all_errors = []\n "}, {"sha": "1cc65406b2c005076292a8255f5b59db96a22cc3", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -14,10 +14,9 @@\n \n f = open(sys.argv[1], 'wb')\n \n-components = sys.argv[2].split(' ')\n-components = [i for i in components if i]  # ignore extra whitespaces\n+components = sys.argv[2].split() # splits on whitespace\n enable_static = sys.argv[3]\n-llconfig = sys.argv[4]\n+llvm_config = sys.argv[4]\n \n f.write(\"\"\"// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -39,15 +38,15 @@ def run(args):\n     out, err = proc.communicate()\n \n     if err:\n-        print(\"failed to run llconfig: args = `{}`\".format(args))\n+        print(\"failed to run llvm_config: args = `{}`\".format(args))\n         print(err)\n         sys.exit(1)\n     return out\n \n f.write(\"\\n\")\n \n # LLVM libs\n-args = [llconfig, '--libs', '--system-libs']\n+args = [llvm_config, '--libs', '--system-libs']\n \n args.extend(components)\n out = run(args)\n@@ -69,13 +68,13 @@ def run(args):\n     f.write(\")]\\n\")\n \n # LLVM ldflags\n-out = run([llconfig, '--ldflags'])\n+out = run([llvm_config, '--ldflags'])\n for lib in out.strip().split(' '):\n     if lib[:2] == \"-l\":\n         f.write(\"#[link(name = \\\"\" + lib[2:] + \"\\\")]\\n\")\n \n # C++ runtime library\n-out = run([llconfig, '--cxxflags'])\n+out = run([llvm_config, '--cxxflags'])\n if enable_static == '1':\n     assert('stdlib=libc++' not in out)\n     f.write(\"#[link(name = \\\"stdc++\\\", kind = \\\"static\\\")]\\n\")"}, {"sha": "6d62a45c703a23561379d40467cb8337aa6efe40", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -41,13 +41,14 @@ def scrub(b):\n download_unpack_base = os.path.join(download_dir_base, \"unpack\")\n \n snapshot_files = {\n+        \"bitrig\": [\"bin/rustc\"],\n+        \"dragonfly\": [\"bin/rustc\"],\n+        \"freebsd\": [\"bin/rustc\"],\n         \"linux\": [\"bin/rustc\"],\n         \"macos\": [\"bin/rustc\"],\n-        \"winnt\": [\"bin/rustc.exe\"],\n-        \"freebsd\": [\"bin/rustc\"],\n-        \"dragonfly\": [\"bin/rustc\"],\n-        \"bitrig\": [\"bin/rustc\"],\n+        \"netbsd\": [\"bin/rustc\"],\n         \"openbsd\": [\"bin/rustc\"],\n+        \"winnt\": [\"bin/rustc.exe\"],\n         }\n \n winnt_runtime_deps_32 = [\"libgcc_s_dw2-1.dll\", \"libstdc++-6.dll\"]\n@@ -103,6 +104,8 @@ def get_kernel(triple):\n         return \"dragonfly\"\n     if os_name == \"bitrig\":\n         return \"bitrig\"\n+    if os_name == \"netbsd\":\n+        return \"netbsd\"\n     if os_name == \"openbsd\":\n         return \"openbsd\"\n     return \"linux\""}, {"sha": "a740e837fdd4e52b72735100b7cd3674156b7d16", "filename": "src/etc/unicode.py", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -372,13 +372,6 @@ def emit_conversions_module(f, to_upper, to_lower, to_title):\n         }\n     }\n \n-    pub fn to_title(c: char) -> [char; 3] {\n-        match bsearch_case_table(c, to_titlecase_table) {\n-            None        => [c, '\\\\0', '\\\\0'],\n-            Some(index) => to_titlecase_table[index].1\n-        }\n-    }\n-\n     fn bsearch_case_table(c: char, table: &'static [(char, [char; 3])]) -> Option<usize> {\n         match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n@@ -400,9 +393,6 @@ def emit_conversions_module(f, to_upper, to_lower, to_title):\n     emit_table(f, \"to_uppercase_table\",\n         sorted(to_upper.iteritems(), key=operator.itemgetter(0)),\n         is_pub=False, t_type = t_type, pfun=pfun)\n-    emit_table(f, \"to_titlecase_table\",\n-        sorted(to_title.iteritems(), key=operator.itemgetter(0)),\n-        is_pub=False, t_type = t_type, pfun=pfun)\n     f.write(\"}\\n\\n\")\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):"}, {"sha": "2a47fd29bd6532c9215b037dbebda8242abdc255", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 182, "deletions": 82, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -77,13 +77,15 @@ use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::fmt;\n use core::cmp::Ordering;\n-use core::mem::{min_align_of_val, size_of_val};\n+use core::mem::{align_of_val, size_of_val};\n use core::intrinsics::drop_in_place;\n use core::mem;\n use core::nonzero::NonZero;\n use core::ops::{Deref, CoerceUnsized};\n+use core::ptr;\n use core::marker::Unsize;\n use core::hash::{Hash, Hasher};\n+use core::usize;\n use heap::deallocate;\n \n /// An atomically reference counted wrapper for shared state.\n@@ -145,6 +147,8 @@ pub struct Weak<T: ?Sized> {\n unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> { }\n unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> { }\n \n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -154,7 +158,12 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n \n struct ArcInner<T: ?Sized> {\n     strong: atomic::AtomicUsize,\n+\n+    // the value usize::MAX acts as a sentinel for temporarily \"locking\" the\n+    // ability to upgrade weak pointers or downgrade strong ones; this is used\n+    // to avoid races in `make_unique` and `get_mut`.\n     weak: atomic::AtomicUsize,\n+\n     data: T,\n }\n \n@@ -201,9 +210,25 @@ impl<T: ?Sized> Arc<T> {\n     #[unstable(feature = \"arc_weak\",\n                reason = \"Weak pointers may not belong in this module.\")]\n     pub fn downgrade(&self) -> Weak<T> {\n-        // See the clone() impl for why this is relaxed\n-        self.inner().weak.fetch_add(1, Relaxed);\n-        Weak { _ptr: self._ptr }\n+        loop {\n+            // This Relaxed is OK because we're checking the value in the CAS\n+            // below.\n+            let cur = self.inner().weak.load(Relaxed);\n+\n+            // check if the weak counter is currently \"locked\"; if so, spin.\n+            if cur == usize::MAX { continue }\n+\n+            // NOTE: this code currently ignores the possibility of overflow\n+            // into usize::MAX; in general both Rc and Arc need to be adjusted\n+            // to deal with overflow.\n+\n+            // Unlike with Clone(), we need this to be an Acquire read to\n+            // synchronize with the write coming from `is_unique`, so that the\n+            // events prior to that write happen before this read.\n+            if self.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n+                return Weak { _ptr: self._ptr }\n+            }\n+        }\n     }\n \n     /// Get the number of weak references to this value.\n@@ -241,7 +266,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of_val(&*ptr), min_align_of_val(&*ptr))\n+            deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n         }\n     }\n }\n@@ -258,51 +283,6 @@ pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::weak_count(this) }\n #[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::strong_count\")]\n pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::strong_count(this) }\n \n-\n-/// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n-///\n-/// Returns `None` if the `Arc<T>` is not unique.\n-///\n-/// This function is marked **unsafe** because it is racy if weak pointers\n-/// are active.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(arc_unique, alloc)]\n-/// extern crate alloc;\n-/// # fn main() {\n-/// use alloc::arc::{Arc, get_mut};\n-///\n-/// # unsafe {\n-/// let mut x = Arc::new(3);\n-/// *get_mut(&mut x).unwrap() = 4;\n-/// assert_eq!(*x, 4);\n-///\n-/// let _y = x.clone();\n-/// assert!(get_mut(&mut x).is_none());\n-/// # }\n-/// # }\n-/// ```\n-#[inline]\n-#[unstable(feature = \"arc_unique\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"this function is unsafe with weak pointers\")]\n-pub unsafe fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n-    // FIXME(#24880) potential race with upgraded weak pointers here\n-    if Arc::strong_count(this) == 1 && Arc::weak_count(this) == 0 {\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Arc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n-        let inner = &mut **this._ptr;\n-        Some(&mut inner.data)\n-    } else {\n-        None\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n@@ -350,44 +330,150 @@ impl<T: Clone> Arc<T> {\n     /// Make a mutable reference from the given `Arc<T>`.\n     ///\n     /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n-    ///\n-    /// This method is marked **unsafe** because it is racy if weak pointers\n-    /// are active.\n+    /// data is cloned if the (strong) reference count is greater than one. If\n+    /// we hold the only strong reference, any existing weak references will no\n+    /// longer be upgradeable.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// # #![feature(arc_unique)]\n     /// use std::sync::Arc;\n     ///\n-    /// # unsafe {\n     /// let mut five = Arc::new(5);\n     ///\n-    /// let mut_five = five.make_unique();\n-    /// # }\n+    /// let mut_five = Arc::make_unique(&mut five);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"arc_unique\")]\n-    #[deprecated(since = \"1.2.0\",\n-                 reason = \"this function is unsafe with weak pointers\")]\n-    pub unsafe fn make_unique(&mut self) -> &mut T {\n-        // FIXME(#24880) potential race with upgraded weak pointers here\n+    pub fn make_unique(this: &mut Arc<T>) -> &mut T {\n+        // Note that we hold both a strong reference and a weak reference.\n+        // Thus, releasing our strong reference only will not, by itself, cause\n+        // the memory to be deallocated.\n         //\n-        // Note that we hold a strong reference, which also counts as a weak\n-        // reference, so we only clone if there is an additional reference of\n-        // either kind.\n-        if self.inner().strong.load(SeqCst) != 1 ||\n-           self.inner().weak.load(SeqCst) != 1 {\n-            *self = Arc::new((**self).clone())\n+        // Use Acquire to ensure that we see any writes to `weak` that happen\n+        // before release writes (i.e., decrements) to `strong`. Since we hold a\n+        // weak count, there's no chance the ArcInner itself could be\n+        // deallocated.\n+        if this.inner().strong.compare_and_swap(1, 0, Acquire) != 1 {\n+            // Another srong pointer exists; clone\n+            *this = Arc::new((**this).clone());\n+        } else if this.inner().weak.load(Relaxed) != 1 {\n+            // Relaxed suffices in the above because this is fundamentally an\n+            // optimization: we are always racing with weak pointers being\n+            // dropped. Worst case, we end up allocated a new Arc unnecessarily.\n+\n+            // We removed the last strong ref, but there are additional weak\n+            // refs remaining. We'll move the contents to a new Arc, and\n+            // invalidate the other weak refs.\n+\n+            // Note that it is not possible for the read of `weak` to yield\n+            // usize::MAX (i.e., locked), since the weak count can only be\n+            // locked by a thread with a strong reference.\n+\n+            // Materialize our own implicit weak pointer, so that it can clean\n+            // up the ArcInner as needed.\n+            let weak = Weak { _ptr: this._ptr };\n+\n+            // mark the data itself as already deallocated\n+            unsafe {\n+                // there is no data race in the implicit write caused by `read`\n+                // here (due to zeroing) because data is no longer accessed by\n+                // other threads (due to there being no more strong refs at this\n+                // point).\n+                let mut swap = Arc::new(ptr::read(&(**weak._ptr).data));\n+                mem::swap(this, &mut swap);\n+                mem::forget(swap);\n+            }\n+        } else {\n+            // We were the sole reference of either kind; bump back up the\n+            // strong ref count.\n+            this.inner().strong.store(1, Release);\n         }\n+\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n-        let inner = &mut **self._ptr;\n-        &mut inner.data\n+        unsafe {\n+            let inner = &mut **this._ptr;\n+            &mut inner.data\n+        }\n     }\n }\n \n+impl<T: ?Sized> Arc<T> {\n+    /// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n+    ///\n+    /// Returns `None` if the `Arc<T>` is not unique.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(arc_unique, alloc)]\n+    /// extern crate alloc;\n+    /// # fn main() {\n+    /// use alloc::arc::Arc;\n+    ///\n+    /// let mut x = Arc::new(3);\n+    /// *Arc::get_mut(&mut x).unwrap() = 4;\n+    /// assert_eq!(*x, 4);\n+    ///\n+    /// let _y = x.clone();\n+    /// assert!(Arc::get_mut(&mut x).is_none());\n+    /// # }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_unique\")]\n+    pub fn get_mut(this: &mut Arc<T>) -> Option<&mut T> {\n+        if this.is_unique() {\n+            // This unsafety is ok because we're guaranteed that the pointer\n+            // returned is the *only* pointer that will ever be returned to T. Our\n+            // reference count is guaranteed to be 1 at this point, and we required\n+            // the Arc itself to be `mut`, so we're returning the only possible\n+            // reference to the inner data.\n+            unsafe {\n+                let inner = &mut **this._ptr;\n+                Some(&mut inner.data)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Determine whether this is the unique reference (including weak refs) to\n+    /// the underlying data.\n+    ///\n+    /// Note that this requires locking the weak ref count.\n+    fn is_unique(&mut self) -> bool {\n+        // lock the weak pointer count if we appear to be the sole weak pointer\n+        // holder.\n+        //\n+        // The acquire label here ensures a happens-before relationship with any\n+        // writes to `strong` prior to decrements of the `weak` count (via drop,\n+        // which uses Release).\n+        if self.inner().weak.compare_and_swap(1, usize::MAX, Acquire) == 1 {\n+            // Due to the previous acquire read, this will observe any writes to\n+            // `strong` that were due to upgrading weak pointers; only strong\n+            // clones remain, which require that the strong count is > 1 anyway.\n+            let unique = self.inner().strong.load(Relaxed) == 1;\n+\n+            // The release write here synchronizes with a read in `downgrade`,\n+            // effectively preventing the above read of `strong` from happening\n+            // after the write.\n+            self.inner().weak.store(1, Release); // release the lock\n+            unique\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+#[inline]\n+#[unstable(feature = \"arc_unique\")]\n+#[deprecated(since = \"1.2\", reason = \"use Arc::get_mut instead\")]\n+pub fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n+    Arc::get_mut(this)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n@@ -483,9 +569,15 @@ impl<T: ?Sized> Weak<T> {\n         // fetch_add because once the count hits 0 it must never be above 0.\n         let inner = self.inner();\n         loop {\n-            let n = inner.strong.load(SeqCst);\n+            // Relaxed load because any write of 0 that we can observe\n+            // leaves the field in a permanently zero state (so a\n+            // \"stale\" read of 0 is fine), and any other value is\n+            // confirmed via the CAS below.\n+            let n = inner.strong.load(Relaxed);\n             if n == 0 { return None }\n-            let old = inner.strong.compare_and_swap(n, n + 1, SeqCst);\n+\n+            // Relaxed is valid for the same reason it is on Arc's Clone impl\n+            let old = inner.strong.compare_and_swap(n, n + 1, Relaxed);\n             if old == n { return Some(Arc { _ptr: self._ptr }) }\n         }\n     }\n@@ -516,9 +608,12 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        // See comments in Arc::clone() for why this is relaxed\n+        // See comments in Arc::clone() for why this is relaxed.  This can use a\n+        // fetch_add (ignoring the lock) because the weak count is only locked\n+        // where are *no other* weak pointers in existence. (So we can't be\n+        // running this code in that case).\n         self.inner().weak.fetch_add(1, Relaxed);\n-        Weak { _ptr: self._ptr }\n+        return Weak { _ptr: self._ptr }\n     }\n }\n \n@@ -561,11 +656,16 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n         // the memory orderings\n+        //\n+        // It's not necessary to check for the locked state here, because the\n+        // weak count can only be locked if there was precisely one weak ref,\n+        // meaning that drop could only subsequently run ON that remaining weak\n+        // ref, which can only happen after the lock is released.\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8,\n                                 size_of_val(&*ptr),\n-                                min_align_of_val(&*ptr)) }\n+                                align_of_val(&*ptr)) }\n         }\n     }\n }\n@@ -792,13 +892,13 @@ mod tests {\n             let mut cow1 = cow0.clone();\n             let mut cow2 = cow1.clone();\n \n-            assert!(75 == *cow0.make_unique());\n-            assert!(75 == *cow1.make_unique());\n-            assert!(75 == *cow2.make_unique());\n+            assert!(75 == *Arc::make_unique(&mut cow0));\n+            assert!(75 == *Arc::make_unique(&mut cow1));\n+            assert!(75 == *Arc::make_unique(&mut cow2));\n \n-            *cow0.make_unique() += 1;\n-            *cow1.make_unique() += 2;\n-            *cow2.make_unique() += 3;\n+            *Arc::make_unique(&mut cow0) += 1;\n+            *Arc::make_unique(&mut cow1) += 2;\n+            *Arc::make_unique(&mut cow2) += 3;\n \n             assert!(76 == *cow0);\n             assert!(77 == *cow1);\n@@ -822,7 +922,7 @@ mod tests {\n         assert!(75 == *cow2);\n \n         unsafe {\n-            *cow0.make_unique() += 1;\n+            *Arc::make_unique(&mut cow0) += 1;\n         }\n \n         assert!(76 == *cow0);\n@@ -845,7 +945,7 @@ mod tests {\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n         unsafe {\n-            *cow0.make_unique() += 1;\n+            *Arc::make_unique(&mut cow0) += 1;\n         }\n \n         assert!(76 == *cow0);"}, {"sha": "acf22094233230f5405f1b0c906c39ef83ef581c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 106, "deletions": 11, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -55,14 +55,17 @@\n \n use core::prelude::*;\n \n+use heap;\n+\n use core::any::Any;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::marker::Unsize;\n+use core::marker::{self, Unsize};\n use core::mem;\n use core::ops::{CoerceUnsized, Deref, DerefMut};\n-use core::ptr::{Unique};\n+use core::ops::{Placer, Boxed, Place, InPlace, BoxPlace};\n+use core::ptr::Unique;\n use core::raw::{TraitObject};\n \n /// A value that represents the heap. This is the default place that the `box`\n@@ -72,7 +75,7 @@ use core::raw::{TraitObject};\n ///\n /// ```\n /// # #![feature(box_heap)]\n-/// #![feature(box_syntax)]\n+/// #![feature(box_syntax, placement_in_syntax)]\n /// use std::boxed::HEAP;\n ///\n /// fn main() {\n@@ -83,15 +86,110 @@ use core::raw::{TraitObject};\n #[lang = \"exchange_heap\"]\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n-pub const HEAP: () = ();\n+pub const HEAP: ExchangeHeapSingleton =\n+    ExchangeHeapSingleton { _force_singleton: () };\n+\n+/// This the singleton type used solely for `boxed::HEAP`.\n+#[derive(Copy, Clone)]\n+pub struct ExchangeHeapSingleton { _force_singleton: () }\n \n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[fundamental]\n-pub struct Box<T>(Unique<T>);\n+pub struct Box<T: ?Sized>(Unique<T>);\n+\n+/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n+///\n+/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n+/// introducing a separate `IntermediateBox<T>`; but then you hit\n+/// issues when you e.g. attempt to destructure an instance of `Box`,\n+/// since it is a lang item and so it gets special handling by the\n+/// compiler.  Easier just to make this parallel type for now.\n+///\n+/// FIXME (pnkfelix): Currently the `box` protocol only supports\n+/// creating instances of sized types. This IntermediateBox is\n+/// designed to be forward-compatible with a future protocol that\n+/// supports creating instances of unsized types; that is why the type\n+/// parameter has the `?Sized` generalization marker, and is also why\n+/// this carries an explicit size. However, it probably does not need\n+/// to carry the explicit alignment; that is just a work-around for\n+/// the fact that the `align_of` intrinsic currently requires the\n+/// input type to be Sized (which I do not think is strictly\n+/// necessary).\n+#[unstable(feature = \"placement_in\", reason = \"placement box design is still being worked out.\")]\n+pub struct IntermediateBox<T: ?Sized>{\n+    ptr: *mut u8,\n+    size: usize,\n+    align: usize,\n+    marker: marker::PhantomData<*mut T>,\n+}\n+\n+impl<T> Place<T> for IntermediateBox<T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { ::core::mem::transmute(self.ptr) }\n+    }\n+}\n+\n+unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n+    let p = b.ptr as *mut T;\n+    mem::forget(b);\n+    mem::transmute(p)\n+}\n+\n+fn make_place<T>() -> IntermediateBox<T> {\n+    let size = mem::size_of::<T>();\n+    let align = mem::align_of::<T>();\n+\n+    let p = if size == 0 {\n+        heap::EMPTY as *mut u8\n+    } else {\n+        let p = unsafe {\n+            heap::allocate(size, align)\n+        };\n+        if p.is_null() {\n+            panic!(\"Box make_place allocation failure.\");\n+        }\n+        p\n+    };\n+\n+    IntermediateBox { ptr: p, size: size, align: align, marker: marker::PhantomData }\n+}\n+\n+impl<T> BoxPlace<T> for IntermediateBox<T> {\n+    fn make_place() -> IntermediateBox<T> { make_place() }\n+}\n+\n+impl<T> InPlace<T> for IntermediateBox<T> {\n+    type Owner = Box<T>;\n+    unsafe fn finalize(self) -> Box<T> { finalize(self) }\n+}\n+\n+impl<T> Boxed for Box<T> {\n+    type Data = T;\n+    type Place = IntermediateBox<T>;\n+    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> { finalize(b) }\n+}\n+\n+impl<T> Placer<T> for ExchangeHeapSingleton {\n+    type Place = IntermediateBox<T>;\n+\n+    fn make_place(self) -> IntermediateBox<T> {\n+        make_place()\n+    }\n+}\n+\n+impl<T: ?Sized> Drop for IntermediateBox<T> {\n+    fn drop(&mut self) {\n+        if self.size > 0 {\n+            unsafe {\n+                heap::deallocate(self.ptr, self.size, self.align)\n+            }\n+        }\n+    }\n+}\n \n impl<T> Box<T> {\n     /// Allocates memory on the heap and then moves `x` into it.\n@@ -116,7 +214,7 @@ impl<T : ?Sized> Box<T> {\n     /// of `T` and releases memory. Since the way `Box` allocates and\n     /// releases memory is unspecified, the only valid pointer to pass\n     /// to this function is the one taken from another `Box` with\n-    /// `boxed::into_raw` function.\n+    /// `Box::into_raw` function.\n     ///\n     /// Function is unsafe, because improper use of this function may\n     /// lead to memory problems like double-free, for example if the\n@@ -140,10 +238,8 @@ impl<T : ?Sized> Box<T> {\n     /// # Examples\n     /// ```\n     /// # #![feature(box_raw)]\n-    /// use std::boxed;\n-    ///\n     /// let seventeen = Box::new(17u32);\n-    /// let raw = boxed::into_raw(seventeen);\n+    /// let raw = Box::into_raw(seventeen);\n     /// let boxed_again = unsafe { Box::from_raw(raw) };\n     /// ```\n     #[unstable(feature = \"box_raw\", reason = \"may be renamed\")]\n@@ -201,8 +297,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// let y = x.clone();\n     /// ```\n     #[inline]\n-    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n-\n+    fn clone(&self) -> Box<T> { box (HEAP) {(**self).clone()} }\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples"}, {"sha": "2ef23b26a56a739549562c57ef71f521dab72063", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -76,9 +76,9 @@ fn deref() {\n \n #[test]\n fn raw_sized() {\n+    let x = Box::new(17);\n+    let p = Box::into_raw(x);\n     unsafe {\n-        let x = Box::new(17);\n-        let p = boxed::into_raw(x);\n         assert_eq!(17, *p);\n         *p = 19;\n         let y = Box::from_raw(p);\n@@ -105,9 +105,9 @@ fn raw_trait() {\n         }\n     }\n \n+    let x: Box<Foo> = Box::new(Bar(17));\n+    let p = Box::into_raw(x);\n     unsafe {\n-        let x: Box<Foo> = Box::new(Bar(17));\n-        let p = boxed::into_raw(x);\n         assert_eq!(17, (*p).get());\n         (*p).set(19);\n         let y: Box<Foo> = Box::from_raw(p);"}, {"sha": "f66495c4057c4c283350eaef90296ac81bf0ca51", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -70,6 +70,8 @@\n        test(no_crate_inject))]\n #![no_std]\n \n+// SNAP d4432b3\n+#![allow(unused_features)] // until feature(placement_in_syntax) is in snap\n #![feature(allocator)]\n #![feature(box_syntax)]\n #![feature(coerce_unsized)]\n@@ -82,12 +84,15 @@\n #![feature(no_std)]\n #![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n+#![feature(placement_in_syntax)]\n+#![feature(placement_new_protocol)]\n #![feature(raw)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(unsize)]\n+#![feature(core_slice_ext)]\n \n #![cfg_attr(test, feature(test, alloc, rustc_private, box_raw))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n@@ -122,6 +127,7 @@ mod boxed { pub use std::boxed::{Box, HEAP}; }\n mod boxed_test;\n pub mod arc;\n pub mod rc;\n+pub mod raw_vec;\n \n /// Common out-of-memory routine\n #[cold]\n@@ -133,19 +139,3 @@ pub fn oom() -> ! {\n     //                allocate.\n     unsafe { core::intrinsics::abort() }\n }\n-\n-// FIXME(#14344): When linking liballoc with libstd, this library will be linked\n-//                as an rlib (it only exists as an rlib). It turns out that an\n-//                optimized standard library doesn't actually use *any* symbols\n-//                from this library. Everything is inlined and optimized away.\n-//                This means that linkers will actually omit the object for this\n-//                file, even though it may be needed in the future.\n-//\n-//                To get around this for now, we define a dummy symbol which\n-//                will never get inlined so the stdlib can call it. The stdlib's\n-//                reference to this symbol will cause this library's object file\n-//                to get linked in to libstd successfully (the linker won't\n-//                optimize it out).\n-#[doc(hidden)]\n-#[unstable(feature = \"issue_14344_fixme\")]\n-pub fn fixme_14344_be_sure_to_link_to_collections() {}"}, {"sha": "9311f44d9df00ff321b3a8d7b94469b9fc3f3b16", "filename": "src/liballoc/raw_vec.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -0,0 +1,453 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::ptr::Unique;\n+use core::mem;\n+use core::slice::{self, SliceExt};\n+use heap;\n+use super::oom;\n+use super::boxed::Box;\n+use core::ops::Drop;\n+\n+/// A low-level utility for more ergonomically allocating, reallocating, and deallocating a\n+/// a buffer of memory on the heap without having to worry about all the corner cases\n+/// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n+/// In particular:\n+///\n+/// * Produces heap::EMPTY on zero-sized types\n+/// * Produces heap::EMPTY on zero-length allocations\n+/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n+/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n+/// * Guards against overflowing your length\n+/// * Aborts on OOM\n+/// * Avoids freeing heap::EMPTY\n+/// * Contains a ptr::Unique and thus endows the user with all related benefits\n+///\n+/// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n+/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n+/// to handle the actual things *stored* inside of a RawVec.\n+///\n+/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n+/// This enables you to use capacity growing logic catch the overflows in your length\n+/// that might occur with zero-sized types.\n+///\n+/// However this means that you need to be careful when roundtripping this type\n+/// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n+/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n+/// field. This allows zero-sized types to not be special-cased by consumers of\n+/// this type.\n+#[unsafe_no_drop_flag]\n+pub struct RawVec<T> {\n+    ptr: Unique<T>,\n+    cap: usize,\n+}\n+\n+impl<T> RawVec<T> {\n+    /// Creates the biggest possible RawVec without allocating. If T has positive\n+    /// size, then this makes a RawVec with capacity 0. If T has 0 size, then it\n+    /// it makes a RawVec with capacity `usize::MAX`. Useful for implementing\n+    /// delayed allocation.\n+    pub fn new() -> Self {\n+        unsafe {\n+            // !0 is usize::MAX. This branch should be stripped at compile time.\n+            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+\n+            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n+            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n+        }\n+    }\n+\n+    /// Creates a RawVec with exactly the capacity and alignment requirements\n+    /// for a `[T; cap]`. This is equivalent to calling RawVec::new when `cap` is 0\n+    /// or T is zero-sized. Note that if `T` is zero-sized this means you will *not*\n+    /// get a RawVec with the requested capacity!\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM\n+    pub fn with_capacity(cap: usize) -> Self {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+\n+            let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n+            alloc_guard(alloc_size);\n+\n+            // handles ZSTs and `cap = 0` alike\n+            let ptr = if alloc_size == 0 {\n+                heap::EMPTY as *mut u8\n+            } else {\n+                let align = mem::align_of::<T>();\n+                let ptr = heap::allocate(alloc_size, align);\n+                if ptr.is_null() { oom() }\n+                ptr\n+            };\n+\n+            RawVec { ptr: Unique::new(ptr as *mut _), cap: cap }\n+        }\n+    }\n+\n+    /// Reconstitutes a RawVec from a pointer and capacity.\n+    ///\n+    /// # Undefined Behaviour\n+    ///\n+    /// The ptr must be allocated, and with the given capacity. The\n+    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n+    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n+        RawVec { ptr: Unique::new(ptr), cap: cap }\n+    }\n+\n+    /// Converts a `Box<[T]>` into a `RawVec<T>`.\n+    pub fn from_box(mut slice: Box<[T]>) -> Self {\n+        unsafe {\n+            let result = RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len());\n+            mem::forget(slice);\n+            result\n+        }\n+    }\n+}\n+\n+impl<T> RawVec<T> {\n+    /// Gets a raw pointer to the start of the allocation. Note that this is\n+    /// heap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// be careful.\n+    pub fn ptr(&self) -> *mut T {\n+        *self.ptr\n+    }\n+\n+    /// Gets the capacity of the allocation.\n+    ///\n+    /// This will always be `usize::MAX` if `T` is zero-sized.\n+    pub fn cap(&self) -> usize {\n+        if mem::size_of::<T>() == 0 { !0 } else { self.cap }\n+    }\n+\n+    /// Doubles the size of the type's backing allocation. This is common enough\n+    /// to want to do that it's easiest to just have a dedicated method. Slightly\n+    /// more efficient logic can be provided for this than the general case.\n+    ///\n+    /// This function is ideal for when pushing elements one-at-a-time because\n+    /// you don't need to incur the costs of the more general computations\n+    /// reserve needs to do to guard against overflow. You do however need to\n+    /// manually check if your `len == cap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    ///   all `usize::MAX` slots in your imaginary buffer.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// struct MyVec<T> {\n+    ///     buf: RawVec<T>,\n+    ///     len: usize,\n+    /// }\n+    ///\n+    /// impl<T> MyVec<T> {\n+    ///     pub fn push(&mut self, elem: T) {\n+    ///         if self.len == self.buf.cap() { self.buf.double(); }\n+    ///         // double would have aborted or panicked if the len exceeded\n+    ///         // `isize::MAX` so this is safe to do unchecked now.\n+    ///         unsafe {\n+    ///             ptr::write(self.buf.ptr().offset(self.len as isize), elem);\n+    ///         }\n+    ///         self.len += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline(never)]\n+    #[cold]\n+    pub fn double(&mut self) {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+\n+            // since we set the capacity to usize::MAX when elem_size is\n+            // 0, getting to here necessarily means the RawVec is overfull.\n+            assert!(elem_size != 0, \"capacity overflow\");\n+\n+            let align = mem::align_of::<T>();\n+\n+            let (new_cap, ptr) = if self.cap == 0 {\n+                // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n+                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n+                let ptr = heap::allocate(new_cap * elem_size, align);\n+                (new_cap, ptr)\n+            } else {\n+                // Since we guarantee that we never allocate more than isize::MAX bytes,\n+                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n+                let new_cap = 2 * self.cap;\n+                let new_alloc_size = new_cap * elem_size;\n+                alloc_guard(new_alloc_size);\n+                let ptr = heap::reallocate(self.ptr() as *mut _,\n+                                           self.cap * elem_size,\n+                                           new_alloc_size,\n+                                           align);\n+                (new_cap, ptr)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+\n+    /// Ensures that the buffer contains at least enough space to hold\n+    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n+    /// will reallocate the minimum possible amount of memory necessary.\n+    /// Generally this will be exactly the amount of memory necessary,\n+    /// but in principle the allocator is free to give back more than\n+    /// we asked for.\n+    ///\n+    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behaviour of this function may break.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM\n+    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+            let align = mem::align_of::<T>();\n+\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity.\n+            // Wrapping in case they gave a bad `used_cap`.\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap { return; }\n+\n+            // Nothing we can really do about these checks :(\n+            let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n+            let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n+            alloc_guard(new_alloc_size);\n+\n+            let ptr = if self.cap == 0 {\n+                heap::allocate(new_alloc_size, align)\n+            } else {\n+                heap::reallocate(self.ptr() as *mut _,\n+                                 self.cap * elem_size,\n+                                 new_alloc_size,\n+                                 align)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+\n+    /// Ensures that the buffer contains at least enough space to hold\n+    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// enough capacity, will reallocate enough space plus comfortable slack\n+    /// space to get amortized `O(1)` behaviour. Will limit this behaviour\n+    /// if it would needlessly cause itself to panic.\n+    ///\n+    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behaviour of this function may break.\n+    ///\n+    /// This is ideal for implementing a bulk-push operation like `extend`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// struct MyVec<T> {\n+    ///     buf: RawVec<T>,\n+    ///     len: usize,\n+    /// }\n+    ///\n+    /// impl<T> MyVec<T> {\n+    ///     pub fn push_all(&mut self, elems: &[T]) {\n+    ///         self.buf.reserve(self.len, elems.len());\n+    ///         // reserve would have aborted or panicked if the len exceeded\n+    ///         // `isize::MAX` so this is safe to do unchecked now.\n+    ///         for x in elems {\n+    ///             unsafe {\n+    ///                 ptr::write(self.buf.ptr().offset(self.len as isize), x.clone());\n+    ///             }\n+    ///             self.len += 1;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+            let align = mem::align_of::<T>();\n+\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity.\n+            // Wrapping in case they give a bas `used_cap`\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap { return; }\n+\n+            // Nothing we can really do about these checks :(\n+            let new_cap = used_cap.checked_add(needed_extra_cap)\n+                                  .and_then(|cap| cap.checked_mul(2))\n+                                  .expect(\"capacity overflow\");\n+            let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n+            // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_alloc_size);\n+\n+            let ptr = if self.cap == 0 {\n+                heap::allocate(new_alloc_size, align)\n+            } else {\n+                heap::reallocate(self.ptr() as *mut _,\n+                                 self.cap * elem_size,\n+                                 new_alloc_size,\n+                                 align)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+\n+    /// Shrinks the allocation down to the specified amount. If the given amount\n+    /// is 0, actually completely deallocates.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the given amount is *larger* than the current capacity.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM.\n+    pub fn shrink_to_fit(&mut self, amount: usize) {\n+        let elem_size = mem::size_of::<T>();\n+        let align = mem::align_of::<T>();\n+\n+        // Set the `cap` because they might be about to promote to a `Box<[T]>`\n+        if elem_size == 0 {\n+            self.cap = amount;\n+            return;\n+        }\n+\n+        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n+        assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n+\n+        if amount == 0 {\n+            mem::replace(self, RawVec::new());\n+        } else if self.cap != amount {\n+            unsafe {\n+                // Overflow check is unnecessary as the vector is already at\n+                // least this large.\n+                let ptr = heap::reallocate(self.ptr() as *mut _,\n+                                           self.cap * elem_size,\n+                                           amount * elem_size,\n+                                           align);\n+                if ptr.is_null() { oom() }\n+                self.ptr = Unique::new(ptr as *mut _);\n+            }\n+            self.cap = amount;\n+        }\n+    }\n+\n+    /// Converts the entire buffer into `Box<[T]>`.\n+    ///\n+    /// While it is not *strictly* Undefined Behaviour to call\n+    /// this procedure while some of the RawVec is unintialized,\n+    /// it cetainly makes it trivial to trigger it.\n+    ///\n+    /// Note that this will correctly reconstitute any `cap` changes\n+    /// that may have been performed. (see description of type for details)\n+    pub unsafe fn into_box(self) -> Box<[T]> {\n+        // NOTE: not calling `cap()` here, actually using the real `cap` field!\n+        let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n+        let output: Box<[T]> = Box::from_raw(slice);\n+        mem::forget(self);\n+        output\n+    }\n+\n+    /// This is a stupid name in the hopes that someone will find this in the\n+    /// not too distant future and remove it with the rest of\n+    /// #[unsafe_no_drop_flag]\n+    pub fn unsafe_no_drop_flag_needs_drop(&self) -> bool {\n+        self.cap != mem::POST_DROP_USIZE\n+    }\n+}\n+\n+impl<T> Drop for RawVec<T> {\n+    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    fn drop(&mut self) {\n+        let elem_size = mem::size_of::<T>();\n+        if elem_size != 0 && self.cap != 0 && self.unsafe_no_drop_flag_needs_drop() {\n+            let align = mem::align_of::<T>();\n+\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+\n+\n+\n+// We need to guarantee the following:\n+// * We don't ever allocate `> isize::MAX` byte-size objects\n+// * We don't overflow `usize::MAX` and actually allocate too little\n+//\n+// On 64-bit we just need to check for overflow since trying to allocate\n+// `> isize::MAX` bytes will surely fail. On 32-bit we need to add an extra\n+// guard for this in case we're running on a platform which can use all 4GB in\n+// user-space. e.g. PAE or x32\n+\n+#[inline]\n+#[cfg(target_pointer_width = \"64\")]\n+fn alloc_guard(_alloc_size: usize) { }\n+\n+#[inline]\n+#[cfg(target_pointer_width = \"32\")]\n+fn alloc_guard(alloc_size: usize) {\n+    assert!(alloc_size <= ::core::isize::MAX as usize, \"capacity overflow\");\n+}"}, {"sha": "d461eeea0b7ebbef617707c72a5f5d86b24dcc1e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -162,7 +162,7 @@ use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::intrinsics::{assume, drop_in_place};\n use core::marker::{self, Unsize};\n-use core::mem::{self, min_align_of, size_of, min_align_of_val, size_of_val, forget};\n+use core::mem::{self, align_of, size_of, align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n use core::ops::{CoerceUnsized, Deref};\n use core::ptr;\n@@ -246,7 +246,7 @@ impl<T> Rc<T> {\n                 // destruct the box and skip our Drop\n                 // we can ignore the refcounts because we know we're unique\n                 deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n-                            min_align_of::<RcBox<T>>());\n+                            align_of::<RcBox<T>>());\n                 forget(rc);\n                 Ok(val)\n             }\n@@ -496,7 +496,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n                     if self.weak() == 0 {\n                         deallocate(ptr as *mut u8,\n                                    size_of_val(&*ptr),\n-                                   min_align_of_val(&*ptr))\n+                                   align_of_val(&*ptr))\n                     }\n                 }\n             }\n@@ -734,6 +734,8 @@ pub struct Weak<T: ?Sized> {\n impl<T: ?Sized> !marker::Send for Weak<T> {}\n impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n+impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n+\n #[unstable(feature = \"rc_weak\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Weak<T> {\n@@ -805,7 +807,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n                 // the strong pointers have disappeared.\n                 if self.weak() == 0 {\n                     deallocate(ptr as *mut u8, size_of_val(&*ptr),\n-                               min_align_of_val(&*ptr))\n+                               align_of_val(&*ptr))\n                 }\n             }\n         }"}, {"sha": "4d064b16ad027ea210d39b2fe0c1028d1d2782c8", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -244,7 +244,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n     fn alloc_copy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n-                                            mem::min_align_of::<T>());\n+                                            mem::align_of::<T>());\n             let ptr = ptr as *mut T;\n             ptr::write(&mut (*ptr), op());\n             return &mut *ptr;\n@@ -300,7 +300,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n                 self.alloc_noncopy_inner(mem::size_of::<T>(),\n-                                         mem::min_align_of::<T>());\n+                                         mem::align_of::<T>());\n             let ty_ptr = ty_ptr as *mut usize;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n@@ -393,7 +393,7 @@ struct TypedArenaChunk<T> {\n \n fn calculate_size<T>(capacity: usize) -> usize {\n     let mut size = mem::size_of::<TypedArenaChunk<T>>();\n-    size = round_up(size, mem::min_align_of::<T>());\n+    size = round_up(size, mem::align_of::<T>());\n     let elem_size = mem::size_of::<T>();\n     let elems_size = elem_size.checked_mul(capacity).unwrap();\n     size = size.checked_add(elems_size).unwrap();\n@@ -405,7 +405,7 @@ impl<T> TypedArenaChunk<T> {\n     unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize)\n            -> *mut TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n-        let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n+        let chunk = allocate(size, mem::align_of::<TypedArenaChunk<T>>())\n                     as *mut TypedArenaChunk<T>;\n         if chunk.is_null() { alloc::oom() }\n         (*chunk).next = next;\n@@ -431,7 +431,7 @@ impl<T> TypedArenaChunk<T> {\n         let size = calculate_size::<T>(self.capacity);\n         let self_ptr: *mut TypedArenaChunk<T> = self;\n         deallocate(self_ptr as *mut u8, size,\n-                   mem::min_align_of::<TypedArenaChunk<T>>());\n+                   mem::align_of::<TypedArenaChunk<T>>());\n         if !next.is_null() {\n             let capacity = (*next).capacity;\n             (*next).destroy(capacity);\n@@ -444,7 +444,7 @@ impl<T> TypedArenaChunk<T> {\n         let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n             mem::transmute(round_up(this.offset(1) as usize,\n-                                    mem::min_align_of::<T>()))\n+                                    mem::align_of::<T>()))\n         }\n     }\n "}, {"sha": "3a4cfbba65f4ecfc463262a32c7cc105b531c521", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deprecated(reason = \"BitVec and BitSet have been migrated to cargo as bit-vec and bit-set\",\n+              since = \"1.3.0\")]\n+#![unstable(feature = \"collections\", reason = \"deprecated\")]\n+#![allow(deprecated)]\n+\n // FIXME(Gankro): BitVec and BitSet are very tightly coupled. Ideally (for\n // maintenance), they should be in separate files/modules, with BitSet only\n // using BitVec's public API. This will be hard for performance though, because\n@@ -278,7 +283,7 @@ impl BitVec {\n     pub fn from_elem(nbits: usize, bit: bool) -> BitVec {\n         let nblocks = blocks_for_bits(nbits);\n         let mut bit_vec = BitVec {\n-            storage: repeat(if bit { !0 } else { 0 }).take(nblocks).collect(),\n+            storage: vec![if bit { !0 } else { 0 }; nblocks],\n             nbits: nbits\n         };\n         bit_vec.fix_last_block();"}, {"sha": "1c75636cb052d39304e06224a520c1b7eecfa5a0", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -215,7 +215,7 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n-    /// Copies the data if it is not already owned.\n+    /// Clones the data if it is not already owned.\n     ///\n     /// # Examples\n     ///\n@@ -241,7 +241,7 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n \n     /// Extracts the owned data.\n     ///\n-    /// Copies the data if it is not already owned.\n+    /// Clones the data if it is not already owned.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4d76a986700a25ed316f879c3b43eb261ad83c81", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -163,12 +163,12 @@ fn test_offset_calculation() {\n }\n \n fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n-    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::min_align_of::<K>());\n-    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::min_align_of::<V>());\n+    let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::align_of::<K>());\n+    let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::align_of::<V>());\n     let (edges_size, edges_align) = if is_leaf {\n         (0, 1)\n     } else {\n-        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::min_align_of::<Node<K, V>>())\n+        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::align_of::<Node<K, V>>())\n     };\n \n     calculate_allocation(\n@@ -181,11 +181,11 @@ fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize,\n fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n     let keys_size = capacity * mem::size_of::<K>();\n     let vals_size = capacity * mem::size_of::<V>();\n-    let vals_align = mem::min_align_of::<V>();\n+    let vals_align = mem::align_of::<V>();\n     let edges_align = if is_leaf {\n         1\n     } else {\n-        mem::min_align_of::<Node<K, V>>()\n+        mem::align_of::<Node<K, V>>()\n     };\n \n     calculate_offsets("}, {"sha": "7df259e9b36a89036b758b6bb979323f8a8c314a", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -128,15 +128,15 @@\n //! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n //! well as `isize`).  The current mapping of types to traits is:\n //!\n-//! * *nothing* \u21d2 `Display`\n-//! * `?` \u21d2 `Debug`\n-//! * `o` \u21d2 `Octal`\n-//! * `x` \u21d2 `LowerHex`\n-//! * `X` \u21d2 `UpperHex`\n-//! * `p` \u21d2 `Pointer`\n-//! * `b` \u21d2 `Binary`\n-//! * `e` \u21d2 `LowerExp`\n-//! * `E` \u21d2 `UpperExp`\n+//! * *nothing* \u21d2 [`Display`](trait.Display.html)\n+//! * `?` \u21d2 [`Debug`](trait.Debug.html)\n+//! * `o` \u21d2 [`Octal`](trait.Octal.html)\n+//! * `x` \u21d2 [`LowerHex`](trait.LowerHex.html)\n+//! * `X` \u21d2 [`UpperHex`](trait.UpperHex.html)\n+//! * `p` \u21d2 [`Pointer`](trait.Pointer.html)\n+//! * `b` \u21d2 [`Binary`](trait.Binary.html)\n+//! * `e` \u21d2 [`LowerExp`](trait.LowerExp.html)\n+//! * `E` \u21d2 [`UpperExp`](trait.UpperExp.html)\n //!\n //! What this means is that any type of argument which implements the\n //! `fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n@@ -367,11 +367,11 @@\n //!         should always be printed.\n //! * '-' - Currently not used\n //! * '#' - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used.  For array slices, the alternate form omits the brackets.\n-//!         For the integer formatting traits, the alternate forms are:\n+//!         be used. The alternate forms are:\n+//!     * `#?` - pretty-print the `Debug` formatting\n //!     * `#x` - precedes the argument with a \"0x\"\n //!     * `#X` - precedes the argument with a \"0x\"\n-//!     * `#t` - precedes the argument with a \"0b\"\n+//!     * `#b` - precedes the argument with a \"0b\"\n //!     * `#o` - precedes the argument with a \"0o\"\n //! * '0' - This is used to indicate for integer formats that the padding should\n //!         both be done with a `0` character as well as be sign-aware. A format\n@@ -408,19 +408,20 @@\n //!\n //! There are three possible ways to specify the desired `precision`:\n //!\n-//! There are three possible ways to specify the desired `precision`:\n-//! 1. An integer `.N`,\n-//! 2. an integer followed by dollar sign `.N$`, or\n-//! 3. an asterisk `.*`.\n+//! 1. An integer `.N`:\n+//!\n+//!    the integer `N` itself is the precision.\n+//!\n+//! 2. An integer followed by dollar sign `.N$`:\n //!\n-//! The first specification, `.N`, means the integer `N` itself is the precision.\n+//!    use format *argument* `N` (which must be a `usize`) as the precision.\n //!\n-//! The second, `.N$`, means use format *argument* `N` (which must be a `usize`) as the precision.\n+//! 3. An asterisk `.*`:\n //!\n-//! Finally,  `.*` means that this `{...}` is associated with *two* format inputs rather than one:\n-//! the first input holds the `usize` precision, and the second holds the value to print.  Note\n-//! that in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part\n-//! refers to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n+//!    first input holds the `usize` precision, and the second holds the value to print.  Note that\n+//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n+//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!\n //! For example, these:\n //!"}, {"sha": "1f94838499218ee1bc22168ed3f7024c5e816c4f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -32,7 +32,6 @@\n \n #![feature(alloc)]\n #![feature(box_patterns)]\n-#![feature(box_raw)]\n #![feature(box_syntax)]\n #![feature(core)]\n #![feature(core_intrinsics)]\n@@ -77,7 +76,9 @@ extern crate alloc;\n #[cfg(test)] extern crate test;\n \n pub use binary_heap::BinaryHeap;\n+#[allow(deprecated)]\n pub use bit_vec::BitVec;\n+#[allow(deprecated)]\n pub use bit_set::BitSet;\n pub use btree_map::BTreeMap;\n pub use btree_set::BTreeSet;\n@@ -111,11 +112,13 @@ pub mod vec_map;\n \n #[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n pub mod bit_vec {\n+    #![allow(deprecated)]\n     pub use bit::{BitVec, Iter};\n }\n \n #[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n pub mod bit_set {\n+    #![allow(deprecated)]\n     pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n }\n@@ -130,12 +133,6 @@ pub mod btree_set {\n     pub use btree::set::*;\n }\n \n-\n-// FIXME(#14344) this shouldn't be necessary\n-#[doc(hidden)]\n-#[unstable(feature = \"issue_14344_fixme\")]\n-pub fn fixme_14344_be_sure_to_link_to_collections() {}\n-\n #[cfg(not(test))]\n mod std {\n     pub use core::ops;      // RangeFull"}, {"sha": "4378d0804df963569c7c2c6dc7f83adf6473f40f", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Utilities for slice manipulation\n+//! A dynamically-sized view into a contiguous sequence, `[T]`.\n //!\n-//! The `slice` module contains useful code to help work with slice values.\n //! Slices are a view into a block of memory represented as a pointer and a\n //! length.\n //!\n@@ -78,7 +77,8 @@\n //!   iterators.\n //! * Further methods that return iterators are `.split()`, `.splitn()`,\n //!   `.chunks()`, `.windows()` and more.\n-#![doc(primitive = \"slice\")]\n+//!\n+//! *[See also the slice primitive type](../primitive.slice.html).*\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Many of the usings in this module are only used in the test configuration.\n@@ -282,34 +282,65 @@ impl<T> [T] {\n \n     /// Returns all but the first element of a slice.\n     #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n+    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_first\")]\n     #[inline]\n     pub fn tail(&self) -> &[T] {\n         core_slice::SliceExt::tail(self)\n     }\n \n+    /// Returns the first and all the rest of the elements of a slice.\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n+    #[inline]\n+    pub fn split_first(&self) -> Option<(&T, &[T])> {\n+        core_slice::SliceExt::split_first(self)\n+    }\n+\n     /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"slice_extras\",\n-               reason = \"likely to be renamed or removed\")]\n+    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed or removed\")]\n+    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_first_mut\")]\n     #[inline]\n     pub fn tail_mut(&mut self) -> &mut [T] {\n         core_slice::SliceExt::tail_mut(self)\n     }\n \n+    /// Returns the first and all the rest of the elements of a slice.\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n+    #[inline]\n+    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        core_slice::SliceExt::split_first_mut(self)\n+    }\n+\n     /// Returns all but the last element of a slice.\n     #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n+    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_last\")]\n     #[inline]\n     pub fn init(&self) -> &[T] {\n         core_slice::SliceExt::init(self)\n     }\n \n+    /// Returns the last and all the rest of the elements of a slice.\n+    #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n+    #[inline]\n+    pub fn split_last(&self) -> Option<(&T, &[T])> {\n+        core_slice::SliceExt::split_last(self)\n+\n+    }\n+\n     /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"slice_extras\",\n-               reason = \"likely to be renamed or removed\")]\n+    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed or removed\")]\n+    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_last_mut\")]\n     #[inline]\n     pub fn init_mut(&mut self) -> &mut [T] {\n         core_slice::SliceExt::init_mut(self)\n     }\n \n+    /// Returns the last and all the rest of the elements of a slice.\n+    #[unstable(feature = \"slice_splits\", since = \"1.3.0\")]\n+    #[inline]\n+    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        core_slice::SliceExt::split_last_mut(self)\n+    }\n+\n     /// Returns the last element of a slice, or `None` if it is empty.\n     ///\n     /// # Examples\n@@ -1025,6 +1056,17 @@ pub trait SliceConcatExt<T: ?Sized> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> Self::Output;\n \n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n+    /// ```\n+    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n+    fn join(&self, sep: &T) -> Self::Output;\n+\n     /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n     /// given separator between each.\n     ///\n@@ -1034,6 +1076,7 @@ pub trait SliceConcatExt<T: ?Sized> {\n     /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     fn connect(&self, sep: &T) -> Self::Output;\n }\n \n@@ -1049,7 +1092,7 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         result\n     }\n \n-    fn connect(&self, sep: &T) -> Vec<T> {\n+    fn join(&self, sep: &T) -> Vec<T> {\n         let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n@@ -1059,6 +1102,10 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         }\n         result\n     }\n+\n+    fn connect(&self, sep: &T) -> Vec<T> {\n+        self.join(sep)\n+    }\n }\n \n /// An iterator that yields the element swaps needed to produce"}, {"sha": "7c64dea3dc3381b6ce9a6361fd3aef4ba90670e2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 109, "deletions": 112, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,43 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unicode string manipulation (the `str` type).\n+//! Unicode string slices\n //!\n-//! Rust's `str` type is one of the core primitive types of the language. `&str`\n-//! is the borrowed string type. This type of string can only be created from\n-//! other strings, unless it is a `&'static str` (see below). It is not possible\n-//! to move out of borrowed strings because they are owned elsewhere.\n-//!\n-//! # Examples\n-//!\n-//! Here's some code that uses a `&str`:\n-//!\n-//! ```\n-//! let s = \"Hello, world.\";\n-//! ```\n-//!\n-//! This `&str` is a `&'static str`, which is the type of string literals.\n-//! They're `'static` because literals are available for the entire lifetime of\n-//! the program.\n-//!\n-//! You can get a non-`'static` `&str` by taking a slice of a `String`:\n-//!\n-//! ```\n-//! let some_string = \"Hello, world.\".to_string();\n-//! let s = &some_string;\n-//! ```\n-//!\n-//! # Representation\n-//!\n-//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as\n-//! a stream of UTF-8 bytes. All [strings](../../reference.html#literals) are\n-//! guaranteed to be validly encoded UTF-8 sequences. Additionally, strings are\n-//! not null-terminated and can thus contain null bytes.\n-//!\n-//! The actual representation of `str`s have direct mappings to slices: `&str`\n-//! is the same as `&[u8]`.\n+//! *[See also the `str` primitive type](../primitive.str.html).*\n+\n \n-#![doc(primitive = \"str\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Many of the usings in this module are only used in the test configuration.\n@@ -61,6 +29,7 @@ use core::result::Result;\n use core::str as core_str;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+use core::mem;\n use rustc_unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n@@ -69,6 +38,7 @@ use string::String;\n use rustc_unicode;\n use vec::Vec;\n use slice::SliceConcatExt;\n+use boxed::Box;\n \n pub use core::str::{FromStr, Utf8Error};\n pub use core::str::{Lines, LinesAny, CharRange};\n@@ -82,10 +52,6 @@ pub use core::str::{from_utf8_unchecked, ParseBoolError};\n pub use rustc_unicode::str::{SplitWhitespace, Words, Graphemes, GraphemeIndices};\n pub use core::str::pattern;\n \n-/*\n-Section: Creating a string\n-*/\n-\n impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     type Output = String;\n \n@@ -105,7 +71,7 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n         result\n     }\n \n-    fn connect(&self, sep: &str) -> String {\n+    fn join(&self, sep: &str) -> String {\n         if self.is_empty() {\n             return String::new();\n         }\n@@ -132,11 +98,11 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n         }\n         result\n     }\n-}\n \n-/*\n-Section: Iterators\n-*/\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n+    }\n+}\n \n // Helper functions used for Unicode normalization\n fn canonical_sort(comb: &mut [(char, u8)]) {\n@@ -382,10 +348,6 @@ impl<'a> Iterator for Utf16Units<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.encoder.size_hint() }\n }\n \n-/*\n-Section: Misc\n-*/\n-\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n@@ -414,15 +376,6 @@ impl ToOwned for str {\n     }\n }\n \n-/*\n-Section: CowString\n-*/\n-\n-/*\n-Section: Trait implementations\n-*/\n-\n-\n /// Any string that can be represented as a slice.\n #[lang = \"str\"]\n #[cfg(not(test))]\n@@ -483,9 +436,7 @@ impl str {\n     /// considered to be\n     /// boundaries.\n     ///\n-    /// # Panics\n-    ///\n-    /// Panics if `index` is greater than `self.len()`.\n+    /// Returns `false` if `index` is greater than `self.len()`.\n     ///\n     /// # Examples\n     ///\n@@ -549,7 +500,7 @@ impl str {\n     ///\n     /// # Unsafety\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries\n+    /// Caller must check both UTF-8 sequence boundaries and the boundaries\n     /// of the entire slice as\n     /// well.\n     ///\n@@ -567,15 +518,24 @@ impl str {\n         core_str::StrExt::slice_unchecked(self, begin, end)\n     }\n \n-    /// Returns a slice of the string from the character range [`begin`..`end`).\n+    /// Takes a bytewise mutable slice from a string.\n+    ///\n+    /// Same as `slice_unchecked`, but works with `&mut str` instead of `&str`.\n+    #[unstable(feature = \"str_slice_mut\", reason = \"recently added\")]\n+    pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        core_str::StrExt::slice_mut_unchecked(self, begin, end)\n+    }\n+\n+    /// Returns a slice of the string from the range [`begin`..`end`) where indices\n+    /// are counted in code points.\n     ///\n     /// That is, start at the `begin`-th code point of the string and continue\n     /// to the `end`-th code point. This does not detect or handle edge cases\n-    /// such as leaving a combining character as the first code point of the\n+    /// such as leaving a combining character as the first `char` of the\n     /// string.\n     ///\n     /// Due to the design of UTF-8, this operation is `O(end)`. Use slicing\n-    /// syntax if you want to use byte indices rather than codepoint indices.\n+    /// syntax if you want to use `O(1)` byte indices instead.\n     ///\n     /// # Panics\n     ///\n@@ -597,26 +557,26 @@ impl str {\n         core_str::StrExt::slice_chars(self, begin, end)\n     }\n \n-    /// Given a byte position, return the next char and its index.\n+    /// Given a byte position, return the next code point and its index.\n     ///\n-    /// This can be used to iterate over the Unicode characters of a string.\n+    /// This can be used to iterate over the Unicode code points of a string.\n     ///\n     /// # Panics\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string;\n+    /// This example manually iterates through the code points of a string;\n     /// this should normally be\n     /// done by `.chars()` or `.char_indices()`.\n     ///\n     /// ```\n     /// # #![feature(str_char, core)]\n     /// use std::str::CharRange;\n     ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let s = \"\u4e2d\u534eVie\u0323\u0302t Nam\";\n     /// let mut i = 0;\n     /// while i < s.len() {\n     ///     let CharRange {ch, next} = s.char_range_at(i);\n@@ -632,12 +592,14 @@ impl str {\n     /// 3: \u534e\n     /// 6: V\n     /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n+    /// 8: e\n+    /// 9: \u0323\n+    /// 11: \u0302\n+    /// 13: t\n+    /// 14:\n+    /// 15: N\n+    /// 16: a\n+    /// 17: m\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"often replaced by char_indices, this method may \\\n@@ -649,26 +611,29 @@ impl str {\n \n     /// Given a byte position, return the previous `char` and its position.\n     ///\n-    /// This function can be used to iterate over a Unicode string in reverse.\n+    /// This function can be used to iterate over a Unicode code points in reverse.\n+    ///\n+    /// Note that Unicode has many features, such as combining marks, ligatures,\n+    /// and direction marks, that need to be taken into account to correctly reverse a string.\n     ///\n     /// Returns 0 for next index if called on start index 0.\n     ///\n     /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n+    /// If `i` is not an index following a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string;\n+    /// This example manually iterates through the code points of a string;\n     /// this should normally be\n     /// done by `.chars().rev()` or `.char_indices()`.\n     ///\n     /// ```\n     /// # #![feature(str_char, core)]\n     /// use std::str::CharRange;\n     ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let s = \"\u4e2d\u534eVie\u0323\u0302t Nam\";\n     /// let mut i = s.len();\n     /// while i > 0 {\n     ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n@@ -680,12 +645,14 @@ impl str {\n     /// This outputs:\n     ///\n     /// ```text\n-    /// 16: m\n-    /// 15: a\n-    /// 14: N\n-    /// 13:\n-    /// 12: t\n-    /// 11: \u1ec7\n+    /// 18: m\n+    /// 17: a\n+    /// 16: N\n+    /// 15:\n+    /// 14: t\n+    /// 13: \u0302\n+    /// 11: \u0323\n+    /// 9: e\n     /// 8: i\n     /// 7: V\n     /// 6: \u534e\n@@ -704,7 +671,7 @@ impl str {\n     /// # Panics\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n@@ -713,6 +680,7 @@ impl str {\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n+    /// assert_eq!(s.char_at(4), 'c');\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"frequently replaced by the chars() iterator, this \\\n@@ -730,7 +698,7 @@ impl str {\n     /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 character.\n+    /// If `i` is not an index following a valid UTF-8 sequence.\n     ///\n     /// # Examples\n     ///\n@@ -739,6 +707,7 @@ impl str {\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n+    /// assert_eq!(s.char_at_reverse(3), '\u03c0');\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"see char_at for more details, but reverse semantics \\\n@@ -748,28 +717,30 @@ impl str {\n         core_str::StrExt::char_at_reverse(self, i)\n     }\n \n-    /// Retrieves the first character from a `&str` and returns it.\n+    /// Retrieves the first code point from a `&str` and returns it.\n+    ///\n+    /// Note that a single Unicode character (grapheme cluster)\n+    /// can be composed of multiple `char`s.\n     ///\n     /// This does not allocate a new string; instead, it returns a slice that\n-    /// points one character\n-    /// beyond the character that was shifted.\n+    /// points one code point beyond the code point that was shifted.\n     ///\n-    /// If the slice does not contain any characters, None is returned instead.\n+    /// `None` is returned if the slice is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// # #![feature(str_char)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let s = \"\u0141o\u0301dz\u0301\"; // \\u{141}o\\u{301}dz\\u{301}\n     /// let (c, s1) = s.slice_shift_char().unwrap();\n     ///\n-    /// assert_eq!(c, 'L');\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// assert_eq!(c, '\u0141');\n+    /// assert_eq!(s1, \"o\u0301dz\u0301\");\n     ///\n     /// let (c, s2) = s1.slice_shift_char().unwrap();\n     ///\n-    /// assert_eq!(c, '\u00f6');\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// assert_eq!(c, 'o');\n+    /// assert_eq!(s2, \"\\u{301}dz\\u{301}\");\n     /// ```\n     #[unstable(feature = \"str_char\",\n                reason = \"awaiting conventions about shifting and slices and \\\n@@ -782,18 +753,18 @@ impl str {\n     /// Divide one string slice into two at an index.\n     ///\n     /// The index `mid` is a byte offset from the start of the string\n-    /// that must be on a character boundary.\n+    /// that must be on a `char` boundary.\n     ///\n     /// Return slices `&self[..mid]` and `&self[mid..]`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `mid` is beyond the last character of the string,\n-    /// or if it is not on a character boundary.\n+    /// Panics if `mid` is beyond the last code point of the string,\n+    /// or if it is not on a `char` boundary.\n     ///\n     /// # Examples\n     /// ```\n-    /// # #![feature(collections)]\n+    /// # #![feature(str_split_at)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let first_space = s.find(' ').unwrap_or(s.len());\n     /// let (a, b) = s.split_at(first_space);\n@@ -802,31 +773,51 @@ impl str {\n     /// assert_eq!(b, \" \u8001\u864e L\u00e9opard\");\n     /// ```\n     #[inline]\n+    #[unstable(feature = \"str_split_at\", reason = \"recently added\")]\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         core_str::StrExt::split_at(self, mid)\n     }\n \n-    /// An iterator over the codepoints of `self`.\n+    /// Divide one mutable string slice into two at an index.\n+    #[inline]\n+    #[unstable(feature = \"str_split_at\", reason = \"recently added\")]\n+    pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        core_str::StrExt::split_at_mut(self, mid)\n+    }\n+\n+    /// An iterator over the code points of `self`.\n+    ///\n+    /// In Unicode relationship between code points and characters is complex.\n+    /// A single character may be composed of multiple code points\n+    /// (e.g. diacritical marks added to a letter), and a single code point\n+    /// (e.g. Hangul syllable) may contain multiple characters.\n+    ///\n+    /// For iteration over human-readable characters a grapheme cluster iterator\n+    /// may be more appropriate. See the [unicode-segmentation crate][1].\n+    ///\n+    /// [1]: https://crates.io/crates/unicode-segmentation\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// let v: Vec<char> = \"ASCII z\u0307o\u0301\u0142c\u0301 \ud83c\udde8\ud83c\udded \ud55c\".chars().collect();\n     ///\n-    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// assert_eq!(v, ['A', 'S', 'C', 'I', 'I', ' ',\n+    ///     'z', '\\u{307}', 'o', '\\u{301}', '\u0142', 'c', '\\u{301}', ' ',\n+    ///     '\\u{1f1e8}', '\\u{1f1ed}', ' ', '\ud55c']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn chars(&self) -> Chars {\n         core_str::StrExt::chars(self)\n     }\n \n-    /// An iterator over the characters of `self` and their byte offsets.\n+    /// An iterator over the `char`s of `self` and their byte offsets.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n-    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n+    /// let v: Vec<(usize, char)> = \"A\ud83c\udde8\ud83c\udded\".char_indices().collect();\n+    /// let b = vec![(0, 'A'), (1, '\\u{1f1e8}'), (5, '\\u{1f1ed}')];\n     ///\n     /// assert_eq!(v, b);\n     /// ```\n@@ -855,7 +846,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let some_words = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.split_whitespace().collect();\n     ///\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n@@ -873,7 +864,7 @@ impl str {\n     /// ```\n     /// # #![feature(str_words)]\n     /// # #![allow(deprecated)]\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let some_words = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n     ///\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n@@ -1859,8 +1850,6 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_casing)]\n-    ///\n     /// let s = \"HELLO\";\n     /// assert_eq!(s.to_lowercase(), \"hello\");\n     /// ```\n@@ -1905,8 +1894,6 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_casing)]\n-    ///\n     /// let s = \"hello\";\n     /// assert_eq!(s.to_uppercase(), \"HELLO\");\n     /// ```\n@@ -1930,4 +1917,14 @@ impl str {\n     pub fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n+\n+    /// Converts the `Box<str>` into a `String` without copying or allocating.\n+    #[unstable(feature = \"box_str\",\n+               reason = \"recently added, matches RFC\")]\n+    pub fn into_string(self: Box<str>) -> String {\n+        unsafe {\n+            let slice = mem::transmute::<Box<str>, Box<[u8]>>(self);\n+            String::from_utf8_unchecked(slice.into_vec())\n+        }\n+    }\n }"}, {"sha": "cc58952be600a341451a12c81af1b00b9f4379c3", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -28,7 +28,8 @@ use rustc_unicode::str::Utf16Item;\n use borrow::{Cow, IntoCow};\n use range::RangeArgument;\n use str::{self, FromStr, Utf8Error, Chars};\n-use vec::{DerefVec, Vec, as_vec};\n+use vec::Vec;\n+use boxed::Box;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n #[derive(Clone, PartialOrd, Eq, Ord)]\n@@ -317,9 +318,14 @@ impl String {\n \n     /// Creates a new `String` from a length, capacity, and pointer.\n     ///\n-    /// This is unsafe because:\n+    /// # Unsafety\n     ///\n-    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`;\n+    /// This is _very_ unsafe because:\n+    ///\n+    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`. Therefore, this\n+    ///   function inherits all of its unsafety, see [its\n+    ///   documentation](../vec/struct.Vec.html#method.from_raw_parts)\n+    ///   for the invariants it expects, they also apply to this function.\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -736,6 +742,16 @@ impl String {\n             string: self_ptr,\n         }\n     }\n+\n+    /// Converts the string into `Box<str>`.\n+    ///\n+    /// Note that this will drop any excess capacity.\n+    #[unstable(feature = \"box_str\",\n+               reason = \"recently added, matches RFC\")]\n+    pub fn into_boxed_slice(self) -> Box<str> {\n+        let slice = self.vec.into_boxed_slice();\n+        unsafe { mem::transmute::<Box<[u8]>, Box<str>>(slice) }\n+    }\n }\n \n impl FromUtf8Error {\n@@ -963,6 +979,35 @@ impl ops::Index<ops::RangeFull> for String {\n     }\n }\n \n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::Range<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n+        &mut self[..][index]\n+    }\n+}\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::RangeTo<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n+        &mut self[..][index]\n+    }\n+}\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::RangeFrom<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n+        &mut self[..][index]\n+    }\n+}\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::IndexMut<ops::RangeFull> for String {\n+    #[inline]\n+    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n+        unsafe { mem::transmute(&mut *self.vec) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {\n     type Target = str;\n@@ -973,49 +1018,14 @@ impl ops::Deref for String {\n     }\n }\n \n-/// Wrapper type providing a `&String` reference via `Deref`.\n-#[unstable(feature = \"collections\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"replaced with deref coercions or Borrow\")]\n-#[allow(deprecated)]\n-pub struct DerefString<'a> {\n-    x: DerefVec<'a, u8>\n-}\n-\n-#[allow(deprecated)]\n-impl<'a> Deref for DerefString<'a> {\n-    type Target = String;\n-\n+#[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+impl ops::DerefMut for String {\n     #[inline]\n-    fn deref<'b>(&'b self) -> &'b String {\n-        unsafe { mem::transmute(&*self.x) }\n+    fn deref_mut(&mut self) -> &mut str {\n+        unsafe { mem::transmute(&mut self.vec[..]) }\n     }\n }\n \n-/// Converts a string slice to a wrapper type providing a `&String` reference.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(collections)]\n-/// use std::string::as_string;\n-///\n-/// // Let's pretend we have a function that requires `&String`\n-/// fn string_consumer(s: &String) {\n-///     assert_eq!(s, \"foo\");\n-/// }\n-///\n-/// // Provide a `&String` from a `&str` without allocating\n-/// string_consumer(&as_string(\"foo\"));\n-/// ```\n-#[unstable(feature = \"collections\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"replaced with deref coercions or Borrow\")]\n-#[allow(deprecated)]\n-pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n-    DerefString { x: as_vec(x.as_bytes()) }\n-}\n-\n /// Error returned from `String::from`\n #[unstable(feature = \"str_parse_error\", reason = \"may want to be replaced with \\\n                                                   Void if it ever exists\")]"}, {"sha": "007de408efec733babd2b574f71fd68809dd30cb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 89, "deletions": 275, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -59,32 +59,25 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n-\n+use alloc::raw_vec::RawVec;\n use alloc::boxed::Box;\n-use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n-use core::cmp::max;\n+use alloc::heap::EMPTY;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::intrinsics::{arith_offset, assume};\n-use core::iter::{repeat, FromIterator};\n+use core::intrinsics::{arith_offset, assume, drop_in_place};\n+use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Index, IndexMut, Deref};\n use core::ops;\n use core::ptr;\n-use core::ptr::Unique;\n use core::slice;\n-use core::isize;\n-use core::usize;\n \n use borrow::{Cow, IntoCow};\n \n use super::range::RangeArgument;\n \n-// FIXME- fix places which assume the max vector allowed has memory usize::MAX.\n-const MAX_MEMORY_SIZE: usize = isize::MAX as usize;\n-\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -152,14 +145,10 @@ const MAX_MEMORY_SIZE: usize = isize::MAX as usize;\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n-    ptr: Unique<T>,\n+    buf: RawVec<T>,\n     len: usize,\n-    cap: usize,\n }\n \n-unsafe impl<T: Send> Send for Vec<T> { }\n-unsafe impl<T: Sync> Sync for Vec<T> { }\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Inherent methods\n ////////////////////////////////////////////////////////////////////////////////\n@@ -177,11 +166,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n-        // We want ptr to never be NULL so instead we set it to some arbitrary\n-        // non-null value which is fine since we never call deallocate on the ptr\n-        // if cap is 0. The reason for this is because the pointer of a slice\n-        // being NULL would break the null pointer optimization for enums.\n-        unsafe { Vec::from_raw_parts(EMPTY as *mut T, 0, 0) }\n+        Vec { buf: RawVec::new(), len: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -212,22 +197,23 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> Vec<T> {\n-        if mem::size_of::<T>() == 0 {\n-            unsafe { Vec::from_raw_parts(EMPTY as *mut T, 0, usize::MAX) }\n-        } else if capacity == 0 {\n-            Vec::new()\n-        } else {\n-            let size = capacity.checked_mul(mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n-            let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n-            if ptr.is_null() { ::alloc::oom() }\n-            unsafe { Vec::from_raw_parts(ptr as *mut T, 0, capacity) }\n-        }\n+        Vec { buf: RawVec::with_capacity(capacity), len: 0 }\n     }\n \n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n     ///\n-    /// This is highly unsafe, due to the number of invariants that aren't checked.\n+    /// # Unsafety\n+    ///\n+    /// This is highly unsafe, due to the number of invariants that aren't\n+    /// checked:\n+    ///\n+    /// * `ptr` needs to have been previously allocated via `String`/`Vec<T>`\n+    ///   (at least, it's highly likely to be incorrect if it wasn't).\n+    /// * `length` needs to be the length that less than or equal to `capacity`.\n+    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n+    ///\n+    /// Violating these may cause problems like corrupting the allocator's\n+    /// internal datastructures.\n     ///\n     /// # Examples\n     ///\n@@ -263,9 +249,8 @@ impl<T> Vec<T> {\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n                                  capacity: usize) -> Vec<T> {\n         Vec {\n-            ptr: Unique::new(ptr),\n+            buf: RawVec::from_raw_parts(ptr, capacity),\n             len: length,\n-            cap: capacity,\n         }\n     }\n \n@@ -299,7 +284,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.cap\n+        self.buf.cap()\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n@@ -319,17 +304,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        if self.cap - self.len < additional {\n-            const ERR_MSG: &'static str  = \"Vec::reserve: `isize` overflow\";\n-\n-            let new_min_cap = self.len.checked_add(additional).expect(ERR_MSG);\n-            if new_min_cap > MAX_MEMORY_SIZE { panic!(ERR_MSG) }\n-            self.grow_capacity(match new_min_cap.checked_next_power_of_two() {\n-                Some(x) if x > MAX_MEMORY_SIZE => MAX_MEMORY_SIZE,\n-                None => MAX_MEMORY_SIZE,\n-                Some(x) => x,\n-            });\n-        }\n+        self.buf.reserve(self.len, additional);\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to\n@@ -353,12 +328,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n-        if self.cap - self.len < additional {\n-            match self.len.checked_add(additional) {\n-                None => panic!(\"Vec::reserve: `usize` overflow\"),\n-                Some(new_cap) => self.grow_capacity(new_cap)\n-            }\n-        }\n+        self.buf.reserve_exact(self.len, additional);\n     }\n \n     /// Shrinks the capacity of the vector as much as possible.\n@@ -377,28 +347,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        if mem::size_of::<T>() == 0 { return }\n-\n-        if self.len == 0 {\n-            if self.cap != 0 {\n-                unsafe {\n-                    dealloc(*self.ptr, self.cap)\n-                }\n-                self.cap = 0;\n-            }\n-        } else if self.cap != self.len {\n-            unsafe {\n-                // Overflow check is unnecessary as the vector is already at\n-                // least this large.\n-                let ptr = reallocate(*self.ptr as *mut u8,\n-                                     self.cap * mem::size_of::<T>(),\n-                                     self.len * mem::size_of::<T>(),\n-                                     mem::min_align_of::<T>()) as *mut T;\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = Unique::new(ptr);\n-            }\n-            self.cap = self.len;\n-        }\n+        self.buf.shrink_to_fit(self.len);\n     }\n \n     /// Converts the vector into Box<[T]>.\n@@ -408,11 +357,11 @@ impl<T> Vec<T> {\n     /// `shrink_to_fit()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n-        self.shrink_to_fit();\n         unsafe {\n-            let xs: Box<[T]> = Box::from_raw(&mut *self);\n+            self.shrink_to_fit();\n+            let buf = ptr::read(&self.buf);\n             mem::forget(self);\n-            xs\n+            buf.into_box()\n         }\n     }\n \n@@ -529,19 +478,20 @@ impl<T> Vec<T> {\n     pub fn insert(&mut self, index: usize, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n+\n         // space for the new element\n-        self.reserve(1);\n+        if len == self.buf.cap() { self.buf.double(); }\n \n         unsafe { // infallible\n             // The spot to put the new value\n             {\n                 let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n-                ptr::copy(&*p, p.offset(1), len - index);\n+                ptr::copy(p, p.offset(1), len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n-                ptr::write(&mut *p, element);\n+                ptr::write(p, element);\n             }\n             self.set_len(len + 1);\n         }\n@@ -575,7 +525,7 @@ impl<T> Vec<T> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy(&*ptr.offset(1), ptr, len - index - 1);\n+                ptr::copy(ptr.offset(1), ptr, len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -631,38 +581,12 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, value: T) {\n-        #[cold]\n-        #[inline(never)]\n-        fn resize<T>(vec: &mut Vec<T>) {\n-            let old_size = vec.cap * mem::size_of::<T>();\n-            if old_size >= MAX_MEMORY_SIZE { panic!(\"capacity overflow\") }\n-            let mut size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n-            if old_size > size || size > MAX_MEMORY_SIZE {\n-                size = MAX_MEMORY_SIZE;\n-            }\n-            unsafe {\n-                let ptr = alloc_or_realloc(*vec.ptr, old_size, size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                vec.ptr = Unique::new(ptr);\n-            }\n-            vec.cap = max(vec.cap, 2) * 2;\n-        }\n-\n-        if mem::size_of::<T>() == 0 {\n-            // zero-size types consume no memory, so we can't rely on the\n-            // address space running out\n-            self.len = self.len.checked_add(1).expect(\"length overflow\");\n-            mem::forget(value);\n-            return\n-        }\n-\n-        if self.len == self.cap {\n-            resize(self);\n-        }\n-\n+        // This will panic or abort if we would allocate > isize::MAX bytes\n+        // or if the length increment would overflow for zero-sized types.\n+        if self.len == self.buf.cap() { self.buf.double(); }\n         unsafe {\n-            let end = (*self.ptr).offset(self.len as isize);\n-            ptr::write(&mut *end, value);\n+            let end = self.as_mut_ptr().offset(self.len as isize);\n+            ptr::write(end, value);\n             self.len += 1;\n         }\n     }\n@@ -709,13 +633,6 @@ impl<T> Vec<T> {\n     #[unstable(feature = \"append\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        if mem::size_of::<T>() == 0 {\n-            // zero-size types consume no memory, so we can't rely on the\n-            // address space running out\n-            self.len = self.len.checked_add(other.len()).expect(\"length overflow\");\n-            unsafe { other.set_len(0) }\n-            return;\n-        }\n         self.reserve(other.len());\n         let len = self.len();\n         unsafe {\n@@ -866,9 +783,9 @@ impl<T> Vec<T> {\n             // FIXME: Assert statically that the types `T` and `U` have the\n             // same minimal alignment in case they are not zero-sized.\n \n-            // These asserts are necessary because the `min_align_of` of the\n+            // These asserts are necessary because the `align_of` of the\n             // types are passed to the allocator by `Vec`.\n-            assert!(mem::min_align_of::<T>() == mem::min_align_of::<U>());\n+            assert!(mem::align_of::<T>() == mem::align_of::<U>());\n \n             // This `as isize` cast is safe, because the size of the elements of the\n             // vector is not 0, and:\n@@ -1099,12 +1016,35 @@ impl<T: Clone> Vec<T> {\n         let len = self.len();\n \n         if new_len > len {\n-            self.extend(repeat(value).take(new_len - len));\n+            self.extend_with_element(new_len - len, value);\n         } else {\n             self.truncate(new_len);\n         }\n     }\n \n+    /// Extend the vector by `n` additional clones of `value`.\n+    fn extend_with_element(&mut self, n: usize, value: T) {\n+        self.reserve(n);\n+\n+        unsafe {\n+            let len = self.len();\n+            let mut ptr = self.as_mut_ptr().offset(len as isize);\n+            // Write all elements except the last one\n+            for i in 1..n {\n+                ptr::write(ptr, value.clone());\n+                ptr = ptr.offset(1);\n+                // Increment the length in every step in case clone() panics\n+                self.set_len(len + i);\n+            }\n+\n+            if n > 0 {\n+                // We can write the last element directly without cloning needlessly\n+                ptr::write(ptr, value);\n+                self.set_len(len + n);\n+            }\n+        }\n+    }\n+\n     /// Appends all elements in a slice to the `Vec`.\n     ///\n     /// Iterates over the slice `other`, clones each element, and then appends\n@@ -1244,68 +1184,12 @@ impl<T: PartialEq> Vec<T> {\n // Internal methods and functions\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T> Vec<T> {\n-    /// Reserves capacity for exactly `capacity` elements in the given vector.\n-    ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n-    fn grow_capacity(&mut self, capacity: usize) {\n-        if mem::size_of::<T>() == 0 { return }\n-\n-        if capacity > self.cap {\n-            let size = capacity.checked_mul(mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n-            unsafe {\n-                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if ptr.is_null() { ::alloc::oom() }\n-                self.ptr = Unique::new(ptr);\n-            }\n-            self.cap = capacity;\n-        }\n-    }\n-}\n-\n-// FIXME: #13996: need a way to mark the return value as `noalias`\n-#[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: usize, size: usize) -> *mut T {\n-    if old_size == 0 {\n-        allocate(size, mem::min_align_of::<T>()) as *mut T\n-    } else {\n-        reallocate(ptr as *mut u8, old_size, size, mem::min_align_of::<T>()) as *mut T\n-    }\n-}\n-\n-#[inline]\n-unsafe fn dealloc<T>(ptr: *mut T, len: usize) {\n-    if mem::size_of::<T>() != 0 {\n-        deallocate(ptr as *mut u8,\n-                   len * mem::size_of::<T>(),\n-                   mem::min_align_of::<T>())\n-    }\n-}\n-\n #[doc(hidden)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n-    unsafe {\n-        let mut v = Vec::with_capacity(n);\n-        let mut ptr = v.as_mut_ptr();\n-\n-        // Write all elements except the last one\n-        for i in 1..n {\n-            ptr::write(ptr, Clone::clone(&elem));\n-            ptr = ptr.offset(1);\n-            v.set_len(i); // Increment the length in every step in case Clone::clone() panics\n-        }\n-\n-        if n > 0 {\n-            // We can write the last element directly without cloning needlessly\n-            ptr::write(ptr, elem);\n-            v.set_len(n);\n-        }\n-\n-        v\n-    }\n+    let mut v = Vec::with_capacity(n);\n+    v.extend_with_element(n, elem);\n+    v\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -1449,7 +1333,7 @@ impl<T> ops::Deref for Vec<T> {\n \n     fn deref(&self) -> &[T] {\n         unsafe {\n-            let p = *self.ptr;\n+            let p = self.buf.ptr();\n             assume(p != 0 as *mut T);\n             slice::from_raw_parts(p, self.len)\n         }\n@@ -1460,7 +1344,7 @@ impl<T> ops::Deref for Vec<T> {\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut(&mut self) -> &mut [T] {\n         unsafe {\n-            let ptr = *self.ptr;\n+            let ptr = self.buf.ptr();\n             assume(!ptr.is_null());\n             slice::from_raw_parts_mut(ptr, self.len)\n         }\n@@ -1482,7 +1366,7 @@ impl<T> FromIterator<T> for Vec<T> {\n             None => return Vec::new(),\n             Some(element) => {\n                 let (lower, _) = iterator.size_hint();\n-                let mut vector = Vec::with_capacity(1 + lower);\n+                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n                 unsafe {\n                     ptr::write(vector.get_unchecked_mut(0), element);\n                     vector.set_len(1);\n@@ -1514,19 +1398,19 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    fn into_iter(self) -> IntoIter<T> {\n+    fn into_iter(mut self) -> IntoIter<T> {\n         unsafe {\n-            let ptr = *self.ptr;\n+            let ptr = self.as_mut_ptr();\n             assume(!ptr.is_null());\n-            let cap = self.cap;\n             let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n                 arith_offset(ptr as *const i8, self.len() as isize) as *const T\n             } else {\n                 ptr.offset(self.len() as isize) as *const T\n             };\n+            let buf = ptr::read(&self.buf);\n             mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n+            IntoIter { buf: buf, ptr: begin, end: end }\n         }\n     }\n }\n@@ -1570,10 +1454,11 @@ impl<T> Vec<T> {\n             let len = self.len();\n             if len == self.capacity() {\n                 let (lower, _) = iterator.size_hint();\n-                self.reserve(lower + 1);\n+                self.reserve(lower.saturating_add(1));\n             }\n             unsafe {\n                 ptr::write(self.get_unchecked_mut(len), element);\n+                // NB can't overflow since we would have had to alloc the address space\n                 self.set_len(len + 1);\n             }\n         }\n@@ -1637,16 +1522,16 @@ impl<T: Ord> Ord for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n-        // This is (and should always remain) a no-op if the fields are\n-        // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n-        if self.cap != 0 && self.cap != mem::POST_DROP_USIZE {\n-            unsafe {\n-                for x in self.iter() {\n-                    ptr::read(x);\n-                }\n-                dealloc(*self.ptr, self.cap)\n+        // NOTE: this is currently abusing the fact that ZSTs can't impl Drop.\n+        // Or rather, that impl'ing Drop makes them not zero-sized. This is\n+        // OK because exactly when this stops being a valid assumption, we\n+        // don't need unsafe_no_drop_flag shenanigans anymore.\n+        if self.buf.unsafe_no_drop_flag_needs_drop() {\n+            for x in self.iter_mut() {\n+                unsafe { drop_in_place(x); }\n             }\n         }\n+        // RawVec handles deallocation\n     }\n }\n \n@@ -1730,8 +1615,7 @@ impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n /// An iterator that moves out of a vector.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    allocation: *mut T, // the block of memory allocated for the vector\n-    cap: usize, // the capacity of the vector\n+    buf: RawVec<T>,\n     ptr: *const T,\n     end: *const T\n }\n@@ -1746,9 +1630,9 @@ impl<T> IntoIter<T> {\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self.by_ref() { }\n-            let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n+            let buf = ptr::read(&self.buf);\n             mem::forget(self);\n-            Vec::from_raw_parts(allocation, 0, cap)\n+            Vec { buf: buf, len: 0 }\n         }\n     }\n }\n@@ -1826,12 +1710,9 @@ impl<T> ExactSizeIterator for IntoIter<T> {}\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n-        if self.cap != 0 {\n-            for _x in self.by_ref() {}\n-            unsafe {\n-                dealloc(self.allocation, self.cap);\n-            }\n-        }\n+        for _x in self.by_ref() {}\n+\n+        // RawVec handles deallocation\n     }\n }\n \n@@ -1905,73 +1786,6 @@ impl<'a, T> Drop for Drain<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Conversion from &[T] to &Vec<T>\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n-#[unstable(feature = \"collections\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"replaced with deref coercions or Borrow\")]\n-pub struct DerefVec<'a, T:'a> {\n-    x: Vec<T>,\n-    l: PhantomData<&'a T>,\n-}\n-\n-#[unstable(feature = \"collections\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"replaced with deref coercions or Borrow\")]\n-#[allow(deprecated)]\n-impl<'a, T> Deref for DerefVec<'a, T> {\n-    type Target = Vec<T>;\n-\n-    fn deref<'b>(&'b self) -> &'b Vec<T> {\n-        &self.x\n-    }\n-}\n-\n-// Prevent the inner `Vec<T>` from attempting to deallocate memory.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"replaced with deref coercions or Borrow\")]\n-#[allow(deprecated)]\n-impl<'a, T> Drop for DerefVec<'a, T> {\n-    fn drop(&mut self) {\n-        self.x.len = 0;\n-        self.x.cap = 0;\n-    }\n-}\n-\n-/// Converts a slice to a wrapper type providing a `&Vec<T>` reference.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(collections)]\n-/// use std::vec::as_vec;\n-///\n-/// // Let's pretend we have a function that requires `&Vec<i32>`\n-/// fn vec_consumer(s: &Vec<i32>) {\n-///     assert_eq!(s, &[1, 2, 3]);\n-/// }\n-///\n-/// // Provide a `&Vec<i32>` from a `&[i32]` without allocating\n-/// let values = [1, 2, 3];\n-/// vec_consumer(&as_vec(&values));\n-/// ```\n-#[unstable(feature = \"collections\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"replaced with deref coercions or Borrow\")]\n-#[allow(deprecated)]\n-pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n-    unsafe {\n-        DerefVec {\n-            x: Vec::from_raw_parts(x.as_ptr() as *mut T, x.len(), x.len()),\n-            l: PhantomData,\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Partial vec, used for map_in_place\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "7bdc10cfb64fa83c9a8b15b14d85197818b63a55", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 184, "deletions": 203, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -23,33 +23,35 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n-use core::mem;\n use core::ops::{Index, IndexMut};\n-use core::ptr::{self, Unique};\n+use core::ptr;\n use core::slice;\n \n use core::hash::{Hash, Hasher};\n use core::cmp;\n \n-use alloc::heap;\n+use alloc::raw_vec::RawVec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n /// `VecDeque` is a growable ring buffer, which can be used as a\n /// double-ended queue efficiently.\n+///\n+/// The \"default\" usage of this type as a queue is to use `push_back` to add to the queue, and\n+/// `pop_front` to remove from the queue. `extend` and `append` push onto the back in this manner,\n+/// and iterating over `VecDeque` goes front to back.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n     // to where data should be written.\n-    // If tail == head the buffer is empty. The length of the ringbuf\n+    // If tail == head the buffer is empty. The length of the ringbuffer\n     // is defined as the distance between the two.\n \n     tail: usize,\n     head: usize,\n-    cap: usize,\n-    ptr: Unique<T>,\n+    buf: RawVec<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -63,13 +65,7 @@ impl<T: Clone> Clone for VecDeque<T> {\n impl<T> Drop for VecDeque<T> {\n     fn drop(&mut self) {\n         self.clear();\n-        unsafe {\n-            if mem::size_of::<T>() != 0 {\n-                heap::deallocate(*self.ptr as *mut u8,\n-                                 self.cap * mem::size_of::<T>(),\n-                                 mem::min_align_of::<T>())\n-            }\n-        }\n+        // RawVec handles deallocation\n     }\n }\n \n@@ -80,78 +76,127 @@ impl<T> Default for VecDeque<T> {\n }\n \n impl<T> VecDeque<T> {\n+    /// Marginally more convenient\n+    #[inline]\n+    fn ptr(&self) -> *mut T {\n+        self.buf.ptr()\n+    }\n+\n+    /// Marginally more convenient\n+    #[inline]\n+    fn cap(&self) -> usize {\n+        self.buf.cap()\n+    }\n+\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n-        slice::from_raw_parts(*self.ptr, self.cap)\n+        slice::from_raw_parts(self.ptr(), self.cap())\n     }\n \n     /// Turn ptr into a mut slice\n     #[inline]\n     unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n-        slice::from_raw_parts_mut(*self.ptr, self.cap)\n+        slice::from_raw_parts_mut(self.ptr(), self.cap())\n     }\n \n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n-        ptr::read(self.ptr.offset(off as isize))\n+        ptr::read(self.ptr().offset(off as isize))\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n-    unsafe fn buffer_write(&mut self, off: usize, t: T) {\n-        ptr::write(self.ptr.offset(off as isize), t);\n+    unsafe fn buffer_write(&mut self, off: usize, value: T) {\n+        ptr::write(self.ptr().offset(off as isize), value);\n     }\n \n-    /// Returns true iff the buffer is at capacity\n+    /// Returns true if and only if the buffer is at capacity\n     #[inline]\n-    fn is_full(&self) -> bool { self.cap - self.len() == 1 }\n+    fn is_full(&self) -> bool { self.cap() - self.len() == 1 }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index.\n     #[inline]\n-    fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap) }\n+    fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap()) }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index + addend.\n     #[inline]\n     fn wrap_add(&self, idx: usize, addend: usize) -> usize {\n-        wrap_index(idx.wrapping_add(addend), self.cap)\n+        wrap_index(idx.wrapping_add(addend), self.cap())\n     }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index - subtrahend.\n     #[inline]\n     fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {\n-        wrap_index(idx.wrapping_sub(subtrahend), self.cap)\n+        wrap_index(idx.wrapping_sub(subtrahend), self.cap())\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                      self.cap);\n-        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                      self.cap);\n+        debug_assert!(dst + len <= self.cap(), \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap());\n+        debug_assert!(src + len <= self.cap(), \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap());\n         ptr::copy(\n-            self.ptr.offset(src as isize),\n-            self.ptr.offset(dst as isize),\n+            self.ptr().offset(src as isize),\n+            self.ptr().offset(dst as isize),\n             len);\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                      self.cap);\n-        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                      self.cap);\n+        debug_assert!(dst + len <= self.cap(), \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap());\n+        debug_assert!(src + len <= self.cap(), \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap());\n         ptr::copy_nonoverlapping(\n-            self.ptr.offset(src as isize),\n-            self.ptr.offset(dst as isize),\n+            self.ptr().offset(src as isize),\n+            self.ptr().offset(dst as isize),\n             len);\n     }\n+\n+    /// Frobs the head and tail sections around to handle the fact that we\n+    /// just reallocated. Unsafe because it trusts old_cap.\n+    #[inline]\n+    unsafe fn handle_cap_increase(&mut self, old_cap: usize) {\n+        let new_cap = self.cap();\n+\n+        // Move the shortest contiguous section of the ring buffer\n+        //    T             H\n+        //   [o o o o o o o . ]\n+        //    T             H\n+        // A [o o o o o o o . . . . . . . . . ]\n+        //        H T\n+        //   [o o . o o o o o ]\n+        //          T             H\n+        // B [. . . o o o o o o o . . . . . . ]\n+        //              H T\n+        //   [o o o o o . o o ]\n+        //              H                 T\n+        // C [o o o o o . . . . . . . . . o o ]\n+\n+        if self.tail <= self.head { // A\n+            // Nop\n+        } else if self.head < old_cap - self.tail { // B\n+            self.copy_nonoverlapping(old_cap, 0, self.head);\n+            self.head += old_cap;\n+            debug_assert!(self.head > self.tail);\n+        } else { // C\n+            let new_tail = new_cap - (old_cap - self.tail);\n+            self.copy_nonoverlapping(new_tail, self.tail, old_cap - self.tail);\n+            self.tail = new_tail;\n+            debug_assert!(self.head < self.tail);\n+        }\n+        debug_assert!(self.head < self.cap());\n+        debug_assert!(self.tail < self.cap());\n+        debug_assert!(self.cap().count_ones() == 1);\n+    }\n }\n \n impl<T> VecDeque<T> {\n@@ -167,24 +212,11 @@ impl<T> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > n, \"capacity overflow\");\n-        let size = cap.checked_mul(mem::size_of::<T>())\n-                      .expect(\"capacity overflow\");\n-\n-        let ptr = unsafe {\n-            if mem::size_of::<T>() != 0 {\n-                let ptr = heap::allocate(size, mem::min_align_of::<T>())  as *mut T;;\n-                if ptr.is_null() { ::alloc::oom() }\n-                Unique::new(ptr)\n-            } else {\n-                Unique::new(heap::EMPTY as *mut T)\n-            }\n-        };\n \n         VecDeque {\n             tail: 0,\n             head: 0,\n-            cap: cap,\n-            ptr: ptr,\n+            buf: RawVec::with_capacity(cap),\n         }\n     }\n \n@@ -202,10 +234,10 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: usize) -> Option<&T> {\n-        if i < self.len() {\n-            let idx = self.wrap_add(self.tail, i);\n-            unsafe { Some(&*self.ptr.offset(idx as isize)) }\n+    pub fn get(&self, index: usize) -> Option<&T> {\n+        if index < self.len() {\n+            let idx = self.wrap_add(self.tail, index);\n+            unsafe { Some(&*self.ptr().offset(idx as isize)) }\n         } else {\n             None\n         }\n@@ -229,10 +261,10 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf[1], 7);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {\n-        if i < self.len() {\n-            let idx = self.wrap_add(self.tail, i);\n-            unsafe { Some(&mut *self.ptr.offset(idx as isize)) }\n+    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n+        if index < self.len() {\n+            let idx = self.wrap_add(self.tail, index);\n+            unsafe { Some(&mut *self.ptr().offset(idx as isize)) }\n         } else {\n             None\n         }\n@@ -264,7 +296,7 @@ impl<T> VecDeque<T> {\n         let ri = self.wrap_add(self.tail, i);\n         let rj = self.wrap_add(self.tail, j);\n         unsafe {\n-            ptr::swap(self.ptr.offset(ri as isize), self.ptr.offset(rj as isize))\n+            ptr::swap(self.ptr().offset(ri as isize), self.ptr().offset(rj as isize))\n         }\n     }\n \n@@ -281,7 +313,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize { self.cap - 1 }\n+    pub fn capacity(&self) -> usize { self.cap() - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n@@ -309,7 +341,7 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Ringbuf`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `VecDeque`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -326,69 +358,23 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        let new_len = self.len() + additional;\n-        assert!(new_len + 1 > self.len(), \"capacity overflow\");\n-        if new_len > self.capacity() {\n-            let count = (new_len + 1).next_power_of_two();\n-            assert!(count >= new_len + 1);\n-\n-            if mem::size_of::<T>() != 0 {\n-                let old = self.cap * mem::size_of::<T>();\n-                let new = count.checked_mul(mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n-                unsafe {\n-                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n-                                               old,\n-                                               new,\n-                                               mem::min_align_of::<T>()) as *mut T;\n-                    if ptr.is_null() { ::alloc::oom() }\n-                    self.ptr = Unique::new(ptr);\n-                }\n-            }\n-\n-            // Move the shortest contiguous section of the ring buffer\n-            //    T             H\n-            //   [o o o o o o o . ]\n-            //    T             H\n-            // A [o o o o o o o . . . . . . . . . ]\n-            //        H T\n-            //   [o o . o o o o o ]\n-            //          T             H\n-            // B [. . . o o o o o o o . . . . . . ]\n-            //              H T\n-            //   [o o o o o . o o ]\n-            //              H                 T\n-            // C [o o o o o . . . . . . . . . o o ]\n-\n-            let oldcap = self.cap;\n-            self.cap = count;\n-\n-            if self.tail <= self.head { // A\n-                // Nop\n-            } else if self.head < oldcap - self.tail { // B\n-                unsafe {\n-                    self.copy_nonoverlapping(oldcap, 0, self.head);\n-                }\n-                self.head += oldcap;\n-                debug_assert!(self.head > self.tail);\n-            } else { // C\n-                let new_tail = count - (oldcap - self.tail);\n-                unsafe {\n-                    self.copy_nonoverlapping(new_tail, self.tail, oldcap - self.tail);\n-                }\n-                self.tail = new_tail;\n-                debug_assert!(self.head < self.tail);\n-            }\n-            debug_assert!(self.head < self.cap);\n-            debug_assert!(self.tail < self.cap);\n-            debug_assert!(self.cap.count_ones() == 1);\n+        let old_cap = self.cap();\n+        let used_cap = self.len() + 1;\n+        let new_cap = used_cap\n+            .checked_add(additional)\n+            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+            .expect(\"capacity overflow\");\n+\n+        if new_cap > self.capacity() {\n+            self.buf.reserve_exact(used_cap, new_cap - used_cap);\n+            unsafe { self.handle_cap_increase(old_cap); }\n         }\n     }\n \n-    /// Shrinks the capacity of the ringbuf as much as possible.\n+    /// Shrinks the capacity of the `VecDeque` as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator may still inform the\n-    /// ringbuf that there is space for a few more elements.\n+    /// `VecDeque` that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n@@ -404,9 +390,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     pub fn shrink_to_fit(&mut self) {\n         // +1 since the ringbuffer always leaves one space empty\n-        // len + 1 can't overflow for an existing, well-formed ringbuf.\n+        // len + 1 can't overflow for an existing, well-formed ringbuffer.\n         let target_cap = cmp::max(self.len() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n-        if target_cap < self.cap {\n+        if target_cap < self.cap() {\n             // There are three cases of interest:\n             //   All elements are out of desired bounds\n             //   Elements are contiguous, and head is out of desired bounds\n@@ -444,7 +430,7 @@ impl<T> VecDeque<T> {\n                 //              H T\n                 //   [o o o o o . o o ]\n                 debug_assert!(self.wrap_sub(self.head, 1) < target_cap);\n-                let len = self.cap - self.tail;\n+                let len = self.cap() - self.tail;\n                 let new_tail = target_cap - len;\n                 unsafe {\n                     self.copy_nonoverlapping(new_tail, self.tail, len);\n@@ -453,28 +439,17 @@ impl<T> VecDeque<T> {\n                 debug_assert!(self.head < self.tail);\n             }\n \n-            if mem::size_of::<T>() != 0 {\n-                let old = self.cap * mem::size_of::<T>();\n-                let new_size = target_cap * mem::size_of::<T>();\n-                unsafe {\n-                    let ptr = heap::reallocate(*self.ptr as *mut u8,\n-                                               old,\n-                                               new_size,\n-                                               mem::min_align_of::<T>()) as *mut T;\n-                    if ptr.is_null() { ::alloc::oom() }\n-                    self.ptr = Unique::new(ptr);\n-                }\n-            }\n-            self.cap = target_cap;\n-            debug_assert!(self.head < self.cap);\n-            debug_assert!(self.tail < self.cap);\n-            debug_assert!(self.cap.count_ones() == 1);\n+            self.buf.shrink_to_fit(target_cap);\n+\n+            debug_assert!(self.head < self.cap());\n+            debug_assert!(self.tail < self.cap());\n+            debug_assert!(self.cap().count_ones() == 1);\n         }\n     }\n \n-    /// Shortens a ringbuf, dropping excess elements from the back.\n+    /// Shortens a `VecDeque`, dropping excess elements from the back.\n     ///\n-    /// If `len` is greater than the ringbuf's current length, this has no\n+    /// If `len` is greater than the `VecDeque`'s current length, this has no\n     /// effect.\n     ///\n     /// # Examples\n@@ -606,7 +581,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { count(self.tail, self.head, self.cap) }\n+    pub fn len(&self) -> usize { count(self.tail, self.head, self.cap()) }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -793,15 +768,17 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(d.front(), Some(&2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push_front(&mut self, t: T) {\n+    pub fn push_front(&mut self, value: T) {\n         if self.is_full() {\n-            self.reserve(1);\n+            let old_cap = self.cap();\n+            self.buf.double();\n+            unsafe { self.handle_cap_increase(old_cap); }\n             debug_assert!(!self.is_full());\n         }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n-        unsafe { self.buffer_write(tail, t); }\n+        unsafe { self.buffer_write(tail, value); }\n     }\n \n     /// Appends an element to the back of a buffer\n@@ -817,15 +794,17 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push_back(&mut self, t: T) {\n+    pub fn push_back(&mut self, value: T) {\n         if self.is_full() {\n-            self.reserve(1);\n+            let old_cap = self.cap();\n+            self.buf.double();\n+            unsafe { self.handle_cap_increase(old_cap); }\n             debug_assert!(!self.is_full());\n         }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n-        unsafe { self.buffer_write(head, t) }\n+        unsafe { self.buffer_write(head, value) }\n     }\n \n     /// Removes the last element from a buffer and returns it, or `None` if\n@@ -858,8 +837,8 @@ impl<T> VecDeque<T> {\n         self.tail <= self.head\n     }\n \n-    /// Removes an element from anywhere in the ringbuf and returns it, replacing it with the last\n-    /// element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n+    /// last element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -892,7 +871,7 @@ impl<T> VecDeque<T> {\n         self.pop_back()\n     }\n \n-    /// Removes an element from anywhere in the ringbuf and returns it,\n+    /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n@@ -926,13 +905,13 @@ impl<T> VecDeque<T> {\n         self.pop_front()\n     }\n \n-    /// Inserts an element at position `i` within the ringbuf. Whichever\n+    /// Inserts an element at `index` within the `VecDeque`. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `i` is greater than ringbuf's length\n+    /// Panics if `index` is greater than `VecDeque`'s length\n     ///\n     /// # Examples\n     /// ```\n@@ -942,13 +921,15 @@ impl<T> VecDeque<T> {\n     /// let mut buf = VecDeque::new();\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n-    /// buf.insert(1,11);\n+    /// buf.insert(1, 11);\n     /// assert_eq!(Some(&11), buf.get(1));\n     /// ```\n-    pub fn insert(&mut self, i: usize, t: T) {\n-        assert!(i <= self.len(), \"index out of bounds\");\n+    pub fn insert(&mut self, index: usize, value: T) {\n+        assert!(index <= self.len(), \"index out of bounds\");\n         if self.is_full() {\n-            self.reserve(1);\n+            let old_cap = self.cap();\n+            self.buf.double();\n+            unsafe { self.handle_cap_increase(old_cap); }\n             debug_assert!(!self.is_full());\n         }\n \n@@ -974,15 +955,15 @@ impl<T> VecDeque<T> {\n         //      A - The element that should be after the insertion point\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_add(self.tail, i);\n+        let idx = self.wrap_add(self.tail, index);\n \n-        let distance_to_tail = i;\n-        let distance_to_head = self.len() - i;\n+        let distance_to_tail = index;\n+        let distance_to_head = self.len() - index;\n \n         let contiguous = self.is_contiguous();\n \n         match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) if i == 0 => {\n+            (true, true, _) if index == 0 => {\n                 // push_front\n                 //\n                 //       T\n@@ -1018,8 +999,8 @@ impl<T> VecDeque<T> {\n                 let new_tail = self.wrap_sub(self.tail, 1);\n \n                 self.copy(new_tail, self.tail, 1);\n-                // Already moved the tail, so we only copy `i - 1` elements.\n-                self.copy(self.tail, self.tail + 1, i - 1);\n+                // Already moved the tail, so we only copy `index - 1` elements.\n+                self.copy(self.tail, self.tail + 1, index - 1);\n \n                 self.tail = new_tail;\n             },\n@@ -1046,7 +1027,7 @@ impl<T> VecDeque<T> {\n                 //      [o o o o o o . . . . o o I A o o]\n                 //                           M M\n \n-                self.copy(self.tail - 1, self.tail, i);\n+                self.copy(self.tail - 1, self.tail, index);\n                 self.tail -= 1;\n             },\n             (false, false, true) => unsafe {\n@@ -1063,10 +1044,10 @@ impl<T> VecDeque<T> {\n                 self.copy(1, 0, self.head);\n \n                 // copy last element into empty spot at bottom of buffer\n-                self.copy(0, self.cap - 1, 1);\n+                self.copy(0, self.cap() - 1, 1);\n \n                 // move elements from idx to end forward not including ^ element\n-                self.copy(idx + 1, idx, self.cap - 1 - idx);\n+                self.copy(idx + 1, idx, self.cap() - 1 - idx);\n \n                 self.head += 1;\n             },\n@@ -1082,10 +1063,10 @@ impl<T> VecDeque<T> {\n                 //                               M M M\n \n                 // copy elements up to new tail\n-                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n+                self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n \n                 // copy last element into empty spot at bottom of buffer\n-                self.copy(self.cap - 1, 0, 1);\n+                self.copy(self.cap() - 1, 0, 1);\n \n                 self.tail -= 1;\n             },\n@@ -1100,10 +1081,10 @@ impl<T> VecDeque<T> {\n                 //       M M                     M M M M\n \n                 // copy elements up to new tail\n-                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n+                self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n \n                 // copy last element into empty spot at bottom of buffer\n-                self.copy(self.cap - 1, 0, 1);\n+                self.copy(self.cap() - 1, 0, 1);\n \n                 // move elements from idx-1 to end forward not including ^ element\n                 self.copy(0, 1, idx - 1);\n@@ -1126,16 +1107,16 @@ impl<T> VecDeque<T> {\n         }\n \n         // tail might've been changed so we need to recalculate\n-        let new_idx = self.wrap_add(self.tail, i);\n+        let new_idx = self.wrap_add(self.tail, index);\n         unsafe {\n-            self.buffer_write(new_idx, t);\n+            self.buffer_write(new_idx, value);\n         }\n     }\n \n-    /// Removes and returns the element at position `i` from the ringbuf.\n+    /// Removes and returns the element at `index` from the `VecDeque`.\n     /// Whichever end is closer to the removal point will be moved to make\n     /// room, and all the affected elements will be moved to new positions.\n-    /// Returns `None` if `i` is out of bounds.\n+    /// Returns `None` if `index` is out of bounds.\n     ///\n     /// # Examples\n     /// ```\n@@ -1150,8 +1131,8 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, i: usize) -> Option<T> {\n-        if self.is_empty() || self.len() <= i {\n+    pub fn remove(&mut self, index: usize) -> Option<T> {\n+        if self.is_empty() || self.len() <= index {\n             return None;\n         }\n \n@@ -1173,14 +1154,14 @@ impl<T> VecDeque<T> {\n         //      R - Indicates element that is being removed\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_add(self.tail, i);\n+        let idx = self.wrap_add(self.tail, index);\n \n         let elem = unsafe {\n             Some(self.buffer_read(idx))\n         };\n \n-        let distance_to_tail = i;\n-        let distance_to_head = self.len() - i;\n+        let distance_to_tail = index;\n+        let distance_to_head = self.len() - index;\n \n         let contiguous = self.is_contiguous();\n \n@@ -1195,7 +1176,7 @@ impl<T> VecDeque<T> {\n                 //      [. . . . o o o o o o . . . . . .]\n                 //               M M\n \n-                self.copy(self.tail + 1, self.tail, i);\n+                self.copy(self.tail + 1, self.tail, index);\n                 self.tail += 1;\n             },\n             (true, false, _) => unsafe {\n@@ -1221,7 +1202,7 @@ impl<T> VecDeque<T> {\n                 //      [o o o o o o . . . . . . o o o o]\n                 //                               M M\n \n-                self.copy(self.tail + 1, self.tail, i);\n+                self.copy(self.tail + 1, self.tail, index);\n                 self.tail = self.wrap_add(self.tail, 1);\n             },\n             (false, false, false) => unsafe {\n@@ -1257,12 +1238,12 @@ impl<T> VecDeque<T> {\n                 //                                   M\n \n                 // draw in elements in the tail section\n-                self.copy(idx, idx + 1, self.cap - idx - 1);\n+                self.copy(idx, idx + 1, self.cap() - idx - 1);\n \n                 // Prevents underflow.\n                 if self.head != 0 {\n                     // copy first element into empty spot\n-                    self.copy(self.cap - 1, 0, 1);\n+                    self.copy(self.cap() - 1, 0, 1);\n \n                     // move elements in the head section backwards\n                     self.copy(0, 1, self.head - 1);\n@@ -1284,10 +1265,10 @@ impl<T> VecDeque<T> {\n                 self.copy(1, 0, idx);\n \n                 // copy last element into empty spot\n-                self.copy(0, self.cap - 1, 1);\n+                self.copy(0, self.cap() - 1, 1);\n \n                 // move elements from tail to end forward, excluding the last one\n-                self.copy(self.tail + 1, self.tail, self.cap - self.tail - 1);\n+                self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n \n                 self.tail = self.wrap_add(self.tail, 1);\n             }\n@@ -1339,20 +1320,20 @@ impl<T> VecDeque<T> {\n                 let amount_in_first = first_len - at;\n \n                 ptr::copy_nonoverlapping(first_half.as_ptr().offset(at as isize),\n-                                         *other.ptr,\n+                                         other.ptr(),\n                                          amount_in_first);\n \n                 // just take all of the second half.\n                 ptr::copy_nonoverlapping(second_half.as_ptr(),\n-                                         other.ptr.offset(amount_in_first as isize),\n+                                         other.ptr().offset(amount_in_first as isize),\n                                          second_len);\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n                 ptr::copy_nonoverlapping(second_half.as_ptr().offset(offset as isize),\n-                                         *other.ptr,\n+                                         other.ptr(),\n                                          amount_in_second);\n             }\n         }\n@@ -1428,7 +1409,7 @@ impl<T> VecDeque<T> {\n }\n \n impl<T: Clone> VecDeque<T> {\n-    /// Modifies the ringbuf in-place so that `len()` is equal to new_len,\n+    /// Modifies the `VecDeque` in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements or by appending copies of a value to the back.\n     ///\n     /// # Examples\n@@ -1719,16 +1700,16 @@ impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n     #[inline]\n-    fn index(&self, i: usize) -> &A {\n-        self.get(i).expect(\"Out of bounds access\")\n+    fn index(&self, index: usize) -> &A {\n+        self.get(index).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n     #[inline]\n-    fn index_mut(&mut self, i: usize) -> &mut A {\n-        self.get_mut(i).expect(\"Out of bounds access\")\n+    fn index_mut(&mut self, index: usize) -> &mut A {\n+        self.get_mut(index).expect(\"Out of bounds access\")\n     }\n }\n \n@@ -1900,8 +1881,8 @@ mod tests {\n                             assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n                         }\n                     }\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n                     assert_eq!(tester, expected);\n                 }\n             }\n@@ -1936,8 +1917,8 @@ mod tests {\n                         }\n                     }\n                     tester.insert(to_insert, to_insert);\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n                     assert_eq!(tester, expected);\n                 }\n             }\n@@ -1973,8 +1954,8 @@ mod tests {\n                         tester.push_back(1234);\n                     }\n                     tester.remove(to_remove);\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n                     assert_eq!(tester, expected);\n                 }\n             }\n@@ -2006,8 +1987,8 @@ mod tests {\n                 }\n                 tester.shrink_to_fit();\n                 assert!(tester.capacity() <= cap);\n-                assert!(tester.tail < tester.cap);\n-                assert!(tester.head < tester.cap);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -2040,10 +2021,10 @@ mod tests {\n                         tester.push_back(i);\n                     }\n                     let result = tester.split_off(at);\n-                    assert!(tester.tail < tester.cap);\n-                    assert!(tester.head < tester.cap);\n-                    assert!(result.tail < result.cap);\n-                    assert!(result.head < result.cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n+                    assert!(result.tail < result.cap());\n+                    assert!(result.head < result.cap());\n                     assert_eq!(tester, expected_self);\n                     assert_eq!(result, expected_other);\n                 }"}, {"sha": "d161dc7a287f93846c1d74a80023b11b5c218ca8", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(ascii)]\n #![feature(append)]\n-#![feature(bit_vec_append_split_off)]\n #![feature(bitset)]\n #![feature(bitvec)]\n #![feature(box_syntax)]\n@@ -37,24 +37,27 @@\n #![feature(rustc_private)]\n #![feature(slice_bytes)]\n #![feature(slice_chars)]\n-#![feature(slice_extras)]\n+#![feature(slice_splits)]\n #![feature(slice_position_elem)]\n #![feature(split_off)]\n #![feature(step_by)]\n #![feature(str_char)]\n #![feature(str_escape)]\n #![feature(str_match_indices)]\n+#![feature(str_split_at)]\n #![feature(str_utf16)]\n+#![feature(box_str)]\n #![feature(subslice_offset)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(vec_deque_retain)]\n #![feature(vec_from_raw_buf)]\n #![feature(vec_push_all)]\n-#![feature(vec_split_off)]\n #![feature(vecmap)]\n \n+#![allow(deprecated)]\n+\n #[macro_use] extern crate log;\n \n extern crate collections;"}, {"sha": "c0ab11380d9f6228d24c480599ddd7621280f261", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 31, "deletions": 54, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -119,71 +119,48 @@ fn test_first_mut() {\n }\n \n #[test]\n-fn test_tail() {\n+fn test_split_first() {\n     let mut a = vec![11];\n     let b: &[i32] = &[];\n-    assert_eq!(a.tail(), b);\n+    assert!(b.split_first().is_none());\n+    assert_eq!(a.split_first(), Some((&11, b)));\n     a = vec![11, 12];\n     let b: &[i32] = &[12];\n-    assert_eq!(a.tail(), b);\n+    assert_eq!(a.split_first(), Some((&11, b)));\n }\n \n #[test]\n-fn test_tail_mut() {\n+fn test_split_first_mut() {\n     let mut a = vec![11];\n     let b: &mut [i32] = &mut [];\n-    assert!(a.tail_mut() == b);\n+    assert!(b.split_first_mut().is_none());\n+    assert!(a.split_first_mut() == Some((&mut 11, b)));\n     a = vec![11, 12];\n     let b: &mut [_] = &mut [12];\n-    assert!(a.tail_mut() == b);\n+    assert!(a.split_first_mut() == Some((&mut 11, b)));\n }\n \n #[test]\n-#[should_panic]\n-fn test_tail_empty() {\n-    let a = Vec::<i32>::new();\n-    a.tail();\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_tail_mut_empty() {\n-    let mut a = Vec::<i32>::new();\n-    a.tail_mut();\n-}\n-\n-#[test]\n-fn test_init() {\n+fn test_split_last() {\n     let mut a = vec![11];\n     let b: &[i32] = &[];\n-    assert_eq!(a.init(), b);\n+    assert!(b.split_last().is_none());\n+    assert_eq!(a.split_last(), Some((&11, b)));\n     a = vec![11, 12];\n     let b: &[_] = &[11];\n-    assert_eq!(a.init(), b);\n+    assert_eq!(a.split_last(), Some((&12, b)));\n }\n \n #[test]\n-fn test_init_mut() {\n+fn test_split_last_mut() {\n     let mut a = vec![11];\n     let b: &mut [i32] = &mut [];\n-    assert!(a.init_mut() == b);\n+    assert!(b.split_last_mut().is_none());\n+    assert!(a.split_last_mut() == Some((&mut 11, b)));\n+\n     a = vec![11, 12];\n     let b: &mut [_] = &mut [11];\n-    assert!(a.init_mut() == b);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_init_empty() {\n-    let a = Vec::<i32>::new();\n-    a.init();\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_init_mut_empty() {\n-    let mut a = Vec::<i32>::new();\n-    a.init_mut();\n+    assert!(a.split_last_mut() == Some((&mut 12, b)));\n }\n \n #[test]\n@@ -606,22 +583,22 @@ fn test_concat() {\n     assert_eq!(d, [1, 2, 3]);\n \n     let v: &[&[_]] = &[&[1], &[2, 3]];\n-    assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n+    assert_eq!(v.join(&0), [1, 0, 2, 3]);\n     let v: &[&[_]] = &[&[1], &[2], &[3]];\n-    assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n+    assert_eq!(v.join(&0), [1, 0, 2, 0, 3]);\n }\n \n #[test]\n-fn test_connect() {\n+fn test_join() {\n     let v: [Vec<i32>; 0] = [];\n-    assert_eq!(v.connect(&0), []);\n-    assert_eq!([vec![1], vec![2, 3]].connect(&0), [1, 0, 2, 3]);\n-    assert_eq!([vec![1], vec![2], vec![3]].connect(&0), [1, 0, 2, 0, 3]);\n+    assert_eq!(v.join(&0), []);\n+    assert_eq!([vec![1], vec![2, 3]].join(&0), [1, 0, 2, 3]);\n+    assert_eq!([vec![1], vec![2], vec![3]].join(&0), [1, 0, 2, 0, 3]);\n \n     let v: [&[_]; 2] = [&[1], &[2, 3]];\n-    assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n+    assert_eq!(v.join(&0), [1, 0, 2, 3]);\n     let v: [&[_]; 3] = [&[1], &[2], &[3]];\n-    assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n+    assert_eq!(v.join(&0), [1, 0, 2, 0, 3]);\n }\n \n #[test]\n@@ -1318,7 +1295,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v: Vec<_> = repeat(0).take(100).collect();\n+        let mut v = vec![0; 100];\n \n         b.iter(|| {\n             let mut i = 0;\n@@ -1339,11 +1316,11 @@ mod bench {\n     }\n \n     #[bench]\n-    fn connect(b: &mut Bencher) {\n+    fn join(b: &mut Bencher) {\n         let xss: Vec<Vec<i32>> =\n             (0..100).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n-            xss.connect(&0)\n+            xss.join(&0)\n         });\n     }\n \n@@ -1419,7 +1396,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_from_elem(b: &mut Bencher) {\n         b.iter(|| {\n-            repeat(0u8).take(1024).collect::<Vec<_>>()\n+            vec![0u8; 1024]\n         });\n     }\n \n@@ -1467,7 +1444,7 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = thread_rng();\n         b.iter(|| {\n-            let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n+            let mut v = vec![(0, 0); 30];\n             for _ in 0..100 {\n                 let l = v.len();\n                 v.insert(rng.gen::<usize>() % (l + 1),\n@@ -1479,7 +1456,7 @@ mod bench {\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = thread_rng();\n         b.iter(|| {\n-            let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n+            let mut v = vec![(0, 0); 130];\n             for _ in 0..100 {\n                 let l = v.len();\n                 v.remove(rng.gen::<usize>() % l);"}, {"sha": "5419c43ba096b7c1c8fa003411199856bf07f993", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -158,32 +158,32 @@ fn test_concat_for_different_lengths() {\n     test_concat!(\"abc\", [\"\", \"a\", \"bc\"]);\n }\n \n-macro_rules! test_connect {\n+macro_rules! test_join {\n     ($expected: expr, $string: expr, $delim: expr) => {\n         {\n-            let s = $string.connect($delim);\n+            let s = $string.join($delim);\n             assert_eq!($expected, s);\n         }\n     }\n }\n \n #[test]\n-fn test_connect_for_different_types() {\n-    test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n+fn test_join_for_different_types() {\n+    test_join!(\"a-b\", [\"a\", \"b\"], \"-\");\n     let hyphen = \"-\".to_string();\n-    test_connect!(\"a-b\", [s(\"a\"), s(\"b\")], &*hyphen);\n-    test_connect!(\"a-b\", vec![\"a\", \"b\"], &*hyphen);\n-    test_connect!(\"a-b\", &*vec![\"a\", \"b\"], \"-\");\n-    test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n+    test_join!(\"a-b\", [s(\"a\"), s(\"b\")], &*hyphen);\n+    test_join!(\"a-b\", vec![\"a\", \"b\"], &*hyphen);\n+    test_join!(\"a-b\", &*vec![\"a\", \"b\"], \"-\");\n+    test_join!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n }\n \n #[test]\n-fn test_connect_for_different_lengths() {\n+fn test_join_for_different_lengths() {\n     let empty: &[&str] = &[];\n-    test_connect!(\"\", empty, \"-\");\n-    test_connect!(\"a\", [\"a\"], \"-\");\n-    test_connect!(\"a-b\", [\"a\", \"b\"], \"-\");\n-    test_connect!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n+    test_join!(\"\", empty, \"-\");\n+    test_join!(\"a\", [\"a\"], \"-\");\n+    test_join!(\"a-b\", [\"a\", \"b\"], \"-\");\n+    test_join!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n }\n \n #[test]\n@@ -701,11 +701,23 @@ fn test_split_at() {\n     assert_eq!(b, \"\");\n }\n \n+#[test]\n+fn test_split_at_mut() {\n+    use std::ascii::AsciiExt;\n+    let mut s = \"Hello World\".to_string();\n+    {\n+        let (a, b) = s.split_at_mut(5);\n+        a.make_ascii_uppercase();\n+        b.make_ascii_lowercase();\n+    }\n+    assert_eq!(s, \"HELLO world\");\n+}\n+\n #[test]\n #[should_panic]\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    let (a, b) = s.split_at(1);\n+    s.split_at(1);\n }\n \n #[test]\n@@ -1746,6 +1758,14 @@ fn to_uppercase() {\n     assert_eq!(\"a\u00e9\u01c5\u00df\ufb01\u1f80\".to_uppercase(), \"A\u00c9\u01c4SSFI\u1f08\u0399\");\n }\n \n+#[test]\n+fn test_into_string() {\n+    // The only way to acquire a Box<str> in the first place is through a String, so just\n+    // test that we can round-trip between Box<str> and String.\n+    let string = String::from(\"Some text goes here\");\n+    assert_eq!(string.clone().into_boxed_slice().into_string(), string);\n+}\n+\n mod pattern {\n     use std::str::pattern::Pattern;\n     use std::str::pattern::{Searcher, ReverseSearcher};\n@@ -1820,6 +1840,14 @@ mod pattern {\n         Match (4, 6),\n         Reject(6, 7),\n     ]);\n+    make_test!(str_searcher_ascii_haystack_seq, \"bb\", \"abbcbbbbd\", [\n+        Reject(0, 1),\n+        Match (1, 3),\n+        Reject(3, 4),\n+        Match (4, 6),\n+        Match (6, 8),\n+        Reject(8, 9),\n+    ]);\n     make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n         Match (0, 0),\n         Reject(0, 1),\n@@ -2073,12 +2101,12 @@ mod bench {\n     }\n \n     #[bench]\n-    fn bench_connect(b: &mut Bencher) {\n+    fn bench_join(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let sep = \"\u2192\";\n         let v = vec![s, s, s, s, s, s, s, s, s, s];\n         b.iter(|| {\n-            assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n+            assert_eq!(v.join(sep).len(), s.len() * 10 + sep.len() * 9);\n         })\n     }\n "}, {"sha": "80283741cccdf5d44d7481a52d2996c82eb91caa", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,18 +10,9 @@\n \n use std::borrow::{IntoCow, Cow};\n use std::iter::repeat;\n-#[allow(deprecated)]\n-use std::string::as_string;\n \n use test::Bencher;\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_as_string() {\n-    let x = \"foo\";\n-    assert_eq!(x, &**as_string(x));\n-}\n-\n #[test]\n fn test_from_str() {\n   let owned: Option<::std::string::String> = \"string\".parse().ok();\n@@ -374,6 +365,13 @@ fn test_extend_ref() {\n     assert_eq!(&a, \"foobar\");\n }\n \n+#[test]\n+fn test_into_boxed_slice() {\n+    let xs = String::from(\"hello my name is bob\");\n+    let ys = xs.into_boxed_slice();\n+    assert_eq!(&*ys, \"hello my name is bob\");\n+}\n+\n #[bench]\n fn bench_with_capacity(b: &mut Bencher) {\n     b.iter(|| {"}, {"sha": "7b340dc5be42ae2cf20c119bd1549bc37bd99075", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,8 +10,6 @@\n \n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n-#[allow(deprecated)]\n-use std::vec::as_vec;\n \n use test::Bencher;\n \n@@ -25,25 +23,6 @@ impl<'a> Drop for DropCounter<'a> {\n     }\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_as_vec() {\n-    let xs = [1u8, 2u8, 3u8];\n-    assert_eq!(&**as_vec(&xs), xs);\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_as_vec_dtor() {\n-    let (mut count_x, mut count_y) = (0, 0);\n-    {\n-        let xs = &[DropCounter { count: &mut count_x }, DropCounter { count: &mut count_y }];\n-        assert_eq!(as_vec(xs).len(), 2);\n-    }\n-    assert_eq!(count_x, 1);\n-    assert_eq!(count_y, 1);\n-}\n-\n #[test]\n fn test_small_vec_struct() {\n     assert!(size_of::<Vec<u8>>() == size_of::<usize>() * 3);"}, {"sha": "e7b39c11f4c1bb98ae30a29310485f8c4d8fcaae", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Traits for dynamic typing of any `'static` type (through runtime reflection)\n-//!\n //! This module implements the `Any` trait, which enables dynamic typing\n //! of any `'static` type through runtime reflection.\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used\n //! as a trait object. As `&Any` (a borrowed trait object), it has the `is` and\n //! `as_ref` methods, to test if the contained value is of a given type, and to\n-//! get a reference to the inner value as a type. As`&mut Any`, there is also\n+//! get a reference to the inner value as a type. As `&mut Any`, there is also\n //! the `as_mut` method, for getting a mutable reference to the inner value.\n //! `Box<Any>` adds the `move` method, which will unwrap a `Box<T>` from the\n //! object.  See the extension traits (`*Ext`) for the full details."}, {"sha": "cfe22b89178743c8e6f43cb83b942b7a90cd2dd8", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,8 +11,9 @@\n //! Implementations of things like `Eq` for fixed-length arrays\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n+//!\n+//! *[See also the array primitive type](../primitive.array.html).*\n \n-#![doc(primitive = \"array\")]\n #![unstable(feature = \"fixed_size_array\",\n             reason = \"traits and impls are better expressed through generic \\\n                       integer constants\")]"}, {"sha": "c6434e71957ae261ea717463d592e2ead0ad8375", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -78,6 +78,7 @@ use intrinsics;\n use cell::UnsafeCell;\n \n use default::Default;\n+use fmt;\n \n /// A boolean type which can be safely shared between threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -272,13 +273,13 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n     }\n \n-    /// Stores a value into the bool if the current value is the same as the expected value.\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n-    /// `swap` also takes an `Ordering` argument which describes the memory ordering of this\n-    /// operation.\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n     ///\n     /// # Examples\n     ///\n@@ -295,11 +296,11 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { UINT_TRUE } else { 0 };\n+    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n+        let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) > 0 }\n     }\n \n     /// Logical \"and\" with a boolean value.\n@@ -515,10 +516,10 @@ impl AtomicIsize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the isize if the current value is the same as the expected value.\n+    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -538,8 +539,8 @@ impl AtomicIsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n     }\n \n     /// Add an isize to the current value, returning the previous value.\n@@ -709,10 +710,10 @@ impl AtomicUsize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the usize if the current value is the same as the expected value.\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -732,8 +733,8 @@ impl AtomicUsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n     }\n \n     /// Add to the current usize, returning the previous value.\n@@ -910,10 +911,10 @@ impl<T> AtomicPtr<T> {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n-    /// Stores a value into the pointer if the current value is the same as the expected value.\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -933,9 +934,9 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get() as *mut usize, old as usize,\n+            atomic_compare_and_swap(self.p.get() as *mut usize, current as usize,\n                                     new as usize, order) as *mut T\n         }\n     }\n@@ -953,7 +954,6 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n@@ -965,7 +965,6 @@ unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n }\n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -978,7 +977,6 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_add).\n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -991,7 +989,6 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the old value (like __sync_fetch_and_sub).\n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -1003,7 +1000,6 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n@@ -1015,7 +1011,6 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n }\n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -1027,7 +1022,6 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -1040,7 +1034,6 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -1053,7 +1046,6 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n \n #[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -1098,3 +1090,23 @@ pub fn fence(order: Ordering) {\n         }\n     }\n }\n+\n+macro_rules! impl_Debug {\n+    ($($t:ident)*) => ($(\n+        #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n+        impl fmt::Debug for $t {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                f.debug_tuple(stringify!($t)).field(&self.load(Ordering::SeqCst)).finish()\n+            }\n+        }\n+    )*);\n+}\n+\n+impl_Debug!{ AtomicUsize AtomicIsize AtomicBool }\n+\n+#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n+impl<T> fmt::Debug for AtomicPtr<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"AtomicPtr\").field(&self.load(Ordering::SeqCst)).finish()\n+    }\n+}"}, {"sha": "2c4ebeafc0bc5444d06e916873363ae911cab116", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -36,16 +36,16 @@\n //! would otherwise be disallowed though, there are occasions when interior mutability might be\n //! appropriate, or even *must* be used, e.g.\n //!\n-//! * Introducing inherited mutability roots to shared types.\n+//! * Introducing mutability 'inside' of something immutable\n //! * Implementation details of logically-immutable methods.\n //! * Mutating implementations of `Clone`.\n //!\n-//! ## Introducing inherited mutability roots to shared types\n+//! ## Introducing mutability 'inside' of something immutable\n //!\n-//! Shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\n+//! Many shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\n //! cloned and shared between multiple parties. Because the contained values may be\n-//! multiply-aliased, they can only be borrowed as shared references, not mutable references.\n-//! Without cells it would be impossible to mutate data inside of shared boxes at all!\n+//! multiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be\n+//! impossible to mutate data inside of these smart pointers at all.\n //!\n //! It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce\n //! mutability:\n@@ -65,8 +65,8 @@\n //! ```\n //!\n //! Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded\n-//! scenarios. Consider using `Mutex<T>` if you need shared mutability in a multi-threaded\n-//! situation.\n+//! scenarios. Consider using `RwLock<T>` or `Mutex<T>` if you need shared mutability in a\n+//! multi-threaded situation.\n //!\n //! ## Implementation details of logically-immutable methods\n //!"}, {"sha": "c6d0e97a0cd0053903e5ed6e6ec18be31ce23488", "filename": "src/libcore/char.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -13,7 +13,6 @@\n //! For more details, see ::rustc_unicode::char (a.k.a. std::char)\n \n #![allow(non_snake_case)]\n-#![doc(primitive = \"char\")]\n #![stable(feature = \"core_char\", since = \"1.2.0\")]\n \n use iter::Iterator;\n@@ -85,10 +84,18 @@ pub fn from_u32(i: u32) -> Option<char> {\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n         None\n     } else {\n-        Some(unsafe { transmute(i) })\n+        Some(unsafe { from_u32_unchecked(i) })\n     }\n }\n \n+/// Converts a `u32` to an `char`, not checking whether it is a valid unicode\n+/// codepoint.\n+#[inline]\n+#[unstable(feature = \"char_from_unchecked\", reason = \"recently added API\")]\n+pub unsafe fn from_u32_unchecked(i: u32) -> char {\n+    transmute(i)\n+}\n+\n /// Converts a number to the character representing it.\n ///\n /// # Return value\n@@ -116,12 +123,11 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n     }\n     if num < radix {\n-        unsafe {\n-            if num < 10 {\n-                Some(transmute('0' as u32 + num))\n-            } else {\n-                Some(transmute('a' as u32 + num - 10))\n-            }\n+        let num = num as u8;\n+        if num < 10 {\n+            Some((b'0' + num) as char)\n+        } else {\n+            Some((b'a' + num - 10) as char)\n         }\n     } else {\n         None\n@@ -319,16 +325,13 @@ impl Iterator for EscapeUnicode {\n                 Some('{')\n             }\n             EscapeUnicodeState::Value(offset) => {\n-                let v = match ((self.c as i32) >> (offset * 4)) & 0xf {\n-                    i @ 0 ... 9 => '0' as i32 + i,\n-                    i => 'a' as i32 + (i - 10)\n-                };\n+                let c = from_digit(((self.c as u32) >> (offset * 4)) & 0xf, 16).unwrap();\n                 if offset == 0 {\n                     self.state = EscapeUnicodeState::RightBrace;\n                 } else {\n                     self.state = EscapeUnicodeState::Value(offset - 1);\n                 }\n-                Some(unsafe { transmute(v) })\n+                Some(c)\n             }\n             EscapeUnicodeState::RightBrace => {\n                 self.state = EscapeUnicodeState::Done;"}, {"sha": "52ed29c1b61f49a72e09406ab30f44880ed7caf8", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -166,6 +166,8 @@ impl Ordering {\n ///\n /// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+///\n+/// When this trait is `derive`d, it produces a lexicographic ordering.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an `Ordering` between `self` and `other`."}, {"sha": "22f0215f0aded53311cf7898c27eb23acedcf681", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -175,6 +175,12 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     fn is_pretty(&self) -> bool {\n         self.fmt.flags() & (1 << (FlagV1::Alternate as usize)) != 0\n     }\n+\n+    /// Returns the wrapped `Formatter`.\n+    #[unstable(feature = \"debug_builder_formatter\", reason = \"recently added\")]\n+    pub fn formatter(&mut self) -> &mut fmt::Formatter<'b> {\n+        &mut self.fmt\n+    }\n }\n \n struct DebugInner<'a, 'b: 'a> {"}, {"sha": "29a2f76ef290b4dcee37738e1781fd4bb195a412", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 360, "deletions": 19, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -267,11 +267,18 @@ impl<'a> Display for Arguments<'a> {\n     }\n }\n \n-/// Format trait for the `:?` format. Useful for debugging, all types\n-/// should implement this.\n+/// Format trait for the `?` character.\n+///\n+/// `Debug` should format the output in a programmer-facing, debugging context.\n ///\n /// Generally speaking, you should just `derive` a `Debug` implementation.\n ///\n+/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n /// # Examples\n ///\n /// Deriving an implementation:\n@@ -309,10 +316,42 @@ impl<'a> Display for Arguments<'a> {\n /// println!(\"The origin is: {:?}\", origin);\n /// ```\n ///\n+/// This outputs:\n+///\n+/// ```text\n+/// The origin is: Point { x: 0, y: 0 }\n+/// ```\n+///\n /// There are a number of `debug_*` methods on `Formatter` to help you with manual\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n+/// `Debug` implementations using either `derive` or the debug builder API\n+/// on `Formatter` support pretty printing using the alternate flag: `{:#?}`.\n+///\n /// [debug_struct]: ../std/fmt/struct.Formatter.html#method.debug_struct\n+///\n+/// Pretty printing with `#?`:\n+///\n+/// ```\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// let origin = Point { x: 0, y: 0 };\n+///\n+/// println!(\"The origin is: {:#?}\", origin);\n+/// ```\n+///\n+/// This outputs:\n+///\n+/// ```text\n+/// The origin is: Point {\n+///     x: 0,\n+///     y: 0\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is \\\n                             defined in your crate, add `#[derive(Debug)]` or \\\n@@ -324,8 +363,39 @@ pub trait Debug {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// When a value can be semantically expressed as a String, this trait may be\n-/// used. It corresponds to the default format, `{}`.\n+/// Format trait for an empty format, `{}`.\n+///\n+/// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing\n+/// output, and so cannot be derived.\n+///\n+/// [debug]: trait.Debug.html\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Implementing `Display` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl fmt::Display for Point {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         write!(f, \"({}, {})\", self.x, self.y)\n+///     }\n+/// }\n+///\n+/// let origin = Point { x: 0, y: 0 };\n+///\n+/// println!(\"The origin is: {}\", origin);\n+/// ```\n #[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default \\\n                             formatter; try using `:?` instead if you are using \\\n                             a format string\"]\n@@ -336,55 +406,320 @@ pub trait Display {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `o` character\n+/// Format trait for the `o` character.\n+///\n+/// The `Octal` trait should format its output as a number in base-8.\n+///\n+/// The alternate flag, `#`, adds a `0o` in front of the output.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `i32`:\n+///\n+/// ```\n+/// let x = 42; // 42 is '52' in octal\n+///\n+/// assert_eq!(format!(\"{:o}\", x), \"52\");\n+/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n+/// ```\n+///\n+/// Implementing `Octal` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::Octal for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         let val = self.0;\n+///\n+///         write!(f, \"{:o}\", val) // delegate to i32's implementation\n+///     }\n+/// }\n+///\n+/// let l = Length(9);\n+///\n+/// println!(\"l as octal is: {:o}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `b` character\n+/// Format trait for the `b` character.\n+///\n+/// The `Binary` trait should format its output as a number in binary.\n+///\n+/// The alternate flag, `#`, adds a `0b` in front of the output.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `i32`:\n+///\n+/// ```\n+/// let x = 42; // 42 is '101010' in binary\n+///\n+/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n+/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n+/// ```\n+///\n+/// Implementing `Binary` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::Binary for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         let val = self.0;\n+///\n+///         write!(f, \"{:b}\", val) // delegate to i32's implementation\n+///     }\n+/// }\n+///\n+/// let l = Length(107);\n+///\n+/// println!(\"l as binary is: {:b}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `x` character\n+/// Format trait for the `x` character.\n+///\n+/// The `LowerHex` trait should format its output as a number in hexidecimal, with `a` through `f`\n+/// in lower case.\n+///\n+/// The alternate flag, `#`, adds a `0x` in front of the output.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `i32`:\n+///\n+/// ```\n+/// let x = 42; // 42 is '2a' in hex\n+///\n+/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n+/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n+/// ```\n+///\n+/// Implementing `LowerHex` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::LowerHex for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         let val = self.0;\n+///\n+///         write!(f, \"{:x}\", val) // delegate to i32's implementation\n+///     }\n+/// }\n+///\n+/// let l = Length(9);\n+///\n+/// println!(\"l as hex is: {:x}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `X` character\n+/// Format trait for the `X` character.\n+///\n+/// The `UpperHex` trait should format its output as a number in hexidecimal, with `A` through `F`\n+/// in upper case.\n+///\n+/// The alternate flag, `#`, adds a `0x` in front of the output.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `i32`:\n+///\n+/// ```\n+/// let x = 42; // 42 is '2A' in hex\n+///\n+/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n+/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n+/// ```\n+///\n+/// Implementing `UpperHex` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::UpperHex for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         let val = self.0;\n+///\n+///         write!(f, \"{:X}\", val) // delegate to i32's implementation\n+///     }\n+/// }\n+///\n+/// let l = Length(9);\n+///\n+/// println!(\"l as hex is: {:X}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `p` character\n+/// Format trait for the `p` character.\n+///\n+/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n+/// as hexidecimal.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `&i32`:\n+///\n+/// ```\n+/// let x = &42;\n+///\n+/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n+/// ```\n+///\n+/// Implementing `Pointer` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::Pointer for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n+///\n+///         write!(f, \"{:p}\", self as *const Length)\n+///     }\n+/// }\n+///\n+/// let l = Length(42);\n+///\n+/// println!(\"l is in memory here: {:p}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `e` character\n+/// Format trait for the `e` character.\n+///\n+/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `i32`:\n+///\n+/// ```\n+/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n+///\n+/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n+/// ```\n+///\n+/// Implementing `LowerExp` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::LowerExp for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         let val = self.0;\n+///         write!(f, \"{}e1\", val / 10)\n+///     }\n+/// }\n+///\n+/// let l = Length(100);\n+///\n+/// println!(\"l in scientific notation is: {:e}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `E` character\n+/// Format trait for the `E` character.\n+///\n+/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n+///\n+/// For more information on formatters, see [the module-level documentation][module].\n+///\n+/// [module]: ../index.html\n+///\n+/// # Examples\n+///\n+/// Basic usage with `f32`:\n+///\n+/// ```\n+/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n+///\n+/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n+/// ```\n+///\n+/// Implementing `UpperExp` on a type:\n+///\n+/// ```\n+/// use std::fmt;\n+///\n+/// struct Length(i32);\n+///\n+/// impl fmt::UpperExp for Length {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         let val = self.0;\n+///         write!(f, \"{}E1\", val / 10)\n+///     }\n+/// }\n+///\n+/// let l = Length(100);\n+///\n+/// println!(\"l in scientific notation is: {:E}\", l);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n@@ -980,7 +1315,14 @@ impl Debug for char {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Display for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.write_char(*self)\n+        if f.width.is_none() && f.precision.is_none() {\n+            f.write_char(*self)\n+        } else {\n+            let mut utf8 = [0; 4];\n+            let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n+            let s: &str = unsafe { mem::transmute(&utf8[..amt]) };\n+            f.pad(s)\n+        }\n     }\n }\n \n@@ -1146,20 +1488,19 @@ macro_rules! tuple {\n         impl<$($name:Debug),*> Debug for ($($name,)*) {\n             #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n-                try!(write!(f, \"(\"));\n+                let mut builder = f.debug_tuple(\"\");\n                 let ($(ref $name,)*) = *self;\n                 let mut n = 0;\n                 $(\n-                    if n > 0 {\n-                        try!(write!(f, \", \"));\n-                    }\n-                    try!(write!(f, \"{:?}\", *$name));\n+                    builder.field($name);\n                     n += 1;\n                 )*\n+\n                 if n == 1 {\n-                    try!(write!(f, \",\"));\n+                    try!(write!(builder.formatter(), \",\"));\n                 }\n-                write!(f, \")\")\n+\n+                builder.finish()\n             }\n         }\n         peel! { $($name,)* }"}, {"sha": "8141916dd60fc61d6fcf1f3fc12cbea03ff6df6c", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 86, "deletions": 4, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -12,26 +12,31 @@\n \n // FIXME: #6220 Implement floating point formatting\n \n-#![allow(unsigned_negation)]\n-\n use prelude::*;\n \n use fmt;\n use num::Zero;\n use ops::{Div, Rem, Sub};\n use str;\n+use slice;\n+use ptr;\n+use mem;\n \n #[doc(hidden)]\n trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n            Sub<Output=Self> + Copy {\n     fn from_u8(u: u8) -> Self;\n     fn to_u8(&self) -> u8;\n+    fn to_u32(&self) -> u32;\n+    fn to_u64(&self) -> u64;\n }\n \n macro_rules! doit {\n     ($($t:ident)*) => ($(impl Int for $t {\n         fn from_u8(u: u8) -> $t { u as $t }\n         fn to_u8(&self) -> u8 { *self as u8 }\n+        fn to_u32(&self) -> u32 { *self as u32 }\n+        fn to_u64(&self) -> u64 { *self as u64 }\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n@@ -188,6 +193,7 @@ macro_rules! radix_fmt {\n         }\n     }\n }\n+\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -209,17 +215,16 @@ macro_rules! debug {\n         }\n     }\n }\n+\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n-        int_base! { Display  for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n         radix_fmt! { $Int as $Int, fmt_int }\n         debug! { $Int }\n \n-        int_base! { Display  for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n@@ -233,3 +238,80 @@ integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }\n integer! { i64, u64 }\n+\n+const DEC_DIGITS_LUT: &'static[u8] =\n+    b\"0001020304050607080910111213141516171819\\\n+      2021222324252627282930313233343536373839\\\n+      4041424344454647484950515253545556575859\\\n+      6061626364656667686970717273747576777879\\\n+      8081828384858687888990919293949596979899\";\n+\n+macro_rules! impl_Display {\n+    ($($t:ident),*: $conv_fn:ident) => ($(\n+    impl fmt::Display for $t {\n+        #[allow(unused_comparisons)]\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let is_positive = *self >= 0;\n+            let mut n = if is_positive {\n+                self.$conv_fn()\n+            } else {\n+                // convert the negative num to positive by summing 1 to it's 2 complement\n+                (!self.$conv_fn()).wrapping_add(1)\n+            };\n+            let mut buf: [u8; 20] = unsafe { mem::uninitialized() };\n+            let mut curr = buf.len() as isize;\n+            let buf_ptr = buf.as_mut_ptr();\n+            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n+\n+            unsafe {\n+                // eagerly decode 4 characters at a time\n+                if <$t>::max_value() as u64 >= 10000 {\n+                    while n >= 10000 {\n+                        let rem = (n % 10000) as isize;\n+                        n /= 10000;\n+\n+                        let d1 = (rem / 100) << 1;\n+                        let d2 = (rem % 100) << 1;\n+                        curr -= 4;\n+                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n+                    }\n+                }\n+\n+                // if we reach here numbers are <= 9999, so at most 4 chars long\n+                let mut n = n as isize; // possibly reduce 64bit math\n+\n+                // decode 2 more chars, if > 2 chars\n+                if n >= 100 {\n+                    let d1 = (n % 100) << 1;\n+                    n /= 100;\n+                    curr -= 2;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+\n+                // decode last 1 or 2 chars\n+                if n < 10 {\n+                    curr -= 1;\n+                    *buf_ptr.offset(curr) = (n as u8) + 48;\n+                } else {\n+                    let d1 = n << 1;\n+                    curr -= 2;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                }\n+            }\n+\n+            let buf_slice = unsafe {\n+                str::from_utf8_unchecked(\n+                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n+            };\n+            f.pad_integral(is_positive, \"\", buf_slice)\n+        }\n+    })*);\n+}\n+\n+impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n+impl_Display!(i64, u64: to_u64);\n+#[cfg(target_pointer_width = \"32\")]\n+impl_Display!(isize, usize: to_u32);\n+#[cfg(target_pointer_width = \"64\")]\n+impl_Display!(isize, usize: to_u64);"}, {"sha": "d26e9ab7072055d9a7a24f38e2e31ca58fa10409", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,8 +10,6 @@\n \n //! An implementation of SipHash 2-4.\n \n-#![allow(deprecated)] // until the next snapshot for inherent wrapping ops\n-\n use prelude::*;\n use super::Hasher;\n "}, {"sha": "1d466895f2cfbb826287d677017ebc5b0fc7413e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -184,6 +184,14 @@ extern \"rust-intrinsic\" {\n     /// elements.\n     pub fn size_of<T>() -> usize;\n \n+    #[cfg(not(stage0))]\n+    /// Moves a value to an uninitialized memory location.\n+    ///\n+    /// Drop glue is not run on the destination.\n+    pub fn move_val_init<T>(dst: *mut T, src: T);\n+\n+    // SNAP d4432b3\n+    #[cfg(stage0)]\n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n@@ -586,20 +594,26 @@ extern \"rust-intrinsic\" {\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n     /// Performs an unchecked signed division, which results in undefined behavior,\n-    /// in cases where y == 0, or x == int::MIN and y == -1\n+    /// in cases where y == 0, or x == isize::MIN and y == -1\n     pub fn unchecked_sdiv<T>(x: T, y: T) -> T;\n     /// Performs an unchecked unsigned division, which results in undefined behavior,\n     /// in cases where y == 0\n     pub fn unchecked_udiv<T>(x: T, y: T) -> T;\n \n     /// Returns the remainder of an unchecked signed division, which results in\n-    /// undefined behavior, in cases where y == 0, or x == int::MIN and y == -1\n-    pub fn unchecked_urem<T>(x: T, y: T) -> T;\n-    /// Returns the remainder of an unchecked signed division, which results in\n-    /// undefined behavior, in cases where y == 0\n+    /// undefined behavior, in cases where y == 0, or x == isize::MIN and y == -1\n     pub fn unchecked_srem<T>(x: T, y: T) -> T;\n+    /// Returns the remainder of an unchecked unsigned division, which results in\n+    /// undefined behavior, in cases where y == 0\n+    pub fn unchecked_urem<T>(x: T, y: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     pub fn discriminant_value<T>(v: &T) -> u64;\n+\n+    /// Rust's \"try catch\" construct which invokes the function pointer `f` with\n+    /// the data pointer `data`, returning the exception payload if an exception\n+    /// is thrown (aka the thread panics).\n+    #[cfg(not(stage0))]\n+    pub fn try(f: fn(*mut u8), data: *mut u8) -> *mut u8;\n }"}, {"sha": "415326a8a616e950c6464b383bc2be0796eff173", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -2555,7 +2555,7 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n #[unstable(feature = \"iter_unfold\")]\n #[derive(Clone)]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n pub struct Unfold<St, F> {\n@@ -2567,7 +2567,7 @@ pub struct Unfold<St, F> {\n \n #[unstable(feature = \"iter_unfold\")]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n@@ -2655,8 +2655,8 @@ macro_rules! step_impl_signed {\n             #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n                 if *by == 0 { return None; }\n-                let mut diff: usize;\n-                let mut by_u: usize;\n+                let diff: usize;\n+                let by_u: usize;\n                 if *by > 0 {\n                     if *start >= *end {\n                         return Some(0);\n@@ -3018,7 +3018,7 @@ type IterateState<T, F> = (F, Option<T>, bool);\n /// from a given seed value.\n #[unstable(feature = \"iter_iterate\")]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n@@ -3027,7 +3027,7 @@ pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>)\n /// repeated applications of the given function `f`.\n #[unstable(feature = \"iter_iterate\")]\n #[deprecated(since = \"1.2.0\",\n-             reason = \"has gained enough traction to retain its position \\\n+             reason = \"has not gained enough traction to retain its position \\\n                        in the standard library\")]\n #[allow(deprecated)]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where"}, {"sha": "ef2a33c37dd307360aa50be534d9842c9bb985b6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -154,10 +154,6 @@ pub mod str;\n pub mod hash;\n pub mod fmt;\n \n-#[doc(primitive = \"bool\")]\n-mod bool {\n-}\n-\n // note: does not need to be public\n mod tuple;\n "}, {"sha": "271d83201b1a545288ffd803478a5bbc3e02291f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -155,6 +155,7 @@ pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n@@ -170,14 +171,14 @@ pub fn min_align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n /// Returns the alignment in memory for a type.\n ///\n-/// This function will return the alignment, in bytes, of a type in memory. If the alignment\n-/// returned is adhered to, then the type is guaranteed to function properly.\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n /// # Examples\n ///\n@@ -189,17 +190,10 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn align_of<T>() -> usize {\n-    // We use the preferred alignment as the default alignment for a type. This\n-    // appears to be what clang migrated towards as well:\n-    //\n-    // http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20110725/044411.html\n-    unsafe { intrinsics::pref_align_of::<T>() }\n+    unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the alignment of the type of the value that `_val` points to.\n-///\n-/// This is similar to `align_of`, but function will properly handle types such as trait objects\n-/// (in the future), returning the alignment for an arbitrary value at runtime.\n+/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n ///\n /// # Examples\n ///\n@@ -210,8 +204,8 @@ pub fn align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of_val<T>(_val: &T) -> usize {\n-    align_of::<T>()\n+pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n }\n \n /// Creates a value initialized to zero.\n@@ -371,11 +365,48 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// This function can be used to destroy any value by allowing `drop` to take ownership of its\n-/// argument.\n+/// While this does call the argument's implementation of `Drop`, it will not\n+/// release any borrows, as borrows are based on lexical scope.\n ///\n /// # Examples\n ///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// drop(v); // explicitly drop the vector\n+/// ```\n+///\n+/// Borrows are based on lexical scope, so this produces an error:\n+///\n+/// ```ignore\n+/// let mut v = vec![1, 2, 3];\n+/// let x = &v[0];\n+///\n+/// drop(x); // explicitly drop the reference, but the borrow still exists\n+///\n+/// v.push(4); // error: cannot borrow `v` as mutable because it is also\n+///            // borrowed as immutable\n+/// ```\n+///\n+/// An inner scope is needed to fix this:\n+///\n+/// ```\n+/// let mut v = vec![1, 2, 3];\n+///\n+/// {\n+///     let x = &v[0];\n+///\n+///     drop(x); // this is now redundant, as `x` is going out of scope anyway\n+/// }\n+///\n+/// v.push(4); // no problems\n+/// ```\n+///\n+/// Since `RefCell` enforces the borrow rules at runtime, `drop()` can\n+/// seemingly release a borrow of one:\n+///\n /// ```\n /// use std::cell::RefCell;\n ///\n@@ -414,17 +445,22 @@ macro_rules! repeat_u8_as_u64 {\n //\n // And of course, 0x00 brings back the old world of zero'ing on drop.\n #[unstable(feature = \"filling_drop\")]\n+#[allow(missing_docs)]\n pub const POST_DROP_U8: u8 = 0x1d;\n #[unstable(feature = \"filling_drop\")]\n+#[allow(missing_docs)]\n pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n #[unstable(feature = \"filling_drop\")]\n+#[allow(missing_docs)]\n pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n \n #[cfg(target_pointer_width = \"32\")]\n #[unstable(feature = \"filling_drop\")]\n+#[allow(missing_docs)]\n pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n #[cfg(target_pointer_width = \"64\")]\n #[unstable(feature = \"filling_drop\")]\n+#[allow(missing_docs)]\n pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n \n /// Interprets `src` as `&U`, and then reads `src` without moving the contained"}, {"sha": "6b4424093b407603fdbdf44ff8f955b5e3524533", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,7 +10,6 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-#![doc(primitive = \"f32\")]\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n@@ -24,14 +23,18 @@ use num::{Float, ParseFloatError};\n use num::FpCategory as Fp;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const RADIX: u32 = 2;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MANTISSA_DIGITS: u32 = 24;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const DIGITS: u32 = 6;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n@@ -45,20 +48,27 @@ pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n pub const MAX: f32 = 3.40282347e+38_f32;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MIN_EXP: i32 = -125;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MAX_EXP: i32 = 128;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MIN_10_EXP: i32 = -37;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MAX_10_EXP: i32 = 38;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const NAN: f32 = 0.0_f32/0.0_f32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Basic mathematial constants.\n@@ -215,13 +225,37 @@ impl Float for f32 {\n     /// Rounds towards minus infinity.\n     #[inline]\n     fn floor(self) -> f32 {\n-        unsafe { intrinsics::floorf32(self) }\n+        return floorf(self);\n+\n+        // On MSVC LLVM will lower many math intrinsics to a call to the\n+        // corresponding function. On MSVC, however, many of these functions\n+        // aren't actually available as symbols to call, but rather they are all\n+        // `static inline` functions in header files. This means that from a C\n+        // perspective it's \"compatible\", but not so much from an ABI\n+        // perspective (which we're worried about).\n+        //\n+        // The inline header functions always just cast to a f64 and do their\n+        // operation, so we do that here as well, but only for MSVC targets.\n+        //\n+        // Note that there are many MSVC-specific float operations which\n+        // redirect to this comment, so `floorf` is just one case of a missing\n+        // function on MSVC, but there are many others elsewhere.\n+        #[cfg(target_env = \"msvc\")]\n+        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n     }\n \n     /// Rounds towards plus infinity.\n     #[inline]\n     fn ceil(self) -> f32 {\n-        unsafe { intrinsics::ceilf32(self) }\n+        return ceilf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n     }\n \n     /// Rounds to nearest integer. Rounds half-way cases away from zero.\n@@ -299,7 +333,13 @@ impl Float for f32 {\n \n     #[inline]\n     fn powf(self, n: f32) -> f32 {\n-        unsafe { intrinsics::powf32(self, n) }\n+        return powf(self, n);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n     }\n \n     #[inline]\n@@ -317,7 +357,13 @@ impl Float for f32 {\n     /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f32 {\n-        unsafe { intrinsics::expf32(self) }\n+        return expf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n     }\n \n     /// Returns 2 raised to the power of the number.\n@@ -329,7 +375,13 @@ impl Float for f32 {\n     /// Returns the natural logarithm of the number.\n     #[inline]\n     fn ln(self) -> f32 {\n-        unsafe { intrinsics::logf32(self) }\n+        return logf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -345,7 +397,13 @@ impl Float for f32 {\n     /// Returns the base 10 logarithm of the number.\n     #[inline]\n     fn log10(self) -> f32 {\n-        unsafe { intrinsics::log10f32(self) }\n+        return log10f(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n     }\n \n     /// Converts to degrees, assuming the number is in radians."}, {"sha": "fa7aa2ab5ce8ca48811ed3378d7979170aa13edc", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,7 +10,6 @@\n \n //! Operations and constants for 64-bits floats (`f64` type)\n \n-#![doc(primitive = \"f64\")]\n // FIXME: MIN_VALUE and MAX_VALUE literals are parsed as -inf and inf #14353\n #![allow(overflowing_literals)]\n \n@@ -24,14 +23,18 @@ use num::FpCategory as Fp;\n use num::{Float, ParseFloatError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const RADIX: u32 = 2;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MANTISSA_DIGITS: u32 = 53;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const DIGITS: u32 = 15;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n@@ -45,20 +48,27 @@ pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n pub const MAX: f64 = 1.7976931348623157e+308_f64;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MIN_EXP: i32 = -1021;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MAX_EXP: i32 = 1024;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MIN_10_EXP: i32 = -307;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MAX_10_EXP: i32 = 308;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const NAN: f64 = 0.0_f64/0.0_f64;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Basic mathematial constants."}, {"sha": "dacb4ebcdfa3ae7be74a19f0f9b38b0bd22f0174", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"i16\")]\n \n int_module! { i16, 16 }"}, {"sha": "250d66de70b345fcd8e99e36ece5adf7456e1c03", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"i32\")]\n \n int_module! { i32, 32 }"}, {"sha": "5ed21d7246cd0385202dddbfdb49c22c2a26bf6d", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"i64\")]\n \n int_module! { i64, 64 }"}, {"sha": "0394c12d5c45790cf382b32a12be3d59741d629e", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"i8\")]\n \n int_module! { i8, 8 }"}, {"sha": "cb9bffca84256ea656723b2a1e9ac4c48e0e310a", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -16,21 +16,25 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n // calling the `mem::size_of` function.\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\")]\n+#[allow(missing_docs)]\n pub const BITS : usize = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\")]\n+#[allow(missing_docs)]\n pub const BYTES : usize = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MAX: $T = !MIN;\n \n ) }"}, {"sha": "066cb10cce265bc45262ffe7994f0afc9b9f52a6", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,7 +11,6 @@\n //! Operations and constants for pointer-sized signed integers (`isize` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"isize\")]\n \n #[cfg(target_pointer_width = \"32\")]\n int_module! { isize, 32 }"}, {"sha": "bfbb2ded0782dbf4e177d35b00cca42e70e581e2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -24,6 +24,7 @@ use mem::size_of;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n+use slice::SliceExt;\n \n /// Provides intentionally-wrapped arithmetic on `T`.\n ///\n@@ -459,15 +460,15 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `floor(self / other)`,\n+        /// Wrapping (modular) division. Computes `self / other`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// The only case where such wrapping can occur is when one\n         /// divides `MIN / -1` on a signed type (where `MIN` is the\n         /// negative minimal value for the type); this is equivalent\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n-        /// itself..\n+        /// itself.\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n@@ -668,10 +669,12 @@ macro_rules! uint_impl {\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n         pub fn min_value() -> Self { 0 }\n \n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n         pub fn max_value() -> Self { !0 }\n \n         /// Converts a string slice in a given base to an integer.\n@@ -1029,15 +1032,15 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `floor(self / other)`,\n+        /// Wrapping (modular) division. Computes `self / other`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// The only case where such wrapping can occur is when one\n         /// divides `MIN / -1` on a signed type (where `MIN` is the\n         /// negative minimal value for the type); this is equivalent\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n-        /// itself..\n+        /// itself.\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n@@ -1124,7 +1127,7 @@ macro_rules! uint_impl {\n             acc\n         }\n \n-        /// Returns `true` iff `self == 2^k` for some `k`.\n+        /// Returns `true` if and only if `self == 2^k` for some `k`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n@@ -1446,19 +1449,30 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n                                          -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n     use self::ParseIntError as PIE;\n+\n     assert!(radix >= 2 && radix <= 36,\n            \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n            radix);\n \n+    if src.is_empty() {\n+        return Err(PIE { kind: Empty });\n+    }\n+\n     let is_signed_ty = T::from_u32(0) > T::min_value();\n \n-    match src.slice_shift_char() {\n-        Some(('-', \"\")) => Err(PIE { kind: Empty }),\n-        Some(('-', src)) if is_signed_ty => {\n+    // all valid digits are ascii, so we will just iterate over the utf8 bytes\n+    // and cast them to chars. .to_digit() will safely return None for anything\n+    // other than a valid ascii digit for a the given radix, including the first-byte\n+    // of multi-byte sequences\n+    let src = src.as_bytes();\n+\n+    match (src[0], &src[1..])  {\n+        (b'-', digits) if digits.is_empty() => Err(PIE { kind: Empty }),\n+        (b'-', digits) if is_signed_ty => {\n             // The number is negative\n             let mut result = T::from_u32(0);\n-            for c in src.chars() {\n-                let x = match c.to_digit(radix) {\n+            for &c in digits {\n+                let x = match (c as char).to_digit(radix) {\n                     Some(x) => x,\n                     None => return Err(PIE { kind: InvalidDigit }),\n                 };\n@@ -1473,11 +1487,14 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n             }\n             Ok(result)\n         },\n-        Some((_, _)) => {\n+        (c, digits) => {\n             // The number is signed\n-            let mut result = T::from_u32(0);\n-            for c in src.chars() {\n-                let x = match c.to_digit(radix) {\n+            let mut result = match (c as char).to_digit(radix) {\n+                Some(x) => T::from_u32(x),\n+                None => return Err(PIE { kind: InvalidDigit }),\n+            };\n+            for &c in digits {\n+                let x = match (c as char).to_digit(radix) {\n                     Some(x) => x,\n                     None => return Err(PIE { kind: InvalidDigit }),\n                 };\n@@ -1491,8 +1508,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n                 };\n             }\n             Ok(result)\n-        },\n-        None => Err(ParseIntError { kind: Empty }),\n+        }\n     }\n }\n "}, {"sha": "ecf799448483c6987b6c9d690342a5a7b730e762", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"u16\")]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "b0682b55ac05da0fd8799e6094b57b3fee9ce71a", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"u32\")]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "dbc6a64a905d26576a9f16ce99ec6bbe11fb4ab8", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"u64\")]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "bf9347ca62c920884bce48c121904e8698c91395", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"u8\")]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "b31d6a73a7fa9b7b0233b691429c44a75adff04f", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -14,14 +14,18 @@ macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\")]\n+#[allow(missing_docs)]\n pub const BITS : usize = $bits;\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\")]\n+#[allow(missing_docs)]\n pub const BYTES : usize = ($bits / 8);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MIN: $T = 0 as $T;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(missing_docs)]\n pub const MAX: $T = !0 as $T;\n \n ) }"}, {"sha": "67e3c954ab695bb7bbf5089aa939416dc668bb48", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,6 +11,5 @@\n //! Operations and constants for pointer-sized unsigned integers (`usize` type)\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"usize\")]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "2e3b34af51382483ec3975b6a2b07fb3c5e1301d", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -119,6 +119,16 @@ macro_rules! wrapping_impl {\n             }\n         }\n \n+        #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n+        impl Div for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_div(other.0))\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;"}, {"sha": "c1cf2230ac476fc474246a02af4a1a4cb074eb1e", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 176, "deletions": 18, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -351,8 +351,10 @@ pub trait Div<RHS=Self> {\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n \n-macro_rules! div_impl {\n+macro_rules! div_impl_integer {\n     ($($t:ty)*) => ($(\n+        /// This operation rounds towards zero, truncating any\n+        /// fractional part of the exact result.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Div for $t {\n             type Output = $t;\n@@ -365,7 +367,23 @@ macro_rules! div_impl {\n     )*)\n }\n \n-div_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+div_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+\n+macro_rules! div_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_float! { f32 f64 }\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n ///\n@@ -407,6 +425,8 @@ pub trait Rem<RHS=Self> {\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n+        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// result has the same sign as the left operand.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {\n             type Output = $t;\n@@ -419,26 +439,40 @@ macro_rules! rem_impl {\n     )*)\n }\n \n-macro_rules! rem_float_impl {\n-    ($t:ty, $fmod:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Rem for $t {\n-            type Output = $t;\n+rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n-            #[inline]\n-            fn rem(self, other: $t) -> $t {\n-                extern { fn $fmod(a: $t, b: $t) -> $t; }\n-                unsafe { $fmod(self, other) }\n-            }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Rem for f32 {\n+    type Output = f32;\n+\n+    // see notes in `core::f32::Float::floor`\n+    #[inline]\n+    #[cfg(target_env = \"msvc\")]\n+    fn rem(self, other: f32) -> f32 {\n+        (self as f64).rem(other as f64) as f32\n+    }\n \n-        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    #[inline]\n+    #[cfg(not(target_env = \"msvc\"))]\n+    fn rem(self, other: f32) -> f32 {\n+        extern { fn fmodf(a: f32, b: f32) -> f32; }\n+        unsafe { fmodf(self, other) }\n     }\n }\n \n-rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n-rem_float_impl! { f32, fmodf }\n-rem_float_impl! { f64, fmod }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Rem for f64 {\n+    type Output = f64;\n+\n+    #[inline]\n+    fn rem(self, other: f64) -> f64 {\n+        extern { fn fmod(a: f64, b: f64) -> f64; }\n+        unsafe { fmod(self, other) }\n+    }\n+}\n+\n+forward_ref_binop! { impl Rem, rem for f64, f64 }\n+forward_ref_binop! { impl Rem, rem for f32, f32 }\n \n /// The `Neg` trait is used to specify the functionality of unary `-`.\n ///\n@@ -483,7 +517,6 @@ pub trait Neg {\n macro_rules! neg_impl_core {\n     ($id:ident => $body:expr, $($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(unsigned_negation)]\n         impl Neg for $t {\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             type Output = $t;\n@@ -1024,6 +1057,10 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`.\n ///\n+/// `Deref` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/deref-coercions.html\n+///\n /// # Examples\n ///\n /// A struct with a single field which is accessible via dereferencing the\n@@ -1078,6 +1115,10 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// The `DerefMut` trait is used to specify the functionality of dereferencing\n /// mutably like `*v = 1;`\n ///\n+/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n+///\n+/// [coercions]: ../../book/deref-coercions.html\n+///\n /// # Examples\n ///\n /// A struct with a single field which is modifiable via dereferencing the\n@@ -1233,3 +1274,120 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+\n+/// Both `in (PLACE) EXPR` and `box EXPR` desugar into expressions\n+/// that allocate an intermediate \"place\" that holds uninitialized\n+/// state.  The desugaring evaluates EXPR, and writes the result at\n+/// the address returned by the `pointer` method of this trait.\n+///\n+/// A `Place` can be thought of as a special representation for a\n+/// hypothetical `&uninit` reference (which Rust cannot currently\n+/// express directly). That is, it represents a pointer to\n+/// uninitialized storage.\n+///\n+/// The client is responsible for two steps: First, initializing the\n+/// payload (it can access its address via `pointer`). Second,\n+/// converting the agent to an instance of the owning pointer, via the\n+/// appropriate `finalize` method (see the `InPlace`.\n+///\n+/// If evaluating EXPR fails, then the destructor for the\n+/// implementation of Place to clean up any intermediate state\n+/// (e.g. deallocate box storage, pop a stack, etc).\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait Place<Data: ?Sized> {\n+    /// Returns the address where the input value will be written.\n+    /// Note that the data at this address is generally uninitialized,\n+    /// and thus one should use `ptr::write` for initializing it.\n+    fn pointer(&mut self) -> *mut Data;\n+}\n+\n+/// Interface to implementations of  `in (PLACE) EXPR`.\n+///\n+/// `in (PLACE) EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let p = PLACE;\n+/// let mut place = Placer::make_place(p);\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     std::ptr::write(raw_place, value);\n+///     InPlace::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `in (PLACE) EXPR` is derived from the type of `PLACE`;\n+/// if the type of `PLACE` is `P`, then the final type of the whole\n+/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n+/// traits).\n+///\n+/// Values for types implementing this trait usually are transient\n+/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n+/// or `Copy`, since the `make_place` method takes `self` by value.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait Placer<Data: ?Sized> {\n+    /// `Place` is the intermedate agent guarding the\n+    /// uninitialized state for `Data`.\n+    type Place: InPlace<Data>;\n+\n+    /// Creates a fresh place from `self`.\n+    fn make_place(self) -> Self::Place;\n+}\n+\n+/// Specialization of `Place` trait supporting `in (PLACE) EXPR`.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait InPlace<Data: ?Sized>: Place<Data> {\n+    /// `Owner` is the type of the end value of `in (PLACE) EXPR`\n+    ///\n+    /// Note that when `in (PLACE) EXPR` is solely used for\n+    /// side-effecting an existing data-structure,\n+    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n+    /// information at all (e.g. it can be the unit type `()` in that\n+    /// case).\n+    type Owner;\n+\n+    /// Converts self into the final value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// the returned instance of `Owner` and forgetting self.\n+    unsafe fn finalize(self) -> Self::Owner;\n+}\n+\n+/// Core trait for the `box EXPR` form.\n+///\n+/// `box EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let mut place = BoxPlace::make_place();\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     ::std::ptr::write(raw_place, value);\n+///     Boxed::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `box EXPR` is supplied from its surrounding\n+/// context; in the above expansion, the result type `T` is used\n+/// to determine which implementation of `Boxed` to use, and that\n+/// `<T as Boxed>` in turn dictates determines which\n+/// implementation of `BoxPlace` to use, namely:\n+/// `<<T as Boxed>::Place as BoxPlace>`.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait Boxed {\n+    /// The kind of data that is stored in this kind of box.\n+    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n+    /// The place that will negotiate the storage of the data.\n+    type Place: BoxPlace<Self::Data>;\n+\n+    /// Converts filled place into final owning value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// returned instance of `Self` and forgetting `filled`.\n+    unsafe fn finalize(filled: Self::Place) -> Self;\n+}\n+\n+/// Specialization of `Place` trait supporting `box EXPR`.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n+    /// Creates a globally fresh place.\n+    fn make_place() -> Self;\n+}"}, {"sha": "9ccba7ad78d45a785278ab64b02e34300812ae23", "filename": "src/libcore/option.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -46,7 +46,7 @@\n //!     // The division was valid\n //!     Some(x) => println!(\"Result: {}\", x),\n //!     // The division was invalid\n-//!     None    => println!(\"Cannot divide by 0\")\n+//!     None    => println!(\"Cannot divide by 0\"),\n //! }\n //! ```\n //!\n@@ -75,7 +75,7 @@\n //! fn check_optional(optional: &Option<Box<i32>>) {\n //!     match *optional {\n //!         Some(ref p) => println!(\"have value {}\", p),\n-//!         None => println!(\"have no value\")\n+//!         None => println!(\"have no value\"),\n //!     }\n //! }\n //! ```\n@@ -95,13 +95,13 @@\n //! // Take a reference to the contained string\n //! match msg {\n //!     Some(ref m) => println!(\"{}\", *m),\n-//!     None => ()\n+//!     None => (),\n //! }\n //!\n //! // Remove the contained string, destroying the Option\n //! let unwrapped_msg = match msg {\n //!     Some(m) => m,\n-//!     None => \"default message\"\n+//!     None => \"default message\",\n //! };\n //! ```\n //!\n@@ -137,7 +137,7 @@\n //!\n //! match name_of_biggest_animal {\n //!     Some(name) => println!(\"the biggest animal is {}\", name),\n-//!     None => println!(\"there are no animals :(\")\n+//!     None => println!(\"there are no animals :(\"),\n //! }\n //! ```\n \n@@ -198,7 +198,7 @@ impl<T> Option<T> {\n     pub fn is_some(&self) -> bool {\n         match *self {\n             Some(_) => true,\n-            None => false\n+            None => false,\n         }\n     }\n \n@@ -244,7 +244,7 @@ impl<T> Option<T> {\n     pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n         match *self {\n             Some(ref x) => Some(x),\n-            None => None\n+            None => None,\n         }\n     }\n \n@@ -265,7 +265,7 @@ impl<T> Option<T> {\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n-            None => None\n+            None => None,\n         }\n     }\n \n@@ -376,7 +376,7 @@ impl<T> Option<T> {\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n             Some(x) => x,\n-            None => def\n+            None => def,\n         }\n     }\n \n@@ -394,7 +394,7 @@ impl<T> Option<T> {\n     pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n         match self {\n             Some(x) => x,\n-            None => f()\n+            None => f(),\n         }\n     }\n \n@@ -420,7 +420,7 @@ impl<T> Option<T> {\n     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n         match self {\n             Some(x) => Some(f(x)),\n-            None => None\n+            None => None,\n         }\n     }\n \n@@ -464,7 +464,7 @@ impl<T> Option<T> {\n     pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n         match self {\n             Some(t) => f(t),\n-            None => default()\n+            None => default(),\n         }\n     }\n \n@@ -637,7 +637,7 @@ impl<T> Option<T> {\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n-            None => optb\n+            None => optb,\n         }\n     }\n \n@@ -659,7 +659,7 @@ impl<T> Option<T> {\n     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n         match self {\n             Some(_) => self,\n-            None => f()\n+            None => f(),\n         }\n     }\n \n@@ -736,7 +736,7 @@ impl<T: Default> Option<T> {\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Some(x) => x,\n-            None => Default::default()\n+            None => Default::default(),\n         }\n     }\n }"}, {"sha": "13d95e9ab1a71fec7ae7b25403424fe10fadf185", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,86 +10,11 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Operations on raw pointers, `*const T`, and `*mut T`.\n+//! Raw, unsafe pointers, `*const T`, and `*mut T`\n //!\n-//! Working with raw pointers in Rust is uncommon,\n-//! typically limited to a few patterns.\n-//!\n-//! Use the `null` function to create null pointers, and the `is_null` method\n-//! of the `*const T` type  to check for null. The `*const T` type also defines\n-//! the `offset` method, for pointer math.\n-//!\n-//! # Common ways to create raw pointers\n-//!\n-//! ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n-//!\n-//! ```\n-//! let my_num: i32 = 10;\n-//! let my_num_ptr: *const i32 = &my_num;\n-//! let mut my_speed: i32 = 88;\n-//! let my_speed_ptr: *mut i32 = &mut my_speed;\n-//! ```\n-//!\n-//! To get a pointer to a boxed value, dereference the box:\n-//!\n-//! ```\n-//! let my_num: Box<i32> = Box::new(10);\n-//! let my_num_ptr: *const i32 = &*my_num;\n-//! let mut my_speed: Box<i32> = Box::new(88);\n-//! let my_speed_ptr: *mut i32 = &mut *my_speed;\n-//! ```\n-//!\n-//! This does not take ownership of the original allocation\n-//! and requires no resource management later,\n-//! but you must not use the pointer after its lifetime.\n-//!\n-//! ## 2. Consume a box (`Box<T>`).\n-//!\n-//! The `into_raw` function consumes a box and returns\n-//! the raw pointer. It doesn't destroy `T` or deallocate any memory.\n-//!\n-//! ```\n-//! # #![feature(box_raw)]\n-//! use std::boxed;\n-//!\n-//! unsafe {\n-//!     let my_speed: Box<i32> = Box::new(88);\n-//!     let my_speed: *mut i32 = boxed::into_raw(my_speed);\n-//!\n-//!     // By taking ownership of the original `Box<T>` though\n-//!     // we are obligated to put it together later to be destroyed.\n-//!     drop(Box::from_raw(my_speed));\n-//! }\n-//! ```\n-//!\n-//! Note that here the call to `drop` is for clarity - it indicates\n-//! that we are done with the given value and it should be destroyed.\n-//!\n-//! ## 3. Get it from C.\n-//!\n-//! ```\n-//! # #![feature(libc)]\n-//! extern crate libc;\n-//!\n-//! use std::mem;\n-//!\n-//! fn main() {\n-//!     unsafe {\n-//!         let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>() as libc::size_t) as *mut i32;\n-//!         if my_num.is_null() {\n-//!             panic!(\"failed to allocate memory\");\n-//!         }\n-//!         libc::free(my_num as *mut libc::c_void);\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! Usually you wouldn't literally use `malloc` and `free` from Rust,\n-//! but C APIs hand out a lot of pointers generally, so are a common source\n-//! of raw pointers in Rust.\n+//! *[See also the pointer primitive types](../primitive.pointer.html).*\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"pointer\")]\n \n use mem;\n use clone::Clone;"}, {"sha": "9339f232e91979035cc6fc2dc60c2fa7bae0484b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -13,7 +13,6 @@\n //! For more details `std::slice`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"slice\")]\n \n // How this module is organized.\n //\n@@ -83,6 +82,8 @@ pub trait SliceExt {\n     fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n     fn tail<'a>(&'a self) -> &'a [Self::Item];\n     fn init<'a>(&'a self) -> &'a [Self::Item];\n+    fn split_first<'a>(&'a self) -> Option<(&'a Self::Item, &'a [Self::Item])>;\n+    fn split_last<'a>(&'a self) -> Option<(&'a Self::Item, &'a [Self::Item])>;\n     fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n     unsafe fn get_unchecked<'a>(&'a self, index: usize) -> &'a Self::Item;\n     fn as_ptr(&self) -> *const Self::Item;\n@@ -95,6 +96,8 @@ pub trait SliceExt {\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n     fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n+    fn split_first_mut<'a>(&'a mut self) -> Option<(&'a mut Self::Item, &'a mut [Self::Item])>;\n+    fn split_last_mut<'a>(&'a mut self) -> Option<(&'a mut Self::Item, &'a mut [Self::Item])>;\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n                         where P: FnMut(&Self::Item) -> bool;\n@@ -238,8 +241,17 @@ impl<T> SliceExt for [T] {\n     fn tail(&self) -> &[T] { &self[1..] }\n \n     #[inline]\n-    fn init(&self) -> &[T] {\n-        &self[..self.len() - 1]\n+    fn split_first(&self) -> Option<(&T, &[T])> {\n+        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n+    }\n+\n+    #[inline]\n+    fn init(&self) -> &[T] { &self[..self.len() - 1] }\n+\n+    #[inline]\n+    fn split_last(&self) -> Option<(&T, &[T])> {\n+        let len = self.len();\n+        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n     }\n \n     #[inline]\n@@ -328,8 +340,14 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn tail_mut(&mut self) -> &mut [T] {\n-        &mut self[1 ..]\n+    fn tail_mut(&mut self) -> &mut [T] { &mut self[1 ..] }\n+\n+    #[inline]\n+    fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        if self.is_empty() { None } else {\n+            let split = self.split_at_mut(1);\n+            Some((&mut split.0[0], split.1))\n+        }\n     }\n \n     #[inline]\n@@ -338,6 +356,15 @@ impl<T> SliceExt for [T] {\n         &mut self[.. (len - 1)]\n     }\n \n+    #[inline]\n+    fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n+        let len = self.len();\n+        if len == 0 { None } else {\n+            let split = self.split_at_mut(len - 1);\n+            Some((&mut split.1[0], split.0))\n+        }\n+    }\n+\n     #[inline]\n     fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n         SplitMut { v: self, pred: pred, finished: false }\n@@ -1368,10 +1395,14 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n+/// # Unsafety\n+///\n /// This function is unsafe as there is no guarantee that the given pointer is\n /// valid for `len` elements, nor whether the lifetime inferred is a suitable\n /// lifetime for the returned slice.\n ///\n+/// `p` must be non-null, even for zero-length slices.\n+///\n /// # Caveat\n ///\n /// The lifetime for the returned slice is inferred from its usage. To\n@@ -1459,12 +1490,30 @@ pub mod bytes {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n-        self.len() == other.len() &&\n-            order::eq(self.iter(), other.iter())\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        for i in 0..self.len() {\n+            if !self[i].eq(&other[i]) {\n+                return false;\n+            }\n+        }\n+\n+        true\n     }\n     fn ne(&self, other: &[B]) -> bool {\n-        self.len() != other.len() ||\n-            order::ne(self.iter(), other.iter())\n+        if self.len() != other.len() {\n+            return true;\n+        }\n+\n+        for i in 0..self.len() {\n+            if self[i].ne(&other[i]) {\n+                return true;\n+            }\n+        }\n+\n+        false\n     }\n }\n "}, {"sha": "4f0b881c5cd604c3ef56040ac8420e50e535a0fa", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 93, "deletions": 321, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -12,16 +12,14 @@\n //!\n //! For more details, see std::str\n \n-#![doc(primitive = \"str\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use self::OldSearcher::{TwoWay, TwoWayLong};\n use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char::CharExt;\n use clone::Clone;\n-use cmp::{self, Eq};\n+use cmp::Eq;\n use convert::AsRef;\n use default::Default;\n use fmt;\n@@ -33,7 +31,6 @@ use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n-use usize;\n \n pub mod pattern;\n \n@@ -638,10 +635,10 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        #[doc=\"Created with the method `.split()`.\"]\n+        /// Created with the method `.split()`.\n         struct Split;\n     reverse:\n-        #[doc=\"Created with the method `.rsplit()`.\"]\n+        /// Created with the method `.rsplit()`.\n         struct RSplit;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -652,10 +649,10 @@ generate_pattern_iterators! {\n \n generate_pattern_iterators! {\n     forward:\n-        #[doc=\"Created with the method `.split_terminator()`.\"]\n+        /// Created with the method `.split_terminator()`.\n         struct SplitTerminator;\n     reverse:\n-        #[doc=\"Created with the method `.rsplit_terminator()`.\"]\n+        /// Created with the method `.rsplit_terminator()`.\n         struct RSplitTerminator;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -698,10 +695,10 @@ impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        #[doc=\"Created with the method `.splitn()`.\"]\n+        /// Created with the method `.splitn()`.\n         struct SplitN;\n     reverse:\n-        #[doc=\"Created with the method `.rsplitn()`.\"]\n+        /// Created with the method `.rsplitn()`.\n         struct RSplitN;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -732,10 +729,10 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        #[doc=\"Created with the method `.match_indices()`.\"]\n+        /// Created with the method `.match_indices()`.\n         struct MatchIndices;\n     reverse:\n-        #[doc=\"Created with the method `.rmatch_indices()`.\"]\n+        /// Created with the method `.rmatch_indices()`.\n         struct RMatchIndices;\n     stability:\n         #[unstable(feature = \"str_match_indices\",\n@@ -773,10 +770,10 @@ impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        #[doc=\"Created with the method `.matches()`.\"]\n+        /// Created with the method `.matches()`.\n         struct Matches;\n     reverse:\n-        #[doc=\"Created with the method `.rmatches()`.\"]\n+        /// Created with the method `.rmatches()`.\n         struct RMatches;\n     stability:\n         #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n@@ -870,311 +867,16 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     }\n }\n \n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using two-way search\n-#[derive(Clone)]\n-struct TwoWaySearcher {\n-    // constants\n-    crit_pos: usize,\n-    period: usize,\n-    byteset: u64,\n-\n-    // variables\n-    position: usize,\n-    memory: usize\n-}\n-\n-/*\n-    This is the Two-Way search algorithm, which was introduced in the paper:\n-    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n-\n-    Here's some background information.\n-\n-    A *word* is a string of symbols. The *length* of a word should be a familiar\n-    notion, and here we denote it for any word x by |x|.\n-    (We also allow for the possibility of the *empty word*, a word of length zero).\n-\n-    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n-    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n-    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n-    the only period of the string \"abcd\" is 4.\n-\n-    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n-    This is always well-defined since every non-empty word x has at least one period,\n-    |x|. We sometimes call this *the period* of x.\n-\n-    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n-    v, then we say that (u, v) is a *factorization* of x.\n-\n-    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n-    that both of the following hold\n-\n-      - either w is a suffix of u or u is a suffix of w\n-      - either w is a prefix of v or v is a prefix of w\n-\n-    then w is said to be a *repetition* for the factorization (u, v).\n-\n-    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n-    might have:\n-\n-      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n-      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n-      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n-      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n-\n-    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n-    so every factorization has at least one repetition.\n-\n-    If x is a string and (u, v) is a factorization for x, then a *local period* for\n-    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n-    a repetition for (u, v).\n-\n-    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n-    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n-    is well-defined (because each non-empty word has at least one factorization, as\n-    noted above).\n-\n-    It can be proven that the following is an equivalent definition of a local period\n-    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n-    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n-    defined. (i.e. i > 0 and i + r < |x|).\n-\n-    Using the above reformulation, it is easy to prove that\n-\n-        1 <= local_period(u, v) <= period(uv)\n-\n-    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n-    *critical factorization*.\n-\n-    The algorithm hinges on the following theorem, which is stated without proof:\n-\n-    **Critical Factorization Theorem** Any word x has at least one critical\n-    factorization (u, v) such that |u| < period(x).\n-\n-    The purpose of maximal_suffix is to find such a critical factorization.\n-\n-*/\n-impl TwoWaySearcher {\n-    #[allow(dead_code)]\n-    fn new(needle: &[u8]) -> TwoWaySearcher {\n-        let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n-        let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n-\n-        let (crit_pos, period) =\n-            if crit_pos_false > crit_pos_true {\n-                (crit_pos_false, period_false)\n-            } else {\n-                (crit_pos_true, period_true)\n-            };\n-\n-        // This isn't in the original algorithm, as far as I'm aware.\n-        let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n-\n-        // A particularly readable explanation of what's going on here can be found\n-        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n-        // see the code for \"Algorithm CP\" on p. 323.\n-        //\n-        // What's going on is we have some critical factorization (u, v) of the\n-        // needle, and we want to determine whether u is a suffix of\n-        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n-        // \"Algorithm CP2\", which is optimized for when the period of the needle\n-        // is large.\n-        if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n-            TwoWaySearcher {\n-                crit_pos: crit_pos,\n-                period: period,\n-                byteset: byteset,\n-\n-                position: 0,\n-                memory: 0\n-            }\n-        } else {\n-            TwoWaySearcher {\n-                crit_pos: crit_pos,\n-                period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n-                byteset: byteset,\n-\n-                position: 0,\n-                memory: usize::MAX // Dummy value to signify that the period is long\n-            }\n-        }\n-    }\n-\n-    // One of the main ideas of Two-Way is that we factorize the needle into\n-    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n-    // left to right. If v matches, we try to match u by scanning right to left.\n-    // How far we can jump when we encounter a mismatch is all based on the fact\n-    // that (u, v) is a critical factorization for the needle.\n-    #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n-            -> Option<(usize, usize)> {\n-        'search: loop {\n-            // Check that we have room to search in\n-            if self.position + needle.len() > haystack.len() {\n-                return None;\n-            }\n-\n-            // Quickly skip by large portions unrelated to our substring\n-            if (self.byteset >>\n-                    ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as usize)) & 1 == 0 {\n-                self.position += needle.len();\n-                if !long_period {\n-                    self.memory = 0;\n-                }\n-                continue 'search;\n-            }\n-\n-            // See if the right part of the needle matches\n-            let start = if long_period { self.crit_pos }\n-                        else { cmp::max(self.crit_pos, self.memory) };\n-            for i in start..needle.len() {\n-                if needle[i] != haystack[self.position + i] {\n-                    self.position += i - self.crit_pos + 1;\n-                    if !long_period {\n-                        self.memory = 0;\n-                    }\n-                    continue 'search;\n-                }\n-            }\n-\n-            // See if the left part of the needle matches\n-            let start = if long_period { 0 } else { self.memory };\n-            for i in (start..self.crit_pos).rev() {\n-                if needle[i] != haystack[self.position + i] {\n-                    self.position += self.period;\n-                    if !long_period {\n-                        self.memory = needle.len() - self.period;\n-                    }\n-                    continue 'search;\n-                }\n-            }\n-\n-            // We have found a match!\n-            let match_pos = self.position;\n-            self.position += needle.len(); // add self.period for all matches\n-            if !long_period {\n-                self.memory = 0; // set to needle.len() - self.period for all matches\n-            }\n-            return Some((match_pos, match_pos + needle.len()));\n-        }\n-    }\n-\n-    // Computes a critical factorization (u, v) of `arr`.\n-    // Specifically, returns (i, p), where i is the starting index of v in some\n-    // critical factorization (u, v) and p = period(v)\n-    #[inline]\n-    #[allow(dead_code)]\n-    #[allow(deprecated)]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n-        let mut left: usize = !0; // Corresponds to i in the paper\n-        let mut right = 0; // Corresponds to j in the paper\n-        let mut offset = 1; // Corresponds to k in the paper\n-        let mut period = 1; // Corresponds to p in the paper\n-\n-        while right + offset < arr.len() {\n-            let a;\n-            let b;\n-            if reversed {\n-                a = arr[left.wrapping_add(offset)];\n-                b = arr[right + offset];\n-            } else {\n-                a = arr[right + offset];\n-                b = arr[left.wrapping_add(offset)];\n-            }\n-            if a < b {\n-                // Suffix is smaller, period is entire prefix so far.\n-                right += offset;\n-                offset = 1;\n-                period = right.wrapping_sub(left);\n-            } else if a == b {\n-                // Advance through repetition of the current period.\n-                if offset == period {\n-                    right += offset;\n-                    offset = 1;\n-                } else {\n-                    offset += 1;\n-                }\n-            } else {\n-                // Suffix is larger, start over from current location.\n-                left = right;\n-                right += 1;\n-                offset = 1;\n-                period = 1;\n-            }\n-        }\n-        (left.wrapping_add(1), period)\n-    }\n-}\n-\n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using a dynamically chosen search algorithm\n-#[derive(Clone)]\n-// NB: This is kept around for convenience because\n-// it is planned to be used again in the future\n-enum OldSearcher {\n-    TwoWay(TwoWaySearcher),\n-    TwoWayLong(TwoWaySearcher),\n-}\n-\n-impl OldSearcher {\n-    #[allow(dead_code)]\n-    fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher {\n-        if needle.is_empty() {\n-            // Handle specially\n-            unimplemented!()\n-        // FIXME: Tune this.\n-        // FIXME(#16715): This unsigned integer addition will probably not\n-        // overflow because that would mean that the memory almost solely\n-        // consists of the needle. Needs #16715 to be formally fixed.\n-        } else if needle.len() + 20 > haystack.len() {\n-            // Use naive searcher\n-            unimplemented!()\n-        } else {\n-            let searcher = TwoWaySearcher::new(needle);\n-            if searcher.memory == usize::MAX { // If the period is long\n-                TwoWayLong(searcher)\n-            } else {\n-                TwoWay(searcher)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-// NB: This is kept around for convenience because\n-// it is planned to be used again in the future\n-struct OldMatchIndices<'a, 'b> {\n-    // constants\n-    haystack: &'a str,\n-    needle: &'b str,\n-    searcher: OldSearcher\n-}\n-\n-impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n-    #[inline]\n-    #[allow(dead_code)]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        match self.searcher {\n-            TwoWay(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n-            TwoWayLong(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true),\n-        }\n-    }\n-}\n-\n /*\n Section: Comparing strings\n */\n \n-// share the implementation of the lang-item vs. non-lang-item\n-// eq_slice.\n+/// Bytewise slice equality\n /// NOTE: This function is (ab)used in rustc::middle::trans::_match\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n+#[lang = \"str_eq\"]\n #[inline]\n-fn eq_slice_(a: &str, b: &str) -> bool {\n+fn eq_slice(a: &str, b: &str) -> bool {\n     // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n     extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n@@ -1185,15 +887,6 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n     }\n }\n \n-/// Bytewise slice equality\n-/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n-/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[lang = \"str_eq\"]\n-#[inline]\n-fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n /*\n Section: Misc\n */\n@@ -1413,6 +1106,23 @@ mod traits {\n         }\n     }\n \n+    /// Returns a mutable slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::Range<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_mut_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n@@ -1435,6 +1145,21 @@ mod traits {\n         }\n     }\n \n+    /// Returns a mutable slice of the string from the beginning to byte\n+    /// `end`.\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::RangeTo<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_mut_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from `begin` to its end.\n     ///\n     /// Equivalent to `self[begin .. self.len()]`.\n@@ -1456,6 +1181,21 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the string from `begin` to its end.\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                let len = self.len();\n+                unsafe { self.slice_mut_unchecked(index.start, len) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n+        }\n+    }\n+\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n@@ -1465,6 +1205,14 @@ mod traits {\n             self\n         }\n     }\n+\n+    #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n+    impl ops::IndexMut<ops::RangeFull> for str {\n+        #[inline]\n+        fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n+            self\n+        }\n+    }\n }\n \n /// Methods for string slices\n@@ -1501,6 +1249,7 @@ pub trait StrExt {\n     fn char_len(&self) -> usize;\n     fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    unsafe fn slice_mut_unchecked<'a>(&'a mut self, begin: usize, end: usize) -> &'a mut str;\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n     fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n         where P::Searcher: ReverseSearcher<'a>;\n@@ -1520,6 +1269,7 @@ pub trait StrExt {\n         where P::Searcher: ReverseSearcher<'a>;\n     fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn split_at(&self, mid: usize) -> (&str, &str);\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n     fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n@@ -1676,6 +1426,14 @@ impl StrExt for str {\n         })\n     }\n \n+    #[inline]\n+    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n+        mem::transmute(Slice {\n+            data: self.as_ptr().offset(begin as isize),\n+            len: end - begin,\n+        })\n+    }\n+\n     #[inline]\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         pat.is_prefix_of(self)\n@@ -1824,6 +1582,20 @@ impl StrExt for str {\n         }\n     }\n \n+    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(mid) {\n+            let len = self.len();\n+            unsafe {\n+                let self2: &mut str = mem::transmute_copy(&self);\n+                (self.slice_mut_unchecked(0, mid),\n+                 self2.slice_mut_unchecked(mid, len))\n+            }\n+        } else {\n+            slice_error_fail(self, 0, mid)\n+        }\n+    }\n+\n     #[inline]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         if self.is_empty() {"}, {"sha": "707f7fcf2abcf9c85de792b22bd3d8232f88d8ec", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 577, "deletions": 142, "changes": 719, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -17,6 +17,8 @@\n             reason = \"API not fully fleshed out and ready to be stabilized\")]\n \n use prelude::*;\n+use core::cmp;\n+use usize;\n \n // Pattern\n \n@@ -341,148 +343,6 @@ unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n \n impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n \n-/////////////////////////////////////////////////////////////////////////////\n-// Impl for &str\n-/////////////////////////////////////////////////////////////////////////////\n-\n-// Todo: Optimize the naive implementation here\n-\n-/// Associated type for `<&str as Pattern<'a>>::Searcher`.\n-#[derive(Clone)]\n-pub struct StrSearcher<'a, 'b> {\n-    haystack: &'a str,\n-    needle: &'b str,\n-    start: usize,\n-    end: usize,\n-    state: State,\n-}\n-\n-#[derive(Clone, PartialEq)]\n-enum State { Done, NotDone, Reject(usize, usize) }\n-impl State {\n-    #[inline] fn done(&self) -> bool { *self == State::Done }\n-    #[inline] fn take(&mut self) -> State { ::mem::replace(self, State::NotDone) }\n-}\n-\n-/// Non-allocating substring search.\n-///\n-/// Will handle the pattern `\"\"` as returning empty matches at each utf8\n-/// boundary.\n-impl<'a, 'b> Pattern<'a> for &'b str {\n-    type Searcher = StrSearcher<'a, 'b>;\n-\n-    #[inline]\n-    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n-        StrSearcher {\n-            haystack: haystack,\n-            needle: self,\n-            start: 0,\n-            end: haystack.len(),\n-            state: State::NotDone,\n-        }\n-    }\n-}\n-\n-unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n-    #[inline]\n-    fn haystack(&self) -> &'a str {\n-        self.haystack\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> SearchStep {\n-        str_search_step(self,\n-        |m: &mut StrSearcher| {\n-            // Forward step for empty needle\n-            let current_start = m.start;\n-            if !m.state.done() {\n-                m.start = m.haystack.char_range_at(current_start).next;\n-                m.state = State::Reject(current_start, m.start);\n-            }\n-            SearchStep::Match(current_start, current_start)\n-        },\n-        |m: &mut StrSearcher| {\n-            // Forward step for nonempty needle\n-            let current_start = m.start;\n-            // Compare byte window because this might break utf8 boundaries\n-            let possible_match = &m.haystack.as_bytes()[m.start .. m.start + m.needle.len()];\n-            if possible_match == m.needle.as_bytes() {\n-                m.start += m.needle.len();\n-                SearchStep::Match(current_start, m.start)\n-            } else {\n-                // Skip a char\n-                let haystack_suffix = &m.haystack[m.start..];\n-                m.start += haystack_suffix.chars().next().unwrap().len_utf8();\n-                SearchStep::Reject(current_start, m.start)\n-            }\n-        })\n-    }\n-}\n-\n-unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep {\n-        str_search_step(self,\n-        |m: &mut StrSearcher| {\n-            // Backward step for empty needle\n-            let current_end = m.end;\n-            if !m.state.done() {\n-                m.end = m.haystack.char_range_at_reverse(current_end).next;\n-                m.state = State::Reject(m.end, current_end);\n-            }\n-            SearchStep::Match(current_end, current_end)\n-        },\n-        |m: &mut StrSearcher| {\n-            // Backward step for nonempty needle\n-            let current_end = m.end;\n-            // Compare byte window because this might break utf8 boundaries\n-            let possible_match = &m.haystack.as_bytes()[m.end - m.needle.len() .. m.end];\n-            if possible_match == m.needle.as_bytes() {\n-                m.end -= m.needle.len();\n-                SearchStep::Match(m.end, current_end)\n-            } else {\n-                // Skip a char\n-                let haystack_prefix = &m.haystack[..m.end];\n-                m.end -= haystack_prefix.chars().rev().next().unwrap().len_utf8();\n-                SearchStep::Reject(m.end, current_end)\n-            }\n-        })\n-    }\n-}\n-\n-// Helper function for encapsulating the common control flow\n-// of doing a search step from the front or doing a search step from the back\n-fn str_search_step<F, G>(mut m: &mut StrSearcher,\n-                         empty_needle_step: F,\n-                         nonempty_needle_step: G) -> SearchStep\n-    where F: FnOnce(&mut StrSearcher) -> SearchStep,\n-          G: FnOnce(&mut StrSearcher) -> SearchStep\n-{\n-    if m.state.done() {\n-        SearchStep::Done\n-    } else if m.needle.is_empty() && m.start <= m.end {\n-        // Case for needle == \"\"\n-        if let State::Reject(a, b) = m.state.take() {\n-            SearchStep::Reject(a, b)\n-        } else {\n-            if m.start == m.end {\n-                m.state = State::Done;\n-            }\n-            empty_needle_step(&mut m)\n-        }\n-    } else if m.start + m.needle.len() <= m.end {\n-        // Case for needle != \"\"\n-        nonempty_needle_step(&mut m)\n-    } else if m.start < m.end {\n-        // Remaining slice shorter than needle, reject it\n-        m.state = State::Done;\n-        SearchStep::Reject(m.start, m.end)\n-    } else {\n-        m.state = State::Done;\n-        SearchStep::Done\n-    }\n-}\n-\n /////////////////////////////////////////////////////////////////////////////\n \n macro_rules! pattern_methods {\n@@ -633,3 +493,578 @@ impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n impl<'a, 'b> Pattern<'a> for &'b &'b str {\n     pattern_methods!(StrSearcher<'a, 'b>, |&s| s, |s| s);\n }\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for &str\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Non-allocating substring search.\n+///\n+/// Will handle the pattern `\"\"` as returning empty matches at each character\n+/// boundary.\n+impl<'a, 'b> Pattern<'a> for &'b str {\n+    type Searcher = StrSearcher<'a, 'b>;\n+\n+    #[inline]\n+    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n+        StrSearcher::new(haystack, self)\n+    }\n+\n+    /// Checks whether the pattern matches at the front of the haystack\n+    #[inline]\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        haystack.is_char_boundary(self.len()) &&\n+            self == &haystack[..self.len()]\n+    }\n+\n+    /// Checks whether the pattern matches at the back of the haystack\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool {\n+        self.len() <= haystack.len() &&\n+            haystack.is_char_boundary(haystack.len() - self.len()) &&\n+            self == &haystack[haystack.len() - self.len()..]\n+    }\n+}\n+\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Two Way substring searcher\n+/////////////////////////////////////////////////////////////////////////////\n+\n+#[derive(Clone, Debug)]\n+/// Associated type for `<&str as Pattern<'a>>::Searcher`.\n+pub struct StrSearcher<'a, 'b> {\n+    haystack: &'a str,\n+    needle: &'b str,\n+\n+    searcher: StrSearcherImpl,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum StrSearcherImpl {\n+    Empty(EmptyNeedle),\n+    TwoWay(TwoWaySearcher),\n+}\n+\n+#[derive(Clone, Debug)]\n+struct EmptyNeedle {\n+    position: usize,\n+    end: usize,\n+    is_match_fw: bool,\n+    is_match_bw: bool,\n+}\n+\n+impl<'a, 'b> StrSearcher<'a, 'b> {\n+    fn new(haystack: &'a str, needle: &'b str) -> StrSearcher<'a, 'b> {\n+        if needle.is_empty() {\n+            StrSearcher {\n+                haystack: haystack,\n+                needle: needle,\n+                searcher: StrSearcherImpl::Empty(EmptyNeedle {\n+                    position: 0,\n+                    end: haystack.len(),\n+                    is_match_fw: true,\n+                    is_match_bw: true,\n+                }),\n+            }\n+        } else {\n+            StrSearcher {\n+                haystack: haystack,\n+                needle: needle,\n+                searcher: StrSearcherImpl::TwoWay(\n+                    TwoWaySearcher::new(needle.as_bytes(), haystack.len())\n+                ),\n+            }\n+        }\n+    }\n+}\n+\n+unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n+    fn haystack(&self) -> &'a str { self.haystack }\n+\n+    #[inline]\n+    fn next(&mut self) -> SearchStep {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(ref mut searcher) => {\n+                // empty needle rejects every char and matches every empty string between them\n+                let is_match = searcher.is_match_fw;\n+                searcher.is_match_fw = !searcher.is_match_fw;\n+                let pos = searcher.position;\n+                match self.haystack[pos..].chars().next() {\n+                    _ if is_match => SearchStep::Match(pos, pos),\n+                    None => SearchStep::Done,\n+                    Some(ch) => {\n+                        searcher.position += ch.len_utf8();\n+                        SearchStep::Reject(pos, searcher.position)\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                // TwoWaySearcher produces valid *Match* indices that split at char boundaries\n+                // as long as it does correct matching and that haystack and needle are\n+                // valid UTF-8\n+                // *Rejects* from the algorithm can fall on any indices, but we will walk them\n+                // manually to the next character boundary, so that they are utf-8 safe.\n+                if searcher.position == self.haystack.len() {\n+                    return SearchStep::Done;\n+                }\n+                let is_long = searcher.memory == usize::MAX;\n+                match searcher.next::<RejectAndMatch>(self.haystack.as_bytes(),\n+                                                      self.needle.as_bytes(),\n+                                                      is_long)\n+                {\n+                    SearchStep::Reject(a, mut b) => {\n+                        // skip to next char boundary\n+                        while !self.haystack.is_char_boundary(b) {\n+                            b += 1;\n+                        }\n+                        searcher.position = cmp::max(b, searcher.position);\n+                        SearchStep::Reject(a, b)\n+                    }\n+                    otherwise => otherwise,\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn next_match(&mut self) -> Option<(usize, usize)> {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(..) => {\n+                loop {\n+                    match self.next() {\n+                        SearchStep::Match(a, b) => return Some((a, b)),\n+                        SearchStep::Done => return None,\n+                        SearchStep::Reject(..) => { }\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                let is_long = searcher.memory == usize::MAX;\n+                if is_long {\n+                    searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n+                                               self.needle.as_bytes(),\n+                                               true)\n+                } else {\n+                    searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n+                                               self.needle.as_bytes(),\n+                                               false)\n+                }\n+            }\n+        }\n+    }\n+\n+}\n+unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(ref mut searcher) => {\n+                let is_match = searcher.is_match_bw;\n+                searcher.is_match_bw = !searcher.is_match_bw;\n+                let end = searcher.end;\n+                match self.haystack[..end].chars().next_back() {\n+                    _ if is_match => SearchStep::Match(end, end),\n+                    None => SearchStep::Done,\n+                    Some(ch) => {\n+                        searcher.end -= ch.len_utf8();\n+                        SearchStep::Reject(searcher.end, end)\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                if searcher.end == 0 {\n+                    return SearchStep::Done;\n+                }\n+                match searcher.next_back::<RejectAndMatch>(self.haystack.as_bytes(),\n+                                                           self.needle.as_bytes())\n+                {\n+                    SearchStep::Reject(mut a, b) => {\n+                        // skip to next char boundary\n+                        while !self.haystack.is_char_boundary(a) {\n+                            a -= 1;\n+                        }\n+                        searcher.end = cmp::min(a, searcher.end);\n+                        SearchStep::Reject(a, b)\n+                    }\n+                    otherwise => otherwise,\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n+        match self.searcher {\n+            StrSearcherImpl::Empty(..) => {\n+                loop {\n+                    match self.next_back() {\n+                        SearchStep::Match(a, b) => return Some((a, b)),\n+                        SearchStep::Done => return None,\n+                        SearchStep::Reject(..) => { }\n+                    }\n+                }\n+            }\n+            StrSearcherImpl::TwoWay(ref mut searcher) => {\n+                searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n+                                                self.needle.as_bytes())\n+            }\n+        }\n+    }\n+}\n+\n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using two-way search\n+#[derive(Clone, Debug)]\n+struct TwoWaySearcher {\n+    // constants\n+    crit_pos: usize,\n+    period: usize,\n+    byteset: u64,\n+\n+    // variables\n+    position: usize,\n+    end: usize,\n+    memory: usize\n+}\n+\n+/*\n+    This is the Two-Way search algorithm, which was introduced in the paper:\n+    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n+\n+    Here's some background information.\n+\n+    A *word* is a string of symbols. The *length* of a word should be a familiar\n+    notion, and here we denote it for any word x by |x|.\n+    (We also allow for the possibility of the *empty word*, a word of length zero).\n+\n+    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n+    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n+    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n+    the only period of the string \"abcd\" is 4.\n+\n+    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n+    This is always well-defined since every non-empty word x has at least one period,\n+    |x|. We sometimes call this *the period* of x.\n+\n+    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n+    v, then we say that (u, v) is a *factorization* of x.\n+\n+    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n+    that both of the following hold\n+\n+      - either w is a suffix of u or u is a suffix of w\n+      - either w is a prefix of v or v is a prefix of w\n+\n+    then w is said to be a *repetition* for the factorization (u, v).\n+\n+    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n+    might have:\n+\n+      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n+      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n+      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n+      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n+\n+    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n+    so every factorization has at least one repetition.\n+\n+    If x is a string and (u, v) is a factorization for x, then a *local period* for\n+    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n+    a repetition for (u, v).\n+\n+    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n+    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n+    is well-defined (because each non-empty word has at least one factorization, as\n+    noted above).\n+\n+    It can be proven that the following is an equivalent definition of a local period\n+    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n+    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n+    defined. (i.e. i > 0 and i + r < |x|).\n+\n+    Using the above reformulation, it is easy to prove that\n+\n+        1 <= local_period(u, v) <= period(uv)\n+\n+    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n+    *critical factorization*.\n+\n+    The algorithm hinges on the following theorem, which is stated without proof:\n+\n+    **Critical Factorization Theorem** Any word x has at least one critical\n+    factorization (u, v) such that |u| < period(x).\n+\n+    The purpose of maximal_suffix is to find such a critical factorization.\n+\n+*/\n+impl TwoWaySearcher {\n+    fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n+        let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n+        let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n+\n+        let (crit_pos, period) =\n+            if crit_pos_false > crit_pos_true {\n+                (crit_pos_false, period_false)\n+            } else {\n+                (crit_pos_true, period_true)\n+            };\n+\n+        // This isn't in the original algorithm, as far as I'm aware.\n+        let byteset = needle.iter()\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n+\n+        // A particularly readable explanation of what's going on here can be found\n+        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n+        // see the code for \"Algorithm CP\" on p. 323.\n+        //\n+        // What's going on is we have some critical factorization (u, v) of the\n+        // needle, and we want to determine whether u is a suffix of\n+        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // \"Algorithm CP2\", which is optimized for when the period of the needle\n+        // is large.\n+        if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n+            // short period case\n+            TwoWaySearcher {\n+                crit_pos: crit_pos,\n+                period: period,\n+                byteset: byteset,\n+\n+                position: 0,\n+                end: end,\n+                memory: 0\n+            }\n+        } else {\n+            // long period case\n+            // we have an approximation to the actual period, and don't use memory.\n+            TwoWaySearcher {\n+                crit_pos: crit_pos,\n+                period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n+                byteset: byteset,\n+\n+                position: 0,\n+                end: end,\n+                memory: usize::MAX // Dummy value to signify that the period is long\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn byteset_contains(&self, byte: u8) -> bool {\n+        (self.byteset >> ((byte & 0x3f) as usize)) & 1 != 0\n+    }\n+\n+    // One of the main ideas of Two-Way is that we factorize the needle into\n+    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n+    // left to right. If v matches, we try to match u by scanning right to left.\n+    // How far we can jump when we encounter a mismatch is all based on the fact\n+    // that (u, v) is a critical factorization for the needle.\n+    #[inline(always)]\n+    fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+        -> S::Output\n+        where S: TwoWayStrategy\n+    {\n+        // `next()` uses `self.position` as its cursor\n+        let old_pos = self.position;\n+        'search: loop {\n+            // Check that we have room to search in\n+            if needle.len() > haystack.len() - self.position {\n+                self.position = haystack.len();\n+                return S::rejecting(old_pos, self.position);\n+            }\n+\n+            if S::use_early_reject() && old_pos != self.position {\n+                return S::rejecting(old_pos, self.position);\n+            }\n+\n+            // Quickly skip by large portions unrelated to our substring\n+            if !self.byteset_contains(haystack[self.position + needle.len() - 1]) {\n+                self.position += needle.len();\n+                if !long_period {\n+                    self.memory = 0;\n+                }\n+                continue 'search;\n+            }\n+\n+            // See if the right part of the needle matches\n+            let start = if long_period { self.crit_pos }\n+                        else { cmp::max(self.crit_pos, self.memory) };\n+            for i in start..needle.len() {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += i - self.crit_pos + 1;\n+                    if !long_period {\n+                        self.memory = 0;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // See if the left part of the needle matches\n+            let start = if long_period { 0 } else { self.memory };\n+            for i in (start..self.crit_pos).rev() {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += self.period;\n+                    if !long_period {\n+                        self.memory = needle.len() - self.period;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // We have found a match!\n+            let match_pos = self.position;\n+\n+            // Note: add self.period instead of needle.len() to have overlapping matches\n+            self.position += needle.len();\n+            if !long_period {\n+                self.memory = 0; // set to needle.len() - self.period for overlapping matches\n+            }\n+\n+            return S::matching(match_pos, match_pos + needle.len());\n+        }\n+    }\n+\n+    // Follows the ideas in `next()`.\n+    //\n+    // All the definitions are completely symmetrical, with period(x) = period(reverse(x))\n+    // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n+    // is a critical factorization, so is (reverse(v), reverse(u)). Similarly,\n+    // the \"period\" stored in self.period is the real period if long_period is\n+    // false, and so is still valid for a reversed needle, and if long_period is\n+    // true, all the algorithm requires is that self.period is less than or\n+    // equal to the real period, which must be true for the forward case anyway.\n+    //\n+    // To search in reverse through the haystack, we search forward through\n+    // a reversed haystack with a reversed needle, and the above paragraph shows\n+    // that the precomputed parameters can be left alone.\n+    #[inline]\n+    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8])\n+        -> S::Output\n+        where S: TwoWayStrategy\n+    {\n+        // `next_back()` uses `self.end` as its cursor -- so that `next()` and `next_back()`\n+        // are independent.\n+        let old_end = self.end;\n+        'search: loop {\n+            // Check that we have room to search in\n+            if needle.len() > self.end {\n+                self.end = 0;\n+                return S::rejecting(0, old_end);\n+            }\n+\n+            if S::use_early_reject() && old_end != self.end {\n+                return S::rejecting(self.end, old_end);\n+            }\n+\n+            // Quickly skip by large portions unrelated to our substring\n+            if !self.byteset_contains(haystack[self.end - needle.len()]) {\n+                self.end -= needle.len();\n+                continue 'search;\n+            }\n+\n+            // See if the left part of the needle matches\n+            for i in (0..self.crit_pos).rev() {\n+                if needle[i] != haystack[self.end - needle.len() + i] {\n+                    self.end -= self.crit_pos - i;\n+                    continue 'search;\n+                }\n+            }\n+\n+            // See if the right part of the needle matches\n+            for i in self.crit_pos..needle.len() {\n+                if needle[i] != haystack[self.end - needle.len() + i] {\n+                    self.end -= self.period;\n+                    continue 'search;\n+                }\n+            }\n+\n+            // We have found a match!\n+            let match_pos = self.end - needle.len();\n+            // Note: sub self.period instead of needle.len() to have overlapping matches\n+            self.end -= needle.len();\n+\n+            return S::matching(match_pos, match_pos + needle.len());\n+        }\n+    }\n+\n+    // Computes a critical factorization (u, v) of `arr`.\n+    // Specifically, returns (i, p), where i is the starting index of v in some\n+    // critical factorization (u, v) and p = period(v)\n+    #[inline]\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n+        let mut left: usize = !0; // Corresponds to i in the paper\n+        let mut right = 0; // Corresponds to j in the paper\n+        let mut offset = 1; // Corresponds to k in the paper\n+        let mut period = 1; // Corresponds to p in the paper\n+\n+        while right + offset < arr.len() {\n+            let a;\n+            let b;\n+            if reversed {\n+                a = arr[left.wrapping_add(offset)];\n+                b = arr[right + offset];\n+            } else {\n+                a = arr[right + offset];\n+                b = arr[left.wrapping_add(offset)];\n+            }\n+            if a < b {\n+                // Suffix is smaller, period is entire prefix so far.\n+                right += offset;\n+                offset = 1;\n+                period = right.wrapping_sub(left);\n+            } else if a == b {\n+                // Advance through repetition of the current period.\n+                if offset == period {\n+                    right += offset;\n+                    offset = 1;\n+                } else {\n+                    offset += 1;\n+                }\n+            } else {\n+                // Suffix is larger, start over from current location.\n+                left = right;\n+                right += 1;\n+                offset = 1;\n+                period = 1;\n+            }\n+        }\n+        (left.wrapping_add(1), period)\n+    }\n+}\n+\n+// TwoWayStrategy allows the algorithm to either skip non-matches as quickly\n+// as possible, or to work in a mode where it emits Rejects relatively quickly.\n+trait TwoWayStrategy {\n+    type Output;\n+    fn use_early_reject() -> bool;\n+    fn rejecting(usize, usize) -> Self::Output;\n+    fn matching(usize, usize) -> Self::Output;\n+}\n+\n+/// Skip to match intervals as quickly as possible\n+enum MatchOnly { }\n+\n+impl TwoWayStrategy for MatchOnly {\n+    type Output = Option<(usize, usize)>;\n+\n+    #[inline]\n+    fn use_early_reject() -> bool { false }\n+    #[inline]\n+    fn rejecting(_a: usize, _b: usize) -> Self::Output { None }\n+    #[inline]\n+    fn matching(a: usize, b: usize) -> Self::Output { Some((a, b)) }\n+}\n+\n+/// Emit Rejects regularly\n+enum RejectAndMatch { }\n+\n+impl TwoWayStrategy for RejectAndMatch {\n+    type Output = SearchStep;\n+\n+    #[inline]\n+    fn use_early_reject() -> bool { true }\n+    #[inline]\n+    fn rejecting(a: usize, b: usize) -> Self::Output { SearchStep::Reject(a, b) }\n+    #[inline]\n+    fn matching(a: usize, b: usize) -> Self::Output { SearchStep::Match(a, b) }\n+}"}, {"sha": "6c5ff2223236525276fce217b3121388e7a27c5d", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Operations on tuples\n+//! A finite heterogeneous sequence, `(T, U, ..)`\n //!\n //! To access a single element of a tuple one can use the `.0`\n //! field access syntax.\n@@ -28,7 +28,6 @@\n //! * `Default`\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![doc(primitive = \"tuple\")]\n \n use clone::Clone;\n use cmp::*;"}, {"sha": "35f8372a7094881a38a821a4d6ab75e183583336", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -102,29 +102,6 @@ fn test_to_uppercase() {\n     assert_eq!(upper('\u1f80'), ['\u1f08', '\u0399']);\n }\n \n-#[test]\n-fn test_to_titlecase() {\n-    fn title(c: char) -> Vec<char> {\n-        c.to_titlecase().collect()\n-    }\n-    assert_eq!(title('a'), ['A']);\n-    assert_eq!(title('\u00f6'), ['\u00d6']);\n-    assert_eq!(title('\u00df'), ['S', 's']); // not \u1e9e: Latin capital letter sharp s\n-    assert_eq!(title('\u00fc'), ['\u00dc']);\n-    assert_eq!(title('\ud83d\udca9'), ['\ud83d\udca9']);\n-\n-    assert_eq!(title('\u03c3'), ['\u03a3']);\n-    assert_eq!(title('\u03c4'), ['\u03a4']);\n-    assert_eq!(title('\u03b9'), ['\u0399']);\n-    assert_eq!(title('\u03b3'), ['\u0393']);\n-    assert_eq!(title('\u03bc'), ['\u039c']);\n-    assert_eq!(title('\u03b1'), ['\u0391']);\n-    assert_eq!(title('\u03c2'), ['\u03a3']);\n-    assert_eq!(title('\u01c4'), ['\u01c5']);\n-    assert_eq!(title('\ufb01'), ['F', 'i']);\n-    assert_eq!(title('\u1f80'), ['\u1f88']);\n-}\n-\n #[test]\n fn test_is_control() {\n     assert!('\\u{0}'.is_control());"}, {"sha": "42872589bb01fa296dbe0d76ffb8e2575a6ef5e7", "filename": "src/libcoretest/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -16,4 +16,6 @@ fn test_format_flags() {\n     // No residual flags left by pointer formatting\n     let p = \"\".as_ptr();\n     assert_eq!(format!(\"{:p} {:x}\", p, 16), format!(\"{:p} 10\", p));\n+\n+    assert_eq!(format!(\"{: >3}\", 'a'), \"  a\");\n }"}, {"sha": "247c3dcb9c705bd026026181607624f07cf6cd48", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -7,8 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![allow(unsigned_negation)]\n-\n use core::fmt::radix;\n \n #[test]"}, {"sha": "697c3ee254b983ee3323381c14e6f8bb649bf654", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod sip;\n+\n use std::mem;\n use std::hash::{Hash, Hasher};\n use std::default::Default;"}, {"sha": "7832985d3f1c1ee158291af85f1ea502e871a3d1", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,28 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use test::Bencher;\n-use std::prelude::*;\n-use std::fmt;\n \n-use str::Str;\n-use string::String;\n-use slice::{AsSlice, SlicePrelude};\n-use vec::Vec;\n-\n-use core::hash::{Hash, Writer};\n-use core::hash::sip::{SipState, hash, hash_with_keys};\n+use core::hash::{Hash, Hasher};\n+use core::hash::SipHasher;\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n \n-impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n+impl<'a> Hash for Bytes<'a> {\n     #[allow(unused_must_use)]\n-    fn hash(&self, state: &mut S) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         let Bytes(v) = *self;\n         state.write(v);\n     }\n }\n \n+macro_rules! u8to64_le {\n+    ($buf:expr, $i:expr) =>\n+    ($buf[0+$i] as u64 |\n+     ($buf[1+$i] as u64) << 8 |\n+     ($buf[2+$i] as u64) << 16 |\n+     ($buf[3+$i] as u64) << 24 |\n+     ($buf[4+$i] as u64) << 32 |\n+     ($buf[5+$i] as u64) << 40 |\n+     ($buf[6+$i] as u64) << 48 |\n+     ($buf[7+$i] as u64) << 56);\n+    ($buf:expr, $i:expr, $len:expr) =>\n+    ({\n+        let mut t = 0;\n+        let mut out = 0;\n+        while t < $len {\n+            out |= ($buf[t+$i] as u64) << t*8;\n+            t += 1;\n+        }\n+        out\n+    });\n+}\n+\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    let mut st = SipHasher::new();\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n+fn hash_with_keys<T: Hash>(k1: u64, k2: u64, x: &T) -> u64 {\n+    let mut st = SipHasher::new_with_keys(k1, k2);\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash() {\n@@ -104,79 +131,43 @@ fn test_siphash() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n     let mut buf = Vec::new();\n     let mut t = 0;\n-    let mut state_inc = SipState::new_with_keys(k0, k1);\n-    let mut state_full = SipState::new_with_keys(k0, k1);\n-\n-    fn to_hex_str(r: &[u8; 8]) -> String {\n-        let mut s = String::new();\n-        for b in r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n-        }\n-        s\n-    }\n-\n-    fn result_bytes(h: u64) -> Vec<u8> {\n-        vec![(h >> 0) as u8,\n-          (h >> 8) as u8,\n-          (h >> 16) as u8,\n-          (h >> 24) as u8,\n-          (h >> 32) as u8,\n-          (h >> 40) as u8,\n-          (h >> 48) as u8,\n-          (h >> 56) as u8,\n-        ]\n-    }\n-\n-    fn result_str(h: u64) -> String {\n-        let r = result_bytes(h);\n-        let mut s = String::new();\n-        for b in &r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n-        }\n-        s\n-    }\n+    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n \n     while t < 64 {\n-        debug!(\"siphash test {}: {}\", t, buf);\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with_keys(k0, k1, &Bytes(buf));\n-        debug!(\"got {}, expected {}\", out, vec);\n+        let out = hash_with_keys(k0, k1, &Bytes(&buf));\n         assert_eq!(vec, out);\n \n-        state_full.reset();\n-        state_full.write(buf);\n-        let f = result_str(state_full.result());\n-        let i = result_str(state_inc.result());\n-        let v = to_hex_str(&vecs[t]);\n-        debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n+        let full = hash_with_keys(k0, k1, &Bytes(&buf));\n+        let i = state_inc.finish();\n \n-        assert_eq!(f, i);\n-        assert_eq!(f, v);\n+        assert_eq!(full, i);\n+        assert_eq!(full, vec);\n \n         buf.push(t as u8);\n-        state_inc.write(&[t as u8]);\n+        Hasher::write(&mut state_inc, &[t as u8]);\n \n         t += 1;\n     }\n }\n \n #[test] #[cfg(target_arch = \"arm\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-    assert!(hash(&(val as u32)) != hash(&(val as uint)));\n+    assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+    assert!(hash(&(val as u32)) != hash(&(val as usize)));\n }\n #[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n \n #[test]\n@@ -200,7 +191,7 @@ fn test_hash_no_bytes_dropped_64() {\n     assert!(hash(&val) != hash(&zero_byte(val, 6)));\n     assert!(hash(&val) != hash(&zero_byte(val, 7)));\n \n-    fn zero_byte(val: u64, byte: uint) -> u64 {\n+    fn zero_byte(val: u64, byte: usize) -> u64 {\n         assert!(byte < 8);\n         val & !(0xff << (byte * 8))\n     }\n@@ -215,7 +206,7 @@ fn test_hash_no_bytes_dropped_32() {\n     assert!(hash(&val) != hash(&zero_byte(val, 2)));\n     assert!(hash(&val) != hash(&zero_byte(val, 3)));\n \n-    fn zero_byte(val: u32, byte: uint) -> u32 {\n+    fn zero_byte(val: u32, byte: usize) -> u32 {\n         assert!(byte < 4);\n         val & !(0xff << (byte * 8))\n     }\n@@ -230,8 +221,9 @@ fn test_hash_no_concat_alias() {\n     assert!(s != t && t != u);\n     assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n \n-    let v: (&[u8], &[u8], &[u8]) = (&[1], &[0, 0], &[0]);\n-    let w: (&[u8], &[u8], &[u8]) = (&[1, 0, 0, 0], &[], &[]);\n+    let u = [1, 0, 0, 0];\n+    let v = (&u[..1], &u[1..3], &u[3..]);\n+    let w = (&u[..], &u[4..4], &u[4..4]);\n \n     assert!(v != w);\n     assert!(hash(&v) != hash(&w));"}, {"sha": "a9baa2cc477f6c326923888cb80bfa3bc162eb05", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -117,7 +117,14 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_int_from_minus_sign() {\n-        assert_eq!(\"-\".parse::<i32>().ok(), None);\n+    fn test_invalid() {\n+        assert_eq!(\"--129\".parse::<i8>().ok(), None);\n+        assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+    }\n+\n+    #[test]\n+    fn test_empty() {\n+        assert_eq!(\"-\".parse::<i8>().ok(), None);\n+        assert_eq!(\"\".parse::<u8>().ok(), None);\n     }\n }"}, {"sha": "865b049aae55a4e8b5b5bf141f2696161bbdb329", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,7 +10,6 @@\n \n use core::ptr::*;\n use core::mem;\n-use std::iter::repeat;\n \n #[test]\n fn test() {\n@@ -110,7 +109,7 @@ fn test_as_mut() {\n #[test]\n fn test_ptr_addition() {\n     unsafe {\n-        let xs = repeat(5).take(16).collect::<Vec<_>>();\n+        let xs = vec![5; 16];\n         let mut ptr = xs.as_ptr();\n         let end = ptr.offset(16);\n \n@@ -128,7 +127,7 @@ fn test_ptr_addition() {\n             m_ptr = m_ptr.offset(1);\n         }\n \n-        assert!(xs_mut == repeat(10).take(16).collect::<Vec<_>>());\n+        assert!(xs_mut == vec![10; 16]);\n     }\n }\n "}, {"sha": "7ca89cfd0c9cc828cee98ef95f313011d8bb7750", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -399,7 +399,7 @@ impl<'a> Parser<'a> {\n             }\n             Some(..) | None => { return &self.input[..0]; }\n         };\n-        let mut end;\n+        let end;\n         loop {\n             match self.cur.clone().next() {\n                 Some((_, c)) if c.is_xid_continue() => {"}, {"sha": "8953375297db26e5309886d49e9b912a6f2fb9de", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -56,7 +56,7 @@\n //!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n //!         optflag(\"h\", \"help\", \"print this help menu\")\n //!     ];\n-//!     let matches = match getopts(args.tail(), opts) {\n+//!     let matches = match getopts(args[1..], opts) {\n //!         Ok(m) => { m }\n //!         Err(f) => { panic!(f.to_string()) }\n //!     };\n@@ -784,13 +784,13 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(&desc_rows.connect(&desc_sep[..]));\n+        row.push_str(&desc_rows.join(&desc_sep[..]));\n \n         row\n     });\n \n     format!(\"{}\\n\\nOptions:\\n{}\\n\", brief,\n-            rows.collect::<Vec<String>>().connect(\"\\n\"))\n+            rows.collect::<Vec<String>>().join(\"\\n\"))\n }\n \n fn format_option(opt: &OptGroup) -> String {\n@@ -836,7 +836,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(&opts.iter()\n                        .map(format_option)\n                        .collect::<Vec<String>>()\n-                       .connect(\" \")[..]);\n+                       .join(\" \")[..]);\n     line\n }\n "}, {"sha": "4d07573268a68fbd0e691f5b53adbe60945944c2", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 158, "deletions": 34, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -312,6 +312,40 @@ pub enum LabelText<'a> {\n     EscStr(Cow<'a, str>),\n }\n \n+/// The style for a node or edge.\n+/// See http://www.graphviz.org/doc/info/attrs.html#k:style for descriptions.\n+/// Note that some of these are not valid for edges.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Style {\n+    None,\n+    Solid,\n+    Dashed,\n+    Dotted,\n+    Bold,\n+    Rounded,\n+    Diagonals,\n+    Filled,\n+    Striped,\n+    Wedged,\n+}\n+\n+impl Style {\n+    pub fn as_slice(self) -> &'static str {\n+        match self {\n+            Style::None => \"\",\n+            Style::Solid => \"solid\",\n+            Style::Dashed => \"dashed\",\n+            Style::Dotted => \"dotted\",\n+            Style::Bold => \"bold\",\n+            Style::Rounded => \"rounded\",\n+            Style::Diagonals => \"diagonals\",\n+            Style::Filled => \"filled\",\n+            Style::Striped => \"striped\",\n+            Style::Wedged => \"wedged\",\n+        }\n+    }\n+}\n+\n // There is a tension in the design of the labelling API.\n //\n // For example, I considered making a `Labeller<T>` trait that\n@@ -430,6 +464,16 @@ pub trait Labeller<'a,N,E> {\n         let _ignored = e;\n         LabelStr(\"\".into_cow())\n     }\n+\n+    /// Maps `n` to a style that will be used in the rendered output.\n+    fn node_style(&'a self, _n: &N) -> Style {\n+        Style::None\n+    }\n+\n+    /// Maps `e` to a style that will be used in the rendered output.\n+    fn edge_style(&'a self, _e: &E) -> Style {\n+        Style::None\n+    }\n }\n \n impl<'a> LabelText<'a> {\n@@ -529,6 +573,8 @@ pub trait GraphWalk<'a, N, E> {\n pub enum RenderOption {\n     NoEdgeLabels,\n     NoNodeLabels,\n+    NoEdgeStyles,\n+    NoNodeStyles,\n }\n \n /// Returns vec holding all the default render options.\n@@ -562,30 +608,53 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n     for n in g.nodes().iter() {\n         try!(indent(w));\n         let id = g.node_id(n);\n-        if options.contains(&RenderOption::NoNodeLabels) {\n-            try!(writeln(w, &[id.as_slice(), \";\"]));\n-        } else {\n-            let escaped = g.node_label(n).escape();\n-            try!(writeln(w, &[id.as_slice(),\n-                              \"[label=\\\"\", &escaped, \"\\\"];\"]));\n+\n+        let escaped = &g.node_label(n).escape();\n+\n+        let mut text = vec![id.as_slice()];\n+\n+        if !options.contains(&RenderOption::NoNodeLabels) {\n+            text.push(\"[label=\\\"\");\n+            text.push(escaped);\n+            text.push(\"\\\"]\");\n+        }\n+\n+        let style = g.node_style(n);\n+        if !options.contains(&RenderOption::NoNodeStyles) && style != Style::None {\n+            text.push(\"[style=\\\"\");\n+            text.push(style.as_slice());\n+            text.push(\"\\\"]\");\n         }\n+\n+        text.push(\";\");\n+        try!(writeln(w, &text));\n     }\n \n     for e in g.edges().iter() {\n-        let escaped_label = g.edge_label(e).escape();\n+        let escaped_label = &g.edge_label(e).escape();\n         try!(indent(w));\n         let source = g.source(e);\n         let target = g.target(e);\n         let source_id = g.node_id(&source);\n         let target_id = g.node_id(&target);\n-        if options.contains(&RenderOption::NoEdgeLabels) {\n-            try!(writeln(w, &[source_id.as_slice(),\n-                              \" -> \", target_id.as_slice(), \";\"]));\n-        } else {\n-            try!(writeln(w, &[source_id.as_slice(),\n-                              \" -> \", target_id.as_slice(),\n-                              \"[label=\\\"\", &escaped_label, \"\\\"];\"]));\n+\n+        let mut text = vec![source_id.as_slice(), \" -> \", target_id.as_slice()];\n+\n+        if !options.contains(&RenderOption::NoEdgeLabels) {\n+            text.push(\"[label=\\\"\");\n+            text.push(escaped_label);\n+            text.push(\"\\\"]\");\n+        }\n+\n+        let style = g.edge_style(e);\n+        if !options.contains(&RenderOption::NoEdgeStyles) && style != Style::None {\n+            text.push(\"[style=\\\"\");\n+            text.push(style.as_slice());\n+            text.push(\"\\\"]\");\n         }\n+\n+        text.push(\";\");\n+        try!(writeln(w, &text));\n     }\n \n     writeln(w, &[\"}\"])\n@@ -594,21 +663,23 @@ pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N\n #[cfg(test)]\n mod tests {\n     use self::NodeLabels::*;\n-    use super::{Id, Labeller, Nodes, Edges, GraphWalk, render};\n+    use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n     use super::LabelText::{self, LabelStr, EscStr};\n     use std::io;\n     use std::io::prelude::*;\n     use std::borrow::IntoCow;\n-    use std::iter::repeat;\n \n     /// each node is an index in a vector in the graph.\n     type Node = usize;\n     struct Edge {\n-        from: usize, to: usize, label: &'static str\n+        from: usize,\n+        to: usize,\n+        label: &'static str,\n+        style: Style,\n     }\n \n-    fn edge(from: usize, to: usize, label: &'static str) -> Edge {\n-        Edge { from: from, to: to, label: label }\n+    fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n+        Edge { from: from, to: to, label: label, style: style }\n     }\n \n     struct LabelledGraph {\n@@ -624,6 +695,8 @@ mod tests {\n         /// text.\n         node_labels: Vec<Option<&'static str>>,\n \n+        node_styles: Vec<Style>,\n+\n         /// Each edge relates a from-index to a to-index along with a\n         /// label; `edges` collects them.\n         edges: Vec<Edge>,\n@@ -647,24 +720,38 @@ mod tests {\n         fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n             match self {\n                 UnlabelledNodes(len)\n-                    => repeat(None).take(len).collect(),\n+                    => vec![None; len],\n                 AllNodesLabelled(lbls)\n                     => lbls.into_iter().map(\n                         |l|Some(l)).collect(),\n                 SomeNodesLabelled(lbls)\n                     => lbls.into_iter().collect(),\n             }\n         }\n+\n+        fn len(&self) -> usize {\n+            match self {\n+                &UnlabelledNodes(len) => len,\n+                &AllNodesLabelled(ref lbls) => lbls.len(),\n+                &SomeNodesLabelled(ref lbls) => lbls.len(),\n+            }\n+        }\n     }\n \n     impl LabelledGraph {\n         fn new(name: &'static str,\n                node_labels: Trivial,\n-               edges: Vec<Edge>) -> LabelledGraph {\n+               edges: Vec<Edge>,\n+               node_styles: Option<Vec<Style>>) -> LabelledGraph {\n+            let count = node_labels.len();\n             LabelledGraph {\n                 name: name,\n                 node_labels: node_labels.to_opt_strs(),\n-                edges: edges\n+                edges: edges,\n+                node_styles: match node_styles {\n+                    Some(nodes) => nodes,\n+                    None => vec![Style::None; count],\n+                }\n             }\n         }\n     }\n@@ -674,7 +761,10 @@ mod tests {\n                node_labels: Trivial,\n                edges: Vec<Edge>) -> LabelledGraphWithEscStrs {\n             LabelledGraphWithEscStrs {\n-                graph: LabelledGraph::new(name, node_labels, edges)\n+                graph: LabelledGraph::new(name,\n+                                          node_labels,\n+                                          edges,\n+                                          None)\n             }\n         }\n     }\n@@ -699,6 +789,12 @@ mod tests {\n         fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n             LabelStr(e.label.into_cow())\n         }\n+        fn node_style(&'a self, n: &Node) -> Style {\n+            self.node_styles[*n]\n+        }\n+        fn edge_style(&'a self, e: & &'a Edge) -> Style {\n+            e.style\n+        }\n     }\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n@@ -761,7 +857,7 @@ mod tests {\n     #[test]\n     fn empty_graph() {\n         let labels : Trivial = UnlabelledNodes(0);\n-        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec!()));\n+        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph empty_graph {\n }\n@@ -771,19 +867,31 @@ r#\"digraph empty_graph {\n     #[test]\n     fn single_node() {\n         let labels : Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec!()));\n+        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph single_node {\n     N0[label=\"N0\"];\n }\n \"#);\n     }\n \n+    #[test]\n+    fn single_node_with_style() {\n+        let labels : Trivial = UnlabelledNodes(1);\n+        let styles = Some(vec![Style::Dashed]);\n+        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n+        assert_eq!(r.unwrap(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"][style=\"dashed\"];\n+}\n+\"#);\n+    }\n+\n     #[test]\n     fn single_edge() {\n         let labels : Trivial = UnlabelledNodes(2);\n         let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n-                                                   vec!(edge(0, 1, \"E\"))));\n+                                                   vec![edge(0, 1, \"E\", Style::None)], None));\n         assert_eq!(result.unwrap(),\n r#\"digraph single_edge {\n     N0[label=\"N0\"];\n@@ -793,15 +901,30 @@ r#\"digraph single_edge {\n \"#);\n     }\n \n+    #[test]\n+    fn single_edge_with_style() {\n+        let labels : Trivial = UnlabelledNodes(2);\n+        let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n+                                                   vec![edge(0, 1, \"E\", Style::Bold)], None));\n+        assert_eq!(result.unwrap(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"][style=\"bold\"];\n+}\n+\"#);\n+    }\n+\n     #[test]\n     fn test_some_labelled() {\n         let labels : Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n+        let styles = Some(vec![Style::None, Style::Dotted]);\n         let result = test_input(LabelledGraph::new(\"test_some_labelled\", labels,\n-                                                   vec![edge(0, 1, \"A-1\")]));\n+                                                   vec![edge(0, 1, \"A-1\", Style::None)], styles));\n         assert_eq!(result.unwrap(),\n r#\"digraph test_some_labelled {\n     N0[label=\"A\"];\n-    N1[label=\"N1\"];\n+    N1[label=\"N1\"][style=\"dotted\"];\n     N0 -> N1[label=\"A-1\"];\n }\n \"#);\n@@ -811,7 +934,7 @@ r#\"digraph test_some_labelled {\n     fn single_cyclic_node() {\n         let labels : Trivial = UnlabelledNodes(1);\n         let r = test_input(LabelledGraph::new(\"single_cyclic_node\", labels,\n-                                              vec!(edge(0, 0, \"E\"))));\n+                                              vec![edge(0, 0, \"E\", Style::None)], None));\n         assert_eq!(r.unwrap(),\n r#\"digraph single_cyclic_node {\n     N0[label=\"N0\"];\n@@ -825,8 +948,9 @@ r#\"digraph single_cyclic_node {\n         let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n         let r = test_input(LabelledGraph::new(\n             \"hasse_diagram\", labels,\n-            vec!(edge(0, 1, \"\"), edge(0, 2, \"\"),\n-                 edge(1, 3, \"\"), edge(2, 3, \"\"))));\n+            vec![edge(0, 1, \"\", Style::None), edge(0, 2, \"\", Style::None),\n+                 edge(1, 3, \"\", Style::None), edge(2, 3, \"\", Style::None)],\n+            None));\n         assert_eq!(r.unwrap(),\n r#\"digraph hasse_diagram {\n     N0[label=\"{x,y}\"];\n@@ -859,8 +983,8 @@ r#\"digraph hasse_diagram {\n \n         let g = LabelledGraphWithEscStrs::new(\n             \"syntax_tree\", labels,\n-            vec!(edge(0, 1, \"then\"), edge(0, 2, \"else\"),\n-                 edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n+            vec![edge(0, 1, \"then\", Style::None), edge(0, 2, \"else\", Style::None),\n+                 edge(1, 3, \";\", Style::None),    edge(2, 3, \";\", Style::None)]);\n \n         render(&g, &mut writer).unwrap();\n         let mut r = String::new();"}, {"sha": "c229df34ccf8918ab1f51c9c16ffd35d92e5df43", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 153, "deletions": 16, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -960,6 +960,100 @@ pub mod types {\n             }\n         }\n \n+        #[cfg(target_arch = \"x86\")]\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i32;\n+                pub type c_ulong = u32;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u32;\n+                pub type ptrdiff_t = i32;\n+                pub type clock_t = i32;\n+                pub type time_t = i32;\n+                pub type suseconds_t = i32;\n+                pub type wchar_t = i32;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = i32;\n+                pub type uintptr_t = u32;\n+                pub type intmax_t = i64;\n+                pub type uintmax_t = u64;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i64;\n+                pub type dev_t = u32;\n+                pub type ino_t = u32;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u16;\n+                pub type ssize_t = i32;\n+            }\n+            pub mod posix01 {\n+                use types::common::c95::{c_void};\n+                use types::common::c99::{uint8_t, uint32_t, int32_t};\n+                use types::os::arch::c95::{c_long, time_t};\n+                use types::os::arch::posix88::{dev_t, gid_t, ino_t};\n+                use types::os::arch::posix88::{mode_t, off_t};\n+                use types::os::arch::posix88::{uid_t};\n+\n+                pub type nlink_t = u16;\n+                pub type blksize_t = i32;\n+                pub type blkcnt_t = i64;\n+                pub type fflags_t = u32;\n+                #[repr(C)]\n+                #[derive(Copy, Clone)] pub struct stat {\n+                    pub st_dev: dev_t,\n+                    pub st_ino: ino_t,\n+                    pub st_mode: mode_t,\n+                    pub st_nlink: nlink_t,\n+                    pub st_uid: uid_t,\n+                    pub st_gid: gid_t,\n+                    pub st_rdev: dev_t,\n+                    pub st_atime: time_t,\n+                    pub st_atime_nsec: c_long,\n+                    pub st_mtime: time_t,\n+                    pub st_mtime_nsec: c_long,\n+                    pub st_ctime: time_t,\n+                    pub st_ctime_nsec: c_long,\n+                    pub st_size: off_t,\n+                    pub st_blocks: blkcnt_t,\n+                    pub st_blksize: blksize_t,\n+                    pub st_flags: fflags_t,\n+                    pub st_gen: uint32_t,\n+                    pub st_lspare: int32_t,\n+                    pub st_birthtime: time_t,\n+                    pub st_birthtime_nsec: c_long,\n+                    pub __unused: [uint8_t; 2],\n+                }\n+\n+                #[repr(C)]\n+                #[derive(Copy, Clone)] pub struct utimbuf {\n+                    pub actime: time_t,\n+                    pub modtime: time_t,\n+                }\n+\n+                pub type pthread_attr_t = *mut c_void;\n+            }\n+            pub mod posix08 {\n+            }\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n+            }\n+        }\n+\n         #[cfg(target_arch = \"x86_64\")]\n         pub mod arch {\n             pub mod c95 {\n@@ -1322,7 +1416,7 @@ pub mod types {\n         }\n     }\n \n-    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os =\"openbsd\"))]\n     pub mod os {\n         pub mod common {\n             pub mod posix01 {\n@@ -1351,7 +1445,7 @@ pub mod types {\n                     pub __unused7: *mut c_void,\n                 }\n \n-                #[cfg(target_os = \"openbsd\")]\n+                #[cfg(any(target_os = \"netbsd\", target_os=\"openbsd\"))]\n                 #[repr(C)]\n                 #[derive(Copy, Clone)] pub struct glob_t {\n                     pub gl_pathc:  c_int,\n@@ -2522,6 +2616,7 @@ pub mod consts {\n             pub const S_IFDIR : c_int = 16384;\n             pub const S_IFREG : c_int = 32768;\n             pub const S_IFLNK : c_int = 40960;\n+            pub const S_IFSOCK : mode_t = 49152;\n             pub const S_IFMT : c_int = 61440;\n             pub const S_IEXEC : c_int = 64;\n             pub const S_IWRITE : c_int = 128;\n@@ -2881,6 +2976,7 @@ pub mod consts {\n             pub const S_IFDIR : mode_t = 16384;\n             pub const S_IFREG : mode_t = 32768;\n             pub const S_IFLNK : mode_t = 40960;\n+            pub const S_IFSOCK : mode_t = 49152;\n             pub const S_IFMT : mode_t = 61440;\n             pub const S_IEXEC : mode_t = 64;\n             pub const S_IWRITE : mode_t = 128;\n@@ -3103,6 +3199,7 @@ pub mod consts {\n             pub const S_IFDIR : mode_t = 16384;\n             pub const S_IFREG : mode_t = 32768;\n             pub const S_IFLNK : mode_t = 40960;\n+            pub const S_IFSOCK : mode_t = 49152;\n             pub const S_IFMT : mode_t = 61440;\n             pub const S_IEXEC : mode_t = 64;\n             pub const S_IWRITE : mode_t = 128;\n@@ -3600,6 +3697,11 @@ pub mod consts {\n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n             pub const SHUT_RDWR: c_int = 2;\n+\n+            pub const LOCK_SH: c_int = 1;\n+            pub const LOCK_EX: c_int = 2;\n+            pub const LOCK_NB: c_int = 4;\n+            pub const LOCK_UN: c_int = 8;\n         }\n         #[cfg(any(target_arch = \"mips\",\n                   target_arch = \"mipsel\"))]\n@@ -3684,6 +3786,11 @@ pub mod consts {\n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n             pub const SHUT_RDWR: c_int = 2;\n+\n+            pub const LOCK_SH: c_int = 1;\n+            pub const LOCK_EX: c_int = 2;\n+            pub const LOCK_NB: c_int = 4;\n+            pub const LOCK_UN: c_int = 8;\n         }\n         #[cfg(any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n@@ -3895,6 +4002,7 @@ pub mod consts {\n             pub const S_IFDIR : mode_t = 16384;\n             pub const S_IFREG : mode_t = 32768;\n             pub const S_IFLNK : mode_t = 40960;\n+            pub const S_IFSOCK : mode_t = 49152;\n             pub const S_IFMT : mode_t = 61440;\n             pub const S_IEXEC : mode_t = 64;\n             pub const S_IWRITE : mode_t = 128;\n@@ -4227,6 +4335,11 @@ pub mod consts {\n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n             pub const SHUT_RDWR: c_int = 2;\n+\n+            pub const LOCK_SH: c_int = 1;\n+            pub const LOCK_EX: c_int = 2;\n+            pub const LOCK_NB: c_int = 4;\n+            pub const LOCK_UN: c_int = 8;\n         }\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n@@ -4308,7 +4421,7 @@ pub mod consts {\n         }\n     }\n \n-    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"))]\n     pub mod os {\n         pub mod c95 {\n             use types::os::arch::c95::{c_int, c_uint};\n@@ -4350,6 +4463,7 @@ pub mod consts {\n             pub const S_IFDIR : mode_t = 16384;\n             pub const S_IFREG : mode_t = 32768;\n             pub const S_IFLNK : mode_t = 40960;\n+            pub const S_IFSOCK : mode_t = 49152;\n             pub const S_IFMT : mode_t = 61440;\n             pub const S_IEXEC : mode_t = 64;\n             pub const S_IWRITE : mode_t = 128;\n@@ -4651,6 +4765,11 @@ pub mod consts {\n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n             pub const SHUT_RDWR: c_int = 2;\n+\n+            pub const LOCK_SH: c_int = 1;\n+            pub const LOCK_EX: c_int = 2;\n+            pub const LOCK_NB: c_int = 4;\n+            pub const LOCK_UN: c_int = 8;\n         }\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n@@ -4771,6 +4890,7 @@ pub mod consts {\n             pub const S_IFDIR : mode_t = 16384;\n             pub const S_IFREG : mode_t = 32768;\n             pub const S_IFLNK : mode_t = 40960;\n+            pub const S_IFSOCK : mode_t = 49152;\n             pub const S_IFMT : mode_t = 61440;\n             pub const S_IEXEC : mode_t = 64;\n             pub const S_IWRITE : mode_t = 128;\n@@ -4952,6 +5072,8 @@ pub mod consts {\n             pub const F_GETFL : c_int = 3;\n             pub const F_SETFL : c_int = 4;\n \n+            pub const O_ACCMODE : c_int = 3;\n+\n             pub const SIGTRAP : c_int = 5;\n             pub const SIG_IGN: size_t = 1;\n \n@@ -5092,13 +5214,19 @@ pub mod consts {\n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n             pub const SHUT_RDWR: c_int = 2;\n+\n+            pub const LOCK_SH: c_int = 1;\n+            pub const LOCK_EX: c_int = 2;\n+            pub const LOCK_NB: c_int = 4;\n+            pub const LOCK_UN: c_int = 8;\n         }\n         pub mod extra {\n             use types::os::arch::c95::c_int;\n \n             pub const O_DSYNC : c_int = 4194304;\n             pub const O_SYNC : c_int = 128;\n             pub const O_NONBLOCK : c_int = 4;\n+            pub const F_GETPATH : c_int = 50;\n             pub const F_FULLFSYNC : c_int = 51;\n \n             pub const MAP_COPY : c_int = 0x0002;\n@@ -5120,6 +5248,8 @@ pub mod consts {\n             pub const SO_DONTTRUNC: c_int = 0x2000;\n             pub const SO_WANTMORE: c_int = 0x4000;\n             pub const SO_WANTOOBFLAG: c_int = 0x8000;\n+\n+            pub const PATH_MAX: c_int = 1024;\n         }\n         pub mod sysconf {\n             use types::os::arch::c95::c_int;\n@@ -5543,6 +5673,7 @@ pub mod funcs {\n               target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n               target_os = \"bitrig\",\n+              target_os = \"netbsd\",\n               target_os = \"openbsd\",\n               target_os = \"nacl\"))]\n     pub mod posix88 {\n@@ -5559,6 +5690,7 @@ pub mod funcs {\n                           target_os = \"freebsd\",\n                           target_os = \"dragonfly\",\n                           target_os = \"bitrig\",\n+                          target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                           target_os = \"android\",\n                           target_os = \"ios\",\n@@ -5577,6 +5709,7 @@ pub mod funcs {\n                           target_os = \"freebsd\",\n                           target_os = \"dragonfly\",\n                           target_os = \"bitrig\",\n+                          target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                           target_os = \"android\",\n                           target_os = \"ios\",\n@@ -5864,6 +5997,7 @@ pub mod funcs {\n               target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n               target_os = \"bitrig\",\n+              target_os = \"netbsd\",\n               target_os = \"openbsd\",\n               target_os = \"nacl\"))]\n     pub mod posix01 {\n@@ -5876,6 +6010,7 @@ pub mod funcs {\n                           target_os = \"freebsd\",\n                           target_os = \"dragonfly\",\n                           target_os = \"bitrig\",\n+                          target_os = \"netbsd\",\n                           target_os = \"openbsd\",\n                           target_os = \"android\",\n                           target_os = \"ios\",\n@@ -5994,16 +6129,17 @@ pub mod funcs {\n     }\n \n \n-    #[cfg(any(target_os = \"windows\",\n-              target_os = \"linux\",\n-              target_os = \"android\",\n-              target_os = \"macos\",\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"bitrig\",\n+              target_os = \"dragonfly\",\n               target_os = \"ios\",\n               target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n+              target_os = \"linux\",\n+              target_os = \"macos\",\n+              target_os = \"nacl\",\n+              target_os = \"netbsd\",\n               target_os = \"openbsd\",\n-              target_os = \"nacl\"))]\n+              target_os = \"windows\"))]\n     pub mod posix08 {\n         pub mod unistd {\n         }\n@@ -6090,13 +6226,14 @@ pub mod funcs {\n               target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n               target_os = \"bitrig\",\n+              target_os = \"netbsd\",\n               target_os = \"openbsd\"))]\n     pub mod bsd44 {\n         use types::common::c95::{c_void};\n         use types::os::arch::c95::{c_char, c_uchar, c_int, c_uint, c_ulong, size_t};\n \n         extern {\n-            pub fn ioctl(d: c_int, request: c_ulong, ...) -> c_int;\n+            pub fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;\n             pub fn sysctl(name: *mut c_int,\n                           namelen: c_uint,\n                           oldp: *mut c_void,\n@@ -6121,22 +6258,24 @@ pub mod funcs {\n                            -> c_int;\n             pub fn realpath(pathname: *const c_char, resolved: *mut c_char)\n                             -> *mut c_char;\n+            pub fn flock(fd: c_int, operation: c_int) -> c_int;\n         }\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     pub mod bsd44 {\n         use types::common::c95::{c_void};\n-        use types::os::arch::c95::{c_uchar, c_int, size_t};\n+        use types::os::arch::c95::{c_uchar, c_int, c_ulong, size_t};\n \n         extern {\n             #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n             pub fn getdtablesize() -> c_int;\n-            pub fn ioctl(d: c_int, request: c_int, ...) -> c_int;\n+            pub fn ioctl(fd: c_int, request: c_ulong, ...) -> c_int;\n             pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int)\n                            -> c_int;\n             pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar)\n                            -> c_int;\n+            pub fn flock(fd: c_int, operation: c_int) -> c_int;\n         }\n     }\n \n@@ -6165,6 +6304,7 @@ pub mod funcs {\n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n               target_os = \"bitrig\",\n+              target_os = \"netbsd\",\n               target_os = \"openbsd\"))]\n     pub mod extra {\n     }\n@@ -6395,7 +6535,4 @@ pub mod funcs {\n     }\n }\n \n-#[doc(hidden)]\n-pub fn issue_14344_workaround() {} // FIXME #14344 force linkage to happen correctly\n-\n #[test] fn work_on_windows() { } // FIXME #10872 needed for a happy windows"}, {"sha": "dce114d1fc21bf48206761f5a3466e8a2fa3bbf3", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -58,6 +58,7 @@ impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n /// The helper trait for types that have a sensible way to sample\n /// uniformly between two values. This should not be used directly,\n /// and is only to facilitate `Range`.\n+#[doc(hidden)]\n pub trait SampleRange {\n     /// Construct the `Range` object that `sample_range`\n     /// requires. This should not ever be called directly, only via"}, {"sha": "1b2210c89edcb04af85df8d7e2d430319f4c1928", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -126,7 +126,6 @@ impl IsaacRng {\n \n     /// Refills the output buffer (`self.rsl`)\n     #[inline]\n-    #[allow(unsigned_negation)]\n     fn isaac(&mut self) {\n         self.c = self.c + w(1);\n         // abbreviations"}, {"sha": "2f76aa53f83ae171534ce5ff803c89bed5cdeed5", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -66,6 +66,7 @@ pub mod reseeding;\n mod rand_impls;\n \n /// A type that can be randomly generated using an `Rng`.\n+#[doc(hidden)]\n pub trait Rand : Sized {\n     /// Generates a random instance of this type using the specified source of\n     /// randomness."}, {"sha": "73ff51da290d83868974d7445a6d37327a254e5b", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -186,7 +186,7 @@ mod tests {\n     const FILL_BYTES_V_LEN: usize = 13579;\n     #[test]\n     fn test_rng_fill_bytes() {\n-        let mut v = repeat(0).take(FILL_BYTES_V_LEN).collect::<Vec<_>>();\n+        let mut v = vec![0; FILL_BYTES_V_LEN];\n         ::test::rng().fill_bytes(&mut v);\n \n         // Sanity test: if we've gotten here, `fill_bytes` has not infinitely"}, {"sha": "10552791d8b86731d2098d9f03c0a37c3884a0fa", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 158, "deletions": 34, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -119,9 +119,10 @@ pub enum Node<'ast> {\n     NodeStructCtor(&'ast StructDef),\n \n     NodeLifetime(&'ast Lifetime),\n+    NodeTyParam(&'ast TyParam)\n }\n \n-/// Represents an entry and its parent Node ID\n+/// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n enum MapEntry<'ast> {\n@@ -142,6 +143,7 @@ enum MapEntry<'ast> {\n     EntryBlock(NodeId, &'ast Block),\n     EntryStructCtor(NodeId, &'ast StructDef),\n     EntryLifetime(NodeId, &'ast Lifetime),\n+    EntryTyParam(NodeId, &'ast TyParam),\n \n     /// Roots for node trees.\n     RootCrate,\n@@ -175,11 +177,12 @@ impl<'ast> MapEntry<'ast> {\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n             NodeStructCtor(n) => EntryStructCtor(p, n),\n-            NodeLifetime(n) => EntryLifetime(p, n)\n+            NodeLifetime(n) => EntryLifetime(p, n),\n+            NodeTyParam(n) => EntryTyParam(p, n),\n         }\n     }\n \n-    fn parent(self) -> Option<NodeId> {\n+    fn parent_node(self) -> Option<NodeId> {\n         Some(match self {\n             EntryItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n@@ -194,6 +197,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n             EntryLifetime(id, _) => id,\n+            EntryTyParam(id, _) => id,\n             _ => return None\n         })\n     }\n@@ -213,6 +217,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryBlock(_, n) => NodeBlock(n),\n             EntryStructCtor(_, n) => NodeStructCtor(n),\n             EntryLifetime(_, n) => NodeLifetime(n),\n+            EntryTyParam(_, n) => NodeTyParam(n),\n             _ => return None\n         })\n     }\n@@ -283,10 +288,88 @@ impl<'ast> Map<'ast> {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n-    /// Retrieve the parent NodeId for `id`, or `id` itself if no\n-    /// parent is registered in this map.\n+    /// Similar to get_parent, returns the parent node id or id if there is no\n+    /// parent.\n+    /// This function returns the immediate parent in the AST, whereas get_parent\n+    /// returns the enclosing item. Note that this might not be the actual parent\n+    /// node in the AST - some kinds of nodes are not in the map and these will\n+    /// never appear as the parent_node. So you can always walk the parent_nodes\n+    /// from a node to the root of the ast (unless you get the same id back here\n+    /// that can happen if the id is not in the map itself or is just weird).\n+    pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n+    }\n+\n+    /// If there is some error when walking the parents (e.g., a node does not\n+    /// have a parent in the map or a node can't be found), then we return the\n+    /// last good node id we found. Note that reaching the crate root (id == 0),\n+    /// is not an error, since items in the crate module have the crate root as\n+    /// parent.\n+    fn walk_parent_nodes<F>(&self, start_id: NodeId, found: F) -> Result<NodeId, NodeId>\n+        where F: Fn(&Node<'ast>) -> bool\n+    {\n+        let mut id = start_id;\n+        loop {\n+            let parent_node = self.get_parent_node(id);\n+            if parent_node == 0 {\n+                return Ok(0);\n+            }\n+            if parent_node == id {\n+                return Err(id);\n+            }\n+\n+            let node = self.find_entry(parent_node);\n+            if node.is_none() {\n+                return Err(id);\n+            }\n+            let node = node.unwrap().to_node();\n+            match node {\n+                Some(ref node) => {\n+                    if found(node) {\n+                        return Ok(parent_node);\n+                    }\n+                }\n+                None => {\n+                    return Err(parent_node);\n+                }\n+            }\n+            id = parent_node;\n+        }\n+    }\n+\n+    /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n+    /// parent item is in this map. The \"parent item\" is the closest parent node\n+    /// in the AST which is recorded by the map and is an item, either an item\n+    /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        self.find_entry(id).and_then(|x| x.parent()).unwrap_or(id)\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(_) |\n+            NodeForeignItem(_) |\n+            NodeTraitItem(_) |\n+            NodeImplItem(_) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => id,\n+            Err(id) => id,\n+        }\n+    }\n+\n+    /// Returns the nearest enclosing scope. A scope is an item or block.\n+    /// FIXME it is not clear to me that all items qualify as scopes - statics\n+    /// and associated types probably shouldn't, for example. Behaviour in this\n+    /// regard should be expected to be highly unstable.\n+    pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(_) |\n+            NodeForeignItem(_) |\n+            NodeTraitItem(_) |\n+            NodeImplItem(_) |\n+            NodeBlock(_) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => Some(id),\n+            Err(_) => None,\n+        }\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n@@ -333,6 +416,13 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expect_trait_item(&self, id: NodeId) -> &'ast TraitItem {\n+        match self.find(id) {\n+            Some(NodeTraitItem(item)) => item,\n+            _ => panic!(\"expected trait item, found {}\", self.node_to_string(id))\n+        }\n+    }\n+\n     pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n@@ -413,9 +503,8 @@ impl<'ast> Map<'ast> {\n     {\n         let parent = self.get_parent(id);\n         let parent = match self.find_entry(id) {\n-            Some(EntryForeignItem(..)) | Some(EntryVariant(..)) => {\n-                // Anonymous extern items, enum variants and struct ctors\n-                // go in the parent scope.\n+            Some(EntryForeignItem(..)) => {\n+                // Anonymous extern items go in the parent scope.\n                 self.get_parent(parent)\n             }\n             // But tuple struct ctors don't have names, so use the path of its\n@@ -489,6 +578,7 @@ impl<'ast> Map<'ast> {\n             Some(NodePat(pat)) => pat.span,\n             Some(NodeBlock(block)) => block.span,\n             Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(NodeTyParam(ty_param)) => ty_param.span,\n             _ => return None,\n         };\n         Some(sp)\n@@ -590,15 +680,15 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n                 return None;\n             }\n             self.idx += 1;\n-            let (p, name) = match self.map.find_entry(idx) {\n-                Some(EntryItem(p, n))       => (p, n.name()),\n-                Some(EntryForeignItem(p, n))=> (p, n.name()),\n-                Some(EntryTraitItem(p, n))  => (p, n.name()),\n-                Some(EntryImplItem(p, n))   => (p, n.name()),\n-                Some(EntryVariant(p, n))    => (p, n.name()),\n+            let name = match self.map.find_entry(idx) {\n+                Some(EntryItem(_, n))       => n.name(),\n+                Some(EntryForeignItem(_, n))=> n.name(),\n+                Some(EntryTraitItem(_, n))  => n.name(),\n+                Some(EntryImplItem(_, n))   => n.name(),\n+                Some(EntryVariant(_, n))    => n.name(),\n                 _ => continue,\n             };\n-            if self.matches_names(p, name) {\n+            if self.matches_names(self.map.get_parent(idx), name) {\n                 return Some(idx)\n             }\n         }\n@@ -647,8 +737,7 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n /// A Visitor that walks over an AST and collects Node's into an AST Map.\n struct NodeCollector<'ast> {\n     map: Vec<MapEntry<'ast>>,\n-    /// The node in which we are currently mapping (an item or a method).\n-    parent: NodeId\n+    parent_node: NodeId,\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -662,7 +751,7 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n-        let entry = MapEntry::from_node(self.parent, node);\n+        let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n \n@@ -676,8 +765,10 @@ impl<'ast> NodeCollector<'ast> {\n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n         self.insert(i.id, NodeItem(i));\n-        let parent = self.parent;\n-        self.parent = i.id;\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = i.id;\n+\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for ii in impl_items {\n@@ -727,21 +818,31 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             _ => {}\n         }\n         visit::walk_item(self, i);\n-        self.parent = parent;\n+        self.parent_node = parent_node;\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'ast Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            self.insert(ty_param.id, NodeTyParam(ty_param));\n+        }\n+\n+        visit::walk_generics(self, generics);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let parent = self.parent;\n-        self.parent = ti.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n         visit::walk_trait_item(self, ti);\n-        self.parent = parent;\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let parent = self.parent;\n-        self.parent = ii.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n+\n         visit::walk_impl_item(self, ii);\n-        self.parent = parent;\n+\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n@@ -750,38 +851,58 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             PatIdent(..) => NodeLocal(pat),\n             _ => NodePat(pat)\n         });\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = pat.id;\n         visit::walk_pat(self, pat);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n+        let parent_node = self.parent_node;\n+        self.parent_node = expr.id;\n         visit::walk_expr(self, expr);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n+        let id = ast_util::stmt_id(stmt);\n+        self.insert(id, NodeStmt(stmt));\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n         visit::walk_stmt(self, stmt);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, _: NodeId) {\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n         self.visit_fn_decl(fd);\n         visit::walk_fn(self, fk, fd, b, s);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_ty(&mut self, ty: &'ast Ty) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = ty.id;\n         match ty.node {\n             TyBareFn(ref fd) => {\n                 self.visit_fn_decl(&*fd.decl);\n             }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_block(&mut self, block: &'ast Block) {\n         self.insert(block.id, NodeBlock(block));\n+        let parent_node = self.parent_node;\n+        self.parent_node = block.id;\n         visit::walk_block(self, block);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime: &'ast Lifetime) {\n@@ -809,7 +930,7 @@ pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map\n \n     let mut collector = NodeCollector {\n         map: vec![],\n-        parent: CRATE_NODE_ID\n+        parent_node: CRATE_NODE_ID,\n     };\n     collector.insert_entry(CRATE_NODE_ID, RootCrate);\n     visit::walk_crate(&mut collector, &forest.krate);\n@@ -864,11 +985,11 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         ii: ii\n     });\n \n+    let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n     let mut collector = NodeCollector {\n         map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-        parent: fld.new_id(DUMMY_NODE_ID)\n+        parent_node: ii_parent_id,\n     };\n-    let ii_parent_id = collector.parent;\n     collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n     visit::walk_inlined_item(&mut collector, &ii_parent.ii);\n \n@@ -908,7 +1029,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodePat(a)         => self.print_pat(&*a),\n             NodeBlock(a)       => self.print_block(&*a),\n             NodeLifetime(a)    => self.print_lifetime(&*a),\n-\n+            NodeTyParam(_)     => panic!(\"cannot print TyParam\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n@@ -1016,6 +1137,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             format!(\"lifetime {}{}\",\n                     pprust::lifetime_to_string(&**l), id_str)\n         }\n+        Some(NodeTyParam(ref ty_param)) => {\n+            format!(\"typaram {:?}{}\", ty_param, id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "768f792d269a8cd7cf52c2d9808a2cb78ee0d5a9", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 943, "deletions": 46, "changes": 989, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -22,6 +22,22 @@ matched, one of the preceding patterns will match.\n \n This means that perhaps some of the preceding patterns are too general, this one\n is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```\n+match foo {\n+    Some(bar) => {/* ... */}\n+    None => {/* ... */}\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms.\n \"##,\n \n E0002: r##\"\n@@ -31,13 +47,50 @@ it is impossible to create an instance of an empty type, so empty match\n expressions are almost never desired.  This error is typically fixed by adding\n one or more cases to the match expression.\n \n-An example of an empty type is `enum Empty { }`.\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n \"##,\n \n E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. To match against NaN values, you should\n-instead use the `is_nan` method in a guard, as in: `x if x.is_nan() => ...`\n+match the input to a match expression. So, the following will not compile:\n+\n+```\n+const NAN: f32 = 0.0 / 0.0;\n+\n+match number {\n+    NAN => { /* ... */ },\n+    // ...\n+}\n+```\n+\n+To match against NaN values, you should instead use the `is_nan()` method in a\n+guard, like so:\n+\n+```\n+match number {\n+    // ...\n+    x if x.is_nan() => { /* ... */ }\n+    // ...\n+}\n+```\n \"##,\n \n E0004: r##\"\n@@ -53,21 +106,13 @@ underscore `_` wildcard pattern can be added after all other patterns to match\n \"anything else\".\n \"##,\n \n-// FIXME: Remove duplication here?\n E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n that a name will be extracted in all cases. If you encounter this error you\n probably need to use a `match` or `if let` to deal with the possibility of\n failure.\n \"##,\n \n-E0006: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. If you encounter this error you\n-probably need to use a `match` or `if let` to deal with the possibility of\n-failure.\n-\"##,\n-\n E0007: r##\"\n This error indicates that the bindings in a match arm would require a value to\n be moved into more than one location, thus violating unique ownership. Code like\n@@ -271,6 +316,28 @@ const FOO: i32 = { const X : i32 = 0; X };\n ```\n \"##,\n \n+E0017: r##\"\n+References in statics and constants may only refer to immutable values. Example:\n+\n+```\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &'static mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\n+\"##,\n+\n E0018: r##\"\n The value of static and const variables must be known at compile time. You\n can't cast a pointer as an integer because we can't know what value the\n@@ -318,7 +385,7 @@ fn main() {\n ```\n \n Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it elsewhere you want:\n+expression! However, you can totally use it anywhere else:\n \n ```\n fn main() {\n@@ -335,10 +402,333 @@ This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression.\n \"##,\n \n+E0022: r##\"\n+Constant functions are not allowed to mutate anything. Thus, binding to an\n+argument with a mutable pattern is not allowed. For example,\n+\n+```\n+const fn foo(mut x: u8) {\n+    // do stuff\n+}\n+```\n+\n+is bad because the function body may not mutate `x`.\n+\n+Remove any mutable bindings from the argument list to fix this error. In case\n+you need to mutate the argument, try lazily initializing a global variable\n+instead of using a `const fn`, or refactoring the code to a functional style to\n+avoid mutation if possible.\n+\"##,\n+\n+E0030: r##\"\n+When matching against a range, the compiler verifies that the range is\n+non-empty.  Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+For example:\n+\n+```\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ... 1 => ...\n+    // This range is empty, and the compiler can tell.\n+    1000 ... 5 => ...\n+}\n+```\n+\"##,\n+\n+E0038: r####\"\n+Trait objects like `Box<Trait>` can only be constructed when certain\n+requirements are satisfied by the trait in question.\n+\n+Trait objects are a form of dynamic dispatch and use a dynamically sized type\n+for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n+type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n+pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n+(among other things) for dynamic dispatch. This design mandates some\n+restrictions on the types of traits that are allowed to be used in trait\n+objects, which are collectively termed as 'object safety' rules.\n+\n+Attempting to create a trait object for a non object-safe trait will trigger\n+this error.\n+\n+There are various rules:\n+\n+### The trait cannot require `Self: Sized`\n+\n+When `Trait` is treated as a type, the type does not implement the special\n+`Sized` trait, because the type does not have a known size at compile time and\n+can only be accessed behind a pointer. Thus, if we have a trait like the\n+following:\n+\n+```\n+trait Foo where Self: Sized {\n+\n+}\n+```\n+\n+we cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+`Self` would not be `Sized`.\n+\n+Generally, `Self : Sized` is used to indicate that the trait should not be used\n+as a trait object. If the trait comes from your own crate, consider removing\n+this restriction.\n+\n+### Method references the `Self` type in its arguments or return type\n+\n+This happens when a trait has a method like the following:\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n+impl Trait for String {\n+    fn foo(&self) -> Self {\n+        \"hi\".to_owned()\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) -> Self {\n+        1\n+    }\n+}\n+```\n+\n+(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n+cause this problem)\n+\n+In such a case, the compiler cannot predict the return type of `foo()` in a\n+situation like the following:\n+\n+```\n+fn call_foo(x: Box<Trait>) {\n+    let y = x.foo(); // What type is y?\n+    // ...\n+}\n+```\n+\n+If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n+on them to mark them as explicitly unavailable to trait objects. The\n+functionality will still be available to all other implementers, including\n+`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self where Self: Sized;\n+    // more functions\n+}\n+```\n+\n+Now, `foo()` can no longer be called on a trait object, but you will now be\n+allowed to make a trait object, and that will be able to call any object-safe\n+methods\". With such a bound, one can still call `foo()` on types implementing\n+that trait that aren't behind trait objects.\n+\n+### Method has generic type parameters\n+\n+As mentioned before, trait objects contain pointers to method tables. So, if we\n+have:\n+\n+```\n+trait Trait {\n+    fn foo(&self);\n+}\n+impl Trait for String {\n+    fn foo(&self) {\n+        // implementation 1\n+    }\n+}\n+impl Trait for u8 {\n+    fn foo(&self) {\n+        // implementation 2\n+    }\n+}\n+// ...\n+```\n+\n+At compile time each implementation of `Trait` will produce a table containing\n+the various methods (and other items) related to the implementation.\n+\n+This works fine, but when the method gains generic parameters, we can have a\n+problem.\n+\n+Usually, generic parameters get _monomorphized_. For example, if I have\n+\n+```\n+fn foo<T>(x: T) {\n+    // ...\n+}\n+```\n+\n+the machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n+other type substitution is different. Hence the compiler generates the\n+implementation on-demand. If you call `foo()` with a `bool` parameter, the\n+compiler will only generate code for `foo::<bool>()`. When we have additional\n+type parameters, the number of monomorphized implementations the compiler\n+generates does not grow drastically, since the compiler will only generate an\n+implementation if the function is called with unparametrized substitutions\n+(i.e., substitutions where none of the substituted types are themselves\n+parametrized).\n+\n+However, with trait objects we have to make a table containing _every_ object\n+that implements the trait. Now, if it has type parameters, we need to add\n+implementations for every type that implements the trait, and there could\n+theoretically be an infinite number of types.\n+\n+For example, with:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T);\n+    // more methods\n+}\n+impl Trait for String {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 1\n+    }\n+}\n+impl Trait for u8 {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 2\n+    }\n+}\n+// 8 more implementations\n+```\n+\n+Now, if we have the following code:\n+\n+```\n+fn call_foo(thing: Box<Trait>) {\n+    thing.foo(true); // this could be any one of the 8 types above\n+    thing.foo(1);\n+    thing.foo(\"hello\");\n+}\n+```\n+\n+we don't just need to create a table of all implementations of all methods of\n+`Trait`, we need to create such a table, for each different type fed to\n+`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n+types being fed to `foo()`) = 30 implementations!\n+\n+With real world traits these numbers can grow drastically.\n+\n+To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n+fix for the sub-error above if you do not intend to call the method with type\n+parameters:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T) where Self: Sized;\n+    // more methods\n+}\n+```\n+\n+If this is not an option, consider replacing the type parameter with another\n+trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number\n+of types you intend to feed to this method is limited, consider manually listing\n+out the methods of different types.\n+\n+### Method has no receiver\n+\n+Methods that do not take a `self` parameter can't be called since there won't be\n+a way to get a pointer to the method table for them\n+\n+```\n+trait Foo {\n+    fn foo() -> u8;\n+}\n+```\n+\n+This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n+an implementation.\n+\n+Adding a `Self: Sized` bound to these methods will generally make this compile.\n+\n+```\n+trait Foo {\n+    fn foo() -> u8 where Self: Sized;\n+}\n+```\n+\n+### The trait cannot use `Self` as a type parameter in the supertrait listing\n+\n+This is similar to the second sub-error, but subtler. It happens in situations\n+like the following:\n+\n+```\n+trait Super<A> {}\n+\n+trait Trait: Super<Self> {\n+}\n+\n+struct Foo;\n+\n+impl Super<Foo> for Foo{}\n+\n+impl Trait for Foo {}\n+```\n+\n+Here, the supertrait might have methods as follows:\n+\n+```\n+trait Super<A> {\n+    fn get_a(&self) -> A; // note that this is object safe!\n+}\n+```\n+\n+If the trait `Foo` was deriving from something like `Super<String>` or\n+`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n+`get_a()` will definitely return an object of that type.\n+\n+However, if it derives from `Super<Self>`, even though `Super` is object safe,\n+the method `get_a()` would return an object of unknown type when called on the\n+function. `Self` type parameters let us make object safe traits no longer safe,\n+so they are forbidden when specifying supertraits.\n+\n+There's no easy fix for this, generally code will need to be refactored so that\n+you no longer need to derive from `Super<Self>`.\n+\"####,\n+\n E0079: r##\"\n Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an\n-integer literal and is therefore invalid.\n+representation. This error indicates that the value provided is not an integer\n+literal and is therefore invalid.\n+\n+For example, in the following code,\n+\n+```\n+enum Foo {\n+    Q = \"32\"\n+}\n+```\n+\n+we try to set the representation to a string.\n+\n+There's no general fix for this; if you can work with an integer then just set\n+it to one:\n+\n+```\n+enum Foo {\n+    Q = 32\n+}\n+```\n+\n+however if you actually wanted a mapping between variants and non-integer\n+objects, it may be preferable to use a method with a match instead:\n+\n+```\n+enum Foo { Q }\n+impl Foo {\n+    fn get_str(&self) -> &'static str {\n+        match *self {\n+            Foo::Q => \"32\",\n+        }\n+    }\n+}\n+```\n \"##,\n \n E0080: r##\"\n@@ -357,7 +747,45 @@ Ensure that the expressions given can be evaluated as the desired integer type.\n See the FFI section of the Reference for more information about using a custom\n integer type:\n \n-http://doc.rust-lang.org/reference.html#ffi-attributes\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n+\"##,\n+\n+E0109: r##\"\n+You tried to give a type parameter to a type which doesn't need it. Erroneous\n+code example:\n+\n+```\n+type X = u32<i32>; // error: type parameters are not allowed on this type\n+```\n+\n+Please check that you used the correct type and recheck its definition. Perhaps\n+it doesn't need the type parameter.\n+\n+Example:\n+\n+```\n+type X = u32; // this compiles\n+```\n+\n+Note that type parameters for enum-variant constructors go after the variant,\n+not after the enum (Option::None::<u32>, not Option::<u32>::None).\n+\"##,\n+\n+E0110: r##\"\n+You tried to give a lifetime parameter to a type which doesn't need it.\n+Erroneous code example:\n+\n+```\n+type X = u32<'static>; // error: lifetime parameters are not allowed on\n+                       //        this type\n+```\n+\n+Please check that the correct type was used and recheck its definition; perhaps\n+it doesn't need the lifetime parameter. Example:\n+\n+```\n+type X = u32; // ok!\n+```\n \"##,\n \n E0133: r##\"\n@@ -374,7 +802,13 @@ fn main() {\n }\n ```\n \n-See also http://doc.rust-lang.org/book/unsafe.html\n+See also https://doc.rust-lang.org/book/unsafe.html\n+\"##,\n+\n+// This shouldn't really ever trigger since the repeated value error comes first\n+E0136: r##\"\n+A binary can only have one entry point, and by default that entry point is the\n+function `main()`. If there are multiple such functions, please rename one.\n \"##,\n \n E0137: r##\"\n@@ -383,6 +817,84 @@ This error indicates that the compiler found multiple functions with the\n point into a Rust program.\n \"##,\n \n+E0138: r##\"\n+This error indicates that the compiler found multiple functions with the\n+`#[start]` attribute. This is an error because there must be a unique entry\n+point into a Rust program.\n+\"##,\n+\n+// FIXME link this to the relevant turpl chapters for instilling fear of the\n+//       transmute gods in the user\n+E0139: r##\"\n+There are various restrictions on transmuting between types in Rust; for example\n+types being transmuted must have the same size. To apply all these restrictions,\n+the compiler must know the exact types that may be transmuted. When type\n+parameters are involved, this cannot always be done.\n+\n+So, for example, the following is not allowed:\n+\n+```\n+struct Foo<T>(Vec<T>)\n+\n+fn foo<T>(x: Vec<T>) {\n+    // we are transmuting between Vec<T> and Foo<T> here\n+    let y: Foo<T> = unsafe { transmute(x) };\n+    // do something with y\n+}\n+```\n+\n+In this specific case there's a good chance that the transmute is harmless (but\n+this is not guaranteed by Rust). However, when alignment and enum optimizations\n+come into the picture, it's quite likely that the sizes may or may not match\n+with different type parameter substitutions. It's not possible to check this for\n+_all_ possible types, so `transmute()` simply only accepts types without any\n+unsubstituted type parameters.\n+\n+If you need this, there's a good chance you're doing something wrong. Keep in\n+mind that Rust doesn't guarantee much about the layout of different structs\n+(even two structs with identical declarations may have different layouts). If\n+there is a solution that avoids the transmute entirely, try it instead.\n+\n+If it's possible, hand-monomorphize the code by writing the function for each\n+possible type substitution. It's possible to use traits to do this cleanly,\n+for example:\n+\n+```\n+trait MyTransmutableType {\n+    fn transmute(Vec<Self>) -> Foo<Self>\n+}\n+\n+impl MyTransmutableType for u8 {\n+    fn transmute(x: Foo<u8>) -> Vec<u8> {\n+        transmute(x)\n+    }\n+}\n+impl MyTransmutableType for String {\n+    fn transmute(x: Foo<String>) -> Vec<String> {\n+        transmute(x)\n+    }\n+}\n+// ... more impls for the types you intend to transmute\n+\n+fn foo<T: MyTransmutableType>(x: Vec<T>) {\n+    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n+    // do something with y\n+}\n+```\n+\n+Each impl will be checked for a size match in the transmute as usual, and since\n+there are no unbound type parameters involved, this should compile unless there\n+is a size mismatch in one of the impls.\n+\n+It is also possible to manually transmute:\n+\n+```\n+let result: SomeType = mem::uninitialized();\n+unsafe { copy_nonoverlapping(&v, &result) };\n+result // `v` transmuted to type `SomeType`\n+```\n+\"##,\n+\n E0152: r##\"\n Lang items are already implemented in the standard library. Unless you are\n writing a free-standing application (e.g. a kernel), you do not need to provide\n@@ -500,6 +1012,14 @@ you prefer them unqualified, you can import the variants into scope:\n use Method::*;\n enum Method { GET, POST }\n ```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```\n+pub use Method::*;\n+enum Method { GET, POST }\n+```\n \"##,\n \n E0261: r##\"\n@@ -568,15 +1088,149 @@ const Y: u32 = X;\n \n E0267: r##\"\n This error indicates the use of a loop keyword (`break` or `continue`) inside a\n-closure but outside of any loop. Break and continue can be used as normal inside\n-closures as long as they are also contained within a loop. To halt the execution\n-of a closure you should instead use a return statement.\n+closure but outside of any loop. Erroneous code example:\n+\n+```\n+let w = || { break; }; // error: `break` inside of a closure\n+```\n+\n+`break` and `continue` keywords can be used as normal inside closures as long as\n+they are also contained within a loop. To halt the execution of a closure you\n+should instead use a return statement. Example:\n+\n+```\n+let w = || {\n+    for _ in 0..10 {\n+        break;\n+    }\n+};\n+\n+w();\n+```\n \"##,\n \n E0268: r##\"\n This error indicates the use of a loop keyword (`break` or `continue`) outside\n of a loop. Without a loop to break out of or continue in, no sensible action can\n-be taken.\n+be taken. Erroneous code example:\n+\n+```\n+fn some_func() {\n+    break; // error: `break` outside of loop\n+}\n+```\n+\n+Please verify that you are using `break` and `continue` only in loops. Example:\n+\n+```\n+fn some_func() {\n+    for _ in 0..10 {\n+        break; // ok!\n+    }\n+}\n+```\n+\"##,\n+\n+E0269: r##\"\n+Functions must eventually return a value of their return type. For example, in\n+the following function\n+\n+```\n+fn foo(x: u8) -> u8 {\n+    if x > 0 {\n+        x // alternatively, `return x`\n+    }\n+    // nothing here\n+}\n+```\n+\n+if the condition is true, the value `x` is returned, but if the condition is\n+false, control exits the `if` block and reaches a place where nothing is being\n+returned. All possible control paths must eventually return a `u8`, which is not\n+happening here.\n+\n+An easy fix for this in a complicated function is to specify a default return\n+value, if possible:\n+\n+```\n+fn foo(x: u8) -> u8 {\n+    if x > 0 {\n+        x // alternatively, `return x`\n+    }\n+    // lots of other if branches\n+    0 // return 0 if all else fails\n+}\n+```\n+\n+It is advisable to find out what the unhandled cases are and check for them,\n+returning an appropriate value or panicking if necessary.\n+\"##,\n+\n+E0270: r##\"\n+Rust lets you define functions which are known to never return, i.e. are\n+'diverging', by marking its return type as `!`.\n+\n+For example, the following functions never return:\n+\n+```\n+fn foo() -> ! {\n+    loop {}\n+}\n+\n+fn bar() -> ! {\n+    foo() // foo() is diverging, so this will diverge too\n+}\n+\n+fn baz() -> ! {\n+    panic!(); // this macro internally expands to a call to a diverging function\n+}\n+\n+```\n+\n+Such functions can be used in a place where a value is expected without\n+returning a value of that type,  for instance:\n+\n+```\n+let y = match x {\n+    1 => 1,\n+    2 => 4,\n+    _ => foo() // diverging function called here\n+};\n+println!(\"{}\", y)\n+```\n+\n+If the third arm of the match block is reached, since `foo()` doesn't ever\n+return control to the match block, it is fine to use it in a place where an\n+integer was expected. The `match` block will never finish executing, and any\n+point where `y` (like the print statement) is needed will not be reached.\n+\n+However, if we had a diverging function that actually does finish execution\n+\n+```\n+fn foo() -> {\n+    loop {break;}\n+}\n+```\n+\n+then we would have an unknown value for `y` in the following code:\n+\n+```\n+let y = match x {\n+    1 => 1,\n+    2 => 4,\n+    _ => foo()\n+};\n+println!(\"{}\", y);\n+```\n+\n+In the previous example, the print statement was never reached when the wildcard\n+match arm was hit, so we were okay with `foo()` not returning an integer that we\n+could set to `y`. But in this example, `foo()` actually does return control, so\n+the print statement will be executed with an uninitialized value.\n+\n+Obviously we cannot have functions which are allowed to be used in such\n+positions and yet can return control. So, if you are defining a function that\n+returns `!`, make sure that there is no way for it to actually finish executing.\n \"##,\n \n E0271: r##\"\n@@ -715,6 +1369,179 @@ for v in &vs {\n ```\n \"##,\n \n+E0272: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { ... }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for substitution\n+with the actual types (using the regular format string syntax) in a given\n+situation. Furthermore, `{Self}` will substitute to the type (in this case,\n+`bool`) that we tried to use.\n+\n+This error appears when the curly braces contain an identifier which doesn't\n+match with any of the type parameters or the string `Self`. This might happen if\n+you misspelled a type parameter, or if you intended to use literal curly braces.\n+If it is the latter, escape the curly braces with a second curly brace of the\n+same type; e.g. a literal `{` is `{{`\n+\"##,\n+\n+E0273: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { ... }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for substitution\n+with the actual types (using the regular format string syntax) in a given\n+situation. Furthermore, `{Self}` will substitute to the type (in this case,\n+`bool`) that we tried to use.\n+\n+This error appears when the curly braces do not contain an identifier. Please\n+add one of the same name as a type parameter. If you intended to use literal\n+braces, use `{{` and `}}` to escape them.\n+\"##,\n+\n+E0274: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { ... }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+For this to work, some note must be specified. An empty attribute will not do\n+anything, please remove the attribute or add some helpful note for users of the\n+trait.\n+\"##,\n+\n+E0275: r##\"\n+This error occurs when there was a recursive trait requirement that overflowed\n+before it could be evaluated. Often this means that there is unbounded recursion\n+in resolving some type bounds.\n+\n+For example, in the following code\n+\n+```\n+trait Foo {}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for T where Bar<T>: Foo {}\n+```\n+\n+to determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n+to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To determine\n+this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is clearly a\n+recursive requirement that can't be resolved directly.\n+\n+Consider changing your trait bounds so that they're less self-referential.\n+\"##,\n+\n+E0276: r##\"\n+This error occurs when a bound in an implementation of a trait does not match\n+the bounds specified in the original trait. For example:\n+\n+```\n+trait Foo {\n+ fn foo<T>(x: T);\n+}\n+\n+impl Foo for bool {\n+ fn foo<T>(x: T) where T: Copy {}\n+}\n+```\n+\n+Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\n+take any type `T`. However, in the `impl` for `bool`, we have added an extra\n+bound that `T` is `Copy`, which isn't compatible with the original trait.\n+\n+Consider removing the bound from the method or adding the bound to the original\n+method definition in the trait.\n+\"##,\n+\n+E0277: r##\"\n+You tried to use a type which doesn't implement some trait in a place which\n+expected that trait. Erroneous code example:\n+\n+```\n+// here we declare the Foo trait with a bar method\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+// we now declare a function which takes an object implementing the Foo trait\n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar();\n+}\n+\n+fn main() {\n+    // we now call the method with the i32 type, which doesn't implement\n+    // the Foo trait\n+    some_func(5i32); // error: the trait `Foo` is not implemented for the\n+                     //     type `i32`\n+}\n+```\n+\n+In order to fix this error, verify that the type you're using does implement\n+the trait. Example:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar(); // we can now use this method since i32 implements the\n+               // Foo trait\n+}\n+\n+// we implement the trait on the i32 type\n+impl Foo for i32 {\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    some_func(5i32); // ok!\n+}\n+```\n+\"##,\n+\n E0282: r##\"\n This error indicates that type inference did not result in one unique possible\n type, and extra information is required. In most cases this can be provided\n@@ -859,16 +1686,16 @@ Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n ```\n-// Code like this...\n-match Some(5) {\n-    ref op_num @ Some(num) => ...\n+// Before.\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(ref s) => ...\n     None => ...\n }\n \n // After.\n match Some(\"hi\".to_string()) {\n     Some(ref s) => {\n-        let op_string_ref = &Some(&s);\n+        let op_string_ref = &Some(s);\n         ...\n     }\n     None => ...\n@@ -892,7 +1719,7 @@ a compile-time constant.\n \n E0308: r##\"\n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. This error can occur for several cases, the most common of which is a\n+variable. It can occur for several cases, the most common of which is a\n mismatch in the expected type that the compiler inferred for a variable's\n initializing expression, and the actual type explicitly assigned to the\n variable.\n@@ -984,6 +1811,57 @@ From [RFC 246]:\n [RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n \"##,\n \n+E0395: r##\"\n+The value assigned to a constant expression must be known at compile time,\n+which is not the case when comparing raw pointers. Erroneous code example:\n+\n+```\n+static foo: i32 = 42;\n+static bar: i32 = 43;\n+\n+static baz: bool = { (&foo as *const i32) == (&bar as *const i32) };\n+// error: raw pointers cannot be compared in statics!\n+```\n+\n+Please check that the result of the comparison can be determined at compile time\n+or isn't assigned to a constant expression. Example:\n+\n+```\n+static foo: i32 = 42;\n+static bar: i32 = 43;\n+\n+let baz: bool = { (&foo as *const i32) == (&bar as *const i32) };\n+// baz isn't a constant expression so it's ok\n+```\n+\"##,\n+\n+E0396: r##\"\n+The value assigned to a constant expression must be known at compile time,\n+which is not the case when dereferencing raw pointers. Erroneous code\n+example:\n+\n+```\n+const foo: i32 = 42;\n+const baz: *const i32 = (&foo as *const i32);\n+\n+const deref: i32 = *baz;\n+// error: raw pointers cannot be dereferenced in constants\n+```\n+\n+To fix this error, please do not assign this value to a constant expression.\n+Example:\n+\n+```\n+const foo: i32 = 42;\n+const baz: *const i32 = (&foo as *const i32);\n+\n+unsafe { let deref: i32 = *baz; }\n+// baz isn't a constant expression so it's ok\n+```\n+\n+You'll also note that this assignment must be done in an unsafe block!\n+\"##,\n+\n E0397: r##\"\n It is not allowed for a mutable static to allocate or have destructors. For\n example:\n@@ -995,32 +1873,52 @@ static mut FOO: Option<Box<usize>> = None;\n // error: mutable statics are not allowed to have destructors\n static mut BAR: Option<Vec<i32>> = None;\n ```\n+\"##,\n+\n+E0398: r##\"\n+In Rust 1.3, the default object lifetime bounds are expected to\n+change, as described in RFC #1156 [1]. You are getting a warning\n+because the compiler thinks it is possible that this change will cause\n+a compilation error in your code. It is possible, though unlikely,\n+that this is a false alarm.\n+\n+The heart of the change is that where `&'a Box<SomeTrait>` used to\n+default to `&'a Box<SomeTrait+'a>`, it now defaults to `&'a\n+Box<SomeTrait+'static>` (here, `SomeTrait` is the name of some trait\n+type). Note that the only types which are affected are references to\n+boxes, like `&Box<SomeTrait>` or `&[Box<SomeTrait>]`.  More common\n+types like `&SomeTrait` or `Box<SomeTrait>` are unaffected.\n+\n+To silence this warning, edit your code to use an explicit bound.\n+Most of the time, this means that you will want to change the\n+signature of a function that you are calling. For example, if\n+the error is reported on a call like `foo(x)`, and `foo` is\n+defined as follows:\n+\n+```\n+fn foo(arg: &Box<SomeTrait>) { ... }\n+```\n+\n+you might change it to:\n+\n+```\n+fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n+```\n+\n+This explicitly states that you expect the trait object `SomeTrait` to\n+contain references (with a maximum lifetime of `'a`).\n+\n+[1]: https://github.com/rust-lang/rfcs/pull/1156\n \"##\n \n }\n \n \n register_diagnostics! {\n-    E0017,\n-    E0022,\n-    E0038,\n-    E0109,\n-    E0110,\n-    E0134,\n-    E0135,\n-    E0136,\n-    E0138,\n-    E0139,\n+    // E0006 // merged with E0005\n+//  E0134,\n+//  E0135,\n     E0264, // unknown external lang item\n-    E0266, // expected item\n-    E0269, // not all control paths return a value\n-    E0270, // computation may converge in a function marked as diverging\n-    E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n-    E0273, // rustc_on_unimplemented must have named format arguments\n-    E0274, // rustc_on_unimplemented must have a value\n-    E0275, // overflow evaluating requirement\n-    E0276, // requirement appears on impl method but not on corresponding trait method\n-    E0277, // trait is not implemented for type\n     E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied\n@@ -1040,6 +1938,5 @@ register_diagnostics! {\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n     E0370, // discriminant overflow\n-    E0395, // pointer comparison in const-expr\n-    E0396  // pointer dereference in const-expr\n+    E0400  // overloaded derefs are not allowed in constants\n }"}, {"sha": "fb11aaed6195825b2ce9801207c46367b8bf2dbb", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -53,14 +53,17 @@\n #![feature(rustc_private)]\n #![feature(scoped_tls)]\n #![feature(slice_bytes)]\n-#![feature(slice_extras)]\n+#![feature(slice_splits)]\n #![feature(slice_patterns)]\n #![feature(slice_position_elem)]\n+#![feature(slice_concat_ext)]\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(str_match_indices)]\n #![feature(vec_push_all)]\n #![feature(wrapping)]\n+#![feature(cell_extras)]\n+#![feature(page_size)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]\n@@ -97,15 +100,8 @@ pub mod diagnostics;\n \n pub mod back {\n     pub use rustc_back::abi;\n-    pub use rustc_back::archive;\n-    pub use rustc_back::arm;\n-    pub use rustc_back::mips;\n-    pub use rustc_back::mipsel;\n     pub use rustc_back::rpath;\n     pub use rustc_back::svh;\n-    pub use rustc_back::target_strs;\n-    pub use rustc_back::x86;\n-    pub use rustc_back::x86_64;\n }\n \n pub mod ast_map;"}, {"sha": "6d29a1031c6bc9859bd976c90afa2de89f416f5c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -75,6 +75,15 @@ enum TargetLint {\n \n     /// Temporary renaming, used for easing migration pain; see #16545\n     Renamed(String, LintId),\n+\n+    /// Lint with this name existed previously, but has been removed/deprecated.\n+    /// The string argument is the reason for removal.\n+    Removed(String),\n+}\n+\n+enum FindLintError {\n+    NotFound,\n+    Removed\n }\n \n impl LintStore {\n@@ -166,30 +175,42 @@ impl LintStore {\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n     }\n \n+    pub fn register_removed(&mut self, name: &str, reason: &str) {\n+        self.by_name.insert(name.into(), Removed(reason.into()));\n+    }\n+\n     #[allow(unused_variables)]\n     fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n-                 -> Option<LintId>\n+                 -> Result<LintId, FindLintError>\n     {\n         match self.by_name.get(lint_name) {\n-            Some(&Id(lint_id)) => Some(lint_id),\n+            Some(&Id(lint_id)) => Ok(lint_id),\n             Some(&Renamed(ref new_name, lint_id)) => {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n                     Some(span) => sess.span_warn(span, &warning[..]),\n                     None => sess.warn(&warning[..]),\n                 };\n-                Some(lint_id)\n-            }\n-            None => None\n+                Ok(lint_id)\n+            },\n+            Some(&Removed(ref reason)) => {\n+                let warning = format!(\"lint {} has been removed: {}\", lint_name, reason);\n+                match span {\n+                    Some(span) => sess.span_warn(span, &warning[..]),\n+                    None => sess.warn(&warning[..])\n+                }\n+                Err(FindLintError::Removed)\n+            },\n+            None => Err(FindLintError::NotFound)\n         }\n     }\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n             match self.find_lint(&lint_name[..], sess, None) {\n-                Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n-                None => {\n+                Ok(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n+                Err(_) => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n@@ -398,8 +419,8 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 }\n                 Ok((lint_name, level, span)) => {\n                     match self.lints.find_lint(&lint_name, &self.tcx.sess, Some(span)) {\n-                        Some(lint_id) => vec![(lint_id, level, span)],\n-                        None => {\n+                        Ok(lint_id) => vec![(lint_id, level, span)],\n+                        Err(FindLintError::NotFound) => {\n                             match self.lints.lint_groups.get(&lint_name[..]) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n@@ -412,7 +433,8 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                     continue;\n                                 }\n                             }\n-                        }\n+                        },\n+                        Err(FindLintError::Removed) => { continue; }\n                     }\n                 }\n             };"}, {"sha": "2a469ed69ef9a5b29b849ffda4b5f3c891c8a583", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -197,7 +197,7 @@ pub fn get_item_attrs(cstore: &cstore::CStore,\n \n pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n-                      -> Vec<ty::field_ty> {\n+                      -> Vec<ty::FieldTy> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_fields(cstore.intr.clone(), &*cdata, def.node)\n }"}, {"sha": "7415b576f762be8f06ab89f9f6cbc6fbe96c334c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -688,7 +688,7 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n                                 -> csearch::FoundAst<'tcx> {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n-    let path = item_path(item_doc).init().to_vec();\n+    let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n         Err(path) => {\n@@ -1049,7 +1049,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n }\n \n pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n-    -> Vec<ty::field_ty> {\n+    -> Vec<ty::FieldTy> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     reader::tagged_docs(item, tag_item_field).filter_map(|an_item| {\n@@ -1059,7 +1059,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n             let origin_id =  translated_def_id(cdata, tagdoc);\n-            Some(ty::field_ty {\n+            Some(ty::FieldTy {\n                 name: name,\n                 id: did,\n                 vis: struct_field_family_to_visibility(f),\n@@ -1073,7 +1073,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n         let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n         let origin_id =  translated_def_id(cdata, tagdoc);\n-        ty::field_ty {\n+        ty::FieldTy {\n             name: special_idents::unnamed_field.name,\n             id: did,\n             vis: struct_field_family_to_visibility(f),"}, {"sha": "987b6ad5b729622d6d4080900d3f81c1190ef057", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -23,7 +23,6 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::def;\n-use middle::ty::lookup_item_type;\n use middle::ty::{self, Ty};\n use middle::stability;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -133,7 +132,7 @@ pub fn def_to_string(did: DefId) -> String {\n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: NodeId) {\n-    let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n+    let v = ecx.tcx.item_variances(ast_util::local_def(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -144,8 +143,8 @@ fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              id: ast::NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n-                           &ty::lookup_item_type(ecx.tcx, local_def(id)),\n-                           &ty::lookup_predicates(ecx.tcx, local_def(id)));\n+                           &ecx.tcx.lookup_item_type(local_def(id)),\n+                           &ecx.tcx.lookup_predicates(local_def(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n@@ -268,7 +267,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        fields: &[ty::field_ty],\n+                        fields: &[ty::FieldTy],\n                         origin: DefId) {\n     for f in fields {\n         if f.name == special_idents::unnamed_field.name {\n@@ -293,8 +292,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n \n     let mut disr_val = 0;\n     let mut i = 0;\n-    let vi = ty::enum_variants(ecx.tcx,\n-                               DefId { krate: ast::LOCAL_CRATE, node: id });\n+    let vi = ecx.tcx.enum_variants(local_def(id));\n     for variant in variants {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n@@ -319,7 +317,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         match variant.node.kind {\n             ast::TupleVariantKind(_) => {},\n             ast::StructVariantKind(_) => {\n-                let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n+                let fields = ecx.tcx.lookup_struct_fields(def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n                                                  &fields[..],\n@@ -328,9 +326,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n-        if (*vi)[i].disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, (*vi)[i].disr_val);\n-            disr_val = (*vi)[i].disr_val;\n+        let specified_disr_val = vi[i].disr_val;\n+        if specified_disr_val != disr_val {\n+            encode_disr_val(ecx, rbml_w, specified_disr_val);\n+            disr_val = specified_disr_val;\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, def_id.local_id());\n \n@@ -379,9 +378,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n                 for &method_did in impl_items.get(base_impl_did).unwrap() {\n-                    let impl_item = ty::impl_or_trait_item(\n-                        ecx.tcx,\n-                        method_did.def_id());\n+                    let impl_item = ecx.tcx.impl_or_trait_item(method_did.def_id());\n                     if let ty::MethodTraitItem(ref m) = impl_item {\n                         encode_reexported_static_method(rbml_w,\n                                                         exp,\n@@ -639,7 +636,7 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           rbml_w: &mut Encoder,\n-                          fields: &[ty::field_ty],\n+                          fields: &[ty::FieldTy],\n                           global_index: &mut Vec<entry<i64>>)\n                           -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n@@ -875,7 +872,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(impl_item) = impl_item_opt {\n         if let ast::MethodImplItem(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n-            let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n+            let scheme = ecx.tcx.lookup_item_type(m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n@@ -923,7 +920,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &ii.attrs);\n     } else {\n         encode_predicates(rbml_w, ecx,\n-                          &ty::lookup_predicates(ecx.tcx, associated_type.def_id),\n+                          &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n \n@@ -995,7 +992,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n     assert!(ast_util::is_local(trait_def_id));\n-    let def = ty::lookup_trait_def(ecx.tcx, trait_def_id);\n+    let def = ecx.tcx.lookup_trait_def(trait_def_id);\n \n     def.for_each_impl(ecx.tcx, |impl_def_id| {\n         rbml_w.start_tag(tag_items_data_item_extension_impl);\n@@ -1161,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n-        let fields = ty::lookup_struct_fields(tcx, def_id);\n+        let fields = tcx.lookup_struct_fields(def_id);\n \n         /* First, encode the fields\n            These come first because we need to write them to make\n@@ -1220,7 +1217,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = ty::impl_trait_ref(tcx, local_def(item.id)).unwrap();\n+          let trait_ref = tcx.impl_trait_ref(local_def(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n@@ -1274,7 +1271,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = ty::impl_trait_ref(tcx, local_def(item.id)) {\n+        if let Some(trait_ref) = tcx.impl_trait_ref(local_def(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1298,7 +1295,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n-            match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+            match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n                     encode_info_for_associated_const(ecx,\n                                                      rbml_w,\n@@ -1333,22 +1330,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'I');\n         encode_item_variances(rbml_w, ecx, item.id);\n-        let trait_def = ty::lookup_trait_def(tcx, def_id);\n-        let trait_predicates = ty::lookup_predicates(tcx, def_id);\n+        let trait_def = tcx.lookup_trait_def(def_id);\n+        let trait_predicates = tcx.lookup_predicates(def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n-        encode_defaulted(rbml_w, ty::trait_has_default_impl(tcx, def_id));\n+        encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates,\n                         tag_item_generics);\n-        encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n+        encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n+        for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n                 ty::ConstTraitItemId(const_def_id) => {\n@@ -1380,7 +1377,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.end_tag();\n \n         // Now output the trait item info for each trait item.\n-        let r = ty::trait_item_def_ids(tcx, def_id);\n+        let r = tcx.trait_item_def_ids(def_id);\n         for (i, &item_def_id) in r.iter().enumerate() {\n             assert_eq!(item_def_id.def_id().krate, ast::LOCAL_CRATE);\n \n@@ -1397,7 +1394,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_stability(rbml_w, stab);\n \n             let trait_item_type =\n-                ty::impl_or_trait_item(tcx, item_def_id.def_id());\n+                tcx.impl_or_trait_item(item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n                 ty::ConstTraitItem(associated_const) => {\n@@ -1454,6 +1451,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_item_sort(rbml_w, 't');\n                     encode_family(rbml_w, 'y');\n \n+                    if let Some(ty) = associated_type.ty {\n+                        encode_type(ecx, rbml_w, ty);\n+                    }\n+\n                     is_nonstatic_method = false;\n                 }\n             }\n@@ -2027,7 +2028,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            rbml_w.wr_tagged_str(tag, &s.connect(\",\"));\n+            rbml_w.wr_tagged_str(tag, &s.join(\",\"));\n         }\n         None => {\n             rbml_w.wr_tagged_str(tag, \"\");\n@@ -2135,11 +2136,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     let mut rbml_w = Encoder::new(wr);\n \n     encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n-    encode_crate_triple(&mut rbml_w,\n-                        &tcx.sess\n-                           .opts\n-                           .target_triple\n-                           );\n+    encode_crate_triple(&mut rbml_w, &tcx.sess.opts.target_triple);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n "}, {"sha": "81acaf66e08fcf742fa4376d9b36afdabaaa431a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -212,7 +212,6 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::loader or metadata::creader for all the juicy details!\n \n-use back::archive::METADATA_FILENAME;\n use back::svh::Svh;\n use session::Session;\n use session::search_paths::PathKind;\n@@ -280,6 +279,8 @@ pub struct CratePaths {\n     pub rlib: Option<PathBuf>\n }\n \n+pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n+\n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n         match (&self.dylib, &self.rlib) {"}, {"sha": "54c55d76a8270215f1e76c1244938447dfde530c", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -21,7 +21,7 @@ pub use self::DefIdSource::*;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, AsPredicate, Ty};\n+use middle::ty::{self, ToPredicate, Ty, HasTypeFlags};\n \n use std::str;\n use syntax::abi;\n@@ -471,14 +471,14 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let def = parse_def_(st, NominalType, conv);\n         let substs = parse_substs_(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_enum(tcx, def, st.tcx.mk_substs(substs));\n+        return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n         let trait_ref = ty::Binder(parse_trait_ref_(st, conv));\n         let bounds = parse_existential_bounds_(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(tcx, trait_ref, bounds);\n+        return tcx.mk_trait(trait_ref, bounds);\n       }\n       'p' => {\n         assert_eq!(next(st), '[');\n@@ -487,45 +487,45 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n         let name = token::intern(&parse_str(st, ']'));\n-        return ty::mk_param(tcx, space, index, name);\n+        return tcx.mk_param(space, index, name);\n       }\n-      '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n-      '*' => return ty::mk_ptr(tcx, parse_mt_(st, conv)),\n+      '~' => return tcx.mk_box(parse_ty_(st, conv)),\n+      '*' => return tcx.mk_ptr(parse_mt_(st, conv)),\n       '&' => {\n         let r = parse_region_(st, conv);\n         let mt = parse_mt_(st, conv);\n-        return ty::mk_rptr(tcx, tcx.mk_region(r), mt);\n+        return tcx.mk_ref(tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty_(st, conv);\n-        let sz = parse_size(st);\n-        return ty::mk_vec(tcx, t, sz);\n+        return match parse_size(st) {\n+            Some(n) => tcx.mk_array(t, n),\n+            None => tcx.mk_slice(t)\n+        };\n       }\n       'v' => {\n-        return ty::mk_str(tcx);\n+        return tcx.mk_str();\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n         st.pos = st.pos + 1;\n-        return ty::mk_tup(tcx, params);\n+        return tcx.mk_tup(params);\n       }\n       'F' => {\n           let def_id = parse_def_(st, NominalType, conv);\n-          return ty::mk_bare_fn(tcx, Some(def_id),\n-                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       'G' => {\n-          return ty::mk_bare_fn(tcx, None,\n-                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n         assert_eq!(next(st), ':');\n         let len = parse_hex(st);\n         assert_eq!(next(st), '#');\n-        let key = ty::creader_cache_key {cnum: st.krate,\n+        let key = ty::CReaderCacheKey {cnum: st.krate,\n                                          pos: pos,\n                                          len: len };\n \n@@ -534,7 +534,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n             // If there is a closure buried in the type some where, then we\n             // need to re-convert any def ids (see case 'k', below). That means\n             // we can't reuse the cached version.\n-            if !ty::type_has_ty_closure(tt) {\n+            if !tt.has_closure_types() {\n                 return tt;\n             }\n           }\n@@ -558,20 +558,25 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           let did = parse_def_(st, NominalType, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_struct(st.tcx, did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_struct(did, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def_(st, ClosureSource, conv);\n           let substs = parse_substs_(st, conv);\n+          let mut tys = vec![];\n+          while peek(st) != '.' {\n+              tys.push(parse_ty_(st, conv));\n+          }\n+          assert_eq!(next(st), '.');\n           assert_eq!(next(st), ']');\n-          return ty::mk_closure(st.tcx, did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs), tys);\n       }\n       'P' => {\n           assert_eq!(next(st), '[');\n           let trait_ref = parse_trait_ref_(st, conv);\n           let name = token::intern(&parse_str(st, ']'));\n-          return ty::mk_projection(tcx, trait_ref, name);\n+          return tcx.mk_projection(trait_ref, name);\n       }\n       'e' => {\n           return tcx.types.err;\n@@ -587,11 +592,11 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     }\n }\n \n-fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::mt<'tcx> where\n+fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::TypeAndMut<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let m = parse_mutability(st);\n-    ty::mt { ty: parse_ty_(st, conv), mutbl: m }\n+    ty::TypeAndMut { ty: parse_ty_(st, conv), mutbl: m }\n }\n \n fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::DefId where\n@@ -775,14 +780,14 @@ fn parse_predicate_<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     match next(st) {\n-        't' => ty::Binder(parse_trait_ref_(st, conv)).as_predicate(),\n+        't' => ty::Binder(parse_trait_ref_(st, conv)).to_predicate(),\n         'e' => ty::Binder(ty::EquatePredicate(parse_ty_(st, conv),\n-                                              parse_ty_(st, conv))).as_predicate(),\n+                                              parse_ty_(st, conv))).to_predicate(),\n         'r' => ty::Binder(ty::OutlivesPredicate(parse_region_(st, conv),\n-                                                parse_region_(st, conv))).as_predicate(),\n+                                                parse_region_(st, conv))).to_predicate(),\n         'o' => ty::Binder(ty::OutlivesPredicate(parse_ty_(st, conv),\n-                                                parse_region_(st, conv))).as_predicate(),\n-        'p' => ty::Binder(parse_projection_predicate_(st, conv)).as_predicate(),\n+                                                parse_region_(st, conv))).to_predicate(),\n+        'p' => ty::Binder(parse_projection_predicate_(st, conv)).to_predicate(),\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }\n@@ -828,6 +833,7 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n+    let default_def_id = parse_def_(st, NominalType, conv);\n     let default = parse_opt(st, |st| parse_ty_(st, conv));\n     let object_lifetime_default = parse_object_lifetime_default(st, conv);\n \n@@ -836,22 +842,23 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n         def_id: def_id,\n         space: space,\n         index: index,\n+        default_def_id: default_def_id,\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     }\n }\n \n fn parse_object_lifetime_default<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n                                              conv: &mut F)\n-                                             -> Option<ty::ObjectLifetimeDefault>\n+                                             -> ty::ObjectLifetimeDefault\n     where F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     match next(st) {\n-        'n' => None,\n-        'a' => Some(ty::ObjectLifetimeDefault::Ambiguous),\n+        'a' => ty::ObjectLifetimeDefault::Ambiguous,\n+        'b' => ty::ObjectLifetimeDefault::BaseDefault,\n         's' => {\n             let region = parse_region_(st, conv);\n-            Some(ty::ObjectLifetimeDefault::Specific(region))\n+            ty::ObjectLifetimeDefault::Specific(region)\n         }\n         _ => panic!(\"parse_object_lifetime_default: bad input\")\n     }"}, {"sha": "597401daccfd22a2245ce6e562b4e6984cf17adb", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -143,9 +143,13 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::TyClosure(def, substs) => {\n+        ty::TyClosure(def, ref substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n+            enc_substs(w, cx, &substs.func_substs);\n+            for ty in &substs.upvar_tys {\n+                enc_ty(w, cx, ty);\n+            }\n+            mywrite!(w, \".\");\n             mywrite!(w, \"]\");\n         }\n         ty::TyProjection(ref data) => {\n@@ -183,7 +187,7 @@ fn enc_mutability(w: &mut Encoder, mt: ast::Mutability) {\n }\n \n fn enc_mt<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n-                    mt: ty::mt<'tcx>) {\n+                    mt: ty::TypeAndMut<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n@@ -405,21 +409,21 @@ pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n \n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n-    mywrite!(w, \"{}:{}|{}|{}|\",\n+    mywrite!(w, \"{}:{}|{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n-             v.space.to_uint(), v.index);\n+             v.space.to_uint(), v.index, (cx.ds)(v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n                                          cx: &ctxt<'a, 'tcx>,\n-                                         default: Option<ty::ObjectLifetimeDefault>)\n+                                         default: ty::ObjectLifetimeDefault)\n {\n     match default {\n-        None => mywrite!(w, \"n\"),\n-        Some(ty::ObjectLifetimeDefault::Ambiguous) => mywrite!(w, \"a\"),\n-        Some(ty::ObjectLifetimeDefault::Specific(r)) => {\n+        ty::ObjectLifetimeDefault::Ambiguous => mywrite!(w, \"a\"),\n+        ty::ObjectLifetimeDefault::BaseDefault => mywrite!(w, \"b\"),\n+        ty::ObjectLifetimeDefault::Specific(r) => {\n             mywrite!(w, \"s\");\n             enc_region(w, cx, r);\n         }"}, {"sha": "fb0131f258d437df00d5561bea74a9b3046f2520", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -49,10 +49,10 @@ pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match nty {\n         ast::TyBool => tcx.types.bool,\n         ast::TyChar => tcx.types.char,\n-        ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n-        ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n-        ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n-        ast::TyStr => ty::mk_str(tcx)\n+        ast::TyInt(it) => tcx.mk_mach_int(it),\n+        ast::TyUint(uit) => tcx.mk_mach_uint(uit),\n+        ast::TyFloat(ft) => tcx.mk_mach_float(ft),\n+        ast::TyStr => tcx.mk_str()\n     }\n }\n "}, {"sha": "7c76f4fe289dfd583fa710957e2ddcc6dbde3f15", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 34, "deletions": 185, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -26,11 +26,10 @@ use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::cast;\n use middle::check_const::ConstQualif;\n-use middle::mem_categorization::Typer;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty, MethodCall, MethodCallee, MethodOrigin};\n+use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap, fold};\n use syntax::codemap::Span;\n@@ -601,21 +600,21 @@ impl tr for ty::UpvarCapture {\n \n trait read_method_callee_helper<'tcx> {\n     fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> (u32, MethodCallee<'tcx>);\n+                                  -> (u32, ty::MethodCallee<'tcx>);\n }\n \n fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n                                   rbml_w: &mut Encoder,\n                                   autoderef: u32,\n-                                  method: &MethodCallee<'tcx>) {\n+                                  method: &ty::MethodCallee<'tcx>) {\n     use serialize::Encoder;\n \n     rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n         rbml_w.emit_struct_field(\"autoderef\", 0, |rbml_w| {\n             autoderef.encode(rbml_w)\n         });\n-        rbml_w.emit_struct_field(\"origin\", 1, |rbml_w| {\n-            Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n+        rbml_w.emit_struct_field(\"def_id\", 1, |rbml_w| {\n+            Ok(rbml_w.emit_def_id(method.def_id))\n         });\n         rbml_w.emit_struct_field(\"ty\", 2, |rbml_w| {\n             Ok(rbml_w.emit_ty(ecx, method.ty))\n@@ -628,21 +627,20 @@ fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n \n impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n     fn read_method_callee<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> (u32, MethodCallee<'tcx>) {\n+                                  -> (u32, ty::MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n-                Decodable::decode(this)\n-            }).unwrap();\n-            Ok((autoderef, MethodCallee {\n-                origin: this.read_struct_field(\"origin\", 1, |this| {\n-                    Ok(this.read_method_origin(dcx))\n+            let autoderef = this.read_struct_field(\"autoderef\", 0,\n+                                                   Decodable::decode).unwrap();\n+            Ok((autoderef, ty::MethodCallee {\n+                def_id: this.read_struct_field(\"def_id\", 1, |this| {\n+                    Ok(this.read_def_id(dcx))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n                     Ok(this.read_ty(dcx))\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(dcx))\n+                    Ok(dcx.tcx.mk_substs(this.read_substs(dcx)))\n                 }).unwrap()\n             }))\n         }).unwrap()\n@@ -708,9 +706,6 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>);\n-    fn emit_method_origin<'a>(&mut self,\n-                              ecx: &e::EncodeContext<'a, 'tcx>,\n-                              method_origin: &ty::MethodOrigin<'tcx>);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n@@ -742,73 +737,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_method_origin<'b>(&mut self,\n-                              ecx: &e::EncodeContext<'b, 'tcx>,\n-                              method_origin: &ty::MethodOrigin<'tcx>)\n-    {\n-        use serialize::Encoder;\n-\n-        self.emit_enum(\"MethodOrigin\", |this| {\n-            match *method_origin {\n-                ty::MethodStatic(def_id) => {\n-                    this.emit_enum_variant(\"MethodStatic\", 0, 1, |this| {\n-                        Ok(this.emit_def_id(def_id))\n-                    })\n-                }\n-\n-                ty::MethodStaticClosure(def_id) => {\n-                    this.emit_enum_variant(\"MethodStaticClosure\", 1, 1, |this| {\n-                        Ok(this.emit_def_id(def_id))\n-                    })\n-                }\n-\n-                ty::MethodTypeParam(ref p) => {\n-                    this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n-                        this.emit_struct(\"MethodParam\", 2, |this| {\n-                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &p.trait_ref))\n-                            }));\n-                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n-                                this.emit_uint(p.method_num)\n-                            }));\n-                            try!(this.emit_struct_field(\"impl_def_id\", 0, |this| {\n-                                this.emit_option(|this| {\n-                                    match p.impl_def_id {\n-                                        None => this.emit_option_none(),\n-                                        Some(did) => this.emit_option_some(|this| {\n-                                            Ok(this.emit_def_id(did))\n-                                        })\n-                                    }\n-                                })\n-                            }));\n-                            Ok(())\n-                        })\n-                    })\n-                }\n-\n-                ty::MethodTraitObject(ref o) => {\n-                    this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n-                        this.emit_struct(\"MethodObject\", 2, |this| {\n-                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &o.trait_ref))\n-                            }));\n-                            try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n-                                Ok(this.emit_def_id(o.object_trait_id))\n-                            }));\n-                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n-                                this.emit_uint(o.method_num)\n-                            }));\n-                            try!(this.emit_struct_field(\"vtable_index\", 0, |this| {\n-                                this.emit_uint(o.vtable_index)\n-                            }));\n-                            Ok(())\n-                        })\n-                    })\n-                }\n-            }\n-        });\n-    }\n-\n     fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -1027,7 +955,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(item_substs) = tcx.item_substs.borrow().get(&id) {\n+    if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_substs(ecx, &item_substs.substs);\n@@ -1051,7 +979,12 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     var_id: var_id,\n                     closure_expr_id: id\n                 };\n-                let upvar_capture = tcx.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone();\n+                let upvar_capture = tcx.tables\n+                                       .borrow()\n+                                       .upvar_capture_map\n+                                       .get(&upvar_id)\n+                                       .unwrap()\n+                                       .clone();\n                 var_id.encode(rbml_w);\n                 upvar_capture.encode(rbml_w);\n             })\n@@ -1073,20 +1006,20 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    let method_call = MethodCall::expr(id);\n-    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n+    let method_call = ty::MethodCall::expr(id);\n+    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             encode_method_callee(ecx, rbml_w, method_call.autoderef, method)\n         })\n     }\n \n-    if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n+    if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n         match *adjustment {\n             ty::AdjustDerefRef(ref adj) => {\n                 for autoderef in 0..adj.autoderefs {\n-                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n-                    if let Some(method) = tcx.method_map.borrow().get(&method_call) {\n+                    let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n+                    if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             encode_method_callee(ecx, rbml_w,\n@@ -1104,14 +1037,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(closure_type) = tcx.closure_tys.borrow().get(&ast_util::local_def(id)) {\n+    if let Some(closure_type) = tcx.tables.borrow().closure_tys.get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_tys, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_closure_type(ecx, closure_type);\n         })\n     }\n \n-    if let Some(closure_kind) = tcx.closure_kinds.borrow().get(&ast_util::local_def(id)) {\n+    if let Some(closure_kind) = tcx.tables.borrow().closure_kinds.get(&ast_util::local_def(id)) {\n         rbml_w.tag(c::tag_table_closure_kinds, |rbml_w| {\n             rbml_w.id(id);\n             encode_closure_kind(rbml_w, *closure_kind)\n@@ -1146,8 +1079,6 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers<'tcx> {\n-    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                  -> ty::MethodOrigin<'tcx>;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1231,88 +1162,6 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                  -> ty::MethodOrigin<'tcx>\n-    {\n-        self.read_enum(\"MethodOrigin\", |this| {\n-            let variants = &[\"MethodStatic\", \"MethodStaticClosure\",\n-                             \"MethodTypeParam\", \"MethodTraitObject\"];\n-            this.read_enum_variant(variants, |this, i| {\n-                Ok(match i {\n-                    0 => {\n-                        let def_id = this.read_def_id(dcx);\n-                        ty::MethodStatic(def_id)\n-                    }\n-\n-                    1 => {\n-                        let def_id = this.read_def_id(dcx);\n-                        ty::MethodStaticClosure(def_id)\n-                    }\n-\n-                    2 => {\n-                        this.read_struct(\"MethodTypeParam\", 2, |this| {\n-                            Ok(ty::MethodTypeParam(\n-                                ty::MethodParam {\n-                                    trait_ref: {\n-                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    method_num: {\n-                                        this.read_struct_field(\"method_num\", 1, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                    impl_def_id: {\n-                                        this.read_struct_field(\"impl_def_id\", 2, |this| {\n-                                            this.read_option(|this, b| {\n-                                                if b {\n-                                                    Ok(Some(this.read_def_id(dcx)))\n-                                                } else {\n-                                                    Ok(None)\n-                                                }\n-                                            })\n-                                        }).unwrap()\n-                                    }\n-                                }))\n-                        }).unwrap()\n-                    }\n-\n-                    3 => {\n-                        this.read_struct(\"MethodTraitObject\", 2, |this| {\n-                            Ok(ty::MethodTraitObject(\n-                                ty::MethodObject {\n-                                    trait_ref: {\n-                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_trait_ref(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    object_trait_id: {\n-                                        this.read_struct_field(\"object_trait_id\", 1, |this| {\n-                                            Ok(this.read_def_id(dcx))\n-                                        }).unwrap()\n-                                    },\n-                                    method_num: {\n-                                        this.read_struct_field(\"method_num\", 2, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                    vtable_index: {\n-                                        this.read_struct_field(\"vtable_index\", 3, |this| {\n-                                            this.read_uint()\n-                                        }).unwrap()\n-                                    },\n-                                }))\n-                        }).unwrap()\n-                    }\n-\n-                    _ => panic!(\"..\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-\n-\n     fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1630,7 +1479,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let item_substs = ty::ItemSubsts {\n                             substs: val_dsr.read_substs(dcx)\n                         };\n-                        dcx.tcx.item_substs.borrow_mut().insert(\n+                        dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);\n                     }\n                     c::tag_table_freevars => {\n@@ -1646,39 +1495,39 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             closure_expr_id: id\n                         };\n                         let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_capture_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n+                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-                        dcx.tcx.tcache.borrow_mut().insert(lid, type_scheme);\n+                        dcx.tcx.register_item_type(lid, type_scheme);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(dcx);\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n                         let (autoderef, method) = val_dsr.read_method_callee(dcx);\n-                        let method_call = MethodCall {\n+                        let method_call = ty::MethodCall {\n                             expr_id: id,\n                             autoderef: autoderef\n                         };\n-                        dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n+                        dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n-                        dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n+                        dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n                     }\n                     c::tag_table_closure_tys => {\n                         let closure_ty =\n                             val_dsr.read_closure_ty(dcx);\n-                        dcx.tcx.closure_tys.borrow_mut().insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_tys.insert(ast_util::local_def(id),\n                                                                 closure_ty);\n                     }\n                     c::tag_table_closure_kinds => {\n                         let closure_kind =\n                             val_dsr.read_closure_kind(dcx);\n-                        dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n+                        dcx.tcx.tables.borrow_mut().closure_kinds.insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n                     c::tag_table_cast_kinds => {"}, {"sha": "bbd452b35acdf7732a5cb04d7708f11e28fa2828", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -36,9 +36,9 @@ pub enum CastTy<'tcx> {\n     /// Function Pointers\n     FnPtr,\n     /// Raw pointers\n-    Ptr(&'tcx ty::mt<'tcx>),\n+    Ptr(&'tcx ty::TypeAndMut<'tcx>),\n     /// References\n-    RPtr(&'tcx ty::mt<'tcx>),\n+    RPtr(&'tcx ty::TypeAndMut<'tcx>),\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n@@ -66,8 +66,8 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(..) if ty::type_is_c_like_enum(\n-                tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n+            ty::TyEnum(..) if t.is_c_like_enum(tcx) =>\n+                Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n             ty::TyBareFn(..) => Some(CastTy::FnPtr),"}, {"sha": "d4737f9d604d154467a10a6a5332248032ce0c1a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(expr) => {\n+            ast::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n@@ -342,7 +342,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.straightline(expr, pred, fields)\n             }\n \n-            ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n+            ast::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }\n \n@@ -411,14 +411,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().get(&method_call) {\n+        let fn_ty = match self.tcx.tables.borrow().method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => ty::expr_ty_adjusted(self.tcx, func_or_rcvr)\n-        });\n+            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n+        };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if return_ty.diverges() {\n+        if fn_ty.fn_ret().diverges() {\n             self.add_unreachable_node()\n         } else {\n             ret\n@@ -631,9 +631,4 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_call = ty::MethodCall::expr(expr.id);\n-        self.tcx.method_map.borrow().contains_key(&method_call)\n-    }\n }"}, {"sha": "baaf6b6a0401d545355bf109e1435418983485d4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -26,6 +26,7 @@\n \n use middle::cast::{CastKind};\n use middle::const_eval;\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n@@ -39,6 +40,7 @@ use syntax::codemap::Span;\n use syntax::visit::{self, Visitor};\n \n use std::collections::hash_map::Entry;\n+use std::cmp::Ordering;\n \n // Const qualification, from partial to completely promotable.\n bitflags! {\n@@ -110,14 +112,16 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'tcx,\n-                                    ty::ParameterEnvironment<'a, 'tcx>>) -> R,\n+        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'b, 'tcx>) -> R,\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n-            None => ty::empty_parameter_environment(self.tcx)\n+            None => self.tcx.empty_parameter_environment()\n         };\n-        f(&mut euv::ExprUseVisitor::new(self, &param_env))\n+\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), false);\n+\n+        f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n \n     fn global_expr(&mut self, mode: Mode, expr: &ast::Expr) -> ConstQualif {\n@@ -231,7 +235,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                                       fn_like.id());\n             self.add_qualif(qualif);\n \n-            if ty::type_contents(self.tcx, ret_ty).interior_unsafe() {\n+            if ret_ty.type_contents(self.tcx).interior_unsafe() {\n                 self.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n \n@@ -266,8 +270,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_static_mut_type(&self, e: &ast::Expr) {\n-        let node_ty = ty::node_id_to_type(self.tcx, e.id);\n-        let tcontents = ty::type_contents(self.tcx, node_ty);\n+        let node_ty = self.tcx.node_id_to_type(e.id);\n+        let tcontents = node_ty.type_contents(self.tcx);\n \n         let suffix = if tcontents.has_dtor() {\n             \"destructors\"\n@@ -282,13 +286,12 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n-        let ty = ty::node_id_to_type(self.tcx, e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new(false);\n+        let ty = self.tcx.node_id_to_type(e.id);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+        let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        let env = ty::empty_parameter_environment(self.tcx);\n-        match fulfill_cx.select_all_or_error(&infcx, &env) {\n+        match fulfill_cx.select_all_or_error(&infcx) {\n             Ok(()) => { },\n             Err(ref errors) => {\n                 traits::report_fulfillment_errors(&infcx, errors);\n@@ -364,6 +367,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n             ast::PatRange(ref start, ref end) => {\n                 self.global_expr(Mode::Const, &**start);\n                 self.global_expr(Mode::Const, &**end);\n+\n+                match const_eval::compare_lit_exprs(self.tcx, start, end) {\n+                    Some(Ordering::Less) |\n+                    Some(Ordering::Equal) => {}\n+                    Some(Ordering::Greater) => {\n+                        span_err!(self.tcx.sess, start.span, E0030,\n+                            \"lower range bound must be less than or equal to upper\");\n+                    }\n+                    None => {\n+                        self.tcx.sess.span_bug(\n+                            start.span, \"literals of different types in range pat\");\n+                    }\n+                }\n             }\n             _ => visit::walk_pat(self, p)\n         }\n@@ -402,8 +418,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n \n-        let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n+        let node_ty = self.tcx.node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n+        check_adjustments(self, ex);\n \n         // Special-case some expressions to avoid certain flags bubbling up.\n         match ex.node {\n@@ -455,7 +472,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 match node_ty.sty {\n                     ty::TyUint(_) | ty::TyInt(_) if div_or_rem => {\n                         if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n-                            match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n+                            match const_eval::eval_const_expr_partial(\n+                                    self.tcx, ex, ExprTypeChecked) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n                                     span_err!(self.tcx.sess, msg.span, E0020,\n@@ -479,7 +497,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // initializer values (very bad).\n                 // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n                 // propagated from another error, so erroring again would be just noise.\n-                let tc = ty::type_contents(self.tcx, node_ty);\n+                let tc = node_ty.type_contents(self.tcx);\n                 if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n                     outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n@@ -529,7 +547,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(did, _) |\n-        ty::TyEnum(did, _) if ty::has_dtor(v.tcx, did) => {\n+        ty::TyEnum(did, _) if v.tcx.has_dtor(did) => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n@@ -544,7 +562,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     match e.node {\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n-        ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n+        ast::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n@@ -560,7 +578,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprUnary(op, ref inner) => {\n-            match ty::node_id_to_type(v.tcx, inner.id).sty {\n+            match v.tcx.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == ast::UnDeref);\n \n@@ -574,7 +592,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprBinary(op, ref lhs, _) => {\n-            match ty::node_id_to_type(v.tcx, lhs.id).sty {\n+            match v.tcx.node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == ast::BiEq || op.node == ast::BiNe ||\n                             op.node == ast::BiLe || op.node == ast::BiLt ||\n@@ -695,13 +713,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprMethodCall(..) => {\n-            let method_did = match v.tcx.method_map.borrow()[&method_call].origin {\n-                ty::MethodStatic(did) => Some(did),\n-                _ => None\n-            };\n-            let is_const = match method_did {\n-                Some(did) => v.handle_const_fn_call(e, did, node_ty),\n-                None => false\n+            let method = v.tcx.tables.borrow().method_map[&method_call];\n+            let is_const = match v.tcx.impl_or_trait_item(method.def_id).container() {\n+                ty::ImplContainer(_) => v.handle_const_fn_call(e, method.def_id, node_ty),\n+                ty::TraitContainer(_) => false\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n@@ -731,7 +746,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprClosure(..) => {\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n+            if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n                         \"global closures can't capture anything\");\n                 v.add_qualif(ConstQualif::NOT_CONST);\n@@ -779,6 +794,25 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     }\n }\n \n+/// Check the adjustments of an expression\n+fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &ast::Expr) {\n+    match v.tcx.tables.borrow().adjustments.get(&e.id) {\n+        None | Some(&ty::AdjustReifyFnPointer) | Some(&ty::AdjustUnsafeFnPointer) => {}\n+        Some(&ty::AdjustDerefRef(ty::AutoDerefRef { autoderefs, .. })) => {\n+            if (0..autoderefs as u32).any(|autoderef| {\n+                    v.tcx.is_overloaded_autoderef(e.id, autoderef)\n+            }) {\n+                v.add_qualif(ConstQualif::NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0400,\n+                              \"user-defined dereference operators are not allowed in {}s\",\n+                              v.msg());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut CheckCrateVisitor {\n         tcx: tcx,"}, {"sha": "7c02045d0838855f7f101544c334226787f77d6f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -15,12 +15,14 @@ use self::WitnessPreference::*;\n use middle::const_eval::{compare_const_vals, ConstVal};\n use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n+use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::WriteAndRead;\n use middle::expr_use_visitor as euv;\n-use middle::mem_categorization::cmt;\n+use middle::infer;\n+use middle::mem_categorization::{cmt};\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n@@ -98,6 +100,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n     }\n }\n \n+//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub param_env: ParameterEnvironment<'a, 'tcx>,\n@@ -149,7 +152,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut MatchCheckCtxt {\n         tcx: tcx,\n-        param_env: ty::empty_parameter_environment(tcx),\n+        param_env: tcx.empty_parameter_environment(),\n     }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n@@ -203,9 +206,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n+            let pat_ty = cx.tcx.node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !type_is_empty(cx.tcx, pat_ty) {\n+                if !pat_ty.is_empty(cx.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n                               \"non-exhaustive patterns: type {} is non-empty\",\n@@ -231,11 +234,11 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n     ast_util::walk_pat(pat, |p| {\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n-                let pat_ty = ty::pat_ty(cx.tcx, p);\n+                let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(def_id, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n-                        if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n+                        if cx.tcx.enum_variants(def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n                                 && variant.args.is_empty()\n                         ) {\n@@ -261,7 +264,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     ast_util::walk_pat(pat, |p| {\n         if let ast::PatLit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &**expr, None) {\n+            match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                                \"unmatchable NaN in pattern, \\\n@@ -509,12 +512,12 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n                 &Variant(vid) =>\n-                    (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n+                    (vid, cx.tcx.enum_variant_with_id(cid, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid, !ty::is_tuple_struct(cx.tcx, cid))\n+                    (cid, !cx.tcx.is_tuple_struct(cid))\n             };\n             if is_structure {\n-                let fields = ty::lookup_struct_fields(cx.tcx, vid);\n+                let fields = cx.tcx.lookup_struct_fields(vid);\n                 let field_pats: Vec<_> = fields.into_iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n@@ -533,7 +536,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             }\n         }\n \n-        ty::TyRef(_, ty::mt { ty, mutbl }) => {\n+        ty::TyRef(_, ty::TypeAndMut { ty, mutbl }) => {\n             match ty.sty {\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n@@ -598,14 +601,14 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n \n-        ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n+        ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n             ty::TySlice(_) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n             _ => vec!(Single)\n         },\n \n         ty::TyEnum(eid, _) =>\n-            ty::enum_variants(cx.tcx, eid)\n+            cx.tcx.enum_variants(eid)\n                 .iter()\n                 .map(|va| Variant(va.id))\n                 .collect(),\n@@ -651,12 +654,14 @@ fn is_useful(cx: &MatchCheckCtxt,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        ty::mk_nil(cx.tcx)\n+        cx.tcx.mk_nil()\n     } else {\n-        let left_ty = ty::pat_ty(cx.tcx, &*real_pat);\n+        let left_ty = cx.tcx.pat_ty(&*real_pat);\n \n         match real_pat.node {\n-            ast::PatIdent(ast::BindByRef(..), _, _) => ty::deref(left_ty, false).unwrap().ty,\n+            ast::PatIdent(ast::BindByRef(..), _, _) => {\n+                left_ty.builtin_deref(false).unwrap().ty\n+            }\n             _ => left_ty,\n         }\n     };\n@@ -692,15 +697,15 @@ fn is_useful(cx: &MatchCheckCtxt,\n             Some(constructor) => {\n                 let matrix = rows.iter().filter_map(|r| {\n                     if pat_is_binding_or_wild(&cx.tcx.def_map, raw_pat(r[0])) {\n-                        Some(r.tail().to_vec())\n+                        Some(r[1..].to_vec())\n                     } else {\n                         None\n                     }\n                 }).collect();\n-                match is_useful(cx, &matrix, v.tail(), witness) {\n+                match is_useful(cx, &matrix, &v[1..], witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats: Vec<_> = repeat(DUMMY_WILD_PAT).take(arity).collect();\n+                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats);\n@@ -804,7 +809,7 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n-        ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n+        ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n             ty::TySlice(_) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0,\n@@ -815,11 +820,11 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n         },\n         ty::TyEnum(eid, _) => {\n             match *ctor {\n-                Variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                Variant(id) => cx.tcx.enum_variant_with_id(eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n-        ty::TyStruct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n+        ty::TyStruct(cid, _) => cx.tcx.lookup_struct_fields(cid).len(),\n         ty::TyArray(_, n) => n,\n         _ => 0\n     }\n@@ -858,7 +863,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n         ast::PatWild(_) =>\n-            Some(repeat(DUMMY_WILD_PAT).take(arity).collect()),\n+            Some(vec![DUMMY_WILD_PAT; arity]),\n \n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n@@ -871,7 +876,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 } else {\n                     None\n                 },\n-                _ => Some(repeat(DUMMY_WILD_PAT).take(arity).collect())\n+                _ => Some(vec![DUMMY_WILD_PAT; arity])\n             }\n         }\n \n@@ -885,7 +890,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => repeat(DUMMY_WILD_PAT).take(arity).collect(),\n+                        &None => vec![DUMMY_WILD_PAT; arity],\n                     })\n                 }\n                 _ => None\n@@ -911,7 +916,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 },\n                 _ => {\n                     // Assume this is a struct.\n-                    match ty::ty_to_def_id(node_id_to_type(cx.tcx, pat_id)) {\n+                    match cx.tcx.node_id_to_type(pat_id).ty_to_def_id() {\n                         None => {\n                             cx.tcx.sess.span_bug(pat_span,\n                                                  \"struct pattern wasn't of a \\\n@@ -922,7 +927,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 }\n             };\n             class_id.map(|variant_id| {\n-                let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                let struct_fields = cx.tcx.lookup_struct_fields(variant_id);\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.ident.name == sf.name) {\n                         Some(ref f) => &*f.node.pat,\n@@ -1011,18 +1016,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n     visit::walk_local(cx, loc);\n \n-    let name = match loc.source {\n-        ast::LocalLet => \"local\",\n-        ast::LocalFor => \"`for` loop\"\n-    };\n-\n-    let mut static_inliner = StaticInliner::new(cx.tcx, None);\n-    is_refutable(cx, &*static_inliner.fold_pat(loc.pat.clone()), |pat| {\n-        span_err!(cx.tcx.sess, loc.pat.span, E0005,\n-            \"refutable pattern in {} binding: `{}` not covered\",\n-            name, pat_to_string(pat)\n-        );\n-    });\n+    let pat = StaticInliner::new(cx.tcx, None).fold_pat(loc.pat.clone());\n+    check_irrefutable(cx, &pat, false);\n \n     // Check legality of move bindings and `@` patterns.\n     check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n@@ -1043,17 +1038,28 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     visit::walk_fn(cx, kind, decl, body, sp);\n \n     for input in &decl.inputs {\n-        is_refutable(cx, &*input.pat, |pat| {\n-            span_err!(cx.tcx.sess, input.pat.span, E0006,\n-                \"refutable pattern in function argument: `{}` not covered\",\n-                pat_to_string(pat)\n-            );\n-        });\n+        check_irrefutable(cx, &input.pat, true);\n         check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n         check_legality_of_bindings_in_at_patterns(cx, &*input.pat);\n     }\n }\n \n+fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n+    let origin = if is_fn_arg {\n+        \"function argument\"\n+    } else {\n+        \"local binding\"\n+    };\n+\n+    is_refutable(cx, pat, |uncovered_pat| {\n+        span_err!(cx.tcx.sess, pat.span, E0005,\n+            \"refutable pattern in {}: `{}` not covered\",\n+            origin,\n+            pat_to_string(uncovered_pat),\n+        );\n+    });\n+}\n+\n fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n     F: FnOnce(&Pat) -> A,\n {\n@@ -1107,8 +1113,13 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n-                        let pat_ty = ty::node_id_to_type(tcx, p.id);\n-                        if ty::type_moves_by_default(&cx.param_env, pat.span, pat_ty) {\n+                        let pat_ty = tcx.node_id_to_type(p.id);\n+                        //FIXME: (@jroesch) this code should be floated up as well\n+                        let infcx = infer::new_infer_ctxt(cx.tcx,\n+                                                          &cx.tcx.tables,\n+                                                          Some(cx.param_env.clone()),\n+                                                          false);\n+                        if infcx.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n@@ -1136,8 +1147,13 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n-    let mut visitor = ExprUseVisitor::new(&mut checker,\n-                                          &checker.cx.param_env);\n+\n+    let infcx = infer::new_infer_ctxt(cx.tcx,\n+                                      &cx.tcx.tables,\n+                                      Some(checker.cx.param_env.clone()),\n+                                      false);\n+\n+    let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n     visitor.walk_expr(guard);\n }\n "}, {"sha": "c9017432473a7b5c8e100eec0fbd53583eefbb18", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -12,6 +12,7 @@\n // is the public starting point.\n \n use middle::expr_use_visitor as euv;\n+use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty::ParameterEnvironment;\n use middle::ty;\n@@ -38,9 +39,14 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         {\n+            // FIXME (@jroesch) change this to be an inference context\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n+            let infcx = infer::new_infer_ctxt(self.tcx,\n+                                              &self.tcx.tables,\n+                                              Some(param_env.clone()),\n+                                              false);\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n-            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &param_env);\n+            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);\n         }\n         visit::walk_fn(self, fk, fd, b, s)\n@@ -59,7 +65,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n+        if !cmt.ty.is_sized(self.param_env, span) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 cmt.ty);"}, {"sha": "55a9a91930045fc8109b7cd8a164188f47411945", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 162, "deletions": 36, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,73 +8,96 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This compiler pass detects static items that refer to themselves\n+// This compiler pass detects constants that refer to themselves\n // recursively.\n \n use ast_map;\n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefMap};\n+use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefVariant, DefMap};\n+use util::nodemap::NodeMap;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n+use syntax::feature_gate::emit_feature_err;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n+use std::cell::RefCell;\n+\n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n     def_map: &'a DefMap,\n-    ast_map: &'a ast_map::Map<'ast>\n+    ast_map: &'a ast_map::Map<'ast>,\n+    // `discriminant_map` is a cache that associates the `NodeId`s of local\n+    // variant definitions with the discriminant expression that applies to\n+    // each one. If the variant uses the default values (starting from `0`),\n+    // then `None` is stored.\n+    discriminant_map: RefCell<NodeMap<Option<&'ast ast::Expr>>>,\n }\n \n-impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n+    fn visit_item(&mut self, it: &'ast ast::Item) {\n         match it.node {\n-            ast::ItemStatic(_, _, ref expr) |\n-            ast::ItemConst(_, ref expr) => {\n+            ast::ItemStatic(..) |\n+            ast::ItemConst(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &it.span);\n                 recursion_visitor.visit_item(it);\n-                visit::walk_expr(self, &*expr)\n             },\n-            _ => visit::walk_item(self, it)\n+            ast::ItemEnum(ref enum_def, ref generics) => {\n+                // We could process the whole enum, but handling the variants\n+                // with discriminant expressions one by one gives more specific,\n+                // less redundant output.\n+                for variant in &enum_def.variants {\n+                    if let Some(_) = variant.node.disr_expr {\n+                        let mut recursion_visitor =\n+                            CheckItemRecursionVisitor::new(self, &variant.span);\n+                        recursion_visitor.populate_enum_discriminants(enum_def);\n+                        recursion_visitor.visit_variant(variant, generics);\n+                    }\n+                }\n+            }\n+            _ => {}\n         }\n+        visit::walk_item(self, it)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'ast ast::TraitItem) {\n         match ti.node {\n             ast::ConstTraitItem(_, ref default) => {\n-                if let Some(ref expr) = *default {\n+                if let Some(_) = *default {\n                     let mut recursion_visitor =\n                         CheckItemRecursionVisitor::new(self, &ti.span);\n                     recursion_visitor.visit_trait_item(ti);\n-                    visit::walk_expr(self, &*expr)\n                 }\n             }\n-            _ => visit::walk_trait_item(self, ti)\n+            _ => {}\n         }\n+        visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast ast::ImplItem) {\n         match ii.node {\n-            ast::ConstImplItem(_, ref expr) => {\n+            ast::ConstImplItem(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &ii.span);\n                 recursion_visitor.visit_impl_item(ii);\n-                visit::walk_expr(self, &*expr)\n             }\n-            _ => visit::walk_impl_item(self, ii)\n+            _ => {}\n         }\n+        visit::walk_impl_item(self, ii)\n     }\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         krate: &ast::Crate,\n+                         krate: &'ast ast::Crate,\n                          def_map: &DefMap,\n                          ast_map: &ast_map::Map<'ast>) {\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         def_map: def_map,\n-        ast_map: ast_map\n+        ast_map: ast_map,\n+        discriminant_map: RefCell::new(NodeMap()),\n     };\n     visit::walk_crate(&mut visitor, krate);\n     sess.abort_if_errors();\n@@ -85,53 +108,139 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a DefMap,\n-    idstack: Vec<ast::NodeId>\n+    discriminant_map: &'a RefCell<NodeMap<Option<&'ast ast::Expr>>>,\n+    idstack: Vec<ast::NodeId>,\n }\n \n impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n-    fn new(v: &CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+    fn new(v: &'a CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n            -> CheckItemRecursionVisitor<'a, 'ast> {\n         CheckItemRecursionVisitor {\n             root_span: span,\n             sess: v.sess,\n             ast_map: v.ast_map,\n             def_map: v.def_map,\n-            idstack: Vec::new()\n+            discriminant_map: &v.discriminant_map,\n+            idstack: Vec::new(),\n         }\n     }\n     fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n           where F: Fn(&mut Self) {\n-        if self.idstack.iter().any(|x| x == &(id)) {\n-            span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+        if self.idstack.iter().any(|&x| x == id) {\n+            let any_static = self.idstack.iter().any(|&x| {\n+                if let ast_map::NodeItem(item) = self.ast_map.get(x) {\n+                    if let ast::ItemStatic(..) = item.node {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    false\n+                }\n+            });\n+            if any_static {\n+                if !self.sess.features.borrow().static_recursion {\n+                    emit_feature_err(&self.sess.parse_sess.span_diagnostic,\n+                                     \"static_recursion\",\n+                                     *self.root_span, \"recursive static\");\n+                }\n+            } else {\n+                span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+            }\n             return;\n         }\n         self.idstack.push(id);\n         f(self);\n         self.idstack.pop();\n     }\n+    // If a variant has an expression specifying its discriminant, then it needs\n+    // to be checked just like a static or constant. However, if there are more\n+    // variants with no explicitly specified discriminant, those variants will\n+    // increment the same expression to get their values.\n+    //\n+    // So for every variant, we need to track whether there is an expression\n+    // somewhere in the enum definition that controls its discriminant. We do\n+    // this by starting from the end and searching backward.\n+    fn populate_enum_discriminants(&self, enum_definition: &'ast ast::EnumDef) {\n+        // Get the map, and return if we already processed this enum or if it\n+        // has no variants.\n+        let mut discriminant_map = self.discriminant_map.borrow_mut();\n+        match enum_definition.variants.first() {\n+            None => { return; }\n+            Some(variant) if discriminant_map.contains_key(&variant.node.id) => {\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        // Go through all the variants.\n+        let mut variant_stack: Vec<ast::NodeId> = Vec::new();\n+        for variant in enum_definition.variants.iter().rev() {\n+            variant_stack.push(variant.node.id);\n+            // When we find an expression, every variant currently on the stack\n+            // is affected by that expression.\n+            if let Some(ref expr) = variant.node.disr_expr {\n+                for id in &variant_stack {\n+                    discriminant_map.insert(*id, Some(expr));\n+                }\n+                variant_stack.clear()\n+            }\n+        }\n+        // If we are at the top, that always starts at 0, so any variant on the\n+        // stack has a default value and does not need to be checked.\n+        for id in &variant_stack {\n+            discriminant_map.insert(*id, None);\n+        }\n+    }\n }\n \n-impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n+    fn visit_item(&mut self, it: &'ast ast::Item) {\n         self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n     }\n \n-    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+    fn visit_enum_def(&mut self, enum_definition: &'ast ast::EnumDef,\n+                      generics: &'ast ast::Generics) {\n+        self.populate_enum_discriminants(enum_definition);\n+        visit::walk_enum_def(self, enum_definition, generics);\n+    }\n+\n+    fn visit_variant(&mut self, variant: &'ast ast::Variant,\n+                     _: &'ast ast::Generics) {\n+        let variant_id = variant.node.id;\n+        let maybe_expr;\n+        if let Some(get_expr) = self.discriminant_map.borrow().get(&variant_id) {\n+            // This is necessary because we need to let the `discriminant_map`\n+            // borrow fall out of scope, so that we can reborrow farther down.\n+            maybe_expr = (*get_expr).clone();\n+        } else {\n+            self.sess.span_bug(variant.span,\n+                               \"`check_static_recursion` attempted to visit \\\n+                                variant with unknown discriminant\")\n+        }\n+        // If `maybe_expr` is `None`, that's because no discriminant is\n+        // specified that affects this variant. Thus, no risk of recursion.\n+        if let Some(expr) = maybe_expr {\n+            self.with_item_id_pushed(expr.id, |v| visit::walk_expr(v, expr));\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'ast ast::TraitItem) {\n         self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'ast ast::ImplItem) {\n         self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &'ast ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id, _)) |\n-                    Some(DefConst(def_id)) if\n-                            ast_util::is_local(def_id) => {\n+                    Some(DefConst(def_id))\n+                           if ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>\n                             self.visit_item(item),\n@@ -141,11 +250,28 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                             self.visit_impl_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n-                            span_err!(self.sess, e.span, E0266,\n-                              \"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node));\n-                            return;\n-                          },\n+                              self.sess.span_bug(\n+                                  e.span,\n+                                  &format!(\"expected item, found {}\",\n+                                           self.ast_map.node_to_string(def_id.node)));\n+                          }\n+                        }\n+                    }\n+                    // For variants, we only want to check expressions that\n+                    // affect the specific variant used, but we need to check\n+                    // the whole enum definition to see what expression that\n+                    // might be (if any).\n+                    Some(DefVariant(enum_id, variant_id, false))\n+                           if ast_util::is_local(enum_id) => {\n+                        if let ast::ItemEnum(ref enum_def, ref generics) =\n+                               self.ast_map.expect_item(enum_id.local_id()).node {\n+                            self.populate_enum_discriminants(enum_def);\n+                            let variant = self.ast_map.expect_variant(variant_id.local_id());\n+                            self.visit_variant(variant, generics);\n+                        } else {\n+                            self.sess.span_bug(e.span,\n+                                \"`check_static_recursion` found \\\n+                                 non-enum in DefVariant\");\n                         }\n                     }\n                     _ => ()"}, {"sha": "a349dab0f72ea990daffca4c82c5608b03ae4f2b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 147, "deletions": 103, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n #![allow(non_camel_case_types)]\n-#![allow(unsigned_negation)]\n \n use self::ConstVal::*;\n-\n use self::ErrKind::*;\n+use self::EvalHint::*;\n \n use ast_map;\n use ast_map::blocks::FnLikeNode;\n@@ -27,7 +26,6 @@ use util::num::ToPrimitive;\n use syntax::ast::{self, Expr};\n use syntax::ast_util;\n use syntax::codemap::Span;\n-use syntax::feature_gate;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::{codemap, visit};\n@@ -126,9 +124,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         Some(ref_id) => {\n-                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                            let trait_id = tcx.trait_of_item(def_id)\n                                               .unwrap();\n-                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                            let substs = tcx.node_id_item_substs(ref_id)\n                                             .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs)\n@@ -176,7 +174,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // a trait-associated const if the caller gives us\n                         // the expression that refers to it.\n                         Some(ref_id) => {\n-                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                            let substs = tcx.node_id_item_substs(ref_id)\n                                             .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs).map(|e| e.id)\n@@ -273,6 +271,22 @@ pub enum ConstVal {\n     Tuple(ast::NodeId),\n }\n \n+impl ConstVal {\n+    pub fn description(&self) -> &'static str {\n+        match *self {\n+            Float(_) => \"float\",\n+            Int(i) if i < 0 => \"negative integer\",\n+            Int(_) => \"positive integer\",\n+            Uint(_) => \"unsigned integer\",\n+            Str(_) => \"string literal\",\n+            Binary(_) => \"binary array\",\n+            Bool(_) => \"boolean\",\n+            Struct(_) => \"struct\",\n+            Tuple(_) => \"tuple\",\n+        }\n+    }\n+}\n+\n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat> {\n     let pat = match expr.node {\n         ast::ExprTup(ref exprs) =>\n@@ -331,7 +345,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> ConstVal {\n-    match eval_const_expr_partial(tcx, e, None) {\n+    match eval_const_expr_partial(tcx, e, ExprTypeChecked) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(s.span, &s.description())\n     }\n@@ -352,16 +366,8 @@ pub enum ErrKind {\n     InvalidOpForFloats(ast::BinOp_),\n     InvalidOpForIntUint(ast::BinOp_),\n     InvalidOpForUintInt(ast::BinOp_),\n-    NegateOnString,\n-    NegateOnBoolean,\n-    NegateOnBinary,\n-    NegateOnStruct,\n-    NegateOnTuple,\n-    NotOnFloat,\n-    NotOnString,\n-    NotOnBinary,\n-    NotOnStruct,\n-    NotOnTuple,\n+    NegateOn(ConstVal),\n+    NotOn(ConstVal),\n \n     NegateWithOverflow(i64),\n     AddiWithOverflow(i64, i64),\n@@ -397,16 +403,8 @@ impl ConstEvalErr {\n             InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n             InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n             InvalidOpForUintInt(..) => \"can't do this op on a usize and isize\".into_cow(),\n-            NegateOnString => \"negate on string\".into_cow(),\n-            NegateOnBoolean => \"negate on boolean\".into_cow(),\n-            NegateOnBinary => \"negate on binary literal\".into_cow(),\n-            NegateOnStruct => \"negate on struct\".into_cow(),\n-            NegateOnTuple => \"negate on tuple\".into_cow(),\n-            NotOnFloat => \"not on float or string\".into_cow(),\n-            NotOnString => \"not on float or string\".into_cow(),\n-            NotOnBinary => \"not on binary literal\".into_cow(),\n-            NotOnStruct => \"not on struct\".into_cow(),\n-            NotOnTuple => \"not on tuple\".into_cow(),\n+            NegateOn(ref const_val) => format!(\"negate on {}\", const_val.description()).into_cow(),\n+            NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n \n             NegateWithOverflow(..) => \"attempted to negate with overflow\".into_cow(),\n             AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n@@ -436,6 +434,28 @@ impl ConstEvalErr {\n pub type EvalResult = Result<ConstVal, ConstEvalErr>;\n pub type CastResult = Result<ConstVal, ErrKind>;\n \n+// FIXME: Long-term, this enum should go away: trying to evaluate\n+// an expression which hasn't been type-checked is a recipe for\n+// disaster.  That said, it's not clear how to fix ast_ty_to_ty\n+// to avoid the ordering issue.\n+\n+/// Hint to determine how to evaluate constant expressions which\n+/// might not be type-checked.\n+#[derive(Copy, Clone, Debug)]\n+pub enum EvalHint<'tcx> {\n+    /// We have a type-checked expression.\n+    ExprTypeChecked,\n+    /// We have an expression which hasn't been type-checked, but we have\n+    /// an idea of what the type will be because of the context. For example,\n+    /// the length of an array is always `usize`. (This is referred to as\n+    /// a hint because it isn't guaranteed to be consistent with what\n+    /// type-checking would compute.)\n+    UncheckedExprHint(Ty<'tcx>),\n+    /// We have an expression which has not yet been type-checked, and\n+    /// and we have no clue what the type will be.\n+    UncheckedExprNoHint,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum IntTy { I8, I16, I32, I64 }\n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -706,26 +726,34 @@ pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n            uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n }}\n \n-// After type checking, `eval_const_expr_partial` should always suffice. The\n-// reason for providing `eval_const_expr_with_substs` is to allow\n-// trait-associated consts to be evaluated *during* type checking, when the\n-// substs for each expression have not been written into `tcx` yet.\n+/// Evaluate a constant expression in a context where the expression isn't\n+/// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n+/// but a few places need to evaluate constants during type-checking, like\n+/// computing the length of an array. (See also the FIXME above EvalHint.)\n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n-                                     ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n-    eval_const_expr_with_substs(tcx, e, ty_hint, |id| {\n-        ty::node_id_item_substs(tcx, id).substs\n-    })\n-}\n-\n-pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n-                                            e: &Expr,\n-                                            ty_hint: Option<Ty<'tcx>>,\n-                                            get_substs: S) -> EvalResult\n-        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n+                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n     fn fromb(b: bool) -> ConstVal { Int(b as i64) }\n \n-    let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n+    // Try to compute the type of the expression based on the EvalHint.\n+    // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n+    let ety = match ty_hint {\n+        ExprTypeChecked => {\n+            // After type-checking, expr_ty is guaranteed to succeed.\n+            Some(tcx.expr_ty(e))\n+        }\n+        UncheckedExprHint(ty) => {\n+            // Use the type hint; it's not guaranteed to be right, but it's\n+            // usually good enough.\n+            Some(ty)\n+        }\n+        UncheckedExprNoHint => {\n+            // This expression might not be type-checked, and we have no hint.\n+            // Try to query the context for a type anyway; we might get lucky\n+            // (for example, if the expression was imported from another crate).\n+            tcx.expr_ty_opt(e)\n+        }\n+    };\n \n     // If type of expression itself is int or uint, normalize in these\n     // bindings so that isize/usize is mapped to a type with an\n@@ -741,44 +769,35 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n \n     let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n           Float(f) => Float(-f),\n           Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n           Uint(i) => {\n-              if !tcx.sess.features.borrow().negate_unsigned {\n-                  feature_gate::emit_feature_err(\n-                      &tcx.sess.parse_sess.span_diagnostic,\n-                      \"negate_unsigned\",\n-                      e.span,\n-                      \"unary negation of unsigned integers may be removed in the future\");\n-              }\n               try!(const_uint_checked_neg(i, e, expr_uint_type))\n           }\n-          Str(_) => signal!(e, NegateOnString),\n-          Bool(_) => signal!(e, NegateOnBoolean),\n-          Binary(_) => signal!(e, NegateOnBinary),\n-          Tuple(_) => signal!(e, NegateOnTuple),\n-          Struct(..) => signal!(e, NegateOnStruct),\n+          const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint)) {\n           Int(i) => Int(!i),\n           Uint(i) => const_uint_not(i, expr_uint_type),\n           Bool(b) => Bool(!b),\n-          Str(_) => signal!(e, NotOnString),\n-          Float(_) => signal!(e, NotOnFloat),\n-          Binary(_) => signal!(e, NotOnBinary),\n-          Tuple(_) => signal!(e, NotOnTuple),\n-          Struct(..) => signal!(e, NotOnStruct),\n+          const_val => signal!(e, NotOn(const_val)),\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n-            ast::BiShl | ast::BiShr => Some(tcx.types.usize),\n-            _ => ety\n+            ast::BiShl | ast::BiShr => {\n+                if let ExprTypeChecked = ty_hint {\n+                    ExprTypeChecked\n+                } else {\n+                    UncheckedExprHint(tcx.types.usize)\n+                }\n+            }\n+            _ => ty_hint\n         };\n-        match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n+        match (try!(eval_const_expr_partial(tcx, &**a, ty_hint)),\n                try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n           (Float(a), Float(b)) => {\n             match op.node {\n@@ -868,22 +887,25 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       ast::ExprCast(ref base, ref target_ty) => {\n-        // This tends to get called w/o the type actually having been\n-        // populated in the ctxt, which was causing things to blow up\n-        // (#5900). Fall back to doing a limited lookup to get past it.\n         let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n \n-        // Prefer known type to noop, but always have a type hint.\n-        //\n-        // FIXME (#23833): the type-hint can cause problems,\n-        // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n-        // type to the sum, and thus no overflow is signaled.\n-        let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n-        let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n+        let base_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            // FIXME (#23833): the type-hint can cause problems,\n+            // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n+            // type to the sum, and thus no overflow is signaled.\n+            match tcx.expr_ty_opt(&base) {\n+                Some(t) => UncheckedExprHint(t),\n+                None => ty_hint\n+            }\n+        };\n+\n+        let val = try!(eval_const_expr_partial(tcx, &**base, base_hint));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n@@ -913,12 +935,16 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n                           def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   ast::ConstTraitItem(ref ty, _) => {\n-                                      let substs = get_substs(e.id);\n-                                      (resolve_trait_associated_const(tcx,\n-                                                                      ti,\n-                                                                      trait_id,\n-                                                                      substs),\n-                                       Some(&**ty))\n+                                      if let ExprTypeChecked = ty_hint {\n+                                          let substs = tcx.node_id_item_substs(e.id).substs;\n+                                          (resolve_trait_associated_const(tcx,\n+                                                                          ti,\n+                                                                          trait_id,\n+                                                                          substs),\n+                                           Some(&**ty))\n+                                       } else {\n+                                           (None, None)\n+                                       }\n                                   }\n                                   _ => (None, None)\n                               },\n@@ -941,33 +967,51 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n               Some(def::DefVariant(enum_def, variant_def, _)) => {\n                   (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n               }\n+              Some(def::DefStruct(_)) => {\n+                  return Ok(ConstVal::Struct(e.id))\n+              }\n               _ => (None, None)\n           };\n           let const_expr = match const_expr {\n               Some(actual_e) => actual_e,\n               None => signal!(e, NonConstPath)\n           };\n-          let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n-          try!(eval_const_expr_partial(tcx, const_expr, ety))\n+          let item_hint = if let UncheckedExprNoHint = ty_hint {\n+              match const_ty {\n+                  Some(ty) => match ast_ty_to_prim_ty(tcx, ty) {\n+                      Some(ty) => UncheckedExprHint(ty),\n+                      None => UncheckedExprNoHint\n+                  },\n+                  None => UncheckedExprNoHint\n+              }\n+          } else {\n+              ty_hint\n+          };\n+          try!(eval_const_expr_partial(tcx, const_expr, item_hint))\n       }\n       ast::ExprLit(ref lit) => {\n           lit_to_const(&**lit, ety)\n       }\n-      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ety)),\n+      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ty_hint)),\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ety)),\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint)),\n             None => Int(0)\n         }\n       }\n       ast::ExprTup(_) => Tuple(e.id),\n       ast::ExprStruct(..) => Struct(e.id),\n       ast::ExprTupField(ref base, index) => {\n-        if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n+        let base_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            UncheckedExprNoHint\n+        };\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n             if let Tuple(tup_id) = c {\n                 if let ast::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                     if index.node < fields.len() {\n-                        return eval_const_expr_partial(tcx, &fields[index.node], None)\n+                        return eval_const_expr_partial(tcx, &fields[index.node], base_hint)\n                     } else {\n                         signal!(e, TupleIndexOutOfBounds);\n                     }\n@@ -983,13 +1027,18 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n       }\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n-        if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n+        let base_hint = if let ExprTypeChecked = ty_hint {\n+            ExprTypeChecked\n+        } else {\n+            UncheckedExprNoHint\n+        };\n+        if let Ok(c) = eval_const_expr_partial(tcx, base, base_hint) {\n             if let Struct(struct_id) = c {\n                 if let ast::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     if let Some(f) = fields.iter().find(|f| f.ident.node.as_str()\n                                                          == field_name.node.as_str()) {\n-                        return eval_const_expr_partial(tcx, &*f.expr, None)\n+                        return eval_const_expr_partial(tcx, &*f.expr, base_hint)\n                     } else {\n                         signal!(e, MissingStructField);\n                     }\n@@ -1030,11 +1079,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n                                               substs: trait_substs });\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx);\n+    tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n \n-    let param_env = ty::empty_parameter_environment(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n@@ -1056,7 +1104,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n \n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n-            match ty::associated_consts(tcx, impl_data.impl_def_id)\n+            match tcx.associated_consts(impl_data.impl_def_id)\n                      .iter().find(|ic| ic.name == ti.ident.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n@@ -1166,21 +1214,17 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     })\n }\n \n-pub fn compare_lit_exprs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n-                                  a: &Expr,\n-                                  b: &Expr,\n-                                  ty_hint: Option<Ty<'tcx>>,\n-                                  get_substs: S) -> Option<Ordering>\n-        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n-    let a = match eval_const_expr_with_substs(tcx, a, ty_hint,\n-                                              |id| {get_substs(id)}) {\n+pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                               a: &Expr,\n+                               b: &Expr) -> Option<Ordering> {\n+    let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked) {\n         Ok(a) => a,\n         Err(e) => {\n             tcx.sess.span_err(a.span, &e.description());\n             return None;\n         }\n     };\n-    let b = match eval_const_expr_with_substs(tcx, b, ty_hint, get_substs) {\n+    let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked) {\n         Ok(b) => b,\n         Err(e) => {\n             tcx.sess.span_err(b.span, &e.description());"}, {"sha": "dea769197aa96c0d9adc0bb053f51ade53989057", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -21,7 +21,6 @@ use middle::cfg::CFGIndex;\n use middle::ty;\n use std::io;\n use std::usize;\n-use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n use syntax::visit;\n@@ -239,11 +238,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let entry = if oper.initial_value() { usize::MAX } else {0};\n \n-        let zeroes: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n-        let gens: Vec<_> = zeroes.clone();\n-        let kills1: Vec<_> = zeroes.clone();\n-        let kills2: Vec<_> = zeroes;\n-        let on_entry: Vec<_> = repeat(entry).take(num_nodes * words_per_id).collect();\n+        let zeroes = vec![0; num_nodes * words_per_id];\n+        let gens = zeroes.clone();\n+        let kills1 = zeroes.clone();\n+        let kills2 = zeroes;\n+        let on_entry = vec![entry; num_nodes * words_per_id];\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n \n@@ -511,7 +510,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n-            let mut temp: Vec<_> = repeat(0).take(words_per_id).collect();\n+            let mut temp = vec![0; words_per_id];\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(&mut temp);"}, {"sha": "8d2d6889b5efa529d384ae73f521e5e548875064", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 45, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -93,48 +93,16 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         });\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n-                                span: codemap::Span) {\n+    fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        match self.tcx.method_map.borrow().get(&method_call) {\n-            Some(method) => {\n-                match method.origin {\n-                    ty::MethodStatic(def_id) => {\n-                        match ty::provided_source(self.tcx, def_id) {\n-                            Some(p_did) => self.check_def_id(p_did),\n-                            None => self.check_def_id(def_id)\n-                        }\n-                    }\n-                    ty::MethodStaticClosure(_) => {}\n-                    ty::MethodTypeParam(ty::MethodParam {\n-                        ref trait_ref,\n-                        method_num: index,\n-                        ..\n-                    }) |\n-                    ty::MethodTraitObject(ty::MethodObject {\n-                        ref trait_ref,\n-                        method_num: index,\n-                        ..\n-                    }) => {\n-                        let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_ref.def_id,\n-                                                        index);\n-                        self.check_def_id(trait_item.def_id());\n-                    }\n-                }\n-            }\n-            None => {\n-                self.tcx.sess.span_bug(span,\n-                                       \"method call expression not \\\n-                                        in method map?!\")\n-            }\n-        }\n+        let method = self.tcx.tables.borrow().method_map[&method_call];\n+        self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n-        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n             ty::TyStruct(id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let fields = self.tcx.lookup_struct_fields(id);\n                 let field_id = fields.iter()\n                     .find(|field| field.name == name).unwrap().id;\n                 self.live_symbols.insert(field_id.node);\n@@ -144,9 +112,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n-        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n             ty::TyStruct(id, _) => {\n-                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let fields = self.tcx.lookup_struct_fields(id);\n                 let field_id = fields[idx].id;\n                 self.live_symbols.insert(field_id.node);\n             },\n@@ -159,8 +127,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n-                match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n-                                                           lhs.id)) {\n+                match self.tcx.node_id_to_type(lhs.id).ty_to_def_id() {\n                     None => {\n                         self.tcx.sess.span_bug(lhs.span,\n                                                \"struct pattern wasn't of a \\\n@@ -170,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 }\n             }\n         };\n-        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let fields = self.tcx.lookup_struct_fields(id);\n         for pat in pats {\n             if let ast::PatWild(ast::PatWildSingle) = pat.node.pat.node {\n                 continue;\n@@ -265,7 +232,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(expr.id, expr.span);\n+                self.lookup_and_handle_method(expr.id);\n             }\n             ast::ExprField(ref lhs, ref ident) => {\n                 self.handle_field_access(&**lhs, ident.node.name);\n@@ -480,8 +447,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n \n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n-        let field_type = ty::node_id_to_type(self.tcx, node.id);\n-        let is_marker_field = match ty::ty_to_def_id(field_type) {\n+        let field_type = self.tcx.node_id_to_type(node.id);\n+        let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n             _ => false\n         };"}, {"sha": "3fe1e2f5e8369903974114a506d532c48e1dd2d1", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,7 +10,7 @@\n \n //! Enforces the Rust effect system. Currently there is just one effect,\n //! `unsafe`.\n-use self::UnsafeContext::*;\n+use self::RootUnsafeContext::*;\n \n use middle::def;\n use middle::ty::{self, Ty};\n@@ -21,8 +21,20 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+#[derive(Copy, Clone)]\n+struct UnsafeContext {\n+    push_unsafe_count: usize,\n+    root: RootUnsafeContext,\n+}\n+\n+impl UnsafeContext {\n+    fn new(root: RootUnsafeContext) -> UnsafeContext {\n+        UnsafeContext { root: root, push_unsafe_count: 0 }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n-enum UnsafeContext {\n+enum RootUnsafeContext {\n     SafeContext,\n     UnsafeFn,\n     UnsafeBlock(ast::NodeId),\n@@ -44,7 +56,8 @@ struct EffectCheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n-        match self.unsafe_context {\n+        if self.unsafe_context.push_unsafe_count > 0 { return; }\n+        match self.unsafe_context.root {\n             SafeContext => {\n                 // Report an error.\n                 span_err!(self.tcx.sess, span, E0133,\n@@ -59,26 +72,6 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             UnsafeFn => {}\n         }\n     }\n-\n-    fn check_str_index(&mut self, e: &ast::Expr) {\n-        let base_type = match e.node {\n-            ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n-            _ => return\n-        };\n-        debug!(\"effect: checking index with base type {:?}\",\n-                 base_type);\n-        match base_type.sty {\n-            ty::TyBox(ty) | ty::TyRef(_, ty::mt{ty, ..}) => if ty::TyStr == ty.sty {\n-                span_err!(self.tcx.sess, e.span, E0134,\n-                          \"modification of string types is not allowed\");\n-            },\n-            ty::TyStr => {\n-                span_err!(self.tcx.sess, e.span, E0135,\n-                          \"modification of string types is not allowed\");\n-            }\n-            _ => {}\n-        }\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n@@ -95,9 +88,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n         let old_unsafe_context = self.unsafe_context;\n         if is_unsafe_fn {\n-            self.unsafe_context = UnsafeFn\n+            self.unsafe_context = UnsafeContext::new(UnsafeFn)\n         } else if is_item_fn {\n-            self.unsafe_context = SafeContext\n+            self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n@@ -125,10 +118,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 // external blocks (e.g. `unsafe { println(\"\") }`,\n                 // expands to `unsafe { ... unsafe { ... } }` where\n                 // the inner one is compiler generated).\n-                if self.unsafe_context == SafeContext || source == ast::CompilerGenerated {\n-                    self.unsafe_context = UnsafeBlock(block.id)\n+                if self.unsafe_context.root == SafeContext || source == ast::CompilerGenerated {\n+                    self.unsafe_context.root = UnsafeBlock(block.id)\n                 }\n             }\n+            ast::PushUnsafeBlock(..) => {\n+                self.unsafe_context.push_unsafe_count =\n+                    self.unsafe_context.push_unsafe_count.checked_add(1).unwrap();\n+            }\n+            ast::PopUnsafeBlock(..) => {\n+                self.unsafe_context.push_unsafe_count =\n+                    self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n+            }\n         }\n \n         visit::walk_block(self, block);\n@@ -140,7 +141,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n+                let base_type = self.tcx.tables.borrow().method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -149,32 +150,26 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprCall(ref base, _) => {\n-                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(ast::UnDeref, ref base) => {\n-                let base_type = ty::node_id_to_type(self.tcx, base.id);\n+                let base_type = self.tcx.node_id_to_type(base.id);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n                     self.require_unsafe(expr.span, \"dereference of raw pointer\")\n                 }\n             }\n-            ast::ExprAssign(ref base, _) | ast::ExprAssignOp(_, ref base, _) => {\n-                self.check_str_index(&**base);\n-            }\n-            ast::ExprAddrOf(ast::MutMutable, ref base) => {\n-                self.check_str_index(&**base);\n-            }\n             ast::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             ast::ExprPath(..) => {\n-                if let def::DefStatic(_, true) = ty::resolve_expr(self.tcx, expr) {\n+                if let def::DefStatic(_, true) = self.tcx.resolve_expr(expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }\n@@ -188,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n-        unsafe_context: SafeContext,\n+        unsafe_context: UnsafeContext::new(SafeContext),\n     };\n \n     visit::walk_crate(&mut visitor, tcx.map.krate());"}, {"sha": "469aacaf50677df1ab735b856633dbd5ff10c88e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 48, "deletions": 94, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -21,12 +21,9 @@ use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n use middle::{def, region, pat_util};\n+use middle::infer;\n use middle::mem_categorization as mc;\n-use middle::mem_categorization::Typer;\n-use middle::ty::{self};\n-use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n-use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::ty::{MethodStatic, MethodStaticClosure};\n+use middle::ty;\n \n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -229,56 +226,8 @@ impl OverloadedCallType {\n \n     fn from_method_id(tcx: &ty::ctxt, method_id: ast::DefId)\n                       -> OverloadedCallType {\n-        let method_descriptor = match ty::impl_or_trait_item(tcx, method_id) {\n-            ty::MethodTraitItem(ref method_descriptor) => {\n-                (*method_descriptor).clone()\n-            }\n-            _ => {\n-                tcx.sess.bug(\"overloaded call method wasn't in method map\")\n-            }\n-        };\n-        let impl_id = match method_descriptor.container {\n-            ty::TraitContainer(_) => {\n-                tcx.sess.bug(\"statically resolved overloaded call method \\\n-                              belonged to a trait?!\")\n-            }\n-            ty::ImplContainer(impl_id) => impl_id,\n-        };\n-        let trait_ref = match ty::impl_trait_ref(tcx, impl_id) {\n-            None => {\n-                tcx.sess.bug(\"statically resolved overloaded call impl \\\n-                              didn't implement a trait?!\")\n-            }\n-            Some(ref trait_ref) => (*trait_ref).clone(),\n-        };\n-        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n-    }\n-\n-    fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n-                    -> OverloadedCallType {\n-        let trait_did =\n-            tcx.closure_kinds\n-               .borrow()\n-               .get(&closure_did)\n-               .expect(\"OverloadedCallType::from_closure: didn't find closure id\")\n-               .trait_did(tcx);\n-        OverloadedCallType::from_trait_id(tcx, trait_did)\n-    }\n-\n-    fn from_method_origin(tcx: &ty::ctxt, origin: &MethodOrigin)\n-                          -> OverloadedCallType {\n-        match *origin {\n-            MethodStatic(def_id) => {\n-                OverloadedCallType::from_method_id(tcx, def_id)\n-            }\n-            MethodStaticClosure(def_id) => {\n-                OverloadedCallType::from_closure(tcx, def_id)\n-            }\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n-            }\n-        }\n+        let method = tcx.impl_or_trait_item(method_id);\n+        OverloadedCallType::from_trait_id(tcx, method.container().id())\n     }\n }\n \n@@ -290,9 +239,9 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n-pub struct ExprUseVisitor<'d,'t,'tcx:'t,TYPER:'t> {\n-    typer: &'t TYPER,\n-    mc: mc::MemCategorizationContext<'t,TYPER>,\n+pub struct ExprUseVisitor<'d,'t,'a: 't, 'tcx:'a> {\n+    typer: &'t infer::InferCtxt<'a, 'tcx>,\n+    mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n }\n \n@@ -307,7 +256,10 @@ macro_rules! return_if_err {\n     ($inp: expr) => (\n         match $inp {\n             Ok(v) => v,\n-            Err(()) => return\n+            Err(()) => {\n+                debug!(\"mc reported err\");\n+                return\n+            }\n         }\n     )\n }\n@@ -318,10 +270,10 @@ enum PassArgs {\n     ByRef,\n }\n \n-impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n+impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n-               typer: &'t TYPER)\n-               -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n+               typer: &'t infer::InferCtxt<'a, 'tcx>)\n+               -> ExprUseVisitor<'d,'t,'a, 'tcx> {\n         ExprUseVisitor {\n             typer: typer,\n             mc: mc::MemCategorizationContext::new(typer),\n@@ -354,7 +306,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n-        self.typer.tcx()\n+        self.typer.tcx\n     }\n \n     fn delegate_consume(&mut self,\n@@ -502,9 +454,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n-                let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n-                let bk = ty::BorrowKind::from_mutbl(m);\n-                self.borrow_expr(&**base, r, bk, AddrOf);\n+                if let ty::TyRef(&r, _) = expr_ty.sty {\n+                    let bk = ty::BorrowKind::from_mutbl(m);\n+                    self.borrow_expr(&**base, r, bk, AddrOf);\n+                }\n             }\n \n             ast::ExprInlineAsm(ref ia) => {\n@@ -605,6 +558,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     None => {}\n                 }\n                 self.consume_expr(&**base);\n+                if place.is_some() {\n+                    self.tcx().sess.span_bug(\n+                        expr.span,\n+                        \"box with explicit place remains after expansion\");\n+                }\n             }\n \n             ast::ExprMac(..) => {\n@@ -627,11 +585,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ty::TyError => { }\n             _ => {\n                 let overloaded_call_type =\n-                    match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n-                        Some(method_origin) => {\n-                            OverloadedCallType::from_method_origin(\n-                                self.tcx(),\n-                                &method_origin)\n+                    match self.typer.node_method_id(ty::MethodCall::expr(call.id)) {\n+                        Some(method_id) => {\n+                            OverloadedCallType::from_method_id(self.tcx(), method_id)\n                         }\n                         None => {\n                             self.tcx().sess.span_bug(\n@@ -688,7 +644,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx().def_map, &*local.pat,\n+                pat_util::pat_bindings(&self.typer.tcx.def_map, &*local.pat,\n                                        |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n@@ -740,7 +696,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // expression that will actually be used\n         let with_fields = match with_cmt.ty.sty {\n             ty::TyStruct(did, substs) => {\n-                ty::struct_fields(self.tcx(), did, substs)\n+                self.tcx().struct_fields(did, substs)\n             }\n             _ => {\n                 // the base expression should always evaluate to a\n@@ -772,7 +728,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: &ty::field,\n+        fn contains_field_named(field: &ty::Field,\n                                 fields: &Vec<ast::Field>)\n                                 -> bool\n         {\n@@ -786,8 +742,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &ast::Expr) {\n         let typer = self.typer;\n-        if let Some(adjustment) = typer.adjustments().borrow().get(&expr.id) {\n-            match *adjustment {\n+        //NOTE(@jroesch): mixed RefCell borrow causes crash\n+        let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n+        if let Some(adjustment) = adj {\n+            match adjustment {\n                 ty::AdjustReifyFnPointer |\n                 ty::AdjustUnsafeFnPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n@@ -821,8 +779,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                     // the method call infrastructure should have\n                     // replaced all late-bound regions with variables:\n-                    let self_ty = ty::ty_fn_sig(method_ty).input(0);\n-                    let self_ty = ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap();\n+                    let self_ty = method_ty.fn_sig().input(0);\n+                    let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n \n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -922,10 +880,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // This is always an rvalue, since we are producing a new\n         // (temporary) indirection.\n \n-        let adj_ty =\n-            ty::adjust_ty_for_autoref(self.tcx(),\n-                                      cmt_base_ty,\n-                                      opt_autoref);\n+        let adj_ty = cmt_base_ty.adjust_for_autoref(self.tcx(), opt_autoref);\n \n         self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n     }\n@@ -1051,7 +1006,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n-                let tcx = typer.tcx();\n+                let tcx = typer.tcx;\n \n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n                        cmt_pat,\n@@ -1074,12 +1029,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n                     ast::PatIdent(ast::BindByRef(m), _, _) => {\n-                        let (r, bk) = {\n-                            (ty::ty_region(tcx, pat.span, pat_ty),\n-                             ty::BorrowKind::from_mutbl(m))\n-                        };\n-                        delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                             r, bk, RefBinding);\n+                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(pat.id, pat.span, cmt_pat,\n+                                            r, bk, RefBinding);\n+                        }\n                     }\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n@@ -1139,7 +1093,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n-            let tcx = typer.tcx();\n+            let tcx = typer.tcx;\n \n             match pat.node {\n                 ast::PatEnum(_, _) | ast::PatQPath(..) |\n@@ -1152,7 +1106,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                         Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n-                                if ty::enum_is_univariant(tcx, enum_did) {\n+                                if tcx.enum_is_univariant(enum_did) {\n                                     cmt_pat\n                                 } else {\n                                     let cmt_pat_ty = cmt_pat.ty;\n@@ -1238,7 +1192,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n+        self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n                 let id_var = freevar.def.def_id().node;\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n@@ -1278,12 +1232,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n }\n \n-fn copy_or_move<'tcx>(typer: &mc::Typer<'tcx>,\n+fn copy_or_move<'a, 'tcx>(typer: &infer::InferCtxt<'a, 'tcx>,\n                       cmt: &mc::cmt<'tcx>,\n                       move_reason: MoveReason)\n                       -> ConsumeMode\n {\n-    if typer.type_moves_by_default(cmt.span, cmt.ty) {\n+    if typer.type_moves_by_default(cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "de7582a13716620ec4e9bd6baf141d1a473d1fdf", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -71,8 +71,10 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         }\n         ty::TyBox(_) => {\n             // treat like we would treat `Box`\n-            let def_id = tcx.lang_items.owned_box().unwrap();\n-            Some(StructSimplifiedType(def_id))\n+            match tcx.lang_items.require_owned_box() {\n+                Ok(def_id) => Some(StructSimplifiedType(def_id)),\n+                Err(msg) => tcx.sess.fatal(&msg),\n+            }\n         }\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))"}, {"sha": "102cd001a296a563d070117c4a8c08749c24db47", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -13,18 +13,21 @@\n use middle::implicator::Implication;\n use middle::ty::{self, FreeRegion};\n use util::common::can_reach;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n-    /// `free_region_map` maps from a free region `a` to a list of\n+    /// `map` maps from a free region `a` to a list of\n     /// free regions `bs` such that `a <= b for all b in bs`\n     map: FnvHashMap<FreeRegion, Vec<FreeRegion>>,\n+    /// regions that are required to outlive (and therefore be\n+    /// equal to) 'static.\n+    statics: FnvHashSet<FreeRegion>\n }\n \n impl FreeRegionMap {\n     pub fn new() -> FreeRegionMap {\n-        FreeRegionMap { map: FnvHashMap() }\n+        FreeRegionMap { map: FnvHashMap(), statics: FnvHashSet() }\n     }\n \n     pub fn relate_free_regions_from_implications<'tcx>(&mut self,\n@@ -37,7 +40,6 @@ impl FreeRegionMap {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n                 Implication::RegionSubRegion(..) |\n-                Implication::RegionSubClosure(..) |\n                 Implication::RegionSubGeneric(..) |\n                 Implication::Predicate(..) => {\n                 }\n@@ -59,6 +61,8 @@ impl FreeRegionMap {\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n                     match (r_a, r_b) {\n+                        (ty::ReStatic, ty::ReFree(_)) => {},\n+                        (ty::ReFree(fr_a), ty::ReStatic) => self.relate_to_static(fr_a),\n                         (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n                             // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n                             self.relate_free_regions(fr_b, fr_a);\n@@ -76,8 +80,12 @@ impl FreeRegionMap {\n         }\n     }\n \n-    pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-        let mut sups = self.map.entry(sub).or_insert(Vec::new());\n+    fn relate_to_static(&mut self, sup: FreeRegion) {\n+        self.statics.insert(sup);\n+    }\n+\n+    fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n+       let mut sups = self.map.entry(sub).or_insert(Vec::new());\n         if !sups.contains(&sup) {\n             sups.push(sup);\n         }\n@@ -88,7 +96,7 @@ impl FreeRegionMap {\n     /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n     /// (that is, the user can give two different names to the same lifetime).\n     pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        can_reach(&self.map, sub, sup)\n+        can_reach(&self.map, sub, sup) || self.is_static(&sup)\n     }\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n@@ -116,10 +124,17 @@ impl FreeRegionMap {\n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n \n+                (ty::ReStatic, ty::ReFree(ref sup_fr)) => self.is_static(sup_fr),\n+\n                 _ =>\n                     false,\n             }\n         }\n     }\n-}\n \n+    /// Determines whether this free-region is required to be 'static\n+    pub fn is_static(&self, super_region: &ty::FreeRegion) -> bool {\n+        debug!(\"is_static(super_region={:?})\", super_region);\n+        self.statics.iter().any(|s| can_reach(&self.map, *s, *super_region))\n+    }\n+}"}, {"sha": "799d9a653ae38be181ba141ecfa92ebefc2a4a73", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 71, "deletions": 23, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -13,7 +13,7 @@\n use middle::infer::{InferCtxt, GenericKind};\n use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, AsPredicate, Ty};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, ToPredicate, Ty};\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n use syntax::ast;\n@@ -28,13 +28,11 @@ use util::nodemap::FnvHashSet;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx Substs<'tcx>),\n     Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n struct Implicator<'a, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a,'tcx>,\n-    closure_typer: &'a (ty::ClosureTyper<'tcx>+'a),\n     body_id: ast::NodeId,\n     stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n     span: Span,\n@@ -46,7 +44,6 @@ struct Implicator<'a, 'tcx: 'a> {\n /// appear in a context with lifetime `outer_region`\n pub fn implications<'a,'tcx>(\n     infcx: &'a InferCtxt<'a,'tcx>,\n-    closure_typer: &ty::ClosureTyper<'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     outer_region: ty::Region,\n@@ -60,8 +57,7 @@ pub fn implications<'a,'tcx>(\n \n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n-    let mut wf = Implicator { closure_typer: closure_typer,\n-                              infcx: infcx,\n+    let mut wf = Implicator { infcx: infcx,\n                               body_id: body_id,\n                               span: span,\n                               stack: stack,\n@@ -99,9 +95,47 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n-                let &(r_a, opt_ty) = self.stack.last().unwrap();\n-                self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));\n+            ty::TyClosure(_, ref substs) => {\n+                // FIXME(#27086). We do not accumulate from substs, since they\n+                // don't represent reachable data. This means that, in\n+                // practice, some of the lifetime parameters might not\n+                // be in scope when the body runs, so long as there is\n+                // no reachable data with that lifetime. For better or\n+                // worse, this is consistent with fn types, however,\n+                // which can also encapsulate data in this fashion\n+                // (though it's somewhat harder, and typically\n+                // requires virtual dispatch).\n+                //\n+                // Note that changing this (in a naive way, at least)\n+                // causes regressions for what appears to be perfectly\n+                // reasonable code like this:\n+                //\n+                // ```\n+                // fn foo<'a>(p: &Data<'a>) {\n+                //    bar(|q: &mut Parser| q.read_addr())\n+                // }\n+                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+                // }\n+                // ```\n+                //\n+                // Note that `p` (and `'a`) are not used in the\n+                // closure at all, but to meet the requirement that\n+                // the closure type `C: 'static` (so it can be coerced\n+                // to the object type), we get the requirement that\n+                // `'a: 'static` since `'a` appears in the closure\n+                // type `C`.\n+                //\n+                // A smarter fix might \"prune\" unused `func_substs` --\n+                // this would avoid breaking simple examples like\n+                // this, but would still break others (which might\n+                // indeed be invalid, depending on your POV). Pruning\n+                // would be a subtle process, since we have to see\n+                // what func/type parameters are used and unused,\n+                // taking into consideration UFCS and so forth.\n+\n+                for &upvar_ty in &substs.upvar_tys {\n+                    self.accumulate_from_ty(upvar_ty);\n+                }\n             }\n \n             ty::TyTrait(ref t) => {\n@@ -112,13 +146,13 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n             ty::TyEnum(def_id, substs) |\n             ty::TyStruct(def_id, substs) => {\n-                let item_scheme = ty::lookup_item_type(self.tcx(), def_id);\n+                let item_scheme = self.tcx().lookup_item_type(def_id);\n                 self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n             ty::TyArray(t, _) |\n             ty::TySlice(t) |\n-            ty::TyRawPtr(ty::mt { ty: t, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) |\n             ty::TyBox(t) => {\n                 self.accumulate_from_ty(t)\n             }\n@@ -236,7 +270,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                            substs: &Substs<'tcx>)\n     {\n         let predicates =\n-            ty::lookup_predicates(self.tcx(), def_id).instantiate(self.tcx(), substs);\n+            self.tcx().lookup_predicates(def_id).instantiate(self.tcx(), substs);\n         let predicates = match self.fully_normalize(&predicates) {\n             Ok(predicates) => predicates,\n             Err(ErrorReported) => { return; }\n@@ -250,15 +284,15 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 ty::Predicate::Equate(..) => { }\n                 ty::Predicate::Projection(..) => { }\n                 ty::Predicate::RegionOutlives(ref data) => {\n-                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                    match self.tcx().no_late_bound_regions(data) {\n                         None => { }\n                         Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                             self.push_sub_region_constraint(Some(ty), r_b, r_a);\n                         }\n                     }\n                 }\n                 ty::Predicate::TypeOutlives(ref data) => {\n-                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                    match self.tcx().no_late_bound_regions(data) {\n                         None => { }\n                         Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                             self.stack.push((r_b, Some(ty)));\n@@ -275,7 +309,22 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                                     .map(|pred| Implication::Predicate(def_id, pred));\n         self.out.extend(obligations);\n \n-        let variances = ty::item_variances(self.tcx(), def_id);\n+        let variances = self.tcx().item_variances(def_id);\n+        self.accumulate_from_substs(substs, Some(&variances));\n+    }\n+\n+    fn accumulate_from_substs(&mut self,\n+                              substs: &Substs<'tcx>,\n+                              variances: Option<&ty::ItemVariances>)\n+    {\n+        let mut tmp_variances = None;\n+        let variances = variances.unwrap_or_else(|| {\n+            tmp_variances = Some(ty::ItemVariances {\n+                types: substs.types.map(|_| ty::Variance::Invariant),\n+                regions: substs.regions().map(|_| ty::Variance::Invariant),\n+            });\n+            tmp_variances.as_ref().unwrap()\n+        });\n \n         for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n             match variance {\n@@ -316,7 +365,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                data);\n \n         for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n-            match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+            match self.tcx().no_late_bound_regions(&poly_trait_ref) {\n                 Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n                 None => { }\n             }\n@@ -330,11 +379,11 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                trait_ref);\n \n         let trait_def_id = trait_ref.def_id;\n-        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n         let assoc_type_projections: Vec<_> =\n             trait_def.associated_type_names\n                      .iter()\n-                     .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n+                     .map(|&name| self.tcx().mk_projection(trait_ref.clone(), name))\n                      .collect();\n         debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n                assoc_type_projections);\n@@ -400,11 +449,10 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n-        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes\n+        where T : TypeFoldable<'tcx> + ty::HasTypeFlags\n     {\n         let value =\n             traits::fully_normalize(self.infcx,\n-                                    self.closure_typer,\n                                     traits::ObligationCause::misc(self.span, self.body_id),\n                                     value);\n         match value {\n@@ -437,15 +485,15 @@ pub fn object_region_bounds<'tcx>(\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n     // Note that we preserve the overall binding levels here.\n     assert!(!open_ty.has_escaping_regions());\n     let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n     let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n \n     let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.extend(trait_refs.iter().map(|t| t.as_predicate()));\n+    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n \n-    ty::required_region_bounds(tcx, open_ty, predicates)\n+    tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "d2268894b20a1d5cb2c06e5b4d2f9e2417317620", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n-        let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n+        let a1 = self.tcx().erase_late_bound_regions(a);\n+        let b1 = self.tcx().erase_late_bound_regions(b);\n         let c = try!(self.relate(&a1, &b1));\n         Ok(ty::Binder(c))\n     }"}, {"sha": "94c76e2399947114245bc87e9ceeff25faa7d797", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -43,7 +43,7 @@ use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use middle::ty::{TyVar};\n use middle::ty::{IntType, UintType};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, TypeError};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n@@ -56,6 +56,7 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n+    pub cause: Option<ty_relate::Cause>,\n }\n \n pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -107,7 +108,7 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n         // All other cases of inference are errors\n         (&ty::TyInfer(_), _) |\n         (_, &ty::TyInfer(_)) => {\n-            Err(ty::terr_sorts(ty_relate::expected_found(relation, &a, &b)))\n+            Err(TypeError::Sorts(ty_relate::expected_found(relation, &a, &b)))\n         }\n \n \n@@ -129,8 +130,8 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n          .unify_var_value(vid, val)\n          .map_err(|e| int_unification_error(vid_is_expected, e)));\n     match val {\n-        IntType(v) => Ok(ty::mk_mach_int(infcx.tcx, v)),\n-        UintType(v) => Ok(ty::mk_mach_uint(infcx.tcx, v)),\n+        IntType(v) => Ok(infcx.tcx.mk_mach_int(v)),\n+        UintType(v) => Ok(infcx.tcx.mk_mach_uint(v)),\n     }\n }\n \n@@ -145,7 +146,7 @@ fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n          .borrow_mut()\n          .unify_var_value(vid, val)\n          .map_err(|e| float_unification_error(vid_is_expected, e)));\n-    Ok(ty::mk_mach_float(infcx.tcx, val))\n+    Ok(infcx.tcx.mk_mach_float(val))\n }\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n@@ -277,7 +278,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         };\n         let u = ty.fold_with(&mut generalize);\n         if generalize.cycle_detected {\n-            Err(ty::terr_cyclic_ty)\n+            Err(TypeError::CyclicTy)\n         } else {\n             Ok(u)\n         }\n@@ -362,12 +363,12 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n pub trait RelateResultCompare<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>;\n+        F: FnOnce() -> ty::TypeError<'tcx>;\n }\n \n impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>,\n+        F: FnOnce() -> ty::TypeError<'tcx>,\n     {\n         self.clone().and_then(|s| {\n             if s == t {\n@@ -380,16 +381,16 @@ impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'t\n }\n \n fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n-                               -> ty::type_err<'tcx>\n+                               -> ty::TypeError<'tcx>\n {\n     let (a, b) = v;\n-    ty::terr_int_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::IntMismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n                                  v: (ast::FloatTy, ast::FloatTy))\n-                                 -> ty::type_err<'tcx>\n+                                 -> ty::TypeError<'tcx>\n {\n     let (a, b) = v;\n-    ty::terr_float_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+    TypeError::FloatMismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "fbf19a10d93bf025deab497f004d342a9279c779", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 170, "deletions": 218, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -77,7 +77,7 @@ use middle::def;\n use middle::infer;\n use middle::region;\n use middle::subst;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, TypeError, HasTypeFlags};\n use middle::ty::{Region, ReFree};\n \n use std::cell::{Cell, RefCell};\n@@ -91,123 +91,125 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-pub fn note_and_explain_region(tcx: &ty::ctxt,\n-                               prefix: &str,\n-                               region: ty::Region,\n-                               suffix: &str) {\n-    fn item_scope_tag(item: &ast::Item) -> &'static str {\n-        match item.node {\n-            ast::ItemImpl(..) => \"impl\",\n-            ast::ItemStruct(..) => \"struct\",\n-            ast::ItemEnum(..) => \"enum\",\n-            ast::ItemTrait(..) => \"trait\",\n-            ast::ItemFn(..) => \"function body\",\n-            _ => \"item\"\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn note_and_explain_region(&self,\n+                                   prefix: &str,\n+                                   region: ty::Region,\n+                                   suffix: &str) {\n+        fn item_scope_tag(item: &ast::Item) -> &'static str {\n+            match item.node {\n+                ast::ItemImpl(..) => \"impl\",\n+                ast::ItemStruct(..) => \"struct\",\n+                ast::ItemEnum(..) => \"enum\",\n+                ast::ItemTrait(..) => \"trait\",\n+                ast::ItemFn(..) => \"function body\",\n+                _ => \"item\"\n+            }\n         }\n-    }\n-\n-    fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n-                    -> (String, Option<Span>) {\n-        let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n-         Some(span))\n-    }\n \n-    let (description, span) = match region {\n-        ty::ReScope(scope) => {\n-            let new_string;\n-            let unknown_scope = || {\n-                format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n-                        prefix, scope, suffix)\n-            };\n-            let span = match scope.span(&tcx.map) {\n-                Some(s) => s,\n-                None => return tcx.sess.note(&unknown_scope())\n-            };\n-            let tag = match tcx.map.find(scope.node_id()) {\n-                Some(ast_map::NodeBlock(_)) => \"block\",\n-                Some(ast_map::NodeExpr(expr)) => match expr.node {\n-                    ast::ExprCall(..) => \"call\",\n-                    ast::ExprMethodCall(..) => \"method call\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                    ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n-                    ast::ExprMatch(..) => \"match\",\n-                    _ => \"expression\",\n-                },\n-                Some(ast_map::NodeStmt(_)) => \"statement\",\n-                Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n-                Some(_) | None => {\n-                    return tcx.sess.span_note(span, &unknown_scope());\n-                }\n-            };\n-            let scope_decorated_tag = match scope {\n-                region::CodeExtent::Misc(_) => tag,\n-                region::CodeExtent::ParameterScope { .. } => {\n-                    \"scope of parameters for function\"\n-                }\n-                region::CodeExtent::DestructionScope(_) => {\n-                    new_string = format!(\"destruction scope surrounding {}\", tag);\n-                    &new_string[..]\n-                }\n-                region::CodeExtent::Remainder(r) => {\n-                    new_string = format!(\"block suffix following statement {}\",\n-                                         r.first_statement_index);\n-                    &new_string[..]\n-                }\n-            };\n-            explain_span(tcx, scope_decorated_tag, span)\n+        fn explain_span(tcx: &ty::ctxt, heading: &str, span: Span)\n+                        -> (String, Option<Span>) {\n+            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n+            (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n+             Some(span))\n         }\n \n-        ty::ReFree(ref fr) => {\n-            let prefix = match fr.bound_region {\n-                ty::BrAnon(idx) => {\n-                    format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n-                }\n-                ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n-                _ => {\n-                    format!(\"the lifetime {} as defined on\",\n-                            fr.bound_region)\n-                }\n-            };\n+        let (description, span) = match region {\n+            ty::ReScope(scope) => {\n+                let new_string;\n+                let unknown_scope = || {\n+                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                            prefix, scope, suffix)\n+                };\n+                let span = match scope.span(&self.map) {\n+                    Some(s) => s,\n+                    None => return self.sess.note(&unknown_scope())\n+                };\n+                let tag = match self.map.find(scope.node_id()) {\n+                    Some(ast_map::NodeBlock(_)) => \"block\",\n+                    Some(ast_map::NodeExpr(expr)) => match expr.node {\n+                        ast::ExprCall(..) => \"call\",\n+                        ast::ExprMethodCall(..) => \"method call\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+                        ast::ExprMatch(_, _, ast::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        ast::ExprMatch(..) => \"match\",\n+                        _ => \"expression\",\n+                    },\n+                    Some(ast_map::NodeStmt(_)) => \"statement\",\n+                    Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                    Some(_) | None => {\n+                        return self.sess.span_note(span, &unknown_scope());\n+                    }\n+                };\n+                let scope_decorated_tag = match scope {\n+                    region::CodeExtent::Misc(_) => tag,\n+                    region::CodeExtent::ParameterScope { .. } => {\n+                        \"scope of parameters for function\"\n+                    }\n+                    region::CodeExtent::DestructionScope(_) => {\n+                        new_string = format!(\"destruction scope surrounding {}\", tag);\n+                        &new_string[..]\n+                    }\n+                    region::CodeExtent::Remainder(r) => {\n+                        new_string = format!(\"block suffix following statement {}\",\n+                                             r.first_statement_index);\n+                        &new_string[..]\n+                    }\n+                };\n+                explain_span(self, scope_decorated_tag, span)\n+            }\n \n-            match tcx.map.find(fr.scope.node_id) {\n-                Some(ast_map::NodeBlock(ref blk)) => {\n-                    let (msg, opt_span) = explain_span(tcx, \"block\", blk.span);\n-                    (format!(\"{} {}\", prefix, msg), opt_span)\n-                }\n-                Some(ast_map::NodeItem(it)) => {\n-                    let tag = item_scope_tag(&*it);\n-                    let (msg, opt_span) = explain_span(tcx, tag, it.span);\n-                    (format!(\"{} {}\", prefix, msg), opt_span)\n-                }\n-                Some(_) | None => {\n-                    // this really should not happen\n-                    (format!(\"{} unknown free region bounded by scope {:?}\",\n-                             prefix, fr.scope), None)\n+            ty::ReFree(ref fr) => {\n+                let prefix = match fr.bound_region {\n+                    ty::BrAnon(idx) => {\n+                        format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                    }\n+                    ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                    _ => {\n+                        format!(\"the lifetime {} as defined on\",\n+                                fr.bound_region)\n+                    }\n+                };\n+\n+                match self.map.find(fr.scope.node_id) {\n+                    Some(ast_map::NodeBlock(ref blk)) => {\n+                        let (msg, opt_span) = explain_span(self, \"block\", blk.span);\n+                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                    }\n+                    Some(ast_map::NodeItem(it)) => {\n+                        let tag = item_scope_tag(&*it);\n+                        let (msg, opt_span) = explain_span(self, tag, it.span);\n+                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                    }\n+                    Some(_) | None => {\n+                        // this really should not happen\n+                        (format!(\"{} unknown free region bounded by scope {:?}\",\n+                                 prefix, fr.scope), None)\n+                    }\n                 }\n             }\n-        }\n \n-        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+            ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-        ty::ReEarlyBound(ref data) => {\n-            (format!(\"{}\", token::get_name(data.name)), None)\n-        }\n+            ty::ReEarlyBound(ref data) => {\n+                (format!(\"{}\", token::get_name(data.name)), None)\n+            }\n \n-        // I believe these cases should not occur (except when debugging,\n-        // perhaps)\n-        ty::ReInfer(_) | ty::ReLateBound(..) => {\n-            (format!(\"lifetime {:?}\", region), None)\n+            // I believe these cases should not occur (except when debugging,\n+            // perhaps)\n+            ty::ReInfer(_) | ty::ReLateBound(..) => {\n+                (format!(\"lifetime {:?}\", region), None)\n+            }\n+        };\n+        let message = format!(\"{}{}{}\", prefix, description, suffix);\n+        if let Some(span) = span {\n+            self.sess.span_note(span, &message);\n+        } else {\n+            self.sess.note(&message);\n         }\n-    };\n-    let message = format!(\"{}{}{}\", prefix, description, suffix);\n-    if let Some(span) = span {\n-        tcx.sess.span_note(span, &message);\n-    } else {\n-        tcx.sess.note(&message);\n     }\n }\n \n@@ -218,17 +220,17 @@ pub trait ErrorReporting<'tcx> {\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n                       -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>);\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>);\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::type_err<'tcx>);\n+                                     terr: &ty::TypeError<'tcx>);\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::expected_found<T>)\n+        exp_found: &ty::ExpectedFound<T>)\n         -> Option<String>;\n \n     fn report_concrete_failure(&self,\n@@ -258,7 +260,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n+                               trace_origin: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, same_regions: &[SameRegions]);\n@@ -349,8 +351,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     match free_regions_from_same_fn(self.tcx, sub, sup) {\n                         Some(ref same_frs) if trace.is_some() => {\n                             let trace = trace.unwrap();\n-                            let terr = ty::terr_regions_does_not_outlive(sup,\n-                                                                         sub);\n+                            let terr = TypeError::RegionsDoesNotOutlive(sup,\n+                                                                        sub);\n                             trace_origins.push((trace, terr));\n                             append_to_same_regions(&mut same_regions, same_frs);\n                         }\n@@ -465,7 +467,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>) {\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -488,10 +490,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::type_err<'tcx>) {\n+                                     terr: &ty::TypeError<'tcx>) {\n         let span = trace.origin.span();\n         self.report_type_error(trace, terr);\n-        ty::note_and_explain_type_err(self.tcx, terr, span);\n+        self.tcx.note_and_explain_type_err(terr, span);\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n@@ -504,18 +506,18 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::expected_found<T>)\n+        exp_found: &ty::ExpectedFound<T>)\n         -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n-        if expected.contains_error() {\n+        if expected.references_error() {\n             return None;\n         }\n \n         let found = exp_found.found.resolve(self);\n-        if found.contains_error() {\n+        if found.references_error() {\n             return None;\n         }\n \n@@ -576,8 +578,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n                         bound_kind));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\");\n@@ -593,20 +594,18 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sup: Region) {\n         match origin {\n             infer::Subtype(trace) => {\n-                let terr = ty::terr_regions_does_not_outlive(sup, sub);\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n                 span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n                     \"\");\n@@ -615,42 +614,33 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 span_err!(self.tcx.sess, span, E0313,\n                     \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   upvar_id.var_id)\n-                                .to_string());\n-                note_and_explain_region(\n-                    self.tcx,\n+                            self.tcx.local_var_name_str(upvar_id.var_id));\n+                self.tcx.note_and_explain_region(\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     &format!(\"...but `{}` is only valid for \",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   upvar_id.var_id)\n-                                .to_string()),\n+                             self.tcx.local_var_name_str(upvar_id.var_id)),\n                     sup,\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n                 span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...the closure must be valid for \",\n                     sub,\n                     \"...\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"...but the closure's stack frame is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n                 span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the closure is only valid for \",\n                     sup,\n                     \"\");\n@@ -659,8 +649,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"dereference of reference outside its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n@@ -669,25 +658,21 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     &format!(\"captured variable `{}` does not \\\n-                            outlive the enclosing closure\",\n-                            ty::local_var_name_str(self.tcx,\n-                                                   id).to_string()));\n-                note_and_explain_region(\n-                    self.tcx,\n+                              outlive the enclosing closure\",\n+                             self.tcx.local_var_name_str(id)));\n+                self.tcx.note_and_explain_region(\n                     \"captured variable is valid for \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"closure is valid for \",\n                     sub,\n                     \"\");\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_err(span,\n                                        \"index of slice outside its lifetime\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n@@ -697,13 +682,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of the source pointer does not outlive \\\n                      lifetime bound of the object type\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"object type is valid for \",\n                     sub,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"source pointer is only valid for \",\n                     sup,\n                     \"\");\n@@ -714,7 +697,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(self.tcx,\n+                self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n@@ -723,13 +706,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"lifetime bound not satisfied\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\");\n@@ -740,7 +721,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(self.tcx,\n+                self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n@@ -750,8 +731,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of method receiver does not outlive \\\n                      the method call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n@@ -761,8 +741,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of function argument does not outlive \\\n                      the function call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n@@ -772,8 +751,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of return value does not outlive \\\n                      the function call\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n@@ -783,8 +761,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"lifetime of operand does not outlive \\\n                      the operation\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n@@ -794,8 +771,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"reference is not valid \\\n                      at the time of borrow\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n@@ -805,8 +781,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     \"automatically reference is not valid \\\n                      at the time of borrow\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n@@ -817,8 +792,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n                             self.ty_to_string(t)));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n@@ -829,13 +803,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"unsafe use of destructor: destructor might be called \\\n                      while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"superregion: \",\n                     sup,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"subregion: \",\n                     sub,\n                     \"\");\n@@ -844,8 +816,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     \"lifetime of variable does not enclose its declaration\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n@@ -856,13 +827,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n                             self.ty_to_string(ty)));\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"the pointer is valid for \",\n                     sub,\n                     \"\");\n-                note_and_explain_region(\n-                    self.tcx,\n+                self.tcx.note_and_explain_region(\n                     \"but the referenced data is only valid for \",\n                     sup,\n                     \"\");\n@@ -878,16 +847,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                sup_region: Region) {\n         self.report_inference_failure(var_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&sup_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n@@ -903,16 +870,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                region2: Region) {\n         self.report_inference_failure(var_origin);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"first, the lifetime must be contained by \",\n             region1,\n             \"...\");\n \n         self.note_region_origin(&origin1);\n \n-        note_and_explain_region(\n-            self.tcx,\n+        self.tcx.note_and_explain_region(\n             \"but, the lifetime must also be contained by \",\n             region2,\n             \"...\");\n@@ -922,14 +887,14 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n+                               trace_origins: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n                                same_regions: &[SameRegions]) {\n         for vo in var_origins {\n             self.report_inference_failure(vo.clone());\n         }\n         self.give_suggestion(same_regions);\n-        for &(ref trace, terr) in trace_origins {\n-            self.report_and_explain_type_error(trace.clone(), &terr);\n+        for &(ref trace, ref terr) in trace_origins {\n+            self.report_and_explain_type_error(trace.clone(), terr);\n         }\n     }\n \n@@ -1353,7 +1318,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     };\n                     match a_def {\n                         def::DefTy(did, _) | def::DefStruct(did) => {\n-                            let generics = ty::lookup_item_type(self.tcx, did).generics;\n+                            let generics = self.tcx.lookup_item_type(did).generics;\n \n                             let expected =\n                                 generics.regions.len(subst::TypeSpace) as u32;\n@@ -1529,7 +1494,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             parameters: new_parameters\n         };\n         let mut new_segs = Vec::new();\n-        new_segs.push_all(path.segments.init());\n+        new_segs.push_all(path.segments.split_last().unwrap().1);\n         new_segs.push(new_seg);\n         ast::Path {\n             span: path.span,\n@@ -1591,7 +1556,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id).to_string())\n+                        self.tcx.local_var_name_str(upvar_id.var_id).to_string())\n             }\n         };\n \n@@ -1671,7 +1636,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\n                         \"...so that closure can access `{}`\",\n-                        ty::local_var_name_str(self.tcx, upvar_id.var_id)\n+                        self.tcx.local_var_name_str(upvar_id.var_id)\n                             .to_string()))\n             }\n             infer::InfStackClosure(span) => {\n@@ -1695,9 +1660,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n-                            ty::local_var_name_str(\n-                                self.tcx,\n-                                id).to_string()));\n+                            self.tcx.local_var_name_str(id)));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1793,26 +1756,19 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n pub trait Resolvable<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n-    fn contains_error(&self) -> bool;\n }\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-    fn contains_error(&self) -> bool {\n-        ty::type_is_error(*self)\n-    }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n                    -> ty::TraitRef<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-    fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(self)\n-    }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n@@ -1822,10 +1778,6 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n-\n-    fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&self.0)\n-    }\n }\n \n fn lifetimes_in_scope(tcx: &ty::ctxt,\n@@ -1902,7 +1854,7 @@ impl LifeGiver {\n     }\n \n     fn give_lifetime(&self) -> ast::Lifetime {\n-        let mut lifetime;\n+        let lifetime;\n         loop {\n             let mut s = String::from(\"'\");\n             s.push_str(&num_to_string(self.counter.get()));"}, {"sha": "d65c4061f11eb3cb7c6b46c6c9f0c038f5307a15", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -30,7 +30,7 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;\n                 self.freshen_count += 1;\n-                let t = ty::mk_infer(self.infcx.tcx, freshener(index));\n+                let t = self.infcx.tcx.mk_infer(freshener(index));\n                 entry.insert(t);\n                 t\n             }\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) && !ty::type_has_erasable_regions(t) {\n+        if !t.needs_infer() && !t.has_erasable_regions() {\n             return t;\n         }\n "}, {"sha": "57665b6d9392348833f973f4502273dc1d448608", "filename": "src/librustc/middle/infer/higher_ranked/README.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -17,7 +17,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters. Consider, for\n example, whether the following relation holds:\n \n-    for<'a> fn(&'a int) <: for<'b> fn(&'b int)? (Yes, a => b)\n+    for<'a> fn(&'a isize) <: for<'b> fn(&'b isize)? (Yes, a => b)\n \n The answer is that of course it does. These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -27,14 +27,14 @@ In the examples that follow, it becomes very important to know whether\n a lifetime is bound in a function type (that is, is a lifetime\n parameter) or appears free (is defined in some outer scope).\n Therefore, from now on I will always write the bindings explicitly,\n-using the Rust syntax `for<'a> fn(&'a int)` to indicate that `a` is a\n+using the Rust syntax `for<'a> fn(&'a isize)` to indicate that `a` is a\n lifetime parameter.\n \n Now let's consider two more function types. Here, we assume that the\n `'b` lifetime is defined somewhere outside and hence is not a lifetime\n parameter bound by the function type (it \"appears free\"):\n \n-    for<'a> fn(&'a int) <: fn(&'b int)? (Yes, a => b)\n+    for<'a> fn(&'a isize) <: fn(&'b isize)? (Yes, a => b)\n \n This subtyping relation does in fact hold. To see why, you have to\n consider what subtyping means. One way to look at `T1 <: T2` is to\n@@ -51,7 +51,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&'b int) <: for<'a> fn(&'a int)? (No)\n+    fn(&'b isize) <: for<'a> fn(&'a isize)? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no. In this case, the function accepts *only the lifetime `'b`*,\n@@ -60,8 +60,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    for<'a,'b> fn(&'a int, &'b int) <: for<'a>    fn(&'a int, &'a int)? (Yes)\n-    for<'a>    fn(&'a int, &'a int) <: for<'a,'b> fn(&'a int, &'b int)? (No)\n+    for<'a,'b> fn(&'a isize, &'b isize) <: for<'a>    fn(&'a isize, &'a isize)? (Yes)\n+    for<'a>    fn(&'a isize, &'a isize) <: for<'a,'b> fn(&'a isize, &'b isize)? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with"}, {"sha": "1919d8ffd294df7736f01b8cfc19715cceacb7d8", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -15,7 +15,7 @@ use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::CombineFields;\n \n use middle::subst;\n-use middle::ty::{self, Binder};\n+use middle::ty::{self, TypeError, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n@@ -85,11 +85,11 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 Err((skol_br, tainted_region)) => {\n                     if self.a_is_expected {\n                         debug!(\"Not as polymorphic!\");\n-                        return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n+                        return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n                                                                                tainted_region));\n                     } else {\n                         debug!(\"Overly polymorphic!\");\n-                        return Err(ty::terr_regions_overly_polymorphic(skol_br,\n+                        return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n                                                                        tainted_region));\n                     }\n                 }\n@@ -359,7 +359,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n+    ty_fold::fold_regions(tcx, unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -369,7 +369,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n         });\n \n         fldr(region, ty::DebruijnIndex::new(current_depth))\n-    }))\n+    })\n }\n \n impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n@@ -437,11 +437,10 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n         let escaping_types =\n             self.type_variables.borrow().types_escaping_snapshot(&snapshot.type_snapshot);\n \n-        let escaping_region_vars: FnvHashSet<_> =\n-            escaping_types\n-            .iter()\n-            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t))\n-            .collect();\n+        let mut escaping_region_vars = FnvHashSet();\n+        for ty in &escaping_types {\n+            ty_fold::collect_regions(self.tcx, ty, &mut escaping_region_vars);\n+        }\n \n         region_vars.retain(|&region_vid| {\n             let r = ty::ReInfer(ty::ReVar(region_vid));\n@@ -507,7 +506,7 @@ pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                   types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n                                   defs: &[ty::TypeParameterDef<'tcx>]) {\n         for def in defs {\n-            let ty = ty::mk_param_from_def(tcx, def);\n+            let ty = tcx.mk_param_from_def(def);\n             types.push(def.space, ty);\n         }\n     }\n@@ -649,7 +648,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     // binder is that we encountered in `value`. The caller is\n     // responsible for ensuring that (a) `value` contains at least one\n     // binder and (b) that binder is the one we want to use.\n-    let result = ty_fold::fold_regions(infcx.tcx, &value, |r, current_depth| {\n+    let result = ty_fold::fold_regions(infcx.tcx, &value, &mut false, |r, current_depth| {\n         match inv_skol_map.get(&r) {\n             None => r,\n             Some(br) => {"}, {"sha": "f63154af724260d2c13d899f490ee632d679dd35", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 501, "deletions": 60, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,32 +10,35 @@\n \n //! See the Book for more information.\n \n-#![allow(non_camel_case_types)]\n-\n pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n-pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n pub use self::region_inference::GenericKind;\n \n use middle::free_region::FreeRegionMap;\n+use middle::mem_categorization as mc;\n+use middle::mem_categorization::McResult;\n+use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n+use middle::subst::Subst;\n+use middle::traits::{self, FulfillmentContext, Normalized,\n+                     SelectionContext, ObligationCause};\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, TypeError, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{RefCell};\n+use std::cell::{RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n-use syntax::codemap::Span;\n-use util::nodemap::FnvHashMap;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -59,11 +62,13 @@ pub mod unify_key;\n \n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n-pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n+pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n+    pub tables: &'a RefCell<ty::Tables<'tcx>>,\n+\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n@@ -77,6 +82,19 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n \n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'tcx>,\n+\n+    pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n+\n+    pub fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+\n+    // This is a temporary field used for toggling on normalization in the inference context,\n+    // as we move towards the approach described here:\n+    // https://internals.rust-lang.org/t/flattening-the-contexts-for-fun-and-profit/2293\n+    // At a point sometime in the future normalization will be done by the typing context\n+    // directly.\n+    normalize: bool,\n+\n+    err_count_on_creation: usize,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -150,9 +168,9 @@ impl fmt::Display for TypeOrigin {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n-    Types(ty::expected_found<Ty<'tcx>>),\n-    TraitRefs(ty::expected_found<ty::TraitRef<'tcx>>),\n-    PolyTraitRefs(ty::expected_found<ty::PolyTraitRef<'tcx>>),\n+    Types(ty::ExpectedFound<Ty<'tcx>>),\n+    TraitRefs(ty::ExpectedFound<ty::TraitRef<'tcx>>),\n+    PolyTraitRefs(ty::ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -289,37 +307,61 @@ pub enum RegionVariableOrigin {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum fixup_err {\n-    unresolved_int_ty(IntVid),\n-    unresolved_float_ty(FloatVid),\n-    unresolved_ty(TyVid)\n+pub enum FixupError {\n+    UnresolvedIntTy(IntVid),\n+    UnresolvedFloatTy(FloatVid),\n+    UnresolvedTy(TyVid)\n }\n \n-pub fn fixup_err_to_string(f: fixup_err) -> String {\n+pub fn fixup_err_to_string(f: FixupError) -> String {\n+    use self::FixupError::*;\n+\n     match f {\n-      unresolved_int_ty(_) => {\n+      UnresolvedIntTy(_) => {\n           \"cannot determine the type of this integer; add a suffix to \\\n            specify the type explicitly\".to_string()\n       }\n-      unresolved_float_ty(_) => {\n+      UnresolvedFloatTy(_) => {\n           \"cannot determine the type of this number; add a suffix to specify \\\n            the type explicitly\".to_string()\n       }\n-      unresolved_ty(_) => \"unconstrained type\".to_string(),\n+      UnresolvedTy(_) => \"unconstrained type\".to_string(),\n     }\n }\n \n-pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n+/// errors_will_be_reported is required to proxy to the fulfillment context\n+/// FIXME -- a better option would be to hold back on modifying\n+/// the global cache until we know that all dependent obligations\n+/// are also satisfied. In that case, we could actually remove\n+/// this boolean flag, and we'd also avoid the problem of squelching\n+/// duplicate errors that occur across fns.\n+pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                tables: &'a RefCell<ty::Tables<'tcx>>,\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n+                                errors_will_be_reported: bool)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n+        tables: tables,\n         type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n         int_unification_table: RefCell::new(UnificationTable::new()),\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n+        parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(errors_will_be_reported)),\n+        normalize: false,\n+        err_count_on_creation: tcx.sess.err_count()\n     }\n }\n \n+pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                        tables: &'a RefCell<ty::Tables<'tcx>>)\n+                                        -> InferCtxt<'a, 'tcx> {\n+    let mut infcx = new_infer_ctxt(tcx, tables, None, false);\n+    infcx.normalize = true;\n+    infcx\n+}\n+\n /// Computes the least upper-bound of `a` and `b`. If this is not possible, reports an error and\n /// returns ty::err.\n pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -414,12 +456,12 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n                      b: T)\n-                     -> ty::expected_found<T>\n+                     -> ty::ExpectedFound<T>\n {\n     if a_is_expected {\n-        ty::expected_found {expected: a, found: b}\n+        ty::ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::expected_found {expected: b, found: a}\n+        ty::ExpectedFound {expected: b, found: a}\n     }\n }\n \n@@ -431,6 +473,149 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n+pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n+{\n+    debug!(\"normalize_associated_type(t={:?})\", value);\n+\n+    let value = erase_regions(tcx, value);\n+\n+    if !value.has_projection_types() {\n+        return value;\n+    }\n+\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: result, obligations } =\n+        traits::normalize(&mut selcx, cause, &value);\n+\n+    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n+           result,\n+           obligations);\n+\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n+\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+\n+    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n+\n+    result\n+}\n+\n+pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n+                                                infcx: &InferCtxt<'a,'tcx>,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx>\n+{\n+    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n+        Ok(v) => v,\n+        Err(errors) => {\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n+                         errors));\n+        }\n+    }\n+}\n+\n+/// Finishes processes any obligations that remain in the fulfillment\n+/// context, and then \"freshens\" and returns `result`. This is\n+/// primarily used during normalization and other cases where\n+/// processing the obligations in `fulfill_cx` may cause type\n+/// inference variables that appear in `result` to be unified, and\n+/// hence we need to process those obligations to get the complete\n+/// picture of the type.\n+pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                       result: &T)\n+                                       -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n+    where T : TypeFoldable<'tcx>\n+{\n+    debug!(\"drain_fulfillment_cx(result={:?})\",\n+           result);\n+\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            return Err(errors);\n+        }\n+    }\n+\n+    // Use freshen to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    Ok(result.fold_with(&mut infcx.freshener()))\n+}\n+\n+/// Returns an equivalent value with all free regions removed (note\n+/// that late-bound regions remain, because they are important for\n+/// subtyping, but they are anonymized and normalized as well). This\n+/// is a stronger, caching version of `ty_fold::erase_regions`.\n+pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx>\n+{\n+    let value1 = value.fold_with(&mut RegionEraser(cx));\n+    debug!(\"erase_regions({:?}) = {:?}\",\n+           value, value1);\n+    return value1;\n+\n+    struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n+\n+    impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n+        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                None => {}\n+                Some(u) => return u\n+            }\n+\n+            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n+            return t_norm;\n+        }\n+\n+        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+            where T : TypeFoldable<'tcx>\n+        {\n+            let u = self.tcx().anonymize_late_bound_regions(t);\n+            ty_fold::super_fold_binder(self, &u)\n+        }\n+\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            // because late-bound regions affect subtyping, we can't\n+            // erase the bound/free distinction, but we can replace\n+            // all free regions with 'static.\n+            //\n+            // Note that we *CAN* replace early-bound regions -- the\n+            // type system never \"sees\" those, they get substituted\n+            // away. In trans, they will always be erased to 'static\n+            // whenever a substitution occurs.\n+            match r {\n+                ty::ReLateBound(..) => r,\n+                _ => ty::ReStatic\n+            }\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &subst::Substs<'tcx>)\n+                       -> subst::Substs<'tcx> {\n+            subst::Substs { regions: subst::ErasedRegions,\n+                            types: substs.types.fold_with(self) }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n@@ -468,11 +653,56 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Returns a type variable's default fallback if any exists. A default\n+    /// must be attached to the variable when created, if it is created\n+    /// without a default, this will return None.\n+    ///\n+    /// This code does not apply to integral or floating point variables,\n+    /// only to use declared defaults.\n+    ///\n+    /// See `new_ty_var_with_default` to create a type variable with a default.\n+    /// See `type_variable::Default` for details about what a default entails.\n+    pub fn default(&self, ty: Ty<'tcx>) -> Option<type_variable::Default<'tcx>> {\n+        match ty.sty {\n+            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().default(vid),\n+            _ => None\n+        }\n+    }\n+\n+    pub fn unsolved_variables(&self) -> Vec<ty::Ty<'tcx>> {\n+        let mut variables = Vec::new();\n+\n+        let unbound_ty_vars = self.type_variables\n+                                  .borrow()\n+                                  .unsolved_variables()\n+                                  .into_iter()\n+                                  .map(|t| self.tcx.mk_var(t));\n+\n+        let unbound_int_vars = self.int_unification_table\n+                                   .borrow_mut()\n+                                   .unsolved_variables()\n+                                   .into_iter()\n+                                   .map(|v| self.tcx.mk_int_var(v));\n+\n+        let unbound_float_vars = self.float_unification_table\n+                                     .borrow_mut()\n+                                     .unsolved_variables()\n+                                     .into_iter()\n+                                     .map(|v| self.tcx.mk_float_var(v));\n+\n+        variables.extend(unbound_ty_vars);\n+        variables.extend(unbound_int_vars);\n+        variables.extend(unbound_float_vars);\n+\n+        return variables;\n+    }\n+\n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n                       -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n-                       trace: trace}\n+                       trace: trace,\n+                       cause: None}\n     }\n \n     // public so that it can be used from the rustc_driver unit tests\n@@ -512,8 +742,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn rollback_to(&self, snapshot: CombinedSnapshot) {\n-        debug!(\"rollback!\");\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot) {\n+        debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n@@ -573,7 +803,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n             Ok(_) => { self.commit_from(snapshot); }\n-            Err(_) => { self.rollback_to(snapshot); }\n+            Err(_) => { self.rollback_to(\"commit_if_ok -- error\", snapshot); }\n         }\n         r\n     }\n@@ -592,6 +822,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let r = self.commit_if_ok(|_| f());\n \n+        debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n+\n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n         self.type_variables\n@@ -618,7 +850,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n-        self.rollback_to(snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n         r\n     }\n \n@@ -723,7 +955,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         match higher_ranked::leak_check(self, skol_map, snapshot) {\n             Ok(()) => Ok(()),\n-            Err((br, r)) => Err(ty::terr_regions_insufficiently_polymorphic(br, r))\n+            Err((br, r)) => Err(TypeError::RegionsInsufficientlyPolymorphic(br, r))\n         }\n     }\n \n@@ -768,15 +1000,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging)\n+            .new_var(diverging, None)\n     }\n \n     pub fn next_ty_var(&self) -> Ty<'tcx> {\n-        ty::mk_var(self.tcx, self.next_ty_var_id(false))\n+        self.tcx.mk_var(self.next_ty_var_id(false))\n+    }\n+\n+    pub fn next_ty_var_with_default(&self,\n+                                    default: Option<type_variable::Default<'tcx>>) -> Ty<'tcx> {\n+        let ty_var_id = self.type_variables\n+                            .borrow_mut()\n+                            .new_var(false, default);\n+\n+        self.tcx.mk_var(ty_var_id)\n     }\n \n     pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n-        ty::mk_var(self.tcx, self.next_ty_var_id(true))\n+        self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n \n     pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n@@ -808,20 +1049,55 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    // We have to take `&mut Substs` in order to provide the correct substitutions for defaults\n+    // along the way, for this reason we don't return them.\n+    pub fn type_vars_for_defs(&self,\n+                              span: Span,\n+                              space: subst::ParamSpace,\n+                              substs: &mut Substs<'tcx>,\n+                              defs: &[ty::TypeParameterDef<'tcx>]) {\n+\n+        let mut vars = Vec::with_capacity(defs.len());\n+\n+        for def in defs.iter() {\n+            let default = def.default.map(|default| {\n+                type_variable::Default {\n+                    ty: default.subst_spanned(self.tcx, substs, Some(span)),\n+                    origin_span: span,\n+                    def_id: def.default_def_id\n+                }\n+            });\n+\n+            let ty_var = self.next_ty_var_with_default(default);\n+            substs.types.push(space, ty_var);\n+            vars.push(ty_var)\n+        }\n+    }\n+\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n                                      generics: &ty::Generics<'tcx>)\n                                      -> subst::Substs<'tcx>\n     {\n-        let type_params =\n-            generics.types.map(\n-                |_| self.next_ty_var());\n+        let type_params = subst::VecPerParamSpace::empty();\n+\n         let region_params =\n             generics.regions.map(\n                 |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n-        subst::Substs::new(type_params, region_params)\n+\n+        let mut substs = subst::Substs::new(type_params, region_params);\n+\n+        for space in subst::ParamSpace::all().iter() {\n+            self.type_vars_for_defs(\n+                span,\n+                *space,\n+                &mut substs,\n+                generics.types.get_slice(*space));\n+        }\n+\n+        return substs;\n     }\n \n     /// Given a set of generics defined on a trait, returns a substitution mapping each output\n@@ -839,19 +1115,66 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::SelfSpace) == 0);\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n-        let type_parameter_count = generics.types.len(subst::TypeSpace);\n-        let type_parameters = self.next_ty_vars(type_parameter_count);\n+        let type_params = Vec::new();\n \n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n \n-        subst::Substs::new_trait(type_parameters, regions, self_ty)\n+        let mut substs = subst::Substs::new_trait(type_params, regions, self_ty);\n+\n+        let type_parameter_defs = generics.types.get_slice(subst::TypeSpace);\n+        self.type_vars_for_defs(span, subst::TypeSpace, &mut substs, type_parameter_defs);\n+\n+        return substs;\n     }\n \n     pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n         self.region_vars.new_bound(debruijn)\n     }\n \n+    /// Apply `adjustment` to the type of `expr`\n+    pub fn adjust_expr_ty(&self,\n+                          expr: &ast::Expr,\n+                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          -> Ty<'tcx>\n+    {\n+        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.shallow_resolve(raw_ty);\n+        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n+        raw_ty.adjust(self.tcx,\n+                      expr.span,\n+                      expr.id,\n+                      adjustment,\n+                      |method_call| self.tables\n+                                        .borrow()\n+                                        .method_map\n+                                        .get(&method_call)\n+                                        .map(|method| resolve_ty(method.ty)))\n+    }\n+\n+    pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types.get(&id) {\n+            Some(&t) => t,\n+            // FIXME\n+            None if self.tcx.sess.err_count() - self.err_count_on_creation != 0 =>\n+                self.tcx.types.err,\n+            None => {\n+                self.tcx.sess.bug(\n+                    &format!(\"no type for node {}: {} in fcx\",\n+                            id, self.tcx.map.node_to_string(id)));\n+            }\n+        }\n+    }\n+\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types.get(&ex.id) {\n+            Some(&t) => t,\n+            None => {\n+                self.tcx.sess.bug(&format!(\"no type for expr in fcx\"));\n+            }\n+        }\n+    }\n+\n     pub fn resolve_regions_and_report_errors(&self,\n                                              free_regions: &FreeRegionMap,\n                                              subject_node_id: ast::NodeId) {\n@@ -865,7 +1188,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n         let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n-        format!(\"({})\", tstrs.connect(\", \"))\n+        format!(\"({})\", tstrs.join(\", \"))\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n@@ -926,7 +1249,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> fres<T> {\n+    /// Resolves all type variables in `t` and then, if any were left\n+    /// unresolved, substitutes an error type. This is used after the\n+    /// main checking when doing a second pass before writeback. The\n+    /// justification is that writeback will produce an error for\n+    /// these unconstrained type variables.\n+    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let ty = self.resolve_type_vars_if_possible(t);\n+        if ty.references_error() || ty.is_ty_var() {\n+            debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n+            Err(())\n+        } else {\n+            Ok(ty)\n+        }\n+    }\n+\n+    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n          * `value`. Region inference must have been run already (e.g.,\n@@ -955,7 +1293,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                      sp: Span,\n                                      mk_msg: M,\n                                      actual_ty: String,\n-                                     err: Option<&ty::type_err<'tcx>>) where\n+                                     err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n@@ -966,27 +1304,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                    mk_msg: M,\n                                                    expected_ty: Option<Ty<'tcx>>,\n                                                    actual_ty: String,\n-                                                   err: Option<&ty::type_err<'tcx>>) where\n+                                                   err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n-        match resolved_expected {\n-            Some(t) if ty::type_is_error(t) => (),\n-            _ => {\n-                let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                    format!(\" ({})\", t_err)\n-                });\n+        if !resolved_expected.references_error() {\n+            let error_str = err.map_or(\"\".to_string(), |t_err| {\n+                format!(\" ({})\", t_err)\n+            });\n \n-                self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n-                    mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str));\n+            self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n+                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n+                error_str));\n \n-                if let Some(err) = err {\n-                    ty::note_and_explain_type_err(self.tcx, err, sp)\n-                }\n+            if let Some(err) = err {\n+                self.tcx.note_and_explain_type_err(err, sp)\n             }\n         }\n     }\n@@ -995,13 +1330,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::type_err<'tcx>>) where\n+                                 err: Option<&ty::TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is TyError.\n-        if ty::type_is_error(actual_ty) {\n+        if actual_ty.references_error() {\n             return;\n         }\n \n@@ -1014,17 +1349,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: &ty::type_err<'tcx>) {\n+                                   err: &ty::TypeError<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n-            values: Types(ty::expected_found {\n+            values: Types(ty::ExpectedFound {\n                 expected: expected,\n                 found: actual\n             })\n         };\n         self.report_and_explain_type_error(trace, err);\n     }\n \n+    pub fn report_conflicting_default_types(&self,\n+                                            span: Span,\n+                                            expected: type_variable::Default<'tcx>,\n+                                            actual: type_variable::Default<'tcx>) {\n+        let trace = TypeTrace {\n+            origin: Misc(span),\n+            values: Types(ty::ExpectedFound {\n+                expected: expected.ty,\n+                found: actual.ty\n+            })\n+        };\n+\n+        self.report_and_explain_type_error(trace,\n+            &TypeError::TyParamDefaultMismatch(ty::ExpectedFound {\n+                expected: expected,\n+                found: actual\n+        }));\n+    }\n+\n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n         span: Span,\n@@ -1068,6 +1422,93 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.equate(true, trace).relate(a, b)\n         }).map(|_| ())\n     }\n+\n+    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+        let ty = self.node_type(id);\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n+        // FIXME(@jroesch): should be able to use:\n+        // ty.moves_by_default(&self.parameter_environment, span)\n+    }\n+\n+    pub fn node_method_ty(&self, method_call: ty::MethodCall)\n+                          -> Option<Ty<'tcx>> {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.ty)\n+            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n+    }\n+\n+    pub fn node_method_id(&self, method_call: ty::MethodCall)\n+                          -> Option<ast::DefId> {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.def_id)\n+    }\n+\n+    pub fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n+                                        -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tables.borrow(), project_adjustments)\n+    }\n+\n+    pub fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n+    }\n+\n+    pub fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n+        self.tcx.region_maps.temporary_scope(rvalue_id)\n+    }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n+    }\n+\n+    pub fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.parameter_environment\n+    }\n+\n+    pub fn closure_kind(&self,\n+                        def_id: ast::DefId)\n+                        -> Option<ty::ClosureKind>\n+    {\n+        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+    }\n+\n+    pub fn closure_type(&self,\n+                        def_id: ast::DefId,\n+                        substs: &ty::ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        let closure_ty = self.tables\n+                             .borrow()\n+                             .closure_tys\n+                             .get(&def_id)\n+                             .unwrap()\n+                             .subst(self.tcx, &substs.func_substs);\n+\n+        if self.normalize {\n+            normalize_associated_type(&self.tcx, &closure_ty)\n+        } else {\n+            closure_ty\n+        }\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {\n@@ -1089,7 +1530,7 @@ impl<'tcx> TypeTrace<'tcx> {\n     pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n-            values: Types(ty::expected_found {\n+            values: Types(ty::ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n             })"}, {"sha": "2dc16d4fa1dd419e0edacba3142cb00847adebe4", "filename": "src/librustc/middle/infer/region_inference/README.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -121,7 +121,7 @@ every expression, block, and pattern (patterns are considered to\n \"execute\" by testing the value they are applied to and creating any\n relevant bindings).  So, for example:\n \n-    fn foo(x: int, y: int) { // -+\n+    fn foo(x: isize, y: isize) { // -+\n     //  +------------+       //  |\n     //  |      +-----+       //  |\n     //  |  +-+ +-+ +-+       //  |\n@@ -168,13 +168,13 @@ an error.\n Here is a more involved example (which is safe) so we can see what's\n going on:\n \n-    struct Foo { f: uint, g: uint }\n+    struct Foo { f: usize, g: usize }\n     ...\n-    fn add(p: &mut uint, v: uint) {\n+    fn add(p: &mut usize, v: usize) {\n         *p += v;\n     }\n     ...\n-    fn inc(p: &mut uint) -> uint {\n+    fn inc(p: &mut usize) -> usize {\n         *p += 1; *p\n     }\n     fn weird() {\n@@ -199,8 +199,8 @@ in a call expression:\n \n     'a: {\n         'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a mut uint = &'a mut (*x).f;\n-        'a_arg3: let a_temp3: uint = {\n+        'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n+        'a_arg3: let a_temp3: usize = {\n             let b_temp1: ... = inc;\n             let b_temp2: &'b = &'b mut (*x).f;\n             'b_call: b_temp1(b_temp2)\n@@ -225,13 +225,13 @@ it will not be *dereferenced* during the evaluation of the second\n argument, it can still be *invalidated* by that evaluation. Consider\n this similar but unsound example:\n \n-    struct Foo { f: uint, g: uint }\n+    struct Foo { f: usize, g: usize }\n     ...\n-    fn add(p: &mut uint, v: uint) {\n+    fn add(p: &mut usize, v: usize) {\n         *p += v;\n     }\n     ...\n-    fn consume(x: Box<Foo>) -> uint {\n+    fn consume(x: Box<Foo>) -> usize {\n         x.f + x.g\n     }\n     fn weird() {"}, {"sha": "4b62c7beab00270b8352582addc8f1ceb59a330e", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -23,7 +23,7 @@ use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use middle::free_region::FreeRegionMap;\n use middle::region;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, TypeError};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n@@ -34,7 +34,6 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n-use std::iter::repeat;\n use std::u32;\n use syntax::ast;\n \n@@ -133,7 +132,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n     ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n+                    Vec<(TypeTrace<'tcx>, ty::TypeError<'tcx>)>,\n                     Vec<SameRegions>),\n }\n \n@@ -870,10 +869,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n                 let fr_scope = fr.scope.to_code_extent();\n-                if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope {\n+                if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope ||\n+                        free_regions.is_static(fr) {\n                     Ok(s)\n                 } else {\n-                    Err(ty::terr_regions_no_overlap(b, a))\n+                    Err(TypeError::RegionsNoOverlap(b, a))\n                 }\n             }\n \n@@ -892,7 +892,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if a == b {\n                     Ok(a)\n                 } else {\n-                    Err(ty::terr_regions_no_overlap(b, a))\n+                    Err(TypeError::RegionsNoOverlap(b, a))\n                 }\n             }\n         }\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         } else if r_id == scope_b {\n             Ok(ReScope(scope_a))\n         } else {\n-            Err(ty::terr_regions_no_overlap(region_a, region_b))\n+            Err(TypeError::RegionsNoOverlap(region_a, region_b))\n         }\n     }\n }\n@@ -1304,7 +1304,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as usize).collect();\n+        let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n \n         for idx in 0..self.num_vars() as usize {\n             match var_data[idx].value {\n@@ -1672,7 +1672,7 @@ impl<'tcx> GenericKind<'tcx> {\n             GenericKind::Param(ref p) =>\n                 p.to_ty(tcx),\n             GenericKind::Projection(ref p) =>\n-                ty::mk_projection(tcx, p.trait_ref.clone(), p.item_name),\n+                tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }"}, {"sha": "39807002b58a167c67785fdf1cb4f9a23ccdff6e", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n-use middle::ty::{self, Ty};\n+use super::{InferCtxt, FixupError, FixupResult};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFoldable};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,7 +36,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx>\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_has_ty_infer(t) {\n+        if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t0 = self.infcx.shallow_resolve(t);\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx>\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> fres<T>\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> FixupResult<T>\n     where T : TypeFoldable<'tcx>\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n@@ -66,7 +66,7 @@ pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> fres\n // `err` field is not enforcable otherwise.\n struct FullTypeResolver<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    err: Option<fixup_err>,\n+    err: Option<FixupError>,\n }\n \n impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n@@ -75,21 +75,21 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) {\n+        if !t.needs_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {\n                 ty::TyInfer(ty::TyVar(vid)) => {\n-                    self.err = Some(unresolved_ty(vid));\n+                    self.err = Some(FixupError::UnresolvedTy(vid));\n                     self.tcx().types.err\n                 }\n                 ty::TyInfer(ty::IntVar(vid)) => {\n-                    self.err = Some(unresolved_int_ty(vid));\n+                    self.err = Some(FixupError::UnresolvedIntTy(vid));\n                     self.tcx().types.err\n                 }\n                 ty::TyInfer(ty::FloatVar(vid)) => {\n-                    self.err = Some(unresolved_float_ty(vid));\n+                    self.err = Some(FixupError::UnresolvedFloatTy(vid));\n                     self.tcx().types.err\n                 }\n                 ty::TyInfer(_) => {"}, {"sha": "4d76d613392ee29fdfa932889667d804c15c2cae", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -10,16 +10,17 @@\n \n use super::combine::{self, CombineFields};\n use super::higher_ranked::HigherRankedRelations;\n-use super::Subtype;\n+use super::SubregionOrigin;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use middle::ty_relate::{Cause, Relate, RelateResult, TypeRelation};\n+use std::mem;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Sub<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+    fields: CombineFields<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Sub<'a, 'tcx> {\n@@ -33,6 +34,17 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n+    fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        debug!(\"sub with_cause={:?}\", cause);\n+        let old_cause = mem::replace(&mut self.fields.cause, Some(cause));\n+        let r = f(self);\n+        debug!(\"sub old_cause={:?}\", old_cause);\n+        self.fields.cause = old_cause;\n+        r\n+    }\n+\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                variance: ty::Variance,\n                                                a: &T,\n@@ -84,11 +96,12 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     }\n \n     fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n-        debug!(\"{}.regions({:?}, {:?})\",\n-               self.tag(),\n-               a,\n-               b);\n-        let origin = Subtype(self.fields.trace.clone());\n+        debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n+               self.tag(), a, b, self.fields.cause);\n+        // FIXME -- we have more fine-grained information available\n+        // from the \"cause\" field, we could perhaps give more tailored\n+        // error messages.\n+        let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n         self.fields.infcx.region_vars.make_subregion(origin, a, b);\n         Ok(a)\n     }"}, {"sha": "3684651f85be6e0bbf6fadb95d109c60d31e2093", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -11,8 +11,10 @@\n pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n-\n use middle::ty::{self, Ty};\n+use syntax::ast::DefId;\n+use syntax::codemap::Span;\n+\n use std::cmp::min;\n use std::marker::PhantomData;\n use std::mem;\n@@ -30,16 +32,30 @@ struct TypeVariableData<'tcx> {\n \n enum TypeVariableValue<'tcx> {\n     Known(Ty<'tcx>),\n-    Bounded(Vec<Relation>),\n+    Bounded {\n+        relations: Vec<Relation>,\n+        default: Option<Default<'tcx>>\n+    }\n+}\n+\n+// We will use this to store the required information to recapitulate what happened when\n+// an error occurs.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Default<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    /// The span where the default was incurred\n+    pub origin_span: Span,\n+    /// The definition that the default originates from\n+    pub def_id: DefId\n }\n \n pub struct Snapshot {\n     snapshot: sv::Snapshot\n }\n \n-enum UndoEntry {\n+enum UndoEntry<'tcx> {\n     // The type of the var was specified.\n-    SpecifyVar(ty::TyVid, Vec<Relation>),\n+    SpecifyVar(ty::TyVid, Vec<Relation>, Option<Default<'tcx>>),\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n@@ -72,6 +88,13 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         relations(self.values.get_mut(a.index as usize))\n     }\n \n+    pub fn default(&self, vid: ty::TyVid) -> Option<Default<'tcx>> {\n+        match &self.values.get(vid.index as usize).value {\n+            &Known(_) => None,\n+            &Bounded { ref default, .. } => default.clone()\n+        }\n+    }\n+\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n         self.values.get(vid.index as usize).diverging\n     }\n@@ -101,8 +124,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             mem::replace(value_ptr, Known(ty))\n         };\n \n-        let relations = match old_value {\n-            Bounded(b) => b,\n+        let (relations, default) = match old_value {\n+            Bounded { relations, default } => (relations, default),\n             Known(_) => panic!(\"Asked to instantiate variable that is \\\n                                already instantiated\")\n         };\n@@ -111,20 +134,22 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             stack.push((ty, dir, vid));\n         }\n \n-        self.values.record(SpecifyVar(vid, relations));\n+        self.values.record(SpecifyVar(vid, relations, default));\n     }\n \n-    pub fn new_var(&mut self, diverging: bool) -> ty::TyVid {\n+    pub fn new_var(&mut self,\n+                   diverging: bool,\n+                   default: Option<Default<'tcx>>) -> ty::TyVid {\n         let index = self.values.push(TypeVariableData {\n-            value: Bounded(vec![]),\n+            value: Bounded { relations: vec![], default: default },\n             diverging: diverging\n         });\n         ty::TyVid { index: index as u32 }\n     }\n \n     pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         match self.values.get(vid.index as usize).value {\n-            Bounded(..) => None,\n+            Bounded { .. } => None,\n             Known(t) => Some(t)\n         }\n     }\n@@ -179,7 +204,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(SpecifyVar(vid, _)) => {\n+                sv::UndoLog::Other(SpecifyVar(vid, _, _)) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n@@ -195,16 +220,30 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n         escaping_types\n     }\n+\n+    pub fn unsolved_variables(&self) -> Vec<ty::TyVid> {\n+        self.values\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, value)| match &value.value {\n+                &TypeVariableValue::Known(_) => None,\n+                &TypeVariableValue::Bounded { .. } => Some(ty::TyVid { index: i as u32 })\n+            })\n+            .collect()\n+    }\n }\n \n impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n     type Value = TypeVariableData<'tcx>;\n-    type Undo = UndoEntry;\n+    type Undo = UndoEntry<'tcx>;\n \n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry) {\n+    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry<'tcx>) {\n         match action {\n-            SpecifyVar(vid, relations) => {\n-                values[vid.index as usize].value = Bounded(relations);\n+            SpecifyVar(vid, relations, default) => {\n+                values[vid.index as usize].value = Bounded {\n+                    relations: relations,\n+                    default: default\n+                };\n             }\n \n             Relate(a, b) => {\n@@ -218,6 +257,6 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n     match v.value {\n         Known(_) => panic!(\"var_sub_var: variable is known\"),\n-        Bounded(ref mut relations) => relations\n+        Bounded { ref mut relations, .. } => relations\n     }\n }"}, {"sha": "c13cec45dc44a353e678486754d5730751e6c16d", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -26,8 +26,8 @@ impl UnifyKey for ty::IntVid {\n impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n-            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n+            ty::IntType(i) => tcx.mk_mach_int(i),\n+            ty::UintType(i) => tcx.mk_mach_uint(i),\n         }\n     }\n }\n@@ -43,6 +43,6 @@ impl UnifyKey for ty::FloatVid {\n \n impl<'tcx> ToType<'tcx> for ast::FloatTy {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_mach_float(tcx, *self)\n+        tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "a10e0b8dfc29e4b8ddd360f372d9be1cb279dbf3", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -13,7 +13,7 @@ use metadata::csearch;\n use middle::def::DefFn;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, HasTypeFlags};\n \n use std::fmt;\n \n@@ -30,7 +30,7 @@ pub fn check_crate(tcx: &ctxt) {\n         tcx: tcx,\n         param_envs: Vec::new(),\n         dummy_sized_ty: tcx.types.isize,\n-        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.isize, None),\n+        dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n     };\n     visit::walk_crate(&mut visitor, tcx.map.krate());\n }\n@@ -54,7 +54,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n+        let intrinsic = match self.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n@@ -92,8 +92,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         // Simple case: no type parameters involved.\n         if\n-            !ty::type_has_params(from) && !ty::type_has_self(from) &&\n-            !ty::type_has_params(to) && !ty::type_has_self(to)\n+            !from.has_param_types() && !from.has_self_ty() &&\n+            !to.has_param_types() && !to.has_self_ty()\n         {\n             let restriction = TransmuteRestriction {\n                 span: span,\n@@ -160,12 +160,12 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // In all cases, we keep the original unsubstituted types\n         // around for error reporting.\n \n-        let from_tc = ty::type_contents(self.tcx, from);\n-        let to_tc = ty::type_contents(self.tcx, to);\n+        let from_tc = from.type_contents(self.tcx);\n+        let to_tc = to.type_contents(self.tcx);\n         if from_tc.interior_param() || to_tc.interior_param() {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute to or from a type that contains \\\n-                       type parameters in its interior\");\n+                       unsubstituted type parameters\");\n             return;\n         }\n \n@@ -213,7 +213,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n                        space, index, param_ty);\n \n-                if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n+                if !param_ty.is_sized(param_env, span) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n \n                     substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n@@ -253,9 +253,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         if let ast::ExprPath(..) = expr.node {\n-            match ty::resolve_expr(self.tcx, expr) {\n+            match self.tcx.resolve_expr(expr) {\n                 DefFn(did, _) if self.def_id_is_transmute(did) => {\n-                    let typ = ty::node_id_to_type(self.tcx, expr.id);\n+                    let typ = self.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         TyBareFn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {"}, {"sha": "f7cd94f30af12e2a30643fbc25df39201109893b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -90,6 +90,10 @@ impl LanguageItems {\n         }\n     }\n \n+    pub fn require_owned_box(&self) -> Result<ast::DefId, String> {\n+        self.require(OwnedBoxLangItem)\n+    }\n+\n     pub fn from_builtin_kind(&self, bound: ty::BuiltinBound)\n                              -> Result<ast::DefId, String>\n     {\n@@ -322,6 +326,8 @@ lets_do_this! {\n     StartFnLangItem,                 \"start\",                   start_fn;\n \n     EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n+    EhPersonalityCatchLangItem,      \"eh_personality_catch\",    eh_personality_catch;\n+    MSVCTryFilterLangItem,           \"msvc_try_filter\",         msvc_try_filter;\n \n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;"}, {"sha": "7db740798bd406f989be18c519cbfca939a638f3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -110,18 +110,15 @@ use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use middle::def::*;\n-use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::region;\n use middle::ty;\n-use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n use std::{fmt, usize};\n use std::io::prelude::*;\n use std::io;\n-use std::iter::repeat;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n@@ -465,7 +462,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ty::with_freevars(ir.tcx, expr.id, |freevars| {\n+        ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n                 if let DefLocal(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -568,8 +565,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Liveness {\n             ir: ir,\n             s: specials,\n-            successors: repeat(invalid_node()).take(num_live_nodes).collect(),\n-            users: repeat(invalid_users()).take(num_live_nodes * num_vars).collect(),\n+            successors: vec![invalid_node(); num_live_nodes],\n+            users: vec![invalid_users(); num_live_nodes * num_vars],\n             loop_scope: Vec::new(),\n             break_ln: NodeMap(),\n             cont_ln: NodeMap(),\n@@ -1137,9 +1134,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ast::ExprCall(ref f, ref args) => {\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f)).diverges()\n-            };\n+            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n+                self.ir.tcx.expr_ty_adjusted(&**f).fn_ret().diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1151,9 +1147,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-            let diverges = ty::ty_fn_ret(method_ty).diverges();\n-            let succ = if diverges {\n+            let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n+            let succ = if method_ty.fn_ret().diverges() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1496,12 +1491,11 @@ fn check_fn(_v: &Liveness,\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n-        let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n+        let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) =>\n+            ty::TyClosure(closure_def_id, ref substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ =>\n-                ty::ty_fn_ret(fn_ty),\n+            _ => fn_ty.fn_ret()\n         }\n     }\n \n@@ -1514,23 +1508,22 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     {\n         // within the fn body, late-bound regions are liberated:\n         let fn_ret =\n-            ty::liberate_late_bound_regions(\n-                self.ir.tcx,\n+            self.ir.tcx.liberate_late_bound_regions(\n                 region::DestructionScopeData::new(body.id),\n                 &self.fn_ret(id));\n \n         match fn_ret {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n \n-                if ty::type_is_nil(t_ret) {\n+                if t_ret.is_nil() {\n                     // for nil return types, it is ok to not return a value expl.\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n-                                    ty::expr_ty(self.ir.tcx, &**e) == t_ret\n+                                    self.ir.tcx.expr_ty(&**e) == t_ret\n                                 },\n                                 _ => false\n                             },"}, {"sha": "ee7079bb47d5920876358134884e2519d7930ecd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 61, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -73,17 +73,16 @@ pub use self::categorization::*;\n use self::Aliasability::*;\n \n use ast_map;\n+use middle::infer;\n use middle::check_const;\n use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n-use util::nodemap::NodeMap;\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n \n-use std::cell::RefCell;\n use std::fmt;\n use std::rc::Rc;\n \n@@ -255,46 +254,13 @@ impl ast_node for ast::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-pub struct MemCategorizationContext<'t,TYPER:'t> {\n-    typer: &'t TYPER\n-}\n-\n-impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n-impl<'t,TYPER:'t> Clone for MemCategorizationContext<'t,TYPER> {\n-    fn clone(&self) -> MemCategorizationContext<'t,TYPER> { *self }\n+#[derive(Copy, Clone)]\n+pub struct MemCategorizationContext<'t, 'a: 't, 'tcx : 'a> {\n+    pub typer: &'t infer::InferCtxt<'a, 'tcx>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n \n-/// The `Typer` trait provides the interface for the mem-categorization\n-/// module to the results of the type check. It can be used to query\n-/// the type assigned to an expression node, to inquire after adjustments,\n-/// and so on.\n-///\n-/// This interface is needed because mem-categorization is used from\n-/// two places: `regionck` and `borrowck`. `regionck` executes before\n-/// type inference is complete, and hence derives types and so on from\n-/// intermediate tables.  This also implies that type errors can occur,\n-/// and hence `node_ty()` and friends return a `Result` type -- any\n-/// error will propagate back up through the mem-categorization\n-/// routines.\n-///\n-/// In the borrow checker, in contrast, type checking is complete and we\n-/// know that no errors have occurred, so we simply consult the tcx and we\n-/// can be sure that only `Ok` results will occur.\n-pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n-    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool;\n-    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>;\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n-    fn is_method_call(&self, id: ast::NodeId) -> bool;\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture>;\n-}\n-\n impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n         let ret = match m {\n@@ -391,24 +357,31 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n-    pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n+impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n+    pub fn new(typer: &'t infer::InferCtxt<'a, 'tcx>) -> MemCategorizationContext<'t, 'a, 'tcx> {\n         MemCategorizationContext { typer: typer }\n     }\n \n-    fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n-        self.typer.tcx()\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.typer.tcx\n     }\n \n     fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        self.typer.node_ty(expr.id)\n+        match self.typer.node_ty(expr.id) {\n+            Ok(t) => Ok(t),\n+            Err(()) => {\n+                debug!(\"expr_ty({:?}) yielded Err\", expr);\n+                Err(())\n+            }\n+        }\n     }\n \n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         let unadjusted_ty = try!(self.expr_ty(expr));\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().get(&expr.id),\n-                         |method_call| self.typer.node_method_ty(method_call)))\n+        Ok(unadjusted_ty.adjust(\n+            self.tcx(), expr.span, expr.id,\n+            self.typer.adjustments().get(&expr.id),\n+            |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -426,7 +399,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                match ty::deref(base_ty, false) {\n+                match base_ty.builtin_deref(false) {\n                     Some(t) => t.ty,\n                     None => { return Err(()); }\n                 }\n@@ -439,7 +412,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n-        match self.typer.adjustments().borrow().get(&expr.id) {\n+        match self.typer.adjustments().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -927,14 +900,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty =\n-                    ty::no_late_bound_regions(\n-                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n+                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n         };\n         let base_cmt_ty = base_cmt.ty;\n-        match ty::deref(base_cmt_ty, true) {\n+        match base_cmt_ty.builtin_deref(true) {\n             Some(mt) => {\n                 let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n                                               mt.ty,\n@@ -1023,11 +995,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n \n                 // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n-                let self_ty = ty::ty_fn_sig(method_ty).input(0);\n-                ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap()\n+                let self_ty = method_ty.fn_sig().input(0);\n+                self.tcx().no_late_bound_regions(&self_ty).unwrap()\n             }\n             None => {\n-                match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n+                match base_cmt.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {\n                         return Err(());\n@@ -1081,7 +1053,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n                     mutbl:m,\n-                    ty: match ty::deref(base_cmt.ty, false) {\n+                    ty: match base_cmt.ty.builtin_deref(false) {\n                         Some(mt) => mt.ty,\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n@@ -1175,15 +1147,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+        where F: FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &ast::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F)\n                        -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+        where F : FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &ast::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1244,7 +1216,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let cmt = match opt_def {\n             Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n-                if !ty::enum_is_univariant(self.tcx(), enum_did) => {\n+                if !self.tcx().enum_is_univariant(enum_did) => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                 }\n             _ => cmt\n@@ -1375,7 +1347,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // types are generated by method resolution and always have\n         // all late-bound regions fully instantiated, so we just want\n         // to skip past the binder.\n-        ty::no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+        self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n            .unwrap()\n            .unwrap() // overloaded ops do not diverge, either\n     }\n@@ -1583,7 +1555,7 @@ impl<'tcx> fmt::Debug for categorization<'tcx> {\n             cat_static_item => write!(f, \"static\"),\n             cat_rvalue(r) => write!(f, \"rvalue({:?})\", r),\n             cat_local(id) => {\n-               let name = ty::tls::with(|tcx| ty::local_var_name_str(tcx, id));\n+               let name = ty::tls::with(|tcx| tcx.local_var_name_str(id));\n                write!(f, \"local({})\", name)\n             }\n             cat_upvar(upvar) => {\n@@ -1648,7 +1620,7 @@ impl fmt::Debug for InteriorKind {\n \n fn element_kind(t: Ty) -> ElementKind {\n     match t.sty {\n-        ty::TyRef(_, ty::mt{ty, ..}) |\n+        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n         ty::TyBox(ty) => match ty.sty {\n             ty::TySlice(_) => VecElement,\n             _ => OtherElement"}, {"sha": "15a1ba853245b0934771e3e8f2daa7b4ecb24cf7", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -192,7 +192,7 @@ pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n }\n \n pub fn def_to_path(tcx: &ty::ctxt, id: ast::DefId) -> ast::Path {\n-    ty::with_path(tcx, id, |path| ast::Path {\n+    tcx.with_path(id, |path| ast::Path {\n         global: false,\n         segments: path.last().map(|elem| ast::PathSegment {\n             identifier: ast::Ident::new(elem.name()),"}, {"sha": "d588f7c6070ce25bd4e1c5ae2682e9a9bd4c2cd5", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d", "patch": "@@ -128,16 +128,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match (*self.tcx.method_map.borrow()).get(&method_call).unwrap().origin {\n-                    ty::MethodStatic(def_id) => {\n+                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                match self.tcx.impl_or_trait_item(def_id).container() {\n+                    ty::ImplContainer(_) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n                                 self.worklist.push(def_id.node)\n                             }\n                             self.reachable_symbols.insert(def_id.node);\n                         }\n                     }\n-                    _ => {}\n+                    ty::TraitContainer(_) => {}\n                 }\n             }\n             _ => {}"}, {"sha": "76edc8c9b20fe1f78e0429ff094d7b2cfbfcdaa9", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "6d3bc7fb68c1418ca20b6775212eecb3b056bb9d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 32, "deletions": 42, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "7d8a20c42e36ecf2800793c5baec0d9c30485574", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "92982af92dcfe7ad772500cb809f66812070bafa", "filename": "src/librustc/middle/traits/README.md", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "977d0577e480f47beb5d76851380dc6f38f6b96b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "582873082a68b2625f07949c0456089859f22805", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "44fc6b6b8abdc6dbb32217a79fc199fc6c1770cc", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "376430e87c6f005b10ee6615a33df7ef044c7a08", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "e7f11b06bd132b1d7c82faac784d704cd149f34c", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ef3a217ecdbf28d494d691def3fe700300a7ab9a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "5727f07edb1d0e77324b3734ee583463f4c1b2a5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 137, "deletions": 164, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "af9d5e5157d28e8567b3ecf2a72602e208184cbb", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ea5ca8acb094fbf829078b2d1de69e9ae027edd3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3273, "deletions": 3782, "changes": 7055, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0c694926ba4b5a829e2c775fadaac7be73924e8e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "4aa0e553a7aa61b4b23a80afde4c8e3d22224d31", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f8678b4d8e3bd1b47cd6481758474bc37400eb87", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 79, "deletions": 45, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "81cad4486904b7e6e7ee946bbd2a2ebc53ca540a", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "72fda9a7ae06ac236f82eda442dc6f2c4bf42f95", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "2cdd2ee2f03c781c280c0b6255b9bae5ccdd8104", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "77575cd6b24c9112eadf13fcd8cc3646c8eeaabc", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "fd49d0468c9063b12289bfd66bfe1efc60e64cfe", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "c7968db4733a2ace8be070c155a16e5f8ecc6a04", "filename": "src/librustc_back/archive.rs", "status": "removed", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "7325e4e7a2ece9aa4a15bee6e35c2820e4159a0c", "filename": "src/librustc_back/arm.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farm.rs?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "ecba37c23153d8c97f149f48a54463dcc50f88d6", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "b46150f75d084516102e96252fc7017489955254", "filename": "src/librustc_back/mips.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmips.rs?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "c7fa7aa879ac272c440982fe5ece76fadd3a70c0", "filename": "src/librustc_back/mipsel.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fmipsel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fmipsel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmipsel.rs?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "4f904c20a51d0fa110fd6dda17e2ae1563031dd8", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "e87cb43128d24fc1efffd5d53c16b3673fc91d95", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "8c350e8b28750ef3ec9f04682a257de05b715468", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ed79caf486942158402e23ce2d47ce527b923ab8", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f34ba40a8b2fe2888d61d84551ba05d056c5625a", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0770fe70e8a5780b69c6e28739fca356d9def1fa", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "084f989277f317024220d1290a180deda2339d2d", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "08f1aa5ade848c6c9d6503c44d463b3b61f0a9db", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "a6d649ea162f93be4cab857075cf4af188055781", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "264385512added148a0519249939a5bcfee2711e", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ddb32f4625b58d0b2af4bedda473ce9271089b45", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "51a371db72446a04745316d64706785c2af5c78e", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "5cf83e575794c83cee2fa0ccee142d1b78bd5cec", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "d17aa915461df369a192a5bf13c88f303cea204a", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "9fe15e76942863c7ada3bf69aa878905f8e3ccb2", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ae1b4d450a58e93792f636f42e9ac966720a0308", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f2ae799bd2438185bcae77d0f17f785c003dae3a", "filename": "src/librustc_back/target/i686_pc_windows_msvc.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f2478e6d0dbfeb37cfe8765013a60a5aafc2d2c7", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "68fee41e2cfa531c31f09f4c3a88f23cafda7c11", "filename": "src/librustc_back/target/i686_unknown_freebsd.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "074d5b2b9ed228d5be4995a2f78c5e0d55b77b18", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "b2dcd5aae21139feaaf4275b2ac7abd001f92533", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "3f3da6d6c9136aa86448c17ead7d1d761b37b021", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "d7f286c8aa4085beda3357ee7c6cbb9b062a2785", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "39e42913ff6745e4389001908b80804bb95e2a16", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "9b20bd927cb7a1d161df8a1b19c512d5d080a0f8", "filename": "src/librustc_back/target/netbsd_base.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "4d3f9668c9f6b3e629609753c87e27743373c51f", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "896824eba0e56b627bbb4ce14ae0caf6f745d11d", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "fd29fe89271cb8f38401794aa6175098edcb7953", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ef40c2f2006e1628086bdb2906f30d6748b6118b", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "7aca8c554dab63dd27c6d9b980dc1a1f3b464ceb", "filename": "src/librustc_back/target/x86_64_apple_ios.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "e4d7b4bc9b024fab54df64f1d57958039c556098", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "addaaeb1b636da2cf7353eed6b96eeca3942cd43", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "6ecf885aba38eff9cf1f1e9441001c32ccf3a3ca", "filename": "src/librustc_back/target/x86_64_unknown_bitrig.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f0e665967ec6f3fd2b77304ce1ec28f584b79543", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f742ebfde1d2c314fdf2e28e54c72d38e76f8613", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "4749e481fd85534724ff1bba722cd73ffc9e557f", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "c66192c28b13d7ce1ef2ddddd1f03dd891ba679c", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "e13e58e3a186d163d22cc7a3dfc3c0491dad20c9", "filename": "src/librustc_back/target/x86_64_unknown_netbsd.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "a404db48b22bb38875769d86e8d82b675e46ccf8", "filename": "src/librustc_back/target/x86_64_unknown_openbsd.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "1c6eacc355947850044b035fb5d6db4f8690a1c9", "filename": "src/librustc_back/x86.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86.rs?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "d016bd12c698fdd5646cafbf4f5c7e298ba10c7a", "filename": "src/librustc_back/x86_64.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003c3eaa62981b791f9eb7bcad015baa1e00d98c/src%2Flibrustc_back%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86_64.rs?ref=003c3eaa62981b791f9eb7bcad015baa1e00d98c"}, {"sha": "1be2b605dbdcc5f45c0e0492e2d6f65a3294ad2d", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 24, "deletions": 196, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "9bd4da28c99fbd2d839b5ba3b3c14985ce708f00", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "2b33dde2cbe2daa18f1e5c4e67beb1e7614cd5bb", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "919bc45f00ddfe955e4ae188574ef83af8cb3a54", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "6899892a245ed5d5d4512705e36cc2f0428839d3", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 101, "deletions": 63, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "5baabebea116b57b5e080ed16bccaa3dbf7e7044", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "4c186dd840610a071816952be41a50c671314d4f", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "8f2e5deb92c7dd5f9be9487f7e576f1b9a108e56", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "4f90a287cb999f43ac249b5cb14c0b92a212195a", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f2f4a69d882b45c671d6538693d2911e7a4d15ce", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "7582b7ff61d8830c66b525a9ce6bb654754c5d3c", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "67301a09e52bf63a6e10225e3a25bf815f62c2b8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "873950b0be893a9f93c835af860cf7413266a6e9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0e735cbb7ff8ebabea7d1761de84c44c3acad2f1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "a9efd13a998986a5a6e706769b01a3e3c1ce8057", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "6289d50588104bbffa0baf63dd9379b38862e535", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 425, "deletions": 156, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "8d6dfb929873064aad959f9c7275ea910d01efb8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "85c0c721114f5837d6c112e9a47a74420c0087e3", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "9ee046915daca66a4a526b90df3cc8d64998e46f", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "d90e5a033a187bb90de3360811dc61e3d7450f99", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "aa7f93776da22918cb8fd56d560d57a660459ce3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "9f8a5c90d4e1cb0c02c09a25d827497eb5316133", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 314, "deletions": 5, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "a3a0398e5ce1d58f5735d66066a70c2076f7580c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 477, "deletions": 195, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ec02963980bd0689f77251b46b5ddef41dd0c924", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "02f4bc83b7524a0a040d66021e528323993f0f28", "filename": "src/librustc_trans/back/archive.rs", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "d7849e8f555ba7539a49deef252e5d2cde6d385c", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 178, "deletions": 159, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "3a709955098c3db0622899741ac4e0fe3917fa38", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "518add44b4c4a6b5622adad232e10daa0e8983ef", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0077e7eed52d02e49e34bed0e301aa357b1f1f6c", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "21078641c1f536ccd7c917a1c926e30633d2220e", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "b901e31a53a001861661355ee8b23b7c7a52fd24", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 119, "deletions": 203, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "af894b218eff8e87e76c7103da155d91e5a9df27", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f291413cedc7ede8ab25fdb8277f70409164ed7a", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 96, "deletions": 236, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "26da803de6557538a42e487d35f663f7f59e1120", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 258, "deletions": 26, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ee7b1c4ff6e29a5d12a71c28619a8ffa231908a7", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "925da81d77e6bdf4d6ac00c4f7d36f7c85f8018c", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 33, "deletions": 79, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "dc7e34a386f93d124377eb22ca85dd0f052922ae", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "67e7aa5baf62b2595773b0a7f3719aaa92940542", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "62b03c9fb0f1fcaa858b6ed464efe9628220e4df", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "c331bf8d4610132f5254db20faedcd13ec699325", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 203, "deletions": 197, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "5a3fcc8d27f3cb8bf422c6d6e8dabc579eb89d66", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "107ae378ac4463925e70fd978af74f270b176dcf", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "fa3824866ccb8880738d9055fa54e1e9fe94437a", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0f75c1f8ab65a6d0befe9ec2f3b25a57db63db43", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 105, "deletions": 153, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0d49712031937fe232cd749e47958829bba10fec", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 9, "deletions": 68, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "ef5da3e40dfda9559e0a753482d5a2e9c9af14ce", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 48, "deletions": 77, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "8ec65639b5227d6fff4c0264294ddda8319fdf15", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 89, "deletions": 211, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "bd9c4a171773c68cb975387da113953a8bb85c7f", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 364, "deletions": 357, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "1b6307f28bfdf91bdb62a7c5ed59947f48d76f82", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "c0ebffb58afcf088ed10c9fab0cf63167261eda0", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "f7b0f37c9ff78bbbb337417310adede676f60942", "filename": "src/librustc_trans/trans/debuginfo/gdb.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fgdb.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "09495dea286864777596fd26fae84c3b36bdd3c8", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "8e4e0aaa75fec338bcb5311a8f6d71ddfb77a1f0", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "8b33acdee8e25db5e1517d2b409039aeeef41325", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "b912acb90a2cec32c9a68153073af153558e16ff", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "0c77e74be38aa1f831bc8a0525ff17a2582694e0", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "962803932b88b03361d671be9dfd79b6dadc6c40", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 81, "deletions": 79, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "e102e3cd062be220dbf886d712cbcecef7c69be7", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "e530eb0de59b8e7b9ed9cdbc6f6c08033be85d89", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}, {"sha": "75c80690f2ad4b73f415cd93112c27135859ca74", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e9240a99e86d2c799dc29f179dd2870e51f71d/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=f6e9240a99e86d2c799dc29f179dd2870e51f71d"}]}