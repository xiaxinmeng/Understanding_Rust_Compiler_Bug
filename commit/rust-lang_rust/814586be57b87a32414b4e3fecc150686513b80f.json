{"sha": "814586be57b87a32414b4e3fecc150686513b80f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNDU4NmJlNTdiODdhMzI0MTRiNGUzZmVjYzE1MDY4NjUxM2I4MGY=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-10-15T06:25:34Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-10-16T15:15:34Z"}, "message": "librustc: Remove all uses of {:?}.", "tree": {"sha": "5d16d22743d333ae2f0cf4d1bd02b986d934d1f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d16d22743d333ae2f0cf4d1bd02b986d934d1f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/814586be57b87a32414b4e3fecc150686513b80f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/814586be57b87a32414b4e3fecc150686513b80f", "html_url": "https://github.com/rust-lang/rust/commit/814586be57b87a32414b4e3fecc150686513b80f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/814586be57b87a32414b4e3fecc150686513b80f/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26e547af5d2d98c9e85770ac53217ad0f8b24999", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e547af5d2d98c9e85770ac53217ad0f8b24999", "html_url": "https://github.com/rust-lang/rust/commit/26e547af5d2d98c9e85770ac53217ad0f8b24999"}], "stats": {"total": 727, "additions": 386, "deletions": 341}, "files": [{"sha": "75171af741110e191a2e0b6fbf6422d877fa684a", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -518,7 +518,7 @@ pub fn pretty_print_input(sess: Session,\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n-                                           block, fn, or method; got {:?}\",\n+                                           block, fn, or method; got {}\",\n                                           node);\n \n                     // point to what was found, if there's an\n@@ -542,7 +542,6 @@ fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n     };\n-    debug!(\"cfg: {:?}\", cfg);\n \n     match code {\n         _ if variants.len() == 0 => {"}, {"sha": "b7bd97e021965432e8f17b664a325dd25ae950bc", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -226,13 +226,13 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n     let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || {\n-        (format!(\"get_field_type: class ID {:?} not found\",\n+        (format!(\"get_field_type: class ID {} not found\",\n                  class_id)).to_string()\n     });\n     let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || {\n-            (format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n+            (format!(\"get_field_type: in class {}, field ID {} not found\",\n                     class_id,\n                     def)).to_string()\n         });"}, {"sha": "b9135e974c5d7963c98b2456d0c9103d7892631c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -256,7 +256,7 @@ fn encode_symbol(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().find(&id) {\n         Some(x) => {\n-            debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n+            debug!(\"encode_symbol(id={}, str={})\", id, *x);\n             rbml_w.writer.write(x.as_bytes());\n         }\n         None => {\n@@ -308,7 +308,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n                             index: &mut Vec<entry<i64>>) {\n-    debug!(\"encode_enum_variant_info(id={:?})\", id);\n+    debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n@@ -592,7 +592,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n             ItemImpl(..) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n-                        ({:?}/{:?})\",\n+                        ({}/{})\",\n                         token::get_ident(ident),\n                         did, ecx.tcx.map.node_to_string(did));\n \n@@ -853,7 +853,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           parent_id: NodeId,\n                           ast_item_opt: Option<&ImplItem>) {\n \n-    debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n+    debug!(\"encode_info_for_method: {} {}\", m.def_id,\n            token::get_ident(m.ident));\n     rbml_w.start_tag(tag_items_data_item);\n "}, {"sha": "34aa9310ef236e6f2ead31fa0536b121f8ad5d4f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -39,7 +39,7 @@ impl<'a> FileSearch<'a> {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n \n-        debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n+        debug!(\"filesearch: searching additional lib search paths [{}]\",\n                self.addl_lib_search_paths.borrow().len());\n         for path in self.addl_lib_search_paths.borrow().iter() {\n             match f(path) {\n@@ -66,7 +66,7 @@ impl<'a> FileSearch<'a> {\n             for path in rustpath.iter() {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n-                debug!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n+                debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n                         visited_dirs.contains_equiv(&tlib_path.as_vec().to_vec()));\n \n                 if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {"}, {"sha": "c8d56c61d2b9ae7310e32d8339f609c5c99e1e85", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -43,6 +43,7 @@ use syntax::parse::token;\n // def-id will depend on where it originated from.  Therefore, the conversion\n // function is given an indicator of the source of the def-id.  See\n // astencode.rs for more information.\n+#[deriving(Show)]\n pub enum DefIdSource {\n     // Identifies a struct, trait, enum, etc.\n     NominalType,\n@@ -390,7 +391,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n-        debug!(\"parsed ty_param: did={:?}\", did);\n+        debug!(\"parsed ty_param: did={}\", did);\n         let index = parse_uint(st);\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n@@ -603,12 +604,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,\n-       None => fail!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n+       None => fail!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as ast::NodeId,\n-       None => fail!(\"internal error: parse_def_id: id expected, found {:?}\",\n+       None => fail!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }"}, {"sha": "ec693679b1539d0704cb88a931bc305fc278fb6a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -1807,7 +1807,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n             TypeParameter => dcx.tr_intern_def_id(did)\n         };\n-        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n+        debug!(\"convert_def_id(source={}, did={})={}\", source, did, r);\n         return r;\n     }\n }\n@@ -1841,7 +1841,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);\n-                        debug!(\"inserting ty for node {:?}: {}\",\n+                        debug!(\"inserting ty for node {}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n                         dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }"}, {"sha": "4eba46b469c7d921c74b2cda50d3ca7d682ca999", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n               loan_cause: euv::LoanCause)\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={:?})\",\n+               bk={}, loan_cause={})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -185,7 +185,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      all_loans: &[Loan],\n                                      decl: &ast::FnDecl,\n                                      body: &ast::Block) {\n-    debug!(\"check_loans(body id={:?})\", body.id);\n+    debug!(\"check_loans(body id={})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -336,10 +336,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! issued when we enter `scope_id` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n \n-        debug!(\"check_for_conflicting_loans(scope_id={:?})\", scope_id);\n+        debug!(\"check_for_conflicting_loans(scope_id={})\", scope_id);\n \n         let new_loan_indices = self.loans_generated_by(scope_id);\n-        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n+        debug!(\"new_loan_indices = {}\", new_loan_indices);\n \n         self.each_issued_loan(scope_id, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        use_path: &LoanPath,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError {\n-        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={})\",\n+        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n                self.tcx().map.node_to_string(expr_id),\n                use_path.repr(self.tcx()));\n \n@@ -679,7 +679,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n          * is using a moved/uninitialized value\n          */\n \n-        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n+        debug!(\"check_if_path_is_moved(id={}, use_kind={}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         let base_lp = owned_ptr_base_path_rc(lp);\n         self.move_data.each_move_of(id, &base_lp, |the_move, moved_lp| {"}, {"sha": "d28baf48ddcdf5825043068a26a56dad2e0be9a8", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n               loan_cause: euv::LoanCause)\n     {\n         debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n-               bk={}, loan_cause={:?})\",\n+               bk={}, loan_cause={})\",\n                borrow_id, cmt.repr(self.tcx()), loan_region,\n                bk, loan_cause);\n \n@@ -218,8 +218,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n          * dynamically that they are not freed.\n          */\n \n-        debug!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n-                req_mutbl={:?}, loan_region={:?})\",\n+        debug!(\"guarantee_valid(borrow_id={}, cmt={}, \\\n+                req_mutbl={}, loan_region={})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n                req_kind,\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             self.bccx, borrow_span, cause,\n             cmt.clone(), loan_region);\n \n-        debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n+        debug!(\"guarantee_valid(): restrictions={}\", restr);\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -289,17 +289,17 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {:?}\",\n+                            format!(\"invalid borrow lifetime: {}\",\n                                     loan_region).as_slice());\n                     }\n                 };\n-                debug!(\"loan_scope = {:?}\", loan_scope);\n+                debug!(\"loan_scope = {}\", loan_scope);\n \n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n-                debug!(\"gen_scope = {:?}\", gen_scope);\n+                debug!(\"gen_scope = {}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n-                debug!(\"kill_scope = {:?}\", kill_scope);\n+                debug!(\"kill_scope = {}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n                     self.mark_loan_path_as_mutated(&*loan_path);\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={:?}), loan={}\",\n+        debug!(\"guarantee_valid(borrow_id={}), loan={}\",\n                borrow_id, loan.repr(self.tcx()));\n \n         // let loan_path = loan.loan_path;"}, {"sha": "bf1b4b7e476ecea82537a2b1d4c0a855052fa2e7", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -21,6 +21,7 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n \n+#[deriving(Show)]\n pub enum RestrictionResult {\n     Safe,\n     SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)"}, {"sha": "ec09e9e72d7ba24be834dce797a7fe0d013c7886", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -264,14 +264,14 @@ impl Loan {\n     }\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n     LpUpvar(ty::UpvarId),             // `x` captured by-value into closure\n     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n@@ -421,6 +421,7 @@ pub enum AliasableViolationKind {\n     BorrowViolation(euv::LoanCause)\n }\n \n+#[deriving(Show)]\n pub enum MovedValueUseKind {\n     MovedInUse,\n     MovedInCapture,\n@@ -530,8 +531,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to \\\n-                                                   {:?}, not Expr\",\n+                        self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n+                                                   {}, not Expr\",\n                                                   the_move.id,\n                                                   r).as_slice())\n                     }\n@@ -566,8 +567,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"Captured({:?}) maps to \\\n-                                                   {:?}, not Expr\",\n+                        self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n+                                                   {}, not Expr\",\n                                                   the_move.id,\n                                                   r).as_slice())\n                     }\n@@ -892,7 +893,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n \n impl Repr for Loan {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n+        format!(\"Loan_{}({}, {}, {}-{}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n                  self.kind,"}, {"sha": "4c2ee9fe551c4fbd14ba2053da6505d83a78719d", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -68,7 +68,7 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub struct MovePathIndex(uint);\n \n impl MovePathIndex {\n@@ -120,7 +120,7 @@ pub struct MovePath {\n     pub next_sibling: MovePathIndex,\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum MoveKind {\n     Declared,   // When declared, variables start out \"moved\".\n     MoveExpr,   // Expression or binding that moves a variable\n@@ -284,7 +284,7 @@ impl MoveData {\n             }\n         };\n \n-        debug!(\"move_path(lp={}, index={:?})\",\n+        debug!(\"move_path(lp={}, index={})\",\n                lp.repr(tcx),\n                index);\n \n@@ -341,7 +341,7 @@ impl MoveData {\n          * location `id` with kind `kind`.\n          */\n \n-        debug!(\"add_move(lp={}, id={:?}, kind={:?})\",\n+        debug!(\"add_move(lp={}, id={}, kind={})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -372,7 +372,7 @@ impl MoveData {\n          * location `id` with the given `span`.\n          */\n \n-        debug!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n+        debug!(\"add_assignment(lp={}, assign_id={}, assignee_id={}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -391,12 +391,12 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n+            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={})\",\n                    lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n \n             self.var_assignments.borrow_mut().push(assignment);\n         } else {\n-            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n+            debug!(\"add_assignment[path](lp={}, path_index={})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.borrow_mut().push(assignment);"}, {"sha": "fa5a6a2e54aad80c022bd1a9eeb3fc5c0b13cba1", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -483,12 +483,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} input:{}\", expr.id, a);\n                     let &(_, ref expr) = a;\n                     &**expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n-                    debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n+                    debug!(\"cfg::construct InlineAsm id:{} output:{}\", expr.id, a);\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n@@ -616,14 +616,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"no loop scope for id {:?}\",\n+                            format!(\"no loop scope for id {}\",\n                                     loop_id).as_slice());\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\",\n+                            format!(\"bad entry `{}` in def_map for label\",\n                                     r).as_slice());\n                     }\n                 }"}, {"sha": "d6b9bbded4ff89e7050b85770ee1e1ad56302523", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -145,7 +145,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 Some(&DefStruct(_)) => { }\n \n                 Some(&def) => {\n-                    debug!(\"(checking const) found bad def: {:?}\", def);\n+                    debug!(\"(checking const) found bad def: {}\", def);\n                     span_err!(v.tcx.sess, e.span, E0014,\n                               \"paths in constants may only refer to constants \\\n                                or functions\");"}, {"sha": "abccc7623a75925fcb1acbe2fe19fcef148cffec", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -987,7 +987,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         cx.tcx.sess.span_bug(\n                             p.span,\n                             format!(\"binding pattern {} is not an \\\n-                                     identifier: {:?}\",\n+                                     identifier: {}\",\n                                     p.id,\n                                     p.node).as_slice());\n                     }"}, {"sha": "cd7c4b15494a997ed05470e87e274278ba05359c", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {\n                span: Span,\n                cmt: mc::cmt,\n                _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n+        debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n         if !ty::type_is_sized(self.tcx, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\","}, {"sha": "a8b8eb2e3394dbe64b67f46733971051dcb890b7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -193,8 +193,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n-        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={:?}, \\\n-                                     bits_per_id={:?}, words_per_id={:?}) \\\n+        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={}, \\\n+                                     bits_per_id={}, words_per_id={}) \\\n                                      num_nodes: {}\",\n                analysis_name, id_range, bits_per_id, words_per_id,\n                num_nodes);\n@@ -222,7 +222,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n-        debug!(\"{:s} add_gen(id={:?}, bit={:?})\",\n+        debug!(\"{:s} add_gen(id={}, bit={})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n@@ -235,7 +235,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n-        debug!(\"{:s} add_kill(id={:?}, bit={:?})\",\n+        debug!(\"{:s} add_kill(id={}, bit={})\",\n                self.analysis_name, id, bit);\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n@@ -336,7 +336,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n+        debug!(\"{:s} each_gen_bit(id={}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n     }\n@@ -408,7 +408,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                     }\n                     None => {\n                         debug!(\"{:s} add_kills_from_flow_exits flow_exit={} \\\n-                                no cfg_idx for exiting_scope={:?}\",\n+                                no cfg_idx for exiting_scope={}\",\n                                self.analysis_name, flow_exit, node_id);\n                     }\n                 }\n@@ -529,7 +529,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"{:s} changed entry set for {:?} to {}\",\n+            debug!(\"{:s} changed entry set for {} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n                    bits_to_string(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;"}, {"sha": "bde868cdf6d07ea2022bffc04618b05e506022da", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: {:?}\", block_id);\n+                debug!(\"effect: recording unsafe block as used: {}\", block_id);\n                 self.tcx.used_unsafe.borrow_mut().insert(block_id);\n             }\n             UnsafeFn => {}"}, {"sha": "65633cfb34cd7f0d31ddc2b996e9616607448a36", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -73,7 +73,7 @@ pub trait Delegate {\n               mode: MutateMode);\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum LoanCause {\n     ClosureCapture(Span),\n     AddrOf,\n@@ -85,7 +85,7 @@ pub enum LoanCause {\n     MatchDiscriminant\n }\n \n-#[deriving(PartialEq,Show)]\n+#[deriving(PartialEq, Show)]\n pub enum ConsumeMode {\n     Copy,                // reference to x where x has a type that copies\n     Move(MoveReason),    // reference to x where x has a type that moves\n@@ -625,7 +625,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"walk_block(blk.id={:?})\", blk.id);\n+        debug!(\"walk_block(blk.id={})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n             self.walk_stmt(&**stmt);"}, {"sha": "463eaa40ae03e30f8f1ac1fd31ad58f8421873d2", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -36,6 +36,7 @@ be indexed by the direction (see the type `Direction`).\n \n #![allow(dead_code)] // still WIP\n \n+use std::fmt::{Formatter, FormatError, Show};\n use std::uint;\n \n pub struct Graph<N,E> {\n@@ -55,12 +56,20 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n+impl<E: Show> Show for Edge<E> {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), FormatError> {\n+        write!(f, \"Edge {{ next_edge: [{}, {}], source: {}, target: {}, data: {} }}\",\n+               self.next_edge[0], self.next_edge[1], self.source,\n+               self.target, self.data)\n+    }\n+}\n+\n #[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n #[allow(non_uppercase_statics)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_uppercase_statics)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n@@ -307,6 +316,7 @@ impl<E> Edge<E> {\n #[cfg(test)]\n mod test {\n     use middle::graph::*;\n+    use std::fmt::Show;\n \n     type TestNode = Node<&'static str>;\n     type TestEdge = Edge<&'static str>;\n@@ -361,7 +371,7 @@ mod test {\n         });\n     }\n \n-    fn test_adjacent_edges<N:PartialEq,E:PartialEq>(graph: &Graph<N,E>,\n+    fn test_adjacent_edges<N:PartialEq+Show,E:PartialEq+Show>(graph: &Graph<N,E>,\n                                       start_index: NodeIndex,\n                                       start_data: N,\n                                       expected_incoming: &[(E,N)],\n@@ -372,7 +382,7 @@ mod test {\n         graph.each_incoming_edge(start_index, |edge_index, edge| {\n             assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_incoming.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+            debug!(\"counter={} expected={} edge_index={} edge={}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n@@ -390,7 +400,7 @@ mod test {\n         graph.each_outgoing_edge(start_index, |edge_index, edge| {\n             assert!(graph.edge_data(edge_index) == &edge.data);\n             assert!(counter < expected_outgoing.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+            debug!(\"counter={} expected={} edge_index={} edge={}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {"}, {"sha": "490e49d051ee58addee73a8e4b87546a665bafff", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -154,7 +154,7 @@ impl Clone for LiveNode {\n     }\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),\n@@ -240,11 +240,13 @@ struct CaptureInfo {\n     var_nid: NodeId\n }\n \n+#[deriving(Show)]\n struct LocalInfo {\n     id: NodeId,\n     ident: Ident\n }\n \n+#[deriving(Show)]\n enum VarKind {\n     Arg(NodeId, Ident),\n     Local(LocalInfo),\n@@ -307,7 +309,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             ImplicitRet => {}\n         }\n \n-        debug!(\"{} is {:?}\", v.to_string(), vk);\n+        debug!(\"{} is {}\", v.to_string(), vk);\n \n         v\n     }\n@@ -424,7 +426,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from match with bm {:?}\",\n+            debug!(\"adding local variable {} from match with bm {}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -442,7 +444,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n+        debug!(\"expr {}: path that leads to {}\", expr.id, def);\n         match def {\n             DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n             _ => {}\n@@ -489,7 +491,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n       ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n-            debug!(\"adding local variable {} from for loop with bm {:?}\",\n+            debug!(\"adding local variable {} from for loop with bm {}\",\n                    p_id, bm);\n             let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -733,7 +735,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut wr = io::MemWriter::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n-            write!(wr, \"[ln({}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n+            write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);"}, {"sha": "c5993dcb39de876696052578e560c7b2727397fa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -78,7 +78,7 @@ use syntax::parse::token;\n use std::cell::RefCell;\n use std::rc::Rc;\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n@@ -94,7 +94,7 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum CopiedUpvarKind {\n     Boxed(ast::Onceness),\n     Unboxed(ty::UnboxedClosureKind)\n@@ -111,15 +111,15 @@ impl CopiedUpvarKind {\n     }\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub kind: CopiedUpvarKind,\n     pub capturing_proc: ast::NodeId,\n }\n \n // different kinds of pointers:\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum PointerKind {\n     OwnedPtr,\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n@@ -129,19 +129,19 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum ElementKind {\n     VecElement,\n     OtherElement,\n@@ -168,7 +168,7 @@ pub enum MutabilityCategory {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct cmt_ {\n     pub id: ast::NodeId,          // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -542,7 +542,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr_ty: ty::t,\n                    def: def::Def)\n                    -> McResult<cmt> {\n-        debug!(\"cat_def: id={} expr={} def={:?}\",\n+        debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n@@ -781,7 +781,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let method_ty = self.typer.node_method_ty(method_call);\n \n-        debug!(\"cat_deref: method_call={:?} method_ty={}\",\n+        debug!(\"cat_deref: method_call={} method_ty={}\",\n             method_call, method_ty.map(|ty| ty.repr(self.tcx())));\n \n         let base_cmt = match method_ty {\n@@ -1352,7 +1352,7 @@ impl cmt_ {\n \n impl Repr for cmt_ {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"{{{} id:{} m:{:?} ty:{}}}\",\n+        format!(\"{{{} id:{} m:{} ty:{}}}\",\n                 self.cat.repr(tcx),\n                 self.id,\n                 self.mutbl,\n@@ -1368,7 +1368,7 @@ impl Repr for categorization {\n             cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_upvar(..) => {\n-                format!(\"{:?}\", *self)\n+                format!(\"{}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n                 format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr_sigil(ptr), derefs)\n@@ -1405,7 +1405,7 @@ impl Repr for InteriorKind {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).get().to_string()\n             }\n-            InteriorField(PositionalField(i)) => format!(\"#{:?}\", i),\n+            InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n             InteriorElement(_) => \"[]\".to_string(),\n         }\n     }"}, {"sha": "6e430760e368ff347a04d2f10950403d1c026e21", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -347,7 +347,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n-            assert!(self.exp_map2.contains_key(&id), \"wut {:?}\", id);\n+            assert!(self.exp_map2.contains_key(&id), \"wut {}\", id);\n             for export in self.exp_map2.get(&id).iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n@@ -394,28 +394,28 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n         if !is_local(did) {\n             if self.external_exports.contains(&did) {\n-                debug!(\"privacy - {:?} was externally exported\", did);\n+                debug!(\"privacy - {} was externally exported\", did);\n                 return Allowable;\n             }\n-            debug!(\"privacy - is {:?} a public method\", did);\n+            debug!(\"privacy - is {} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().find(&did) {\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {:?}\",\n+                    debug!(\"privacy - well at least it's a method: {}\",\n                            *meth);\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            debug!(\"privacy - recursing on trait {}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    debug!(\"privacy - impl of trait {}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a method {:?}\",\n+                                    debug!(\"privacy - found a method {}\",\n                                             meth.vis);\n                                     if meth.vis == ast::Public {\n                                         Allowable\n@@ -430,17 +430,17 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 Some(&ty::TypeTraitItem(ref typedef)) => {\n                     match typedef.container {\n                         ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            debug!(\"privacy - recursing on trait {}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    debug!(\"privacy - impl of trait {}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug!(\"privacy - found a typedef {:?}\",\n+                                    debug!(\"privacy - found a typedef {}\",\n                                             typedef.vis);\n                                     if typedef.vis == ast::Public {\n                                         Allowable\n@@ -551,7 +551,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // members, so that's why we test the parent, and not the did itself.\n         let mut cur = self.curitem;\n         loop {\n-            debug!(\"privacy - questioning {}, {:?}\", self.nodestr(cur), cur);\n+            debug!(\"privacy - questioning {}, {}\", self.nodestr(cur), cur);\n             match cur {\n                 // If the relevant parent is in our history, then we're allowed\n                 // to look inside any of our ancestor's immediate private items,"}, {"sha": "cf48e1899d18ef8cc369310616d74c66e1346da1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -113,7 +113,7 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n+        debug!(\"relate_free_regions(sub={}, sup={})\", sub, sup);\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n@@ -211,7 +211,7 @@ impl RegionMaps {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({}) = {:?}\", id, scope);\n+        debug!(\"var_region({}) = {}\", id, scope);\n         scope\n     }\n \n@@ -270,7 +270,7 @@ impl RegionMaps {\n          * duplicated with the code in infer.rs.\n          */\n \n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n+        debug!(\"is_subregion_of(sub_region={}, super_region={})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -802,7 +802,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               sp: Span,\n               id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={}, \\\n-                               span={:?}, \\\n+                               span={}, \\\n                                body.id={}, \\\n                                cx.parent={})\",\n            id,"}, {"sha": "0aff56ba3cfc5ac0c09992c820313986baab50cb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -94,6 +94,7 @@ pub type ExternalExports = DefIdSet;\n // FIXME: dox\n pub type LastPrivateMap = NodeMap<LastPrivate>;\n \n+#[deriving(Show)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),\n     // `use` directives (imports) can refer to two separate definitions in the\n@@ -107,13 +108,14 @@ pub enum LastPrivate {\n                pub type_used: ImportUse},\n }\n \n+#[deriving(Show)]\n pub enum PrivateDep {\n     AllPublic,\n     DependsOn(DefId),\n }\n \n // How an import is used.\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used.\n@@ -135,7 +137,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n enum Namespace {\n     TypeNS,\n     ValueNS\n@@ -576,7 +578,7 @@ struct TypeNsDef {\n }\n \n // Records a possibly-private value definition.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n struct ValueNsDef {\n     is_public: bool, // see note in ImportResolution about how to use this\n     def: Def,\n@@ -1761,7 +1763,7 @@ impl<'a> Resolver<'a> {\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {:?}\",\n+                external crate) building external def, priv {}\",\n                vis);\n         let is_public = vis == ast::Public;\n         let is_exported = is_public && match new_parent {\n@@ -1900,13 +1902,13 @@ impl<'a> Resolver<'a> {\n           }\n           DefMethod(..) => {\n               debug!(\"(building reduced graph for external crate) \\\n-                      ignoring {:?}\", def);\n+                      ignoring {}\", def);\n               // Ignored; handled elsewhere.\n           }\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n-            fail!(\"didn't expect `{:?}`\", def);\n+            fail!(\"didn't expect `{}`\", def);\n           }\n         }\n     }\n@@ -2420,7 +2422,7 @@ impl<'a> Resolver<'a> {\n                              lp: LastPrivate)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {:?}\",\n+                `{}` id {}, last private {}\",\n                token::get_ident(target),\n                self.module_to_string(&*containing_module),\n                token::get_ident(source),\n@@ -2522,7 +2524,7 @@ impl<'a> Resolver<'a> {\n                                     shadowable: _\n                                 }) => {\n                                     debug!(\"(resolving single import) found \\\n-                                            import in ns {:?}\", namespace);\n+                                            import in ns {}\", namespace);\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n@@ -2596,7 +2598,7 @@ impl<'a> Resolver<'a> {\n \n         match value_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found value target: {:?}\",\n+                debug!(\"(resolving single import) found value target: {}\",\n                        { name_bindings.value_def.borrow().clone().unwrap().def });\n                 self.check_for_conflicting_import(\n                     &import_resolution.value_target,\n@@ -2619,7 +2621,7 @@ impl<'a> Resolver<'a> {\n         }\n         match type_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n-                debug!(\"(resolving single import) found type target: {:?}\",\n+                debug!(\"(resolving single import) found type target: {}\",\n                        { name_bindings.type_def.borrow().clone().unwrap().type_def });\n                 self.check_for_conflicting_import(\n                     &import_resolution.type_target,\n@@ -2724,7 +2726,7 @@ impl<'a> Resolver<'a> {\n                                                   .borrow();\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n-                    {:?} into `{}`\",\n+                    {} into `{}`\",\n                    target_import_resolution.type_target.is_none(),\n                    self.module_to_string(module_));\n \n@@ -3305,7 +3307,7 @@ impl<'a> Resolver<'a> {\n                                      namespace: Namespace)\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n-                namespace {:?} in `{}`\",\n+                namespace {} in `{}`\",\n                token::get_ident(name),\n                namespace,\n                self.module_to_string(&*module_));\n@@ -3339,7 +3341,7 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         // Not found; continue.\n                         debug!(\"(resolving item in lexical scope) found \\\n-                                import resolution, but not in namespace {:?}\",\n+                                import resolution, but not in namespace {}\",\n                                namespace);\n                     }\n                     Some(target) => {\n@@ -3620,7 +3622,7 @@ impl<'a> Resolver<'a> {\n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n                         debug!(\"(resolving name in module) name found, \\\n-                                but not in namespace {:?}\",\n+                                but not in namespace {}\",\n                                namespace);\n                     }\n                     Some(target) => {\n@@ -3780,15 +3782,15 @@ impl<'a> Resolver<'a> {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n                 let name = token::get_name(name);\n-                debug!(\"(computing exports) YES: export '{}' => {:?}\",\n+                debug!(\"(computing exports) YES: export '{}' => {}\",\n                        name, d.def_id());\n                 exports2.push(Export2 {\n                     name: name.get().to_string(),\n                     def_id: d.def_id()\n                 });\n             }\n             d_opt => {\n-                debug!(\"(computing exports) NO: {:?}\", d_opt);\n+                debug!(\"(computing exports) NO: {}\", d_opt);\n             }\n         }\n     }\n@@ -4447,7 +4449,7 @@ impl<'a> Resolver<'a> {\n             Some(def) => {\n                 match def {\n                     (DefTrait(_), _) => {\n-                        debug!(\"(resolving trait) found trait def: {:?}\", def);\n+                        debug!(\"(resolving trait) found trait def: {}\", def);\n                         self.record_def(trait_reference.ref_id, def);\n                     }\n                     (def, _) => {\n@@ -4840,7 +4842,7 @@ impl<'a> Resolver<'a> {\n                         match self.resolve_path(ty.id, path, TypeNS, true) {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n-                                        type {:?}\",\n+                                        type {}\",\n                                        token::get_ident(path.segments\n                                                             .last().unwrap()\n                                                             .identifier),\n@@ -5124,7 +5126,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n-                                    def: {:?}\", result);\n+                                    def: {}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_idents_to_string(path));\n                             self.resolve_error(path.span, msg.as_slice());\n@@ -5148,7 +5150,7 @@ impl<'a> Resolver<'a> {\n                                                  ValueNS) {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n-                         finding {} at {:?}\",\n+                         finding {} at {}\",\n                         token::get_ident(name),\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n@@ -5489,7 +5491,7 @@ impl<'a> Resolver<'a> {\n         match search_result {\n             Some(DlDef(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `{}` to \\\n-                        local: {:?}\",\n+                        local: {}\",\n                        token::get_ident(ident),\n                        def);\n                 return Some(def);\n@@ -5840,7 +5842,7 @@ impl<'a> Resolver<'a> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n-                                def: {:?}\", result);\n+                                def: {}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_idents_to_string(path));\n                         self.resolve_error(path.span, msg.as_slice());\n@@ -6026,7 +6028,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n-        debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n+        debug!(\"(recording def) recording {} for {}, last private {}\",\n                 def, node_id, lp);\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n@@ -6038,8 +6040,8 @@ impl<'a> Resolver<'a> {\n             // the same conclusion! - nmatsakis\n             Occupied(entry) => if def != *entry.get() {\n                 self.session\n-                    .bug(format!(\"node_id {:?} resolved first to {:?} and \\\n-                                  then {:?}\",\n+                    .bug(format!(\"node_id {} resolved first to {} and \\\n+                                  then {}\",\n                                  node_id,\n                                  *entry.get(),\n                                  def).as_slice());"}, {"sha": "6f517f1f166b9a4be37e441e946cb5ef106c0088", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -57,6 +57,7 @@ struct LifetimeContext<'a> {\n     scope: Scope<'a>\n }\n \n+#[deriving(Show)]\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n@@ -118,10 +119,10 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         };\n \n         self.with(|_, f| f(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE)), |v| {\n-            debug!(\"entering scope {:?}\", v.scope);\n+            debug!(\"entering scope {}\", v.scope);\n             v.check_lifetime_defs(lifetimes);\n             visit::walk_item(v, item);\n-            debug!(\"exiting scope {:?}\", v.scope);\n+            debug!(\"exiting scope {}\", v.scope);\n         });\n     }\n \n@@ -268,7 +269,7 @@ impl<'a> LifetimeContext<'a> {\n \n         let referenced_idents = early_bound_lifetime_names(generics);\n         debug!(\"pushing fn scope id={} due to fn item/method\\\n-               referenced_idents={:?}\",\n+               referenced_idents={}\",\n                n,\n                referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n         let lifetimes = &generics.lifetimes;\n@@ -439,7 +440,7 @@ impl<'a> LifetimeContext<'a> {\n                                probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={} id={} resolved to {:?}\",\n+        debug!(\"lifetime_ref={} id={} resolved to {}\",\n                 lifetime_to_string(lifetime_ref),\n                 lifetime_ref.id,\n                 def);"}, {"sha": "9dfde7ec08415ab337f40b78edf4318153dd1752", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -246,7 +246,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n                                                  def).as_slice());\n             },\n         }\n@@ -313,7 +313,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 },\n                 _ => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Container {} for method {} is not a node item {:?}\",\n+                                       format!(\"Container {} for method {} is not a node item {}\",\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n@@ -1415,7 +1415,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // FIXME(nrc) what is this doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                _ => error!(\"unexpected definition kind when processing collected paths: {}\",\n                             *def)\n             }\n         }"}, {"sha": "c31a3730a7c36969b834367cc078bb084cbdd234", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -226,6 +226,7 @@ use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n \n+#[deriving(Show)]\n struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n@@ -240,6 +241,7 @@ impl<'a> ConstantExpr<'a> {\n }\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n+#[deriving(Show)]\n enum Opt<'a> {\n     ConstantValue(ConstantExpr<'a>),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n@@ -519,7 +521,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              variant_size: uint,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n-    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={}, opt={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -863,7 +865,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             _ => {}\n         }\n \n-        debug!(\"binding {:?} to {}\",\n+        debug!(\"binding {} to {}\",\n                binding_info.id,\n                bcx.val_to_string(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n@@ -1048,7 +1050,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Decide what kind of branch we need\n     let opts = get_branches(bcx, m, col);\n-    debug!(\"options={:?}\", opts);\n+    debug!(\"options={}\", opts);\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));"}, {"sha": "2f06f16ace1311cefea3e752e579e4bf4a8a07a9", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -74,7 +74,7 @@ type Hint = attr::ReprAttr;\n \n \n /// Representations.\n-#[deriving(Eq, PartialEq)]\n+#[deriving(Eq, PartialEq, Show)]\n pub enum Repr {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n@@ -127,7 +127,7 @@ pub enum Repr {\n }\n \n /// For structs, and struct-like parts of anything fancier.\n-#[deriving(Eq, PartialEq)]\n+#[deriving(Eq, PartialEq, Show)]\n pub struct Struct {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n@@ -156,7 +156,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n-    debug!(\"Represented as: {:?}\", repr)\n+    debug!(\"Represented as: {}\", repr)\n     cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }\n@@ -371,6 +371,7 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     }\n }\n \n+#[deriving(Show)]\n struct IntBounds {\n     slo: i64,\n     shi: i64,\n@@ -387,7 +388,7 @@ fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n }\n \n fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n-    debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n+    debug!(\"range_to_inttype: {} {}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     #[allow(non_uppercase_statics)]\n     static choose_shortest: &'static[IntType] = &[\n@@ -440,7 +441,7 @@ pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n }\n \n fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n-    debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n+    debug!(\"bounds_usable: {} {}\", ity, bounds);\n     match ity {\n         attr::SignedInt(_) => {\n             let lllo = C_integral(ll_inttype(cx, ity), bounds.slo as u64, true);\n@@ -538,7 +539,7 @@ fn generic_type_of(cx: &CrateContext,\n                                  Type::array(&Type::i64(cx), align_units),\n                 a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n-                _ => fail!(\"unsupported enum alignment: {:?}\", align)\n+                _ => fail!(\"unsupported enum alignment: {}\", align)\n             };\n             assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n             assert_eq!(align % discr_size, 0);"}, {"sha": "f4586fca52fd6abd9cdbe95cf0d8b25d20f69ee3", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -101,7 +101,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         constraints.push_str(clobbers.as_slice());\n     }\n \n-    debug!(\"Asm Constraints: {:?}\", constraints.as_slice());\n+    debug!(\"Asm Constraints: {}\", constraints.as_slice());\n \n     let num_outputs = outputs.len();\n "}, {"sha": "c5b0e10f0936994651d3b0c57603ec063ef6f07c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -1088,7 +1088,7 @@ pub fn ignore_lhs(_bcx: Block, local: &ast::Local) -> bool {\n \n pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &ast::Local)\n                               -> Block<'blk, 'tcx> {\n-    debug!(\"init_local(bcx={}, local.id={:?})\", bcx.to_str(), local.id);\n+    debug!(\"init_local(bcx={}, local.id={})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"init_local\");\n     _match::store_local(bcx, local)\n@@ -2672,7 +2672,7 @@ fn contains_null(s: &str) -> bool {\n }\n \n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug!(\"get_item_val(id=`{:?}`)\", id);\n+    debug!(\"get_item_val(id=`{}`)\", id);\n \n     match ccx.item_vals().borrow().find_copy(&id) {\n         Some(v) => return v,\n@@ -2857,7 +2857,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         }\n \n         ref variant => {\n-            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n+            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n                                    variant).as_slice())\n         }\n     };"}, {"sha": "dbc668a04bac9798a7459de86c957420d8ad8dae", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -795,11 +795,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n-            debug!(\"Asm Input Type: {:?}\", self.ccx.tn().val_to_string(*v));\n+            debug!(\"Asm Input Type: {}\", self.ccx.tn().val_to_string(*v));\n             val_ty(*v)\n         }).collect::<Vec<_>>();\n \n-        debug!(\"Asm Output Type: {:?}\", self.ccx.tn().type_to_string(output));\n+        debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n         let fty = Type::func(argtys.as_slice(), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm("}, {"sha": "f607dfdd17f49b3881938f620fbac7664e74005a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -209,7 +209,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefSelfTy(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    format!(\"cannot translate def {:?} \\\n+                    format!(\"cannot translate def {} \\\n                              to a callable thing!\", def).as_slice());\n             }\n         }\n@@ -226,7 +226,7 @@ pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> V\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = node_id_substs(bcx, node);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n+    debug!(\"trans_fn_ref(def_id={}, node={}, substs={})\",\n            def_id.repr(bcx.tcx()),\n            node,\n            substs.repr(bcx.tcx()));\n@@ -398,7 +398,7 @@ pub fn trans_fn_ref_with_substs(\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={:?}, \\\n+    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={}, \\\n             substs={})\",\n            bcx.to_str(),\n            def_id.repr(tcx),"}, {"sha": "9edca215aef8df1773a75d878f2f7c84e39a5240", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -23,6 +23,7 @@ use middle::trans::debuginfo;\n use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n+use std::fmt;\n use syntax::ast;\n use util::ppaux::Repr;\n \n@@ -45,6 +46,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n \n+#[deriving(Show)]\n pub struct CustomScopeIndex {\n     index: uint\n }\n@@ -59,7 +61,23 @@ pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>, ..EXIT_MAX])\n }\n \n-#[deriving(PartialEq)]\n+impl<'blk, 'tcx: 'blk> fmt::Show for CleanupScopeKind<'blk, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::FormatError> {\n+        match *self {\n+            CustomScopeKind => write!(f, \"CustomScopeKind\"),\n+            AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),\n+            LoopScopeKind(nid, ref blks) => {\n+                try!(write!(f, \"LoopScopeKind({}, [\", nid));\n+                for blk in blks.iter() {\n+                    try!(write!(f, \"{:p}, \", blk));\n+                }\n+                write!(f, \"])\")\n+            }\n+        }\n+    }\n+}\n+\n+#[deriving(PartialEq, Show)]\n pub enum EarlyExitLabel {\n     UnwindExit,\n     ReturnExit,\n@@ -83,6 +101,7 @@ pub trait Cleanup {\n \n pub type CleanupObj = Box<Cleanup+'static>;\n \n+#[deriving(Show)]\n pub enum ScopeId {\n     AstScope(ast::NodeId),\n     CustomScope(CustomScopeIndex)\n@@ -222,7 +241,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n          * cleanups for normal exit.\n          */\n \n-        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n+        debug!(\"pop_and_trans_custom_cleanup_scope({})\", custom_scope);\n         assert!(self.is_valid_to_pop_custom_scope(custom_scope));\n \n         let scope = self.pop_scope();\n@@ -273,7 +292,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ptr: val,\n         };\n \n-        debug!(\"schedule_lifetime_end({:?}, val={})\",\n+        debug!(\"schedule_lifetime_end({}, val={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val));\n \n@@ -298,7 +317,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -324,7 +343,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: true\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_and_zero_mem({}, val={}, ty={}, zero={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n@@ -350,7 +369,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             zero: false\n         };\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_immediate({}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()));\n@@ -370,7 +389,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n-        debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n+        debug!(\"schedule_free_value({}, val={}, heap={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -391,7 +410,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n \n-        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n+        debug!(\"schedule_free_slice({}, val={}, heap={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                heap);\n@@ -417,7 +436,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n          * in the topmost scope, which must be a temporary scope.\n          */\n \n-        debug!(\"schedule_clean_in_ast_scope(cleanup_scope={:?})\",\n+        debug!(\"schedule_clean_in_ast_scope(cleanup_scope={})\",\n                cleanup_scope);\n \n         for scope in self.scopes.borrow_mut().iter_mut().rev() {\n@@ -598,7 +617,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n          * perform all cleanups and finally branch to the `break_blk`.\n          */\n \n-        debug!(\"trans_cleanups_to_exit_scope label={:?} scopes={}\",\n+        debug!(\"trans_cleanups_to_exit_scope label={} scopes={}\",\n                label, self.scopes_len());\n \n         let orig_scopes_len = self.scopes_len();\n@@ -634,7 +653,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n-                                \"cannot exit from scope {:?}, \\\n+                                \"cannot exit from scope {}, \\\n                                 not in scope\", id).as_slice());\n                     }\n                 }\n@@ -968,6 +987,7 @@ impl Cleanup for DropValue {\n     }\n }\n \n+#[deriving(Show)]\n pub enum Heap {\n     HeapExchange\n }\n@@ -1072,7 +1092,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n             let r = AstScope(scope);\n-            debug!(\"temporary_scope({}) = {:?}\", id, r);\n+            debug!(\"temporary_scope({}) = {}\", id, r);\n             r\n         }\n         None => {\n@@ -1086,7 +1106,7 @@ pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id));\n-    debug!(\"var_scope({}) = {:?}\", id, r);\n+    debug!(\"var_scope({}) = {}\", id, r);\n     r\n }\n "}, {"sha": "8f877f981c8d920f19866ea16f88dde23ab9890e", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -550,7 +550,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a statically resolved fn, got \\\n-                                    {:?}\",\n+                                    {}\",\n                                     def).as_slice());\n         }\n     };"}, {"sha": "8f0ea7a85d433d5f496a09d838112849a32c1b4e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -468,7 +468,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {:?}\", nid).as_slice());\n+                    \"no def associated with node id {}\", nid).as_slice());\n             }\n         }\n     }\n@@ -704,7 +704,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n     unsafe {\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n+        debug!(\"const_get_elt(v={}, us={}, r={})\",\n                cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n         return r;\n@@ -865,7 +865,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum ExprOrMethodCall {\n     // Type parameters for a path like `None::<int>`\n     ExprId(ast::NodeId),\n@@ -891,7 +891,7 @@ pub fn node_id_substs(bcx: Block,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            format!(\"type parameters for node {:?} include inference types: \\\n+            format!(\"type parameters for node {} include inference types: \\\n                      {}\",\n                     node,\n                     substs.repr(bcx.tcx())).as_slice());"}, {"sha": "d83c46be14ab8aa8820498dd94e14d7f0ea3e6e0", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -210,7 +210,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                 ty::AdjustAddEnv(store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n-                                format!(\"unexpected static function: {:?}\",\n+                                format!(\"unexpected static function: {}\",\n                                         store).as_slice())\n                 }\n                 ty::AdjustDerefRef(ref adj) => {\n@@ -279,7 +279,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                                     cx.sess()\n                                       .span_bug(e.span,\n                                                 format!(\"unimplemented const \\\n-                                                         autoref {:?}\",\n+                                                         autoref {}\",\n                                                         autoref).as_slice())\n                                 }\n                             }"}, {"sha": "fe9f832e44a186914fe862326174e39bb2544570", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -138,7 +138,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             els: Option<&ast::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n-    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n+    debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={}, dest={})\",\n            bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n            dest.to_string(bcx.ccx()));\n     let _icx = push_ctxt(\"trans_if\");\n@@ -429,7 +429,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().find(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n-                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n+                    bcx.tcx().sess.bug(format!(\"{} in def-map for label\",\n                                                r).as_slice())\n                 }\n             }"}, {"sha": "ea6d9e1dd8c48a61a93ae7618934948e66aa5cd9", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -25,6 +25,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::{ty_to_string};\n \n+use std::fmt;\n use syntax::ast;\n \n /**\n@@ -51,6 +52,7 @@ pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n     pub datum: Datum<K>,\n }\n \n+#[deriving(Show)]\n pub enum Expr {\n     /// a fresh value that was produced and which has no cleanup yet\n     /// because it has not yet \"landed\" into its permanent home\n@@ -62,9 +64,10 @@ pub enum Expr {\n     LvalueExpr,\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct Lvalue;\n \n+#[deriving(Show)]\n pub struct Rvalue {\n     pub mode: RvalueMode\n }\n@@ -80,7 +83,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,\n@@ -539,7 +542,7 @@ impl Datum<Lvalue> {\n /**\n  * Generic methods applicable to any sort of datum.\n  */\n-impl<K:KindOps> Datum<K> {\n+impl<K: KindOps + fmt::Show> Datum<K> {\n     pub fn new(val: ValueRef, ty: ty::t, kind: K) -> Datum<K> {\n         Datum { val: val, ty: ty, kind: kind }\n     }\n@@ -615,7 +618,7 @@ impl<K:KindOps> Datum<K> {\n \n     #[allow(dead_code)] // useful for debugging\n     pub fn to_string(&self, ccx: &CrateContext) -> String {\n-        format!(\"Datum({}, {}, {:?})\",\n+        format!(\"Datum({}, {}, {})\",\n                 ccx.tn().val_to_string(self.val),\n                 ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)\n@@ -658,7 +661,7 @@ impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n     }\n }\n \n-impl<'blk, 'tcx, K:KindOps> DatumBlock<'blk, 'tcx, K> {\n+impl<'blk, 'tcx, K: KindOps + fmt::Show> DatumBlock<'blk, 'tcx, K> {\n     pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n         DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }"}, {"sha": "4e3eaf26f42e8993bfb163cc5ded32cb70cc02c8", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -468,7 +468,7 @@ impl TypeMap {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n+                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n                                       ppaux::ty_to_string(cx.tcx(), type_).as_slice(),\n                                       ty::get(type_).sty).as_slice())\n             }\n@@ -783,14 +783,14 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                 format!(\"debuginfo::\\\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n-                                         unexpected ast_item variant: {:?}\",\n+                                         unexpected ast_item variant: {}\",\n                                         var_item).as_slice())\n                 }\n             }\n         },\n         _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n-                                    ast_map variant: {:?}\",\n+                                    ast_map variant: {}\",\n                                    var_item).as_slice())\n     };\n \n@@ -846,7 +846,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {:?}\",\n+                    format!(\"no entry in lllocals table for {}\",\n                             node_id).as_slice());\n             }\n         };\n@@ -896,7 +896,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n                                 format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n-                                 ast_map variant: {:?}\",\n+                                 ast_map variant: {}\",\n                                  ast_item).as_slice());\n                 }\n             }\n@@ -906,7 +906,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n               .span_bug(span,\n                         format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n-                                 ast_map variant: {:?}\",\n+                                 ast_map variant: {}\",\n                                 ast_item).as_slice());\n         }\n     };\n@@ -1009,7 +1009,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {:?}\",\n+                    format!(\"no entry in lllocals table for {}\",\n                             node_id).as_slice());\n             }\n         };\n@@ -1250,7 +1250,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 _ => {\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n+                                    unexpected sort of node: {}\",\n                                     fnitem).as_slice())\n                 }\n             }\n@@ -1261,7 +1261,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n+                                    unexpected sort of node: {}\",\n                                    fnitem).as_slice())\n     };\n \n@@ -1542,7 +1542,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n         }\n     };\n \n-    debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n+    debug!(\"compile_unit_metadata: {}\", compile_unit_name);\n     let producer = format!(\"rustc version {}\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n@@ -1703,15 +1703,15 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n-                format!(\"debuginfo: Could not find scope info for node {:?}\",\n+                format!(\"debuginfo: Could not find scope info for node {}\",\n                         node).as_slice());\n         }\n     }\n }\n \n fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n \n-    debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n+    debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil => (\"()\".to_string(), DW_ATE_unsigned),\n@@ -2855,7 +2855,7 @@ fn type_metadata(cx: &CrateContext,\n         }\n     };\n \n-    debug!(\"type_metadata: {:?}\", ty::get(t));\n+    debug!(\"type_metadata: {}\", ty::get(t));\n \n     let sty = &ty::get(t).sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n@@ -2937,7 +2937,7 @@ fn type_metadata(cx: &CrateContext,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n+            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {}\",\n                                   sty).as_slice())\n         }\n     };\n@@ -3991,7 +3991,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             Some(node) => node,\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n-                                       path too short for {:?}\",\n+                                       path too short for {}\",\n                                       def_id).as_slice());\n             }\n         }"}, {"sha": "bcbc9fff834da2eb5dabe4401da8b843faea295e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -666,7 +666,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n-                         fall-through case: {:?}\",\n+                         fall-through case: {}\",\n                         expr.node).as_slice());\n         }\n     }\n@@ -982,7 +982,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n-                         fall-through case: {:?}\",\n+                         fall-through case: {}\",\n                         expr.node).as_slice());\n         }\n     }\n@@ -1128,7 +1128,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n-                         case: {:?}\",\n+                         case: {}\",\n                         expr.node).as_slice());\n         }\n     }\n@@ -1176,7 +1176,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n-                \"Non-DPS def {:?} referened by {}\",\n+                \"Non-DPS def {} referened by {}\",\n                 def, bcx.node_id_to_string(ref_expr.id)).as_slice());\n         }\n     }\n@@ -1200,7 +1200,7 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n-                    \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n+                    \"trans_def_fn_unadjusted invoked on: {} for {}\",\n                     def,\n                     ref_expr.repr(bcx.tcx())).as_slice());\n         }\n@@ -1228,7 +1228,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n-                        \"trans_local_var: no llval for upvar {:?} found\",\n+                        \"trans_local_var: no llval for upvar {} found\",\n                         nid).as_slice());\n                 }\n             }\n@@ -1238,17 +1238,17 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&v) => v,\n                 None => {\n                     bcx.sess().bug(format!(\n-                        \"trans_local_var: no datum for local/arg {:?} found\",\n+                        \"trans_local_var: no datum for local/arg {} found\",\n                         nid).as_slice());\n                 }\n             };\n-            debug!(\"take_local(nid={:?}, v={}, ty={})\",\n+            debug!(\"take_local(nid={}, v={}, ty={})\",\n                    nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n             datum\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n-                \"unsupported def type in trans_local_var: {:?}\",\n+                \"unsupported def type in trans_local_var: {}\",\n                 def).as_slice());\n         }\n     }\n@@ -1869,7 +1869,7 @@ fn float_cast(bcx: Block,\n     } else { llsrc };\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(PartialEq, Show)]\n pub enum cast_kind {\n     cast_pointer,\n     cast_integral,\n@@ -1981,7 +1981,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n                 _ => {\n                     ccx.sess().bug(format!(\"translating unsupported cast: \\\n-                                            {} ({:?}) -> {} ({:?})\",\n+                                            {} ({}) -> {} ({})\",\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n@@ -1990,7 +1990,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n-                                    {} ({:?}) -> {} ({:?})\",\n+                                    {} ({}) -> {} ({})\",\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),"}, {"sha": "cc28b8032087f004b09e0c54d6019a9265add49d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -474,7 +474,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n             let llalign = cmp::min(llforeign_align, llrust_align);\n-            debug!(\"llrust_size={:?}\", llrust_size);\n+            debug!(\"llrust_size={}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n                               C_uint(ccx, llrust_size as uint), llalign as u32);\n         }\n@@ -576,7 +576,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     };\n     let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n     add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n+    debug!(\"register_rust_fn_with_foreign_abi(node_id={}, llfn_ty={}, llfn={})\",\n            node_id, ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n     llfn\n }"}, {"sha": "0b3f1c9840c4ad2b193eda0a01f5ac78cb284b1a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -60,7 +60,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     let _icx = push_ctxt(\"meth::trans_impl\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_impl(name={}, id={:?})\", name.repr(tcx), id);\n+    debug!(\"trans_impl(name={}, id={})\", name.repr(tcx), id);\n \n     // Both here and below with generic methods, be sure to recurse and look for\n     // items that we need to translate.\n@@ -174,8 +174,8 @@ pub fn trans_static_method_callee(bcx: Block,\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n-            expr_id={:?})\",\n+    debug!(\"trans_static_method_callee(method_id={}, trait_id={}, \\\n+            expr_id={})\",\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n            expr_id);"}, {"sha": "258d12e631f2fb1a8f741b4d86c56df542476bb9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -38,7 +38,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n-            ref_id={:?})\",\n+            ref_id={})\",\n            fn_id.repr(ccx.tcx()),\n            real_substs.repr(ccx.tcx()),\n            ref_id);\n@@ -70,7 +70,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             psubsts={}, \\\n-            hash_id={:?})\",\n+            hash_id={})\",\n            fn_id.repr(ccx.tcx()),\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n@@ -82,7 +82,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ccx.sess(),\n         ccx.tcx().map.find(fn_id.node),\n         || {\n-            format!(\"while monomorphizing {:?}, couldn't find it in \\\n+            format!(\"while monomorphizing {}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n                      an item defined in a different crate?)\",\n                     fn_id)\n@@ -247,7 +247,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                     d\n                 }\n                 _ => {\n-                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+                    ccx.sess().bug(format!(\"can't monomorphize a {}\",\n                                            map_node).as_slice())\n                 }\n             }\n@@ -273,7 +273,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+            ccx.sess().bug(format!(\"can't monomorphize a {}\",\n                                    map_node).as_slice())\n         }\n     };\n@@ -284,7 +284,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, true)\n }\n \n-#[deriving(PartialEq, Eq, Hash)]\n+#[deriving(PartialEq, Eq, Hash, Show)]\n pub struct MonoId {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<ty::t>"}, {"sha": "a404d9d221ec1f6ce5c34cd1956a15b9cabb300e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -118,7 +118,7 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug!(\"trans_fixed_vstore(expr={}, dest={:?})\",\n+    debug!(\"trans_fixed_vstore(expr={}, dest={})\",\n            bcx.expr_to_string(expr), dest.to_string(bcx.ccx()));\n \n     let vt = vec_types_from_expr(bcx, expr);\n@@ -175,7 +175,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n+    debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n     let llcount = C_uint(ccx, count);\n \n     let fixed_ty = ty::mk_vec(bcx.tcx(),\n@@ -249,7 +249,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n+    debug!(\"write_content(vt={}, dest={}, vstore_expr={})\",\n            vt.to_string(bcx.ccx()),\n            dest.to_string(bcx.ccx()),\n            bcx.expr_to_string(vstore_expr));\n@@ -291,7 +291,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let temp_scope = fcx.push_custom_cleanup_scope();\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n-                        debug!(\"writing index {:?} with lleltptr={:?}\",\n+                        debug!(\"writing index {} with lleltptr={}\",\n                                i, bcx.val_to_string(lleltptr));\n                         bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));"}, {"sha": "e723d5af89cc4a0ca5a2e331dcae9338d57d3992", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -253,7 +253,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         None => ()\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), ty::get(t).sty);\n+    debug!(\"type_of {} {}\", t.repr(cx.tcx()), ty::get(t).sty);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -264,7 +264,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n-        debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n+        debug!(\"--> normalized {} {} to {} {} llty={}\",\n                 t.repr(cx.tcx()),\n                 t,\n                 t_norm.repr(cx.tcx()),\n@@ -378,7 +378,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };\n \n-    debug!(\"--> mapped t={} {:?} to llty={}\",\n+    debug!(\"--> mapped t={} {} to llty={}\",\n             t.repr(cx.tcx()),\n             t,\n             cx.tn().type_to_string(llty));"}, {"sha": "d026b31b914f07ae59ce14ffc8453986bd45418a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -70,7 +70,7 @@ pub struct field {\n     pub mt: mt\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n@@ -138,7 +138,7 @@ impl ImplOrTraitItemId {\n     }\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct Method {\n     pub ident: ast::Ident,\n     pub generics: ty::Generics,\n@@ -268,13 +268,13 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum AutoAdjustment {\n     AdjustAddEnv(ty::TraitStore),\n     AdjustDerefRef(AutoDerefRef)\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum UnsizeKind {\n     // [T, ..n] -> [T], the uint field is n.\n     UnsizeLength(uint),\n@@ -284,13 +284,13 @@ pub enum UnsizeKind {\n     UnsizeVtable(TyTrait, /* the self type of the trait */ ty::t)\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct AutoDerefRef {\n     pub autoderefs: uint,\n     pub autoref: Option<AutoRef>\n }\n \n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     /// The third field allows us to wrap other AutoRef adjustments.\n@@ -726,7 +726,7 @@ pub enum Region {\n  * the original var id (that is, the root variable that is referenced\n  * by the upvar) and the id of the closure expression.\n  */\n-#[deriving(Clone, PartialEq, Eq, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n@@ -827,7 +827,7 @@ pub enum BorrowKind {\n  *   the closure, so sometimes it is necessary for them to be larger\n  *   than the closure lifetime itself.\n  */\n-#[deriving(PartialEq, Clone, Encodable, Decodable)]\n+#[deriving(PartialEq, Clone, Encodable, Decodable, Show)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,\n@@ -1434,7 +1434,7 @@ pub struct UnboxedClosure {\n     pub kind: UnboxedClosureKind,\n }\n \n-#[deriving(Clone, PartialEq, Eq)]\n+#[deriving(Clone, PartialEq, Eq, Show)]\n pub enum UnboxedClosureKind {\n     FnUnboxedClosureKind,\n     FnMutUnboxedClosureKind,\n@@ -3133,7 +3133,7 @@ pub fn fn_is_variadic(fty: t) -> bool {\n         ty_bare_fn(ref f) => f.sig.variadic,\n         ty_closure(ref f) => f.sig.variadic,\n         ref s => {\n-            fail!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n+            fail!(\"fn_is_variadic() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3143,7 +3143,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n-            fail!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_sig() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3163,7 +3163,7 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n-            fail!(\"ty_fn_args() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_args() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3177,7 +3177,7 @@ pub fn ty_closure_store(fty: t) -> TraitStore {\n             UniqTraitStore\n         }\n         ref s => {\n-            fail!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n+            fail!(\"ty_closure_store() called on non-closure type: {}\", s)\n         }\n     }\n }\n@@ -3187,7 +3187,7 @@ pub fn ty_fn_ret(fty: t) -> t {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n-            fail!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_ret() called on non-fn type: {}\", s)\n         }\n     }\n }\n@@ -3208,7 +3208,7 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n+                format!(\"ty_region() invoked on an inappropriate ty: {}\",\n                         s).as_slice());\n         }\n     }\n@@ -3272,7 +3272,7 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n             e.span\n         }\n         Some(f) => {\n-            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n+            cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n                                 id,\n                                 f).as_slice());\n         }\n@@ -3292,14 +3292,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 }\n                 _ => {\n                     cx.sess.bug(\n-                        format!(\"Variable id {} maps to {:?}, not local\",\n+                        format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n                                 pat).as_slice());\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n+            cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n                                 r).as_slice());\n         }\n@@ -3343,7 +3343,7 @@ pub fn adjust_ty(cx: &ctxt,\n                         ref b => {\n                             cx.sess.bug(\n                                 format!(\"add_env adjustment on non-bare-fn: \\\n-                                         {:?}\",\n+                                         {}\",\n                                         b).as_slice());\n                         }\n                     }\n@@ -3456,7 +3456,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {:?}\", expr.id).as_slice());\n+                \"no def-map entry for expr {}\", expr.id).as_slice());\n         }\n     }\n }\n@@ -3547,7 +3547,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        format!(\"uncategorized def for expr {:?}: {:?}\",\n+                        format!(\"uncategorized def for expr {}: {}\",\n                                 expr.id,\n                                 def).as_slice());\n                 }\n@@ -3671,7 +3671,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n     tcx.sess.bug(format!(\n-        \"no field named `{}` found in the list of fields `{:?}`\",\n+        \"no field named `{}` found in the list of fields `{}`\",\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_ident(f.ident).get().to_string())\n@@ -3965,7 +3965,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     }\n \n     if def_id.krate == ast::LOCAL_CRATE {\n-        fail!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n+        fail!(\"No def'n found for {} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -4083,7 +4083,7 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n-            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n+            debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n             match cx.map.find(id.node) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n@@ -5418,7 +5418,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n }\n \n /// The category of explicit self.\n-#[deriving(Clone, Eq, PartialEq)]\n+#[deriving(Clone, Eq, PartialEq, Show)]\n pub enum ExplicitSelfCategory {\n     StaticExplicitSelfCategory,\n     ByValueExplicitSelfCategory,"}, {"sha": "0e9d255adf9daf1ba8be33a359398b328104fad0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -961,7 +961,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n-                                                     as a type: {:?}\",\n+                                                     as a type: {}\",\n                                                     a_def).as_slice());\n                     }\n                 }"}, {"sha": "9463bafc9d277b70d21ad9e95905a73cb6e265a0", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -442,8 +442,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**begin));\n         let e_ty =\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(&**end));\n-        debug!(\"pat_range beginning type: {:?}\", b_ty);\n-        debug!(\"pat_range ending type: {:?}\", e_ty);\n+        debug!(\"pat_range beginning type: {}\", b_ty);\n+        debug!(\"pat_range ending type: {}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n             || \"mismatched types in range\".to_string())"}, {"sha": "c2e7be2781fd6d073af52be163149e14f5ae10f9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -643,7 +643,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                                            rcvr_ty: ty::t,\n                                            restrict_to: Option<DefId>,\n                                            param_ty: ParamTy) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n+        debug!(\"push_inherent_candidates_from_param(param_ty={})\",\n                param_ty);\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     }\n                 }\n                 None => {\n-                    debug!(\"trait doesn't contain method: {:?}\",\n+                    debug!(\"trait doesn't contain method: {}\",\n                         bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n@@ -873,7 +873,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             None => None,\n             Some(method) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {:?} for {}\", adjustment, self.ty_to_string(self_ty));\n+                       adjustment {} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n                     Some((self_expr_id, adj)) => {\n                         self.fcx.write_adjustment(self_expr_id, self.span, adj);\n@@ -1759,7 +1759,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, \\\n-                 origin={:?})\",\n+                 origin={})\",\n                 self.rcvr_match_condition.repr(tcx),\n                 self.rcvr_substs.repr(tcx),\n                 self.method_ty.repr(tcx),"}, {"sha": "c8318825e705450d1c56f2ecf96951a441b8579a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -1563,7 +1563,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"no type for local variable {:?}\",\n+                    format!(\"no type for local variable {}\",\n                             nid).as_slice());\n             }\n         }\n@@ -1622,7 +1622,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             node_id: ast::NodeId,\n                             span: Span,\n                             adj: ty::AutoAdjustment) {\n-        debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n+        debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj);\n \n         // Careful: adjustments can imply trait obligations if we are\n         // casting from a concrete type to an object type. I think\n@@ -1673,7 +1673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn register_unsize_obligations(&self,\n                                    span: Span,\n                                    unsize: &ty::UnsizeKind) {\n-        debug!(\"register_unsize_obligations: unsize={:?}\", unsize);\n+        debug!(\"register_unsize_obligations: unsize={}\", unsize);\n \n         match *unsize {\n             ty::UnsizeLength(..) => {}\n@@ -2551,7 +2551,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n         err_args(supplied_arg_count)\n     };\n \n-    debug!(\"check_argument_types: formal_tys={:?}\",\n+    debug!(\"check_argument_types: formal_tys={}\",\n            formal_tys.iter().map(|t| fcx.infcx().ty_to_string(*t)).collect::<Vec<String>>());\n \n     // Check the arguments."}, {"sha": "b810ea3d94de613d17dd276126ef85173bbe8d3d", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -239,7 +239,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n+            tcx.sess.bug(format!(\"unexpected def in region_of_def: {}\",\n                                  def).as_slice())\n         }\n     }\n@@ -560,7 +560,7 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n-    debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n+    debug!(\"regionck::visit_expr(e={}, repeating_scope={})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     // No matter what, the type of each expression must outlive the\n@@ -575,7 +575,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n     // Check any autoderefs or autorefs that appear.\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n-        debug!(\"adjustment={:?}\", adjustment);\n+        debug!(\"adjustment={}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n@@ -978,7 +978,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         debug!(\"constrain_free_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n-            debug!(\"freevar def is {:?}\", freevar.def);\n+            debug!(\"freevar def is {}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n@@ -1116,7 +1116,7 @@ fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     debug!(\"constrain_call(call_expr={}, \\\n             receiver={}, \\\n-            implicitly_ref_args={:?})\",\n+            implicitly_ref_args={})\",\n             call_expr.repr(tcx),\n             receiver.repr(tcx),\n             implicitly_ref_args);\n@@ -1171,7 +1171,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n      */\n     let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n+        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={}/{}\",\n                rcx.fcx.infcx().ty_to_string(derefd_ty),\n                i, derefs);\n \n@@ -1280,7 +1280,7 @@ fn type_of_node_must_outlive(\n                            rcx.fcx.inh.adjustments.borrow().find(&id),\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n+            ty={}, ty0={}, id={}, minimum_lifetime={})\",\n            ty_to_string(tcx, ty), ty_to_string(tcx, ty0),\n            id, minimum_lifetime);\n     type_must_outlive(rcx, origin, ty, minimum_lifetime);\n@@ -1381,7 +1381,7 @@ fn link_autoref(rcx: &Rcx,\n      * to lifetimes in the value being autoref'd.\n      */\n \n-    debug!(\"link_autoref(autoref={:?})\", autoref);\n+    debug!(\"link_autoref(autoref={})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n@@ -1779,7 +1779,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n      * this function.\n      */\n \n-    debug!(\"link_upvar_borrow_kind: inner_upvar_id={:?} outer_upvar_id={:?}\",\n+    debug!(\"link_upvar_borrow_kind: inner_upvar_id={} outer_upvar_id={}\",\n            inner_upvar_id, outer_upvar_id);\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n@@ -1795,7 +1795,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n                                      upvar_borrow: &mut ty::UpvarBorrow,\n                                      kind: ty::BorrowKind) {\n-    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={:?} kind={:?} -> {:?}\",\n+    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={} kind={} -> {}\",\n            upvar_id, upvar_borrow.kind, kind);\n \n     adjust_upvar_borrow_kind(upvar_id, upvar_borrow, kind)\n@@ -1812,7 +1812,7 @@ fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n      * is required by some particular use.\n      */\n \n-    debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n+    debug!(\"adjust_upvar_borrow_kind: id={} kind=({} -> {})\",\n            upvar_id, upvar_borrow.kind, kind);\n \n     match (upvar_borrow.kind, kind) {"}, {"sha": "56dec61d4102e054a2c596659527199c2fdb87a8", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -306,7 +306,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         })\n                     }\n                 };\n-                debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n+                debug!(\"Adjustments for node {}: {}\", id, resolved_adjustment);\n                 self.tcx().adjustments.borrow_mut().insert(\n                     id, resolved_adjustment);\n             }\n@@ -319,7 +319,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // Resolve any method map entry\n         match self.fcx.inh.method_map.borrow_mut().pop(&method_call) {\n             Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={})\",\n+                debug!(\"writeback::resolve_method_map_entry(call={}, entry={})\",\n                        method_call,\n                        method.repr(self.tcx()));\n                 let new_method = MethodCallee {"}, {"sha": "eef466ceebb9f35be39dd9c8ccf39fe99d025fa3", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -86,7 +86,7 @@ fn get_base_type(inference_context: &InferCtxt,\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {\n-            debug!(\"(getting base type) no base type; found {:?}\",\n+            debug!(\"(getting base type) no base type; found {}\",\n                    get(original_type).sty);\n             None\n         }\n@@ -245,7 +245,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             trait_ref: &ty::TraitRef,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n-        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n+        debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n+            debug!(\"new_did={} trait_method={}\", new_did, trait_method.repr(tcx));\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty ="}, {"sha": "8e4948bbea98016feb1b10b8fee5624027f7a372", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_ty(): {:?}\",\n+                                           in get_item_ty(): {}\",\n                                           x).as_slice());\n             }\n         }\n@@ -1421,7 +1421,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {:?}\", s).as_slice());\n+                format!(\"trait_def_of_item invoked on {}\", s).as_slice());\n         }\n     };\n "}, {"sha": "9f88bec7f42257e98d64d350bc2b8dad6558d504", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -231,7 +231,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n                     self.get_ref().trace.origin.span(),\n                     format!(\"failed to resolve even without \\\n-                             any force options: {:?}\", e).as_slice());\n+                             any force options: {}\", e).as_slice());\n             }\n         }\n     }\n@@ -243,7 +243,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                    b: ty::t,\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult {\n-        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -283,7 +283,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                   b: ty::t,\n                                   mutbl_b: ast::Mutability)\n                                   -> CoerceResult {\n-        debug!(\"coerce_unsized_with_borrow(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsized_with_borrow(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -314,7 +314,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                       sty_a: &ty::sty,\n                       b: ty::t)\n                       -> CoerceResult {\n-        debug!(\"coerce_unsized(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -342,7 +342,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                                    AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n@@ -365,7 +365,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                                    AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n@@ -383,7 +383,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoUnsizeUniq({:?}))\", kind);\n+                                    AutoUnsizeUniq({}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsizeUniq(kind))\n@@ -405,7 +405,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                  sty_a: &ty::sty,\n                  ty_b: ty::t)\n                  -> Option<(ty::t, ty::UnsizeKind)> {\n-        debug!(\"unsize_ty(sty_a={:?}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -485,7 +485,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_borrowed_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n                b.repr(tcx), b_mutbl);\n \n@@ -505,7 +505,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n+        debug!(\"coerce_unsafe_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n                b.repr(tcx), b_mutbl);\n \n@@ -557,7 +557,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                               sty_a: &ty::sty,\n                               b: ty::t)\n                               -> CoerceResult {\n-        debug!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n \n@@ -610,7 +610,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                              b: ty::t,\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult {\n-        debug!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n "}, {"sha": "8ae0b603e487185abe183895e288b074be30c3ec", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -390,7 +390,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n     let tcx = this.infcx().tcx;\n     let a_sty = &ty::get(a).sty;\n     let b_sty = &ty::get(b).sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (&ty::ty_bot, _) |\n@@ -470,7 +470,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_))\n       if a_.def_id == b_.def_id => {\n-          debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n+          debug!(\"Trying to match traits {} and {}\", a, b);\n           let substs = try!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n           let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx,"}, {"sha": "2ab585f5ae9988b78fef4d20b3b0589098ce6052", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n-            debug!(\"errors processed: {:?}\", pe);\n+            debug!(\"errors processed: {}\", pe);\n             processed_errors.push(pe);\n         }\n         return processed_errors;\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n+            debug!(\"free_regions_from_same_fn(sub={}, sup={})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n                     if fr1.scope_id != fr2.scope_id {"}, {"sha": "83ca67f33bc31a7a7e5a47a4af97138619b622f9", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -109,7 +109,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug!(\"{}.regions({:?}, {:?})\",\n+        debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n@@ -130,7 +130,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        debug!(\"{}.fn_sigs({:?}, {:?})\",\n+        debug!(\"{}.fn_sigs({}, {})\",\n                self.tag(), a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         let _indenter = indenter();\n \n@@ -254,7 +254,7 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n             }\n             this.fields.infcx.tcx.sess.span_bug(\n                 this.fields.trace.origin.span(),\n-                format!(\"could not find original bound region for {:?}\",\n+                format!(\"could not find original bound region for {}\",\n                         r).as_slice())\n         }\n "}, {"sha": "24642d5213892ddb1a563f383d7278d1bf9fc18d", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -123,7 +123,7 @@ pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n-                    format!(\"found non-region-vid: {:?}\", r).as_slice());\n+                    format!(\"found non-region-vid: {}\", r).as_slice());\n             }\n         }).collect()\n }"}, {"sha": "f2d9203f8437b11bdf6a6a44be34e1556a20879a", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -157,7 +157,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n-                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n+                debug!(\"generalize_region(r0={}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -167,8 +167,8 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0={:?}): \\\n-                        non-new-variables found in {:?}\",\n+                debug!(\"generalize_region(r0={}): \\\n+                        non-new-variables found in {}\",\n                        r0, tainted);\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -181,16 +181,16 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n             // with.\n             for (a_br, a_r) in a_map.iter() {\n                 if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={:?}): \\\n-                            replacing with {:?}, tainted={:?}\",\n+                    debug!(\"generalize_region(r0={}): \\\n+                            replacing with {}, tainted={}\",\n                            r0, *a_br, tainted);\n                     return ty::ReLateBound(new_scope, *a_br);\n                 }\n             }\n \n             this.fields.infcx.tcx.sess.span_bug(\n                 this.fields.trace.origin.span(),\n-                format!(\"region {:?} is not associated with \\\n+                format!(\"region {} is not associated with \\\n                          any bound region from A!\",\n                         r0).as_slice())\n         }"}, {"sha": "7c455b85707b8fe812fe061257c4e2d1870360f7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -95,7 +95,7 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum TypeOrigin {\n     // Not yet categorized in a better way\n     Misc(Span),\n@@ -127,7 +127,7 @@ pub enum TypeOrigin {\n }\n \n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum ValuePairs {\n     Types(ty::expected_found<ty::t>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n@@ -137,7 +137,7 @@ pub enum ValuePairs {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct TypeTrace {\n     origin: TypeOrigin,\n     values: ValuePairs,\n@@ -146,7 +146,7 @@ pub struct TypeTrace {\n /// The origin of a `r1 <= r2` constraint.\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum SubregionOrigin {\n     // Arose from a subtyping relation\n     Subtype(TypeTrace),\n@@ -224,7 +224,7 @@ pub enum SubregionOrigin {\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting.rs` for more details\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n@@ -887,7 +887,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: String,\n                                                 err: Option<&ty::type_err>) {\n-        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n+        debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let error_str = err.map_or(\"\".to_string(), |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             replace_late_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n-                debug!(\"Bound region {} maps to {:?}\",\n+                debug!(\"Bound region {} maps to {}\",\n                        bound_region_to_string(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n@@ -1120,7 +1120,7 @@ impl Repr for SubregionOrigin {\n             }\n             Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n             ReborrowUpvar(a, b) => {\n-                format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b)\n+                format!(\"ReborrowUpvar({},{})\", a.repr(tcx), b)\n             }\n             ReferenceOutlivesReferent(_, a) => {\n                 format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx))"}, {"sha": "504550f0d40d2fc5b80efe1ea7755d7f2aaaaa19", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -81,7 +81,7 @@ pub enum CombineMapType {\n     Lub, Glb\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum RegionResolutionError {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n@@ -133,7 +133,7 @@ pub enum RegionResolutionError {\n /// ```\n /// would report an error because we expect 'a and 'b to match, and so we group\n /// 'a and 'b together inside a SameRegions struct\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct SameRegions {\n     pub scope_id: ast::NodeId,\n     pub regions: Vec<BoundRegion>"}, {"sha": "158fda802ff002e79a4d550607ea7e16a71cf576", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -200,7 +200,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         let (skol_map, b_sig) = {\n             replace_late_bound_regions_in_fn_sig(self.fields.infcx.tcx, b, |br| {\n                 let skol = self.fields.infcx.region_vars.new_skolemized(br);\n-                debug!(\"Bound region {} skolemized to {:?}\",\n+                debug!(\"Bound region {} skolemized to {}\",\n                        bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol"}, {"sha": "baa4f6d013bd24fe437f284e633559d5374ff425", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n-            Err(ref e) => fail!(\"unexpected error computing LUB: {:?}\",\n+            Err(ref e) => fail!(\"unexpected error computing LUB: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail!(\"unexpected error computing LUB: {:?}\", e)\n+                fail!(\"unexpected error computing LUB: {}\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);"}, {"sha": "5a23d54c9720b60766dbe0e6d00c4bec7b258097", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -87,13 +87,13 @@ pub mod collect;\n pub mod coherence;\n pub mod variance;\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, PartialOrd, Show)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n     pub index: uint\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub enum MethodOrigin {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -111,7 +111,7 @@ pub enum MethodOrigin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct MethodParam {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed.\n@@ -122,7 +122,7 @@ pub struct MethodParam {\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[deriving(Clone)]\n+#[deriving(Clone, Show)]\n pub struct MethodObject {\n     // the (super)trait containing the method to be invoked\n     pub trait_ref: Rc<ty::TraitRef>,\n@@ -249,15 +249,15 @@ impl Repr for vtable_origin {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n-                format!(\"vtable_static({:?}:{}, {}, {})\",\n+                format!(\"vtable_static({}:{}, {}, {})\",\n                         def_id,\n                         ty::item_path_str(tcx, def_id),\n                         tys.repr(tcx),\n                         vtable_res.repr(tcx))\n             }\n \n             vtable_param(x, y) => {\n-                format!(\"vtable_param({:?}, {:?})\", x, y)\n+                format!(\"vtable_param({}, {})\", x, y)\n             }\n \n             vtable_unboxed_closure(def_id) => {"}, {"sha": "dd6e087b6727a04d9253698357ec3c459fbdcda5", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -232,6 +232,7 @@ pub fn infer_variance(tcx: &ty::ctxt) {\n \n type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n+#[deriving(Show)]\n struct InferredIndex(uint);\n \n enum VarianceTerm<'a> {\n@@ -325,10 +326,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         assert!(newly_added);\n \n         debug!(\"add_inferred(item_id={}, \\\n-                kind={:?}, \\\n+                kind={}, \\\n                 index={}, \\\n                 param_id={},\n-                inf_index={:?})\",\n+                inf_index={})\",\n                 item_id, kind, index, param_id, inf_index);\n     }\n \n@@ -852,7 +853,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs,\n                                    variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+        debug!(\"add_constraints_from_substs(def_id={})\", def_id);\n \n         for p in type_param_defs.iter() {\n             let variance_decl ="}, {"sha": "082dde978d8e7068d66745f9f71532a5573aba54", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -13,6 +13,7 @@\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::hash::{Hash, Hasher};\n+use std::fmt::Show;\n use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -36,12 +37,12 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     rv\n }\n \n-pub fn indent<R>(op: || -> R) -> R {\n+pub fn indent<R: Show>(op: || -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n     let r = op();\n-    debug!(\"<< (Result = {:?})\", r);\n+    debug!(\"<< (Result = {})\", r);\n     r\n }\n "}, {"sha": "404864cec04e4968a45a64b2e8203907d938e730", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814586be57b87a32414b4e3fecc150686513b80f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=814586be57b87a32414b4e3fecc150686513b80f", "patch": "@@ -154,7 +154,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n       ty::ReInfer(_) | ty::ReLateBound(..) => {\n-        (format!(\"lifetime {:?}\", region), None)\n+        (format!(\"lifetime {}\", region), None)\n       }\n     };\n \n@@ -599,7 +599,7 @@ impl<T:UserString> UserString for Vec<T> {\n \n impl Repr for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n@@ -843,14 +843,14 @@ impl Repr for ast::DefId {\n                 Some(ast_map::NodeVariant(..)) |\n                 Some(ast_map::NodeStructCtor(..)) => {\n                     return format!(\n-                                \"{:?}:{}\",\n+                                \"{}:{}\",\n                                 *self,\n                                 ty::item_path_str(tcx, *self))\n                 }\n                 _ => {}\n             }\n         }\n-        return format!(\"{:?}\", *self)\n+        return format!(\"{}\", *self)\n     }\n }\n \n@@ -922,19 +922,19 @@ impl Repr for ast::Ident {\n \n impl Repr for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::Visibility {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"BareFnTy {{fn_style: {:?}, abi: {}, sig: {}}}\",\n+        format!(\"BareFnTy {{fn_style: {}, abi: {}, sig: {}}}\",\n                 self.fn_style,\n                 self.abi.to_string(),\n                 self.sig.repr(tcx))\n@@ -985,7 +985,7 @@ impl Repr for typeck::MethodParam {\n \n impl Repr for typeck::MethodObject {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"MethodObject({},{:?},{:?})\",\n+        format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n                 self.real_index)\n@@ -1000,7 +1000,7 @@ impl Repr for ty::TraitStore {\n \n impl Repr for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n@@ -1118,13 +1118,13 @@ impl Repr for ty::UpvarId {\n \n impl Repr for ast::Mutability {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ty::BorrowKind {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n@@ -1162,25 +1162,25 @@ impl Repr for ty::TyVid {\n \n impl Repr for ty::IntVarValue {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::IntTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::UintTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n \n impl Repr for ast::FloatTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n-        format!(\"{:?}\", *self)\n+        format!(\"{}\", *self)\n     }\n }\n "}]}