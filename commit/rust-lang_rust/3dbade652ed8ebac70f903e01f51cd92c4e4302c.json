{"sha": "3dbade652ed8ebac70f903e01f51cd92c4e4302c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYmFkZTY1MmVkOGViYWM3MGY5MDNlMDFmNTFjZDkyYzRlNDMwMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-09T11:58:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-09T11:58:17Z"}, "message": "Auto merge of #69851 - Centril:rollup-iivxvah, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #69201 (Permit attributes on 'if' expressions)\n - #69685 (unix: Don't override existing SIGSEGV/BUS handlers)\n - #69762 (Ensure that validity only raises validity errors)\n - #69779 (librustc_codegen_llvm: Use slices in preference to 0-terminated strings)\n - #69801 (rustc_parse: Remove `Parser::normalized(_prev)_token`)\n - #69842 (Add more regression tests)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9e1d2f9871ea0024b1657db356742eae8c2b750a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e1d2f9871ea0024b1657db356742eae8c2b750a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dbade652ed8ebac70f903e01f51cd92c4e4302c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbade652ed8ebac70f903e01f51cd92c4e4302c", "html_url": "https://github.com/rust-lang/rust/commit/3dbade652ed8ebac70f903e01f51cd92c4e4302c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dbade652ed8ebac70f903e01f51cd92c4e4302c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cb0b8582ebbf9784db9cec06fff517badbf4553", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb0b8582ebbf9784db9cec06fff517badbf4553", "html_url": "https://github.com/rust-lang/rust/commit/2cb0b8582ebbf9784db9cec06fff517badbf4553"}, {"sha": "7e903f82ff1401445853905083456b9bb0e761cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e903f82ff1401445853905083456b9bb0e761cc", "html_url": "https://github.com/rust-lang/rust/commit/7e903f82ff1401445853905083456b9bb0e761cc"}], "stats": {"total": 1652, "additions": 1050, "deletions": 602}, "files": [{"sha": "b46095927b70910aee9e5ffaeefefd1906cb3914", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -245,7 +245,7 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n-impl From<ErrorHandled> for InterpErrorInfo<'tcx> {\n+impl From<ErrorHandled> for InterpErrorInfo<'_> {\n     fn from(err: ErrorHandled) -> Self {\n         match err {\n             ErrorHandled::Reported => err_inval!(ReferencedConstant),\n@@ -291,7 +291,7 @@ pub enum InvalidProgramInfo<'tcx> {\n     Layout(layout::LayoutError<'tcx>),\n }\n \n-impl fmt::Debug for InvalidProgramInfo<'tcx> {\n+impl fmt::Debug for InvalidProgramInfo<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use InvalidProgramInfo::*;\n         match self {\n@@ -321,6 +321,8 @@ pub enum UndefinedBehaviorInfo {\n     RemainderByZero,\n     /// Overflowing inbounds pointer arithmetic.\n     PointerArithOverflow,\n+    /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n+    InvalidMeta(&'static str),\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -338,6 +340,7 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n             DivisionByZero => write!(f, \"dividing by zero\"),\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n+            InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n         }\n     }\n }\n@@ -354,8 +357,8 @@ pub enum UnsupportedOpInfo<'tcx> {\n     Unsupported(String),\n \n     /// When const-prop encounters a situation it does not support, it raises this error.\n-    /// This must not allocate for performance reasons.\n-    ConstPropUnsupported(&'tcx str),\n+    /// This must not allocate for performance reasons (hence `str`, not `String`).\n+    ConstPropUnsupported(&'static str),\n \n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n@@ -612,3 +615,19 @@ impl fmt::Debug for InterpError<'_> {\n         }\n     }\n }\n+\n+impl InterpError<'_> {\n+    /// Some errors allocate to be created as they contain free-form strings.\n+    /// And sometimes we want to be sure that did not happen as it is a\n+    /// waste of resources.\n+    pub fn allocates(&self) -> bool {\n+        match self {\n+            InterpError::MachineStop(_)\n+            | InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n+            | InterpError::Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_)) => true,\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "52a59e82ae23f672db81c1c34d0a268348768a39", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -286,6 +286,10 @@ impl MetaItem {\n }\n \n impl AttrItem {\n+    pub fn span(&self) -> Span {\n+        self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n+    }\n+\n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n         Some(MetaItem {\n             path: self.path.clone(),\n@@ -437,7 +441,7 @@ impl MetaItem {\n         I: Iterator<Item = TokenTree>,\n     {\n         // FIXME: Share code with `parse_path`.\n-        let path = match tokens.next() {\n+        let path = match tokens.next().map(TokenTree::uninterpolate) {\n             Some(TokenTree::Token(Token { kind: kind @ token::Ident(..), span }))\n             | Some(TokenTree::Token(Token { kind: kind @ token::ModSep, span })) => 'arm: {\n                 let mut segments = if let token::Ident(name, _) = kind {\n@@ -453,7 +457,7 @@ impl MetaItem {\n                 };\n                 loop {\n                     if let Some(TokenTree::Token(Token { kind: token::Ident(name, _), span })) =\n-                        tokens.next()\n+                        tokens.next().map(TokenTree::uninterpolate)\n                     {\n                         segments.push(PathSegment::from_ident(Ident::new(name, span)));\n                     } else {\n@@ -470,7 +474,6 @@ impl MetaItem {\n                 Path { span, segments }\n             }\n             Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n-                token::Nonterminal::NtIdent(ident, _) => Path::from_ident(ident),\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,"}, {"sha": "b67b7d346f7565009be3a963ca086f60978f6089", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -14,8 +14,8 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::kw;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, Span, DUMMY_SP};\n-use std::fmt;\n-use std::mem;\n+use std::borrow::Cow;\n+use std::{fmt, mem};\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n@@ -225,8 +225,15 @@ pub enum TokenKind {\n     /* Literals */\n     Literal(Lit),\n \n-    /* Name components */\n+    /// Identifier token.\n+    /// Do not forget about `NtIdent` when you want to match on identifiers.\n+    /// It's recommended to use `Token::(ident,uninterpolate,uninterpolated_span)` to\n+    /// treat regular and interpolated identifiers in the same way.\n     Ident(ast::Name, /* is_raw */ bool),\n+    /// Lifetime identifier token.\n+    /// Do not forget about `NtLifetime` when you want to match on lifetime identifiers.\n+    /// It's recommended to use `Token::(lifetime,uninterpolate,uninterpolated_span)` to\n+    /// treat regular and interpolated lifetime identifiers in the same way.\n     Lifetime(ast::Name),\n \n     Interpolated(Lrc<Nonterminal>),\n@@ -328,6 +335,19 @@ impl Token {\n         mem::replace(self, Token::dummy())\n     }\n \n+    /// For interpolated tokens, returns a span of the fragment to which the interpolated\n+    /// token refers. For all other tokens this is just a regular span.\n+    /// It is particularly important to use this for identifiers and lifetimes\n+    /// for which spans affect name resolution and edition checks.\n+    /// Note that keywords are also identifiers, so they should use this\n+    /// if they keep spans or perform edition checks.\n+    pub fn uninterpolated_span(&self) -> Span {\n+        match &self.kind {\n+            Interpolated(nt) => nt.span(),\n+            _ => self.span,\n+        }\n+    }\n+\n     pub fn is_op(&self) -> bool {\n         match self.kind {\n             OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) | Ident(..)\n@@ -345,7 +365,7 @@ impl Token {\n \n     /// Returns `true` if the token can appear at the start of an expression.\n     pub fn can_begin_expr(&self) -> bool {\n-        match self.kind {\n+        match self.uninterpolate().kind {\n             Ident(name, is_raw)              =>\n                 ident_can_begin_expr(name, self.span, is_raw), // value name or keyword\n             OpenDelim(..)                     | // tuple, array or block\n@@ -363,12 +383,10 @@ impl Token {\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => ident_can_begin_expr(ident.name, ident.span, is_raw),\n                 NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n-                NtPath(..)    |\n-                NtLifetime(..) => true,\n+                NtPath(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -377,7 +395,7 @@ impl Token {\n \n     /// Returns `true` if the token can appear at the start of a type.\n     pub fn can_begin_type(&self) -> bool {\n-        match self.kind {\n+        match self.uninterpolate().kind {\n             Ident(name, is_raw)        =>\n                 ident_can_begin_type(name, self.span, is_raw), // type name or keyword\n             OpenDelim(Paren)            | // tuple\n@@ -391,8 +409,7 @@ impl Token {\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => ident_can_begin_type(ident.name, ident.span, is_raw),\n-                NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n+                NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -433,38 +450,48 @@ impl Token {\n     ///\n     /// Keep this in sync with `Lit::from_token`.\n     pub fn can_begin_literal_or_bool(&self) -> bool {\n-        match self.kind {\n+        match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n             Interpolated(ref nt) => match &**nt {\n-                NtIdent(ident, false) if ident.name.is_bool_lit() => true,\n                 NtExpr(e) | NtLiteral(e) => matches!(e.kind, ast::ExprKind::Lit(_)),\n                 _ => false,\n             },\n             _ => false,\n         }\n     }\n \n+    // A convenience function for matching on identifiers during parsing.\n+    // Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n+    // into the regular identifier or lifetime token it refers to,\n+    // otherwise returns the original token.\n+    pub fn uninterpolate(&self) -> Cow<'_, Token> {\n+        match &self.kind {\n+            Interpolated(nt) => match **nt {\n+                NtIdent(ident, is_raw) => {\n+                    Cow::Owned(Token::new(Ident(ident.name, is_raw), ident.span))\n+                }\n+                NtLifetime(ident) => Cow::Owned(Token::new(Lifetime(ident.name), ident.span)),\n+                _ => Cow::Borrowed(self),\n+            },\n+            _ => Cow::Borrowed(self),\n+        }\n+    }\n+\n     /// Returns an identifier if this token is an identifier.\n     pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n-        match self.kind {\n-            Ident(name, is_raw) => Some((ast::Ident::new(name, self.span), is_raw)),\n-            Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => Some((ident, is_raw)),\n-                _ => None,\n-            },\n+        let token = self.uninterpolate();\n+        match token.kind {\n+            Ident(name, is_raw) => Some((ast::Ident::new(name, token.span), is_raw)),\n             _ => None,\n         }\n     }\n \n     /// Returns a lifetime identifier if this token is a lifetime.\n     pub fn lifetime(&self) -> Option<ast::Ident> {\n-        match self.kind {\n-            Lifetime(name) => Some(ast::Ident::new(name, self.span)),\n-            Interpolated(ref nt) => match **nt {\n-                NtLifetime(ident) => Some(ident),\n-                _ => None,\n-            },\n+        let token = self.uninterpolate();\n+        match token.kind {\n+            Lifetime(name) => Some(ast::Ident::new(name, token.span)),\n             _ => None,\n         }\n     }\n@@ -714,6 +741,24 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n+impl Nonterminal {\n+    fn span(&self) -> Span {\n+        match self {\n+            NtItem(item) => item.span,\n+            NtBlock(block) => block.span,\n+            NtStmt(stmt) => stmt.span,\n+            NtPat(pat) => pat.span,\n+            NtExpr(expr) | NtLiteral(expr) => expr.span,\n+            NtTy(ty) => ty.span,\n+            NtIdent(ident, _) | NtLifetime(ident) => ident.span,\n+            NtMeta(attr_item) => attr_item.span(),\n+            NtPath(path) => path.span,\n+            NtVis(vis) => vis.span,\n+            NtTT(tt) => tt.span(),\n+        }\n+    }\n+}\n+\n impl PartialEq for Nonterminal {\n     fn eq(&self, rhs: &Self) -> bool {\n         match (self, rhs) {"}, {"sha": "916a5ff6f46f49a0d6969f6e0d809e19f41b623a", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -116,6 +116,13 @@ impl TokenTree {\n     pub fn close_tt(span: DelimSpan, delim: DelimToken) -> TokenTree {\n         TokenTree::token(token::CloseDelim(delim), span.close)\n     }\n+\n+    pub fn uninterpolate(self) -> TokenTree {\n+        match self {\n+            TokenTree::Token(token) => TokenTree::Token(token.uninterpolate().into_owned()),\n+            tt => tt,\n+        }\n+    }\n }\n \n impl<CTX> HashStable<CTX> for TokenStream"}, {"sha": "d1757394f3a1dee633881c5720e6695022c9727c", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -191,23 +191,16 @@ impl Lit {\n     ///\n     /// Keep this in sync with `Token::can_begin_literal_or_bool`.\n     pub fn from_token(token: &Token) -> Result<Lit, LitError> {\n-        let lit = match token.kind {\n+        let lit = match token.uninterpolate().kind {\n             token::Ident(name, false) if name.is_bool_lit() => {\n                 token::Lit::new(token::Bool, name, None)\n             }\n             token::Literal(lit) => lit,\n             token::Interpolated(ref nt) => {\n-                match &**nt {\n-                    token::NtIdent(ident, false) if ident.name.is_bool_lit() => {\n-                        let lit = token::Lit::new(token::Bool, ident.name, None);\n-                        return Lit::from_lit_token(lit, ident.span);\n+                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n+                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n+                        return Ok(lit.clone());\n                     }\n-                    token::NtExpr(expr) | token::NtLiteral(expr) => {\n-                        if let ast::ExprKind::Lit(lit) = &expr.kind {\n-                            return Ok(lit.clone());\n-                        }\n-                    }\n-                    _ => {}\n                 }\n                 return Err(LitError::NotLiteral);\n             }"}, {"sha": "2883159a9f34ca1af05fb9dd435cfd0aa14368dd", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -156,44 +156,43 @@ fn parse_args<'a>(\n         if p.token == token::Eof {\n             break;\n         } // accept trailing commas\n-        if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n-            named = true;\n-            let name = if let token::Ident(name, _) = p.normalized_token.kind {\n+        match p.token.ident() {\n+            Some((ident, _)) if p.look_ahead(1, |t| *t == token::Eq) => {\n+                named = true;\n                 p.bump();\n-                name\n-            } else {\n-                unreachable!();\n-            };\n+                p.expect(&token::Eq)?;\n+                let e = p.parse_expr()?;\n+                if let Some(prev) = names.get(&ident.name) {\n+                    ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n+                        .span_label(args[*prev].span, \"previously here\")\n+                        .span_label(e.span, \"duplicate argument\")\n+                        .emit();\n+                    continue;\n+                }\n \n-            p.expect(&token::Eq)?;\n-            let e = p.parse_expr()?;\n-            if let Some(prev) = names.get(&name) {\n-                ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n-                    .span_label(args[*prev].span, \"previously here\")\n-                    .span_label(e.span, \"duplicate argument\")\n-                    .emit();\n-                continue;\n+                // Resolve names into slots early.\n+                // Since all the positional args are already seen at this point\n+                // if the input is valid, we can simply append to the positional\n+                // args. And remember the names.\n+                let slot = args.len();\n+                names.insert(ident.name, slot);\n+                args.push(e);\n             }\n-\n-            // Resolve names into slots early.\n-            // Since all the positional args are already seen at this point\n-            // if the input is valid, we can simply append to the positional\n-            // args. And remember the names.\n-            let slot = args.len();\n-            names.insert(name, slot);\n-            args.push(e);\n-        } else {\n-            let e = p.parse_expr()?;\n-            if named {\n-                let mut err = ecx\n-                    .struct_span_err(e.span, \"positional arguments cannot follow named arguments\");\n-                err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                for pos in names.values() {\n-                    err.span_label(args[*pos].span, \"named argument\");\n+            _ => {\n+                let e = p.parse_expr()?;\n+                if named {\n+                    let mut err = ecx.struct_span_err(\n+                        e.span,\n+                        \"positional arguments cannot follow named arguments\",\n+                    );\n+                    err.span_label(e.span, \"positional arguments must be before named arguments\");\n+                    for pos in names.values() {\n+                        err.span_label(args[*pos].span, \"named argument\");\n+                    }\n+                    err.emit();\n                 }\n-                err.emit();\n+                args.push(e);\n             }\n-            args.push(e);\n         }\n     }\n     Ok((fmtstr, args, names))"}, {"sha": "46c4a51111432ac18ae9bcb440f7d7ee51df0b02", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 139, "deletions": 109, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -37,7 +37,6 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n@@ -49,7 +48,6 @@ use rustc_target::abi::HasDataLayout;\n \n use libc::{c_longlong, c_uint};\n use std::collections::hash_map::Entry;\n-use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n use std::iter;\n@@ -227,11 +225,11 @@ impl TypeMap<'ll, 'tcx> {\n     /// Gets the unique type ID string for an enum variant part.\n     /// Variant parts are not types and shouldn't really have their own ID,\n     /// but it makes `set_members_of_composite_type()` simpler.\n-    fn get_unique_type_id_str_of_enum_variant_part(&mut self, enum_type_id: UniqueTypeId) -> &str {\n-        let variant_part_type_id =\n-            format!(\"{}_variant_part\", self.get_unique_type_id_as_string(enum_type_id));\n-        let interner_key = self.unique_id_interner.intern(&variant_part_type_id);\n-        self.unique_id_interner.get(interner_key)\n+    fn get_unique_type_id_str_of_enum_variant_part(\n+        &mut self,\n+        enum_type_id: UniqueTypeId,\n+    ) -> String {\n+        format!(\"{}_variant_part\", self.get_unique_type_id_as_string(enum_type_id))\n     }\n }\n \n@@ -640,9 +638,11 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n                     // type is going to see *something* weird - the only\n                     // question is what exactly it will see.\n                     let (size, align) = cx.size_and_align_of(t);\n+                    let name = \"<recur_type>\";\n                     llvm::LLVMRustDIBuilderCreateBasicType(\n                         DIB(cx),\n-                        SmallCStr::new(\"<recur_type>\").as_ptr(),\n+                        name.as_ptr().cast(),\n+                        name.len(),\n                         size.bits(),\n                         align.bits() as u32,\n                         DW_ATE_unsigned,\n@@ -786,16 +786,17 @@ fn file_metadata_raw(\n             let (file_name, directory) = v.key();\n             debug!(\"file_metadata: file_name: {:?}, directory: {:?}\", file_name, directory);\n \n-            let file_name = SmallCStr::new(if let Some(file_name) = file_name {\n-                &file_name\n-            } else {\n-                \"<unknown>\"\n-            });\n-            let directory =\n-                SmallCStr::new(if let Some(directory) = directory { &directory } else { \"\" });\n+            let file_name = file_name.as_deref().unwrap_or(\"<unknown>\");\n+            let directory = directory.as_deref().unwrap_or(\"\");\n \n             let file_metadata = unsafe {\n-                llvm::LLVMRustDIBuilderCreateFile(DIB(cx), file_name.as_ptr(), directory.as_ptr())\n+                llvm::LLVMRustDIBuilderCreateFile(\n+                    DIB(cx),\n+                    file_name.as_ptr().cast(),\n+                    file_name.len(),\n+                    directory.as_ptr().cast(),\n+                    directory.len(),\n+                )\n             };\n \n             v.insert(file_metadata);\n@@ -819,11 +820,11 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     };\n \n     let (size, align) = cx.size_and_align_of(t);\n-    let name = SmallCStr::new(name);\n     let ty_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n-            name.as_ptr(),\n+            name.as_ptr().cast(),\n+            name.len(),\n             size.bits(),\n             align.bits() as u32,\n             encoding,\n@@ -851,14 +852,15 @@ fn pointer_type_metadata(\n ) -> &'ll DIType {\n     let (pointer_size, pointer_align) = cx.size_and_align_of(pointer_type);\n     let name = compute_debuginfo_type_name(cx.tcx, pointer_type, false);\n-    let name = SmallCStr::new(&name);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreatePointerType(\n             DIB(cx),\n             pointee_type_metadata,\n             pointer_size.bits(),\n             pointer_align.bits() as u32,\n-            name.as_ptr(),\n+            0, // Ignore DWARF address space.\n+            name.as_ptr().cast(),\n+            name.len(),\n         )\n     }\n }\n@@ -889,11 +891,9 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let name_in_debuginfo = SmallCStr::new(&name_in_debuginfo);\n-    let work_dir = SmallCStr::new(&tcx.sess.working_dir.0.to_string_lossy());\n-    let producer = CString::new(producer).unwrap();\n+    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n     let flags = \"\\0\";\n-    let split_name = \"\\0\";\n+    let split_name = \"\";\n \n     // FIXME(#60020):\n     //\n@@ -916,19 +916,23 @@ pub fn compile_unit_metadata(\n     unsafe {\n         let file_metadata = llvm::LLVMRustDIBuilderCreateFile(\n             debug_context.builder,\n-            name_in_debuginfo.as_ptr(),\n-            work_dir.as_ptr(),\n+            name_in_debuginfo.as_ptr().cast(),\n+            name_in_debuginfo.len(),\n+            work_dir.as_ptr().cast(),\n+            work_dir.len(),\n         );\n \n         let unit_metadata = llvm::LLVMRustDIBuilderCreateCompileUnit(\n             debug_context.builder,\n             DW_LANG_RUST,\n             file_metadata,\n-            producer.as_ptr(),\n+            producer.as_ptr().cast(),\n+            producer.len(),\n             tcx.sess.opts.optimize != config::OptLevel::No,\n             flags.as_ptr().cast(),\n             0,\n             split_name.as_ptr().cast(),\n+            split_name.len(),\n             kind,\n         );\n \n@@ -1021,12 +1025,12 @@ impl<'ll> MemberDescription<'ll> {\n         cx: &CodegenCx<'ll, '_>,\n         composite_type_metadata: &'ll DIScope,\n     ) -> &'ll DIType {\n-        let member_name = CString::new(self.name).unwrap();\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateVariantMemberType(\n                 DIB(cx),\n                 composite_type_metadata,\n-                member_name.as_ptr(),\n+                self.name.as_ptr().cast(),\n+                self.name.len(),\n                 unknown_file_metadata(cx),\n                 UNKNOWN_LINE_NUMBER,\n                 self.size.bits(),\n@@ -1827,17 +1831,22 @@ fn prepare_enum_metadata(\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx, discr.to_ty(cx.tcx), rustc_span::DUMMY_SP);\n \n+                let item_name;\n                 let discriminant_name = match enum_type.kind {\n-                    ty::Adt(..) => SmallCStr::new(&cx.tcx.item_name(enum_def_id).as_str()),\n-                    ty::Generator(..) => SmallCStr::new(&enum_name),\n+                    ty::Adt(..) => {\n+                        item_name = cx.tcx.item_name(enum_def_id).as_str();\n+                        &*item_name\n+                    }\n+                    ty::Generator(..) => enum_name.as_str(),\n                     _ => bug!(),\n                 };\n \n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMRustDIBuilderCreateEnumerationType(\n                         DIB(cx),\n                         containing_scope,\n-                        discriminant_name.as_ptr(),\n+                        discriminant_name.as_ptr().cast(),\n+                        discriminant_name.len(),\n                         file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n                         discriminant_size.bits(),\n@@ -1872,11 +1881,6 @@ fn prepare_enum_metadata(\n         _ => {}\n     }\n \n-    let enum_name = SmallCStr::new(&enum_name);\n-    let unique_type_id_str = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n-    );\n-\n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             layout::Variants::Single { .. }\n@@ -1891,20 +1895,27 @@ fn prepare_enum_metadata(\n             } => Some(discriminant_type_metadata(discr.value)),\n         };\n \n-        let enum_metadata = unsafe {\n-            llvm::LLVMRustDIBuilderCreateUnionType(\n-                DIB(cx),\n-                containing_scope,\n-                enum_name.as_ptr(),\n-                file_metadata,\n-                UNKNOWN_LINE_NUMBER,\n-                layout.size.bits(),\n-                layout.align.abi.bits() as u32,\n-                DIFlags::FlagZero,\n-                None,\n-                0, // RuntimeLang\n-                unique_type_id_str.as_ptr(),\n-            )\n+        let enum_metadata = {\n+            let type_map = debug_context(cx).type_map.borrow();\n+            let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n+            unsafe {\n+                llvm::LLVMRustDIBuilderCreateUnionType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    enum_name.as_ptr().cast(),\n+                    enum_name.len(),\n+                    file_metadata,\n+                    UNKNOWN_LINE_NUMBER,\n+                    layout.size.bits(),\n+                    layout.align.abi.bits() as u32,\n+                    DIFlags::FlagZero,\n+                    None,\n+                    0, // RuntimeLang\n+                    unique_type_id_str.as_ptr().cast(),\n+                    unique_type_id_str.len(),\n+                )\n+            }\n         };\n \n         return create_and_register_recursive_type_forward_declaration(\n@@ -1924,10 +1935,9 @@ fn prepare_enum_metadata(\n     }\n \n     let discriminator_name = match &enum_type.kind {\n-        ty::Generator(..) => Some(SmallCStr::new(&\"__state\")),\n-        _ => None,\n+        ty::Generator(..) => \"__state\",\n+        _ => \"\",\n     };\n-    let discriminator_name = discriminator_name.map(|n| n.as_ptr()).unwrap_or(ptr::null_mut());\n     let discriminator_metadata = match layout.variants {\n         // A single-variant enum has no discriminant.\n         layout::Variants::Single { .. } => None,\n@@ -1955,7 +1965,8 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    discriminator_name,\n+                    discriminator_name.as_ptr().cast(),\n+                    discriminator_name.len(),\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -1981,7 +1992,8 @@ fn prepare_enum_metadata(\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n                     containing_scope,\n-                    discriminator_name,\n+                    discriminator_name.as_ptr().cast(),\n+                    discriminator_name.len(),\n                     file_metadata,\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n@@ -2010,48 +2022,57 @@ fn prepare_enum_metadata(\n         }\n     };\n \n-    let variant_part_unique_type_id_str = SmallCStr::new(\n-        debug_context(cx)\n-            .type_map\n-            .borrow_mut()\n-            .get_unique_type_id_str_of_enum_variant_part(unique_type_id),\n-    );\n+    let variant_part_unique_type_id_str = debug_context(cx)\n+        .type_map\n+        .borrow_mut()\n+        .get_unique_type_id_str_of_enum_variant_part(unique_type_id);\n     let empty_array = create_DIArray(DIB(cx), &[]);\n+    let name = \"\";\n     let variant_part = unsafe {\n         llvm::LLVMRustDIBuilderCreateVariantPart(\n             DIB(cx),\n             containing_scope,\n-            ptr::null_mut(),\n+            name.as_ptr().cast(),\n+            name.len(),\n             file_metadata,\n             UNKNOWN_LINE_NUMBER,\n             layout.size.bits(),\n             layout.align.abi.bits() as u32,\n             DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n-            variant_part_unique_type_id_str.as_ptr(),\n+            variant_part_unique_type_id_str.as_ptr().cast(),\n+            variant_part_unique_type_id_str.len(),\n         )\n     };\n     outer_fields.push(Some(variant_part));\n \n-    // The variant part must be wrapped in a struct according to DWARF.\n-    let type_array = create_DIArray(DIB(cx), &outer_fields);\n-    let struct_wrapper = unsafe {\n-        llvm::LLVMRustDIBuilderCreateStructType(\n-            DIB(cx),\n-            Some(containing_scope),\n-            enum_name.as_ptr(),\n-            file_metadata,\n-            UNKNOWN_LINE_NUMBER,\n-            layout.size.bits(),\n-            layout.align.abi.bits() as u32,\n-            DIFlags::FlagZero,\n-            None,\n-            type_array,\n-            0,\n-            None,\n-            unique_type_id_str.as_ptr(),\n-        )\n+    let struct_wrapper = {\n+        // The variant part must be wrapped in a struct according to DWARF.\n+        let type_array = create_DIArray(DIB(cx), &outer_fields);\n+\n+        let type_map = debug_context(cx).type_map.borrow();\n+        let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateStructType(\n+                DIB(cx),\n+                Some(containing_scope),\n+                enum_name.as_ptr().cast(),\n+                enum_name.len(),\n+                file_metadata,\n+                UNKNOWN_LINE_NUMBER,\n+                layout.size.bits(),\n+                layout.align.abi.bits() as u32,\n+                DIFlags::FlagZero,\n+                None,\n+                type_array,\n+                0,\n+                None,\n+                unique_type_id_str.as_ptr().cast(),\n+                unique_type_id_str.len(),\n+            )\n+        }\n     };\n \n     return create_and_register_recursive_type_forward_declaration(\n@@ -2156,12 +2177,13 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                         let actual_type_metadata =\n                             type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n-                        let name = SmallCStr::new(&name.as_str());\n+                        let name = &name.as_str();\n                         Some(unsafe {\n                             Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                 DIB(cx),\n                                 None,\n-                                name.as_ptr(),\n+                                name.as_ptr().cast(),\n+                                name.len(),\n                                 actual_type_metadata,\n                                 unknown_file_metadata(cx),\n                                 0,\n@@ -2200,10 +2222,9 @@ fn create_struct_stub(\n ) -> &'ll DICompositeType {\n     let (struct_size, struct_align) = cx.size_and_align_of(struct_type);\n \n-    let name = SmallCStr::new(struct_type_name);\n-    let unique_type_id = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n-    );\n+    let type_map = debug_context(cx).type_map.borrow();\n+    let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateStructType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -2213,7 +2234,8 @@ fn create_struct_stub(\n         llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n             containing_scope,\n-            name.as_ptr(),\n+            struct_type_name.as_ptr().cast(),\n+            struct_type_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             struct_size.bits(),\n@@ -2223,7 +2245,8 @@ fn create_struct_stub(\n             empty_array,\n             0,\n             None,\n-            unique_type_id.as_ptr(),\n+            unique_type_id.as_ptr().cast(),\n+            unique_type_id.len(),\n         )\n     };\n \n@@ -2239,10 +2262,9 @@ fn create_union_stub(\n ) -> &'ll DICompositeType {\n     let (union_size, union_align) = cx.size_and_align_of(union_type);\n \n-    let name = SmallCStr::new(union_type_name);\n-    let unique_type_id = SmallCStr::new(\n-        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id),\n-    );\n+    let type_map = debug_context(cx).type_map.borrow();\n+    let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n+\n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateUnionType()` wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -2252,15 +2274,17 @@ fn create_union_stub(\n         llvm::LLVMRustDIBuilderCreateUnionType(\n             DIB(cx),\n             containing_scope,\n-            name.as_ptr(),\n+            union_type_name.as_ptr().cast(),\n+            union_type_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             union_size.bits(),\n             union_align.bits() as u32,\n             DIFlags::FlagZero,\n             Some(empty_array),\n             0, // RuntimeLang\n-            unique_type_id.as_ptr(),\n+            unique_type_id.as_ptr().cast(),\n+            unique_type_id.len(),\n         )\n     };\n \n@@ -2294,24 +2318,26 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n     let variable_type = Instance::mono(cx.tcx, def_id).monomorphic_ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = SmallCStr::new(&tcx.item_name(def_id).as_str());\n+    let var_name = tcx.item_name(def_id).as_str();\n     let linkage_name = if no_mangle {\n         None\n     } else {\n-        let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id));\n-        Some(SmallCStr::new(&linkage_name.name.as_str()))\n+        Some(mangled_name_of_instance(cx, Instance::mono(tcx, def_id)).name.as_str())\n     };\n+    // When empty, linkage_name field is omitted,\n+    // which is what we want for no_mangle statics\n+    let linkage_name = linkage_name.as_deref().unwrap_or(\"\");\n \n     let global_align = cx.align_of(variable_type);\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(\n             DIB(cx),\n             Some(var_scope),\n-            var_name.as_ptr(),\n-            // If null, linkage_name field is omitted,\n-            // which is what we want for no_mangle statics\n-            linkage_name.as_ref().map_or(ptr::null(), |name| name.as_ptr()),\n+            var_name.as_ptr().cast(),\n+            var_name.len(),\n+            linkage_name.as_ptr().cast(),\n+            linkage_name.len(),\n             file_metadata,\n             line_number,\n             type_metadata,\n@@ -2339,16 +2365,16 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n         // pointer will lead to hard to trace and debug LLVM assertions\n         // later on in `llvm/lib/IR/Value.cpp`.\n         let empty_array = create_DIArray(DIB(cx), &[]);\n-\n-        let name = const_cstr!(\"vtable\");\n+        let name = \"vtable\";\n \n         // Create a new one each time. We don't want metadata caching\n         // here, because each vtable will refer to a unique containing\n         // type.\n         let vtable_type = llvm::LLVMRustDIBuilderCreateStructType(\n             DIB(cx),\n             NO_SCOPE_METADATA,\n-            name.as_ptr(),\n+            name.as_ptr().cast(),\n+            name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             Size::ZERO.bits(),\n@@ -2358,14 +2384,18 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n             empty_array,\n             0,\n             Some(type_metadata),\n-            name.as_ptr(),\n+            name.as_ptr().cast(),\n+            name.len(),\n         );\n \n+        let linkage_name = \"\";\n         llvm::LLVMRustDIBuilderCreateStaticVariable(\n             DIB(cx),\n             NO_SCOPE_METADATA,\n-            name.as_ptr(),\n-            ptr::null(),\n+            name.as_ptr().cast(),\n+            name.len(),\n+            linkage_name.as_ptr().cast(),\n+            linkage_name.len(),\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             vtable_type,"}, {"sha": "8deab1be3d3a93f6c04534baaab6c79a47c92ef6", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -25,13 +25,11 @@ use rustc::ty::{self, Instance, ParamEnv, Ty};\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_index::vec::IndexVec;\n \n use libc::c_uint;\n use log::debug;\n use std::cell::RefCell;\n-use std::ffi::CString;\n \n use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, Size};\n use rustc_ast::ast;\n@@ -273,13 +271,11 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         // Get the linkage_name, which is just the symbol name\n         let linkage_name = mangled_name_of_instance(self, instance);\n+        let linkage_name = linkage_name.name.as_str();\n \n         // FIXME(eddyb) does this need to be separate from `loc.line` for some reason?\n         let scope_line = loc.line;\n \n-        let function_name = CString::new(name).unwrap();\n-        let linkage_name = SmallCStr::new(&linkage_name.name.as_str());\n-\n         let mut flags = DIFlags::FlagPrototyped;\n \n         if fn_abi.ret.layout.abi.is_uninhabited() {\n@@ -303,8 +299,10 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n-                function_name.as_ptr(),\n-                linkage_name.as_ptr(),\n+                name.as_ptr().cast(),\n+                name.len(),\n+                linkage_name.as_ptr().cast(),\n+                linkage_name.len(),\n                 file_metadata,\n                 loc.line as c_uint,\n                 function_type_metadata,\n@@ -424,12 +422,13 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                             let actual_type_metadata =\n                                 type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n-                            let name = SmallCStr::new(&name.as_str());\n+                            let name = name.as_str();\n                             Some(unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                     DIB(cx),\n                                     None,\n-                                    name.as_ptr(),\n+                                    name.as_ptr().cast(),\n+                                    name.len(),\n                                     actual_type_metadata,\n                                     file_metadata,\n                                     0,\n@@ -542,13 +541,14 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         };\n         let align = self.align_of(variable_type);\n \n-        let name = SmallCStr::new(&variable_name.as_str());\n+        let name = variable_name.as_str();\n         unsafe {\n             llvm::LLVMRustDIBuilderCreateVariable(\n                 DIB(self),\n                 dwarf_tag,\n                 scope_metadata,\n-                name.as_ptr(),\n+                name.as_ptr().cast(),\n+                name.len(),\n                 file_metadata,\n                 loc.line as c_uint,\n                 type_metadata,"}, {"sha": "55a3540809b487a35d924f37d3a11d566ae69b96", "filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fnamespace.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -1,6 +1,5 @@\n // Namespace Handling.\n \n-use super::metadata::{unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n use super::utils::{debug_context, DIB};\n use rustc::ty::{self, Instance};\n \n@@ -10,8 +9,6 @@ use crate::llvm::debuginfo::DIScope;\n use rustc::hir::map::DefPathData;\n use rustc_hir::def_id::DefId;\n \n-use rustc_data_structures::small_c_str::SmallCStr;\n-\n pub fn mangled_name_of_instance<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     instance: Instance<'tcx>,\n@@ -34,16 +31,15 @@ pub fn item_namespace(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll DIScope {\n         DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate),\n         data => data.as_symbol(),\n     };\n-\n-    let namespace_name = SmallCStr::new(&namespace_name.as_str());\n+    let namespace_name = namespace_name.as_str();\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace(\n             DIB(cx),\n             parent_scope,\n-            namespace_name.as_ptr(),\n-            unknown_file_metadata(cx),\n-            UNKNOWN_LINE_NUMBER,\n+            namespace_name.as_ptr().cast(),\n+            namespace_name.len(),\n+            false, // ExportSymbols (only relevant for C++ anonymous namespaces)\n         )\n     };\n "}, {"sha": "31a0f52809088695b2c46dda75b2384e05999deb", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -1607,17 +1607,21 @@ extern \"C\" {\n         Lang: c_uint,\n         File: &'a DIFile,\n         Producer: *const c_char,\n+        ProducerLen: size_t,\n         isOptimized: bool,\n         Flags: *const c_char,\n         RuntimeVer: c_uint,\n         SplitName: *const c_char,\n+        SplitNameLen: size_t,\n         kind: DebugEmissionKind,\n     ) -> &'a DIDescriptor;\n \n     pub fn LLVMRustDIBuilderCreateFile(\n         Builder: &DIBuilder<'a>,\n         Filename: *const c_char,\n+        FilenameLen: size_t,\n         Directory: *const c_char,\n+        DirectoryLen: size_t,\n     ) -> &'a DIFile;\n \n     pub fn LLVMRustDIBuilderCreateSubroutineType(\n@@ -1630,7 +1634,9 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n+        NameLen: size_t,\n         LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         Ty: &'a DIType,\n@@ -1645,6 +1651,7 @@ extern \"C\" {\n     pub fn LLVMRustDIBuilderCreateBasicType(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         SizeInBits: u64,\n         AlignInBits: u32,\n         Encoding: c_uint,\n@@ -1655,13 +1662,16 @@ extern \"C\" {\n         PointeeTy: &'a DIType,\n         SizeInBits: u64,\n         AlignInBits: u32,\n+        AddressSpace: c_uint,\n         Name: *const c_char,\n+        NameLen: size_t,\n     ) -> &'a DIDerivedType;\n \n     pub fn LLVMRustDIBuilderCreateStructType(\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIDescriptor>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1672,12 +1682,14 @@ extern \"C\" {\n         RunTimeLang: c_uint,\n         VTableHolder: Option<&'a DIType>,\n         UniqueId: *const c_char,\n+        UniqueIdLen: size_t,\n     ) -> &'a DICompositeType;\n \n     pub fn LLVMRustDIBuilderCreateMemberType(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         SizeInBits: u64,\n@@ -1691,6 +1703,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1719,7 +1732,9 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Context: Option<&'a DIScope>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         Ty: &'a DIType,\n@@ -1734,6 +1749,7 @@ extern \"C\" {\n         Tag: c_uint,\n         Scope: &'a DIDescriptor,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         Ty: &'a DIType,\n@@ -1785,6 +1801,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1798,6 +1815,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNumber: c_uint,\n         SizeInBits: u64,\n@@ -1806,12 +1824,14 @@ extern \"C\" {\n         Elements: Option<&'a DIArray>,\n         RunTimeLang: c_uint,\n         UniqueId: *const c_char,\n+        UniqueIdLen: size_t,\n     ) -> &'a DIType;\n \n     pub fn LLVMRustDIBuilderCreateVariantPart(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,\n         Name: *const c_char,\n+        NameLen: size_t,\n         File: &'a DIFile,\n         LineNo: c_uint,\n         SizeInBits: u64,\n@@ -1820,6 +1840,7 @@ extern \"C\" {\n         Discriminator: Option<&'a DIDerivedType>,\n         Elements: &'a DIArray,\n         UniqueId: *const c_char,\n+        UniqueIdLen: size_t,\n     ) -> &'a DIDerivedType;\n \n     pub fn LLVMSetUnnamedAddr(GlobalVar: &Value, UnnamedAddr: Bool);\n@@ -1828,6 +1849,7 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n+        NameLen: size_t,\n         Ty: &'a DIType,\n         File: &'a DIFile,\n         LineNo: c_uint,\n@@ -1838,8 +1860,8 @@ extern \"C\" {\n         Builder: &DIBuilder<'a>,\n         Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n-        File: &'a DIFile,\n-        LineNo: c_uint,\n+        NameLen: size_t,\n+        ExportSymbols: bool,\n     ) -> &'a DINameSpace;\n \n     pub fn LLVMRustDICompositeTypeReplaceArrays("}, {"sha": "6d4d7f5b4f394f0c99efb9eae0c27ed46ff129a4", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -750,17 +750,8 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n \n /// The token is an identifier, but not `_`.\n /// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_name(token: &Token) -> Option<(Name, bool)> {\n-    match token.kind {\n-        token::Ident(name, is_raw) if name != kw::Underscore => Some((name, is_raw)),\n-        token::Interpolated(ref nt) => match **nt {\n-            token::NtIdent(ident, is_raw) if ident.name != kw::Underscore => {\n-                Some((ident.name, is_raw))\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n+    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n }\n \n /// Checks whether a non-terminal may begin with a particular token.\n@@ -783,7 +774,7 @@ fn may_begin_with(token: &Token, name: Name) -> bool {\n             && !token.is_keyword(kw::Let)\n         }\n         sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_name(token).is_some(),\n+        sym::ident => get_macro_ident(token).is_some(),\n         sym::literal => token.can_begin_literal_or_bool(),\n         sym::vis => match token.kind {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n@@ -888,9 +879,9 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n         sym::ty => token::NtTy(p.parse_ty()?),\n         // this could be handled like a token, since it is one\n         sym::ident => {\n-            if let Some((name, is_raw)) = get_macro_name(&p.token) {\n+            if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n                 p.bump();\n-                token::NtIdent(Ident::new(name, p.normalized_prev_token.span), is_raw)\n+                token::NtIdent(ident, is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n                 let msg = &format!(\"expected ident, found {}\", &token_str);"}, {"sha": "ffbff00cf376005a6b983d0ddc9c247b1ad67383", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -186,7 +186,12 @@ fn validate_and_turn_into_const<'tcx>(\n         if cid.promoted.is_none() {\n             let mut ref_tracking = RefTracking::new(mplace);\n             while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+                ecx.const_validate_operand(\n+                    mplace.into(),\n+                    path,\n+                    &mut ref_tracking,\n+                    /*may_ref_to_static*/ is_static,\n+                )?;\n             }\n         }\n         // Now that we validated, turn this into a proper constant."}, {"sha": "9b28b7a20c044ef3779e561566cb22b6e52ff866", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -457,10 +457,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Check if this brought us over the size limit.\n                 if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n-                    throw_ub_format!(\n-                        \"wide pointer metadata contains invalid information: \\\n-                        total size is bigger than largest supported object\"\n-                    );\n+                    throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n             }\n@@ -476,10 +473,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Make sure the slice is not too big.\n                 let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n-                    err_ub_format!(\n-                        \"invalid slice: \\\n-                        total size is bigger than largest supported object\"\n-                    )\n+                    err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))\n             }\n@@ -685,7 +679,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // invariant -- that is, unless a function somehow has a ptr to\n                     // its return place... but the way MIR is currently generated, the\n                     // return place is always a local and then this cannot happen.\n-                    self.validate_operand(self.place_to_op(return_place)?, vec![], None)?;\n+                    self.validate_operand(self.place_to_op(return_place)?)?;\n                 }\n             } else {\n                 // Uh, that shouldn't happen... the function did not intend to return"}, {"sha": "a4815b9696ebb5d0d0d2a4c57e3e4d8adb1afe1d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -689,7 +689,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n+            self.validate_operand(self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -706,7 +706,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None)?;\n+            self.validate_operand(dest.into())?;\n         }\n \n         Ok(())\n@@ -843,7 +843,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n+            self.validate_operand(self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -951,7 +951,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None)?;\n+            self.validate_operand(dest.into())?;\n         }\n \n         Ok(())"}, {"sha": "05bb010959b32093e07245b623fa14c4baf8fb0d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -46,13 +46,17 @@ macro_rules! try_validation {\n     ($e:expr, $what:expr, $where:expr, $details:expr) => {{\n         match $e {\n             Ok(x) => x,\n+            // We re-throw the error, so we are okay with allocation:\n+            // this can only slow down builds that fail anyway.\n             Err(_) => throw_validation_failure!($what, $where, $details),\n         }\n     }};\n \n     ($e:expr, $what:expr, $where:expr) => {{\n         match $e {\n             Ok(x) => x,\n+            // We re-throw the error, so we are okay with allocation:\n+            // this can only slow down builds that fail anyway.\n             Err(_) => throw_validation_failure!($what, $where),\n         }\n     }};\n@@ -167,6 +171,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     path: Vec<PathElem>,\n     ref_tracking_for_consts:\n         Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    may_ref_to_static: bool,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n@@ -320,9 +325,17 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n-        let (size, align) = self\n-            .ecx\n-            .size_and_align_of(place.meta, place.layout)?\n+        let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n+            Ok(res) => res,\n+            Err(err) => match err.kind {\n+                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(\n+                    format_args!(\"invalid {} metadata: {}\", kind, msg),\n+                    self.path\n+                ),\n+                _ => bug!(\"Unexpected error during ptr size_and_align_of: {}\", err),\n+            },\n+        };\n+        let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n@@ -359,10 +372,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         format_args!(\"a dangling {} (created from integer)\", kind),\n                         self.path\n                     ),\n-                    _ => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n-                        self.path\n-                    ),\n+                    err_unsup!(PointerOutOfBounds { .. }) | err_unsup!(DanglingPointerDeref) => {\n+                        throw_validation_failure!(\n+                            format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n+                            self.path\n+                        )\n+                    }\n+                    _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n                 }\n             }\n         };\n@@ -380,6 +396,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n                         return Ok(());\n                     }\n+                    if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n+                        throw_validation_failure!(\n+                            format_args!(\"a {} pointing to a static variable\", kind),\n+                            self.path\n+                        );\n+                    }\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!\n@@ -638,6 +660,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 err_unsup!(ReadPointerAsBytes) => {\n                     throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n                 }\n+                // Propagate upwards (that will also check for unexpected errors).\n                 _ => return Err(err),\n             },\n         }\n@@ -773,31 +796,59 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n-    /// is an indirect operand.\n-    /// It will error if the bits at the destination do not match the ones described by the layout.\n-    ///\n-    /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n-    /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n-    /// specific validation checks.\n-    pub fn validate_operand(\n+    fn validate_operand_internal(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking_for_consts: Option<\n             &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n         >,\n+        may_ref_to_static: bool,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n+        trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n-        let mut visitor = ValidityVisitor { path, ref_tracking_for_consts, ecx: self };\n+        let mut visitor =\n+            ValidityVisitor { path, ref_tracking_for_consts, may_ref_to_static, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n         let op = self.force_op_ptr(op).unwrap_or(op);\n \n-        // Run it\n-        visitor.visit_value(op)\n+        // Run it.\n+        match visitor.visit_value(op) {\n+            Ok(()) => Ok(()),\n+            Err(err) if matches!(err.kind, err_unsup!(ValidationFailure { .. })) => Err(err),\n+            Err(err) if cfg!(debug_assertions) => {\n+                bug!(\"Unexpected error during validation: {}\", err)\n+            }\n+            Err(err) => Err(err),\n+        }\n+    }\n+\n+    /// This function checks the data at `op` to be const-valid.\n+    /// `op` is assumed to cover valid memory if it is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    ///\n+    /// `ref_tracking` is used to record references that we encounter so that they\n+    /// can be checked recursively by an outside driving loop.\n+    ///\n+    /// `may_ref_to_static` controls whether references are allowed to point to statics.\n+    #[inline(always)]\n+    pub fn const_validate_operand(\n+        &self,\n+        op: OpTy<'tcx, M::PointerTag>,\n+        path: Vec<PathElem>,\n+        ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n+        may_ref_to_static: bool,\n+    ) -> InterpResult<'tcx> {\n+        self.validate_operand_internal(op, path, Some(ref_tracking), may_ref_to_static)\n+    }\n+\n+    /// This function checks the data at `op` to be runtime-valid.\n+    /// `op` is assumed to cover valid memory if it is an indirect operand.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    #[inline(always)]\n+    pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        self.validate_operand_internal(op, vec![], None, false)\n     }\n }"}, {"sha": "a07c8575b300c9048d9266c8352a3dc67cd61109", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -404,32 +404,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                use rustc::mir::interpret::{\n-                    InterpError::*, UndefinedBehaviorInfo, UnsupportedOpInfo,\n-                };\n-                match error.kind {\n-                    MachineStop(_) => bug!(\"ConstProp does not stop\"),\n-\n-                    // Some error shouldn't come up because creating them causes\n-                    // an allocation, which we should avoid. When that happens,\n-                    // dedicated error variants should be introduced instead.\n-                    // Only test this in debug builds though to avoid disruptions.\n-                    Unsupported(UnsupportedOpInfo::Unsupported(_))\n-                    | Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n-                    | UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n-                    | UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_))\n-                        if cfg!(debug_assertions) =>\n-                    {\n-                        bug!(\"const-prop encountered allocating error: {:?}\", error.kind);\n-                    }\n-\n-                    Unsupported(_)\n-                    | UndefinedBehavior(_)\n-                    | InvalidProgram(_)\n-                    | ResourceExhaustion(_) => {\n-                        // Ignore these errors.\n-                    }\n-                }\n+                // Some errors shouldn't come up because creating them causes\n+                // an allocation, which we should avoid. When that happens,\n+                // dedicated error variants should be introduced instead.\n+                // Only test this in debug builds though to avoid disruptions.\n+                debug_assert!(\n+                    !error.kind.allocates(),\n+                    \"const-prop encountered allocating error: {}\",\n+                    error\n+                );\n                 None\n             }\n         };\n@@ -654,11 +637,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.validate_operand(\n+        if let Err(e) = self.ecx.const_validate_operand(\n             value,\n             vec![],\n             // FIXME: is ref tracking too expensive?\n-            Some(&mut interpret::RefTracking::empty()),\n+            &mut interpret::RefTracking::empty(),\n+            /*may_ref_to_static*/ true,\n         ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;"}, {"sha": "10d524776a11b58c5b5ca2751244f9a1a8805f96", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -4,7 +4,7 @@\n #![feature(crate_visibility_modifier)]\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, Nonterminal, Token};\n+use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n@@ -171,8 +171,7 @@ fn maybe_source_file_to_parser(\n     let mut parser = stream_to_parser(sess, stream, None);\n     parser.unclosed_delims = unclosed_delims;\n     if parser.token == token::Eof {\n-        let span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n-        parser.set_token(Token::new(token::Eof, span));\n+        parser.token.span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n     }\n \n     Ok(parser)"}, {"sha": "7c1df531ad16e341167f193314175c0402f07bd0", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -192,17 +192,19 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(token::DelimToken::Brace),\n             TokenKind::CloseDelim(token::DelimToken::Paren),\n         ];\n-        if let token::Ident(name, false) = self.normalized_token.kind {\n-            if Ident::new(name, self.normalized_token.span).is_raw_guess()\n-                && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n+        match self.token.ident() {\n+            Some((ident, false))\n+                if ident.is_raw_guess()\n+                    && self.look_ahead(1, |t| valid_follow.contains(&t.kind)) =>\n             {\n                 err.span_suggestion(\n-                    self.normalized_token.span,\n+                    ident.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n-                    format!(\"r#{}\", name),\n+                    format!(\"r#{}\", ident.name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n+            _ => {}\n         }\n         if let Some(token_descr) = super::token_descr_opt(&self.token) {\n             err.span_label(self.token.span, format!(\"expected identifier, found {}\", token_descr));"}, {"sha": "16ea2773b200910c058fb3ad911dc8078d8f6362", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -50,7 +50,6 @@ macro_rules! maybe_whole_expr {\n                         AttrVec::new(),\n                     ));\n                 }\n-                // N.B., `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n                 _ => {}\n             };\n         }\n@@ -97,9 +96,9 @@ impl<'a> Parser<'a> {\n     fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n         match self.parse_expr() {\n             Ok(expr) => Ok(expr),\n-            Err(mut err) => match self.normalized_token.kind {\n-                token::Ident(name, false)\n-                    if name == kw::Underscore && self.look_ahead(1, |t| t == &token::Comma) =>\n+            Err(mut err) => match self.token.ident() {\n+                Some((Ident { name: kw::Underscore, .. }, false))\n+                    if self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n@@ -331,21 +330,19 @@ impl<'a> Parser<'a> {\n     ///\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n     fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n-        Some(Spanned {\n-            node: match (AssocOp::from_token(&self.token), &self.normalized_token.kind) {\n-                (Some(op), _) => op,\n-                (None, token::Ident(sym::and, false)) => {\n-                    self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n-                    AssocOp::LAnd\n-                }\n-                (None, token::Ident(sym::or, false)) => {\n-                    self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n-                    AssocOp::LOr\n-                }\n-                _ => return None,\n-            },\n-            span: self.normalized_token.span,\n-        })\n+        let (op, span) = match (AssocOp::from_token(&self.token), self.token.ident()) {\n+            (Some(op), _) => (op, self.token.span),\n+            (None, Some((Ident { name: sym::and, span }, false))) => {\n+                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                (AssocOp::LAnd, span)\n+            }\n+            (None, Some((Ident { name: sym::or, span }, false))) => {\n+                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                (AssocOp::LOr, span)\n+            }\n+            _ => return None,\n+        };\n+        Some(source_map::respan(span, op))\n     }\n \n     /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n@@ -436,7 +433,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n-        let (hi, ex) = match self.normalized_token.kind {\n+        let (hi, ex) = match self.token.uninterpolate().kind {\n             token::Not => self.parse_unary_expr(lo, UnOp::Not), // `!expr`\n             token::Tilde => self.recover_tilde_expr(lo),        // `~expr`\n             token::BinOp(token::Minus) => self.parse_unary_expr(lo, UnOp::Neg), // `-expr`\n@@ -483,7 +480,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_mistaken_not_ident_negation(&self) -> bool {\n-        let token_cannot_continue_expr = |t: &Token| match t.kind {\n+        let token_cannot_continue_expr = |t: &Token| match t.uninterpolate().kind {\n             // These tokens can start an expression after `!`, but\n             // can't continue an expression after an ident\n             token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n@@ -718,20 +715,11 @@ impl<'a> Parser<'a> {\n             expr.map(|mut expr| {\n                 attrs.extend::<Vec<_>>(expr.attrs.into());\n                 expr.attrs = attrs;\n-                self.error_attr_on_if_expr(&expr);\n                 expr\n             })\n         })\n     }\n \n-    fn error_attr_on_if_expr(&self, expr: &Expr) {\n-        if let (ExprKind::If(..), [a0, ..]) = (&expr.kind, &*expr.attrs) {\n-            // Just point to the first attribute in there...\n-            self.struct_span_err(a0.span, \"attributes are not yet allowed on `if` expressions\")\n-                .emit();\n-        }\n-    }\n-\n     fn parse_dot_or_call_expr_with_(&mut self, mut e: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         loop {\n             if self.eat(&token::Question) {\n@@ -756,7 +744,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n-        match self.normalized_token.kind {\n+        match self.token.uninterpolate().kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n                 Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix))\n@@ -850,7 +838,7 @@ impl<'a> Parser<'a> {\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.normalized_token.span.rust_2018() && self.eat_keyword(kw::Await) {\n+        if self.token.uninterpolated_span().rust_2018() && self.eat_keyword(kw::Await) {\n             return self.mk_await_expr(self_arg, lo);\n         }\n \n@@ -964,7 +952,7 @@ impl<'a> Parser<'a> {\n             //       |             ^ expected expression\n             self.bump();\n             Ok(self.mk_expr_err(self.token.span))\n-        } else if self.normalized_token.span.rust_2018() {\n+        } else if self.token.uninterpolated_span().rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {\n                 if self.is_async_block() {\n@@ -1397,11 +1385,14 @@ impl<'a> Parser<'a> {\n         let movability =\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n-        let asyncness =\n-            if self.normalized_token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n-        if asyncness.is_async() {\n+        let asyncness = if self.token.uninterpolated_span().rust_2018() {\n+            self.parse_asyncness()\n+        } else {\n+            Async::No\n+        };\n+        if let Async::Yes { span, .. } = asyncness {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.gate(sym::async_closure, self.normalized_prev_token.span);\n+            self.sess.gated_spans.gate(sym::async_closure, span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n@@ -1757,7 +1748,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&self) -> bool {\n         self.token.is_keyword(kw::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.normalized_token.span.rust_2018() &&\n+        self.token.uninterpolated_span().rust_2018() &&\n         // Prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -1907,20 +1898,23 @@ impl<'a> Parser<'a> {\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n     fn find_struct_error_after_field_looking_code(&self) -> Option<Field> {\n-        if let token::Ident(name, _) = self.normalized_token.kind {\n-            if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                return Some(ast::Field {\n-                    ident: Ident::new(name, self.normalized_token.span),\n+        match self.token.ident() {\n+            Some((ident, is_raw))\n+                if (is_raw || !ident.is_reserved())\n+                    && self.look_ahead(1, |t| *t == token::Colon) =>\n+            {\n+                Some(ast::Field {\n+                    ident,\n                     span: self.token.span,\n                     expr: self.mk_expr_err(self.token.span),\n                     is_shorthand: false,\n                     attrs: AttrVec::new(),\n                     id: DUMMY_NODE_ID,\n                     is_placeholder: false,\n-                });\n+                })\n             }\n+            _ => None,\n         }\n-        None\n     }\n \n     fn recover_struct_comma_after_dotdot(&mut self, span: Span) {"}, {"sha": "126686c8defbf5ee883538f600b744d30303ce51", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -574,7 +574,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| t.is_non_raw_ident_where(|i| i.name != kw::As))\n         {\n             self.bump(); // `default`\n-            Defaultness::Default(self.normalized_prev_token.span)\n+            Defaultness::Default(self.prev_token.uninterpolated_span())\n         } else {\n             Defaultness::Final\n         }\n@@ -750,10 +750,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.normalized_token.kind {\n-            token::Ident(name @ kw::Underscore, false) => {\n+        match self.token.ident() {\n+            Some((ident @ Ident { name: kw::Underscore, .. }, false)) => {\n                 self.bump();\n-                Ok(Ident::new(name, self.normalized_prev_token.span))\n+                Ok(ident)\n             }\n             _ => self.parse_ident(),\n         }\n@@ -1544,7 +1544,9 @@ impl<'a> Parser<'a> {\n \n         let is_name_required = match self.token.kind {\n             token::DotDotDot => false,\n-            _ => req_name(self.normalized_token.span.edition()),\n+            // FIXME: Consider using interpolated token for this edition check,\n+            // it should match the intent of edition hygiene better.\n+            _ => req_name(self.token.uninterpolate().span.edition()),\n         };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n@@ -1609,15 +1611,12 @@ impl<'a> Parser<'a> {\n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         // Extract an identifier *after* having confirmed that the token is one.\n-        let expect_self_ident = |this: &mut Self| {\n-            match this.normalized_token.kind {\n-                // Preserve hygienic context.\n-                token::Ident(name, _) => {\n-                    this.bump();\n-                    Ident::new(name, this.normalized_prev_token.span)\n-                }\n-                _ => unreachable!(),\n+        let expect_self_ident = |this: &mut Self| match this.token.ident() {\n+            Some((ident, false)) => {\n+                this.bump();\n+                ident\n             }\n+            _ => unreachable!(),\n         };\n         // Is `self` `n` tokens ahead?\n         let is_isolated_self = |this: &Self, n| {\n@@ -1651,7 +1650,7 @@ impl<'a> Parser<'a> {\n         // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.token.span;\n-        let (eself, eself_ident, eself_hi) = match self.normalized_token.kind {\n+        let (eself, eself_ident, eself_hi) = match self.token.uninterpolate().kind {\n             token::BinOp(token::And) => {\n                 let eself = if is_isolated_self(self, 1) {\n                     // `&self`"}, {"sha": "9376c7c1c724d15fee382596ae6bb0b40eae5ffc", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 12, "deletions": 44, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -88,21 +88,10 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n-    /// The current non-normalized token.\n+    /// The current token.\n     pub token: Token,\n-    /// The current normalized token.\n-    /// \"Normalized\" means that some interpolated tokens\n-    /// (`$i: ident` and `$l: lifetime` meta-variables) are replaced\n-    /// with non-interpolated identifier and lifetime tokens they refer to.\n-    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n-    /// this also includes edition checks for edition-specific keyword identifiers.\n-    pub normalized_token: Token,\n-    /// The previous non-normalized token.\n+    /// The previous token.\n     pub prev_token: Token,\n-    /// The previous normalized token.\n-    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n-    /// this also includes edition checks for edition-specific keyword identifiers.\n-    pub normalized_prev_token: Token,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n     pub(super) directory: Directory,\n@@ -374,9 +363,7 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n-            normalized_prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n@@ -480,9 +467,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n-        match self.normalized_token.kind {\n-            token::Ident(name, _) => {\n-                if self.token.is_reserved_ident() {\n+        match self.token.ident() {\n+            Some((ident, is_raw)) => {\n+                if !is_raw && ident.is_reserved() {\n                     let mut err = self.expected_ident_found();\n                     if recover {\n                         err.emit();\n@@ -491,7 +478,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 self.bump();\n-                Ok(Ident::new(name, self.normalized_prev_token.span))\n+                Ok(ident)\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {\n@@ -609,7 +596,7 @@ impl<'a> Parser<'a> {\n             Some((first, second)) if first == expected => {\n                 let first_span = self.sess.source_map().start_point(self.token.span);\n                 let second_span = self.token.span.with_lo(first_span.hi());\n-                self.set_token(Token::new(first, first_span));\n+                self.token = Token::new(first, first_span);\n                 self.bump_with(Token::new(second, second_span));\n                 true\n             }\n@@ -817,23 +804,6 @@ impl<'a> Parser<'a> {\n         self.parse_delim_comma_seq(token::Paren, f)\n     }\n \n-    // Interpolated identifier (`$i: ident`) and lifetime (`$l: lifetime`)\n-    // tokens are replaced with usual identifier and lifetime tokens,\n-    // so the former are never encountered during normal parsing.\n-    crate fn set_token(&mut self, token: Token) {\n-        self.token = token;\n-        self.normalized_token = match &self.token.kind {\n-            token::Interpolated(nt) => match **nt {\n-                token::NtIdent(ident, is_raw) => {\n-                    Token::new(token::Ident(ident.name, is_raw), ident.span)\n-                }\n-                token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n-                _ => self.token.clone(),\n-            },\n-            _ => self.token.clone(),\n-        }\n-    }\n-\n     /// Advance the parser by one token using provided token as the next one.\n     fn bump_with(&mut self, next_token: Token) {\n         // Bumping after EOF is a bad sign, usually an infinite loop.\n@@ -843,9 +813,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // Update the current and previous tokens.\n-        self.prev_token = self.token.take();\n-        self.normalized_prev_token = self.normalized_token.take();\n-        self.set_token(next_token);\n+        self.prev_token = mem::replace(&mut self.token, next_token);\n \n         // Diagnostics.\n         self.expected_tokens.clear();\n@@ -884,7 +852,7 @@ impl<'a> Parser<'a> {\n     /// Parses asyncness: `async` or nothing.\n     fn parse_asyncness(&mut self) -> Async {\n         if self.eat_keyword(kw::Async) {\n-            let span = self.normalized_prev_token.span;\n+            let span = self.prev_token.uninterpolated_span();\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n             Async::No\n@@ -894,7 +862,7 @@ impl<'a> Parser<'a> {\n     /// Parses unsafety: `unsafe` or nothing.\n     fn parse_unsafety(&mut self) -> Unsafe {\n         if self.eat_keyword(kw::Unsafe) {\n-            Unsafe::Yes(self.normalized_prev_token.span)\n+            Unsafe::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Unsafe::No\n         }\n@@ -903,7 +871,7 @@ impl<'a> Parser<'a> {\n     /// Parses constness: `const` or nothing.\n     fn parse_constness(&mut self) -> Const {\n         if self.eat_keyword(kw::Const) {\n-            Const::Yes(self.normalized_prev_token.span)\n+            Const::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Const::No\n         }\n@@ -1005,7 +973,7 @@ impl<'a> Parser<'a> {\n                     &mut self.token_cursor.frame,\n                     self.token_cursor.stack.pop().unwrap(),\n                 );\n-                self.set_token(Token::new(TokenKind::CloseDelim(frame.delim), frame.span.close));\n+                self.token = Token::new(TokenKind::CloseDelim(frame.delim), frame.span.close);\n                 self.bump();\n                 TokenTree::Delimited(frame.span, frame.delim, frame.tree_cursor.stream)\n             }"}, {"sha": "f52a91ff5989dd06343224768e54c09d5dc2386f", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -151,7 +151,7 @@ impl<'a> Parser<'a> {\n     /// Note that there are more tokens such as `@` for which we know that the `|`\n     /// is an illegal parse. However, the user's intent is less clear in that case.\n     fn recover_trailing_vert(&mut self, lo: Option<Span>) -> bool {\n-        let is_end_ahead = self.look_ahead(1, |token| match &token.kind {\n+        let is_end_ahead = self.look_ahead(1, |token| match &token.uninterpolate().kind {\n             token::FatArrow // e.g. `a | => 0,`.\n             | token::Ident(kw::If, false) // e.g. `a | if expr`.\n             | token::Eq // e.g. `let a | = 0`."}, {"sha": "f88b4fe6ff0a8dfedec357ab9a8802e6797599ce", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -240,10 +240,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n-        match self.normalized_token.kind {\n-            token::Ident(name, _) if name.is_path_segment_keyword() => {\n+        match self.token.ident() {\n+            Some((ident, false)) if ident.is_path_segment_keyword() => {\n                 self.bump();\n-                Ok(Ident::new(name, self.normalized_prev_token.span))\n+                Ok(ident)\n             }\n             _ => self.parse_ident(),\n         }"}, {"sha": "16adf5c05a4eeafa9d5284052340fe0d080d32b6", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -323,7 +323,7 @@ impl<'a> Parser<'a> {\n     /// Is a `dyn B0 + ... + Bn` type allowed here?\n     fn is_explicit_dyn_type(&mut self) -> bool {\n         self.check_keyword(kw::Dyn)\n-            && (self.normalized_token.span.rust_2018()\n+            && (self.token.uninterpolated_span().rust_2018()\n                 || self.look_ahead(1, |t| {\n                     t.can_begin_bound() && !can_continue_type_after_non_fn_ident(t)\n                 }))"}, {"sha": "9e8be55075578611593cf9e71f1f7c2972f90c44", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -13,6 +13,10 @@ impl Handler {\n     pub unsafe fn new() -> Handler {\n         make_handler()\n     }\n+\n+    fn null() -> Handler {\n+        Handler { _data: crate::ptr::null_mut() }\n+    }\n }\n \n impl Drop for Handler {\n@@ -108,13 +112,20 @@ mod imp {\n     }\n \n     static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n+    static mut NEED_ALTSTACK: bool = false;\n \n     pub unsafe fn init() {\n         let mut action: sigaction = mem::zeroed();\n-        action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n-        action.sa_sigaction = signal_handler as sighandler_t;\n-        sigaction(SIGSEGV, &action, ptr::null_mut());\n-        sigaction(SIGBUS, &action, ptr::null_mut());\n+        for &signal in &[SIGSEGV, SIGBUS] {\n+            sigaction(signal, ptr::null_mut(), &mut action);\n+            // Configure our signal handler if one is not already set.\n+            if action.sa_sigaction == SIG_DFL {\n+                action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n+                action.sa_sigaction = signal_handler as sighandler_t;\n+                sigaction(signal, &action, ptr::null_mut());\n+                NEED_ALTSTACK = true;\n+            }\n+        }\n \n         let handler = make_handler();\n         MAIN_ALTSTACK = handler._data;\n@@ -152,6 +163,9 @@ mod imp {\n     }\n \n     pub unsafe fn make_handler() -> Handler {\n+        if !NEED_ALTSTACK {\n+            return Handler::null();\n+        }\n         let mut stack = mem::zeroed();\n         sigaltstack(ptr::null(), &mut stack);\n         // Configure alternate signal stack, if one is not already set.\n@@ -160,7 +174,7 @@ mod imp {\n             sigaltstack(&stack, ptr::null_mut());\n             Handler { _data: stack.ss_sp as *mut libc::c_void }\n         } else {\n-            Handler { _data: ptr::null_mut() }\n+            Handler::null()\n         }\n     }\n \n@@ -191,14 +205,12 @@ mod imp {\n     target_os = \"openbsd\"\n )))]\n mod imp {\n-    use crate::ptr;\n-\n     pub unsafe fn init() {}\n \n     pub unsafe fn cleanup() {}\n \n     pub unsafe fn make_handler() -> super::Handler {\n-        super::Handler { _data: ptr::null_mut() }\n+        super::Handler::null()\n     }\n \n     pub unsafe fn drop_handler(_handler: &mut super::Handler) {}"}, {"sha": "aeddd4cfb9fe9f32444e768f9a2278418f8bb402", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 87, "deletions": 59, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -665,20 +665,24 @@ extern \"C\" void LLVMRustDIBuilderFinalize(LLVMRustDIBuilderRef Builder) {\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n     LLVMRustDIBuilderRef Builder, unsigned Lang, LLVMMetadataRef FileRef,\n-    const char *Producer, bool isOptimized, const char *Flags,\n-    unsigned RuntimeVer, const char *SplitName,\n+    const char *Producer, size_t ProducerLen, bool isOptimized,\n+    const char *Flags, unsigned RuntimeVer,\n+    const char *SplitName, size_t SplitNameLen,\n     LLVMRustDebugEmissionKind Kind) {\n   auto *File = unwrapDI<DIFile>(FileRef);\n \n-  return wrap(Builder->createCompileUnit(Lang, File, Producer, isOptimized,\n-                                         Flags, RuntimeVer, SplitName,\n+  return wrap(Builder->createCompileUnit(Lang, File, StringRef(Producer, ProducerLen),\n+                                         isOptimized, Flags, RuntimeVer,\n+                                         StringRef(SplitName, SplitNameLen),\n                                          fromRust(Kind)));\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateFile(LLVMRustDIBuilderRef Builder, const char *Filename,\n-                            const char *Directory) {\n-  return wrap(Builder->createFile(Filename, Directory));\n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFile(\n+    LLVMRustDIBuilderRef Builder,\n+    const char *Filename, size_t FilenameLen,\n+    const char *Directory, size_t DirectoryLen) {\n+  return wrap(Builder->createFile(StringRef(Filename, FilenameLen),\n+                                  StringRef(Directory, DirectoryLen)));\n }\n \n extern \"C\" LLVMMetadataRef\n@@ -690,8 +694,10 @@ LLVMRustDIBuilderCreateSubroutineType(LLVMRustDIBuilderRef Builder,\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n-    const char *LinkageName, LLVMMetadataRef File, unsigned LineNo,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, unsigned ScopeLine, LLVMRustDIFlags Flags,\n     LLVMRustDISPFlags SPFlags, LLVMValueRef Fn, LLVMMetadataRef TParam,\n     LLVMMetadataRef Decl) {\n@@ -705,8 +711,11 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n     llvmFlags |= DINode::DIFlags::FlagMainSubprogram;\n #endif\n   DISubprogram *Sub = Builder->createFunction(\n-      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n-      LineNo, unwrapDI<DISubroutineType>(Ty), ScopeLine, llvmFlags,\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty), ScopeLine, llvmFlags,\n       llvmSPFlags, TParams, unwrapDIPtr<DISubprogram>(Decl));\n #else\n   bool IsLocalToUnit = isSet(SPFlags & LLVMRustDISPFlags::SPFlagLocalToUnit);\n@@ -716,77 +725,87 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n   if (isSet(SPFlags & LLVMRustDISPFlags::SPFlagMainSubprogram))\n     llvmFlags |= DINode::DIFlags::FlagMainSubprogram;\n   DISubprogram *Sub = Builder->createFunction(\n-      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n-      LineNo, unwrapDI<DISubroutineType>(Ty), IsLocalToUnit, IsDefinition,\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty), IsLocalToUnit, IsDefinition,\n       ScopeLine, llvmFlags, IsOptimized, TParams,\n       unwrapDIPtr<DISubprogram>(Decl));\n #endif\n   unwrap<Function>(Fn)->setSubprogram(Sub);\n   return wrap(Sub);\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateBasicType(LLVMRustDIBuilderRef Builder, const char *Name,\n-                                 uint64_t SizeInBits, uint32_t AlignInBits,\n-                                 unsigned Encoding) {\n-  return wrap(Builder->createBasicType(Name, SizeInBits, Encoding));\n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateBasicType(\n+    LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n+    uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding) {\n+  return wrap(Builder->createBasicType(StringRef(Name, NameLen), SizeInBits, Encoding));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreatePointerType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef PointeeTy,\n-    uint64_t SizeInBits, uint32_t AlignInBits, const char *Name) {\n+    uint64_t SizeInBits, uint32_t AlignInBits, unsigned AddressSpace,\n+    const char *Name, size_t NameLen) {\n   return wrap(Builder->createPointerType(unwrapDI<DIType>(PointeeTy),\n                                          SizeInBits, AlignInBits,\n-                                         /* DWARFAddressSpace */ None,\n-                                         Name));\n+                                         AddressSpace,\n+                                         StringRef(Name, NameLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStructType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMRustDIFlags Flags,\n     LLVMMetadataRef DerivedFrom, LLVMMetadataRef Elements,\n     unsigned RunTimeLang, LLVMMetadataRef VTableHolder,\n-    const char *UniqueId) {\n+    const char *UniqueId, size_t UniqueIdLen) {\n   return wrap(Builder->createStructType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+      unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIType>(DerivedFrom),\n       DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n-      unwrapDI<DIType>(VTableHolder), UniqueId));\n+      unwrapDI<DIType>(VTableHolder), StringRef(UniqueId, UniqueIdLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantPart(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMMetadataRef Discriminator,\n-    LLVMMetadataRef Elements, const char *UniqueId) {\n+    LLVMMetadataRef Elements, const char *UniqueId, size_t UniqueIdLen) {\n   return wrap(Builder->createVariantPart(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+      unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIDerivedType>(Discriminator),\n-      DINodeArray(unwrapDI<MDTuple>(Elements)), UniqueId));\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), StringRef(UniqueId, UniqueIdLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMemberType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n     uint32_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n     LLVMMetadataRef Ty) {\n-  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope),\n+                                        StringRef(Name, NameLen),\n                                         unwrapDI<DIFile>(File), LineNo,\n                                         SizeInBits, AlignInBits, OffsetInBits,\n                                         fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantMemberType(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n-    const char *Name, LLVMMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n-    uint32_t AlignInBits, uint64_t OffsetInBits, LLVMValueRef Discriminant,\n+    const char *Name, size_t NameLen, LLVMMetadataRef File, unsigned LineNo,\n+    uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits, LLVMValueRef Discriminant,\n     LLVMRustDIFlags Flags, LLVMMetadataRef Ty) {\n   llvm::ConstantInt* D = nullptr;\n   if (Discriminant) {\n     D = unwrap<llvm::ConstantInt>(Discriminant);\n   }\n-  return wrap(Builder->createVariantMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+  return wrap(Builder->createVariantMemberType(unwrapDI<DIDescriptor>(Scope),\n+                                               StringRef(Name, NameLen),\n                                                unwrapDI<DIFile>(File), LineNo,\n                                                SizeInBits, AlignInBits, OffsetInBits, D,\n                                                fromRust(Flags), unwrapDI<DIType>(Ty)));\n@@ -808,8 +827,10 @@ LLVMRustDIBuilderCreateLexicalBlockFile(LLVMRustDIBuilderRef Builder,\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Context, const char *Name,\n-    const char *LinkageName, LLVMMetadataRef File, unsigned LineNo,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Context,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, bool IsLocalToUnit, LLVMValueRef V,\n     LLVMMetadataRef Decl = nullptr, uint32_t AlignInBits = 0) {\n   llvm::GlobalVariable *InitVal = cast<llvm::GlobalVariable>(unwrap(V));\n@@ -825,7 +846,8 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n   }\n \n   llvm::DIGlobalVariableExpression *VarExpr = Builder->createGlobalVariableExpression(\n-      unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n+      unwrapDI<DIDescriptor>(Context), StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n       unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), IsLocalToUnit,\n #if LLVM_VERSION_GE(10, 0)\n       /* isDefined */ true,\n@@ -843,17 +865,20 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariable(\n     LLVMRustDIBuilderRef Builder, unsigned Tag, LLVMMetadataRef Scope,\n-    const char *Name, LLVMMetadataRef File, unsigned LineNo,\n+    const char *Name, size_t NameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, bool AlwaysPreserve, LLVMRustDIFlags Flags,\n     unsigned ArgNo, uint32_t AlignInBits) {\n   if (Tag == 0x100) { // DW_TAG_auto_variable\n     return wrap(Builder->createAutoVariable(\n-        unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+        unwrapDI<DIFile>(File), LineNo,\n         unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags), AlignInBits));\n   } else {\n     return wrap(Builder->createParameterVariable(\n-        unwrapDI<DIDescriptor>(Scope), Name, ArgNo, unwrapDI<DIFile>(File),\n-        LineNo, unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags)));\n+        unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), ArgNo,\n+        unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags)));\n   }\n }\n \n@@ -894,47 +919,50 @@ extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerator(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     int64_t Value, bool IsUnsigned) {\n-  return wrap(Builder->createEnumerator({Name, NameLen}, Value, IsUnsigned));\n+  return wrap(Builder->createEnumerator(StringRef(Name, NameLen), Value, IsUnsigned));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMMetadataRef Elements,\n     LLVMMetadataRef ClassTy, bool IsScoped) {\n   return wrap(Builder->createEnumerationType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen),\n+      unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n       unwrapDI<DIType>(ClassTy), \"\", IsScoped));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateUnionType(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint32_t AlignInBits, LLVMRustDIFlags Flags, LLVMMetadataRef Elements,\n-    unsigned RunTimeLang, const char *UniqueId) {\n+    unsigned RunTimeLang, const char *UniqueId, size_t UniqueIdLen) {\n   return wrap(Builder->createUnionType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n-      SizeInBits, AlignInBits, fromRust(Flags),\n-      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang, UniqueId));\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIFile>(File),\n+      LineNumber, SizeInBits, AlignInBits, fromRust(Flags),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n+      StringRef(UniqueId, UniqueIdLen)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n-    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope, const char *Name,\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n     LLVMMetadataRef Ty, LLVMMetadataRef File, unsigned LineNo,\n     unsigned ColumnNo) {\n   return wrap(Builder->createTemplateTypeParameter(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIType>(Ty)));\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), unwrapDI<DIType>(Ty)));\n }\n \n-extern \"C\" LLVMMetadataRef\n-LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n-                                 LLVMMetadataRef Scope, const char *Name,\n-                                 LLVMMetadataRef File, unsigned LineNo) {\n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateNameSpace(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen, bool ExportSymbols) {\n   return wrap(Builder->createNameSpace(\n-      unwrapDI<DIDescriptor>(Scope), Name,\n-      false // ExportSymbols (only relevant for C++ anonymous namespaces)\n-      ));\n+      unwrapDI<DIDescriptor>(Scope), StringRef(Name, NameLen), ExportSymbols\n+  ));\n }\n \n extern \"C\" void"}, {"sha": "652604fc7f34b2808e6af7db558ab27189ab332e", "filename": "src/test/pretty/if-attr.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fpretty%2Fif-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fpretty%2Fif-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fif-attr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,37 @@\n+// pp-exact\n+\n+#[cfg(FALSE)]\n+fn simple_attr() {\n+\n+    #[attr]\n+    if true { }\n+\n+    #[allow_warnings]\n+    if true { }\n+}\n+\n+#[cfg(FALSE)]\n+fn if_else_chain() {\n+\n+    #[first_attr]\n+    if true { } else if false { } else { }\n+}\n+\n+#[cfg(FALSE)]\n+fn if_let() {\n+\n+    #[attr]\n+    if let Some(_) = Some(true) { }\n+}\n+\n+#[cfg(FALSE)]\n+fn let_attr_if() {\n+    let _ = #[attr] if let _ = 0 { };\n+    let _ = #[attr] if true { };\n+\n+    let _ = #[attr] if let _ = 0 { } else { };\n+    let _ = #[attr] if true { } else { };\n+}\n+\n+\n+fn main() { }"}, {"sha": "16cf7ad52e4f9a84eedad3abee777aaf98073d91", "filename": "src/test/ui/async-await/issue-54239-private-type-triggers-lint.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fasync-await%2Fissue-54239-private-type-triggers-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fasync-await%2Fissue-54239-private-type-triggers-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-54239-private-type-triggers-lint.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,17 @@\n+// Regression test for #54239, shouldn't trigger lint.\n+// check-pass\n+// edition:2018\n+\n+#![deny(missing_debug_implementations)]\n+\n+struct DontLookAtMe(i32);\n+\n+async fn secret() -> DontLookAtMe {\n+    DontLookAtMe(41)\n+}\n+\n+pub async fn looking() -> i32 { // Shouldn't trigger lint here.\n+    secret().await.0\n+}\n+\n+fn main() {}"}, {"sha": "c6b8e8eb611819a10c9af6cb0da142ca8a246158", "filename": "src/test/ui/consts/const-eval/dangling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -6,7 +6,7 @@ use std::{mem, usize};\n const TEST: () = { unsafe { //~ NOTE\n     let slice: *const [u8] = mem::transmute((1usize, usize::MAX));\n     let _val = &*slice; //~ ERROR: any use of this value will cause an error\n-    //~^ NOTE: total size is bigger than largest supported object\n+    //~^ NOTE: slice is bigger than largest supported object\n     //~^^ on by default\n } };\n "}, {"sha": "b9ddc93b03b84e942dfc318b09c2d48b275743fd", "filename": "src/test/ui/consts/const-eval/dangling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdangling.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | / const TEST: () = { unsafe {\n LL | |     let slice: *const [u8] = mem::transmute((1usize, usize::MAX));\n LL | |     let _val = &*slice;\n-   | |                ^^^^^^^ invalid slice: total size is bigger than largest supported object\n+   | |                ^^^^^^^ invalid metadata in wide pointer: slice is bigger than largest supported object\n LL | |\n LL | |\n LL | | } };"}, {"sha": "2d48309b727229354512ca82cad09ce87a9ff9ed", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -31,12 +31,16 @@ const STR_VALID: &str = unsafe { mem::transmute((&42u8, 1usize)) };\n // bad str\n const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+//~^ ERROR it is undefined behavior to use this value\n // bad str\n const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad str in user-defined unsized type\n const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n+const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n \n // invalid UTF-8\n const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n@@ -83,7 +87,7 @@ const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute\n // # raw slice\n const RAW_SLICE_VALID: *const [u8] = unsafe { mem::transmute((&42u8, 1usize)) }; // ok\n const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, 999usize)) }; // ok because raw\n-const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::max_value())) }; // ok because raw\n+const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::MAX)) }; // ok because raw\n const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n //~^ ERROR it is undefined behavior to use this value\n     let uninit_len = MaybeUninit::<usize> { uninit: () };"}, {"sha": "a562c64b124f99e36c73b838f24976bdd54f2013", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -7,15 +7,23 @@ LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:35:1\n+  --> $DIR/ub-wide-ptr.rs:34:1\n+   |\n+LL | const NESTED_STR_MUCH_TOO_LONG: (&str,) = (unsafe { mem::transmute((&42, usize::MAX)) },);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object at .0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:37:1\n    |\n LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:38:1\n+  --> $DIR/ub-wide-ptr.rs:40:1\n    |\n LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -25,21 +33,29 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:42:1\n    |\n+LL | const MY_STR_MUCH_TOO_LONG: &MyStr = unsafe { mem::transmute((&42u8, usize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:46:1\n+   |\n LL | const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:45:1\n+  --> $DIR/ub-wide-ptr.rs:49:1\n    |\n LL | const MYSTR_NO_UTF8: &MyStr = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:52:1\n+  --> $DIR/ub-wide-ptr.rs:56:1\n    |\n LL | / const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n LL | |\n@@ -51,63 +67,63 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:58:1\n+  --> $DIR/ub-wide-ptr.rs:62:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:61:1\n+  --> $DIR/ub-wide-ptr.rs:65:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:64:1\n+  --> $DIR/ub-wide-ptr.rs:68:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:67:1\n+  --> $DIR/ub-wide-ptr.rs:71:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:71:1\n+  --> $DIR/ub-wide-ptr.rs:75:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:81:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:80:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:91:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -119,65 +135,65 @@ LL | | };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:99:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:98:1\n+  --> $DIR/ub-wide-ptr.rs:102:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:101:1\n+  --> $DIR/ub-wide-ptr.rs:105:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:109:1\n+  --> $DIR/ub-wide-ptr.rs:113:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:115:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:117:5\n+  --> $DIR/ub-wide-ptr.rs:121:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid use of NULL pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:121:5\n+  --> $DIR/ub-wide-ptr.rs:125:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f2ca7ff782591d0b45d8e9598f708a2c2a1ddf5e", "filename": "src/test/ui/consts/const-points-to-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -8,7 +8,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-points-to-static.rs:5:1\n    |\n LL | const TEST: &u8 = &MY_STATIC;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "5e85be45b164711a54c96d36519996e76263d345", "filename": "src/test/ui/consts/issue-63952.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -8,7 +8,7 @@ LL | |             ptr: &42,\n ...  |\n LL | |     .slice\n LL | | };\n-   | |__^ invalid slice: total size is bigger than largest supported object\n+   | |__^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "ad777cfe8ea4bcb2d52a6a4b393e620a825bd4c0", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -48,7 +48,7 @@ LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n LL | |\n LL | | };\n-   | |__^ constant accesses static\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -97,7 +97,7 @@ LL | |     static FOO: usize = 0;\n LL | |     &FOO\n LL | |\n LL | | };\n-   | |__^ constant accesses static\n+   | |__^ type validation failed: encountered a reference pointing to a static variable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "2cbe8f5161465b11258f799d2c4e7c89de2365d3", "filename": "src/test/ui/generator/issue-64620-yield-array-element.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fgenerator%2Fissue-64620-yield-array-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fgenerator%2Fissue-64620-yield-array-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-64620-yield-array-element.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,9 @@\n+// Regression test for #64620\n+\n+#![feature(generators)]\n+\n+pub fn crash(arr: [usize; 1]) {\n+    yield arr[0]; //~ ERROR: yield expression outside of generator literal\n+}\n+\n+fn main() {}"}, {"sha": "48383c2ed08243ed884c6d4e86a6e36da89bff35", "filename": "src/test/ui/generator/issue-64620-yield-array-element.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fgenerator%2Fissue-64620-yield-array-element.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fgenerator%2Fissue-64620-yield-array-element.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-64620-yield-array-element.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,9 @@\n+error[E0627]: yield expression outside of generator literal\n+  --> $DIR/issue-64620-yield-array-element.rs:6:5\n+   |\n+LL |     yield arr[0];\n+   |     ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0627`."}, {"sha": "3f84929a00e4f4e5a1896ab93cf6a55946b83c17", "filename": "src/test/ui/if-attrs/bad-cfg.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fbad-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fbad-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fbad-cfg.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,5 @@\n+#![feature(stmt_expr_attributes)]\n+\n+fn main() {\n+    let _ = #[cfg(FALSE)] if true {}; //~ ERROR removing an expression\n+}"}, {"sha": "8a2890886a15c9a9b8c951507b48fcddddce2af3", "filename": "src/test/ui/if-attrs/bad-cfg.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fbad-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fbad-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fbad-cfg.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,8 @@\n+error: removing an expression is not supported in this position\n+  --> $DIR/bad-cfg.rs:4:13\n+   |\n+LL |     let _ = #[cfg(FALSE)] if true {};\n+   |             ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7e290661501c9c36eb05c0e395a9e27e5c5b0bc3", "filename": "src/test/ui/if-attrs/builtin-if-attr.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fbuiltin-if-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fbuiltin-if-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fbuiltin-if-attr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+fn main() {\n+    #[allow(unused_variables)]\n+    if true {\n+        let a = 1;\n+    } else if false {\n+        let b = 1;\n+    } else {\n+        let c = 1;\n+    }\n+}"}, {"sha": "1f77a1bb3427db868b975ebdf12473ab5e147542", "filename": "src/test/ui/if-attrs/cfg-false-if-attr.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fcfg-false-if-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fcfg-false-if-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fcfg-false-if-attr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+\n+#[cfg(FALSE)]\n+fn simple_attr() {\n+    #[attr] if true {}\n+    #[allow_warnings] if true {}\n+}\n+\n+#[cfg(FALSE)]\n+fn if_else_chain() {\n+    #[first_attr] if true {\n+    } else if false {\n+    } else {\n+    }\n+}\n+\n+#[cfg(FALSE)]\n+fn if_let() {\n+    #[attr] if let Some(_) = Some(true) {}\n+}\n+\n+fn bar() {\n+    #[cfg(FALSE)]\n+    if true {\n+        let x: () = true; // Should not error due to the #[cfg(FALSE)]\n+    }\n+\n+    #[cfg_attr(not(unset_attr), cfg(FALSE))]\n+    if true {\n+        let a: () = true; // Should not error due to the applied #[cfg(FALSE)]\n+    }\n+}\n+\n+macro_rules! custom_macro {\n+    ($expr:expr) => {}\n+}\n+\n+custom_macro! {\n+    #[attr] if true {}\n+}\n+\n+\n+fn main() {}"}, {"sha": "4394b2100c1b547229b80127d66e1795ddc20d9d", "filename": "src/test/ui/if-attrs/else-attrs.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,25 @@\n+#[cfg(FALSE)]\n+fn if_else_parse_error() {\n+    if true {\n+    } #[attr] else if false { //~ ERROR expected\n+    }\n+}\n+\n+#[cfg(FALSE)]\n+fn else_attr_ifparse_error() {\n+    if true {\n+    } else #[attr] if false { //~ ERROR expected\n+    } else {\n+    }\n+}\n+\n+#[cfg(FALSE)]\n+fn else_parse_error() {\n+    if true {\n+    } else if false {\n+    } #[attr] else { //~ ERROR expected\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "af25b6abc0a3ad77a2efe11125da7c9d0fe7bdb1", "filename": "src/test/ui/if-attrs/else-attrs.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Felse-attrs.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,27 @@\n+error: expected expression, found keyword `else`\n+  --> $DIR/else-attrs.rs:4:15\n+   |\n+LL |     } #[attr] else if false {\n+   |               ^^^^ expected expression\n+\n+error: expected `{`, found `#`\n+  --> $DIR/else-attrs.rs:11:12\n+   |\n+LL |     } else #[attr] if false {\n+   |            ^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |     } else #[attr] { if false {\n+LL |     } else {\n+LL |     } }\n+   |\n+\n+error: expected expression, found keyword `else`\n+  --> $DIR/else-attrs.rs:20:15\n+   |\n+LL |     } #[attr] else {\n+   |               ^^^^ expected expression\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "63772d54b531dacdaca24a706900e90abf75683f", "filename": "src/test/ui/if-attrs/gate-whole-expr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fgate-whole-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fgate-whole-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fgate-whole-expr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+fn main() {\n+    let x = 1;\n+\n+    #[cfg(FALSE)]\n+    if false {\n+        x = 2;\n+    } else if true {\n+        x = 3;\n+    } else {\n+        x = 4;\n+    }\n+    assert_eq!(x, 1);\n+}"}, {"sha": "5237a9ff3961a060c3d459f0e985bddc2bad9a16", "filename": "src/test/ui/if-attrs/let-chains-attr.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Flet-chains-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Flet-chains-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Flet-chains-attr.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(let_chains)] //~ WARN the feature `let_chains` is incomplete\n+\n+#[cfg(FALSE)]\n+fn foo() {\n+    #[attr]\n+    if let Some(_) = Some(true) && let Ok(_) = Ok(1) {\n+    } else if let Some(false) = Some(true) {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a6c91bb9203b3b180ea37b3a46ae3cb6234e4316", "filename": "src/test/ui/if-attrs/let-chains-attr.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Flet-chains-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Flet-chains-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Flet-chains-attr.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `let_chains` is incomplete and may cause the compiler to crash\n+  --> $DIR/let-chains-attr.rs:3:12\n+   |\n+LL | #![feature(let_chains)]\n+   |            ^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "38599c8e67c4e94dbd4ccbd66b40987957065df0", "filename": "src/test/ui/if-attrs/stmt-expr-gated.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fstmt-expr-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fstmt-expr-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fstmt-expr-gated.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let _ = #[deny(warnings)] if true { //~ ERROR attributes on expressions\n+    } else if false {\n+    } else {\n+    };\n+}"}, {"sha": "47dac39a9ae88563bcbfd92ed05bc5f0ad4c6302", "filename": "src/test/ui/if-attrs/stmt-expr-gated.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fstmt-expr-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fif-attrs%2Fstmt-expr-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-attrs%2Fstmt-expr-gated.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/stmt-expr-gated.rs:2:13\n+   |\n+LL |     let _ = #[deny(warnings)] if true {\n+   |             ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e0c71d1ac9a61cb59081935d61c13f4d6a02a858", "filename": "src/test/ui/impl-trait/issue-57200.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57200.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for #57200\n+// FIXME: The error is temporary hack, we'll revisit here at some point.\n+\n+#![feature(impl_trait_in_bindings)]\n+#![allow(incomplete_features)]\n+\n+fn bug<'a, 'b, T>()\n+where\n+    'a: 'b,\n+{\n+    let f: impl Fn(&'a T) -> &'b T = |x| x;\n+    //~^ ERROR: lifetimes in impl Trait types in bindings are not currently supported\n+}\n+\n+fn main() {}"}, {"sha": "b44f332d58ccdc9f9cde8ec280a8cfac0e49f4c2", "filename": "src/test/ui/impl-trait/issue-57200.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57200.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57200.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57200.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,8 @@\n+error: lifetimes in impl Trait types in bindings are not currently supported\n+  --> $DIR/issue-57200.rs:11:12\n+   |\n+LL |     let f: impl Fn(&'a T) -> &'b T = |x| x;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c1a98d8897bfbd075373d1ddfad1ae2fa86a95a6", "filename": "src/test/ui/impl-trait/issue-57201.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57201.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for #57201\n+// FIXME: The error is temporary hack, we'll revisit here at some point.\n+\n+#![feature(impl_trait_in_bindings)]\n+#![allow(incomplete_features)]\n+\n+fn bug<'a, 'b, T>()\n+where\n+    'a: 'b,\n+{\n+    let f: &impl Fn(&'a T) -> &'b T = &|x| x;\n+    //~^ ERROR: lifetimes in impl Trait types in bindings are not currently supported\n+}\n+\n+fn main() {}"}, {"sha": "462b17bf45e2f71e63789debb4ccd800950daac4", "filename": "src/test/ui/impl-trait/issue-57201.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57201.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57201.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57201.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,8 @@\n+error: lifetimes in impl Trait types in bindings are not currently supported\n+  --> $DIR/issue-57201.rs:11:13\n+   |\n+LL |     let f: &impl Fn(&'a T) -> &'b T = &|x| x;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "50cf0c8c6d641dfdce25f8e2899d1740a3580a99", "filename": "src/test/ui/impl-trait/issue-60473.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,17 @@\n+// Regression test for #60473\n+\n+#![feature(impl_trait_in_bindings)]\n+#![allow(incomplete_features)]\n+\n+struct A<'a>(&'a ());\n+\n+trait Trait<T> {\n+}\n+\n+impl<T> Trait<T> for () {\n+}\n+\n+fn main() {\n+    let x: impl Trait<A> = (); // FIXME: The error doesn't seem correct.\n+    //~^ ERROR: opaque type expands to a recursive type\n+}"}, {"sha": "2d95be4e52c61b34c52a78d7a9b3782c61f8ac14", "filename": "src/test/ui/impl-trait/issue-60473.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-60473.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,11 @@\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/issue-60473.rs:15:12\n+   |\n+LL |     let x: impl Trait<A> = (); // FIXME: The error doesn't seem correct.\n+   |            ^^^^^^^^^^^^^ expands to a recursive type\n+   |\n+   = note: type resolves to itself\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "de7433a9bfc4cdbb63961f0e17c41f0e01e1f53c", "filename": "src/test/ui/impl-trait/issue-67166.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,11 @@\n+// Regression test for #67166\n+\n+#![feature(impl_trait_in_bindings)]\n+#![allow(incomplete_features)]\n+\n+pub fn run() {\n+    let _foo: Box<impl Copy + '_> = Box::new(()); // FIXME: The error doesn't much make sense.\n+    //~^ ERROR: opaque type expands to a recursive type\n+}\n+\n+fn main() {}"}, {"sha": "56cba3cff0b554b70f049506de4318a561ea988c", "filename": "src/test/ui/impl-trait/issue-67166.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-67166.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,11 @@\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/issue-67166.rs:7:19\n+   |\n+LL |     let _foo: Box<impl Copy + '_> = Box::new(()); // FIXME: The error doesn't much make sense.\n+   |                   ^^^^^^^^^^^^^^ expands to a recursive type\n+   |\n+   = note: type resolves to itself\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "f3980a596481c2cd4fb6acf14ce68f983f3dc569", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -38,8 +38,6 @@ fn main() {}\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n //~^ ERROR an inner attribute is not permitted in this context\n-#[cfg(FALSE)] fn e() { let _ = #[attr] if 0 {}; }\n-//~^ ERROR attributes are not yet allowed on `if` expressions\n #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n //~^ ERROR expected `{`, found `#`\n #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n@@ -51,14 +49,11 @@ fn main() {}\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n-//~^ ERROR attributes are not yet allowed on `if` expressions\n-//~| ERROR expected `{`, found `#`\n+//~^ ERROR expected `{`, found `#`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n //~^ ERROR expected `{`, found `#`\n #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n-#[cfg(FALSE)] fn e() { let _ = #[attr] if let _ = 0 {}; }\n-//~^ ERROR attributes are not yet allowed on `if` expressions\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n //~^ ERROR expected `{`, found `#`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n@@ -70,8 +65,7 @@ fn main() {}\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n //~^ ERROR an inner attribute is not permitted in this context\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n-//~^ ERROR attributes are not yet allowed on `if` expressions\n-//~| ERROR expected `{`, found `#`\n+//~^ ERROR expected `{`, found `#`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n //~^ ERROR expected `{`, found `#`\n #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }"}, {"sha": "4dcba27cb68db7909309354ee28db603b2173979", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 35, "deletions": 59, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -136,14 +136,8 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:41:32\n-   |\n-LL | #[cfg(FALSE)] fn e() { let _ = #[attr] if 0 {}; }\n-   |                                ^^^^^^^\n-\n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:43:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:41:37\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                --   ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -152,51 +146,45 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:45:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:43:38\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n    |                                      ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:47:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:45:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n    |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:49:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n    |                                             ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                             |\n    |                                             expected `{`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:51:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:49:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    |                                              ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:53:45\n-   |\n-LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n-   |                                             ^^^^^^^\n-\n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:53:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                             ^       -------- help: try placing this code inside a block: `{ if 0 {}; }`\n    |                                             |\n    |                                             expected `{`\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:56:50\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:53:50\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             --   ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -205,21 +193,15 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:58:51\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:55:51\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    |                                                   ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:60:32\n-   |\n-LL | #[cfg(FALSE)] fn e() { let _ = #[attr] if let _ = 0 {}; }\n-   |                                ^^^^^^^\n-\n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:62:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:57:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                --           ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -228,51 +210,45 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:64:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:59:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n    |                                              ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:66:48\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:61:48\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n    |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:68:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:63:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n    |                                                     ^       --- help: try placing this code inside a block: `{ {}; }`\n    |                                                     |\n    |                                                     expected `{`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:70:54\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:65:54\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    |                                                      ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n-error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:72:53\n-   |\n-LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n-   |                                                     ^^^^^^^\n-\n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:72:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:67:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n    |                                                     ^       ---------------- help: try placing this code inside a block: `{ if let _ = 0 {}; }`\n    |                                                     |\n    |                                                     expected `{`\n \n error: expected `{`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:75:66\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:69:66\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n    |                                                     --           ^       --- help: try placing this code inside a block: `{ {}; }`\n@@ -281,15 +257,15 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}\n    |                                                     this `if` expression has a condition, but no block\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:77:67\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:71:67\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n    |                                                                   ^^^^^^^^\n    |\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:80:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:74:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -299,7 +275,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:82:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:76:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -309,7 +285,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:84:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:78:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -319,7 +295,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:86:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:80:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -329,7 +305,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:88:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:82:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -339,89 +315,89 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:94:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:88:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:94:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:88:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:97:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:91:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:97:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:91:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:100:39\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:94:39\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n    |                                       ^\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:102:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:96:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:102:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:96:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:106:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:106:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, or an operator\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:109:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:103:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:109:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:103:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, or an operator\n \n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:114:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:108:37\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                     ^^^^^^^\n \n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:116:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:110:37\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n    |                                     ^^^^^^^\n \n-error: aborting due to 57 previous errors\n+error: aborting due to 53 previous errors\n \n For more information about this error, try `rustc --explain E0586`."}, {"sha": "0d1f5be7b4930524cf00dece81f9a8dda4efb023", "filename": "src/test/ui/parser/recovery-attr-on-if.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2cb0b8582ebbf9784db9cec06fff517badbf4553/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb0b8582ebbf9784db9cec06fff517badbf4553/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.rs?ref=2cb0b8582ebbf9784db9cec06fff517badbf4553", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    #[attr] if true {};\n-    //~^ ERROR cannot find attribute\n-    //~| ERROR attributes are not yet allowed on `if` expressions\n-    #[attr] if true {};\n-    //~^ ERROR cannot find attribute\n-    //~| ERROR attributes are not yet allowed on `if` expressions\n-    let _recovery_witness: () = 0; //~ ERROR mismatched types\n-}"}, {"sha": "a02846827c9ab34072d1c86f0d5177df634c4217", "filename": "src/test/ui/parser/recovery-attr-on-if.stderr", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2cb0b8582ebbf9784db9cec06fff517badbf4553/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cb0b8582ebbf9784db9cec06fff517badbf4553/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.stderr?ref=2cb0b8582ebbf9784db9cec06fff517badbf4553", "patch": "@@ -1,35 +0,0 @@\n-error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/recovery-attr-on-if.rs:2:5\n-   |\n-LL |     #[attr] if true {};\n-   |     ^^^^^^^\n-\n-error: attributes are not yet allowed on `if` expressions\n-  --> $DIR/recovery-attr-on-if.rs:5:5\n-   |\n-LL |     #[attr] if true {};\n-   |     ^^^^^^^\n-\n-error: cannot find attribute `attr` in this scope\n-  --> $DIR/recovery-attr-on-if.rs:5:7\n-   |\n-LL |     #[attr] if true {};\n-   |       ^^^^\n-\n-error: cannot find attribute `attr` in this scope\n-  --> $DIR/recovery-attr-on-if.rs:2:7\n-   |\n-LL |     #[attr] if true {};\n-   |       ^^^^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/recovery-attr-on-if.rs:8:33\n-   |\n-LL |     let _recovery_witness: () = 0;\n-   |                            --   ^ expected `()`, found integer\n-   |                            |\n-   |                            expected due to this\n-\n-error: aborting due to 5 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "1ca082c8b47042f8444a34801e2ca12c0515b34b", "filename": "src/test/ui/sanitize/badfree.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbade652ed8ebac70f903e01f51cd92c4e4302c/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitize%2Fbadfree.rs?ref=3dbade652ed8ebac70f903e01f51cd92c4e4302c", "patch": "@@ -0,0 +1,19 @@\n+// needs-sanitizer-support\n+// only-x86_64\n+//\n+// compile-flags: -Z sanitizer=address -O\n+//\n+// run-fail\n+// error-pattern: AddressSanitizer: SEGV\n+\n+use std::ffi::c_void;\n+\n+extern \"C\" {\n+    fn free(ptr: *mut c_void);\n+}\n+\n+fn main() {\n+    unsafe {\n+        free(1 as *mut c_void);\n+    }\n+}"}]}