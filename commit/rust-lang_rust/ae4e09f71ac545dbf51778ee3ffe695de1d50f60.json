{"sha": "ae4e09f71ac545dbf51778ee3ffe695de1d50f60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNGUwOWY3MWFjNTQ1ZGJmNTE3NzhlZTNmZmU2OTVkZTFkNTBmNjA=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-27T19:36:10Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-28T16:49:20Z"}, "message": "adding parse_path", "tree": {"sha": "50dff982b12f5d61a40406650912823af3857944", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50dff982b12f5d61a40406650912823af3857944"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae4e09f71ac545dbf51778ee3ffe695de1d50f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae4e09f71ac545dbf51778ee3ffe695de1d50f60", "html_url": "https://github.com/rust-lang/rust/commit/ae4e09f71ac545dbf51778ee3ffe695de1d50f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae4e09f71ac545dbf51778ee3ffe695de1d50f60/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28b285764cd6d9b184584756177199d0f1c32ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b285764cd6d9b184584756177199d0f1c32ce3", "html_url": "https://github.com/rust-lang/rust/commit/28b285764cd6d9b184584756177199d0f1c32ce3"}], "stats": {"total": 53, "additions": 34, "deletions": 19}, "files": [{"sha": "3925d4aa9bf0aa2204fba99ac1605ab40d34a43c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ae4e09f71ac545dbf51778ee3ffe695de1d50f60/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4e09f71ac545dbf51778ee3ffe695de1d50f60/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ae4e09f71ac545dbf51778ee3ffe695de1d50f60", "patch": "@@ -900,30 +900,45 @@ pub impl Parser {\n         codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n-    // parse a path that doesn't have type parameters attached\n-    fn parse_path_without_tps(&self)\n-        -> @ast::Path {\n-        maybe_whole!(self, nt_path);\n+    // parse a path into a vector of idents, whether the path starts\n+    // with ::, and a span.\n+    fn parse_path(&self) -> (~[ast::ident],bool,span) {\n+        let lo = self.span.lo;\n+        let is_global = self.eat(&token::MOD_SEP);\n+        let (ids,span{lo:_,hi,expn_info}) = self.parse_path_non_global();\n+        (ids,is_global,span{lo:lo,hi:hi,expn_info:expn_info})\n+    }\n+\n+    // parse a path beginning with an identifier into a vector of idents and a span\n+    fn parse_path_non_global(&self) -> (~[ast::ident],span) {\n         let lo = self.span.lo;\n-        let global = self.eat(&token::MOD_SEP);\n         let mut ids = ~[];\n+        // must be at least one to begin:\n+        ids.push(self.parse_ident());\n         loop {\n-            // if there's a ::< coming, stop processing\n-            // the path.\n-            let is_not_last =\n-                self.look_ahead(2u) != token::LT\n-                && self.look_ahead(1u) == token::MOD_SEP;\n-\n-            if is_not_last {\n-                ids.push(self.parse_ident());\n-                self.expect(&token::MOD_SEP);\n-            } else {\n-                ids.push(self.parse_ident());\n-                break;\n+            match *self.token {\n+                token::MOD_SEP => {\n+                    match self.look_ahead(1u) {\n+                        token::IDENT(id,_) => {\n+                            self.bump();\n+                            ids.push(self.parse_ident());\n+                        }\n+                        _ => break\n+                    }\n+                }\n+                _ => break\n             }\n         }\n-        @ast::Path { span: mk_sp(lo, self.last_span.hi),\n-                     global: global,\n+        (ids, mk_sp(lo, self.last_span.hi))\n+    }\n+\n+    // parse a path that doesn't have type parameters attached\n+    fn parse_path_without_tps(&self)\n+        -> @ast::Path {\n+        maybe_whole!(self, nt_path);\n+        let (ids,is_global,sp) = self.parse_path();\n+        @ast::Path { span: sp,\n+                     global: is_global,\n                      idents: ids,\n                      rp: None,\n                      types: ~[] }"}]}