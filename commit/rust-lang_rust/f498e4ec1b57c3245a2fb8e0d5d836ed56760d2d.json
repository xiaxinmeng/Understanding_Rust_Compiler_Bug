{"sha": "f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OThlNGVjMWI1N2MzMjQ1YTJmYjhlMGQ1ZDgzNmVkNTY3NjBkMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-24T15:11:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-24T15:11:56Z"}, "message": "Auto merge of #51587 - mark-i-m:at_most_once_rep_2018, r=alexcrichton\n\n2018 edition `?` Kleene operator\n\nThis is my first attempt at implementing the migration lint + 2018 behavior as discussed in #48075\n\nr? @nikomatsakis", "tree": {"sha": "870ef7d674c7aee50c7d3b59b4dce7053b1589ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/870ef7d674c7aee50c7d3b59b4dce7053b1589ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "html_url": "https://github.com/rust-lang/rust/commit/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a3db033ad05f156281d50ee489d727ee0e5d767", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3db033ad05f156281d50ee489d727ee0e5d767", "html_url": "https://github.com/rust-lang/rust/commit/6a3db033ad05f156281d50ee489d727ee0e5d767"}, {"sha": "10ee0f68a6815fafa69f58daf347f0c2a8339f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ee0f68a6815fafa69f58daf347f0c2a8339f32", "html_url": "https://github.com/rust-lang/rust/commit/10ee0f68a6815fafa69f58daf347f0c2a8339f32"}], "stats": {"total": 1072, "additions": 769, "deletions": 303}, "files": [{"sha": "251fc7209122c8e0d3df4c36c2219a61c713a8a5", "filename": "src/doc/unstable-book/src/language-features/macro-at-most-once-rep.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -1,13 +1,15 @@\n # `macro_at_most_once_rep`\n \n-The tracking issue for this feature is: TODO(mark-i-m)\n+NOTE: This feature is only available in the 2018 Edition.\n+\n+The tracking issue for this feature is: #48075\n \n With this feature gate enabled, one can use `?` as a Kleene operator meaning \"0\n or 1 repetitions\" in a macro definition. Previously only `+` and `*` were allowed.\n \n For example:\n \n-```rust\n+```rust,ignore\n #![feature(macro_at_most_once_rep)]\n \n macro_rules! foo {"}, {"sha": "4184cba7db3ef6ee4343b52a1d89d1d47c6b2bc1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -331,6 +331,15 @@ declare_lint! {\n      via the module system\"\n }\n \n+/// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n+pub mod parser {\n+    declare_lint! {\n+        pub QUESTION_MARK_MACRO_SEP,\n+        Allow,\n+        \"detects the use of `?` as a macro separator\"\n+    }\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -389,6 +398,7 @@ impl LintPass for HardwiredLints {\n             WHERE_CLAUSES_OBJECT_SAFETY,\n             PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n             MACRO_USE_EXTERN_CRATE,\n+            parser::QUESTION_MARK_MACRO_SEP,\n         )\n     }\n }"}, {"sha": "3c1b20562089200aa9e1989f8855d193d487b714", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -38,10 +38,12 @@ use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit;\n use hir;\n use lint::builtin::BuiltinLintDiagnostics;\n+use lint::builtin::parser::QUESTION_MARK_MACRO_SEP;\n use session::{Session, DiagnosticMessageId};\n use std::{hash, ptr};\n use syntax::ast;\n use syntax::codemap::{MultiSpan, ExpnFormat};\n+use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n use syntax::visit as ast_visit;\n@@ -86,6 +88,13 @@ pub struct Lint {\n }\n \n impl Lint {\n+    /// Returns the `rust::lint::Lint` for a `syntax::early_buffered_lints::BufferedEarlyLintId`.\n+    pub fn from_parser_lint_id(lint_id: BufferedEarlyLintId) -> &'static Self {\n+        match lint_id {\n+            BufferedEarlyLintId::QuestionMarkMacroSep => QUESTION_MARK_MACRO_SEP,\n+        }\n+    }\n+\n     /// Get the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n         self.name.to_ascii_lowercase()\n@@ -118,7 +127,7 @@ macro_rules! declare_lint {\n         };\n     );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n-     $lint_edition: expr => $edition_level: ident $(,)?\n+     $lint_edition: expr => $edition_level: ident\n     ) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n@@ -133,7 +142,8 @@ macro_rules! declare_lint {\n /// Declare a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array {\n-    ($( $lint:expr ),* $(,)?) => {{\n+    ($( $lint:expr ),* ,) => { lint_array!( $($lint),* ) };\n+    ($( $lint:expr ),*) => {{\n         vec![$($lint),*]\n     }}\n }"}, {"sha": "0bf1f4decc43040c4184d1fd31924ba01434d672", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -71,7 +71,9 @@ macro_rules! __impl_stable_hash_field {\n \n #[macro_export]\n macro_rules! impl_stable_hash_for {\n-    (enum $enum_name:path { $( $variant:ident $( ( $($field:ident $(-> $delegate:tt)?),* ) )* ),* $(,)? }) => {\n+    // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n+    // them back when `?` is supported again.\n+    (enum $enum_name:path { $( $variant:ident $( ( $($field:ident $(-> $delegate:tt)*),* ) )* ),* $(,)* }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -83,14 +85,15 @@ macro_rules! impl_stable_hash_for {\n                 match *self {\n                     $(\n                         $variant $( ( $(ref $field),* ) )* => {\n-                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)*\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n-    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n+    // FIXME(mark-i-m): same here.\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -100,11 +103,12 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n             }\n         }\n     };\n-    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n+    // FIXME(mark-i-m): same here.\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -114,7 +118,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n             }\n         }\n     };"}, {"sha": "91392ab013d6c2234cad016a3536d9ceee7b2d07", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -52,6 +52,7 @@ use std::path::{Path, PathBuf};\n use rustc_data_structures::sync::{self, Lrc, Lock};\n use std::sync::mpsc;\n use syntax::{self, ast, attr, diagnostics, visit};\n+use syntax::early_buffered_lints::BufferedEarlyLint;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::parse::{self, PResult};\n@@ -1066,6 +1067,15 @@ where\n         )\n     });\n \n+    // Add all buffered lints from the `ParseSess` to the `Session`.\n+    sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n+        info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n+        for BufferedEarlyLint{id, span, msg, lint_id} in buffered_lints.drain(..) {\n+            let lint = lint::Lint::from_parser_lint_id(lint_id);\n+            sess.buffer_lint(lint, id, span, &msg);\n+        }\n+    });\n+\n     // Done with macro expansion!\n \n     after_expand(&krate)?;"}, {"sha": "e6aa7c0d16c6a9b8285a0ac09eb49fddb127e13b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -617,7 +617,7 @@ declare_lint! {\n     pub ANONYMOUS_PARAMETERS,\n     Allow,\n     \"detects anonymous parameters\",\n-    Edition::Edition2018 => Warn,\n+    Edition::Edition2018 => Warn\n }\n \n /// Checks for use of anonymous parameters (RFC 1685)\n@@ -1706,7 +1706,7 @@ impl LintPass for SoftLints {\n             UNIONS_WITH_DROP_FIELDS,\n             UNREACHABLE_PUB,\n             TYPE_ALIAS_BOUNDS,\n-            TRIVIAL_BOUNDS,\n+            TRIVIAL_BOUNDS\n         )\n     }\n }"}, {"sha": "798c289ac2f9f4f824dafe2c2458304f291e2a99", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -44,9 +44,13 @@ extern crate syntax_pos;\n \n use rustc::lint;\n use rustc::lint::{LateContext, LateLintPass, LintPass, LintArray};\n-use rustc::lint::builtin::{BARE_TRAIT_OBJECTS, ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-                           ELIDED_LIFETIMES_IN_PATHS};\n-use rustc::lint::builtin::MACRO_USE_EXTERN_CRATE;\n+use rustc::lint::builtin::{\n+    BARE_TRAIT_OBJECTS,\n+    ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n+    MACRO_USE_EXTERN_CRATE,\n+    ELIDED_LIFETIMES_IN_PATHS,\n+    parser::QUESTION_MARK_MACRO_SEP\n+};\n use rustc::session;\n use rustc::util;\n use rustc::hir;\n@@ -321,6 +325,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n             edition: None,\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(QUESTION_MARK_MACRO_SEP),\n+            reference: \"issue #48075 <https://github.com/rust-lang/rust/issues/48075>\",\n+            edition: Some(Edition::Edition2018),\n+        }\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "a976af1435d2369edaf49596b760d5ff91561cc7", "filename": "src/libsyntax/early_buffered_lints.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fearly_buffered_lints.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Allows the buffering of lints for later.\n+//!\n+//! Since we cannot have a dependency on `librustc`, we implement some types here that are somewhat\n+//! redundant. Later, these types can be converted to types for use by the rest of the compiler.\n+\n+use syntax::ast::NodeId;\n+use syntax_pos::MultiSpan;\n+\n+/// Since we cannot import `LintId`s from `rustc::lint`, we define some Ids here which can later be\n+/// passed to `rustc::lint::Lint::from_parser_lint_id` to get a `rustc::lint::Lint`.\n+pub enum BufferedEarlyLintId {\n+    /// Usage of `?` as a macro separator is deprecated.\n+    QuestionMarkMacroSep,\n+}\n+\n+/// Stores buffered lint info which can later be passed to `librustc`.\n+pub struct BufferedEarlyLint {\n+    /// The span of code that we are linting on.\n+   pub span: MultiSpan,\n+\n+   /// The lint message.\n+   pub msg: String,\n+\n+   /// The `NodeId` of the AST node that generated the lint.\n+   pub id: NodeId,\n+\n+   /// A lint Id that can be passed to `rustc::lint::Lint::from_parser_lint_id`.\n+   pub lint_id: BufferedEarlyLintId,\n+}"}, {"sha": "b84046d10505125f1ca9a7ad9024f23b6154f3db", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -44,8 +44,10 @@ macro_rules! ast_fragments {\n     (\n         $($Kind:ident($AstTy:ty) {\n             $kind_name:expr;\n-            $(one fn $fold_ast:ident; fn $visit_ast:ident;)?\n-            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)?\n+            // FIXME: HACK: this should be `$(one ...)?` and `$(many ...)?` but `?` macro\n+            // repetition was removed from 2015 edition in #51587 because of ambiguities.\n+            $(one fn $fold_ast:ident; fn $visit_ast:ident;)*\n+            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)*\n             fn $make_ast:ident;\n         })*\n     ) => {\n@@ -100,22 +102,22 @@ macro_rules! ast_fragments {\n                     AstFragment::OptExpr(expr) =>\n                         AstFragment::OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n                     $($(AstFragment::$Kind(ast) =>\n-                        AstFragment::$Kind(folder.$fold_ast(ast)),)?)*\n+                        AstFragment::$Kind(folder.$fold_ast(ast)),)*)*\n                     $($(AstFragment::$Kind(ast) =>\n                         AstFragment::$Kind(ast.into_iter()\n                                               .flat_map(|ast| folder.$fold_ast_elt(ast))\n-                                              .collect()),)?)*\n+                                              .collect()),)*)*\n                 }\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n                 match *self {\n                     AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n-                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)*)*\n                     $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt);\n-                    })?)*\n+                    })*)*\n                 }\n             }\n         }\n@@ -126,10 +128,10 @@ macro_rules! ast_fragments {\n             }\n             $($(fn $fold_ast(&mut self, ast: $AstTy) -> $AstTy {\n                 self.expand_fragment(AstFragment::$Kind(ast)).$make_ast()\n-            })?)*\n+            })*)*\n             $($(fn $fold_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n                 self.expand_fragment(AstFragment::$Kind(SmallVector::one(ast_elt))).$make_ast()\n-            })?)*\n+            })*)*\n         }\n \n         impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {"}, {"sha": "c9ec2c7d1e86adeef111c98ea0a1112c5260d3cb", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -240,8 +240,17 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = quoted::parse(tt.clone().into(), true, sess, features, &def.attrs)\n-                            .pop().unwrap();\n+                        let tt = quoted::parse(\n+                            tt.clone().into(),\n+                            true,\n+                            sess,\n+                            features,\n+                            &def.attrs,\n+                            edition,\n+                            def.id,\n+                        )\n+                        .pop()\n+                        .unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -257,8 +266,16 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return quoted::parse(tt.clone().into(), false, sess, features, &def.attrs)\n-                            .pop().unwrap();\n+                        return quoted::parse(\n+                            tt.clone().into(),\n+                            false,\n+                            sess,\n+                            features,\n+                            &def.attrs,\n+                            edition,\n+                            def.id,\n+                        ).pop()\n+                         .unwrap();\n                     }\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")"}, {"sha": "357fc77a3a79d8c7f8a3df5f72a004132a7131a9", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 223, "deletions": 67, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -8,17 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {ast, attr};\n+use ast::NodeId;\n+use early_buffered_lints::BufferedEarlyLintId;\n use ext::tt::macro_parser;\n use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{token, ParseSess};\n use print::pprust;\n use symbol::keywords;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::{edition::Edition, BytePos, Span};\n use tokenstream;\n+use {ast, attr};\n \n-use std::iter::Peekable;\n use rustc_data_structures::sync::Lrc;\n+use std::iter::Peekable;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n@@ -174,6 +176,8 @@ impl TokenTree {\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n ///   unstable features or not.\n+/// - `edition`: which edition are we in.\n+/// - `macro_node_id`: the NodeId of the macro we are parsing.\n ///\n /// # Returns\n ///\n@@ -184,6 +188,8 @@ pub fn parse(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n+    edition: Edition,\n+    macro_node_id: NodeId,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -194,7 +200,16 @@ pub fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e. in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, features, attrs);\n+        let tree = parse_tree(\n+            tree,\n+            &mut trees,\n+            expect_matchers,\n+            sess,\n+            features,\n+            attrs,\n+            edition,\n+            macro_node_id,\n+        );\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -207,11 +222,13 @@ pub fn parse(\n                             }\n                             _ => end_sp,\n                         },\n-                        tree => tree.as_ref()\n+                        tree => tree\n+                            .as_ref()\n                             .map(tokenstream::TokenTree::span)\n                             .unwrap_or(span),\n                     },\n-                    tree => tree.as_ref()\n+                    tree => tree\n+                        .as_ref()\n                         .map(tokenstream::TokenTree::span)\n                         .unwrap_or(start_sp),\n                 };\n@@ -252,6 +269,8 @@ fn parse_tree<I>(\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n+    edition: Edition,\n+    macro_node_id: NodeId,\n ) -> TokenTree\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -270,9 +289,26 @@ where\n                     sess.span_diagnostic.span_err(span, &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(delimited.tts.into(), expect_matchers, sess, features, attrs);\n+                let sequence = parse(\n+                    delimited.tts.into(),\n+                    expect_matchers,\n+                    sess,\n+                    features,\n+                    attrs,\n+                    edition,\n+                    macro_node_id,\n+                );\n                 // Get the Kleene operator and optional separator\n-                let (separator, op) = parse_sep_and_kleene_op(trees, span, sess, features, attrs);\n+                let (separator, op) =\n+                    parse_sep_and_kleene_op(\n+                        trees,\n+                        span,\n+                        sess,\n+                        features,\n+                        attrs,\n+                        edition,\n+                        macro_node_id,\n+                    );\n                 // Count the number of captured \"names\" (i.e. named metavars)\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n@@ -322,7 +358,15 @@ where\n             span,\n             Lrc::new(Delimited {\n                 delim: delimited.delim,\n-                tts: parse(delimited.tts.into(), expect_matchers, sess, features, attrs),\n+                tts: parse(\n+                    delimited.tts.into(),\n+                    expect_matchers,\n+                    sess,\n+                    features,\n+                    attrs,\n+                    edition,\n+                    macro_node_id,\n+                ),\n             }),\n         ),\n     }\n@@ -341,22 +385,23 @@ fn kleene_op(token: &token::Token) -> Option<KleeneOp> {\n \n /// Parse the next token tree of the input looking for a KleeneOp. Returns\n ///\n-/// - Ok(Ok(op)) if the next token tree is a KleeneOp\n+/// - Ok(Ok((op, span))) if the next token tree is a KleeneOp\n /// - Ok(Err(tok, span)) if the next token tree is a token but not a KleeneOp\n /// - Err(span) if the next token tree is not a token\n fn parse_kleene_op<I>(\n     input: &mut I,\n     span: Span,\n-) -> Result<Result<KleeneOp, (token::Token, Span)>, Span>\n+) -> Result<Result<(KleeneOp, Span), (token::Token, Span)>, Span>\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n {\n     match input.next() {\n         Some(tokenstream::TokenTree::Token(span, tok)) => match kleene_op(&tok) {\n-            Some(op) => Ok(Ok(op)),\n+            Some(op) => Ok(Ok((op, span))),\n             None => Ok(Err((tok, span))),\n         },\n-        tree => Err(tree.as_ref()\n+        tree => Err(tree\n+            .as_ref()\n             .map(tokenstream::TokenTree::span)\n             .unwrap_or(span)),\n     }\n@@ -374,12 +419,43 @@ where\n /// session `sess`. If the next one (or possibly two) tokens in `input` correspond to a Kleene\n /// operator and separator, then a tuple with `(separator, KleeneOp)` is returned. Otherwise, an\n /// error with the appropriate span is emitted to `sess` and a dummy value is returned.\n+///\n+/// NOTE: In 2015 edition, * and + are the only Kleene operators and `?` is a separator. In 2018,\n+/// `?` is a Kleene op and not a separator.\n fn parse_sep_and_kleene_op<I>(\n     input: &mut Peekable<I>,\n     span: Span,\n     sess: &ParseSess,\n     features: &Features,\n     attrs: &[ast::Attribute],\n+    edition: Edition,\n+    macro_node_id: NodeId,\n+) -> (Option<token::Token>, KleeneOp)\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n+{\n+    match edition {\n+        Edition::Edition2015 => parse_sep_and_kleene_op_2015(\n+            input,\n+            span,\n+            sess,\n+            features,\n+            attrs,\n+            macro_node_id,\n+        ),\n+        Edition::Edition2018 => parse_sep_and_kleene_op_2018(input, span, sess, features, attrs),\n+        _ => unimplemented!(),\n+    }\n+}\n+\n+// `?` is a separator (with a migration warning) and never a KleeneOp.\n+fn parse_sep_and_kleene_op_2015<I>(\n+    input: &mut Peekable<I>,\n+    span: Span,\n+    sess: &ParseSess,\n+    _features: &Features,\n+    _attrs: &[ast::Attribute],\n+    macro_node_id: NodeId,\n ) -> (Option<token::Token>, KleeneOp)\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -388,14 +464,14 @@ where\n     let span = match parse_kleene_op(input, span) {\n         // #1 is a `+` or `*` KleeneOp\n         //\n-        // `?` is ambiguous: it could be a separator or a Kleene::ZeroOrOne, so we need to look\n-        // ahead one more token to be sure.\n-        Ok(Ok(op)) if op != KleeneOp::ZeroOrOne => return (None, op),\n-\n-        // #1 is `?` token, but it could be a Kleene::ZeroOrOne without a separator or it could\n-        // be a `?` separator followed by any Kleene operator. We need to look ahead 1 token to\n-        // find out which.\n-        Ok(Ok(op)) => {\n+        // `?` is ambiguous: it could be a separator (warning) or a Kleene::ZeroOrOne (error), so\n+        // we need to look ahead one more token to be sure.\n+        Ok(Ok((op, _))) if op != KleeneOp::ZeroOrOne => return (None, op),\n+\n+        // #1 is `?` token, but it could be a Kleene::ZeroOrOne (error in 2015) without a separator\n+        // or it could be a `?` separator followed by any Kleene operator. We need to look ahead 1\n+        // token to find out which.\n+        Ok(Ok((op, op1_span))) => {\n             assert_eq!(op, KleeneOp::ZeroOrOne);\n \n             // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n@@ -406,71 +482,149 @@ where\n             };\n \n             if is_1_sep {\n-                // #1 is a separator and #2 should be a KleepeOp::*\n+                // #1 is a separator and #2 should be a KleepeOp.\n                 // (N.B. We need to advance the input iterator.)\n                 match parse_kleene_op(input, span) {\n-                    // #2 is a KleeneOp (this is the only valid option) :)\n-                    Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                        if !features.macro_at_most_once_rep\n-                            && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                        {\n-                            let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                            emit_feature_err(\n-                                sess,\n-                                \"macro_at_most_once_rep\",\n-                                span,\n-                                GateIssue::Language,\n-                                explain,\n-                            );\n-                        }\n+                    // #2 is `?`, which is not allowed as a Kleene op in 2015 edition.\n+                    Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n+                        sess.span_diagnostic\n+                            .struct_span_err(op2_span, \"expected `*` or `+`\")\n+                            .note(\"`?` is not a macro repetition operator\")\n+                            .emit();\n+\n+                        // Return a dummy\n+                        return (None, KleeneOp::ZeroOrMore);\n+                    }\n+\n+                    // #2 is a Kleene op, which is the the only valid option\n+                    Ok(Ok((op, _))) => {\n+                        // Warn that `?` as a separator will be deprecated\n+                        sess.buffer_lint(\n+                            BufferedEarlyLintId::QuestionMarkMacroSep,\n+                            op1_span,\n+                            macro_node_id,\n+                            \"using `?` as a separator is deprecated and will be \\\n+                             a hard error in an upcoming edition\",\n+                        );\n+\n                         return (Some(token::Question), op);\n                     }\n-                    Ok(Ok(op)) => return (Some(token::Question), op),\n \n                     // #2 is a random token (this is an error) :(\n-                    Ok(Err((_, span))) => span,\n+                    Ok(Err((_, _))) => op1_span,\n \n                     // #2 is not even a token at all :(\n-                    Err(span) => span,\n+                    Err(_) => op1_span,\n                 }\n             } else {\n-                if !features.macro_at_most_once_rep\n-                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-                {\n-                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                    emit_feature_err(\n-                        sess,\n-                        \"macro_at_most_once_rep\",\n-                        span,\n-                        GateIssue::Language,\n-                        explain,\n-                    );\n-                }\n+                // `?` is not allowed as a Kleene op in 2015\n+                sess.span_diagnostic\n+                    .struct_span_err(op1_span, \"expected `*` or `+`\")\n+                    .note(\"`?` is not a macro repetition operator\")\n+                    .emit();\n+\n+                // Return a dummy\n+                return (None, KleeneOp::ZeroOrMore);\n+            }\n+        }\n+\n+        // #1 is a separator followed by #2, a KleeneOp\n+        Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n+            // #2 is a `?`, which is not allowed as a Kleene op in 2015 edition.\n+            Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n+                sess.span_diagnostic\n+                    .struct_span_err(op2_span, \"expected `*` or `+`\")\n+                    .note(\"`?` is not a macro repetition operator\")\n+                    .emit();\n+\n+                // Return a dummy\n+                return (None, KleeneOp::ZeroOrMore);\n+            }\n+\n+            // #2 is a KleeneOp :D\n+            Ok(Ok((op, _))) => return (Some(tok), op),\n+\n+            // #2 is a random token :(\n+            Ok(Err((_, span))) => span,\n \n-                // #2 is a random tree and #1 is KleeneOp::ZeroOrOne\n+            // #2 is not a token at all :(\n+            Err(span) => span,\n+        },\n+\n+        // #1 is not a token\n+        Err(span) => span,\n+    };\n+\n+    sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+\n+    // Return a dummy\n+    (None, KleeneOp::ZeroOrMore)\n+}\n+\n+// `?` is a Kleene op, not a separator\n+fn parse_sep_and_kleene_op_2018<I>(\n+    input: &mut Peekable<I>,\n+    span: Span,\n+    sess: &ParseSess,\n+    features: &Features,\n+    attrs: &[ast::Attribute],\n+) -> (Option<token::Token>, KleeneOp)\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n+{\n+    // We basically look at two token trees here, denoted as #1 and #2 below\n+    let span = match parse_kleene_op(input, span) {\n+        // #1 is a `?` (needs feature gate)\n+        Ok(Ok((op, op1_span))) if op == KleeneOp::ZeroOrOne => {\n+            if !features.macro_at_most_once_rep\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+            {\n+                let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                emit_feature_err(\n+                    sess,\n+                    \"macro_at_most_once_rep\",\n+                    op1_span,\n+                    GateIssue::Language,\n+                    explain,\n+                );\n+\n+                op1_span\n+            } else {\n                 return (None, op);\n             }\n         }\n \n+        // #1 is a `+` or `*` KleeneOp\n+        Ok(Ok((op, _))) => return (None, op),\n+\n         // #1 is a separator followed by #2, a KleeneOp\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n-            // #2 is a KleeneOp :D\n-            Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+            // #2 is the `?` Kleene op, which does not take a separator (error)\n+            Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n+                // Error!\n+\n                 if !features.macro_at_most_once_rep\n                     && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                 {\n-                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n-                    emit_feature_err(\n-                        sess,\n-                        \"macro_at_most_once_rep\",\n+                    // FIXME: when `?` as a Kleene op is stabilized, we only need the \"does not\n+                    // take a macro separator\" error (i.e. the `else` case).\n+                    sess.span_diagnostic\n+                        .struct_span_err(op2_span, \"expected `*` or `+`\")\n+                        .note(\"`?` is not a macro repetition operator\")\n+                        .emit();\n+                } else {\n+                    sess.span_diagnostic.span_err(\n                         span,\n-                        GateIssue::Language,\n-                        explain,\n+                        \"the `?` macro repetition operator does not take a separator\",\n                     );\n                 }\n-                return (Some(tok), op);\n+\n+                // Return a dummy\n+                return (None, KleeneOp::ZeroOrMore);\n             }\n-            Ok(Ok(op)) => return (Some(tok), op),\n+\n+            // #2 is a KleeneOp :D\n+            Ok(Ok((op, _))) => return (Some(tok), op),\n \n             // #2 is a random token :(\n             Ok(Err((_, span))) => span,\n@@ -483,13 +637,15 @@ where\n         Err(span) => span,\n     };\n \n-    if !features.macro_at_most_once_rep\n-        && !attr::contains_name(attrs, \"allow_internal_unstable\")\n-    {\n+    // If we ever get to this point, we have experienced an \"unexpected token\" error\n+\n+    if !features.macro_at_most_once_rep && !attr::contains_name(attrs, \"allow_internal_unstable\") {\n+        sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+    } else {\n         sess.span_diagnostic\n             .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n-    } else {\n-        sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n     }\n+\n+    // Return a dummy\n     (None, KleeneOp::ZeroOrMore)\n }"}, {"sha": "d241ae1d44227bd4f0539abb06bba18e8f453f6e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -181,6 +181,8 @@ pub mod ext {\n     }\n }\n \n+pub mod early_buffered_lints;\n+\n #[cfg(test)]\n mod test_snippet;\n "}, {"sha": "4b077aa8dd4c6d437113a945e58c823da98b0e95", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -1807,6 +1807,7 @@ mod tests {\n             raw_identifier_spans: Lock::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n             non_modrs_mods: Lock::new(vec![]),\n+            buffered_lints: Lock::new(vec![]),\n         }\n     }\n "}, {"sha": "d029509f0c12d1bac578c6b918ebbebbc424b379", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -11,9 +11,10 @@\n //! The main parser interface\n \n use rustc_data_structures::sync::{Lrc, Lock};\n-use ast::{self, CrateConfig};\n+use ast::{self, CrateConfig, NodeId};\n+use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use codemap::{CodeMap, FilePathMapping};\n-use syntax_pos::{Span, FileMap, FileName};\n+use syntax_pos::{Span, FileMap, FileName, MultiSpan};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -57,6 +58,7 @@ pub struct ParseSess {\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: Lock<Vec<PathBuf>>,\n     code_map: Lrc<CodeMap>,\n+    pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n }\n \n impl ParseSess {\n@@ -80,12 +82,29 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             code_map,\n             non_modrs_mods: Lock::new(vec![]),\n+            buffered_lints: Lock::new(vec![]),\n         }\n     }\n \n     pub fn codemap(&self) -> &CodeMap {\n         &self.code_map\n     }\n+\n+    pub fn buffer_lint<S: Into<MultiSpan>>(&self,\n+        lint_id: BufferedEarlyLintId,\n+        span: S,\n+        id: NodeId,\n+        msg: &str,\n+    ) {\n+        self.buffered_lints.with_lock(|buffered_lints| {\n+            buffered_lints.push(BufferedEarlyLint{\n+                span: span.into(),\n+                id,\n+                msg: msg.into(),\n+                lint_id,\n+            });\n+        });\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "15d491719a6d58dd8edf2350edd32d3309d98fee", "filename": "src/test/parse-fail/issue-33569.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fparse-fail%2Fissue-33569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fparse-fail%2Fissue-33569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33569.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -13,7 +13,7 @@\n macro_rules! foo {\n     { $+ } => { //~ ERROR expected identifier, found `+`\n                 //~^ ERROR missing fragment specifier\n-        $(x)(y) //~ ERROR expected one of: `*`, `+`, or `?`\n+        $(x)(y) //~ ERROR expected `*` or `+`\n     }\n }\n "}, {"sha": "f1777745e06c343ea61bb5366566d8ed8739572e", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -20,7 +20,7 @@ extern crate rustc_plugin;\n \n use syntax::feature_gate::Features;\n use syntax::parse::token::{NtExpr, NtPat};\n-use syntax::ast::{Ident, Pat};\n+use syntax::ast::{Ident, Pat, NodeId};\n use syntax::tokenstream::{TokenTree};\n use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::ext::build::AstBuilder;\n@@ -29,11 +29,9 @@ use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n use syntax::ext::tt::macro_parser::parse_failure_msg;\n use syntax::ptr::P;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, edition::Edition};\n use rustc_plugin::Registry;\n \n-use std::cell::RefCell;\n-\n fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n \n@@ -42,7 +40,10 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n                                     true,\n                                     cx.parse_sess,\n                                     &Features::new(),\n-                                    &[]);\n+                                    &[],\n+                                    Edition::Edition2015,\n+                                    // not used...\n+                                    NodeId::new(0));\n     let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n         Success(map) => map,\n         Failure(_, tok) => {"}, {"sha": "dcf2222ba6dea18a012768b49d4f0db05957bc97", "filename": "src/test/run-pass/macro-at-most-once-rep.rs", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -18,6 +18,8 @@\n //\n // This test focuses on non-error cases and making sure the correct number of repetitions happen.\n \n+// compile-flags: --edition=2018\n+\n #![feature(macro_at_most_once_rep)]\n \n macro_rules! foo {\n@@ -32,57 +34,10 @@ macro_rules! foo {\n     } }\n }\n \n-macro_rules! baz {\n-    ($($a:ident),? ; $num:expr) => { { // comma separator is meaningless for `?`\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )?\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n-macro_rules! barplus {\n-    ($($a:ident)?+ ; $num:expr) => { {\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )+\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n-macro_rules! barstar {\n-    ($($a:ident)?* ; $num:expr) => { {\n-        let mut x = 0;\n-\n-        $(\n-            x += $a;\n-         )*\n-\n-        assert_eq!(x, $num);\n-    } }\n-}\n-\n pub fn main() {\n     let a = 1;\n \n     // accept 0 or 1 repetitions\n     foo!( ; 0);\n     foo!(a ; 1);\n-    baz!( ; 0);\n-    baz!(a ; 1);\n-\n-    // Make sure using ? as a separator works as before\n-    barplus!(a ; 1);\n-    barplus!(a?a ; 2);\n-    barplus!(a?a?a ; 3);\n-    barstar!( ; 0);\n-    barstar!(a ; 1);\n-    barstar!(a?a ; 2);\n-    barstar!(a?a?a ; 3);\n }"}, {"sha": "9ca71d937f8598dadfd363d0af6e11731b42df55", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n-  --> $DIR/feature-gate-macro_at_most_once_rep.rs:14:20\n-   |\n-LL | macro_rules! m { ($(a)?) => {} }\n-   |                    ^^^\n-   |\n-   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "15eef429eab974667e3ea77daaada669acb10ccc", "filename": "src/test/ui/issue-39388.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fissue-39388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fissue-39388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-39388.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_macros)]\n \n macro_rules! assign {\n-    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected one of: `*`, `+`, or `?`\n+    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected `*` or `+`\n         $($a)* = $($b)*\n     }\n }"}, {"sha": "dc19487f3af6538a2e78005f41fb9d638a25a196", "filename": "src/test/ui/issue-39388.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fissue-39388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fissue-39388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-39388.stderr?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -1,7 +1,7 @@\n-error: expected one of: `*`, `+`, or `?`\n+error: expected `*` or `+`\n   --> $DIR/issue-39388.rs:14:22\n    |\n-LL |     (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected one of: `*`, `+`, or `?`\n+LL |     (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected `*` or `+`\n    |                      ^^^^^^^\n \n error: aborting due to previous error"}, {"sha": "fd7925ea3eeeb07bf1821fa8d6ae55396f80892b", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep-feature-flag.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test behavior of `?` macro _kleene op_ under the 2015 edition. Namely, it doesn't exist, even\n+// with the feature flag.\n+\n+// gate-test-macro_at_most_once_rep\n+// compile-flags: --edition=2015\n+\n+#![feature(macro_at_most_once_rep)]\n+\n+macro_rules! bar {\n+    ($(a)?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+fn main() {}\n+"}, {"sha": "5f687900421bf4823aaedb95b0f663f82429eb2f", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep-feature-flag.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep-feature-flag.stderr?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,18 @@\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep-feature-flag.rs:20:10\n+   |\n+LL |     ($(a)?) => {} //~ERROR expected `*` or `+`\n+   |          ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep-feature-flag.rs:24:11\n+   |\n+LL |     ($(a),?) => {} //~ERROR expected `*` or `+`\n+   |           ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "90bc19739b8724b279891854f02352afa8a24fe9", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep.rs", "status": "renamed", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that `?` macro Kleene operator can not be used when the `macro_at_most_once_rep` feature\n-// gate is not used.\n+// Test behavior of `?` macro _kleene op_ under the 2015 edition. Namely, it doesn't exist.\n \n-macro_rules! m { ($(a)?) => {} }\n-//~^ ERROR using the `?` macro Kleene operator for \"at most one\" repetition is unstable\n+// compile-flags: --edition=2015\n \n-fn main() {\n-    m!();\n+macro_rules! bar {\n+    ($(a)?) => {} //~ERROR expected `*` or `+`\n }\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+fn main() {}", "previous_filename": "src/test/ui/feature-gate-macro_at_most_once_rep.rs"}, {"sha": "8681b5d5be54e0394ebea1253dc7e8478050cf67", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-rep.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-rep.stderr?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,18 @@\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep.rs:16:10\n+   |\n+LL |     ($(a)?) => {} //~ERROR expected `*` or `+`\n+   |          ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2015-ques-rep.rs:20:11\n+   |\n+LL |     ($(a),?) => {} //~ERROR expected `*` or `+`\n+   |           ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2e06b4bd5c2405819a29fe8efbe2822d5c48257b", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-sep.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test behavior of `?` macro _separator_ under the 2015 edition. Namely, `?` can be used as a\n+// separator, but you get a migration warning for the edition.\n+\n+// compile-flags: --edition=2015\n+// compile-pass\n+\n+#![warn(rust_2018_compatibility)]\n+\n+macro_rules! bar {\n+    ($(a)?*) => {} //~WARN using `?` as a separator\n+    //~^WARN this was previously accepted\n+}\n+\n+macro_rules! baz {\n+    ($(a)?+) => {} //~WARN using `?` as a separator\n+    //~^WARN this was previously accepted\n+}\n+\n+fn main() {\n+    bar!();\n+    bar!(a);\n+    bar!(a?a);\n+    bar!(a?a?a?a?a);\n+\n+    baz!(a);\n+    baz!(a?a);\n+    baz!(a?a?a?a?a);\n+}"}, {"sha": "db1872c24134ae51049705ad7b5793ea6a362056", "filename": "src/test/ui/macros/macro-at-most-once-rep-2015-ques-sep.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2015-ques-sep.stderr?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,24 @@\n+warning: using `?` as a separator is deprecated and will be a hard error in an upcoming edition\n+  --> $DIR/macro-at-most-once-rep-2015-ques-sep.rs:20:10\n+   |\n+LL |     ($(a)?*) => {} //~WARN using `?` as a separator\n+   |          ^\n+   |\n+note: lint level defined here\n+  --> $DIR/macro-at-most-once-rep-2015-ques-sep.rs:17:9\n+   |\n+LL | #![warn(rust_2018_compatibility)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: #[warn(question_mark_macro_sep)] implied by #[warn(rust_2018_compatibility)]\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #48075 <https://github.com/rust-lang/rust/issues/48075>\n+\n+warning: using `?` as a separator is deprecated and will be a hard error in an upcoming edition\n+  --> $DIR/macro-at-most-once-rep-2015-ques-sep.rs:25:10\n+   |\n+LL |     ($(a)?+) => {} //~WARN using `?` as a separator\n+   |          ^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #48075 <https://github.com/rust-lang/rust/issues/48075>\n+"}, {"sha": "f3107d4f1e4f6382942cfef5bea134988755bea8", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018-feature-gate.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Feature gate test for macro_at_most_once_rep under 2018 edition.\n+\n+// gate-test-macro_at_most_once_rep\n+// compile-flags: --edition=2018\n+\n+macro_rules! foo {\n+    ($(a)?) => {}\n+    //~^ERROR using the `?` macro Kleene operator for\n+    //~|ERROR expected `*` or `+`\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR expected `*` or `+`\n+}\n+\n+macro_rules! barplus {\n+    ($(a)?+) => {}\n+    //~^ERROR using the `?` macro Kleene operator for\n+    //~|ERROR expected `*` or `+`\n+}\n+\n+macro_rules! barstar {\n+    ($(a)?*) => {}\n+    //~^ERROR using the `?` macro Kleene operator for\n+    //~|ERROR expected `*` or `+`\n+}\n+\n+pub fn main() {\n+    foo!();\n+    foo!(a);\n+    foo!(a?); //~ ERROR no rules expected the token `?`\n+    foo!(a?a); //~ ERROR no rules expected the token `?`\n+    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+}\n+"}, {"sha": "22f1c94fced6f3cbf02d63c49ae579e252d128c8", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018-feature-gate.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018-feature-gate.stderr?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,71 @@\n+error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:17:10\n+   |\n+LL |     ($(a)?) => {}\n+   |          ^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:17:10\n+   |\n+LL |     ($(a)?) => {}\n+   |          ^\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:23:11\n+   |\n+LL |     ($(a),?) => {} //~ERROR expected `*` or `+`\n+   |           ^\n+   |\n+   = note: `?` is not a macro repetition operator\n+\n+error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:27:10\n+   |\n+LL |     ($(a)?+) => {}\n+   |          ^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:27:10\n+   |\n+LL |     ($(a)?+) => {}\n+   |          ^\n+\n+error[E0658]: using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:33:10\n+   |\n+LL |     ($(a)?*) => {}\n+   |          ^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: expected `*` or `+`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:33:10\n+   |\n+LL |     ($(a)?*) => {}\n+   |          ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:41:11\n+   |\n+LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:42:11\n+   |\n+LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018-feature-gate.rs:43:11\n+   |\n+LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: aborting due to 10 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "958a7e0cdf444beed41e76010c0f8ebe5580420c", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.rs?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that `?` is a Kleene op and not a macro separator in the 2018 edition.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(macro_at_most_once_rep)]\n+\n+macro_rules! foo {\n+    ($(a)?) => {}\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} //~ERROR the `?` macro repetition operator\n+}\n+\n+macro_rules! barplus {\n+    ($(a)?+) => {} // ok. matches \"a+\" and \"+\"\n+}\n+\n+macro_rules! barstar {\n+    ($(a)?*) => {} // ok. matches \"a*\" and \"*\"\n+}\n+\n+pub fn main() {\n+    foo!();\n+    foo!(a);\n+    foo!(a?); //~ ERROR no rules expected the token `?`\n+    foo!(a?a); //~ ERROR no rules expected the token `?`\n+    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+\n+    barplus!(); //~ERROR unexpected end of macro invocation\n+    barplus!(a); //~ERROR unexpected end of macro invocation\n+    barplus!(a?); //~ ERROR no rules expected the token `?`\n+    barplus!(a?a); //~ ERROR no rules expected the token `?`\n+    barplus!(a+);\n+    barplus!(+);\n+\n+    barstar!(); //~ERROR unexpected end of macro invocation\n+    barstar!(a); //~ERROR unexpected end of macro invocation\n+    barstar!(a?); //~ ERROR no rules expected the token `?`\n+    barstar!(a?a); //~ ERROR no rules expected the token `?`\n+    barstar!(a*);\n+    barstar!(*);\n+}"}, {"sha": "0a15bdb10686d9e01fef808ca474af1a4d4c6b1f", "filename": "src/test/ui/macros/macro-at-most-once-rep-2018.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-2018.stderr?ref=f498e4ec1b57c3245a2fb8e0d5d836ed56760d2d", "patch": "@@ -0,0 +1,74 @@\n+error: the `?` macro repetition operator does not take a separator\n+  --> $DIR/macro-at-most-once-rep-2018.rs:22:10\n+   |\n+LL |     ($(a),?) => {} //~ERROR the `?` macro repetition operator\n+   |          ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:36:11\n+   |\n+LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:37:11\n+   |\n+LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:38:11\n+   |\n+LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+   |           ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:40:5\n+   |\n+LL |     barplus!(); //~ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:41:14\n+   |\n+LL |     barplus!(a); //~ERROR unexpected end of macro invocation\n+   |              ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:42:15\n+   |\n+LL |     barplus!(a?); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:43:15\n+   |\n+LL |     barplus!(a?a); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:47:5\n+   |\n+LL |     barstar!(); //~ERROR unexpected end of macro invocation\n+   |     ^^^^^^^^^^^\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/macro-at-most-once-rep-2018.rs:48:14\n+   |\n+LL |     barstar!(a); //~ERROR unexpected end of macro invocation\n+   |              ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:49:15\n+   |\n+LL |     barstar!(a?); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: no rules expected the token `?`\n+  --> $DIR/macro-at-most-once-rep-2018.rs:50:15\n+   |\n+LL |     barstar!(a?a); //~ ERROR no rules expected the token `?`\n+   |               ^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "a5660f8b41f8da43aeeea29deefa8607dc764bf4", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.rs?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n-// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n-// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n-// exercise that logic in the macro parser.\n-//\n-// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n-// included for consistency with `+` and `*`.\n-//\n-// This test focuses on error cases.\n-\n-#![feature(macro_at_most_once_rep)]\n-\n-macro_rules! foo {\n-    ($(a)?) => {}\n-}\n-\n-macro_rules! baz {\n-    ($(a),?) => {} // comma separator is meaningless for `?`\n-}\n-\n-macro_rules! barplus {\n-    ($(a)?+) => {}\n-}\n-\n-macro_rules! barstar {\n-    ($(a)?*) => {}\n-}\n-\n-pub fn main() {\n-    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n-    foo!(a?a); //~ ERROR no rules expected the token `?`\n-    foo!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?a); //~ ERROR no rules expected the token `?`\n-    baz!(a?); //~ ERROR no rules expected the token `?`\n-    baz!(a,); //~ ERROR unexpected end of macro invocation\n-    baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?a,); //~ ERROR no rules expected the token `?`\n-    baz!(a?,); //~ ERROR no rules expected the token `?`\n-    barplus!(); //~ ERROR unexpected end of macro invocation\n-    barplus!(a?); //~ ERROR unexpected end of macro invocation\n-    barstar!(a?); //~ ERROR unexpected end of macro invocation\n-}"}, {"sha": "d382082a5758562bb4f6163ef74237c8c0fbc3af", "filename": "src/test/ui/macros/macro-at-most-once-rep-ambig.stderr", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a3db033ad05f156281d50ee489d727ee0e5d767/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-at-most-once-rep-ambig.stderr?ref=6a3db033ad05f156281d50ee489d727ee0e5d767", "patch": "@@ -1,80 +0,0 @@\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:40:11\n-   |\n-LL |     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:41:11\n-   |\n-LL |     foo!(a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:42:11\n-   |\n-LL |     foo!(a?); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:43:11\n-   |\n-LL |     baz!(a?a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:44:11\n-   |\n-LL |     baz!(a?a); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:45:11\n-   |\n-LL |     baz!(a?); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:46:11\n-   |\n-LL |     baz!(a,); //~ ERROR unexpected end of macro invocation\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:47:11\n-   |\n-LL |     baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:48:11\n-   |\n-LL |     baz!(a?a,); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: no rules expected the token `?`\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:49:11\n-   |\n-LL |     baz!(a?,); //~ ERROR no rules expected the token `?`\n-   |           ^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:50:5\n-   |\n-LL |     barplus!(); //~ ERROR unexpected end of macro invocation\n-   |     ^^^^^^^^^^^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:51:15\n-   |\n-LL |     barplus!(a?); //~ ERROR unexpected end of macro invocation\n-   |               ^\n-\n-error: unexpected end of macro invocation\n-  --> $DIR/macro-at-most-once-rep-ambig.rs:52:15\n-   |\n-LL |     barstar!(a?); //~ ERROR unexpected end of macro invocation\n-   |               ^\n-\n-error: aborting due to 13 previous errors\n-"}]}