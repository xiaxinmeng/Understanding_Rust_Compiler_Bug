{"sha": "25090f0e6d72b3330b05aebf74d425080bfcfff0", "node_id": "C_kwDOAAsO6NoAKDI1MDkwZjBlNmQ3MmIzMzMwYjA1YWViZjc0ZDQyNTA4MGJmY2ZmZjA", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-16T09:17:15Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-07-16T09:17:15Z"}, "message": "internal: Remove allocation in DefCollector::reseed_with_unresolved_attribute", "tree": {"sha": "ff36e329844ceb4102cc84cc703ade9f0ae645ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff36e329844ceb4102cc84cc703ade9f0ae645ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25090f0e6d72b3330b05aebf74d425080bfcfff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25090f0e6d72b3330b05aebf74d425080bfcfff0", "html_url": "https://github.com/rust-lang/rust/commit/25090f0e6d72b3330b05aebf74d425080bfcfff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25090f0e6d72b3330b05aebf74d425080bfcfff0/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af3ef527c803d8ed5df41b0cff7e0a8f46a1505", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af3ef527c803d8ed5df41b0cff7e0a8f46a1505", "html_url": "https://github.com/rust-lang/rust/commit/5af3ef527c803d8ed5df41b0cff7e0a8f46a1505"}], "stats": {"total": 125, "additions": 60, "deletions": 65}, "files": [{"sha": "e50cc307dd291cb8678dba4c3701041fa617b317", "filename": "crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/25090f0e6d72b3330b05aebf74d425080bfcfff0/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25090f0e6d72b3330b05aebf74d425080bfcfff0/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=25090f0e6d72b3330b05aebf74d425080bfcfff0", "patch": "@@ -270,35 +270,33 @@ impl ItemScope {\n                 $glob_imports:ident [ $lookup:ident ],\n                 $def_import_type:ident\n             ) => {{\n-                let existing = $this.$field.entry($lookup.1.clone());\n-                match (existing, $def.$field) {\n-                    (Entry::Vacant(entry), Some(_)) => {\n-                        match $def_import_type {\n-                            ImportType::Glob => {\n-                                $glob_imports.$field.insert($lookup.clone());\n+                if let Some(fld) = $def.$field {\n+                    let existing = $this.$field.entry($lookup.1.clone());\n+                    match existing {\n+                        Entry::Vacant(entry) => {\n+                            match $def_import_type {\n+                                ImportType::Glob => {\n+                                    $glob_imports.$field.insert($lookup.clone());\n+                                }\n+                                ImportType::Named => {\n+                                    $glob_imports.$field.remove(&$lookup);\n+                                }\n                             }\n-                            ImportType::Named => {\n-                                $glob_imports.$field.remove(&$lookup);\n-                            }\n-                        }\n \n-                        if let Some(fld) = $def.$field {\n                             entry.insert(fld);\n+                            $changed = true;\n                         }\n-                        $changed = true;\n-                    }\n-                    (Entry::Occupied(mut entry), Some(_))\n-                        if $glob_imports.$field.contains(&$lookup)\n-                            && matches!($def_import_type, ImportType::Named) =>\n-                    {\n-                        cov_mark::hit!(import_shadowed);\n-                        $glob_imports.$field.remove(&$lookup);\n-                        if let Some(fld) = $def.$field {\n+                        Entry::Occupied(mut entry)\n+                            if $glob_imports.$field.contains(&$lookup)\n+                                && matches!($def_import_type, ImportType::Named) =>\n+                        {\n+                            cov_mark::hit!(import_shadowed);\n+                            $glob_imports.$field.remove(&$lookup);\n                             entry.insert(fld);\n+                            $changed = true;\n                         }\n-                        $changed = true;\n+                        _ => {}\n                     }\n-                    _ => {}\n                 }\n             }};\n         }"}, {"sha": "4ed81c1c2a51578f1e45a54a6706321d8bc8f624", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/25090f0e6d72b3330b05aebf74d425080bfcfff0/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25090f0e6d72b3330b05aebf74d425080bfcfff0/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=25090f0e6d72b3330b05aebf74d425080bfcfff0", "patch": "@@ -395,9 +395,8 @@ impl DefCollector<'_> {\n         // As some of the macros will expand newly import shadowing partial resolved imports\n         // FIXME: We maybe could skip this, if we handle the indeterminate imports in `resolve_imports`\n         // correctly\n-        let partial_resolved = self.indeterminate_imports.drain(..).filter_map(|mut directive| {\n-            directive.status = PartialResolvedImport::Unresolved;\n-            Some(directive)\n+        let partial_resolved = self.indeterminate_imports.drain(..).map(|directive| {\n+            ImportDirective { status: PartialResolvedImport::Unresolved, ..directive }\n         });\n         self.unresolved_imports.extend(partial_resolved);\n         self.resolve_imports();\n@@ -434,50 +433,48 @@ impl DefCollector<'_> {\n     fn reseed_with_unresolved_attribute(&mut self) -> ReachedFixedPoint {\n         cov_mark::hit!(unresolved_attribute_fallback);\n \n-        let mut unresolved_macros = mem::take(&mut self.unresolved_macros);\n-        let pos = unresolved_macros.iter().position(|directive| {\n-            if let MacroDirectiveKind::Attr { ast_id, mod_item, attr, tree } = &directive.kind {\n-                self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n-                    directive.module_id,\n-                    MacroCallKind::Attr {\n-                        ast_id: ast_id.ast_id,\n-                        attr_args: Default::default(),\n-                        invoc_attr_index: attr.id.ast_index,\n-                        is_derive: false,\n-                    },\n-                    attr.path().clone(),\n-                ));\n+        let unresolved_attr =\n+            self.unresolved_macros.iter().enumerate().find_map(|(idx, directive)| match &directive\n+                .kind\n+            {\n+                MacroDirectiveKind::Attr { ast_id, mod_item, attr, tree } => {\n+                    self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                        directive.module_id,\n+                        MacroCallKind::Attr {\n+                            ast_id: ast_id.ast_id,\n+                            attr_args: Default::default(),\n+                            invoc_attr_index: attr.id.ast_index,\n+                            is_derive: false,\n+                        },\n+                        attr.path().clone(),\n+                    ));\n \n-                self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), attr.id);\n+                    self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), attr.id);\n \n-                let item_tree = tree.item_tree(self.db);\n-                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                    Some((idx, directive, *mod_item, *tree))\n+                }\n+                _ => None,\n+            });\n+\n+        match unresolved_attr {\n+            Some((pos, &MacroDirective { module_id, depth, container, .. }, mod_item, tree_id)) => {\n+                let item_tree = &tree_id.item_tree(self.db);\n+                let mod_dir = self.mod_dirs[&module_id].clone();\n                 ModCollector {\n                     def_collector: self,\n-                    macro_depth: directive.depth,\n-                    module_id: directive.module_id,\n-                    tree_id: *tree,\n-                    item_tree: &item_tree,\n+                    macro_depth: depth,\n+                    module_id,\n+                    tree_id,\n+                    item_tree,\n                     mod_dir,\n                 }\n-                .collect(&[*mod_item], directive.container);\n-                true\n-            } else {\n-                false\n-            }\n-        });\n-\n-        if let Some(pos) = pos {\n-            unresolved_macros.swap_remove(pos);\n-        }\n-\n-        self.unresolved_macros.extend(unresolved_macros);\n+                .collect(&[mod_item], container);\n \n-        if pos.is_some() {\n-            // Continue name resolution with the new data.\n-            ReachedFixedPoint::No\n-        } else {\n-            ReachedFixedPoint::Yes\n+                self.unresolved_macros.swap_remove(pos);\n+                // Continue name resolution with the new data.\n+                ReachedFixedPoint::No\n+            }\n+            None => ReachedFixedPoint::Yes,\n         }\n     }\n \n@@ -722,7 +719,8 @@ impl DefCollector<'_> {\n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n         let mut res = ReachedFixedPoint::Yes;\n         let imports = mem::take(&mut self.unresolved_imports);\n-        let imports = imports\n+\n+        self.unresolved_imports = imports\n             .into_iter()\n             .filter_map(|mut directive| {\n                 directive.status = self.resolve_import(directive.module_id, &directive.import);\n@@ -742,7 +740,6 @@ impl DefCollector<'_> {\n                 }\n             })\n             .collect();\n-        self.unresolved_imports = imports;\n         res\n     }\n \n@@ -1034,7 +1031,7 @@ impl DefCollector<'_> {\n             .glob_imports\n             .get(&module_id)\n             .into_iter()\n-            .flat_map(|v| v.iter())\n+            .flatten()\n             .filter(|(glob_importing_module, _)| {\n                 // we know all resolutions have the same visibility (`vis`), so we\n                 // just need to check that once"}]}